/*! For license information please see index.min.js.LICENSE.txt */
(()=>{var e,t,r,s={1741:()=>{"toJSON"in Error.prototype||Object.defineProperty(Error.prototype,"toJSON",{value:function(){const e={};return Object.getOwnPropertyNames(this).forEach((function(t){"object"==typeof this[t]?"function"!=typeof this[t].toJSON?e[t]=JSON.parse(JSON.stringify(this[t])):e[t]=this[t].toJSON():e[t]=this[t]}),this),e},configurable:!0,writable:!0})},9891:(e,t,r)=>{"use strict";const s=JSON.parse('{"debug":false,"log":{"level":0,"console":false}}');function i(){this._storage=chrome.storage.local,this._data={}}i.prototype.init=function(){const e=this;return new Promise(((t,r)=>{e._storage.get("_passbolt_data",(s=>{void 0!==chrome.runtime.lastError&&null!==chrome.runtime.lastError?r(chrome.runtime.lastError):void 0!==s._passbolt_data&&(e._data=JSON.parse(JSON.stringify(s._passbolt_data))),t()}))}))},i.prototype._store=function(){this._storage.set({_passbolt_data:this._data},(()=>{void 0!==chrome.runtime.lastError&&null!==chrome.runtime.lastError&&console.error(chrome.runtime.lastError.message)}))},i.prototype.getItem=function(e){const t=this._data[e];return void 0===t?null:t},i.prototype.setItem=function(e,t){this._data[e]=t,this._store()},i.prototype.removeItem=function(e,t){void 0===t?delete this._data[e]:delete this._data[e][t],this._store()};const a=new i,o=function(){void 0!==a.getItem("config").debug&&(a.removeItem("config","setupBootstrapRegex"),a.removeItem("config","debug"),a.removeItem("config","log"),a.removeItem("config","baseUrl"),a.removeItem("config","extensionId"))},n=function(e){if(void 0!==s[e])return s[e]},c=function(){const e=a.getItem("config");if(null!==e){for(const t in e)void 0===s[t]&&(s[t]=e[t]);o()}},l=n,u=function(e,t){return"debug"!==e&&(s[e]=t,a.setItem("config",s),!0)},d=function(){for(const e in s)delete s[e];for(const e in s)s[e]=s[e];a.removeItem("config")},p=l("log"),h={error:1,warning:2,info:3,debug:4};let g=[];const y=function(){};y.write=function(e){if(0==p.level||p.level<h[e.level])return;function t(e){return e<10?`0${e}`:e}e.date||(e.date=new Date);const r=t(e.date.getHours()),s=t(e.date.getMinutes()),i=t(e.date.getSeconds()),a=t(e.date.getMilliseconds());if(e.created=`${r}:${s}:${i}:${a}`,g.push(e),p.console){const t=`${e.created} [${e.level}] ${e.message}`;"error"===e.level?console.error(t):"warning"===e.level?console.warn(t):console.log(t)}},y.init=function(){g=[]};const m=y;var w=r(4628);const _=class{constructor(e){if(!e)throw Error("A port is required.");this._listeners={},this._disconnectListeners={},this._port=e,this._port.onMessage.addListener((e=>{this._onMessage(e)})),this._port.onDisconnect.addListener((()=>this._onDisconnect()))}_onDisconnect(){Object.keys(this._disconnectListeners).forEach((e=>{this._disconnectListeners[e]?.apply(),delete this._disconnectListeners[e]}))}_onMessage(e){const t=JSON.parse(e),r=t[0];if(Array.isArray(this._listeners[r])){const e=this._listeners[r];for(let s=0;s<e.length;s++){const i=e[s],a=Array.prototype.slice.call(t,1);i.callback.apply(this,a),i.once&&(this._listeners[r].splice(s,1),0===this._listeners[r].length&&delete this._listeners[r],s--)}}}_addListener(e,t,r){Array.isArray(this._listeners[e])||(this._listeners[e]=[]),this._listeners[e].push({name:e,callback:t,once:r})}on(e,t){this._addListener(e,t,!1)}once(e,t){this._addListener(e,t,!0)}emit(...e){const t=JSON.stringify(e);m.write({level:"debug",message:`Port emit @ message: ${t}`}),this._port.postMessage(t)}async emitQuiet(...e){const t=JSON.stringify(e);this._port.postMessage(t)}request(e,...t){const r=(0,w.A)(),s=[e,r].concat(t);return new Promise(((e,t)=>{this.once(r,((s,...i)=>{"SUCCESS"===s?e.apply(null,i):"ERROR"===s&&t.apply(null,i),delete this._disconnectListeners[r]})),this._disconnectListeners[r]=t,this.emit.apply(this,s)}))}disconnect(){this._port.disconnect()}};var f=r(7946);function v(e){window.portname=e}function S(e){const t=e.split(",")[0].split(":")[1].split(";")[0],r=e.split(",")[1],s=atob(r),i=[];for(let e=0;e<s.length;e+=512){const t=s.slice(e,e+512),r=new Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);const a=new Uint8Array(r);i.push(a)}const a=new Blob(i,{type:t});return self.URL.createObjectURL(a)}function b(e){self.URL.revokeObjectURL(e)}const E=class{constructor(e,t=0){this.tabId=e,this.frameId=t}injectJs(e){0!==e.length&&f.scripting.executeScript({files:e,target:{tabId:this.tabId,frameIds:[this.frameId]},world:"ISOLATED"})}injectCss(e){0!==e.length&&f.scripting.insertCSS({files:e,target:{tabId:this.tabId,frameIds:[this.frameId]}})}injectPortname(e){f.scripting.executeScript({func:v,args:[e],target:{tabId:this.tabId,frameIds:[this.frameId]},world:"ISOLATED"})}async injectBase64UrlToCreateObjectURL(e){const t=await f.scripting.executeScript({func:S,args:[e],target:{tabId:this.tabId,frameIds:[this.frameId]},world:"ISOLATED"});return t[0]?.result}injectURLToRevoke(e){f.scripting.executeScript({func:b,args:[e],target:{tabId:this.tabId,frameIds:[this.frameId]},world:"ISOLATED"})}};const k=class{constructor(){this._locked=!1,this._queue=[]}acquire(){return this._locked?new Promise((e=>this._queue.push(e))):(this._locked=!0,Promise.resolve())}release(){const e=this._queue.shift();e?e():this._locked=!1}};class A{constructor(e,t={}){(t?.clone??!0)&&(e=JSON.parse(JSON.stringify(e))),this._props=e}toDto(){return JSON.parse(JSON.stringify(this))}toJSON(){return this._props}_hasProp(e){if(!e.includes(".")){const t=A._normalizePropName(e);return Object.prototype.hasOwnProperty.call(this._props,t)}try{return this._getPropByPath(e),!0}catch(e){return!1}}_getPropByPath(e){return A._normalizePropName(e).split(".").reduce(((e,t)=>{if(Object.prototype.hasOwnProperty.call(e,t))return e[t];throw new Error}),this._props)}static _normalizePropName(e){return e.replace(/([A-Z])/g,((e,t)=>`_${t.toLowerCase()}`)).replace(/\._/,".").replace(/^_/,"").replace(/^\./,"")}}const T=A;class I extends Error{constructor(e="Entity validation error."){super(e),this.name="EntityValidationError",this.details={}}addError(e,t,r){if("string"!=typeof e)throw new TypeError("EntityValidationError addError property should be a string.");if("string"!=typeof t)throw new TypeError("EntityValidationError addError rule should be a string.");if("string"!=typeof r)throw new TypeError("EntityValidationError addError message should be a string.");Object.prototype.hasOwnProperty.call(this.details,e)||(this.details[e]={}),this.details[e][t]=r}getError(e,t){if(!this.hasError(e,t))return null;const r=this.details[e];return t?r[t]:r}hasError(e,t){if("string"!=typeof e)throw new TypeError("EntityValidationError hasError property should be a string.");const r=this.details&&Object.prototype.hasOwnProperty.call(this.details,e);if(!r)return!1;if(!t)return r;if("string"!=typeof t)throw new TypeError("EntityValidationError hasError rule should be a string.");return Object.prototype.hasOwnProperty.call(this.details[e],t)}hasErrors(){return Object.keys(this.details).length>0}getFirstRuleErrorByField(e){if(!this.hasError(e))return null;const t=this.details[e];return t[Object.keys(t)[0]]}}const R=I;var C=r(7761),O=r.n(C);class x extends Error{constructor(e="Collection validation error."){super(e),this.name="CollectionValidationError",this.errors=[]}addItemValidationError(e,t){if(!Number.isInteger(e))throw new TypeError('CollectionValidationError::addEntityValidationError expects "position" to be an integer.');if(!(t instanceof R||t instanceof x))throw new TypeError('CollectionValidationError::addEntityValidationError expects "entityValidationError" to be an instance of EntityValidationError or CollectionValidationError.');this.errors[e]=t}addCollectionValidationError(e,t){if("string"!=typeof e)throw new TypeError('CollectionValidationError::addCollectionValidationError expects "rule" to be a string.');if("string"!=typeof t)throw new TypeError('CollectionValidationError::addCollectionValidationError expects "error" to be a string.');this.errors[e]=t}get details(){const e={};for(const t in this.errors)this.errors[t]instanceof R||this.errors[t]instanceof x?e[t]=this.errors[t].details:e[t]=this.errors[t];return e}}const P=x;class N{static validateSchema(e,t){if(!t)throw new TypeError(`Could not validate entity ${e}. No schema for entity ${e}.`);if(!t.type)throw new TypeError(`Could not validate entity ${e}. Type missing.`);if("array"!==t.type){if("object"===t.type){if(!t.required||!Array.isArray(t.required))throw new TypeError(`Could not validate entity ${e}. Schema error: no required properties.`);if(!t.properties||!Object.keys(t).length)throw new TypeError(`Could not validate entity ${e}. Schema error: no properties.`);const r=t.properties;for(const e in r){if(!Object.prototype.hasOwnProperty.call(r,e)||!r[e].type&&!r[e].anyOf)throw TypeError(`Invalid schema. Type missing for ${e}...`);if(r[e].anyOf&&(!Array.isArray(r[e].anyOf)||!r[e].anyOf.length))throw new TypeError(`Invalid schema, prop ${e} anyOf should be an array`)}}}else if(!t.items)throw new TypeError(`Could not validate entity ${e}. Schema error: missing item definition.`)}static validate(e,t,r){if(!e||!t||!r)throw new TypeError(`Could not validate entity ${e}. No data provided.`);switch(r.type){case"object":return N.validateObject(e,t,r);case"array":return N.validateArray(e,t,r);default:throw new TypeError(`Could not validate entity ${e}. Unsupported type.`)}}static validateArray(e,t,r){let s;const i=N.validateProp("items",t,r);if("number"==typeof r.minItems&&(N.isGreaterThanOrEqual(t.length,r.minItems)||(s=N.handleCollectionValidationError("minItems",`The items array should contain at least ${r.minItems} item(s).`,s))),s)throw s;return i}static validateObject(e,t,r){const s=r.required,i=r.properties,a={};let o;for(const r in i)if(Object.prototype.hasOwnProperty.call(i,r))if(null!==t?.[r]||!0!==i[r]?.nullable){if(s.includes(r)){if(!Object.prototype.hasOwnProperty.call(t,r)){o=N.getOrInitEntityValidationError(e,o),o.addError(r,"required",`The ${r} is required.`);continue}}else if(!Object.prototype.hasOwnProperty.call(t,r))continue;try{a[r]=N.validateProp(r,t[r],i[r])}catch(t){if(!(t instanceof R))throw t;o=N.getOrInitEntityValidationError(e,o),o.details[r]=t.details[r]}}else a[r]=null;if(o)throw o;return a}static getOrInitEntityValidationError(e,t){return t||new R(`Could not validate entity ${e}.`)}static validateProp(e,t,r){if(r.anyOf)return N.validateAnyOf(e,t,r.anyOf),t;if(N.validatePropType(e,t,r),r.enum)return N.validatePropEnum(e,t,r),t;switch(r.type){case"string":N.validatePropTypeString(e,t,r);break;case"integer":case"number":N.validatePropTypeNumber(e,t,r);break;case"array":N.validatePropTypeArray(e,t,r);break;case"object":case"boolean":case"blob":case"null":break;case"x-custom":N.validatePropCustom(e,t,r);break;default:throw new TypeError(`Could not validate property ${e}. Unsupported prop type ${r.type}`)}return t}static validatePropType(e,t,r){if(!N.isValidPropType(t,r.type))throw N.handlePropertyValidationError(e,"type",`The ${e} is not a valid ${r.type}.`)}static validatePropCustom(e,t,r){try{r.validationCallback(t)}catch(t){throw N.handlePropertyValidationError(e,"custom",`The ${e} is not valid: ${t.message}`)}}static validatePropTypeString(e,t,r){let s;if(r.format&&(N.isValidStringFormat(t,r.format)||(s=N.handlePropertyValidationError(e,"format",`The ${e} is not a valid ${r.format}.`,s))),r.notEmpty&&(N.isValidStringNotEmpty(t)||(s=N.handlePropertyValidationError(e,"notEmpty",`The ${e} should be not empty`,s))),r.length&&(N.isValidStringLength(t,r.length,r.length)||(s=N.handlePropertyValidationError(e,"length",`The ${e} should be ${r.length} character in length.`,s))),r.minLength&&(N.isValidStringLength(t,r.minLength)||(s=N.handlePropertyValidationError(e,"minLength",`The ${e} should be ${r.minLength} character in length minimum.`,s))),r.maxLength&&(N.isValidStringLength(t,0,r.maxLength)||(s=N.handlePropertyValidationError(e,"maxLength",`The ${e} should be ${r.maxLength} character in length maximum.`,s))),r.pattern&&(O().matches(t,r.pattern)||(s=N.handlePropertyValidationError(e,"pattern",`The ${e} is not valid.`,s))),r.custom&&(r.custom(t)||(s=N.handlePropertyValidationError(e,"custom",`The ${e} is not valid.`,s))),s)throw s}static handlePropertyValidationError(e,t,r,s=null){return(s=s||new R(`Could not validate property ${e}.`)).addError(e,t,r),s}static handleCollectionValidationError(e,t,r=null){return(r=r||new P("Could not validate collection.")).addCollectionValidationError(e,t),r}static validatePropTypeNumber(e,t,r){let s;if("number"==typeof r.minimum&&(N.isGreaterThanOrEqual(t,r.minimum)||(s=N.handlePropertyValidationError(e,"minimum",`The ${e} should be greater or equal to ${r.minimum}.`,s))),"number"==typeof r.maximum&&(N.isLesserThanOrEqual(t,r.maximum)||(s=N.handlePropertyValidationError(e,"maximum",`The ${e} should be lesser or equal to ${r.maximum}.`,s))),s)throw s}static validatePropTypeArray(e,t,r){let s;if(r?.items&&"object"==typeof r.items){for(let i=0;i<t.length;i++){const a=`${e}.${i}`;try{this.validateProp(a,t[i],r.items)}catch(t){if(!(t instanceof R))throw t;{s=N.getOrInitEntityValidationError(e,s);const r=t.details[a];s.details[e]={...s.details[e],[i]:r}}}}if(s)throw s}}static validatePropEnum(e,t,r){if(!N.isPropInEnum(t,r.enum)){const t=new R(`Could not validate property ${e}.`);throw t.addError(e,"enum",`The ${e} value is not included in the supported list.`),t}}static validateAnyOf(e,t,r){for(let s=0;s<r.length;s++)try{return void N.validateProp(e,t,r[s])}catch(e){}const s=new R(`Could not validate property ${e}.`);throw s.addError(e,"type",`The ${e} does not match any of the supported types.`),s}static isValidPropType(e,t){if(Array.isArray(t))throw new TypeError("EntitySchema isValidPropType multiple types are not supported.");if("string"!=typeof t)throw new TypeError("EntitySchema isValidPropType type is invalid.");switch(t){case"null":return null===e;case"boolean":return"boolean"==typeof e;case"string":return"string"==typeof e;case"integer":return Number.isInteger(e);case"number":return"number"==typeof e;case"object":return"object"==typeof e;case"array":return Array.isArray(e);case"blob":return e instanceof Blob;case"x-custom":return!0;default:throw new TypeError("EntitySchema validation type not supported.")}}static isValidStringFormat(e,t){if("string"!=typeof t)throw new TypeError("EntitySchema validPropFormat format is invalid.");switch(t){case"uuid":return O().isUUID(e);case"email":case"idn-email":return O().isEmail(e);case"date-time":return O().isISO8601(e);case"x-url":return O().isURL(e,{require_tld:!1});case"x-hex-color":return O().isHexColor(e);case"x-base64":return O().isBase64(e);default:throw new TypeError(`EntitySchema string validation format ${t} is not supported.`)}}static isValidStringNotEmpty(e){return!O().isEmpty(e,{ignore_whitespace:!0})}static isValidStringLength(e,t,r){return t=t||0,O().isLength(e,t,r)}static isPropInEnum(e,t){if(!t||!Array.isArray(t)||!t.length)throw new TypeError("EntitySchema enum schema cannot be empty.");return t.includes(e)}static isGreaterThanOrEqual(e,t){return e>=t}static isLesserThanOrEqual(e,t){return e<=t}}const U=N,D="waiting_connection",M="connected",L="reconnecting";class F extends T{constructor(e,t={}){super(U.validate(F.ENTITY_NAME,e,F.getSchema()),t)}static getSchema(){return{type:"object",required:["id","tabId","name","status"],properties:{id:{type:"string",format:"uuid"},tabId:{type:"integer"},frameId:{type:"integer",nullable:!0},name:{type:"string"},status:{type:"string",enum:[this.STATUS_WAITING_CONNECTION,this.STATUS_CONNECTED,this.STATUS_RECONNECTING]}}}}get id(){return this._props.id}get tabId(){return this._props.tabId}get frameId(){return void 0!==this._props.frameId?this._props.frameId:null}get name(){return this._props.name}get status(){return this._props.status}set frameId(e){this._props.frameId=e}set status(e){const t=F.getSchema().properties.status;this._props.status=U.validateProp("status",e,t)}get isWaitingConnection(){return this.status===D}get isConnected(){return this.status===M}get isReconnecting(){return this.status===L}static get ENTITY_NAME(){return"Worker"}static get STATUS_WAITING_CONNECTION(){return D}static get STATUS_CONNECTED(){return M}static get STATUS_RECONNECTING(){return L}}const q=F;var K=r(7946);const B=new k;const j=new class{async getWorkers(){const{workers:e}=await K.storage.session.get("workers");return e||[]}getWorkerById(e){if(!O().isUUID(e))throw new TypeError("The worker id should be a valid uuid.");return this.getWorkers().then((t=>t.find((t=>t.id===e))))}getWorkersByTabId(e){return this.getWorkers().then((t=>t.filter((t=>t.tabId===e))))}getWorkersByNames(e){return this.getWorkers().then((t=>t.filter((t=>e.includes(t.name)))))}getWorkersByNameAndTabId(e,t){return this.getWorkers().then((r=>r.filter((r=>r.name===e&&r.tabId===t))))}async getWorkerOnMainFrame(e){return(await this.getWorkersByTabId(e)).find((e=>0===e.frameId))}async addWorker(e){await B.acquire();try{this.assertEntityBeforeSave(e);const t=await this.getWorkers();if(this.IsExceedNumberWorkersByTabId(t,e.tabId))throw new Error(`The extension port limit is exceeded on tab ${e.tabId}`);t.push(e.toDto()),await K.storage.session.set({workers:t})}finally{B.release()}}IsExceedNumberWorkersByTabId(e,t,r=100){return e.filter((e=>e.tabId===t)).length>=r}async updateWorker(e){await B.acquire();try{this.assertEntityBeforeSave(e);const t=await this.getWorkers(),r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The worker could not be found in the session storage");t[r]=e.toDto(),await K.storage.session.set({workers:t})}finally{B.release()}}async deleteByTabId(e){await B.acquire();try{const t=await this.getWorkers(),r=t=>t.tabId!==e,s=t.filter(r);await K.storage.session.set({workers:s})}finally{B.release()}}async deleteById(e){if(!O().isUUID(e))throw new TypeError("The worker id should be a valid uuid.");await B.acquire();try{const t=await this.getWorkers(),r=t=>t.id!==e,s=t.filter(r);await K.storage.session.set({workers:s})}finally{B.release()}}async flush(){const e=[];await B.acquire();try{await K.storage.session.set({workers:e})}finally{B.release()}}assertEntityBeforeSave(e){if(!e)throw new TypeError("WorkerSessionStorage expects a WorkerEntity to be set");if(!(e instanceof q))throw new TypeError("WorkerSessionStorage expects an object of type WorkerEntity")}};const z=class{static get TOP_FRAME_ID(){return 0}get contentStyleFiles(){return[]}get contentScriptFiles(){return[]}get appName(){return""}get events(){return[]}get mustReloadOnExtensionUpdate(){return!1}async canBeAttachedTo(e){return console.debug(`The pagemod "${this.appName}" should implement canBeAttachedTo. Default false.`),!1}async injectFiles(e,t){const r={id:(0,w.A)(),name:this.appName,tabId:e,frameId:t,status:q.STATUS_WAITING_CONNECTION};await j.addWorker(new q(r));const s=new E(e,t);s.injectPortname(r.id),s.injectCss(this.contentStyleFiles),s.injectJs(this.contentScriptFiles)}async attachEvents(e){const t=e._port.sender.tab;for(const r of this.events)await r.listen({port:e,tab:t,name:this.appName})}};const $=class{static parse(e){const t=e.match(this.getRegex());if(!t)throw new Error("The url does not match the pattern.");let[,r]=t;const[,,,s,i]=t;r=r.replace(/\/*$/g,"");try{new URL(r)}catch(e){throw new Error("The domain is not valid.")}return{domain:r,user_id:s,authentication_token_token:i}}static getRegex(){const e="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}";return new RegExp(`(.*)/(setup/recover|setup/recover/start)/(${e})/(${e})`)}static test(e){try{return this.parse(e),!0}catch(e){return!1}}},V={RecoverBootstrap:["Recover"],SetupBootstrap:["Setup","FileIframe"],AuthBootstrap:["Auth"],AppBootstrap:["App","FileIframe"],AccountRecoveryBootstrap:["AccountRecovery","FileIframe"],WebIntegration:["InFormCallToAction","InFormMenu"]};const Y=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if("string"!=typeof e)throw new Error("The application name should be a string");if(!this.isAllowedToGeneratePortId(this.worker.name,e))throw new Error(`The application is not allowed to open the application ${e}`);const t=this.worker.tab,r={id:(0,w.A)(),name:e,tabId:t.id,frameId:null,status:q.STATUS_WAITING_CONNECTION};return await j.addWorker(new q(r)),r.id}isAllowedToGeneratePortId(e,t){return V[e]?.includes(t)}},G={listen:function(e){e.port.on("passbolt.port.generate-id",(async(t,r)=>{const s=new Y(e,t);await s._exec(r)}))}};const W=new class extends z{get appName(){return"RecoverBootstrap"}get contentStyleFiles(){return["webAccessibleResources/css/themes/default/ext_external.min.css"]}get contentScriptFiles(){return["contentScripts/js/dist/vendors.js","contentScripts/js/dist/recover.js"]}get events(){return[G]}get mustReloadOnExtensionUpdate(){return!0}async canBeAttachedTo(e){return this.assertTopFrameAttachConstraint(e)&&this.assertUrlAttachConstraint(e)}assertTopFrameAttachConstraint(e){return e.frameId===z.TOP_FRAME_ID}assertUrlAttachConstraint(e){return $.test(e.url)}};const H=class{isValid(){try{this.getSecurityToken(),this.getDomain()}catch(e){return!1}return!0}validateField(e,t){switch(e){case"securityToken":this.validateSecurityToken(t);break;case"domain":this.validateDomain(t);break;case"theme":this.validateTheme(t);break;case"locale":this.validateLocale(t);break;default:throw new Error(`No validation defined for field: ${e}.`)}}validateSecurityToken(e){if(void 0===e)throw Error("A token cannot be empty.");if(void 0===e.code||""===e.code)throw Error("A token code cannot be empty.");if(!O().isAscii(e.code))throw new Error("The token code should only contain ASCII characters.");if(!O().isLength(e.code,3,3))throw Error("The token code should only contain 3 characters.");if(void 0===e.color||""===e.color)throw Error("The token color cannot be empty.");if(!O().isHexColor(e.color))throw Error(`This is not a valid token color: ${e.color}.`);if(void 0===e.textcolor||""===e.textcolor)throw Error("The token text color cannot be empty.");if(!O().isHexColor(e.textcolor))throw Error(`This is not a valid token text color: ${e.textcolor}.`);return!0}validateDomain(e){if(void 0===e||""===e)throw new Error("A domain cannot be empty");if(!O().isURL(e,{require_tld:!1}))throw new Error("The trusted domain url is not valid.")}validateTheme(e){if(-1===["default","midgar","solarized_light","solarized_dark"].indexOf(e))throw new Error("The theme is not valid.")}validateLocale(e){const t=new RegExp("^[a-z]{2}-[A-Z]{2}$");if(!e.match(t))throw new Error("The locale is not valid.")}validate(e,t){void 0===t&&(t=["securityToken","domain"]);const r=[];for(const s in t){const i=t[s];try{this.validateField(i,e[i])}catch(e){const t={};t[i]=e.message,r.push(t)}}if(r.length>0){const e=new Error("settings could not be validated");throw e.validationErrors=r,e}return e}getSecurityToken(){const e={};if(e.code=l("user.settings.securityToken.code"),e.color=l("user.settings.securityToken.color"),e.textcolor=l("user.settings.securityToken.textColor"),void 0===e.code||void 0===e.color||void 0===e.textcolor)throw new Error("Security token is not set");return e}setSecurityToken(e){return this.validateSecurityToken(e),u("user.settings.securityToken.code",e.code),u("user.settings.securityToken.color",e.color),u("user.settings.securityToken.textColor",e.textcolor),!0}setDomain(e){return this.validateDomain(e),u("user.settings.trustedDomain",e)}getDomain(){const e=l("user.settings.trustedDomain");if(void 0===e)throw new Error("Trusted domain is not set");return e}setTheme(e){return this.validateTheme(e),u("user.settings.theme",e)}getTheme(){const e=l("user.settings.theme");if(void 0===e)throw new Error("The user has no selected themes.");return e}async setLocale(e){return this.validateLocale(e),u("user.settings.locale",e)}getLocale(){const e=l("user.settings.locale");if(void 0===e)throw new Error("The user has no locale language.");return e}get(e){const t={};return void 0===e&&(e=["domain","securityToken"]),-1!==e.indexOf("domain")&&(t.domain=this.getDomain()),-1!==e.indexOf("securityToken")&&(t.securityToken=this.getSecurityToken()),t}set(e){if(void 0===e)throw new Error("UserSettings cannot be empty");return this.setSecurityToken(e.securityToken),this.setDomain(e.domain),!0}setDefaults(){this.setTheme("default")}flush(){d()}async sync(){const e="undefined"!=typeof customApiClientFetch?customApiClientFetch:fetch,t=`${this.getDomain()}/account/settings.json?api-version=v2`,r=await e(t,{method:"GET",credentials:"include",headers:{Accept:"application/json","Content-Type":"application/json"}}),s=await r.json();if(!r.ok){let e="Could not synchronize the account settings. The server responded with an error.";throw s.header.msg&&(e+=` ${s.header.msg}`),e+=`(${r.status})`,new Error(e)}if(!s.header)throw new Error("Could not synchronize account settings. The server response header is missing.");if(!s.body)throw new Error("Could not synchronize account settings. The server response body is missing.");let i,a;for(a in s.body)if(i=s.body[a],void 0!==i.property)switch(i.property){case"theme":this.setTheme(i.value);break;case"locale":this.setLocale(i.value);break;default:console.error(`Unknown property ${i.property}`)}return!0}};var J=r(7946);class Z{setBaseUrl(e){if(!e)throw new TypeError("ApiClientOption baseUrl is required.");if("string"==typeof e)try{this.baseUrl=new URL(e)}catch(e){throw new TypeError("ApiClientOption baseUrl is invalid.")}else{if(!(e instanceof URL))throw new TypeError("ApiClientOptions baseurl should be a string or URL");this.baseUrl=e}return this}setResourceName(e){if(!e)throw new TypeError("ApiClientOptions.setResourceName resourceName is required.");if("string"!=typeof e)throw new TypeError("ApiClientOptions.setResourceName resourceName should be a valid string.");return this.resourceName=e,this}getBaseUrl(){return this.baseUrl}getResourceName(){return this.resourceName}async getHeaders(){const e=await this.getCsrfToken();if(e)return{"X-CSRF-Token":e}}async getCsrfToken(){if(void 0===J||void 0===J.cookies){const e=document?.cookie?.split("; ")?.find((e=>e.startsWith("csrfToken")))?.split("=");return e&&2===e.length?e[1]:null}const e=this.baseUrl.toString(),t="/"===e.slice(-1)?e:`${e}/`,r=await J.cookies.get({name:"csrfToken",url:t});return r?.value||null}}const Q=function(e){return"string"==typeof e&&!/[\u{10000}-\u{10FFFF}]/u.test(e)},X=function(e){return"string"==typeof e};var ee=r(7946);const te=function(){this.settings=new H,this._user={},this._csrfToken=null,this.validate=function(e,t){void 0===t&&(t=["id","username","firstname","lastname"]);const r=[];for(const s in t){const i=t[s];try{this.__validate(i,e[i])}catch(e){const t={};t[i]=e.message,r.push(t)}}if(r.length>0){const e=new Error("user could not be validated");throw e.validationErrors=r,e}return e},this.__validate=function(e,t){switch(e){case"firstname":if(void 0===t||""===t)throw new Error("The first name cannot be empty");if(!Q(t))throw new Error("The first name should be a valid UTF8 string");if(!O().isLength(t,0,255))throw new Error("The first name length should be maximum 255 characters.");break;case"lastname":if(void 0===t||""===t)throw new Error("The last name cannot be empty");if(!Q(t))throw new Error("The last name should be a valid UTF8 string");if(!O().isLength(t,0,255))throw new Error("The last name length should be maximum 255 characters.");break;case"username":if(void 0===t||""===t)throw new Error("The username cannot be empty");if(!Q(t))throw new Error("The username should be a valid email address");if(!O().isLength(t,0,255))throw new Error("The username length should be maximum 255 characters.");break;case"id":if(void 0===t||""===t)throw new Error("The user id cannot be empty");if(!O().isUUID(t))throw new Error("The user id should be a valid UUID");break;default:throw new Error(`No validation defined for field: ${e}`)}return!0},this.setName=function(e,t){return this.__validate("firstname",e),this.__validate("lastname",t),this._user.lastname=t,this._user.firstname=e,u("user.firstname",e)&&u("user.lastname",t)},this.setUsername=function(e){return this.__validate("username",e),this._user.username=e,u("user.username",e)},this.setId=function(e){return this.__validate("id",e),this._user.id=e,u("user.id",e)},this.set=function(e){if(void 0===e)throw new Error("The user cannot be empty");return this.setId(e.id),this.setUsername(e.username),this.setName(e.firstname,e.lastname),void 0!==e.settings&&this.settings.set(e.settings),this._user},this.get=function(e){try{void 0!==e&&void 0!==e.user?this._getLocal(e.user):this._getLocal();const t=this._user;return void 0!==e&&void 0!==e.user&&void 0!==e.settings?t.settings=this.settings.get(e.settings):void 0===e&&(t.settings=this.settings.get()),t}catch(e){throw new Error("The user is not set")}},this._getLocal=function(e){void 0===e&&(e=["id","username","firstname","lastname"]);for(const t in e){const r=e[t];this._user[r]=l(`user.${r}`);try{this.__validate(r,this._user[r])}catch(e){throw this._user[r]={},new Error("The user is not set")}}return this._user},this.isValid=function(){try{this.get()}catch(e){return!1}return this.settings.isValid()},this.retrieveAndStoreCsrfToken=async function(){const e="/"===this.settings.getDomain().slice(-1)?this.settings.getDomain():`${this.settings.getDomain()}/`,t=await ee.cookies.get({name:"csrfToken",url:e});this.setCsrfToken(t?.value)},this.getCsrfToken=function(){return this._csrfToken},this.getOrFetchCsrfToken=async function(){return this._csrfToken||await this.retrieveAndStoreCsrfToken(),this._csrfToken},this.setCsrfToken=function(e){this._csrfToken=e},this.getApiClientOptions=async function(){return(new Z).setBaseUrl(this.settings.getDomain())},this.updateSecurityToken=async function(e){this.settings.setSecurityToken(e)}},re=function(){let e;return{getInstance:function(){return e||(e=new te),e}}}();const se=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return chrome.runtime.getManifest().version}},ie={listen:function(e){e.port.on("passbolt.config.read",((t,r)=>{e.port.emit(t,"SUCCESS",l(r))})),e.port.on("passbolt.config.readAll",((t,r)=>{const s={};for(const e in r)s[r[e]]=l(r[e]);e.port.emit(t,"SUCCESS",s)})),e.port.on("passbolt.addon.is-configured",(t=>{const r=re.getInstance();e.port.emit(t,"SUCCESS",r.isValid())})),e.port.on("passbolt.addon.check-domain",(t=>{const r=l("user.settings.trustedDomain");void 0!==r&&""!=r||e.port.emit(t,"SUCCESS",!1);const s=e.tab.url.startsWith(r);e.port.emit(t,"SUCCESS",s)})),e.port.on("passbolt.addon.get-domain",(t=>{const r=l("user.settings.trustedDomain");e.port.emit(t,"SUCCESS",r)})),e.port.on("passbolt.addon.get-version",(async t=>{const r=new se(e,t);await r._exec()})),e.port.on("passbolt.addon.get-url",(t=>{e.port.emit(t,"SUCCESS",chrome.runtime.getURL(""))}))}};var ae=r(5604),oe=r(2635),ne=r(1347);let ce;class le{static init(e,t){ce=oe.Ay.createInstance(),ce.use(ne.A).init({lng:e,load:"currentOnly",backend:{loadPath:"/locales/{{lng}}/{{ns}}.json"},supportedLngs:t,fallbackLng:!1,ns:["common"],defaultNS:"common",keySeparator:!1,nsSeparator:!1,debug:!1})}static initWithDefaultLocale(){const e="en-UK",t=[e];le.init(e,t)}static t(){return ce||le.initWithDefaultLocale(),ce.t.apply(ce,arguments)}}const ue=le;const de=class{static fromHex(e){const t=new Uint8Array(e.length>>1);for(let r=0;r<e.length>>1;r++)t[r]=parseInt(e.substr(r<<1,2),16);return t}static toHex(e){const t=[],r=e.length;let s,i=0;for(;i<r;){for(s=e[i++].toString(16);s.length<2;)s=`0${s}`;t.push(`${s}`)}return t.join("").toUpperCase()}},pe=/[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,he=(e,t="The given parameter is not a valid UUID")=>{if(!pe.test(e))throw new Error(t)},ge=e=>{if(!O().isBase64(e))throw new Error("The given parameter is not a valid base64 string")},ye=e=>{if(!X(e))throw new Error("The given parameter should be a valid UTF8 string.")},me=e=>{if(!(e instanceof CryptoKey))throw new Error("The given parameter is not a CryptoKey");const t=e.algorithm;if("AES-GCM"!==t.name)throw new Error("The given key should use the algorithm 'AES-GCM'");if(t.length<256)throw new Error("The given key length should be of 256 bits");const r=e.usages;if(!(2===r.length&&r.includes("encrypt")&&r.includes("decrypt")))throw new Error("The given key should be usable for encryption and decryption only")},we=e=>{if(me(e),e.extractable)throw new Error("The given key should not be extractable")},_e=e=>{if(me(e),!e.extractable)throw new Error("The given key should be extractable")},fe=e=>{if(!(e instanceof Uint8Array))throw new Error("The given initialisation vector should be a Uint8Array");if(12!==e.length)throw new Error("The initialisation vector should be 12 bytes long")},ve=(e,t="The given parameter is not a valid string")=>{if("string"!=typeof e&&!(e instanceof String))throw new Error(t)},Se=(e,t="The given parameter should be a non empty string")=>{if(ve(e,t),!e.length)throw new TypeError(t)},be=(e,t,r="The given data is not of the expected type")=>{if(!(e instanceof t))throw new TypeError(r)},Ee=(e,t,r="The given data is not of any of the expected type")=>{for(let r=0;r<t.length;r++)if(e instanceof t[r])return;throw new TypeError(r)},ke=(e,t="The given parameter is not a valid boolean")=>{if(void 0!==e&&"boolean"!=typeof e)throw new TypeError(t)},Ae=(e,t="The given parameter is not a valid array")=>{if(!Array.isArray(e))throw new TypeError(t)},Te=(e,t="The given parameter is not a valid non empty array")=>{if(!Array.isArray(e)||0===e.length)throw new TypeError(t)},Ie=(e,t="The given parameter is not a valid array of uuid")=>{try{Ae(e),e.forEach((e=>he(e)))}catch(e){throw new TypeError(t,{cause:e})}},Re=(e,t="The given parameter is not a valid number")=>{if(void 0!==e&&"number"!=typeof e)throw new TypeError(t)},Ce=async e=>{if("string"!=typeof e)throw new Error(ue.t("The key should be a valid openpgp armored key string."));try{return await ae.YZ({armoredKey:e})}catch(e){throw new Error(ue.t("The key should be a valid openpgp armored key string."))}},Oe=e=>{if(!(e instanceof ae.J3||e instanceof ae.ZD))throw new Error(ue.t("The key should be a valid openpgp key."))},xe=e=>{if(!(e instanceof ae.J3)||e instanceof ae.J3&&e.isPrivate())throw new Error(ue.t("The key should be a valid openpgp public key."))},Pe=e=>{if(!(e instanceof ae.ZD)||e instanceof ae.ZD&&!e.isPrivate())throw new Error(ue.t("The key should be a valid openpgp private key."))},Ne=e=>{if(Pe(e),!e.isDecrypted())throw new Error(ue.t("The private key should be decrypted."))},Ue=e=>{if(Pe(e),e.isDecrypted())throw new Error(ue.t("The private key should be encrypted."))},De=e=>{if(!(e instanceof ae.QB))throw new Error(ue.t("The message should be a valid openpgp message."))},Me=De,Le=e=>{if(!(e instanceof ae.wN))throw new Error(ue.t("The message should be a valid openpgp clear text message."))},Fe=e=>{De(e);const t=e.packets.findPacket(ae.vP.packet.publicKeyEncryptedSessionKey);if(!t)throw new Error(ue.t("The message should contain at least one session key."));if(null!==t.encrypted)throw new Error(ue.t("The message should be decrypted."))},qe=Ue,Ke=e=>{if(!Array.isArray(e))throw new Error(ue.t("The keys should be an array of valid decrypted openpgp private keys."));for(let t=0;t<e.length;t++)Ne(e[t])},Be=Ne,je=Pe,ze=xe,$e=e=>{if("[object Object]"!==Object.prototype.toString.call(e))throw new Error("The session keys should be an object.");if(!(e.data instanceof Uint8Array)||"aes256"!==e.algorithm)throw new Error("The session keys should be a valid openpgp session key aes256.")},Ve=e=>{if(!Array.isArray(e))throw new Error(ue.t("The keys should be an array."));for(let t=0;t<e.length;t++)Oe(e[t])},Ye=Oe,Ge=async e=>{if("string"!=typeof e)throw new Error(ue.t("The message should be of type string."));try{return await ae._8({armoredMessage:e})}catch(e){throw new Error(ue.t("The message should be a valid openpgp message."))}},We=async e=>{if("string"!=typeof e)throw new Error(ue.t("The message should be of type string."));return ae.w7({text:e})},He=async e=>{if("string"!=typeof e)throw new Error(ue.t("The message should be of type string."));return ae.oH({text:e,format:"utf8"})},Je=Ce,Ze=e=>{if(Se(e,"The session key should be a string."),!/^\d{1,2}:[0-9A-F]{64}$/i.test(e))throw new TypeError('The parameter session key does not match the expected format "integer:hexadecimal-string".');try{const t=e.split(":"),r=ae.vP.read(ae.vP.symmetric,t[0]);return{data:de.fromHex(t[1]),algorithm:r}}catch(e){throw new Error("The session key should be a valid openpgp session key.",{cause:e})}};var Qe=r(2885),Xe=r(3050),et=r.n(Xe);const tt=class{static randomValuesArray(e){const t=new Uint8Array(e);return self.crypto.getRandomValues(t),t}};const rt=function(e){let t;if(void 0===e)t=function(e){let t,r="";const s="ABCDEF0123456789",i=tt.randomValuesArray(e);for(t=e;t>0;t--)r+=s.charAt(Math.floor(i[t]%16));return r}(32);else{const r=new Qe.A("SHA-1","TEXT");r.update(e),t=r.getHash("HEX").substring(0,32)}const r=et()("^(?<first>.{8})(?<second>.{4})(?<third>.{1})(?<fourth>.{3})(?<fifth>.{1})(?<sixth>.{3})(?<seventh>.{12}$)"),s=et()("${first}-${second}-3${fourth}-a${sixth}-${seventh}");return et().replace(t,r,s).replace(/\//g,"")};class st extends Error{constructor(e,t){super(e),this.name="PassboltApiFetchError",this.data=t||{}}}const it=st;class at extends Error{constructor(){super("An internal error occurred. The server response could not be parsed. Please contact your administrator."),this.name="PassboltBadResponseError"}}const ot=at;class nt extends Error{constructor(e){super(e=e||"The service is unavailable"),this.name="PassboltServiceUnavailableError"}}const ct=nt,lt=["GET","POST","PUT","DELETE"];class ut{constructor(e){if(this.options=e,!this.options.getBaseUrl())throw new TypeError("ApiClient constructor error: baseUrl is required.");if(!this.options.getResourceName())throw new TypeError("ApiClient constructor error: resourceName is required.");try{let e=this.options.getBaseUrl().toString();e.endsWith("/")&&(e=e.slice(0,-1));let t=this.options.getResourceName();t.startsWith("/")&&(t=t.slice(1)),t.endsWith("/")&&(t=t.slice(0,-1)),this.baseUrl=`${e}/${t}`,this.baseUrl=new URL(this.baseUrl)}catch(e){throw new TypeError("ApiClient constructor error: b.")}this.apiVersion="api-version=v2"}getDefaultHeaders(){return{Accept:"application/json","content-type":"application/json"}}async buildFetchOptions(){const e=await this.options.getHeaders();return{credentials:"include",headers:{...this.getDefaultHeaders(),...e}}}async get(e,t){this.assertValidId(e);const r=this.buildUrl(`${this.baseUrl}/${e}`,t||{});return this.fetchAndHandleResponse("GET",r)}async delete(e,t,r,s){let i;this.assertValidId(e),void 0===s&&(s=!1),i=s?this.buildUrl(`${this.baseUrl}/${e}/dry-run`,r||{}):this.buildUrl(`${this.baseUrl}/${e}`,r||{});let a=null;return t&&(a=this.buildBody(t)),this.fetchAndHandleResponse("DELETE",i,a)}async findAll(e){const t=this.buildUrl(this.baseUrl.toString(),e||{});return this.fetchAndHandleResponse("GET",t)}async create(e,t){const r=this.buildUrl(this.baseUrl.toString(),t||{}),s=this.buildBody(e);return this.fetchAndHandleResponse("POST",r,s)}async update(e,t,r,s){let i;this.assertValidId(e),void 0===s&&(s=!1),i=s?this.buildUrl(`${this.baseUrl}/${e}/dry-run`,r||{}):this.buildUrl(`${this.baseUrl}/${e}`,r||{});let a=null;return t&&(a=this.buildBody(t)),this.fetchAndHandleResponse("PUT",i,a)}async updateAll(e,t={}){const r=this.buildUrl(this.baseUrl.toString(),t),s=e?this.buildBody(e):null;return this.fetchAndHandleResponse("PUT",r,s)}assertValidId(e){if(!e)throw new TypeError("ApiClient.assertValidId error: id cannot be empty");if("string"!=typeof e)throw new TypeError("ApiClient.assertValidId error: id should be a string")}assertMethod(e){if("string"!=typeof e)throw new TypeError("ApiClient.assertValidMethod method should be a string.");if(lt.indexOf(e.toUpperCase())<0)throw new TypeError(`ApiClient.assertValidMethod error: method ${e} is not supported.`)}assertUrl(e){if(!e)throw new TypeError("ApliClient.assertUrl error: url is required.");if(!(e instanceof URL))throw new TypeError("ApliClient.assertUrl error: url should be a valid URL object.");if("https:"!==e.protocol&&"http:"!==e.protocol)throw new TypeError("ApliClient.assertUrl error: url protocol should only be https or http.")}assertBody(e){if(!(e instanceof FormData)&&"string"!=typeof e)throw new TypeError("ApiClient.assertBody error: body should be a string or a FormData.")}buildBody(e){return JSON.stringify(e)}buildUrl(e,t){if("string"!=typeof e)throw new TypeError("ApiClient.buildUrl error: url should be a string.");const r=new URL(`${e}.json?${this.apiVersion}`);t=t||{};for(const[e,s]of Object.entries(t)){if("string"!=typeof e)throw new TypeError("ApiClient.buildUrl error: urlOptions key should be a string.");if("string"==typeof s)r.searchParams.append(e,s);else{if(!Array.isArray(s))throw new TypeError("ApiClient.buildUrl error: urlOptions value should be a string or array.");s.forEach((t=>{r.searchParams.append(e,t)}))}}return r}async sendRequest(e,t,r,s){this.assertUrl(t),this.assertMethod(e),r&&this.assertBody(r);const i="undefined"!=typeof customApiClientFetch?customApiClientFetch:fetch,a={...await this.buildFetchOptions(),...s};a.method=e,r&&(a.body=r);try{return await i(t.toString(),a)}catch(e){throw console.error(e),navigator.onLine?new ct("Unable to reach the server, an unexpected error occurred"):new ct("Unable to reach the server, you are not connected to the network")}}async fetchAndHandleResponse(e,t,r,s){const i=await this.sendRequest(e,t,r,s);return this.parseResponseJson(i)}async parseResponseJson(e){let t;try{t=await e.json()}catch(t){throw console.debug(e.url.toString(),t),new ot(t,e)}if(!e.ok){const r=t.header.message;throw new it(r,{code:e.status,body:t.body})}return t}}const dt=class{constructor(e,t){e.setResourceName(t),this.apiClient=new ut(e)}formatContainOptions(e,t){const r={};for(const s in e){if("string"!=typeof s){const t=JSON.stringify(e);throw new TypeError(`Invalid contain ${t}, items should be a string.`)}t.includes(s)&&(r[`contain[${s}]`]=e[s]?"1":"0")}return r}formatFilterOptions(e,t){const r={};for(const s in e)if(Object.prototype.hasOwnProperty.call(e,s)&&t.includes(s))if("boolean"==typeof e[s])r[`filter[${s}]`]=e[s]?"1":"0";else if("string"==typeof e[s])r[`filter[${s}]`]=e[s];else{if(!Array.isArray(e[s]))throw new TypeError("Service error. Filter option should be an array or a string.");r[`filter[${s}][]`]=e[s]}return r}formatOrderOptions(e,t){const r={};for(const s in e)t.includes(s)&&(r["order[]"]=s);return r}assertValidId(e){if(!e||"string"!=typeof e||!O().isUUID(e))throw new TypeError(`Service error. The id '${e}' is not a valid uuid.`)}assertNonEmptyData(e){if(!e)throw new TypeError("Service error. Data cannot be empty.")}};class pt extends dt{constructor(e){super(e,pt.RESOURCE_NAME)}static get RESOURCE_NAME(){return"settings"}async find(){const e=await this.apiClient.findAll(),t=JSON.parse(JSON.stringify(e.body));if(t.serverTimeDiff=null,e.header.servertime){const r=new Date;t.serverTimeDiff=1e3*e.header.servertime-r.getTime()}return t}}const ht=pt;class gt extends T{constructor(e,t={}){const r=Object.assign(gt.getDefault(),e),s=gt.sanitizeDto(r);super(U.validate(gt.ENTITY_NAME,s,gt.getSchema()),t)}static getDefault(){return{status:gt.ORGANIZATION_ENABLED}}static getSchema(){return{type:"object",required:[],properties:{status:{type:"string",enum:[gt.ORGANIZATION_ENABLED,gt.ORGANIZATION_DISABLED,gt.ORGANIZATION_NOT_FOUND]},app:{type:"object"},passbolt:{type:"object"},serverTimeDiff:{type:"integer",nullable:!0}}}}static get disabledOrganizationSettings(){return{status:this.ORGANIZATION_DISABLED}}static sanitizeDto(e){const t=JSON.parse(JSON.stringify(e));return gt.sanitizeEmailValidateRegex(t),t}static sanitizeEmailValidateRegex(e){const t=e?.passbolt?.email?.validate?.regex;t&&"string"==typeof t&&t.trim().length&&(e.passbolt.email.validate.regex=t.trim().replace(/^\/+/,"").replace(/\/+$/,""))}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get locale(){return this._props.app&&this._props.app.locale}isPluginEnabled(e){const t=this._props?.passbolt?.plugins?.[e];return t&&!1!==t?.enabled}getPluginSettings(e){if(this.isPluginEnabled(e))return this._props.passbolt.plugins[e]}isServerInPast(){return(this._props.serverTimeDiff||0)<0}get serverTime(){const e=new Date,t=this._props.serverTimeDiff||0;return new Date(e.getTime()+t).getTime()}get emailValidateRegex(){return this._props?.passbolt?.email?.validate?.regex||null}static get ENTITY_NAME(){return"OrganizationSettings"}static get ORGANIZATION_ENABLED(){return"enabled"}static get ORGANIZATION_DISABLED(){return"disabled"}static get ORGANIZATION_NOT_FOUND(){return"not found"}}const yt=gt;let mt;const wt=class{constructor(e){this.organizationSettingsService=new ht(e)}static set(e){if(!(e instanceof yt))throw new Error("The settings should be an instance of OrganizationSettingsEntity");mt=e}static get(){return mt||null}async getOrFind(e=!1){return!e&&mt||(mt=await this.find()),mt}static flushCache(){mt=null}async find(){let e;try{e=await this.organizationSettingsService.find()}catch(t){t instanceof it&&403===t?.data?.code&&(e=yt.disabledOrganizationSettings)}return new yt(e)}};class _t{constructor(e){if("string"!=typeof e)throw Error("The regex should be a string.");this.regex=new(et())(e)}validate(e){return"string"==typeof e&&this.regex.test(e)}}class ft{static validate(e){return"string"==typeof e&&et()("^[\\p{L}0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[\\p{L}0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[_\\p{L}0-9][-_\\p{L}0-9]*\\.)*(?:[\\p{L}0-9][-\\p{L}0-9]{0,62})\\.(?:(?:[a-z]{2}\\.)?[a-z]{2,})$","i").test(e)}}class vt{static validate(e){return vt.getValidator().validate(e)}static getValidator(){const e=wt.get();return e&&e instanceof yt&&e.emailValidateRegex?new _t(e.emailValidateRegex):ft}static hasCustomValidator(){return vt.getValidator!==ft}}class St extends T{constructor(e,t={}){const r=St.sanitizeDto(e);super(U.validate(St.ENTITY_NAME,r,St.getSchema()),t)}static getSchema(){return{type:"object",required:["armored_key"],properties:{armored_key:{type:"string",minLength:1},key_id:{type:"string",minLength:8,maxLength:16},user_ids:{type:"array",items:{type:"object",required:["email","name"],properties:{email:{type:"string",custom:vt.validate},name:{type:"string"}}}},fingerprint:{type:"string",minLength:40,maxLength:40},expires:{anyOf:[{type:"string",format:"date-time"},{type:"string",pattern:"^Infinity$"},{}],nullable:!0},created:{type:"string",format:"date-time"},algorithm:{type:"string"},length:{type:"integer",minimum:1},curve:{type:"string",nullable:!0},private:{type:"boolean"},revoked:{type:"boolean"}}}}static sanitizeDto(e){const t=JSON.parse(JSON.stringify(e));if(e.key&&(t.armored_key=e.key,delete t.key),e.keyId&&(t.key_id=e.keyId,delete t.keyId),e.userIds&&(t.user_ids=e.userIds,delete t.userIds),e.created)try{const e=new Date(t.created);t.created=e.toISOString()}catch(e){delete t.created}if("Never"===e.expires)t.expires="Infinity";else if(e.expires&&"Infinity"!==e.expires)try{const e=new Date(t.expires);t.expires=e.toISOString()}catch(r){delete t.expires,console.error(`ExternalGpgKeyEntity::sanitizeDto Unable to sanitize the key for the user ${e.user_id}`)}return t}get armoredKey(){return this._props.armored_key}get keyId(){return this._props.key_id}get userIds(){return this._props.user_ids}get fingerprint(){return this._props.fingerprint}get expires(){return this._props.expires}get isValid(){return null!==this.expires}get created(){return this._props.created}get algorithm(){return this._props.algorithm}get length(){return this._props.length}get curve(){return this._props.curve}get revoked(){return this._props.revoked}get private(){return this._props.private}get isExpired(){const e=this.expires;if(null===e)return null;if("Infinity"===e)return!1;const t=Date.now();return new Date(e)<t}static get ENTITY_NAME(){return"externalGpgKey"}}const bt=St,Et={string:{}};Et.string.Unicode={NBSP:" "},Et.string.startsWith=function(e,t){return 0==e.lastIndexOf(t,0)},Et.string.endsWith=function(e,t){const r=e.length-t.length;return r>=0&&e.indexOf(t,r)==r},Et.string.caseInsensitiveStartsWith=function(e,t){return 0==Et.string.caseInsensitiveCompare(t,e.substr(0,t.length))},Et.string.caseInsensitiveEndsWith=function(e,t){return 0==Et.string.caseInsensitiveCompare(t,e.substr(e.length-t.length,t.length))},Et.string.subs=function(e,t){for(let t=1;t<arguments.length;t++){const r=String(arguments[t]).replace(/\$/g,"$$$$");e=e.replace(/\%s/,r)}return e},Et.string.collapseWhitespace=function(e){return e.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")},Et.string.isEmpty=function(e){return/^[\s\xa0]*$/.test(e)},Et.string.isEmptySafe=function(e){return Et.string.isEmpty(Et.string.makeSafe(e))},Et.string.isBreakingWhitespace=function(e){return!/[^\t\n\r ]/.test(e)},Et.string.isAlpha=function(e){return!/[^a-zA-Z]/.test(e)},Et.string.isNumeric=function(e){return!/[^0-9]/.test(e)},Et.string.isAlphaNumeric=function(e){return!/[^a-zA-Z0-9]/.test(e)},Et.string.isSpace=function(e){return" "==e},Et.string.isUnicodeChar=function(e){return 1==e.length&&e>=" "&&e<="~"||e>=""&&e<="�"},Et.string.stripNewlines=function(e){return e.replace(/(\r\n|\r|\n)+/g," ")},Et.string.canonicalizeNewlines=function(e){return e.replace(/(\r\n|\r|\n)/g,"\n")},Et.string.normalizeWhitespace=function(e){return e.replace(/\xa0|\s/g," ")},Et.string.normalizeSpaces=function(e){return e.replace(/\xa0|[ \t]+/g," ")},Et.string.collapseBreakingSpaces=function(e){return e.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")},Et.string.trim=function(e){return e.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},Et.string.trimLeft=function(e){return e.replace(/^[\s\xa0]+/,"")},Et.string.trimRight=function(e){return e.replace(/[\s\xa0]+$/,"")},Et.string.caseInsensitiveCompare=function(e,t){const r=String(e).toLowerCase(),s=String(t).toLowerCase();return r<s?-1:r==s?0:1},Et.string.numerateCompareRegExp_=/(\.\d+)|(\d+)|(\D+)/g,Et.string.numerateCompare=function(e,t){if(e==t)return 0;if(!e)return-1;if(!t)return 1;const r=e.toLowerCase().match(Et.string.numerateCompareRegExp_),s=t.toLowerCase().match(Et.string.numerateCompareRegExp_),i=Math.min(r.length,s.length);for(let e=0;e<i;e++){const t=r[e],i=s[e];if(t!=i){const e=parseInt(t,10);if(!isNaN(e)){const t=parseInt(i,10);if(!isNaN(t)&&e-t)return e-t}return t<i?-1:1}}return r.length!=s.length?r.length-s.length:e<t?-1:1},Et.string.urlEncode=function(e){return encodeURIComponent(String(e))},Et.string.urlDecode=function(e){return decodeURIComponent(e.replace(/\+/g," "))},Et.string.newLineToBr=function(e,t){return e.replace(/(\r\n|\r|\n)/g,t?"<br />":"<br>")},Et.string.htmlEscape=function(e,t){return t?e.replace(Et.string.amperRe_,"&amp;").replace(Et.string.ltRe_,"&lt;").replace(Et.string.gtRe_,"&gt;").replace(Et.string.quotRe_,"&quot;"):Et.string.allRe_.test(e)?(-1!=e.indexOf("&")&&(e=e.replace(Et.string.amperRe_,"&amp;")),-1!=e.indexOf("<")&&(e=e.replace(Et.string.ltRe_,"&lt;")),-1!=e.indexOf(">")&&(e=e.replace(Et.string.gtRe_,"&gt;")),-1!=e.indexOf('"')&&(e=e.replace(Et.string.quotRe_,"&quot;")),e):e},Et.string.amperRe_=/&/g,Et.string.ltRe_=/</g,Et.string.gtRe_=/>/g,Et.string.quotRe_=/\"/g,Et.string.allRe_=/[&<>\"]/,Et.string.unescapeEntities=function(e){return Et.string.contains(e,"&")?"document"in Et.global?Et.string.unescapeEntitiesUsingDom_(e):Et.string.unescapePureXmlEntities_(e):e},Et.string.unescapeEntitiesUsingDom_=function(e){const t={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'},r=document.createElement("div");return e.replace(Et.string.HTML_ENTITY_PATTERN_,((e,s)=>{let i=t[e];if(i)return i;if("#"==s.charAt(0)){const e=Number(`0${s.substr(1)}`);isNaN(e)||(i=String.fromCharCode(e))}return i||(r.innerHTML=`${e} `,i=r.firstChild.nodeValue.slice(0,-1)),t[e]=i}))},Et.string.unescapePureXmlEntities_=function(e){return e.replace(/&([^;]+);/g,((e,t)=>{switch(t){case"amp":return"&";case"lt":return"<";case"gt":return">";case"quot":return'"';default:if("#"==t.charAt(0)){const e=Number(`0${t.substr(1)}`);if(!isNaN(e))return String.fromCharCode(e)}return e}}))},Et.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g,Et.string.whitespaceEscape=function(e,t){return Et.string.newLineToBr(e.replace(/ {2}/g," &#160;"),t)},Et.string.stripQuotes=function(e,t){const r=t.length;for(let s=0;s<r;s++){const i=1==r?t:t.charAt(s);if(e.charAt(0)==i&&e.charAt(e.length-1)==i)return e.substring(1,e.length-1)}return e},Et.string.truncate=function(e,t,r){return r&&(e=Et.string.unescapeEntities(e)),e.length>t&&(e=`${e.substring(0,t-3)}...`),r&&(e=Et.string.htmlEscape(e)),e},Et.string.truncateMiddle=function(e,t,r,s){if(r&&(e=Et.string.unescapeEntities(e)),s&&e.length>t){s>t&&(s=t);const r=e.length-s,i=t-s;e=`${e.substring(0,i)}...${e.substring(r)}`}else if(e.length>t){let r=Math.floor(t/2);const s=e.length-r;r+=t%2,e=`${e.substring(0,r)}...${e.substring(s)}`}return r&&(e=Et.string.htmlEscape(e)),e},Et.string.specialEscapeChars_={"\0":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\x0B",'"':'\\"',"\\":"\\\\"},Et.string.jsEscapeCache_={"'":"\\'"},Et.string.quote=function(e){if((e=String(e)).quote)return e.quote();{const t=['"'];for(let r=0;r<e.length;r++){const s=e.charAt(r),i=s.charCodeAt(0);t[r+1]=Et.string.specialEscapeChars_[s]||(i>31&&i<127?s:Et.string.escapeChar(s))}return t.push('"'),t.join("")}},Et.string.escapeString=function(e){const t=[];for(let r=0;r<e.length;r++)t[r]=Et.string.escapeChar(e.charAt(r));return t.join("")},Et.string.escapeChar=function(e){if(e in Et.string.jsEscapeCache_)return Et.string.jsEscapeCache_[e];if(e in Et.string.specialEscapeChars_)return Et.string.jsEscapeCache_[e]=Et.string.specialEscapeChars_[e];let t=e;const r=e.charCodeAt(0);return r>31&&r<127?t=e:(r<256?(t="\\x",(r<16||r>256)&&(t+="0")):(t="\\u",r<4096&&(t+="0")),t+=r.toString(16).toUpperCase()),Et.string.jsEscapeCache_[e]=t},Et.string.toMap=function(e){const t={};for(let r=0;r<e.length;r++)t[e.charAt(r)]=!0;return t},Et.string.contains=function(e,t){return-1!=e.indexOf(t)},Et.string.countOf=function(e,t){return e&&t?e.split(t).length-1:0},Et.string.removeAt=function(e,t,r){let s=e;return t>=0&&t<e.length&&r>0&&(s=e.substr(0,t)+e.substr(t+r,e.length-t-r)),s},Et.string.remove=function(e,t){const r=new RegExp(Et.string.regExpEscape(t),"");return e.replace(r,"")},Et.string.removeAll=function(e,t){const r=new RegExp(Et.string.regExpEscape(t),"g");return e.replace(r,"")},Et.string.regExpEscape=function(e){return String(e).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Et.string.repeat=function(e,t){return new Array(t+1).join(e)},Et.string.padNumber=function(e,t,r){const s=Et.isDef(r)?e.toFixed(r):String(e);let i=s.indexOf(".");return-1==i&&(i=s.length),Et.string.repeat("0",Math.max(0,t-i))+s},Et.string.makeSafe=function(e){return null==e?"":String(e)},Et.string.buildString=function(e){return Array.prototype.join.call(arguments,"")},Et.string.getRandomString=function(){const e=2147483648;return Math.floor(Math.random()*e).toString(36)+Math.abs(Math.floor(Math.random()*e)^Et.now()).toString(36)},Et.string.compareVersions=function(e,t){let r=0;const s=Et.string.trim(String(e)).split("."),i=Et.string.trim(String(t)).split("."),a=Math.max(s.length,i.length);for(let e=0;0==r&&e<a;e++){const t=s[e]||"",a=i[e]||"",o=new RegExp("(\\d*)(\\D*)","g"),n=new RegExp("(\\d*)(\\D*)","g");do{const e=o.exec(t)||["","",""],s=n.exec(a)||["","",""];if(0==e[0].length&&0==s[0].length)break;const i=0==e[1].length?0:parseInt(e[1],10),c=0==s[1].length?0:parseInt(s[1],10);r=Et.string.compareElements_(i,c)||Et.string.compareElements_(0==e[2].length,0==s[2].length)||Et.string.compareElements_(e[2],s[2])}while(0==r)}return r},Et.string.compareElements_=function(e,t){return e<t?-1:e>t?1:0},Et.string.HASHCODE_MAX_=4294967296,Et.string.hashCode=function(e){let t=0;for(let r=0;r<e.length;++r)t=31*t+e.charCodeAt(r),t%=Et.string.HASHCODE_MAX_;return t},Et.string.uniqueStringCounter_=2147483648*Math.random()|0,Et.string.createUniqueString=function(){return"goog_"+Et.string.uniqueStringCounter_++},Et.string.toNumber=function(e){const t=Number(e);return 0==t&&Et.string.isEmpty(e)?NaN:t},Et.string.toCamelCase=function(e){return String(e).replace(/\-([a-z])/g,((e,t)=>t.toUpperCase()))},Et.string.toSelectorCase=function(e){return String(e).replace(/([A-Z])/g,"-$1").toLowerCase()},Et.string.toTitleCase=function(e,t){let r=Et.isString(t)?Et.string.regExpEscape(t):"\\s";r=r?`|[${r}]+`:"";const s=new RegExp(`(^${r})([a-z])`,"g");return e.replace(s,((e,t,r)=>t+r.toUpperCase()))},Et.string.parseInt=function(e){return isFinite(e)&&(e=String(e)),Et.isString(e)?/^\s*-?0x/i.test(e)?parseInt(e,16):parseInt(e,10):NaN};const kt=Et,At={};At.string=kt.string,At.format={},At.format.EmailAddress=function(e,t){this.name_=t||"",this.address_=e||""},At.format.EmailAddress.OPENERS_='"<([',At.format.EmailAddress.CLOSERS_='">)]',At.format.EmailAddress.SPECIAL_CHARS_RE_=/[()<>@,;:\\\".\[\]]/,At.format.EmailAddress.ALL_DOUBLE_QUOTES_=/\"/g,At.format.EmailAddress.ESCAPED_DOUBLE_QUOTES_=/\\\"/g,At.format.EmailAddress.ALL_BACKSLASHES_=/\\/g,At.format.EmailAddress.ESCAPED_BACKSLASHES_=/\\\\/g,At.format.EmailAddress.LOCAL_PART_REGEXP_STR_="[+a-zA-Z0-9_.!#$%&'*\\/=?^`{|}~-]+",At.format.EmailAddress.DOMAIN_PART_REGEXP_STR_="([a-zA-Z0-9-]+\\.)+[a-zA-Z0-9]{2,63}",At.format.EmailAddress.LOCAL_PART_=new RegExp(`^${At.format.EmailAddress.LOCAL_PART_REGEXP_STR_}$`),At.format.EmailAddress.DOMAIN_PART_=new RegExp(`^${At.format.EmailAddress.DOMAIN_PART_REGEXP_STR_}$`),At.format.EmailAddress.EMAIL_ADDRESS_=new RegExp(`^${At.format.EmailAddress.LOCAL_PART_REGEXP_STR_}@${At.format.EmailAddress.DOMAIN_PART_REGEXP_STR_}$`),At.format.EmailAddress.prototype.getName=function(){return this.name_},At.format.EmailAddress.prototype.getAddress=function(){return this.address_},At.format.EmailAddress.prototype.setName=function(e){this.name_=e},At.format.EmailAddress.prototype.setAddress=function(e){this.address_=e},At.format.EmailAddress.prototype.toString=function(){let e=this.getName();e=e.replace(At.format.EmailAddress.ALL_DOUBLE_QUOTES_,"");return At.format.EmailAddress.SPECIAL_CHARS_RE_.test(e)&&(e=`"${e.replace(At.format.EmailAddress.ALL_BACKSLASHES_,"\\\\")}"`),""==e?this.address_:""==this.address_?e:`${e} <${this.address_}>`},At.format.EmailAddress.prototype.isValid=function(){return At.format.EmailAddress.isValidAddrSpec(this.address_)},At.format.EmailAddress.isValidAddress=function(e){return At.format.EmailAddress.parse(e).isValid()},At.format.EmailAddress.isValidAddrSpec=function(e){return At.format.EmailAddress.EMAIL_ADDRESS_.test(e)},At.format.EmailAddress.parse=function(e){let t="",r="";for(let s=0;s<e.length;){const i=At.format.EmailAddress.getToken_(e,s);if("<"==i.charAt(0)&&-1!=i.indexOf(">")){const e=i.indexOf(">");r=i.substring(1,e)}else""==r&&(t+=i);s+=i.length}return""==r&&-1!=t.indexOf("@")&&(r=t,t=""),t=At.string.collapseWhitespace(t),t=At.string.stripQuotes(t,"'"),t=At.string.stripQuotes(t,'"'),t=t.replace(At.format.EmailAddress.ESCAPED_DOUBLE_QUOTES_,'"'),t=t.replace(At.format.EmailAddress.ESCAPED_BACKSLASHES_,"\\"),r=At.string.collapseWhitespace(r),new At.format.EmailAddress(r,t)},At.format.EmailAddress.parseList=function(e){const t=[];let r,s="";for(let i=0;i<e.length;)r=At.format.EmailAddress.getToken_(e,i),","!=r&&";"!=r?(s+=r,i+=r.length):(At.string.isEmpty(s)||t.push(At.format.EmailAddress.parse(s)),s="",i++);return At.string.isEmpty(s)||t.push(At.format.EmailAddress.parse(s)),t},At.format.EmailAddress.getToken_=function(e,t){const r=e.charAt(t),s=At.format.EmailAddress.OPENERS_.indexOf(r);if(-1==s)return r;if(At.format.EmailAddress.isEscapedDlQuote_(e,t))return r;const i=At.format.EmailAddress.CLOSERS_.charAt(s);let a=e.indexOf(i,t+1);for(;a>=0&&At.format.EmailAddress.isEscapedDlQuote_(e,a);)a=e.indexOf(i,a+1);return a>=0?e.substring(t,a+1):r},At.format.EmailAddress.isEscapedDlQuote_=function(e,t){if('"'!=e.charAt(t))return!1;let r=0;for(let s=t-1;s>=0&&"\\"==e.charAt(s);s--)r++;return r%2!=0};const Tt=At;class It extends Error{constructor(e){super(e),this.name="GpgKeyError"}}const Rt=It;const Ct=class{static async getKeyInfo(e){Ye(e);const t=e.getUserIDs(),r=[];if(0===t.length)throw new Rt("No key user ID found");for(const e in t)if(Object.prototype.hasOwnProperty.call(t,e)){const s=Tt.format.EmailAddress.parse(t[e]);r.push({name:s.name_,email:s.address_})}let s,i=e.getKeyID().toHex();i.length>8&&(i=i.substr(i.length-8));const a=await e.getExpirationTime();s=a instanceof Date?a.toISOString():a===1/0?a.toString():null;const o=e.getAlgorithmInfo(),n={armored_key:e.armor(),key_id:i,user_ids:r,fingerprint:e.getFingerprint().toUpperCase(),created:e.getCreationTime().toISOString(),expires:s,algorithm:this.formatAlgorithm(o.algorithm),length:this.getKeyLength(o),curve:o.curve||null,private:e.isPrivate(),revoked:await e.isRevoked()};return new bt(n)}static formatAlgorithm(e){switch(e){case"rsaEncryptSign":case"rsaEncrypt":case"rsaSign":return"rsa";case"elgamal":return"elgamal";case"dsa":return"dsa";case"ecdh":return"ecdh";case"ecdsa":return"ecdsa";case"eddsa":return"eddsa";case"aedh":return"aedh";case"aedsa":return"aedsa";default:throw new Error("Unknown algorithm.")}}static getKeyLength(e){if(void 0!==e.bits)return e.bits;const t=e?.curve.toString().toLowerCase();switch(t){case"p256":case"ed25519":case"secp256k1":case"curve25519":case"brainpoolp256r1":return 256;case"brainpoolp384r1":case"p384":return 384;case"brainpoolp512r1":return 512;case"p521":return 521}}};class Ot{findPublic(e){let t;const r=this.getPublicKeysFromStorage();for(t in r)if(Object.prototype.hasOwnProperty.call(r,t)&&r[t].user_id===e)return new bt(r[t])}findPrivate(){const e=Ot.MY_KEY_ID,t=this.getPrivateKeysFromStorage();return t[e]?new bt(t[e]):void 0}async importPublic(e,t){if(void 0===t)throw new Error("The user id is undefined");if(!O().isUUID(t))throw new Error("The user id is not valid");e=this.findArmoredKeyInText(e,Ot.PUBLIC);const r=await Je(e);ze(r);const s=(await Ct.getKeyInfo(r)).toDto(),i=this.getPublicKeysFromStorage();return i[t]=s,i[t].user_id=t,this.store(Ot.PUBLIC,i),!0}async importPrivate(e){this.flush(Ot.PRIVATE),e=this.findArmoredKeyInText(e,Ot.PRIVATE);const t=await Je(e);je(t);const r=(await Ct.getKeyInfo(t)).toDto(),s=this.getPrivateKeysFromStorage();return s[Ot.MY_KEY_ID]=r,s[Ot.MY_KEY_ID].user_id=Ot.MY_KEY_ID,this.store(Ot.PRIVATE,s),!0}async importServerPublicKey(e,t){const r=rt(t);return await this.importPublic(e,r),!0}findArmoredKeyInText(e,t){let r,s;if(t===Ot.PUBLIC){if(r=e.indexOf(Ot.PUBLIC_HEADER),-1!==r&&(s=e.indexOf(Ot.PUBLIC_FOOTER),-1!==s))return e.substr(r,s+Ot.PUBLIC_FOOTER.length)}else t===Ot.PRIVATE&&(r=e.indexOf(Ot.PRIVATE_HEADER),-1!==r&&(s=e.indexOf(Ot.PRIVATE_FOOTER),-1!==s&&(e=e.substr(r,s+Ot.PRIVATE_HEADER.length))));return e}async sync(){const e=a.getItem("latestSync");let t=`${(new H).getDomain()}/gpgkeys.json?api-version=v2`;null!==e&&(t+=`&modified_after=${e}`);const r="undefined"!=typeof customApiClientFetch?customApiClientFetch:fetch,s=await r(t,{method:"GET",credentials:"include",headers:{Accept:"application/json","Content-Type":"application/json"}}),i=await s.json();if(!s.ok){let e="Could not synchronize the keyring. The server responded with an error.";throw i.header.msg&&(e+=` ${i.header.msg}`),e+=`(${s.status})`,new Error(e)}if(!i.header)throw new Error("Could not synchronize the keyring. The server response header is missing.");if(!i.body)throw new Error("Could not synchronize the keyring. The server response body is missing.");let o,n;const c=[];for(n in i.body)Object.prototype.hasOwnProperty.call(i.body,n)&&(o=i.body[n],c.push(this.importPublic(o.armored_key,o.user_id)));return await Promise.all(c),a.setItem("latestSync",i.header.servertime),i.body.length}store(e,t){if(e!==Ot.PUBLIC&&e!==Ot.PRIVATE)throw new Error("Key type is incorrect");const r=e===Ot.PRIVATE?Ot.STORAGE_KEY_PRIVATE:Ot.STORAGE_KEY_PUBLIC;a.setItem(r,JSON.stringify(t))}getPrivateKeysFromStorage(){const e=a.getItem(Ot.STORAGE_KEY_PRIVATE);return e?JSON.parse(e):{}}getPublicKeysFromStorage(){const e=a.getItem(Ot.STORAGE_KEY_PUBLIC);return e?JSON.parse(e):{}}flush(e){void 0===e&&(e=Ot.PUBLIC),e===Ot.PUBLIC?this.store(Ot.PUBLIC,{}):e===Ot.PRIVATE&&this.store(Ot.PRIVATE,{}),a.removeItem("latestSync")}static get MY_KEY_ID(){return"MY_KEY_ID"}static get PUBLIC_HEADER(){return"-----BEGIN PGP PUBLIC KEY BLOCK-----"}static get PUBLIC_FOOTER(){return"-----END PGP PUBLIC KEY BLOCK-----"}static get PRIVATE_HEADER(){return"-----BEGIN PGP PRIVATE KEY BLOCK-----"}static get PRIVATE_FOOTER(){return"-----END PGP PRIVATE KEY BLOCK-----"}static get PUBLIC(){return"PUBLIC"}static get PRIVATE(){return"PRIVATE"}static get STORAGE_KEY_PUBLIC(){return"passbolt-public-gpgkeys"}static get STORAGE_KEY_PRIVATE(){return"passbolt-private-gpgkeys"}}const xt=Ot;const Pt=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new xt}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!e)throw new Error("An armored key must be provided");const t=await Je(e);return await Ct.getKeyInfo(t)}};class Nt extends dt{constructor(e){super(e,Nt.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/organization-policies"}static getSupportedContainOptions(){return["creator","creator.gpgkey"]}async find(e){const t=e?this.formatContainOptions(e,Nt.getSupportedContainOptions()):null;return(await this.apiClient.findAll(t)).body}async saveOrganizationPolicy(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}}const Ut=Nt;class Dt extends Error{constructor(e,t,r){if(super(r=r||"Entity collection error."),"number"!=typeof e)throw new TypeError("EntityCollectionError requires a valid position");if(!t||"string"!=typeof t)throw new TypeError("EntityCollectionError requires a valid rule");if(!r||"string"!=typeof r)throw new TypeError("EntityCollectionError requires a valid message");this.position=e,this.rule=t}}const Mt=Dt;class Lt{constructor(e=[],t={}){const r=t?.clone??!0;this._items=[],r&&(e=JSON.parse(JSON.stringify(e))),this._props=e}toDto(){return JSON.parse(JSON.stringify(this._items))}toJSON(){return this.toDto()}get items(){return this._items}get length(){return this._items.length}[Symbol.iterator](){let e=0;return{next:()=>e<this._items.length?{value:this._items[e++],done:!1}:{done:!0}}}getAll(e,t){if("string"!=typeof e)throw new TypeError("EntityCollection excludeAll expects propName to be string.");if("string"!=typeof t)throw new TypeError("EntityCollection excludeAll expects search to be string.");return this._items.filter((r=>Object.prototype.hasOwnProperty.call(r._props,e)&&r._props[e]===t))}getFirst(e,t){if("string"!=typeof e||"string"!=typeof t)throw new TypeError("EntityCollection getFirst by expect propName and search to be strings");const r=this.getAll(e,t);if(r&&r.length)return r[0]}extract(e){if("string"!=typeof e)throw new TypeError("EntityCollection extract expects propName to be a string.");return this._items.reduce(((t,r)=>(void 0!==r._props[e]&&t.push(r._props[e]),t)),[])}push(e){return this._items.push(e),this._items.length}unshift(e){return this._items.unshift(e),this._items.length}filterByPropertyValueIn(e,t,r=!0){if("string"!=typeof e)throw new TypeError("EntityCollection filterByPropertyValueIn expects propName to be a string.");if(!Array.isArray(t))throw new TypeError("EntityCollection filterByPropertyValueIn expects needles to be an array.");this.filterByCallback((s=>{const i=Object.prototype.hasOwnProperty.call(s._props,e);return!(r&&!i||i&&!t.includes(s._props[e]))}))}filterByCallback(e){if("function"!=typeof e)throw new TypeError("EntityCollection filterByCallback expects callback to be a function.");for(let t=this._items.length-1;t>=0;t--)e(this._items[t])||this._items.splice(t,1)}assertUniqueByProperty(e,t){const r=`unique_${e}`,s=this.extract(e),i=new Set;t=t||`The collection should only contain items with unique values for the property: ${e}.`,s.forEach(((e,s)=>{if(i.add(e),s!==i.size-1)throw new Mt(s,r,t)}))}assertNotExist(e,t,r={}){if(void 0===t)return;let s=r?.haystackSet;if(!s){const t=this.extract(e);s=new Set(t)}if(s.has(t)){const t=new R,s=r?.message||`The collection already includes an element that has a property (${e}) with an identical value.`;throw t.addError(e,"unique",s),t}}}const Ft=Lt;class qt extends T{constructor(e,t={}){super(U.validate(qt.ENTITY_NAME,e,qt.getSchema()),t)}static getSchema(){return{type:"object",required:["recipient_foreign_model","recipient_fingerprint","data"],properties:{id:{type:"string",format:"uuid"},private_key_id:{type:"string",format:"uuid"},recipient_foreign_model:{type:"string",enum:[qt.FOREIGN_MODEL_ORGANIZATION_KEY]},recipient_foreign_key:{type:"string",format:"uuid"},recipient_fingerprint:{type:"string",length:40},data:{type:"string"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get id(){return this._props.id||null}get privateKeyId(){return this._props.private_key_id||null}get recipientForeignKey(){return this._props.recipient_foreign_key||null}get data(){return this._props.data}get recipientForeignModel(){return this._props.recipient_foreign_model}get recipientFingerprint(){return this._props.recipient_fingerprint}static get ENTITY_NAME(){return"AccountRecoveryPrivateKeyPassword"}static get FOREIGN_MODEL_ORGANIZATION_KEY(){return"AccountRecoveryOrganizationKey"}}const Kt=qt,Bt=(e,t)=>{if(!Array.isArray(e))throw new TypeError("deduplicateObjects first parameter should be an array.");if("string"!=typeof t)throw new TypeError("deduplicateObjects second parameter should be a string.");const r=e.filter((e=>Object.prototype.hasOwnProperty.call(e,t))).map((e=>e[t])).reduce(((e,t,r)=>(e[t]=Object.prototype.hasOwnProperty.call(e,t)?e[t]:r,e)),{});return e.filter(((e,s)=>!Object.prototype.hasOwnProperty.call(e,t)||r[e[t]]===s))};class jt extends Ft{constructor(e,t={}){super(U.validate(jt.ENTITY_NAME,e,jt.getSchema()),t);this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new Mt(0,jt.RULE_UNIQUE_ID,`AccountRecoveryPrivateKeyPassword id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new Kt(e,{...t,clone:!1}))})),this._props=null}static getSchema(){return{type:"array",items:Kt.getSchema()}}get accountRecoveryPrivateKeyPasswords(){return this._items}get ids(){return this._items.map((e=>e.id))}static sanitizeDto(e){return Array.isArray(e)?Bt(e,"id"):[]}assertUniqueId(e){if(!e.id)return;const t=this.accountRecoveryPrivateKeyPasswords.length;let r=0;for(;r<t;r++){const t=this.accountRecoveryPrivateKeyPasswords[r];if(t.id&&t.id===e.id)throw new Mt(r,jt.RULE_UNIQUE_ID,`account recovery private key password id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("accountRecoveryPrivateKeyPasswordsCollection push parameter should be an object.");e instanceof Kt&&(e=e.toDto());const t=new Kt(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}filterByForeignModel(e){return this.items.find((t=>t.recipientForeignModel===e))}static get ENTITY_NAME(){return"AccountRecoveryPrivateKeyPassword"}static get RULE_UNIQUE_ID(){return"unique_id"}}const zt=jt;const $t=class extends T{static _cachedSchema={};constructor(e={},t={}){super(e,t),this.marshall();(t?.validate??!0)&&(this.validateSchema(t?.schema),this.validateBuildRules(t?.validateBuildRules))}marshall(){}validateSchema(e=null){this._props=U.validate(this.constructor.name,this._props,e??this.cachedSchema)}get cachedSchema(){return this.constructor._cachedSchema[this.constructor.name]||(this.constructor._cachedSchema[this.constructor.name]=this.constructor.getSchema()),this.constructor._cachedSchema[this.constructor.name]}static getSchema(){throw new Error("The entity class should declare its schema.")}validateBuildRules(e={}){}};class Vt extends $t{static getSchema(){return{type:"object",required:["id","name"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",enum:[Vt.ROLE_ADMIN,Vt.ROLE_USER,Vt.ROLE_GUEST,Vt.ROLE_ROOT]},description:{type:"string",maxLength:255},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id}get name(){return this._props.name}get description(){return this._props.description||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}isAdmin(){return this.name===Vt.ROLE_ADMIN}static get ENTITY_NAME(){return"Role"}static get ROLE_ADMIN(){return"admin"}static get ROLE_USER(){return"user"}static get ROLE_GUEST(){return"guest"}static get ROLE_ROOT(){return"root"}}const Yt=Vt;class Gt extends $t{static getSchema(){return{type:"object",required:[Gt.AVATAR_URL_SIZE_MEDIUM,Gt.AVATAR_URL_SIZE_SMALL],properties:{medium:{type:"string"},small:{type:"string"}}}}get medium(){return this._props.medium}get small(){return this._props.small}static get ENTITY_NAME(){return"AvatarUrl"}static get AVATAR_URL_SIZE_MEDIUM(){return"medium"}static get AVATAR_URL_SIZE_SMALL(){return"small"}}const Wt=Gt;const Ht=class extends $t{constructor(e={},t={}){super(e,t),this._props.url&&(this._url=new Wt(this._props.url,{...t,clone:!1}),delete this._props.url)}static getSchema(){return{type:"object",required:["url"],properties:{id:{type:"string",format:"uuid"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},url:Wt.getSchema()}}}get id(){return this._props.id||null}get urlMedium(){return this._url.medium}get urlSmall(){return this._url.small}get created(){return this._props.created||null}get modified(){return this._props.modified||null}toDto(e){const t=super.toDto(e);return t.url=this._url.toDto(),t}static get ENTITY_NAME(){return"Avatar"}static get AVATAR_URL_SIZE_MEDIUM(){return"medium"}static get AVATAR_URL_SIZE_SMALL(){return"small"}};class Jt extends $t{constructor(e={},t={}){super(e,t),this._props.avatar&&(this._avatar=new Ht(this._props.avatar,{...t,clone:!1}),delete this._props.avatar)}static getSchema(){return{type:"object",required:["first_name","last_name"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},first_name:{type:"string",minLength:1,maxLength:255},last_name:{type:"string",minLength:1,maxLength:255},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},avatar:Ht.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return this.avatar&&e&&e.avatar&&(t.avatar=this.avatar.toDto()),t}toJSON(){return this.toDto(Jt.ALL_CONTAIN_OPTIONS)}static get ENTITY_NAME(){return"Profile"}static get ALL_CONTAIN_OPTIONS(){return{avatar:!0}}get id(){return this._props.id||null}get name(){return`${this._props.first_name} ${this._props.last_name}`}get firstName(){return this._props.first_name}get lastName(){return this._props.last_name}get userId(){return this._props.user_id||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get avatar(){return this._avatar||null}}const Zt=Jt;const Qt=class extends $t{static getSchema(){return{type:"object",required:["user_id","armored_key"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},fingerprint:{type:"string",minLength:40,maxLength:40},armored_key:{type:"string"},deleted:{type:"boolean"},type:{type:"string",nullable:!0},uid:{type:"string"},bits:{type:"integer",nullable:!0},key_id:{type:"string",minLength:8,maxLength:16},key_created:{type:"string",format:"date-time"},expires:{type:"string",format:"date-time",nullable:!0},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id||null}get userId(){return this._props.user_id}get armoredKey(){return this._props.armored_key}get fingerprint(){return this._props.fingerprint}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get isDeleted(){return void 0===this._props.deleted?null:this._props.deleted}static get ENTITY_NAME(){return"gpgkey"}};const Xt=class extends Ft{static _cachedSchema={};get entityClass(){throw new Error("The collection class should declare the entity class that is handled.")}constructor(e=[],t={}){super(e,t);(t?.validate??!0)&&this.validateSchema(),this.pushMany(this._props,{...t,clone:!1}),this._props=null}validateSchema(){this._props=U.validate(this.constructor.name,this._props,this.cachedSchema)}get cachedSchema(){return this.constructor._cachedSchema[this.constructor.name]||(this.constructor._cachedSchema[this.constructor.name]=this.constructor.getSchema()),this.constructor._cachedSchema[this.constructor.name]}static getSchema(){throw new Error("The collection class should declare its schema.")}buildOrCloneEntity(e,t={}){if(!e||"object"!=typeof e)throw new TypeError(`${this.entityClass.name}::buildOrCloneEntity expects "data" to be an object.`);return e instanceof this.entityClass&&(e=e.toDto(this.entityClass?.ALL_CONTAIN_OPTIONS)),new this.entityClass(e,t)}validateBuildRules(e,t={}){}push(e,t={},r={}){const s=this.buildOrCloneEntity(e,t);this.validateBuildRules(s,r?.validateBuildRules),this._items.push(s),r?.onItemPushed?.(s)}pushOrReplace(e,t={},r={}){const s=r?.replacePropertyName||"id",i=this.items.findIndex((t=>t[s]===e[s]));if(-1!==i){this.items.splice(i,1);const s=this.buildOrCloneEntity(e,t);this.validateBuildRules(s,r?.validateBuildRules),this.items.splice(i,0,s)}else this.push(e,t,r)}pushMany(e,t={},r={}){if(!Array.isArray(e))throw new TypeError(`${this.constructor.name} pushMany expects "data" to be an array.`);e.forEach(((e,s)=>{try{this.push(e,t,r)}catch(e){this.handlePushItemError(s,e,t)}}))}handlePushItemError(e,t,r){if(!(t instanceof R||t instanceof P||t instanceof Mt))throw t;if(!r?.ignoreInvalidEntity){const r=new P;throw r.addItemValidationError(e,t),r}console.debug(`${this.entityClass.name}::pushMany ignore item (${e}) due to validation error ${JSON.stringify(t?.details)}`)}};const er=class extends $t{static getSchema(){return{type:"object",required:["user_id","is_admin"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},group_id:{type:"string",format:"uuid"},is_admin:{type:"boolean"},created:{type:"string",format:"date-time"}}}}toDto(){return Object.assign({},this._props)}get id(){return this._props.id||null}get userId(){return this._props.user_id}get groupId(){return this._props.group_id||null}get isAdmin(){return this._props.is_admin}get created(){return this._props.created||null}set id(e){if(!O().isUUID(e))throw new TypeError("The group user id should be a valid UUID.");this._props.id=e}static get ENTITY_NAME(){return"GroupUser"}static get ALL_CONTAIN_OPTIONS(){return{}}};const tr=class extends Xt{get entityClass(){return er}static getSchema(){return{type:"array",items:er.getSchema()}}get groupsUsers(){return this._items}static get ENTITY_NAME(){return"GroupsUsers"}getGroupUserByUserId(e){return this.groupsUsers.find((t=>t.userId===e))}getById(e){return this.items.find((t=>t.id===e))}};class rr extends T{constructor(e,t={}){if(super(U.validate(rr.ENTITY_NAME,e,rr.getSchema()),t),this._props.account_recovery_private_key_passwords){const e=zt.sanitizeDto(this._props.account_recovery_private_key_passwords);this._account_recovery_private_key_passwords=new zt(e,{...t,clone:!1}),delete this._props.account_recovery_private_key_passwords}}static getSchema(){return{type:"object",required:[],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},data:{type:"string"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},account_recovery_private_key_passwords:zt.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._account_recovery_private_key_passwords&&e.account_recovery_private_key_passwords&&(t.account_recovery_private_key_passwords=this._account_recovery_private_key_passwords.toDto()),t):t}toJSON(){return this.toDto(rr.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get userId(){return this._props.user_id||null}get data(){return this._props.data||null}get accountRecoveryPrivateKeyPasswords(){return this._account_recovery_private_key_passwords||null}static get ENTITY_NAME(){return"AccountRecoveryPrivateKey"}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_private_key_passwords:!0}}}const sr=rr;class ir extends T{constructor(e,t={}){super(U.validate(ir.ENTITY_NAME,e,ir.getSchema()),t),this._props.account_recovery_private_key&&(this._account_recovery_private_key=new sr(this._props.account_recovery_private_key,{...t,clone:!1}),delete this._props.account_recovery_private_key)}static getSchema(){return{type:"object",required:["status"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},status:{type:"string",enum:[ir.STATUS_APPROVED,ir.STATUS_REJECTED]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},account_recovery_private_key:sr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return this._account_recovery_private_key&&e?.account_recovery_private_key&&(t.account_recovery_private_key=this._account_recovery_private_key.toDto(sr.ALL_CONTAIN_OPTIONS)),t}toJSON(){return this.toDto()}get status(){return this._props.status}get isApproved(){return this.status===ir.STATUS_APPROVED}get isRejected(){return this.status===ir.STATUS_REJECTED}get accountRecoveryPrivateKey(){return this._account_recovery_private_key||null}static get ENTITY_NAME(){return"AccountRecoveryUserSetting"}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_private_key:!0}}static get STATUS_APPROVED(){return"approved"}static get STATUS_REJECTED(){return"rejected"}}const ar=ir;class or extends T{constructor(e={},t={}){super(U.validate(or.ENTITY_NAME,e,or.getSchema()),t)}static getSchema(){return{type:"object",required:["id","status"],properties:{id:{type:"string",format:"uuid"},status:{type:"string",enum:["pending"]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}get id(){return this._props.id}get status(){return this._props.status}static get ENTITY_NAME(){return"PendingAccountRecoveryRequest"}}const nr=or;class cr extends $t{constructor(e,t={}){super(e,t),this._props.profile&&(this._profile=new Zt(this._props.profile,{...t,clone:!1}),delete this._props.profile),this._props.role&&(this._role=new Yt(this._props.role,{...t,clone:!1}),delete this._props.role),this._props.gpgkey&&(this._gpgkey=new Qt(this._props.gpgkey,{...t,clone:!1}),delete this._props.gpgkey),this._props.groups_users&&(this._groups_users=new tr(this._props.groups_users,{...t,clone:!1}),delete this._props.groups_users),this._props.account_recovery_user_setting&&(this._account_recovery_user_setting=new ar(this._props.account_recovery_user_setting,{...t,clone:!1}),delete this._props.account_recovery_user_setting),this._props.pending_account_recovery_request&&(this._pending_account_recovery_request=new nr(this._props.pending_account_recovery_request,{...t,clone:!1}),delete this._props.pending_account_recovery_request)}marshall(){""===this._props.last_logged_in&&(this._props.last_logged_in=null),super.marshall()}static getSchema(){return{type:"object",required:["username"],properties:{id:{type:"string",format:"uuid"},role_id:{type:"string",format:"uuid"},username:{type:"string",custom:vt.validate},active:{type:"boolean"},deleted:{type:"boolean"},disabled:{type:"string",format:"date-time",nullable:!0},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},last_logged_in:{type:"string",format:"date-time",nullable:!0},is_mfa_enabled:{type:"boolean",nullable:!0},locale:{type:"string",pattern:/^[a-z]{2}-[A-Z]{2}$/,nullable:!0},role:Yt.getSchema(),profile:Zt.getSchema(),gpgkey:Qt.getSchema(),groups_users:tr.getSchema(),account_recovery_user_setting:ar.getSchema(),pending_account_recovery_request:nr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.role&&e.role&&(t.role=this.role.toDto()),this.profile&&e.profile&&(!0===e.profile?t.profile=this.profile.toDto():t.profile=this.profile.toDto(e.profile)),this.gpgkey&&e.gpgkey&&(t.gpgkey=this.gpgkey.toDto()),this.groupsUsers&&e.groups_users&&(t.groups_users=this.groupsUsers.toDto()),this.accountRecoveryUserSetting&&e.account_recovery_user_setting&&(t.account_recovery_user_setting=this.accountRecoveryUserSetting.toDto()),this.pendingAccountRecoveryUserRequest&&e.pending_account_recovery_request&&(t.pending_account_recovery_request=this.pendingAccountRecoveryUserRequest.toDto()),t):t}toJSON(){return this.toDto(cr.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get roleId(){return this._props.role_id||null}get username(){return this._props.username}get isActive(){return void 0===this._props.active?null:this._props.active}get isDeleted(){return void 0===this._props.deleted?null:this._props.deleted}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get lastLoggedIn(){return this._props.last_logged_in||null}get isMfaEnabled(){return void 0===this._props.is_mfa_enabled?null:this._props.is_mfa_enabled}get locale(){return this._props.locale||null}set locale(e){this._props.locale=e}static get ALL_CONTAIN_OPTIONS(){return{profile:Zt.ALL_CONTAIN_OPTIONS,role:!0,gpgkey:!0,groups_users:!0,account_recovery_user_setting:!0,pending_account_recovery_request:!0}}static get ENTITY_NAME(){return"User"}get profile(){return this._profile||null}get role(){return this._role||null}get gpgkey(){return this._gpgkey||null}get groupsUsers(){return this._groups_users||null}get accountRecoveryUserSetting(){return this._account_recovery_user_setting||null}get pendingAccountRecoveryUserRequest(){return this._pending_account_recovery_request||null}}const lr=cr;class ur extends T{constructor(e,t={}){e=ur.sanitizeDto(e),super(U.validate(ur.ENTITY_NAME,e,ur.getSchema()),t)}static getSchema(){return{type:"object",required:["armored_key"],properties:{id:{type:"string",format:"uuid"},armored_key:{type:"string"},fingerprint:{type:"string",length:40,nullable:!0},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},deleted:{type:"string",format:"date-time"}}}}static sanitizeDto(e){return(e=Object.assign({},e)).fingerprint&&(e.fingerprint=this.sanitizeFingerPrint(e.fingerprint)),e}static sanitizeFingerPrint(e=""){return e.toUpperCase()}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get armoredKey(){return this._props.armored_key}get fingerprint(){return this._props.fingerprint}set fingerprint(e){U.validateProp("fingerprint",e,ur.getSchema().properties.fingerprint),this._props.fingerprint=ur.sanitizeFingerPrint(e)}static get ENTITY_NAME(){return"AccountRecoveryOrganizationPublicKey"}}const dr=ur;class pr extends T{constructor(e,t={}){super(U.validate(pr.ENTITY_NAME,e,pr.getSchema()),t),this._props.account_recovery_organization_public_key&&(this._account_recovery_organization_public_key=new dr(this._props.account_recovery_organization_public_key,{clone:!1}),pr.assertValidAccountRecoveryOrganizationPublicKey(this._account_recovery_organization_public_key,this.public_key_id),delete this._props.account_recovery_organization_public_key),this._props.account_recovery_organization_revoked_key&&(this._account_recovery_organization_revoked_key=new dr(this._props.account_recovery_organization_revoked_key,{clone:!1}),delete this._props.account_recovery_organization_revoked_key),this._props.account_recovery_private_key_passwords&&(this._account_recovery_private_key_passwords=new zt(this._props.account_recovery_private_key_passwords,{clone:!1}),delete this._props.account_recovery_private_key_passwords),this._props.creator&&(this._creator=new lr(this._props.creator,{clone:!1}),delete this._props.creator)}static getSchema(){return{type:"object",required:["policy"],properties:{id:{type:"string",format:"uuid"},policy:{type:"string",enum:[pr.POLICY_DISABLED,pr.POLICY_MANDATORY,pr.POLICY_OPT_IN,pr.POLICY_OPT_OUT]},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"},public_key_id:{type:"string",format:"uuid",nullable:!0},account_recovery_organization_public_key:dr.getSchema(),account_recovery_organization_revoked_key:dr.getSchema(),account_recovery_private_key_passwords:zt.getSchema(),creator:lr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._account_recovery_organization_public_key&&e.account_recovery_organization_public_key&&(t.account_recovery_organization_public_key=this._account_recovery_organization_public_key.toDto()),this._account_recovery_organization_revoked_key&&e.account_recovery_organization_revoked_key&&(t.account_recovery_organization_revoked_key=this._account_recovery_organization_revoked_key.toDto()),this._account_recovery_private_key_passwords&&e.account_recovery_private_key_passwords&&(t.account_recovery_private_key_passwords=this._account_recovery_private_key_passwords.toDto()),this._creator&&e.creator&&(t.creator=this._creator.toDto(lr.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto({account_recovery_organization_public_key:!0,account_recovery_organization_revoked_key:!0,account_recovery_private_key_passwords:!0,creator:!0})}static assertValidAccountRecoveryOrganizationPublicKey(e,t){if(!e)throw new R("AccountRecoveryOrganizationPolicyEntity assertValidAccountRecoveryOrganizationPublicKey expect an accountRecoveryOrganizationPublicKey.");if(t&&e.id!==t)throw new R("AccountRecoveryOrganizationPolicyEntity assertValidPermission resource id doesnt not match foreign key permission.")}static async assertValidCreatorGpgkey(e){const t=e.creator;if(!t)throw new R("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects a creator to be defined.");const r=t.gpgkey;if(!r)throw new R("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects a creator.gpgkey to be defined.");if(t.id!==r.userId)throw new R("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects the creator's id to match the gpgkey.user_id.");if((await Je(r.armoredKey)).getFingerprint().toUpperCase()!==r.fingerprint.toUpperCase())throw new R("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects the gpgkey armoredKey's fingerprint to match the given fingerprint.")}get accountRecoveryOrganizationPublicKey(){return this._account_recovery_organization_public_key||null}get publicKeyId(){return this._props.public_key_id}get armoredKey(){return this._account_recovery_organization_public_key?this._account_recovery_organization_public_key.armoredKey:null}get revokedKey(){return this._account_recovery_organization_revoked_key?this._account_recovery_organization_revoked_key.armoredKey:null}get policy(){return this._props.policy}get privateKeyPasswords(){return this._account_recovery_private_key_passwords?this._account_recovery_private_key_passwords:null}get isDisabled(){return this.policy===pr.POLICY_DISABLED}get isEnabled(){return!this.isDisabled}get isOptIn(){return this.policy===pr.POLICY_OPT_IN}get isOptOut(){return this.policy===pr.POLICY_OPT_OUT}get creator(){return this._creator}static get ENTITY_NAME(){return"AccountRecoveryOrganizationPolicy"}static get POLICY_DISABLED(){return"disabled"}static get POLICY_MANDATORY(){return"mandatory"}static get POLICY_OPT_IN(){return"opt-in"}static get POLICY_OPT_OUT(){return"opt-out"}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_organization_public_key:!0,account_recovery_organization_revoked_key:!0,account_recovery_private_key_passwords:!0,creator:!0}}}const hr=pr;class gr extends dt{constructor(e){super(e,gr.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/requests"}static getSupportedContainOptions(){return["creator","creator.gpgkey","account_recovery_private_key_passwords","armored_key"]}static getSupportedFiltersOptions(){return["has-users"]}async findById(e,t={}){const r=t?this.formatContainOptions(t,gr.getSupportedContainOptions()):null;return(await this.apiClient.get(e,r)).body}async findRequestByIdAndUserIdAndAuthenticationToken(e,t,r){this.assertValidId(e),this.assertValidId(t),this.assertValidId(r);const s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e}/${t}/${r}`);return(await this.apiClient.fetchAndHandleResponse("GET",s)).body}async findByUser(e){e=e?this.formatFilterOptions(e,gr.getSupportedFiltersOptions()):null;const t={...e};return(await this.apiClient.findAll(t)).body}async create(e){return(await this.apiClient.create(e)).body}}const yr=gr;class mr extends dt{constructor(e){super(e,mr.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/user-settings"}async saveUserSetting(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}}const wr=mr;class _r extends dt{constructor(e){super(e,_r.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/responses"}async saveReview(e){return(await this.apiClient.create(e)).body}}const fr=_r;class vr extends dt{constructor(e){super(e,vr.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/private-key-passwords"}async findAll(){return(await this.apiClient.findAll()).body}}const Sr=vr;class br extends dt{constructor(e){super(e,br.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/continue"}async continue(e,t){this.assertValidId(e),this.assertValidId(t),await this.apiClient.get(`${e}/${t}`)}}const Er=br;class kr extends dt{constructor(e){super(e,kr.RESOURCE_NAME)}static get RESOURCE_NAME(){return"setup"}async complete(e,t){this.assertValidId(e);const r=new URL(`${this.apiClient.baseUrl}/complete/${e}`),s=this.apiClient.buildBody(t);return this.apiClient.fetchAndHandleResponse("POST",r,s)}async completeRecover(e,t){this.assertValidId(e);const r=new URL(`${this.apiClient.baseUrl}/recover/complete/${e}`),s=this.apiClient.buildBody(t);return this.apiClient.fetchAndHandleResponse("POST",r,s)}async findSetupInfo(e,t){this.assertValidId(e),this.assertValidId(t);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/start/${e}/${t}`,{});return(await this.apiClient.fetchAndHandleResponse("GET",r)).body}async findRecoverInfo(e,t){this.assertValidId(e),this.assertValidId(t);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover/start/${e}/${t}`,{});return(await this.apiClient.fetchAndHandleResponse("GET",r)).body}async abort(e,t){this.assertValidId(e);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover/abort/${e}`,{}),s=this.apiClient.buildBody(t);return(await this.apiClient.fetchAndHandleResponse("POST",r,s)).body}}const Ar=kr;class Tr extends T{constructor(e,t={}){super(U.validate(Tr.ENTITY_NAME,e,Tr.getSchema()),t)}static getSchema(){return{type:"object",required:["account_recovery_request_id","responder_foreign_key","responder_foreign_model","status"],properties:{id:{type:"string",format:"uuid"},account_recovery_request_id:{type:"string",format:"uuid"},responder_foreign_key:{type:"string",format:"uuid"},responder_foreign_model:{type:"string",enum:[this.RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY]},data:{type:"string"},status:{type:"string",enum:[this.STATUS_REJECTED,this.STATUS_APPROVED]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}get id(){return this._props.id||null}get status(){return this._props.status}get data(){return this._props.data||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get createdBy(){return this._props.created_by||null}get modifiedBy(){return this._props.modified_by||null}static get ENTITY_NAME(){return"AccountRecoveryResponse"}static get STATUS_APPROVED(){return"approved"}static get STATUS_REJECTED(){return"rejected"}static get RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY(){return"AccountRecoveryOrganizationKey"}}const Ir=Tr;class Rr extends Ft{constructor(e,t={}){super(U.validate(Rr.ENTITY_NAME,e,Rr.getSchema()),t);this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new Mt(0,Rr.RULE_UNIQUE_ID,`AccountRecoveryRequest id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new Ir(e,{clone:!1}))})),this._props=null}static getSchema(){return{type:"array",items:Ir.getSchema()}}get accountRecoveryResponses(){return this._items}get ids(){return this._items.map((e=>e.id))}static sanitizeDto(e){return Array.isArray(e)?Bt(e,"id"):[]}assertUniqueId(e){if(!e.id)return;const t=this.accountRecoveryResponses.length;let r=0;for(;r<t;r++){const t=this.accountRecoveryResponses[r];if(t.id&&t.id===e.id)throw new Mt(r,Rr.RULE_UNIQUE_ID,`account recovery private key password id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("accountRecoveryResponsesCollection push parameter should be an object.");e instanceof Ir&&(e=e.toDto());const t=new Ir(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"AccountRecoveryResponse"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Cr=Rr;class Or extends T{constructor(e={},t={}){super(U.validate(Or.ENTITY_NAME,e,Or.getSchema()),t),this._props.account_recovery_private_key&&(this._account_recovery_private_key=new sr(this._props.account_recovery_private_key,{clone:!1}),delete this._props.account_recovery_private_key),this._props.account_recovery_responses&&(this._account_recovery_responses=new Cr(this._props.account_recovery_responses,{clone:!1}),delete this._props.account_recovery_responses),this._props.creator&&(this._creator=new lr(this._props.creator,{clone:!1}),delete this._props.creator)}static getSchema(){return{type:"object",required:["id","status"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},armored_key:{type:"string"},fingerprint:{type:"string",length:40,nullable:!0},status:{type:"string",enum:["pending","rejected","approved","completed"]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},account_recovery_private_key:sr.getSchema(),creator:lr.getSchema(),account_recovery_responses:Cr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.accountRecoveryPrivateKey&&e.account_recovery_private_key&&(t.account_recovery_private_key=this.accountRecoveryPrivateKey.toDto(sr.ALL_CONTAIN_OPTIONS)),this.creator&&e.creator&&(t.creator=this.creator.toDto(lr.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(Or.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id}get userId(){return this._props.user_id}get status(){return this._props.status}get armoredKey(){return this._props.armored_key}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_private_key:!0,creator:!0}}get creator(){return this._creator||null}get accountRecoveryPrivateKey(){return this._account_recovery_private_key||null}get accountRecoveryResponses(){return this._account_recovery_responses||null}static get ENTITY_NAME(){return"AccountRecoveryRequest"}}const xr=Or;class Pr extends Ft{constructor(e,t={}){super(U.validate(Pr.ENTITY_NAME,e,Pr.getSchema()),t);this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new Mt(0,Pr.RULE_UNIQUE_ID,`AccountRecoveryRequest id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new xr(e,{clone:!1}))})),this._props=null}static getSchema(){return{type:"array",items:xr.getSchema()}}get accountRecoveryRequests(){return this._items}get ids(){return this._items.map((e=>e.id))}static sanitizeDto(e){return Array.isArray(e)?Bt(e,"id"):[]}assertUniqueId(e){if(!e.id)return;const t=this.accountRecoveryRequests.length;let r=0;for(;r<t;r++){const t=this.accountRecoveryRequests[r];if(t.id&&t.id===e.id)throw new Mt(r,Pr.RULE_UNIQUE_ID,`account recovery private key password id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("accountRecoveryRequestsCollection push parameter should be an object.");e instanceof xr&&(e=e.toDto());const t=new xr(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"AccountRecoveryRequest"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Nr=Pr;const Ur=class{constructor(e){this.accountRecoveryOrganizationPolicyService=new Ut(e),this.accountRecoveryRequestService=new yr(e),this.accountRecoveryUserService=new wr(e),this.accountRecoveryResponseService=new fr(e),this.accountRecoveryPrivateKeyPasswordService=new Sr(e),this.accountRecoveryContinueService=new Er(e),this.setupService=new Ar(e)}async findOrganizationPolicy(e={}){const t=await this.accountRecoveryOrganizationPolicyService.find(e);if(!t)return null;const r=new hr(t);return r.isDisabled&&r.creator&&await hr.assertValidCreatorGpgkey(r),r}async findUserRequests(e={}){const t=await this.accountRecoveryRequestService.findByUser(e);return new Nr(t)}async findRequestById(e,t={}){if(!O().isUUID(e))throw new TypeError("id should be a valid uuid.");const r=await this.accountRecoveryRequestService.findById(e,t);return new xr(r)}async findAccountRecoveryPrivateKeyPasswords(){const e=await this.accountRecoveryPrivateKeyPasswordService.findAll();return new zt(e)}async saveUserSetting(e){const t=e.toDto(ar.ALL_CONTAIN_OPTIONS),r=await this.accountRecoveryUserService.saveUserSetting(t);return new ar(r)}async saveOrganizationPolicy(e){const t=e.toDto(hr.ALL_CONTAIN_OPTIONS),r=await this.accountRecoveryOrganizationPolicyService.saveOrganizationPolicy(t);return new hr(r)}async saveReview(e){const t=e.toDto(),r=await this.accountRecoveryResponseService.saveReview(t);return new Ir(r)}async continue(e,t){if(!O().isUUID(e))throw new TypeError("userId should be a valid uuid.");if(!O().isUUID(t))throw new TypeError("authenticationTokenToken should be a valid uuid.");await this.accountRecoveryContinueService.continue(e,t)}async findRequestByIdAndUserIdAndAuthenticationToken(e,t,r){if(!O().isUUID(e))throw new TypeError("requestId should be a valid uuid.");if(!O().isUUID(t))throw new TypeError("userId should be a valid uuid.");if(!O().isUUID(r))throw new TypeError("authenticationTokenToken should be a valid uuid.");const s=await this.accountRecoveryRequestService.findRequestByIdAndUserIdAndAuthenticationToken(e,t,r);return new xr(s)}};class Dr extends Error{constructor(e){super(e=e||ue.t("This is not a valid passphrase")),this.name="InvalidMasterPasswordError"}}const Mr=Dr;class Lr{static async decrypt(e,t){qe(e),ye(t);try{return await ae.Vw({privateKey:e,passphrase:t})}catch(e){throw new Mr}}static async decryptArmoredKey(e,t){const r=await Je(e);return await Lr.decrypt(r,t)}}const Fr=Lr;const qr=class{static async encrypt(e,t){return Be(e),ye(t),await ae.T1({privateKey:e,passphrase:t})}};const Kr=class{constructor(){this.keyring=new xt}async add(e){const t=re.getInstance();t.settings.setSecurityToken(e.securityToken.toDto()),t.settings.setDomain(e.domain);const r=e.toLegacyUserDto();t.set(r),this.keyring.flush(xt.PUBLIC),this.keyring.flush(xt.PRIVATE),await this.keyring.importServerPublicKey(e.serverPublicArmoredKey,e.domain),await this.keyring.importPublic(e.userPublicArmoredKey,e.userId),await this.keyring.importPrivate(e.userPrivateArmoredKey)}async changeSecurityToken(e){await re.getInstance().updateSecurityToken(e.toDto())}async rotatePrivateKeyPassphrase(e,t){const r=this.keyring.findPrivate().armoredKey,s=await Je(r),i=await Fr.decrypt(s,e);return(await qr.encrypt(i,t)).armor()}async updatePrivateKey(e){const t=this.keyring.findPrivate(),r=await Je(e);if(t.fingerprint.toUpperCase()!==r.getFingerprint().toUpperCase())throw new Error("The private key to import doesn't match the current private key.");await this.keyring.importPrivate(e)}};class Br extends T{constructor(e,t={}){super(U.validate(Br.ENTITY_NAME,e,Br.getSchema()),t)}static getSchema(){return{type:"object",required:["code","color","textcolor"],properties:{code:{type:"string",pattern:/^[a-zA-Z0-9-_]{3}$/},color:{type:"string",format:"x-hex-color"},textcolor:{type:"string",format:"x-hex-color"}}}}get code(){return this._props.code}get color(){return this._props.color}get textcolor(){return this._props.textcolor}static get ENTITY_NAME(){return"SecurityToken"}}const jr=Br;var zr=r(4236);class $r extends T{constructor(e,t={}){super(e,t),this._props.security_token&&(this._security_token=new jr(this._props.security_token,{clone:!1}),delete this._props.security_token)}static getSchema(){const e=lr.getSchema(),t=Zt.getSchema();return{type:"object",required:[],properties:{type:{type:"string"},domain:{type:"string"},user_id:{type:"string",format:"uuid"},user_key_fingerprint:{type:"string",minLength:40,maxLength:40,pattern:/^[A-F0-9]{40}$/},user_public_armored_key:{type:"string"},user_private_armored_key:{type:"string"},server_public_armored_key:{type:"string"},username:e.properties.username,first_name:t.properties.first_name,last_name:t.properties.last_name,locale:{type:"string",pattern:/^[a-z]{2}-[A-Z]{2}$/,nullable:!0},security_token:jr.getSchema()}}}get id(){return this.domain&&this.userId?(0,zr.A)(`${this.domain}${this.userId}`,"d5447ca1-950f-459d-8b20-86ddfdd0f922"):null}get type(){return this._props.type}get domain(){return this._props.domain}get userId(){return this._props.user_id}get username(){return this._props.username}set username(e){U.validateProp("username",e,$r.getSchema().properties.username),this._props.username=e}get firstName(){return this._props.first_name}set firstName(e){U.validateProp("first_name",e,$r.getSchema().properties.first_name),this._props.first_name=e}get lastName(){return this._props.last_name}set lastName(e){U.validateProp("last_name",e,$r.getSchema().properties.last_name),this._props.last_name=e}get locale(){return this._props.locale}set locale(e){U.validateProp("locale",e,$r.getSchema().properties.locale),this._props.locale=e}get userPublicArmoredKey(){return this._props.user_public_armored_key}set userPublicArmoredKey(e){U.validateProp("user_public_armored_key",e,$r.getSchema().properties.user_public_armored_key),this._props.user_public_armored_key=e}get userPrivateArmoredKey(){return this._props.user_private_armored_key}set userPrivateArmoredKey(e){U.validateProp("user_private_armored_key",e,$r.getSchema().properties.user_private_armored_key),this._props.user_private_armored_key=e}get serverPublicArmoredKey(){return this._props.server_public_armored_key}set serverPublicArmoredKey(e){U.validateProp("server_public_armored_key",e,$r.getSchema().properties.server_public_armored_key),this._props.server_public_armored_key=e}get userKeyFingerprint(){return this._props.user_key_fingerprint}set userKeyFingerprint(e){U.validateProp("user_key_fingerprint",e,$r.getSchema().properties.user_key_fingerprint),this._props.user_key_fingerprint=e}get securityToken(){return this._security_token||null}set securityToken(e){e instanceof jr&&(e=e.toDto()),this._security_token=new jr(e)}static get ENTITY_NAME(){return"AbstractAccount"}}const Vr=$r;var Yr=r(8901),Gr=r.n(Yr),Wr=r(7946);const Hr=new(Gr()),Jr="accounts";class Zr{static async get(){const{accounts:e}=await Wr.storage.local.get([Jr]);return e||[]}static async getAccountByUserIdAndType(e,t){return(await Zr.get()).find((r=>r.user_id===e&&r.type===t))}static async add(e){if(!(e instanceof Vr))throw new TypeError("ResourceLocalStorage::add expects an AccountEntity");await Hr.acquireAsync();try{const t=await Zr.get();t.push(e.toDto(Zr.DEFAULT_CONTAIN)),await Wr.storage.local.set({[Jr]:t}),Hr.release()}catch(e){throw Hr.release(),e}}static async deleteByUserIdAndType(e,t){await Hr.acquireAsync();try{const r=await Zr.get();if(r){const s=r.filter((r=>r.user_id!==e||r.type!==t));await Wr.storage.local.set({[Jr]:s})}Hr.release()}catch(e){throw Hr.release(),e}}static get DEFAULT_CONTAIN(){return{user:!0,security_token:!0,authentication_token_token:!0,account_recovery_request_id:!0,user_private_armored_key:!0}}static get ACCOUNTS_LOCAL_STORAGE_KEY(){return Jr}}const Qr=Zr;class Xr extends T{constructor(e,t={}){super(U.validate(Xr.ENTITY_NAME,e,Xr.getSchema()),t)}static getSchema(){return{type:"object",required:["token"],properties:{id:{type:"string",format:"uuid"},token:{type:"string",format:"uuid"},active:{type:"boolean"},type:{type:"string",enum:[Xr.AUTHENTICATION_TOKEN_TYPE_LOGIN,Xr.AUTHENTICATION_TOKEN_TYPE_MFA,Xr.AUTHENTICATION_TOKEN_TYPE_MOBILE_TRANSFER,Xr.AUTHENTICATION_TOKEN_TYPE_RECOVER,Xr.AUTHENTICATION_TOKEN_TYPE_REGISTER]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get token(){return this._props.token}static get ENTITY_NAME(){return"AuthenticationToken"}static get AUTHENTICATION_TOKEN_TYPE_LOGIN(){return"login"}static get AUTHENTICATION_TOKEN_TYPE_MFA(){return"mfa"}static get AUTHENTICATION_TOKEN_TYPE_MOBILE_TRANSFER(){return"mobile_transfer"}static get AUTHENTICATION_TOKEN_TYPE_RECOVER(){return"recover"}static get AUTHENTICATION_TOKEN_TYPE_REGISTER(){return"register"}}const es=Xr;class ts extends T{constructor(e,t={}){super(U.validate(ts.ENTITY_NAME,e,ts.getSchema()),t),this._props.authentication_token&&(this._authentication_token=new es(this._props.authentication_token,{clone:!1}),delete this._props.authentication_token)}static getSchema(){return{type:"object",required:["user_id","fingerprint","armored_key","authentication_token"],properties:{user_id:xr.getSchema().properties.user_id,armored_key:xr.getSchema().properties.armored_key,fingerprint:xr.getSchema().properties.fingerprint,authentication_token:es.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.authenticationToken&&e.authentication_token&&(t.authentication_token=this.authenticationToken.toDto()),t):t}toJSON(){return this.toDto(ts.ALL_CONTAIN_OPTIONS)}get authenticationToken(){return this._authentication_token||null}static get ENTITY_NAME(){return"AccountRecoveryRequestCreate"}static get ALL_CONTAIN_OPTIONS(){return{authentication_token:!0}}}const rs=ts;class ss extends Vr{constructor(e,t={}){ss.marshal(e),super(U.validate(ss.ENTITY_NAME,e,ss.getSchema()),t),this._props.account_recovery_user_setting&&(this._account_recovery_user_setting=new ar(this._props.account_recovery_user_setting,{clone:!1}),delete this._props.account_recovery_user_setting),this._props.user&&(this._user=new lr(this._props.user,{clone:!1}),delete this._props.user)}static marshal(e){Object.assign(e,{type:ss.TYPE_ACCOUNT_RECOVER})}static getSchema(){const e=Vr.getSchema(),t=es.getSchema();return{type:"object",required:["type","domain","user_id","authentication_token_token"],properties:{...e.properties,type:{type:"string",pattern:`^${ss.TYPE_ACCOUNT_RECOVER}$`},authentication_token_token:t.properties.token,user:lr.getSchema()}}}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,delete t.authentication_token_token,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.authentication_token_token&&(t.authentication_token_token=this.authenticationTokenToken),e.security_token&&this.securityToken&&(t.security_token=this.securityToken.toDto()),e.account_recovery_user_setting&&this.accountRecoveryUserSetting&&(t.account_recovery_user_setting=this.accountRecoveryUserSetting.toDto(ar.ALL_CONTAIN_OPTIONS)),e.user&&this._user&&(t.user=this._user.toDto(lr.ALL_CONTAIN_OPTIONS)),t):t}toCompleteRecoverDto(){return{authenticationtoken:{token:this.authenticationTokenToken},authentication_token:{token:this.authenticationTokenToken},gpgkey:{armored_key:this.userPublicArmoredKey},user:{locale:this.locale},locale:this.locale}}toAbortRecoverDto(){return{authentication_token:{token:this.authenticationTokenToken}}}toAccountRecoveryRequestDto(){return{authentication_token:{token:this.authenticationTokenToken},fingerprint:this.userKeyFingerprint,user_id:this.userId,armored_key:this.userPublicArmoredKey}}get authenticationTokenToken(){return this._props.authentication_token_token||null}get type(){return this._props.type}get user(){return this._user||null}set user(e){if(!(e&&e instanceof lr))throw new TypeError("Failed to assert the parameter is a valid UserEntity");this._user=e}get accountRecoveryUserSetting(){return this._account_recovery_user_setting||null}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,security_token:!0,authentication_token_token:!0,account_recovery_user_setting:!0,user:!0}}static get ENTITY_NAME(){return"AccountRecover"}static get TYPE_ACCOUNT_RECOVER(){return"account-recover"}}const is=ss;class as extends Vr{constructor(e,t={}){as.marshal(e);const r=!1!==t?.validateUsername;super(U.validate(as.ENTITY_NAME,e,as.getSchema(r)),t),this.isUsernameValidated=r,this._props.account_recovery_request&&(this._account_recovery_request=new xr(this._props.account_recovery_request,{clone:!1}),delete this._props.account_recovery_request)}static marshal(e){Object.assign(e,{type:as.TYPE_ACCOUNT_ACCOUNT_RECOVERY})}static getSchema(e=!0){const t=Vr.getSchema(),r=es.getSchema(),s={type:"object",required:["type","domain","user_id","authentication_token_token","account_recovery_request_id"],properties:{...t.properties,type:{type:"string",pattern:`^${as.TYPE_ACCOUNT_ACCOUNT_RECOVERY}$`},account_recovery_request_id:{type:"string",format:"uuid"},authentication_token_token:r.properties.token,account_recovery_request:xr.getSchema()}};return e||(s.properties.username={type:"string"}),s}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,delete t.authentication_token_token,delete t.account_recovery_request_id,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.authentication_token_token&&(t.authentication_token_token=this.authenticationTokenToken),e.account_recovery_request_id&&(t.account_recovery_request_id=this.accountRecoveryRequestId),e.security_token&&this.securityToken&&(t.security_token=this.securityToken.toDto()),e.account_recovery_request&&this.accountRecoveryRequest&&(t.account_recovery_request=this._account_recovery_request.toDto(xr.ALL_CONTAIN_OPTIONS)),t):t}toAbortRecoverDto(){return{authentication_token:{token:this.authenticationTokenToken}}}toCompleteRecoverDto(){return{authenticationtoken:{token:this.authenticationTokenToken},authentication_token:{token:this.authenticationTokenToken},gpgkey:{armored_key:this.userPublicArmoredKey},user:{locale:this.locale},locale:this.locale,account_recovery_request_id:this.accountRecoveryRequestId}}get authenticationTokenToken(){return this._props.authentication_token_token||null}get type(){return this._props.type}get accountRecoveryRequestId(){return this._props.account_recovery_request_id||null}set accountRecoveryRequestId(e){U.validateProp("account_recovery_request_id",e,as.getSchema().properties.account_recovery_request_id),this._props.account_recovery_request_id=e}get accountRecoveryRequest(){return this._account_recovery_request||null}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,authentication_token_token:!0,account_recovery_request_id:!0,security_token:!0,account_recovery_request:!0}}static get ENTITY_NAME(){return"AccountAccountRecovery"}static get TYPE_ACCOUNT_ACCOUNT_RECOVERY(){return"account-account-recovery"}}const os=as;class ns extends Vr{constructor(e,t={}){ns.marshal(e),super(U.validate(ns.ENTITY_NAME,e,ns.getSchema()),t),this._props.account_recovery_user_setting&&(this._account_recovery_user_setting=new ar(this._props.account_recovery_user_setting,{clone:!1}),delete this._props.account_recovery_user_setting),this._props.user&&(this._user=new lr(this._props.user,{clone:!1}),delete this._props.user)}static marshal(e){Object.assign(e,{type:ns.TYPE_ACCOUNT_SETUP})}static getSchema(){const e=Vr.getSchema(),t=es.getSchema();return{type:"object",required:["type","domain","user_id","authentication_token_token"],properties:{...e.properties,type:{type:"string",pattern:`^${ns.TYPE_ACCOUNT_SETUP}$`},authentication_token_token:t.properties.token,user:lr.getSchema(),account_recovery_user_setting:ar.getSchema()}}}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,delete t.authentication_token_token,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.authentication_token_token&&(t.authentication_token_token=this.authenticationTokenToken),e.security_token&&this.securityToken&&(t.security_token=this.securityToken.toDto()),e.account_recovery_user_setting&&this.accountRecoveryUserSetting&&(t.account_recovery_user_setting=this.accountRecoveryUserSetting.toDto(ar.ALL_CONTAIN_OPTIONS)),e.user&&this._user&&(t.user=this.user.toDto(lr.ALL_CONTAIN_OPTIONS)),t):t}toCompleteSetupDto(){return{authenticationtoken:{token:this.authenticationTokenToken},authentication_token:{token:this.authenticationTokenToken},gpgkey:{armored_key:this.userPublicArmoredKey},user:{locale:this.locale},locale:this.locale,account_recovery_user_setting:this.accountRecoveryUserSetting?.toDto(ar.ALL_CONTAIN_OPTIONS)}}get authenticationTokenToken(){return this._props.authentication_token_token||null}get type(){return this._props.type}get user(){return this._user||null}set user(e){if(!(e&&e instanceof lr))throw new TypeError("Failed to assert the parameter is a valid UserEntity");this._user=e}get accountRecoveryUserSetting(){return this._account_recovery_user_setting||null}set accountRecoveryUserSetting(e){if(!(e&&e instanceof ar))throw new TypeError("Failed to assert the parameter is a valid AccountRecoveryUserSettingEntity");this._account_recovery_user_setting=e}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,security_token:!0,authentication_token_token:!0,account_recovery_user_setting:!0,user:!0}}static get ENTITY_NAME(){return"AccountSetup"}static get TYPE_ACCOUNT_SETUP(){return"account-setup"}}const cs=ns;class ls extends T{constructor(e,t={}){super(U.validate(ls.ENTITY_NAME,e,ls.getSchema()),t)}static getSchema(){return{type:"object",required:["entropy_minimum","external_dictionary_check"],properties:{id:{type:"string",format:"uuid"},entropy_minimum:{type:"integer",minimum:50,maximum:224},external_dictionary_check:{type:"boolean"},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"}}}}static get ENTITY_NAME(){return"UserPassphrasePolicies"}static createFromDefault(e={}){const t=Object.assign({entropy_minimum:50,external_dictionary_check:!0},e);return new ls(t)}}const us=ls;class ds extends Vr{constructor(e){if(super(U.validate(ds.ENTITY_NAME,e,ds.getSchema())),this._props.account){switch(this._props.account.type){case cs.TYPE_ACCOUNT_SETUP:this._account=new cs(this._props.account,{clone:!1});break;case is.TYPE_ACCOUNT_RECOVER:this._account=new is(this._props.account,{clone:!1});break;case os.TYPE_ACCOUNT_ACCOUNT_RECOVERY:this._account=new os(this._props.account,{clone:!1});break;default:throw new TypeError("The account should have a known type.")}delete this._props.account}this._props.account_recovery_organization_policy&&(this._account_recovery_organization_policy=new hr(this._props.account_recovery_organization_policy,{clone:!1}),delete this._props.account_recovery_organization_policy),this._props.user_passphrase_policies&&(this._user_passphrase_policies=new us(this._props.user_passphrase_policies,{clone:!1}),delete this._props.user_passphrase_policies)}static getSchema(){return{type:"object",required:["worker_id","account"],properties:{account:{anyOf:[cs.getSchema(),is.getSchema(),os.getSchema()]},passphrase:{type:"string"},worker_id:{type:"string",format:"uuid"},account_recovery_organization_policy:hr.getSchema(),user_passphrase_policies:us.getSchema()}}}toDto(e={}){const t=Object.assign({},this._props);if(delete t.passphrase,delete t.worker_id,!e)return t;if(e.account)switch(this.account.type){case cs.TYPE_ACCOUNT_SETUP:t.account=this.account.toDto(cs.ALL_CONTAIN_OPTIONS);break;case is.TYPE_ACCOUNT_RECOVER:t.account=this.account.toDto(is.ALL_CONTAIN_OPTIONS);break;case os.TYPE_ACCOUNT_ACCOUNT_RECOVERY:t.account=this.account.toDto(os.ALL_CONTAIN_OPTIONS)}return e.passphrase&&this.passphrase&&(t.passphrase=this.passphrase),e.worker_id&&(t.worker_id=this.workerId),e.account_recovery_organization_policy&&this.accountRecoveryOrganizationPolicy&&(t.account_recovery_organization_policy=this.accountRecoveryOrganizationPolicy.toDto(hr.ALL_CONTAIN_OPTIONS)),e.user_passphrase_policies&&this.userPassphrasePolicies&&(t.user_passphrase_policies=this.userPassphrasePolicies.toDto()),t}get workerId(){return this._props.worker_id}get passphrase(){return this._props.passphrase||null}set passphrase(e){this._props.passphrase=e}get account(){return this._account}get accountRecoveryOrganizationPolicy(){return this._account_recovery_organization_policy||null}set accountRecoveryOrganizationPolicy(e){if(!(e&&e instanceof hr))throw new TypeError("Failed to assert the parameter is a valid AccountRecoveryOrganizationPolicyEntity");this._account_recovery_organization_policy=e}get userPassphrasePolicies(){return this._user_passphrase_policies||null}set userPassphrasePolicies(e){if(!(e&&e instanceof us))throw new TypeError("Failed to assert the parameter is a valid UserPassphrasePoliciesEntity");this._user_passphrase_policies=e}static get ALL_CONTAIN_OPTIONS(){return{passphrase:!0,worker_id:!0,account:!0,account_recovery_organization_policy:!0,user_passphrase_policies:!0}}static get ENTITY_NAME(){return"AccountTemporary"}}const ps=ds;var hs=r(7946);const gs="account-temporary";const ys=class{static async get(e){const t=await hs.storage.session.get(gs),r=t?.[gs];if(r){const t=new ps(r);if(t.workerId===e)return t}return null}static async set(e){if(!(e instanceof ps))throw new Error("The account is not an AccountTemporaryEntity, storage has not been set");await navigator.locks.request(gs,(async()=>{await hs.storage.session.set({[gs]:e.toDto(ps.ALL_CONTAIN_OPTIONS)})}))}static async remove(){await navigator.locks.request(gs,(async()=>{await hs.storage.session.remove(gs)}))}};const ms=class{static async exec(e){const t=await ys.get(e);if(!t)throw new Error(ue.t("You have already started the process on another tab."));return t}};const ws=class{constructor(e,t,r){this.worker=e,this.requestId=r,this.accountModel=new Kr(t),this.accountRecoveryModel=new Ur(t),this.accountRecoveryRequestService=new yr(t)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ms.exec(this.worker.port._port.name),t=e.account.toAccountRecoveryRequestDto(),r=new rs(t),s=await this.accountRecoveryRequestService.create(r),i=e.account.toDto(is.ALL_CONTAIN_OPTIONS);i.account_recovery_request_id=s.id;const a=new os(i);await Qr.deleteByUserIdAndType(a.userId,os.TYPE_ACCOUNT_ACCOUNT_RECOVERY),await Qr.add(a),await ys.remove()}};const _s=class{static async getDate(e){const t=new wt(e);let r;try{r=await t.getOrFind()}catch(e){return console.error(e),(new Date).getTime()}return r.isServerInPast()?r.serverTime:(new Date).getTime()}};class fs extends T{constructor(e,t={}){fs.marshal(e),super(U.validate(fs.ENTITY_NAME,e,fs.getSchema()),t)}static marshal(e){e.keySize||(e.keySize=this.DEFAULT_KEY_SIZE),e.type||(e.type=this.DEFAULT_TYPE)}static getSchema(){return{type:"object",required:["name","email","passphrase","keySize","type"],properties:{name:{type:"string",minLength:1},email:{type:"string",custom:vt.validate},passphrase:{type:"string",minLength:8},type:{type:"string",enum:[fs.TYPE_RSA]},keySize:{type:"integer",minLength:this.DEFAULT_KEY_SIZE},date:{type:"integer"}}}}toGenerateOpenpgpKeyDto(){return{userIDs:[this.userId],rsaBits:this.rsaBits,passphrase:this.passphrase,type:this.type,date:this.date}}get userId(){return{name:this.name,email:this.email}}get name(){return this._props.name}get email(){return this._props.email}get type(){return this._props.type}get rsaBits(){return this._props.keySize}get passphrase(){return this._props.passphrase}get date(){return void 0!==this._props.date?new Date(this._props.date):new Date}static get ENTITY_NAME(){return"GenerateGpgKeyPairOptionsEntity"}static get DEFAULT_KEY_SIZE(){return 3072}static get DEFAULT_TYPE(){return"rsa"}static get TYPE_RSA(){return"rsa"}}const vs=fs;class Ss extends T{constructor(e,t={}){super(U.validate(Ss.ENTITY_NAME,e,Ss.getSchema()),t),this._props.private_key&&(this._private_key=new bt(this._props.private_key,{clone:!1}),delete this._props.private_key),this._props.public_key&&(this._public_key=new bt(this._props.public_key,{clone:!1}),delete this._props.public_key)}static getSchema(){return{type:"object",required:["public_key","private_key"],properties:{public_key:bt.getSchema(),private_key:bt.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(e.public_key&&this._public_key&&(t.public_key=this.publicKey.toDto()),e.private_key&&this._private_key&&(t.private_key=this.privateKey.toDto()),t):t}toJSON(){return this.toDto(Ss.ALL_CONTAIN_OPTIONS)}get publicKey(){return this._public_key}get privateKey(){return this._private_key}static get ENTITY_NAME(){return"externalGpgKeyPairEntity"}static get ALL_CONTAIN_OPTIONS(){return{public_key:!0,private_key:!0}}}const bs=Ss;class Es{static async generateKeyPair(e){const t=Object.assign(e.toGenerateOpenpgpKeyDto(),{format:"armored"});Es.shouldOverrideOpenPgpEmailValidation(e)&&Es.overrideOpenPgpEmailValidation();const r=await ae.rh(t);return new bs({public_key:{armored_key:r.publicKey},private_key:{armored_key:r.privateKey}})}static async shouldOverrideOpenPgpEmailValidation(e){return!!vt.hasCustomValidator()&&!ft.validate(e.email)}static overrideOpenPgpEmailValidation(){ae.pt.fromObject=e=>{if("string"==typeof e||e instanceof String||e.name&&!("string"==typeof e.name||e.name instanceof String)||e.email&&!vt.validate(e.email)||e.comment&&!("string"==typeof e.comment||e.comment instanceof String))throw new Error("Invalid user ID format");const t=new ae.pt;Object.assign(t,e);const r=[];return t.name&&r.push(t.name),t.comment&&r.push(`(${t.comment})`),t.email&&r.push(`<${t.email}>`),t.userID=r.join(" "),t}}}const ks=Es;const As=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.apiClientOptions=r}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await ms.exec(this.worker.port._port.name),r={name:"Account recovery request key",email:t.account?.username,passphrase:e?.passphrase,keySize:4096,date:await _s.getDate(this.apiClientOptions)},s=new vs(r),i=await ks.generateKeyPair(s),a=await Je(i.publicKey.armoredKey);t.account.userPrivateArmoredKey=i.privateKey.armoredKey,t.account.userPublicArmoredKey=i.publicKey.armoredKey,t.account.userKeyFingerprint=a.getFingerprint().toUpperCase(),await ys.set(t)}};const Ts=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await ms.exec(this.worker.port._port.name),r=t.account?.userPrivateArmoredKey;if(!r)throw new Error("An account user private key is required.");if("string"!=typeof e)throw new TypeError("The passphrase should be a string.");const s=await Je(r);await Fr.decrypt(s,e),t.passphrase=e,await ys.set(t)}};const Is=class{constructor(e){if(void 0===e)this.token="gpgauthv1.3.0|36|",this.token+=rt(),this.token+="|gpgauthv1.3.0";else{const t=this.validate("token",e);if(!0!==t)throw t;this.token=e}}validate(e,t){let r=[];return"token"===e?void 0===t||""===t?new Error("The user authentication token cannot be empty"):(r=t.split("|"),4!==r.length?new Error("The user authentication token is not in the right format"):r[0]!==r[3]&&"gpgauthv1.3.0"!==r[0]?new Error("Passbolt does not support this GPGAuth version"):"36"!==r[1]?new Error(`Passbolt does not support GPGAuth token nonce longer than 36 characters: ${r[2]}`):!!O().isUUID(r[2])||new Error("Passbolt does not support GPGAuth token nonce that are not UUIDs")):new Error(`No validation defined for field: ${e}`)}};const Rs=class{static async encryptSymmetrically(e,t,r=null){r&&Ke(r);const s=await He(e);return ae.w({message:s,passwords:t,signingKeys:r})}static async encrypt(e,t,r=null){ze(t),r&&Ke(r);const s=await He(e);return ae.w({message:s,encryptionKeys:t,signingKeys:r})}};class Cs extends Error{constructor(e){super(e),this.name="UserAlreadyLoggedInError"}}const Os=Cs,xs=function(e,t){this.headers={};const r=["x-gpgauth-version","x-gpgauth-authenticated","x-gpgauth-progress","x-gpgauth-user-auth-token","x-gpgauth-verify-response","x-gpgauth-refer","x-gpgauth-debug","x-gpgauth-error"];let s;for(let t=0;t<r.length;t++)s=r[t],e.has(s)&&(this.headers[s]=e.get(s));return this.__validate(t)};xs.prototype.__validate=function(e){const t=this.__validateCommonAllStage();if(t instanceof Error)throw t;const r=this.__validateByStage(e);if(r instanceof Error)throw r;return!0},xs.prototype.__validateCommonAllStage=function(){let e;return void 0===this.headers?new Error("No GPGAuth headers set."):"string"!=typeof this.headers["x-gpgauth-version"]||"1.3.0"!==this.headers["x-gpgauth-version"]?new Error(`That version of GPGAuth is not supported. (${this.headers["x-gpgauth-version"]})`):void 0===this.headers["x-gpgauth-error"]||(e=void 0!==this.headers["x-gpgauth-debug"]?this.headers["x-gpgauth-debug"]:"There was an error during authentication. Enable debug mode for more information",new Error(e))},xs.prototype.__validateByStage=function(e){switch(e){case"logout":if("string"!=typeof this.headers["x-gpgauth-authenticated"]||"false"!=this.headers["x-gpgauth-authenticated"])return new Error("x-gpgauth-authenticated should be set to false during the logout stage");break;case"verify":case"stage0":if("string"!=typeof this.headers["x-gpgauth-authenticated"]||"false"!=this.headers["x-gpgauth-authenticated"])return new Error("x-gpgauth-authenticated should be set to false during the verify stage");if("string"!=typeof this.headers["x-gpgauth-progress"]||"stage0"!=this.headers["x-gpgauth-progress"])return new Error("x-gpgauth-progress should be set to stage0 during the verify stage");if(void 0!==this.headers["x-gpgauth-user-auth-token"])return new Error("x-gpgauth-user-auth-token should not be set during the verify stage"+typeof this.headers["x-gpgauth-user-auth-token"]);if("string"!=typeof this.headers["x-gpgauth-verify-response"])return new Error("x-gpgauth-verify-response should be set during the verify stage");if(void 0!==this.headers["x-gpgauth-refer"])return new Error("x-gpgauth-refer should not be set during verify stage");break;case"stage1":return"string"!=typeof this.headers["x-gpgauth-authenticated"]||"false"!=this.headers["x-gpgauth-authenticated"]?new Os("x-gpgauth-authenticated should be set to false during stage1"):"string"!=typeof this.headers["x-gpgauth-progress"]||"stage1"!=this.headers["x-gpgauth-progress"]?new Error("x-gpgauth-progress should be set to stage1"):void 0===this.headers["x-gpgauth-user-auth-token"]?new Error("x-gpgauth-user-auth-token should be set during stage1"):void 0!==this.headers["x-gpgauth-verify-response"]?new Error("x-gpgauth-verify-response should not be set during stage1"):void 0===this.headers["x-gpgauth-refer"]||new Error("x-gpgauth-refer should not be set during stage1");case"complete":return"string"!=typeof this.headers["x-gpgauth-authenticated"]||"true"!=this.headers["x-gpgauth-authenticated"]?new Error("x-gpgauth-authenticated should be set to true when GPGAuth is complete"):"string"!=typeof this.headers["x-gpgauth-progress"]||"complete"!=this.headers["x-gpgauth-progress"]?new Error("x-gpgauth-progress should be set to complete during final stage"):void 0!==this.headers["x-gpgauth-user-auth-token"]?new Error("x-gpgauth-user-auth-token should not be set during final stage"):void 0!==this.headers["x-gpgauth-verify-response"]?new Error("x-gpgauth-verify-response should not be set during final stage"):"string"==typeof this.headers["x-gpgauth-refer"]||new Error("x-gpgauth-refer should be set during final stage");default:return new Error("Unknown GPGAuth stage")}};const Ps=xs;class Ns extends dt{constructor(e){super(e,Ns.RESOURCE_NAME)}static get RESOURCE_NAME(){return"auth/verify"}async getServerKey(){const e=await this.apiClient.findAll();return this.mapGetServerKey(e.body)}mapGetServerKey(e){const{keydata:t,fingerprint:r}=e;return{armored_key:t,fingerprint:r}}async verify(e,t){const r=new FormData;r.append("data[gpg_auth][keyid]",e),r.append("data[gpg_auth][server_verify_token]",t);const s=await this.apiClient.buildFetchOptions();delete s.headers["content-type"];const i=this.apiClient.buildUrl(this.apiClient.baseUrl.toString()),a=await this.apiClient.sendRequest("POST",i,r,s);return await this.apiClient.parseResponseJson(a),a}}const Us=Ns;const Ds=class{constructor(e){this.authVerifyServerKeyService=new Us(e),this.gpgAuthToken=new Is}async verifyAndValidateServerChallenge(e,t){const r=await Je(t),s=await Rs.encrypt(this.gpgAuthToken.token,r),i=await this.authVerifyServerKeyService.verify(e,s),a=new Ps(i.headers,"verify");if(new Is(a.headers["x-gpgauth-verify-response"]).token!==this.gpgAuthToken.token)throw new Error("The server was unable to prove it can use the advertised OpenPGP key.")}};const Ms=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.authVerifyServerChallengeService=new Ds(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await ms.exec(this.worker.port._port.name),r=await Je(e);je(r);const s=r.getFingerprint().toUpperCase();await this._assertImportKeyOwnedByUser(s,t.account.serverPublicArmoredKey),t.account.userPrivateArmoredKey=r.armor(),t.account.userPublicArmoredKey=r.toPublic().armor(),t.account.userKeyFingerprint=s,await ys.set(t)}async _assertImportKeyOwnedByUser(e,t){if(!t)throw new Error("The server public key should have been provided before importing a private key");try{await this.authVerifyServerChallengeService.verifyAndValidateServerChallenge(e,t)}catch(e){throw console.error(e),new Rt(ue.t("This key does not match any account."))}}};class Ls extends dt{constructor(e){super(e,Ls.RESOURCE_NAME)}static get RESOURCE_NAME(){return"users"}static getSupportedContainOptions(){return["LastLoggedIn","is_mfa_enabled","last_logged_in","gpgkey","groups_users","profile","account_recovery_user_setting","pending_account_recovery_request"]}static getSupportedFiltersOptions(){return["search","has-groups","has-access","is-admin"]}static getSupportedOrdersOptions(){return["Profile.first_name DESC","Profile.first_name ASC","Profile.last_name DESC","Profile.last_name ASC","Profile.created DESC","Profile.created ASC","Profile.modified DESC","Profile.modified ASC"]}async get(e,t){this.assertValidId(e),t=t?this.formatContainOptions(t,Ls.getSupportedContainOptions()):null;const r={...t};return(await this.apiClient.get(e,r)).body}async findAll(e,t,r){const s=Ls.remapToLegacyContain(e);e=e?this.formatContainOptions(s,Ls.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(t,Ls.getSupportedFiltersOptions()):null,r=r?this.formatOrderOptions(r,Ls.getSupportedFiltersOptions()):null;const i={...e,...t,...r},a=await this.apiClient.findAll(i);return a.body&&a.body.length?a.body:[]}static remapToLegacyContain(e){if(e)return Object.prototype.hasOwnProperty.call(e,"last_logged_in")&&(e.LastLoggedIn=e.last_logged_in,delete e.last_logged_in),e}async create(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}async update(e,t){this.assertValidId(e),this.assertNonEmptyData(t);return(await this.apiClient.update(e,t)).body}async updateAvatar(e,t,r){this.assertValidId(e),this.assertNonEmptyData(t),this.assertNonEmptyData(r);const s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e}`),i=new FormData;i.append("profile[avatar][file]",t,r);const a=await this.apiClient.buildFetchOptions();delete a.headers["content-type"];return(await this.apiClient.fetchAndHandleResponse("POST",s,i,a)).body}async delete(e,t,r){this.assertValidId(e);const s=t?{transfer:t}:{};return(await this.apiClient.delete(e,s,{},r)).body}async resendInvite(e){const t=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover`),r={username:e},s=this.apiClient.buildBody(r);return this.apiClient.fetchAndHandleResponse("POST",t,s)}async keepSessionAlive(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/me`,{});return await this.apiClient.fetchAndHandleResponse("GET",e),!0}async requestHelpCredentialsLost(e){const t=this.apiClient.buildBody(e),r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover`,{});return(await this.apiClient.fetchAndHandleResponse("POST",r,t)).body}}const Fs=Ls;const qs=class{constructor(e){this.setupService=new Ar(e),this.userService=new Fs(e)}async startSetup(e,t){let r,s,i;if(!O().isUUID(e))throw new TypeError("userId should be a valid uuid.");if(!O().isUUID(t))throw new TypeError("authenticationTokenToken should be a valid uuid.");const a=await this.setupService.findSetupInfo(e,t),o=a?.user,n=a?.account_recovery_organization_policy,c=a?.user_passphrase_policy;return o&&(r=new lr(o)),n&&(s=new hr(n)),c&&(i=new us(c)),{user:r,accountRecoveryOrganizationPolicy:s,userPassphrasePolicies:i}}async startRecover(e,t){let r,s;if(!O().isUUID(e))throw new TypeError("userId should be a valid uuid.");if(!O().isUUID(t))throw new TypeError("authenticationTokenToken should be a valid uuid.");const i=await this.setupService.findRecoverInfo(e,t),a=i?.user,o=i?.user_passphrase_policy;return a&&(r=new lr(a)),o&&(s=new us(o)),{user:r,userPassphrasePolicies:s}}async completeSetup(e){const t=e.toCompleteSetupDto();await this.setupService.complete(e.userId,t)}async completeRecover(e){const t=e.toCompleteRecoverDto();await this.setupService.completeRecover(e.userId,t)}async abortRecover(e){const t=e.toAbortRecoverDto();await this.setupService.abort(e.userId,t)}};var Ks=r(7946);const Bs=class{static async getCurrent(){return(await Ks.tabs.query({active:!0,currentWindow:!0}))[0]}static async getById(e){return(await Ks.tabs.query({})).find((t=>t.id===parseInt(e)))}static async sendMessage(e,t,...r){const s=[t].concat(r);return Ks.tabs.sendMessage(e.tabId,s,{frameId:e.frameId})}static async reloadTab(e){await Ks.tabs.reload(e)}};const js=class{static async exec(e){0===e.frameId&&await W_.onTabRemoved(e.tabId),await Y_.exec(e)}};const zs=class{static timeoutByWorkerID={};static async get(e,t){const r=await j.getWorkersByNameAndTabId(e,t);if(0===r.length)throw new Error(`Could not find worker ${e} for tab ${t}.`);const s=r[0];W_.isPortExist(s.id)||await Bs.sendMessage(s,"passbolt.port.connect",s.id);const i=await W_.getPortById(s.id);return{port:i,tab:i._port.sender.tab}}static async waitExists(e,t,r=50){const s=async(r,i,a)=>{try{await this.get(e,t),r()}catch(e){a<=0?i(e):setTimeout(s,100,r,i,a-1)}};return new Promise(((e,t)=>{s(e,t,r)}))}static async checkAndExecNavigationForWorkerWaitingConnection(e){clearTimeout(this.timeoutByWorkerID[e.id]),this.timeoutByWorkerID[e.id]=setTimeout(this.execNavigationForWorkerWaitingConnection,50,e.id)}static async execNavigationForWorkerWaitingConnection(e){const t=await j.getWorkerById(e);if(!t)return void console.debug(`WorkerService::execNavigationForWorkerWaitingConnection(${e}): Worker not found.`);const r=new q(t);if(!r.isWaitingConnection&&!r.isReconnecting)return void console.debug(`WorkerService::execNavigationForWorkerWaitingConnection(${e}): Worker port connected to the content script application.`);const s=await Bs.getById(r.tabId),i={frameId:0,tabId:t.tabId,url:s.url};console.debug(`WorkerService::execNavigationForWorkerWaitingConnection(${e}): Trigger pagemods identification process.`),await js.exec(i)}static async destroyWorkersByName(e){this.emitOnWorkersWithName("passbolt.content-script.destroy",e)}static async emitOnWorkersWithName(e,t){const r=await j.getWorkersByNames(t);for(const t of r){if(!W_.isPortExist(t.id))try{await Bs.sendMessage(t,"passbolt.port.connect",t.id)}catch(e){console.debug("Unable to reconnect the port prior to emitting event"),console.error(e);continue}W_.getPortById(t.id).emit(e)}}};const $s=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.authVerifyServerKeyService=new Us(r),this.setupModel=new qs(r),this.temporaryAccount=null}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{await this._buildTemporaryAccountEntity(),await this._findAndSetAccountServerPublicKey();const{user:e,userPassphrasePolicies:t}=await this.setupModel.startRecover(this.temporaryAccount.account.userId,this.temporaryAccount.account.authenticationTokenToken);t&&(this.temporaryAccount.userPassphrasePolicies=t),this._setAccountUserMeta(e),await ys.set(this.temporaryAccount)}catch(e){await this._handleUnexpectedError(e)}}async _buildTemporaryAccountEntity(){const e={account:this.account.toDto(is.ALL_CONTAIN_OPTIONS),worker_id:this.worker.port._port.name};this.temporaryAccount=new ps(e)}async _findAndSetAccountServerPublicKey(){const e=await this.authVerifyServerKeyService.getServerKey(),t=await Je(e.armored_key);ze(t),this.temporaryAccount.account.serverPublicArmoredKey=t.armor()}_setAccountUserMeta(e){this.temporaryAccount.account.username=e?.username,this.temporaryAccount.account.firstName=e?.profile?.firstName,this.temporaryAccount.account.lastName=e?.profile?.lastName,e?.locale&&(this.temporaryAccount.account.locale=e.locale),e?.accountRecoveryUserSetting?.status===ar.STATUS_APPROVED&&(this.temporaryAccount.account.hasApprovedAccountRecoveryUserSetting=!0),this.temporaryAccount.account.user=e}async _handleUnexpectedError(e){throw(await zs.get("RecoverBootstrap",this.worker.tab.id)).port.emit("passbolt.recover-bootstrap.remove-iframe"),console.error(e),e}};class Vs extends Vr{constructor(e,t={}){Vs.marshal(e);const r=!1!==t?.validateUsername;super(U.validate(Vs.ENTITY_NAME,e,Vs.getSchema(r)),t),this.isUsernameValidated=r}static marshal(e){Object.assign(e,{type:Vs.TYPE_ACCOUNT})}static getSchema(e=!0){const t={type:"object",required:["type","domain","user_id","username","first_name","last_name","user_public_armored_key","user_private_armored_key","server_public_armored_key","security_token"],properties:{...Vr.getSchema().properties,type:{type:"string",enum:[Vs.TYPE_ACCOUNT]},role_name:{...Yt.getSchema().properties.name,nullable:!0}}};return e||(t.properties.username={type:"string"}),t}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.security_token&&this._security_token&&(t.security_token=this._security_token.toDto()),t):t}toLegacyUserDto(){return{id:this.userId,username:this.username,firstname:this.firstName,lastname:this.lastName,locale:this.locale}}get roleName(){return this._props.role_name}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,security_token:!0}}static get ENTITY_NAME(){return"Account"}static get TYPE_ACCOUNT(){return"Account"}}const Ys=Vs;const Gs=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountModel=new Kr(r),this.setupModel=new qs(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ms.exec(this.worker.port._port.name),t=new Ys(e.account.toDto(is.ALL_CONTAIN_OPTIONS));await this.setupModel.completeRecover(e.account),await this.accountModel.add(t)}};const Ws=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await Je(e);qe(t);const r=await Ct.getKeyInfo(t);if(r.isValid||console.warn("The private key should be a valid openpgp key."),r.revoked)throw new Error(ue.t("The private key should not be revoked."));if(r.isExpired)throw new Error(ue.t("The private key should not be expired."))}};const Hs=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.recoverModel=new qs(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ms.exec(this.worker.port._port.name);await this.recoverModel.abortRecover(e.account)}};const Js=class{constructor(e){this.keyring=e}async checkPassphrase(e){ye(e);const t=this.keyring.findPrivate();if(!t)throw new Rt(ue.t("Private key not found."));const r=await Je(t.armoredKey);await Fr.decrypt(r,e)}};class Zs extends dt{constructor(e){super(e,Zs.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/sso/settings"}static getSupportedContainOptions(){return["data"]}async get(e){he(e,"The SSO settings id should be a valid uuid.");return(await this.apiClient.get(e)).body}async getCurrent(e){const t=e?this.formatContainOptions(e,Zs.getSupportedContainOptions()):null;return(await this.apiClient.get("current",t)).body}async saveDraft(e){return(await this.apiClient.create(e)).body}async activateSettings(e,t){he(e,"The SSO settings id should be a valid uuid.");return(await this.apiClient.update(e,t)).body}async delete(e){he(e,"The SSO settings id should be a valid uuid.");return(await this.apiClient.delete(e)).body}}const Qs=Zs,Xs=["https://login.microsoftonline.com","https://login.microsoftonline.us","https://login.partner.microsoftonline.cn"],ei=/^https:\/\/login\.(microsoftonline\.(com|us)|partner\.microsoftonline\.cn)$/;class ti extends T{constructor(e,t={}){const r=ti.sanitizeDto(e);super(U.validate(ti.ENTITY_NAME,r,ti.getSchema()),t)}static getSchema(){return{type:"object",required:["url","client_id","tenant_id","client_secret","client_secret_expiry"],properties:{url:{type:"string",pattern:ei},client_id:{type:"string",format:"uuid"},tenant_id:{type:"string",format:"uuid"},client_secret:{type:"string",minLength:1},client_secret_expiry:{type:"string",format:"date-time"},email_claim:{type:"string",enum:["email","preferred_username","upn"]},prompt:{type:"string",enum:["login","none"]}}}}static sanitizeDto(e){return e=Object.assign({},e),e?.email_claim||(e.email_claim="email"),e?.prompt||(e.prompt="login"),e}static get ENTITY_NAME(){return"AzureSsoSettings"}static get PROVIDER_ID(){return"azure"}static get SUPPORTED_URLS(){return Xs}}const ri=ti,si=["https://accounts.google.com"];class ii extends T{constructor(e,t={}){super(U.validate(ii.ENTITY_NAME,e,ii.getSchema()),t)}static getSchema(){return{type:"object",required:["client_id","client_secret"],properties:{client_id:{type:"string",minLength:1},client_secret:{type:"string",minLength:1}}}}static get ENTITY_NAME(){return"GoogleSsoSettings"}static get PROVIDER_ID(){return"google"}static get SUPPORTED_URLS(){return si}}const ai=ii,oi=/^https:\/\/.+[^\/]$/;class ni extends T{constructor(e,t={}){super(U.validate(ni.ENTITY_NAME,e,ni.getSchema()),t)}static getSchema(){return{type:"object",required:["url","openid_configuration_path","scope","client_id","client_secret"],properties:{url:{type:"string",pattern:oi},openid_configuration_path:{type:"string",minLength:1},scope:{type:"string",minLength:1},client_id:{type:"string",minLength:1},client_secret:{type:"string",minLength:1}}}}static get ENTITY_NAME(){return"OAuth2SsoSettings"}static get PROVIDER_ID(){return"oauth2"}}const ci=ni,li=/^https:\/\/.+[^\/]$/;class ui extends T{constructor(e,t={}){super(U.validate(ui.ENTITY_NAME,e,ui.getSchema()),t)}static getSchema(){return{type:"object",required:["url","openid_configuration_path","scope","client_id","client_secret"],properties:{url:{type:"string",pattern:li},openid_configuration_path:{type:"string",minLength:1},scope:{type:"string",minLength:1},client_id:{type:"string",minLength:1},client_secret:{type:"string",minLength:1}}}}static validateUrl(e){if("string"!=typeof e)throw new TypeError("The url should be a string.");let t;try{t=new URL(e)}catch(e){throw new Error("The url should be a valid url.")}if("https:"!==t.protocol)throw new Error("The url protocol should be HTTPS.")}static get ENTITY_NAME(){return"ADFSSsoSettings"}static get PROVIDER_ID(){return"adfs"}}const di=ui;class pi extends T{constructor(e,t={}){super(U.validate(pi.ENTITY_NAME,e,pi.getSchema()),t),this._props.data&&(this._data=pi.buildSsoProviderSettingsFromData(this._props.provider,this._props.data,{clone:!1}),delete this._props.data)}static getSchema(){return{type:"object",required:[],properties:{id:{type:"string",format:"uuid"},providers:{type:"array",items:{type:"string"}},provider:{type:"string",enum:pi.AVAILABLE_PROVIDERS,nullable:!0},data:{type:"object"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}static buildSsoProviderSettingsFromData(e,t,r={}){switch(e){case ri.PROVIDER_ID:return new ri(t,r);case ai.PROVIDER_ID:return new ai(t,r);case ci.PROVIDER_ID:return new ci(t,r);case di.PROVIDER_ID:return new di(t,r);default:return null}}toJSON(){return this.toDto(pi.DEFAULT_CONTAIN)}toDto(e={}){const t=Object.assign({},this._props);return e?.data&&this._data&&(t.data=this._data.toDto()),t}get id(){return this._props.id}get provider(){return this._props.provider}static get ENTITY_NAME(){return"SsoSettings"}static get DEFAULT_CONTAIN(){return{data:!0}}static get AVAILABLE_PROVIDERS(){return[ri.PROVIDER_ID,ai.PROVIDER_ID,ci.PROVIDER_ID,di.PROVIDER_ID]}}const hi=pi;const gi=class{constructor(e){this.ssoSettingsService=new Qs(e)}async saveDraft(e){const t=await this.ssoSettingsService.saveDraft(e.toDto(hi.DEFAULT_CONTAIN));return new hi(t)}async getById(e){const t=await this.ssoSettingsService.get(e);return new hi(t)}async getCurrent(e){const t=await this.ssoSettingsService.getCurrent(e);return new hi(t)}async activate(e,t){const r={token:t,status:"active"},s=await this.ssoSettingsService.activateSettings(e,r);return new hi(s)}async delete(e){await this.ssoSettingsService.delete(e)}};class yi extends T{constructor(e,t={}){const r=structuredClone(e);super(U.validate(yi.ENTITY_NAME,r,yi.getSchema()),t),yi.validateNek(r.nek),yi.validateIv(r.iv1),yi.validateIv(r.iv2),this._props.nek=r.nek,this._props.iv1=r.iv1,this._props.iv2=r.iv2}static validateNek(e){const t=new R;if(e instanceof CryptoKey||t.addError("nek","type","SsoKitClientPartEntity expects an nek to be an instance of CryptoKey."),e.extractable&&t.addError("nek","type","SsoKitClientPartEntity expects an nek not to be extractable."),"AES-GCM"!==e?.algorithm?.name&&t.addError("nek","type","SsoKitClientPartEntity expects an nek to use the algorithm 'AES-GSM'."),256!==e?.algorithm?.length&&t.addError("nek","type","SsoKitClientPartEntity expects an nek to use 256 bits."),e?.usages?.includes("encrypt")||t.addError("nek","type","SsoKitClientPartEntity expects an nek to have the capability to encrypt."),e?.usages?.includes("decrypt")||t.addError("nek","type","SsoKitClientPartEntity expects an nek to have the capability to decrypt."),2!==e?.usages?.length&&t.addError("nek","type","SsoKitClientPartEntity expects an nek to only have the following capabilities: encrypt and decrypt."),t.hasErrors())throw t}static validateIv(e){const t=new R;if(e instanceof Uint8Array||t.addError("iv","type","SsoKitClientPartEntity expects IVs to be an instance of Uint8Array."),12!==e.length&&t.addError("iv","type","SsoKitClientPartEntity expects IVs to be of a length of 12 bytes."),t.hasErrors())throw t}toDto(){throw new Error("Serialization is not supported on this object")}toDbSerializableObject(){return structuredClone(this._props)}static getSchema(){return{type:"object",required:["nek","iv1","iv2","secret"],properties:{id:{type:"string",format:"uuid"},provider:{type:"string",enum:hi.AVAILABLE_PROVIDERS},nek:{type:"object"},iv1:{type:"object"},iv2:{type:"object"},secret:{type:"string"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}isRegistered(){return Boolean(this.id)&&Boolean(this.provider)}set id(e){const t=yi.getSchema();U.validateProp("id",e,t.properties.id),this._props.id=e}get id(){return this._props.id||null}set provider(e){const t=yi.getSchema();U.validateProp("provider",e,t.properties.provider),this._props.provider=e}get provider(){return this._props.provider||null}get secret(){return this._props.secret}get nek(){return this._props.nek}get iv1(){return this._props.iv1}get iv2(){return this._props.iv2}static get ENTITY_NAME(){return"SsoKitClientPartEntity"}}const mi=yi,wi="sso_kit";const _i=class{static async get(){const e=await this.getDbHandler(),t=await this.getSsoData(e);return e.close(),t}static async save(e){const t=await this.getDbHandler();await this.replaceSsoData(t,e),t.close()}static async updateLocalKitIdWith(e){const t=await this.getDbHandler();await this.updateSsoDataWithId(t,e.id),t.close()}static async updateLocalKitProviderWith(e){const t=await this.getDbHandler();await this.updateSsoDataWithProvider(t,e.provider),t.close()}static async flush(){const e=await this.getDbHandler();await this.clearData(e)}static async getDbHandler(){return new Promise(((e,t)=>{const r=indexedDB.open("sso_kit_db",1);r.onupgradeneeded=e=>{const t=e.target.result;if(console.log(`Upgrading SSO IndexedDB from version ${e.oldVersion} to version ${e.newVersion}.`),e.oldVersion<1){t.createObjectStore(wi,{keyPath:"pk_id"}).createIndex("sso_kit","sso_kit",{unique:!0})}console.log("SSO IndexedDB upgrade completed.")},r.onsuccess=()=>{e(r.result)},r.onerror=e=>{console.error("Database failed to open"),console.error(e),t()}}))}static async replaceSsoData(e,t){await this.clearData(e),await this.storeData(e,t)}static async getSsoData(e){return new Promise(((t,r)=>{const s=e.transaction([wi],"readonly").objectStore(wi).openCursor();s.onsuccess=e=>{const s=e.target.result;if(s)try{const e=new mi(s.value.sso_kit);t(e)}catch(e){console.error(e),r()}else t(null)},s.onerror=e=>{console.error("An error occured when trying to open the IndexDb cursor:",e),r()}}))}static async clearData(e){return new Promise(((t,r)=>{const s=e.transaction([wi],"readwrite").objectStore(wi).clear();s.onsuccess=()=>{console.log("IndexDB SSO client data cleared"),t()},s.onerror=e=>{console.error("The IndexedDB transaction couldn't be opened to clear the data"),console.error(e),r()}}))}static async storeData(e,t){return new Promise(((r,s)=>{const i=e.transaction([wi],"readwrite"),a=i.objectStore(wi),o=t.toDbSerializableObject();a.add({pk_id:1,sso_kit:o}).onsuccess=()=>{console.log("New SSO client data stored successfully")},i.oncomplete=()=>{r()},i.onerror=e=>{console.error("The IndexedDB transaction couldn't be opened to add new data"),console.error(e),s()}}))}static async updateSsoDataWithId(e,t){const r=await this.getSsoData(e);return new Promise(((s,i)=>{const a=e.transaction([wi],"readwrite"),o=a.objectStore(wi),n=Object.assign({},r.toDbSerializableObject(),{id:t});o.put({pk_id:1,sso_kit:n}).onsuccess=()=>{console.log("The SSO Kit identifier has been updated successfully")},a.oncomplete=()=>{s()},a.onerror=e=>{console.error("The IndexedDB transaction couldn't be opened to updated the SSO Kit"),console.error(e),i()}}))}static async updateSsoDataWithProvider(e,t){const r=await this.getSsoData(e);return new Promise(((s,i)=>{const a=e.transaction([wi],"readwrite"),o=a.objectStore(wi),n=Object.assign({},r.toDbSerializableObject(),{provider:t});o.put({pk_id:1,sso_kit:n}).onsuccess=()=>{console.log("The SSO provider has been updated successfully")},a.oncomplete=()=>{s()},a.onerror=e=>{console.error("The IndexedDB transaction couldn't be opened to updated the SSO Kit"),console.error(e),i()}}))}};var fi=r(8287);class vi extends T{constructor(e,t={}){super(U.validate(vi.ENTITY_NAME,e,vi.getSchema()),t)}static getSchema(){return{type:"object",required:["data"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},data:{type:"x-custom",validationCallback:vi.validateData},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}static validateData(e){if("string"!=typeof e)throw new TypeError("The data should be a string");if(!O().isBase64(e))throw new TypeError("The data should be a base64 formated string");const t=JSON.parse(fi.hp.from(e,"base64").toString());if("A256GCM"!==t.alg)throw new TypeError("The SSO server key should use the algorithm AES 256 bits");if(!t.ext)throw new TypeError("The SSO server key should be extractable");if("oct"!==t.kty)throw new TypeError("The SSO server key type should be an octect sequence");if("string"!=typeof t.k)throw new TypeError("The SSO server key data should be a string");const r=t.key_ops;if(!(2===r.length&&r.includes("encrypt")&&r.includes("decrypt")))throw new TypeError("The SSO server key be usable for and only for encryption and decryption")}get id(){return this._props.id}get data(){return this._props.data}get key(){return JSON.parse(fi.hp.from(this.data,"base64").toString())}static get ENTITY_NAME(){return"SsoKitServerPartEntity"}}const Si=vi;const bi=class{static async encrypt(e,t,r,s,i){we(t),_e(r),fe(s),fe(i);const a=fi.hp.from(e),o={name:t.algorithm.name,iv:s},n={name:r.algorithm.name,iv:i},c=await crypto.subtle.encrypt(o,t,a),l=await crypto.subtle.encrypt(n,r,c);return fi.hp.from(l).toString("base64")}};const Ei=class{static generateIv(e=12){return crypto.getRandomValues(new Uint8Array(e))}};const ki=class{static async generateSsoKey(e=!1){return crypto.subtle.generateKey({name:"AES-GCM",length:256},e,["encrypt","decrypt"])}};var Ai=r(7946);const Ti=new k,Ii="temp_server_part_sso_kit";const Ri=class{static async set(e){await Ti.acquire();try{await Ai.storage.session.set({[Ii]:e.toDto()})}catch(e){throw Ti.release(),e}Ti.release()}static async getAndFlush(){await Ti.acquire();try{const e=await Ai.storage.session.get(Ii),t=e?.[Ii]||null;if(!t)return Ti.release(),null;const r=new Si(t);return m.write({level:"debug",message:"SsoKitTemporaryStorageService flushed"}),await Ai.storage.session.remove(Ii),Ti.release(),r}catch(e){throw Ti.release(),e}}static async flush(){await Ti.acquire();try{m.write({level:"debug",message:"SsoKitTemporaryStorageService flushed"}),await Ai.storage.session.remove(Ii)}catch(e){throw Ti.release(),e}Ti.release()}};const Ci=class{static async generate(e,t){try{const r=await this.generateSsoKits(e,t);await _i.save(r.clientPart),await Ri.set(r.serverPart)}catch(e){throw await _i.flush(),await Ri.flush(),e}}static async generateSsoKits(e,t){const r=await ki.generateSsoKey(),s=await ki.generateSsoKey(!0),i=Ei.generateIv(),a=Ei.generateIv(),o=await bi.encrypt(e,r,s,i,a),n=new mi({nek:r,iv1:i,iv2:a,secret:o,provider:t}),c=await crypto.subtle.exportKey("jwk",s),l=fi.hp.from(JSON.stringify(c)).toString("base64");return{clientPart:n,serverPart:new Si({data:l})}}};class Oi extends dt{constructor(e){super(e,Oi.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/sso/keys"}async getSsoKit(e,t,r){he(e,"The SSO kit id should be a valid uuid."),he(t,"The user id should be a valid uuid."),he(r,"The SSO token should be a valid uuid.");return(await this.apiClient.get(`${e}/${t}/${r}`)).body}async setupSsoKit(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}async deleteSsoKit(e){he(e,"The SSO kit id should be a valid uuid."),await this.apiClient.delete(e)}}const xi=Oi;const Pi=class{constructor(e){this.ssoKitServerPartService=new xi(e)}async getSsoKit(e,t,r){he(e,"The SSO kit id should be a valid uuid."),he(t,"The user id should be a valid uuid."),he(r,"The SSO token should be a valid uuid.");const s=await this.ssoKitServerPartService.getSsoKit(e,t,r);return new Si(s)}async setupSsoKit(e){const t=await this.ssoKitServerPartService.setupSsoKit(e);return new Si(t)}async deleteSsoKit(e){he(e,"The SSO kit id should be a valid uuid."),await this.ssoKitServerPartService.deleteSsoKit(e)}};const Ni=class{constructor(e){this.organisationSettingsModel=new wt(e),this.ssoSettingsModel=new gi(e),this.ssoKitServerPartModel=new Pi(e)}async forceUpdateSsoKit(e){await _i.flush(),await this.updateSsoKitIfNeeded(e)}async updateSsoKitIfNeeded(e){const t=await _i.get();if(!(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("sso"))return void(t&&await _i.flush());let r;try{r=await this.ssoSettingsModel.getCurrent()}catch(e){if(e instanceof R)return void console.error(e);throw e}!r?.provider&&t?await _i.flush():r?.provider&&!t&&await Ci.generate(e,r.provider)}};class Ui extends dt{constructor(e){super(e,Ui.RESOURCE_NAME)}static get RESOURCE_NAME(){return"auth/login"}async loginStage1(e){const t=new FormData;t.append("data[gpg_auth][keyid]",e);const r=await this.apiClient.buildFetchOptions();delete r.headers["content-type"];const s=this.apiClient.buildUrl(this.apiClient.baseUrl.toString()),i=await this.apiClient.sendRequest("POST",s,t,r);return await this.apiClient.parseResponseJson(i),i}async loginStage2(e,t){const r=new FormData;r.append("data[gpg_auth][keyid]",t),r.append("data[gpg_auth][user_token_result]",e);const s=await this.apiClient.buildFetchOptions();delete s.headers["content-type"];const i=this.apiClient.buildUrl(this.apiClient.baseUrl.toString()),a=await this.apiClient.sendRequest("POST",i,r,s);return await this.apiClient.parseResponseJson(a),a}}const Di=Ui;const Mi=class{static async decryptSymmetrically(e,t,r=null){r&&Ve(r),Me(e);const{data:s,signatures:i}=await ae.Yc({message:e,passwords:[t],verificationKeys:r,expectSigned:Boolean(r)});return r&&await this.doSignatureVerification(i),s}static async decryptWithSessionKey(e,t,r=null){r&&Ve(r),Me(e),$e(t);const{data:s,signatures:i}=await ae.Yc({message:e,sessionKeys:t,verificationKeys:r,expectSigned:Boolean(r)});return r&&await this.doSignatureVerification(i),s}static async decrypt(e,t,r=null){Me(e),Be(t),r&&Ve(r);const{data:s,signatures:i}=await ae.Yc({message:e,decryptionKeys:t,verificationKeys:r,expectSigned:Boolean(r)});return r&&await this.doSignatureVerification(i),s}static async doSignatureVerification(e){const t=e.map((e=>e.verified));await Promise.all(t)}};var Li=r(4375),Fi=r.n(Li),qi=r(8838),Ki=r.n(qi);const Bi=class{static async decryptToken(e,t,r){if("string"!=typeof e)throw new TypeError("The encrypted user auth token should be string.");if("string"!=typeof t)throw new TypeError("The user private armored key should be string.");if("string"!=typeof r)throw new TypeError("The passphrase should be string.");const s=Fi()(Ki()(e)),i=await Je(t),a=await Fr.decrypt(i,r),o=await Ge(s),n=await Mi.decrypt(o,a);return new Is(n).token}};const ji=class{constructor(e){this.authLoginService=new Di(e)}async verifyAndValidateLoginChallenge(e,t,r){const s=await this.authLoginService.loginStage1(e),i=new Ps(s.headers,"stage1").headers["x-gpgauth-user-auth-token"],a=await Bi.decryptToken(i,t,r),o=await this.authLoginService.loginStage2(a,e);new Ps(o.headers,"complete")}};class zi extends Error{constructor(e){super(e=e||"The user passphrase is required."),this.name="UserPassphraseRequiredError"}}const $i=zi;var Vi=r(7946);const Yi="passphrase";class Gi{static async set(e,t){await navigator.locks.request(Yi,(async()=>{await Vi.storage.session.set({[Yi]:e})})),Gi._clearFlushAlarms(),t>=0&&Vi.alarms.create(Gi.ALARM_NAME,{when:Date.now()+1e3*t})}static async get(){const e=await Vi.storage.session.get(Yi);return e?.[Yi]||null}static async getOrFail(){const e=await this.get();if(!e)throw new $i;return e}static async flush(){return m.write({level:"debug",message:"PassphraseStorageService flushed"}),Promise.all([Gi.flushPassphrase(),Gi._clearFlushAlarms()])}static flushPassphrase(){return navigator.locks.request(Yi,(()=>Vi.storage.session.remove(Yi)))}static _clearFlushAlarms(){return Vi.alarms.clear(Gi.ALARM_NAME)}static async handleFlushEvent(e){e.name===Gi.ALARM_NAME&&await Gi.flush()}static get ALARM_NAME(){return"PassphraseStorageFlush"}}const Wi=Gi;var Hi=r(7946);function Ji(e){Hi.action.setIcon({path:{32:e||"/webAccessibleResources/img/icons/icon-32.png"}})}const Zi={activate:function(){Ji("/webAccessibleResources/img/icons/icon-32.png")},deactivate:function(){Ji("/webAccessibleResources/img/icons/icon-32-signout.png")},setSuggestedResourcesCount:function(e){if(e>0){Ji(e<=5?`/webAccessibleResources/img/icons/icon-32-badge-${e}.png`:"/webAccessibleResources/img/icons/icon-32-badge-5+.png")}else Ji("/webAccessibleResources/img/icons/icon-32.png")}},Qi=function(){};Qi.getToolbarUrl=function(){const e=re.getInstance();return e.isValid()?e.settings.getDomain():"https://www.passbolt.com/start"};const Xi=Qi,ea=function(e){chrome.tabs.create({url:e})};const ta=class{static buildFromAccount(e){return this.buildFromDomain(e.domain)}static buildFromDomain(e){return(new Z).setBaseUrl(e)}};const ra=class extends Xt{get entityClass(){return lr}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:lr.getSchema()}}validateBuildRules(e,t){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertNotExist("username",e._props.username,{haystackSet:t?.uniqueUsernamesSetCache})}get users(){return this._items}get ids(){return this._items.map((e=>e.id))}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.extract("username"));r={onItemPushed:e=>{s.add(e.id),i.add(e.username)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueUsernamesSetCache:i},...r},super.pushMany(e,t,r)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"Users"}};var sa=r(7946);const ia=new k;class aa{static async flush(){return m.write({level:"debug",message:"UserLocalStorage flushed"}),await sa.storage.local.remove(aa.USER_LOCAL_STORAGE_KEY)}static async get(){const{users:e}=await sa.storage.local.get([aa.USER_LOCAL_STORAGE_KEY]);return e}static async set(e){await ia.acquire();const t=[];if(!(e instanceof ra))throw new TypeError("UserLocalStorage::set expects a UsersCollection");for(const r of e)aa.assertEntityBeforeSave(r),t.push(r.toDto(aa.DEFAULT_CONTAIN));await sa.storage.local.set({users:t}),ia.release()}static async getUserById(e){return(await aa.get()).find((t=>t.id===e))}static async addUser(e){await ia.acquire();try{aa.assertEntityBeforeSave(e);const t=await aa.get();t.push(e.toDto(aa.DEFAULT_CONTAIN)),await sa.storage.local.set({users:t}),ia.release()}catch(e){throw ia.release(),e}}static async updateUser(e){await ia.acquire();try{aa.assertEntityBeforeSave(e);const t=await aa.get();if(t){const r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The user could not be found in the local storage");t[r]=Object.assign(t[r],e.toDto(aa.DEFAULT_CONTAIN)),await sa.storage.local.set({users:t})}ia.release()}catch(e){throw ia.release(),e}}static async delete(e){await ia.acquire();try{const t=await aa.get();if(t){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await sa.storage.local.set({users:t}),ia.release()}}catch(e){throw ia.release(),e}}static get DEFAULT_CONTAIN(){return{profile:{avatar:!0},pending_account_recovery_request:!0,account_recovery_user_setting:!0}}static get USER_LOCAL_STORAGE_KEY(){return"users"}static assertEntityBeforeSave(e){if(!e)throw new TypeError("UserLocalStorage expects a UserEntity to be set");if(!(e instanceof lr))throw new TypeError("UserLocalStorage expects an object of type UserEntity");if(!e.id)throw new TypeError("UserLocalStorage expects UserEntity id to be set");if(!e.profile)throw new TypeError("UserLocalStorage::set expects UserEntity profile to be set");if(!e.profile.avatar)throw new TypeError("UserLocalStorage::set expects UserEntity avatar to be set")}}const oa=aa;class na extends $t{constructor(e,t={}){super(e,t),this._props.groups_users&&(this._groups_users=new tr(this._props.groups_users,{...t,clone:!1}),delete this._props.groups_users),this._props.my_group_user&&(this._my_group_user=new er(this._props.my_group_user,{...t,clone:!1}),delete this._props.my_group_user),this._props.creator&&(this._creator=new lr(this._props.creator,{...t,clone:!1}),delete this._props.creator),this._props.modifier&&(this._modifier=new lr(this._props.modifier,{...t,clone:!1}),delete this._props.modifier)}static getSchema(){return{type:"object",required:["name"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",minLength:1,maxLength:255},deleted:{type:"boolean"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},groups_users:tr.getSchema(),my_group_user:er.getSchema(),creator:lr.getSchema(),modifier:lr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._groups_users&&e.groups_users&&(!0===e.groups_users?t.groups_users=this._groups_users.toDto():t.groups_users=this._groups_users.toDto(e.groups_users)),this._my_group_user&&e.my_group_user&&(t.my_group_user=this._my_group_user.toDto()),this._creator&&e.creator&&(!0===e.creator?t.creator=this._creator.toDto():t.creator=this._creator.toDto(e.creator)),this._modifier&&e.modifier&&(!0===e.modifier?t.modifier=this._modifier.toDto():t.modifier=this._modifier.toDto(e.modifier)),t):t}toJSON(){return this.toDto(na.ALL_CONTAIN_OPTIONS)}static get ALL_CONTAIN_OPTIONS(){return{creator:lr.ALL_CONTAIN_OPTIONS,modifier:lr.ALL_CONTAIN_OPTIONS,groups_users:er.ALL_CONTAIN_OPTIONS,my_group_user:er.ALL_CONTAIN_OPTIONS}}get id(){return this._props.id||null}get name(){return this._props.name}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get createdBy(){return this._props.created_by||null}get modifiedBy(){return this._props.modified_by||null}get groupsUsers(){return this._groups_users||null}get myGroupUser(){return this._my_group_user||null}static get ENTITY_NAME(){return"Group"}}const ca=na;const la=class extends Xt{get entityClass(){return ca}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:ca.getSchema()}}validateBuildRules(e,t){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertNotExist("name",e._props.name,{haystackSet:t?.uniqueNamesSetCache})}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.extract("name"));r={onItemPushed:e=>{s.add(e.id),i.add(e.name)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueNamesSetCache:i},...r},super.pushMany(e,t,r)}get groups(){return this._items}get ids(){return this._items.map((e=>e.id))}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"Groups"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_GROUP_NAME(){return"unique_group_name"}};class ua extends $t{constructor(e,t={}){super(e,t),this._props.user&&(this._user=new lr(this._props.user,{...t,clone:!1}),delete this._props.user),this._props.group&&(this._group=new ca(this._props.group,{...t,clone:!1}),delete this._props.group)}static getSchema(){return{type:"object",required:["aco","aro","aco_foreign_key","aro_foreign_key","type"],properties:{id:{type:"string",format:"uuid"},aco:{type:"string",enum:[ua.ACO_FOLDER,ua.ACO_RESOURCE]},aco_foreign_key:{type:"string",format:"uuid"},aro:{type:"string",enum:[ua.ARO_GROUP,ua.ARO_USER]},aro_foreign_key:{type:"string",format:"uuid"},type:{type:"integer",enum:ua.PERMISSION_TYPES},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},user:lr.getSchema(),group:ca.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._user&&e.user&&(!0===e.user?t.user=this._user.toDto():t.user=this._user.toDto(e.user)),this._group&&e.group&&(t.group=this._group.toDto()),t):t}toJSON(){return this.toDto(ua.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get aco(){return this._props.aco}get aro(){return this._props.aro}get aroForeignKey(){return this._props.aro_foreign_key}get acoForeignKey(){return this._props.aco_foreign_key}get type(){return this._props.type}isOwner(){return this.type===ua.PERMISSION_OWNER}static get ENTITY_NAME(){return"Permission"}static get PERMISSION_OWNER(){return 15}static get PERMISSION_UPDATE(){return 7}static get PERMISSION_READ(){return 1}static get ARO_GROUP(){return"Group"}static get ARO_USER(){return"User"}static get ACO_RESOURCE(){return"Resource"}static get ACO_FOLDER(){return"Folder"}static get ALL_CONTAIN_OPTIONS(){return{user:{profile:{avatar:!0}},group:!0}}static get PERMISSION_TYPES(){return[ua.PERMISSION_READ,ua.PERMISSION_UPDATE,ua.PERMISSION_OWNER]}get user(){return this._user||null}get group(){return this._group||null}set id(e){if(!O().isUUID(e))throw new TypeError("The permission id should be a valid UUID.");this._props.id=e}set type(e){if(!e||!ua.PERMISSION_TYPES.includes(e))throw new TypeError("The type should be a valid integer.");this._props.type=e}static assertIsPermission(e){if(!(e&&e instanceof ua))throw new TypeError("Failed to assert the parameter is a valid permission")}static assertArePermissions(e,t){ua.assertIsPermission(e),ua.assertIsPermission(t)}static isIdMatching(e,t){return ua.assertArePermissions(e,t),e.id===t.id}static isAroMatching(e,t){return ua.assertArePermissions(e,t),e.aro===t.aro&&e.aroForeignKey===t.aroForeignKey}static isAcoMatching(e,t){return ua.assertArePermissions(e,t),e.aco===t.aco&&e.acoForeignKey===t.acoForeignKey}static isAcoAndAroMatching(e,t){return ua.assertArePermissions(e,t),ua.isAcoMatching(e,t)&&ua.isAroMatching(e,t)}static isTypeMatching(e,t){return ua.assertArePermissions(e,t),e.type===t.type}static isMatchingAroAcoType(e,t){return ua.assertArePermissions(e,t),ua.isAcoAndAroMatching(e,t)&&ua.isTypeMatching(e,t)}static getHighestPermissionType(e,t){return ua.assertArePermissions(e,t),e.type>t.type?e.type:t.type}static getHighestPermission(e,t){return ua.assertArePermissions(e,t),e.type>t.type?e:t}copyForAnotherAco(e,t){return new ua({aro:this.aro,aro_foreign_key:this.aroForeignKey,aco:e,aco_foreign_key:t,type:this.type})}}const da=ua;class pa extends Xt{get entityClass(){return da}constructor(e=[],t={}){super(e,t)}toDto(e){const t=[];e||(e=da.ALL_CONTAIN_OPTIONS);for(const r of this)t.push(r.toDto(e));return t}toJSON(){return this.toDto(da.ALL_CONTAIN_OPTIONS)}static getSchema(){return{type:"array",items:da.getSchema()}}validateBuildRules(e,t={}){this.assertItemSameAco(e),this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertNotExist("aro_foreign_key",e._props.aro_foreign_key,{haystackSet:t?.uniqueAroForeignKeysSetCache})}assertItemSameAco(e){if(!this.permissions.length)return;const t=this.permissions[0];if(!da.isAcoMatching(e,t)){const e=new R,r=`The collection is already composed of this type of aco: ${t.aco} / aco_foreign_key: ${t.acoForeignKey}.`;throw e.addError("aco_foreign_key",pa.RULE_SAME_ACO,r),e}}assertAtLeastOneOwner(){if(!this.length)return;if(this.items.some((e=>e.isOwner())))return;const e=new P;throw e.addCollectionValidationError(pa.RULE_ONE_OWNER,"Permission collection should contain at least one owner."),e}get permissions(){return this._items}getByAroMatchingPermission(e){return this._items.find((t=>da.isAroMatching(t,e)))}getByAro(e,t){return this._items.find((r=>r.aro===e&&r.aroForeignKey===t))}pushMany(e,t={},r={}){const s=t?.assertAtLeastOneOwner??!0,i=new Set(this.extract("id")),a=new Set(this.extract("aro_foreign_key"));r={onItemPushed:e=>{i.add(e.id),a.add(e.aroForeignKey)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:i,uniqueAroForeignKeysSetCache:a},...r},super.pushMany(e,t,r),s&&this.assertAtLeastOneOwner()}addOrReplace(e){e=this.buildOrCloneEntity(e);const t=this.items.findIndex((t=>(!t.id||!e._props.id||t.id===e._props.id)&&da.isAcoAndAroMatching(t,e)));if(-1===t)return void this.push(e);const r=this._items[t];if(!(e.type<=r.type)){this._items.splice(t,1);try{this.validateBuildRules(e),this._items.splice(t,0,e)}catch(e){throw this._items.splice(t,0,r),e}}}static sum(e,t,r=!0){const s=new pa(e.toDto(),{assertAtLeastOneOwner:!1});return t.items.forEach(((e,r)=>{try{s.addOrReplace(e)}catch(e){t.handlePushItemError(r,e)}})),r&&s.assertAtLeastOneOwner(),s}static diff(e,t,r=!0){const s=new pa([],{assertAtLeastOneOwner:!1});for(const r of e)t.containAtLeastPermission(r.aro,r.aroForeignKey,r.type)||s.push(r);return r&&s.assertAtLeastOneOwner(),s}containAtLeastPermission(e,t,r){for(const s of this.items)if(s.aro===e&&s.aroForeignKey===t&&s.type>=r)return!0;return!1}cloneForAco(e,t,r=!0){const s=new pa([],{assertAtLeastOneOwner:!1});for(const r of this.permissions){const i=r.copyForAnotherAco(e,t);s.addOrReplace(i)}return r&&s.assertAtLeastOneOwner(),s}static get ENTITY_NAME(){return"Permissions"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_ARO(){return"unique_aro"}static get RULE_SAME_ACO(){return"same_aco"}static get RULE_ONE_OWNER(){return"owner"}}const ha=pa,ga="Resource";const ya=class extends $t{static getSchema(){return{type:"object",required:["id","user_id","foreign_key","created"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},foreign_key:{type:"string",format:"uuid"},created:{type:"string",format:"date-time"}}}}get id(){return this._props.id}get userId(){return this._props.user_id}get foreignKey(){return this._props.foreign_key}get created(){return this._props.created||null}static get ENTITY_NAME(){return"Favorite"}static get FAVORITE_RESOURCE(){return ga}static get ALLOWED_FOREIGN_MODELS(){return[ga]}},ma="v4",wa="v5";class _a extends $t{static getSchema(){return{type:"object",required:["default_resource_types","default_folder_type","default_tag_type","default_comment_type","allow_creation_of_v5_resources","allow_creation_of_v5_folders","allow_creation_of_v5_tags","allow_creation_of_v5_comments","allow_creation_of_v4_resources","allow_creation_of_v4_folders","allow_creation_of_v4_tags","allow_creation_of_v4_comments"],properties:{default_resource_types:{type:"string",enum:[ma,wa]},default_folder_type:{type:"string",enum:[ma,wa]},default_tag_type:{type:"string",enum:[ma,wa]},default_comment_type:{type:"string",enum:[ma,wa]},allow_creation_of_v5_resources:{type:"boolean"},allow_creation_of_v5_folders:{type:"boolean"},allow_creation_of_v5_tags:{type:"boolean"},allow_creation_of_v5_comments:{type:"boolean"},allow_creation_of_v4_resources:{type:"boolean"},allow_creation_of_v4_folders:{type:"boolean"},allow_creation_of_v4_tags:{type:"boolean"},allow_creation_of_v4_comments:{type:"boolean"}}}}static createFromV4Default(){return new _a({default_resource_types:"v4",default_folder_type:"v4",default_tag_type:"v4",default_comment_type:"v4",allow_creation_of_v5_resources:!1,allow_creation_of_v5_folders:!1,allow_creation_of_v5_tags:!1,allow_creation_of_v5_comments:!1,allow_creation_of_v4_resources:!0,allow_creation_of_v4_folders:!0,allow_creation_of_v4_tags:!0,allow_creation_of_v4_comments:!0})}static createFromDefault(e={}){return new _a({default_resource_types:"v4",default_folder_type:"v4",default_tag_type:"v4",default_comment_type:"v4",allow_creation_of_v5_resources:!1,allow_creation_of_v5_folders:!1,allow_creation_of_v5_tags:!1,allow_creation_of_v5_comments:!1,allow_creation_of_v4_resources:!0,allow_creation_of_v4_folders:!0,allow_creation_of_v4_tags:!0,allow_creation_of_v4_comments:!0,...e})}get defaultResourceTypes(){return this._props.default_resource_types}get allowCreationOfV5Resources(){return this._props.allow_creation_of_v5_resources}get allowCreationOfV4Resources(){return this._props.allow_creation_of_v4_resources}get isDefaultResourceTypeV5(){return this._props.default_resource_types===wa}get isDefaultResourceTypeV4(){return this._props.default_resource_types===ma}}const fa=_a,va="password-string",Sa="password-and-description",ba="password-description-totp",Ea="totp",ka="v5-default",Aa="v5-password-string",Ta="v5-default-with-totp",Ia="v5-totp-standalone",Ra={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},username:{type:"string",maxLength:255,nullable:!0},description:{maxLength:1e4,nullable:!0,type:"string"},uri:{type:"string",maxLength:1024,nullable:!0}}},secret:{type:"string",maxLength:4096}},Ca={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},username:{type:"string",maxLength:255,nullable:!0},uri:{type:"string",maxLength:1024,nullable:!0}}},secret:{type:"object",required:["password"],properties:{password:{type:"string",maxLength:4096},description:{type:"string",maxLength:1e4,nullable:!0}}}},Oa={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},uri:{type:"string",maxLength:1024,nullable:!0}}},secret:{type:"object",required:["totp"],properties:{totp:{type:"object",required:["secret_key","digits","algorithm"],properties:{algorithm:{type:"string",minLength:4,maxLength:6},secret_key:{type:"string",maxLength:1024},digits:{type:"number",minimum:6,maximum:8},period:{type:"number"}}}}}},xa={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},username:{type:"string",maxLength:255,nullable:!0},uri:{type:"string",maxLength:1024,nullable:!0}}},secret:{type:"object",required:["password","totp"],properties:{password:{type:"string",maxLength:4096},description:{type:"string",maxLength:1e4,nullable:!0},totp:Oa.secret.properties.totp}}},Pa={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},username:{type:"string",maxLength:255,nullable:!0},uris:{type:"array",items:{type:"string",maxLength:1024,nullable:!0}},description:{type:"string",maxLength:1e4,nullable:!0}}},secret:{type:"object",required:["password"],properties:{password:{type:"string",maxLength:4096},description:{type:"string",maxLength:1e4,nullable:!0}}}},Na={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},username:{type:"string",maxLength:255,nullable:!0},uris:{type:"array",items:{type:"string",maxLength:1024,nullable:!0}},description:{type:"string",maxLength:1e4,nullable:!0}}},secret:{type:"string",maxLength:4096}},Ua={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},username:{type:"string",maxLength:255,nullable:!0},uris:{type:"array",items:{type:"string",maxLength:1024,nullable:!0}},description:{type:"string",maxLength:1e4,nullable:!0}}},secret:{type:"object",required:["password","totp"],properties:{password:{type:"string",maxLength:4096},description:{type:"string",maxLength:1e4,nullable:!0},totp:Oa.secret.properties.totp}}},Da={resource:{type:"object",required:["name"],properties:{name:{type:"string",maxLength:255},uris:{type:"array",items:{type:"string",maxLength:1024,nullable:!0}},description:{type:"string",maxLength:1e4,nullable:!0}}},secret:Oa.secret};const Ma=new class{get SCHEMAS(){return{[va]:Ra,[Sa]:Ca,[ba]:xa,[Ea]:Oa,[ka]:Pa,[Aa]:Na,[Ta]:Ua,[Ia]:Da}}},La=[va,Sa,ba,ka,Ta,Aa],Fa=[ba,Ea,Ta,Ia],qa=[Ea,Ia],Ka=[va,Aa],Ba=[Sa,ba,ka,Ta],ja=[va,ka,Ta,Aa,Ia];const za=class extends $t{marshall(){if("string"!=typeof this._props.slug||!(this._props.slug in Ma.SCHEMAS))return void delete this._props.definition;const e=Ma.SCHEMAS[this._props.slug],t=Object.assign({},e);this._props.definition=t}static getSchema(){return{type:"object",required:["id","name","slug","definition"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",minLength:1,maxLength:255},slug:{type:"string",minLength:1,maxLength:64},definition:{type:"object"},description:{type:"string",maxLength:255,nullable:!0},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id}get slug(){return this._props.slug}get definition(){return this._props.definition}hasTotp(){return Fa.includes(this.slug)}hasPassword(){return La.includes(this.slug)}isStandaloneTotp(){return qa.includes(this.slug)}isPasswordString(){return Ka.includes(this.slug)}hasSecretDescription(){return Ba.includes(this.slug)}hasMetadataDescription(){return ja.includes(this.slug)}get version(){return this.slug.startsWith("v5")?wa:ma}isV5(){return this.version===wa}isV4(){return this.version===ma}};const $a=class extends $t{constructor(e,t={}){super(e,t)}marshall(){void 0===this._props.is_shared&&"string"==typeof this._props.slug&&(this._props.is_shared=this._props.slug?.startsWith("#")),super.marshall()}static getSchema(){return{type:"object",required:["slug"],properties:{id:{type:"string",format:"uuid"},slug:{type:"string",minLength:1,maxLength:128},is_shared:{type:"boolean"}}}}validateBuildRules(e={}){if(this.slug.startsWith("#")&&!this.isShared){new R("Invalid tag").addError("is_shared","hashtag","A shared tag should start with a hashtag.")}}get id(){return this._props.id||null}get slug(){return this._props.slug}get isShared(){return this._props.is_shared}static get ENTITY_NAME(){return"Tag"}};const Va=class extends Xt{get entityClass(){return $a}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:$a.getSchema()}}validateBuildRules(e,t){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache})}get tags(){return this._items}pushMany(e,t={},r={}){const s=new Set(this.extract("id"));r={onItemPushed:e=>{s.add(e.id)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s},...r},super.pushMany(e,t,r)}removeById(e){const t=this.tags.length;let r=0;for(;r<t;r++){if(this.tags[r].id===e)return this._items.splice(r,1),!0}return!1}replaceTag(e,t){if(!e)return!1;const r=this.tags.length;let s=0;for(;s<r;s++){if(this.tags[s].id===e)return this._items[s]=t,!0}return!1}static get ENTITY_NAME(){return"Tags"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_SLUG(){return"unique_slug"}};class Ya extends $t{constructor(e,t={}){super(e,t)}static getSchema(){return{type:"object",required:["data"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},resource_id:{type:"string",format:"uuid"},data:{type:"string"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}validateBuildRules(){Ya.assertValidMessage(this._props.data)}get id(){return this._props.id||null}get data(){return this._props.data}get userId(){return this._props.user_id||null}get resourceId(){return this._props.resource_id||null}static assertValidMessage(e){const t=new R("This is not a valid OpenPGP armored message");if(!e||"string"!=typeof e||""===e)throw t.addError("data","empty","The OpenPGP armored message should not be empty."),t;if(!e.match(/-----BEGIN PGP MESSAGE-----/))throw t.addError("data","begin","The OpenPGP armored message should contain a start delimiter."),t;if(!e.match(/-----END PGP MESSAGE-----/))throw t.addError("data","end","The OpenPGP armored message should contain an end delimiter."),t}}const Ga=Ya;class Wa extends Xt{get entityClass(){return Ga}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:Ga.getSchema()}}validateBuildRules(e,t){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertNotExist("user_id",e._props.user_id,{haystackSet:t?.uniqueUsersIdsSetCache}),this.assertSameResource(e)}assertSameResource(e){if(!this.secrets.length)return;if(void 0===e._props.resource_id)return;const t=this.secrets[0].resourceId;if(e._props.resource_id!==t){const e=new R,r=`The collection is already used for another resource with id ${t}.`;throw e.addError("resource_id",Wa.BUILD_RULE_SAME_RESOURCE,r),e}}get secrets(){return this._items}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.extract("user_id"));r={onItemPushed:e=>{s.add(e.id),i.add(e.userId)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueUsersIdsSetCache:i},...r},super.pushMany(e,t,r)}static get ENTITY_NAME(){return"ResourceSecrets"}static get BUILD_RULE_SAME_RESOURCE(){return"same_resource"}}const Ha=Wa;var Ja=r(3975);const Za=function(e){let t,r="",s="",i="",a=!1;/^[a-zA-Z\-]*:\/\//.test(e)||(a=!0,e=`fake://${e}`);try{t=new URL(e)}catch(e){return!1}return i=t.port,a?(t.protocol="https:",s=t.hostname):(r=t.protocol,s=t.hostname),{protocol:r,hostname:s,port:i}},Qa=et()("^[\\p{L}\\p{N}.-]*$"),Xa=function(e,t){if(!(t&&e&&Qa.test(t)&&Qa.test(e)))return!1;const r=t.lastIndexOf(e);return-1!==r&&r+e.length===t.length&&(void 0===t[r-1]||"."===t[r-1])},eo=function(e,t){let r;try{r=new URL(e)}catch(e){return!1}const s=Za(t);if(!r||!r.hostname)return!1;if(!s||!s.hostname)return!1;if(s.protocol&&r.protocol!==s.protocol)return!1;if(s.port&&r.port!==s.port)return!1;if(r.hostname===s.hostname)return!0;const i=(0,Ja.A)({exact:!0}).test(r.hostname),a=(0,Ja.A)({exact:!0}).test(s.hostname);return i||a?r.hostname===s.hostname:-1!==s.hostname.indexOf(".")&&Xa(s.hostname,r.hostname)},to="PASSBOLT_RESOURCE_METADATA";const ro=class extends $t{static getSchema(){return{type:"object",required:["name","resource_type_id"],properties:{object_type:{type:"string",enum:[to]},resource_type_id:{type:"string",format:"uuid"},name:{type:"string",maxLength:255},username:{type:"string",maxLength:255,nullable:!0},uris:{type:"array",items:{type:"string",maxLength:1024}},description:{type:"string",maxLength:1e4,nullable:!0}}}}get objectType(){return this._props.object_type}get name(){return this._props.name}get username(){return this._props.username}get description(){return this._props.description||null}get resourceTypeId(){return this._props.resource_type_id}get uris(){return this._props.uris||[]}static get ENTITY_NAME(){return"ResourceMetadataEntity"}static get METADATA_OBJECT_TYPE(){return to}static get URI_MAX_LENGTH(){return 1024}},so="user_key",io="shared_key",ao=[so,io];class oo extends $t{constructor(e,t={}){super(e,t),this._props.permission&&(this._permission=new da(this._props.permission,{...t,clone:!1}),oo.assertValidPermission(this._permission,this.id),delete this._props.permission),this._props.permissions&&(this._permissions=new ha(this._props.permissions,{...t,clone:!1}),oo.assertValidPermissions(this._permissions,this.id),delete this._props.permissions),this._props.secrets&&(this._secrets=new Ha(this._props.secrets,{...t,clone:!1}),oo.assertValidSecrets(this._secrets,this.id),delete this._props.secrets),this._props.favorite&&(this._favorite=new ya(this._props.favorite,{...t,clone:!1}),oo.assertValidFavorite(this._favorite,this.id),delete this._props.favorite),this._props.tags&&(this._tags=new Va(this._props.tags,{...t,clone:!1}),delete this._props.tags),this._props.creator&&(this._creator=new lr(this._props.creator,{...t,clone:!1}),delete this._props._creator),this._props.modifier&&(this._modifier=new lr(this._props.modifier,{...t,clone:!1}),delete this._props._modifier),this._props.metadata&&"string"!=typeof this._props.metadata&&(this._metadata=new ro(this._props.metadata,{...t,clone:!1}),delete this._props.metadata)}marshall(){oo.transformDtoFromV4toV5(this._props)}validateBuildRules(){if(Boolean(this._props.metadata)&&Boolean(this._metadata)){const e=new R,t="The property metadata and _metadata cannot be set at the same time";throw e.addError("metadata","only-one-defined",t),e}}static getSchema(){const e=lr.getSchema();return{type:"object",required:["metadata","resource_type_id"],properties:{id:{type:"string",format:"uuid"},resource_type_id:{type:"string",format:"uuid"},metadata_key_id:{type:"string",format:"uuid",nullable:!0},metadata_key_type:{type:"string",enum:ao,nullable:!0},expired:{type:"string",format:"date-time",nullable:!0},deleted:{type:"boolean"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},folder_parent_id:{type:"string",format:"uuid",nullable:!0},personal:{type:"boolean",nullable:!0},metadata:{anyOf:[{type:"string",pattern:/^-----BEGIN PGP MESSAGE-----([\r\n])([ -9;-~]{1,76}: [ -~]{1,76}([\r\n]))*\n([a-zA-Z0-9\/+=]{1,76}([\r\n]))*=[a-zA-Z0-9\/+=]{4}([\r\n])-----END PGP MESSAGE-----([\r\n]*)$/},ro.getSchema()]},favorite:{...ya.getSchema(),nullable:!0},permission:da.getSchema(),permissions:ha.getSchema(),resource_type:za.getSchema(),secrets:Ha.getSchema(),tags:Va.getSchema(),creator:e,modifier:e}}}toDto(e){const t=Object.assign({},this._props);return t.metadata=t.metadata||this._metadata.toDto(),e?(void 0!==this._favorite&&e.favorite&&(t.favorite=null===this._favorite?null:this._favorite.toDto()),this._permission&&e.permission&&(t.permission=this._permission.toDto()),this._permissions&&e.permissions&&(t.permissions=this._permissions.toDto()),this._tags&&e.tag&&(t.tags=this._tags.toDto()),this._secrets&&e.secrets&&(t.secrets=this._secrets.toDto()),this._creator&&e.creator&&(t.creator=this._creator.toDto(lr.ALL_CONTAIN_OPTIONS)),this._modifier&&e.modifier&&(t.modifier=this._modifier.toDto(lr.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(oo.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get isDeleted(){return void 0===this._props.deleted?null:this._props.deleted}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get createdBy(){return this._props.created_by||null}get modifiedBy(){return this._props.modified_by||null}get folderParentId(){return this._props.folder_parent_id||null}get resourceTypeId(){return this._props.resource_type_id||null}get metadataKeyId(){return this._props.metadata_key_id||null}get metadataKeyType(){return this._props.metadata_key_type||null}isPersonal(){return Object.prototype.hasOwnProperty.call(this._props,"personal")?this._props.personal:this.permissions?1===this.permissions.length:null}isShared(){return null===this.isPersonal()?null:!this.isPersonal()}get metadata(){return this.isMetadataDecrypted()?this._metadata:this._props.metadata}isMetadataDecrypted(){return Boolean(this._metadata)}isMetadataKeyTypeUserKey(){return this._props.metadata_key_type===so}get permission(){return this._permission||null}get permissions(){return this._permissions||null}isOwner(){return null===this.permission?null:this.permission.type===da.PERMISSION_OWNER}canUpdate(){return this.permission.type>=da.PERMISSION_UPDATE}isReadOnly(){return null===this.permission?null:this.permission.type===da.PERMISSION_READ}canMove(e,t){return this.isReadOnly()?(null===e||e.isPersonal())&&(null===t||t.isPersonal()):null===t||!t.isReadOnly()}isSuggestion(e){return eo(e,this.metadata.uris?.[0])}static transformDtoFromV4toV5(e){return null==e.metadata&&(e.metadata={object_type:ro.METADATA_OBJECT_TYPE,resource_type_id:e.resource_type_id,name:e.name,username:e.username||null,uris:e.uri?[e.uri]:[],description:e.description||null}),delete e.name,delete e.username,delete e.uri,delete e.description,e}toV4Dto(e){const t=this.toDto(e);return t.name=t.metadata.name,t.username=t.metadata.username,t.uri=t.metadata.uris?.[0]||"",t.description=t.metadata.description,delete t.metadata,t}get tags(){return this._tags||null}get favorite(){return this._favorite||null}isFavorited(){return!0===this.favorite}get secrets(){return this._secrets||null}get secret(){for(const e of this._secrets)return e;return null}set secrets(e){oo.assertValidSecrets(e),this._secrets=new Ha(e.toDto())}set folderParentId(e){const t="folder_parent_id";if(null===e)return void(this._props[t]=null);const r=oo.getSchema().properties[t];this._props[t]=U.validateProp(t,e,r)}set permissions(e){this._permissions=e}set tags(e){this._tags=e}set favorite(e){this._favorite=e}set metadata(e){e instanceof ro?(this._metadata=new ro(e.toDto(),{validate:!1}),delete this._props.metadata):"object"==typeof e?(this._metadata=new ro(e),delete this._props.metadata):(U.validateProp("metadata",e,oo.getSchema().properties.metadata.anyOf[0]),this._props.metadata=e,delete this._metadata)}set metadataKeyId(e){U.validateProp("metadata_key_id",e,oo.getSchema().properties.metadata_key_id),this._props.metadata_key_id=e}set metadataKeyType(e){U.validateProp("metadata_key_type",e,oo.getSchema().properties.metadata_key_type),this._props.metadata_key_type=e}set personal(e){U.validateProp("personal",e,oo.getSchema().properties.personal),this._props.personal=e}static assertValidPermission(e,t){if(!e)throw new R("ResourceEntity assertValidPermission expect a permission.");if(e.aco!==da.ACO_RESOURCE)throw new R("ResourceEntity assertValidPermission not a valid resource permission.");if(t&&e.acoForeignKey!==t)throw new R("ResourceEntity assertValidPermission resource id doesnt not match foreign key permission.")}static assertValidPermissions(e,t){if(!e||!e.length)throw new R("ResourceEntity assertValidPermissions expect an array of permissions.");for(const r of e)oo.assertValidPermission(r,t)}static assertValidSecrets(e,t){if(!e||!e.length)throw new R("ResourceEntity assertValidSecrets cannot be empty.");if(!(e instanceof Ha))throw new R("ResourceEntity assertValidSecrets expect a ResourceSecretsCollection.");for(const r of e)if(r.resourceId&&r.resourceId!==t)throw new R("ResourceEntity assertValidSecrets secret resourceId should match the resource id.")}static assertValidFavorite(e,t){if(e.foreignKey!==t)throw new R("ResourceEntity assertValidFavorite favorite foreign key should match the resource id.")}static get ENTITY_NAME(){return"Resource"}static get METADATA_KEY_TYPE_USER_KEY(){return so}static get METADATA_KEY_TYPE_METADATA_KEY(){return io}static get ALL_CONTAIN_OPTIONS(){return{permission:!0,permissions:!0,secrets:!0,favorite:!0,tag:!0,creator:!0,modifier:!0}}}const no=oo,co=[va,Sa,ba,Ea,ka,Ta,Aa,Ia];const lo=class extends Xt{get entityClass(){return za}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:za.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertNotExist("slug",e._props.slug,{haystackSet:t?.uniqueSlugsSetCache})}isResourceTypeIdPresent(e){return this._items.some((t=>t.id===e))}filterByPasswordResourceTypes(){this.filterByPropertyValueIn("slug",La)}filterByResourceTypeVersion(e){this.filterByCallback((t=>t.version===e))}getFirstById(e){return this.getFirst("id",e)}getFirstBySlug(e){return this.getFirst("slug",e)}hasOneWithSlug(e){return Boolean(this.getFirstBySlug(e))}hasSomePasswordResourceTypes(e=ma){return this.items.some((t=>t.hasPassword()&&t.version===e))}hasSomeTotpResourceTypes(e=ma){return this.items.some((t=>t.hasTotp()&&t.version===e))}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.extract("slug"));r={onItemPushed:e=>{s.add(e.id),i.add(e.slug)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueSlugsSetCache:i},...r},super.pushMany(e,t,r)}push(e,t={},r={}){co.includes(e?.slug)&&super.push(e,t,r)}};class uo extends Xt{get entityClass(){return no}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:no.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache})}get resources(){return this._items}get ids(){return this._items.map((e=>e.id))}get folderParentIds(){return this._items.filter((e=>null!==e.folderParentId)).map((e=>e.folderParentId))}getFirstById(e){return this._items.find((t=>t.id===e))}getFirstIndexById(e){return this._items.findIndex((t=>t.id===e))}filterByIsOwner(){return new uo(this._items.filter((e=>e.isOwner())),{validate:!1})}filterByResourceTypes(e){if(!(e instanceof lo))throw new TypeError("ResourcesCollection filterByResourceTypes expects resourceTypes to be a ResourceTypesCollection.");const t=e.extract("id");this.filterByPropertyValueIn("resource_type_id",t)}filterBySuggestResources(e){if("string"!=typeof e)throw new TypeError("ResourcesCollection filterBySuggestResources expects url to be a string.");this.filterByCallback((t=>t.isSuggestion(e)))}filterByTagNotPresent(e){const t=t=>t.id!==e;return this._items.filter((e=>e.tags.tags.every(t)))}filterOutMetadataEncrypted(){this.filterByCallback((e=>e.isMetadataDecrypted()))}filterOutMetadataNotEncryptedWithUserKey(){this.filterByCallback((e=>e.isMetadataKeyTypeUserKey()))}pushMany(e,t={},r={}){const s=new Set(this.extract("id"));r={onItemPushed:e=>{s.add(e.id)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s},...r},super.pushMany(e,t,r)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}removeTagById(e){let t=!1;for(const r of this.resources)r.tags&&(t=r.tags.removeById(e)||t);return t}replaceTag(e,t){let r=!1;for(const s of this.resources)s.tags&&(r=s.tags.replaceTag(e,t)||r);return r}bulkReplaceTagsCollection(e,t){if(!e||!Array.isArray(e)||!e.length)throw new Error("Resource ids should be provided to bulk update tags in resource collection.");if(!t||!Array.isArray(t)||!t.length)throw new Error("Tag collections should be provided to bulk update tags in resource collection.");if(e.length!==t.length)throw new Error("Bulk update requires matching tags collections and list of resource ids.");let r,s=0,i=0;for(;i<e.length;i++)if(i in t){const a=e[i],o=t[i];r=this.getFirstIndexById(a),r>=0&&(this.items[r].tags=o,s++)}return s}static get ENTITY_NAME(){return"Resources"}static get RULE_UNIQUE_ID(){return"unique_id"}}const po=uo;class ho extends $t{constructor(e,t={}){super(e,t),this._props.permission&&(this._permission=new da(this._props.permission,{clone:!1}),ho.assertValidPermission(this._permission,this.id),delete this._props.permission),this._props.permissions&&(this._permissions=new ha(this._props.permissions,{clone:!1}),ho.assertValidPermissions(this._permissions,this.id),delete this._props.permissions),this._props.creator&&(this._creator=new lr(this._props.creator,{...t,clone:!1}),delete this._props._creator),this._props.modifier&&(this._modifier=new lr(this._props.modifier,{...t,clone:!1}),delete this._props._modifier)}marshall(){Object.prototype.hasOwnProperty.call(this._props,"folder_parent_id")||(this._props.folder_parent_id=null),super.marshall()}static getSchema(){const e=lr.getSchema();return{type:"object",required:["name"],properties:{id:{type:"string",format:"uuid"},folder_parent_id:{type:"string",format:"uuid",nullable:!0},name:{type:"string",minLength:1,maxLength:256},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},personal:{type:"boolean",nullable:!0},permission:da.getSchema(),permissions:ha.getSchema(),creator:e,modifier:e}}}toDto(e){const t=Object.assign({},this._props);return e?(this._permission&&e.permission&&(t.permission=this._permission.toDto(da.ALL_CONTAIN_OPTIONS)),this._permissions&&e.permissions&&(t.permissions=this._permissions.toDto(da.ALL_CONTAIN_OPTIONS)),this._creator&&e.creator&&(t.creator=this._creator.toDto(lr.ALL_CONTAIN_OPTIONS)),this._modifier&&e.modifier&&(t.modifier=this._modifier.toDto(lr.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(ho.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get name(){return this._props.name}get folderParentId(){return this._props.folder_parent_id||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get permission(){return this._permission||null}get permissions(){return this._permissions||null}isOwner(){return null!==this.permission&&this.permission.type===da.PERMISSION_OWNER}canUpdate(){return!(!this.permission||!this.permission.type)&&this.permission.type>=da.PERMISSION_UPDATE}isReadOnly(){return null!==this.permission&&this.permission.type===da.PERMISSION_READ}isPersonal(){return Object.prototype.hasOwnProperty.call(this._props,"personal")?this._props.personal:this.permissions?1===this.permissions.length:null}isShared(){return null===this.isPersonal()?null:!this.isPersonal()}static assertValidPermission(e,t){if(!e)throw new R("FolderEntity assertValidPermission expect a permission.");if(e.aco!==da.ACO_FOLDER)throw new R("FolderEntity assertValidPermission not a valid folder permission.");if(t&&e.acoForeignKey!==t)throw new R("FolderEntity assertValidPermission folder id doesnt not match foreign key permission.")}static assertValidPermissions(e,t){if(!e||!e.length)throw new R("FolderEntity assertValidPermissions expect an array of permissions.");for(const r of e)ho.assertValidPermission(r,t)}static canFolderMove(e,t,r){return e.isReadOnly()?(null===t||t.isPersonal())&&(null===r||r.isPersonal()):null===r||!r.isReadOnly()}set folderParentId(e){const t="folder_parent_id";if(!e)return void(this._props[t]=null);const r=ho.getSchema().properties[t];this._props[t]=U.validateProp(t,e,r)}static get ENTITY_NAME(){return"Folder"}static get ALL_CONTAIN_OPTIONS(){return{permission:!0,permissions:!0,creator:!0,modifier:!0}}}const go=ho;class yo extends Xt{get entityClass(){return go}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:go.getSchema()}}validateBuildRules(e,t){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache})}static get ENTITY_NAME(){return"Folders"}static get RULE_UNIQUE_ID(){return"unique_id"}get folders(){return this._items}get ids(){return this._items.map((e=>e.id))}get folderParentIds(){return this._items.map((e=>e.folderParentIds))}filterByIsOwner(){return new yo(this._items.filter((e=>e.isOwner())),{validate:!1})}getById(e){return this._items.find((t=>t.id===e))}getAllChildren(e){return yo.getAllChildren(e,this,new yo([]))}static getAllChildren(e,t,r){const s=t.folders.filter((t=>t.folderParentId===e));if(s.length){try{r.pushMany(s)}catch(e){}s.map((e=>e.id)).forEach((e=>yo.getAllChildren(e,t,r)))}return r}getFolderPath(e){if(null===e)return"/";const t=this.folders.find((t=>t.id===e));if(!t){let t="FoldersCollection::getAllParentsAsPath the folder is missing in the inputCollection.";throw t+=`(id: ${e})`,new Error(t)}const r=this.getAllParents(t);return r.unshift(t),`/${r.folders.map((e=>e.name)).reverse().join("/")}`}getAllParents(e){return yo.getAllParents(e,this,new yo([]))}static getAllParents(e,t,r){if(null!==e.folderParentId){const s=t.folders.find((t=>t.id===e.folderParentId));void 0!==s&&(r.push(s),yo.getAllParents(s,t,r))}return r}pushMany(e,t={},r={}){const s=new Set(this.extract("id"));r={onItemPushed:e=>{s.add(e.id)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s},...r},super.pushMany(e,t,r)}merge(e){for(const t of e)try{this.push(t)}catch(e){}return this}assertUniqueId(e){if(!e.id)return;const t=this.folders.length;let r=0;for(;r<t;r++){const t=this.folders[r];if(t.id&&t.id===e.id)throw new Mt(r,yo.RULE_UNIQUE_ID,`Folder id ${e.id} already exists.`)}}}const mo=yo;r(1741);class wo extends Error{constructor(e,t){if(super(e),this.name="DeleteDryRunError",this.errors={},t.groups&&t.groups.sole_manager&&(this.errors.groups={sole_manager:new la(t.groups.sole_manager)}),t.resources&&t.resources.sole_owner&&(this.errors.resources={sole_owner:new po(t.resources.sole_owner)}),t.folders&&t.folders.sole_owner&&(this.errors.folders={sole_owner:new mo(t.folders.sole_owner)}),!this.errors.folders&&!this.errors.resources&&!this.errors.groups)throw console.error(this),new TypeError("Invalid user deletion error. There should be at least some error details.")}toJSON(){const e=super.toJSON();return e.errors={},this.errors.groups&&this.errors.groups.sole_manager&&(e.errors.groups={sole_manager:this.errors.groups.sole_manager.toJSON()}),this.errors.resources&&this.errors.resources.sole_owner&&(e.errors.resources={sole_owner:this.errors.resources.sole_owner.toJSON()}),this.errors.folders&&this.errors.folders.sole_owner&&(e.errors.folders={sole_owner:this.errors.folders.sole_owner.toJSON()}),e}}const _o=wo;const fo=class extends $t{static getSchema(){return{type:"object",required:["id","group_id"],properties:{id:{type:"string",format:"uuid"},group_id:{type:"string",format:"uuid"}}}}};const vo=class extends Xt{get entityClass(){return fo}static getSchema(){return{type:"array",items:fo.getSchema(),minItems:1}}};const So=class extends $t{static getSchema(){return{type:"object",required:["id","aco_foreign_key"],properties:{id:{type:"string",format:"uuid"},aco_foreign_key:{type:"string",format:"uuid"}}}}get id(){return this._props.id}get acoForeignKey(){return this._props.aco_foreign_key}};const bo=class extends Xt{get entityClass(){return So}static getSchema(){return{type:"array",items:So.getSchema(),minItems:1}}};const Eo=class extends $t{constructor(e,t={}){super(e,t),this._props.owners&&(this._owners=new bo(this._props.owners,{clone:!1}),delete this._props.owners),this._props.managers&&(this._managers=new vo(this._props.managers,{clone:!1}),delete this._props.managers)}validateBuildRules(e){if(!this._props.owners&&!this._props.managers)throw new R("The user delete transfer data cannot be empty.")}static getSchema(){return{type:"object",required:[],properties:{owners:bo.getSchema(),managers:vo.getSchema()}}}toDto(){const e={};return this._owners&&(e.owners=this._owners.toDto()),this._managers&&(e.managers=this._managers.toDto()),e}};var ko=r(7946);const Ao=class{static getStorageKey(e){if(!e.id)throw new Error("Cannot retrieve account id, necessary to get a users me storage key.");return`user-me-${e.id}`}static async get(e){const t=this.getStorageKey(e);let r;try{r=await ko.storage.session.get(t)}catch(e){throw new Error("Unable to access the user me session storage",{cause:e})}const s=r?.[t];if(s)try{return new lr(s)}catch(e){console.debug("Unable to instantiate the user entity based on the cached user dto.",e)}return null}static async set(e,t){const r=this.getStorageKey(e);await navigator.locks.request(r,(async()=>{await ko.storage.session.set({[r]:t.toDto(lr.ALL_CONTAIN_OPTIONS)})}))}static async remove(e){const t=this.getStorageKey(e);await navigator.locks.request(t,(async()=>{await ko.storage.session.remove(t)}))}};const To=class{constructor(e,t=null){this.userService=new Fs(e),this.account=t}async updateLocalStorage(){const e={profile:!0,gpgkey:!1,groups_users:!1,last_logged_in:!0,pending_account_recovery_request:!0,account_recovery_user_setting:!0};this.account&&this.account.roleName===Yt.ROLE_ADMIN&&(e.is_mfa_enabled=!0);const t=await this.findAll(e,null,null,!0);return await oa.set(t),t}async resendInvite(e){return this.userService.resendInvite(e)}async getOrFindMe(e=!1){let t=await Ao.get(this.account);if(!t||e){const e={profile:!0,role:!0,account_recovery_user_setting:!0};t=await this.findOne(this.account.userId,e,!0),await Ao.set(this.account,t)}return t}async getOrFindAll(){const e=await oa.get();return void 0!==e?new ra(e):this.updateLocalStorage()}async findOne(e,t,r){const s=await this.userService.get(e,t);return new lr(s,{ignoreInvalidEntity:r})}async findAll(e,t,r,s){const i=await this.userService.findAll(e,t,r);return new ra(i,{clone:!1,ignoreInvalidEntity:s})}async findAllIdsForResourceUpdate(e){if(!O().isUUID(e))throw new TypeError("Error in find all users for users updates. The user id is not a valid uuid.");const t=await this.userService.findAll(null,{"has-access":e});return new ra(t).ids}async create(e){const t=e.toDto({profile:{avatar:!1}}),r=await this.userService.create(t),s=new lr(r);return await oa.addUser(s),s}async update(e,t){const r=e.toDto({profile:{avatar:!1}}),s=await this.userService.update(e.id,r),i=new lr(s,{ignoreInvalidEntity:t});return await oa.updateUser(i),i}async updateAvatar(e,t,r){const s=await this.userService.updateAvatar(e,t.file,t.filename);return new lr(s,{ignoreInvalidEntity:r})}async deleteDryRun(e,t){try{const r=t&&t instanceof Eo?t.toDto():{};await this.userService.delete(e,r,!0)}catch(e){if(e instanceof it&&400===e.data.code&&e.data.body.errors)throw new _o(e.message,e.data.body.errors);throw e}}async delete(e,t){try{const r=t&&t instanceof Eo?t.toDto():{};await this.userService.delete(e,r)}catch(e){if(e instanceof it&&400===e.data.code&&e.data.body.errors)throw new _o(e.message,e.data.body.errors);throw e}await oa.delete(e)}async requestHelpCredentialsLost(e){const t={username:e.username,case:"lost-passphrase"};await this.userService.requestHelpCredentialsLost(t)}};const Io=class{static async get(e={}){const t=new xt,r=re.getInstance().get(),s=t.findPublic(rt(r.settings.domain)),i=t.findPublic(r.id),a=t.findPrivate();let o;if(e?.role){const e=ta.buildFromDomain(r.settings.domain);o=await new To(e).findOne(r.id,{role:!0})}const n={domain:r.settings.domain,user_id:r.id,username:r.username,first_name:r.firstname,last_name:r.lastname,server_public_armored_key:s.armoredKey,user_key_fingerprint:i.fingerprint.toUpperCase(),user_public_armored_key:i.armoredKey,user_private_armored_key:a.armoredKey,security_token:r.settings.securityToken,role_name:o?.role?.name||null};return new Ys(n,{validateUsername:!1})}};const Ro=new class{get(e={}){return navigator.locks.request("active-account",(async()=>(0===Object.keys(a._data).length&&(await a.init(),c()),await Io.get(e))))}};class Co extends Error{constructor(e,t){super(e=e||ue.t("MFA authentication is required.")),this.name="MfaAuthenticationRequiredError",this.details=t}}const Oo=Co;class xo extends Error{constructor(e){super(e=e||"NotFoundError"),this.name="NotFoundError"}}const Po=xo;class No extends Error{constructor(e,t){super(ue.t("An internal error occurred. The server response could not be parsed. Please contact your administrator.")),this.name="PassboltBadResponseError",this.srcError=e,this.srcResponse=t}}const Uo=No;const Do=class{static async isAuthenticated(){const e=new ut(await this.getApiClientOptions()),t=e.buildUrl(`${e.baseUrl.toString()}/is-authenticated`,null),r=await e.sendRequest("GET",t,null,{credentials:"include",headers:{Accept:"application/json","content-type":"application/json"}});let s;try{s=await r.json()}catch(e){throw new Uo}if(r.ok)return!0;if(/mfa\/verify\/error\.json$/.test(r.url))throw new Oo(null,s.body);if(404===r.status)throw new Po;return!1}static async getApiClientOptions(){const e=await Ro.get();return ta.buildFromAccount(e).setResourceName("/auth")}};var Mo=r(7946);const Lo=class{static get storageKey(){return"auth_status"}static async flush(){return m.write({level:"debug",message:"AuthStatusLocalStorage flushed"}),await Mo.storage.local.remove(this.storageKey)}static async get(){const e=await Mo.storage.local.get([this.storageKey]);if(e)return e[this.storageKey]}static async set(e,t){await navigator.locks.request(this.storageKey,(async()=>{const r={isAuthenticated:Boolean(e),isMfaRequired:Boolean(t)};await Mo.storage.local.set({[this.storageKey]:r})}))}};const Fo=class{async checkAuthStatus(e=!1){if(!e){const e=await Lo.get();if(e)return e}let t,r;try{t=await Do.isAuthenticated(),r=!1}catch(e){if(!(e instanceof Oo))throw e;t=!0,r=!0}return await Lo.set(t,r),{isAuthenticated:t,isMfaRequired:r}}};class qo extends T{constructor(e,t={}){super(U.validate(qo.ENTITY_NAME,e,qo.getSchema()),t)}static getSchema(){return{type:"object",required:["id","expired"],properties:{id:{type:"string",format:"uuid"},expired:{type:"string",format:"date-time",nullable:!0},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}get id(){return this._props.id}get expired(){return this._props.expired}static get ENTITY_NAME(){return"PasswordExpiryResource"}}const Ko=qo;var Bo=r(7946);const jo=new k,zo="resources";class $o{static _cachedData=null;static hasCachedData(){return null!==$o._cachedData}static async flush(){m.write({level:"debug",message:"ResourceLocalStorage flushed"}),await Bo.storage.local.remove(zo),$o._cachedData=null}static async get(){if(!$o._cachedData){const{resources:e}=await Bo.storage.local.get([zo]);$o._cachedData=e}return $o._cachedData}static async set(e){await jo.acquire();try{const t=[];if(e){if(!(e instanceof po))throw new TypeError("ResourceLocalStorage::set expects a ResourcesCollection");for(const r of e)$o.assertEntityBeforeSave(r),t.push(r.toDto($o.DEFAULT_CONTAIN))}await Bo.storage.local.set({resources:t}),$o._cachedData=t}finally{jo.release()}}static async getResourceById(e){const t=await $o.get();return t?.find((t=>t.id===e))}static async addResource(e){await jo.acquire();try{$o.assertEntityBeforeSave(e);const t=await $o.get()||[];t.push(e.toDto($o.DEFAULT_CONTAIN)),await Bo.storage.local.set({resources:t}),$o._cachedData=t}finally{jo.release()}}static async addResources(e){Ae(e,"The parameter resourcesEntities should be an array"),await jo.acquire();try{const t=await $o.get()||[];e.forEach((e=>{$o.assertEntityBeforeSave(e),t.push(e.toDto($o.DEFAULT_CONTAIN))})),await Bo.storage.local.set({resources:t}),$o._cachedData=t}finally{jo.release()}}static async updateResource(e){await jo.acquire();try{$o.assertEntityBeforeSave(e);const t=await $o.get()||[],r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The resource could not be found in the local storage");t[r]=e.toDto($o.DEFAULT_CONTAIN),await Bo.storage.local.set({resources:t}),$o._cachedData=t}finally{jo.release()}}static async updateResourcesCollection(e){be(e,po,"The parameter resourcesEntities should be of ResourcesCollection type."),await jo.acquire();try{const t=await $o.get()||[];for(const r of e){$o.assertEntityBeforeSave(r);const e=t.findIndex((e=>e.id===r.id));if(-1===e)throw new Error("The resource could not be found in the local storage");t[e]=r.toDto($o.DEFAULT_CONTAIN)}await Bo.storage.local.set({resources:t}),$o._cachedData=t}finally{jo.release()}}static async addOrReplaceResourcesCollection(e){be(e,po,"The parameter resourcesEntities should be of ResourcesCollection type."),await jo.acquire();try{const t=await $o.get()||[];for(const r of e){$o.assertEntityBeforeSave(r);const e=t.findIndex((e=>e.id===r.id));-1===e?t.push(r.toDto($o.DEFAULT_CONTAIN)):t[e]=r.toDto($o.DEFAULT_CONTAIN)}await Bo.storage.local.set({resources:t}),$o._cachedData=t}finally{jo.release()}}static async updateResourcesExpiryDate(e){await jo.acquire();try{const t=await $o.get()||[];for(const r of e){be(r,Ko,"The given entity is not a PasswordExpiryResourceEntity");const e=t.findIndex((e=>e.id===r.id));if(-1===e)throw new Error("The resource could not be found in the local storage");t[e].expired=r.expired}await Bo.storage.local.set({resources:t}),$o._cachedData=t}finally{jo.release()}}static async delete(e){he(e,"The parameter resourceId should be a UUID."),await jo.acquire();try{const t=await $o.get()||[];if(t.length>0){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await Bo.storage.local.set({resources:t}),$o._cachedData=t}}finally{jo.release()}}static get DEFAULT_CONTAIN(){return{permission:!0,favorite:!0,tag:!0}}static assertEntityBeforeSave(e){if(!e)throw new TypeError("ResourceLocalStorage expects a ResourceEntity to be set");if(!(e instanceof no))throw new TypeError("ResourceLocalStorage expects an object of type ResourceEntity");if(!e.id)throw new TypeError("ResourceLocalStorage expects ResourceEntity id to be set");if(!e.permission)throw new TypeError("ResourceLocalStorage::set expects ResourceEntity permission to be set")}}const Vo=$o;class Yo extends dt{constructor(e){super(e,Yo.RESOURCE_NAME)}static get RESOURCE_NAME(){return"resources"}static getSupportedContainOptions(){return["creator","favorite","modifier","secret","permission","permissions","permissions.user.profile","permissions.group","tag","resource-type"]}static getSupportedFiltersOptions(){return["is-favorite","is-shared-with-group","is-owned-by-me","is-shared-with-me","has-id","has-tag"]}static getSupportedOrdersOptions(){return["Resource.modified DESC","Resource.modified ASC"]}async get(e,t){this.assertValidId(e);const r=t?this.formatContainOptions(t,Yo.getSupportedContainOptions()):null;return(await this.apiClient.get(e,r)).body}async findAll(e,t,r){e=e?this.formatContainOptions(e,Yo.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(t,Yo.getSupportedFiltersOptions()):null,r=r?this.formatOrderOptions(r,Yo.getSupportedFiltersOptions()):null;const s={...e,...t,...r},i=await this.apiClient.findAll(s);return i.body&&i.body.length?i.body:[]}async create(e,t){this.assertNonEmptyData(e);const r=t?this.formatContainOptions(t,Yo.getSupportedContainOptions()):null;return(await this.apiClient.create(e,r)).body}async update(e,t,r){this.assertValidId(e),this.assertNonEmptyData(t);const s=r?this.formatContainOptions(r,Yo.getSupportedContainOptions()):null;return(await this.apiClient.update(e,t,s)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}}const Go=Yo;var Wo=r(7946);const Ho=class{static get storageKey(){return"resourceTypes"}static async flush(){return m.write({level:"debug",message:"ResourceTypeLocalStorage flushed"}),await Wo.storage.local.remove(this.storageKey)}static async get(){const{resourceTypes:e}=await Wo.storage.local.get([this.storageKey]);return e}static async set(e){be(e,lo,"ResourceTypeLocalStorage::set expects a ResourceTypesCollection"),await navigator.locks.request(this.storageKey,(async()=>{await Wo.storage.local.set({[this.storageKey]:e.toDto()})}))}};class Jo extends dt{constructor(e){super(e,Jo.RESOURCE_NAME)}static get RESOURCE_NAME(){return"resource-types"}async get(e){this.assertValidId(e);return(await this.apiClient.get(e)).body}async findAll(){const e=await this.apiClient.findAll();return e.body&&e.body.length?e.body:[]}}const Zo=Jo;const Qo=class{constructor(e){this.resourceTypeService=new Zo(e)}async updateLocalStorage(){const e=await this.resourceTypeService.findAll(),t=new lo(e);return await Ho.set(t),t}async getOrFindAll(){const e=await Ho.get();return void 0!==e?new lo(e):this.updateLocalStorage()}async getSecretSchemaById(e){he(e,"The resource type id should be a valid UUID");const t=(await this.getOrFindAll()).getFirst("id",e);return t?.definition?.secret}};const Xo=class{constructor(){this.nextCallbackIndex=0,this.lockKey=(0,w.A)(),this.hasError=!1}async execute(e,t,r={ignoreError:!1}){if(0!==this.nextCallbackIndex)throw new Error("ExecuteConcurrentlyService should be executed only once");Ae(e),Re(t);const s=r?.ignoreError??!1,i={};return new Promise(((r,a)=>{for(let o=0;o<t;o++)this.executeCallbacksUntilComplete(e,i,s,r,a)}))}getAndIncrementCallbackIndex(){return navigator.locks.request(this.lockKey,(()=>this.nextCallbackIndex++))}async executeCallbacksUntilComplete(e,t,r,s,i){let a=await this.getAndIncrementCallbackIndex();for(;a<e.length&&!this.hasError;){try{t[a]=await e[a]()}catch(e){if(!r){this.hasError=!0,i(e);break}t[a]=e}if(Object.keys(t).length===e.length){s(Object.values(t));break}a=await this.getAndIncrementCallbackIndex()}}},en=(e,t)=>e.reduce(((e,r,s)=>(s%t?e[e.length-1].push(r):e.push([r]),e)),[]);const tn=class extends $t{static getSchema(){return{type:"object",required:["object_type","domain","fingerprint","armored_key","passphrase"],properties:{object_type:{type:"string",enum:["PASSBOLT_METADATA_PRIVATE_KEY"]},domain:{type:"string",maxLength:1024},fingerprint:{type:"string",pattern:/^[a-f0-9]{40}$/im},armored_key:{type:"string",maxLength:1e4,pattern:/^-----BEGIN PGP PRIVATE KEY BLOCK-----([\r\n])([ -9;-~]{1,76}: [ -~]{1,76}([\r\n]))*\n([a-zA-Z0-9\/+=]{1,76}([\r\n]))*=[a-zA-Z0-9\/+=]{4}([\r\n])-----END PGP PRIVATE KEY BLOCK-----([\r\n]*)$/},passphrase:{type:"string",maxLength:1024}}}}get armoredKey(){return this._props.armored_key}};const rn=class extends $t{constructor(e,t){super(e),this._props.data&&"string"!=typeof this._props.data&&(this._data=new tn(this._props.data,{...t,clone:!1}),delete this._props.data)}static getSchema(){return{type:"object",required:["user_id","data"],properties:{id:{type:"string",format:"uuid",nullable:!0},metadata_key_id:{type:"string",format:"uuid",nullable:!0},user_id:{type:"string",format:"uuid"},data:{anyOf:[{type:"string",maxLength:1e4,pattern:/^-----BEGIN PGP MESSAGE-----([\r\n])([ -9;-~]{1,76}: [ -~]{1,76}([\r\n]))*\n([a-zA-Z0-9\/+=]{1,76}([\r\n]))*=[a-zA-Z0-9\/+=]{4}([\r\n])-----END PGP MESSAGE-----([\r\n]*)$/},{type:"object"}]},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"}}}}validateBuildRules(){if(Boolean(this._props.data)&&Boolean(this._data)){const e=new R,t="The property data and _data cannot be set at the same time";throw e.addError("data","only-one-defined",t),e}}toDto(){const e=Object.assign({},this._props),t=this.data;return e.data=t instanceof tn?t.toDto():t,e}toJSON(){return this.toDto()}get data(){return this.isDecrypted?this._data:this._props.data}get metadataKeyId(){return this._props.metadata_key_id||null}set data(e){U.validateProp("data",e,this.cachedSchema.properties.data),"string"==typeof e?(this._props.data=e,delete this._data):(this._data=new tn(e.toDto(),{clone:!0,validate:!1}),delete this._props.data)}get isDecrypted(){return Boolean(this._data)}};const sn=class extends Xt{get entityClass(){return rn}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:rn.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertNotExist("user_id",e._props.user_id,{haystackSet:t?.uniqueUserIdsSetCache}),this.assertSameMetadataKeyId(e)}assertSameMetadataKeyId(e){if(!e.metadataKeyId)return;const t=this._items.find((e=>Boolean(e.metadataKeyId)))?.metadataKeyId;if(!t)return;if(e.metadataKeyId===t)return;const r=new R;throw r.addError("metadata_key_id","same_metadata_key","The collection should not contain different metadata key ID."),r}hasDecryptedPrivateKeys(){return this._items.some((e=>e.isDecrypted))}hasEncryptedPrivateKeys(){return this._items.some((e=>!e.isDecrypted))}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.extract("user_id"));r={onItemPushed:e=>{s.add(e._props.id),i.add(e._props.user_id)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueUserIdsSetCache:i},...r},super.pushMany(e,t,r)}};const an=class extends $t{constructor(e,t={}){super(e,t),this._props.metadata_private_keys&&(this._metadata_private_keys=new sn(this._props.metadata_private_keys,{...t,clone:!1}),delete this._props.metadata_private_keys,this.assertSameMetadataKeyId())}static getSchema(){return{type:"object",required:["fingerprint","armored_key"],properties:{id:{type:"string",format:"uuid",nullable:!0},fingerprint:{type:"string",pattern:/^[a-f0-9]{40}$/im},armored_key:{type:"string",maxLength:1e4,pattern:/^-----BEGIN PGP PUBLIC KEY BLOCK-----([\r\n])([ -9;-~]{1,76}: [ -~]{1,76}([\r\n]))*\n([a-zA-Z0-9\/+=]{1,76}([\r\n]))*=[a-zA-Z0-9\/+=]{4}([\r\n])-----END PGP PUBLIC KEY BLOCK-----([\r\n]*)$/},created:{type:"string",format:"date-time",nullable:!0},created_by:{type:"string",format:"uuid",nullable:!0},modified:{type:"string",format:"date-time",nullable:!0},modified_by:{type:"string",format:"uuid",nullable:!0},deleted:{type:"string",format:"date-time",nullable:!0},metadata_private_keys:sn.getSchema()}}}validateBuildRules(){}assertSameMetadataKeyId(){if(0===(this._metadata_private_keys?.length||0))return;if(this._props.id!==this._metadata_private_keys.items[0].metadataKeyId){const e=new R;throw e.addError("id:metadata_private_keys","same_id","`id` and the `metadata_private_keys.id` should be the same"),e}}toDto(e){const t=Object.assign({},this._props);return e?(this._metadata_private_keys&&e.metadata_private_keys&&(t.metadata_private_keys=this._metadata_private_keys.toDto()),t):t}get armoredKey(){return this._props.armored_key}get id(){return this._props.id||null}get metadataPrivateKeys(){return this._metadata_private_keys||null}get created(){return this._props.created||null}static get ALL_CONTAIN_OPTIONS(){return{metadata_private_keys:!0}}};const on=class extends Xt{get entityClass(){return an}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:an.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertNotExist("fingerprint",e._props.fingerprint,{haystackSet:t?.uniqueFingerprintsSetCache})}getFirstByLatestCreated(){return this.length?this._items.reduce(((e,t)=>e.created?t.created&&t.created>e.created?t:e:t)):null}toDto(e={}){return this._items.map((t=>t.toDto(e)))}hasDecryptedKeys(){return this._items.some((e=>e.metadataPrivateKeys?.hasDecryptedPrivateKeys()))}hasEncryptedKeys(){return this._items.some((e=>e.metadataPrivateKeys?.hasEncryptedPrivateKeys()))}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.extract("fingerprint"));r={onItemPushed:e=>{s.add(e._props.id),i.add(e._props.fingerprint)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueFingerprintsSetCache:i},...r},super.pushMany(e,t,r)}};const nn=class{constructor(e){this.account=e}async decryptOne(e,t=null){if(be(e,rn,"The given entity is not a MetadataPrivateKeyEntity"),e.isDecrypted)return;const r=await Ge(e.data);t=t||await this.getPassphraseFromLocalStorageOrFail();const s=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t),i=await Mi.decrypt(r,s),a=JSON.parse(i),o=new tn(a);e.data=o}async decryptAll(e,t=null){be(e,sn,"The given collection is not of the type MetadataPrivateKeysCollection"),t=t||await this.getPassphraseFromLocalStorageOrFail();const r=e.items;for(let e=0;e<r.length;e++){const s=r[e];await this.decryptOne(s,t)}}async decryptAllFromMetadataKeysCollection(e,t=null){be(e,on,"The given collection is not of the type MetadataKeysCollection"),t=t||await this.getPassphraseFromLocalStorageOrFail();const r=e.items;for(let e=0;e<r.length;e++){const s=r[e].metadataPrivateKeys;await this.decryptAll(s,t)}}async getPassphraseFromLocalStorageOrFail(){const e=await Wi.get();if(!e)throw new $i;return e}};class cn extends dt{constructor(e){super(e,"metadata/keys")}static getSupportedContainOptions(){return["metadata_private_keys"]}async findAll(e={}){be(e,Object,"The given contains is not an Object"),e=e?this.formatContainOptions(e,cn.getSupportedContainOptions()):null;const t={...e},r=await this.apiClient.findAll(t);return r.body&&r.body.length?r.body:[]}}const ln=cn;const un=class{constructor(e,t){this.metadataKeysApiService=new ln(e),this.decryptMetadataPrivateKeysService=new nn(t)}async findAll(e={}){const t=ln.getSupportedContainOptions();if(e&&!Object.keys(e).every((e=>t.includes(e))))throw new Error("Unsupported contains parameter used, please check supported contains");const r=await this.metadataKeysApiService.findAll(e),s=new on(r);if(s.hasDecryptedKeys())throw new Error("The metadata private keys should not be decrypted.");return await this.decryptMetadataPrivateKeysService.decryptAllFromMetadataKeysCollection(s),s}findAllForSessionStorage(){return this.findAll({metadata_private_keys:!0})}};var dn=r(7946);class pn{static _runtimeCachedData={};constructor(e){if(!(e&&e instanceof Ys))throw new TypeError("Parameter `account` should be of type AccountEntity.");this.account=e,this.storageKey=this.getStorageKey(e)}getStorageKey(e){return`metadata_keys-${e.id}`}async flush(){await dn.storage.session.remove(this.storageKey),delete pn._runtimeCachedData[this.account.id],console.debug(`MetadataKeysSessionStorage flushed for (${this.account.id})`)}async get(){if(!pn._runtimeCachedData[this.account.id]){const e=await dn.storage.session.get(this.storageKey);if(!e[this.storageKey])return;pn._runtimeCachedData[this.account.id]=e[this.storageKey]}return pn._runtimeCachedData[this.account.id]}async set(e){if(!(e&&e instanceof on))throw new TypeError("The parameter `collection` should be of type MetadataKeysCollection.");if(e.hasEncryptedKeys())throw new TypeError("The parameter `collection` should contain only decrypted keys.");await navigator.locks.request(this.storageKey,(async()=>{for(const t of e)pn.assertEntityBeforeSave(t);const t=e.toDto(pn.DEFAULT_CONTAIN);await this._setBrowserStorage({[this.storageKey]:t}),pn._runtimeCachedData[this.account.id]=t}))}static assertEntityBeforeSave(e){["id","created","created_by","modified","modified_by"].forEach((t=>{if(void 0===e._props[t])throw new TypeError(`The parameter 'metadataKey' should have the property '${t}' set.`)})),["_metadata_private_keys"].forEach((t=>{if(void 0===e[t])throw new TypeError(`The parameter 'metadataKey' should have the association '${t}' set.`)}))}async _setBrowserStorage(e){await dn.storage.session.set(e)}static get DEFAULT_CONTAIN(){return{metadata_private_keys:!0}}}const hn=pn;class gn{constructor(e,t){this.account=e,this.findMetadataKeysService=new un(t,e),this.metadataKeysSessionStorage=new hn(e)}async findAndUpdateAll(){const e=`FIND_AND_UPDATE_METADATA_KEYS_SS_LOCK-${this.account.id}`;return await navigator.locks.request(e,{ifAvailable:!0},(async t=>{if(!t)return await navigator.locks.request(e,{mode:"shared"},(async()=>new on(await this.metadataKeysSessionStorage.get())));const r=await this.findMetadataKeysService.findAllForSessionStorage();return await this.metadataKeysSessionStorage.set(r),r}))}}class yn{constructor(e,t){this.findAndUpdateMetadataKeysService=new gn(e,t),this.metadataKeysSessionStorage=new hn(e)}async getOrFindAll(){const e=await this.metadataKeysSessionStorage.get();return e?new on(e):this.findAndUpdateMetadataKeysService.findAndUpdateAll()}}const mn=["Resource","Folder","Tag"];const wn=class extends $t{static getSchema(){return{type:"object",required:["foreign_model","foreign_id","session_key"],properties:{foreign_model:{type:"string",enum:mn},foreign_id:{type:"string",format:"uuid"},session_key:{type:"string",pattern:/^9:[0-9A-F]{64}$/i}}}}get foreignModel(){return this._props.foreign_model}get foreignId(){return this._props.foreign_id}get sessionKey(){return this._props.session_key}};const _n=class extends Xt{get entityClass(){return wn}static getSchema(){return{type:"array",items:wn.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("foreign_id",e._props.foreign_id,{haystackSet:t?.uniqueForeignIdsSetCache})}toDto(e={}){return this._items.map((t=>t.toDto(e)))}pushMany(e,t={},r={}){const s=new Set(this.extract("foreign_id"));r={onItemPushed:e=>{s.add(e._props.foreign_id)},validateBuildRules:{...r?.validateBuildRules,uniqueForeignIdsSetCache:s},...r},super.pushMany(e,t,r)}filterOutSessionKeysNotMatchingForeignModelAndForeignIds(e,t){this.filterByCallback((r=>r.foreignModel===e&&t.includes(r.foreignId)))}remove(e){this.filterByCallback((t=>t!==e))}};class fn extends $t{constructor(e,t={}){super(e,t),this._props.session_keys&&(this._session_keys=new _n(this._props.session_keys,{...t,clone:!1}),delete this._props.session_keys)}static getSchema(){return{type:"object",required:["object_type","session_keys"],properties:{object_type:{type:"string",enum:["PASSBOLT_SESSION_KEYS"]},session_keys:_n.getSchema()}}}static createFromSessionKeys(e){if(!(e instanceof _n))throw new TypeError('The parameter "sessionKey" should be a SessionKeysCollection.');return new fn({object_type:"PASSBOLT_SESSION_KEYS",session_keys:e})}get sessionKeys(){return this._session_keys}toDto(){const e=Object.assign({},this._props);return e.session_keys=this.sessionKeys.toDto(),e}}const vn=fn;class Sn extends $t{constructor(e,t={}){super(e,t),this._props.data&&"string"!=typeof this._props.data&&(this._data=new vn(this._props.data,{...t,clone:!1}),delete this._props.data)}static getSchema(){return{type:"object",required:["data"],properties:{id:{type:"string",format:"uuid",nullable:!0},user_id:{type:"string",format:"uuid",nullable:!0},created:{type:"string",format:"date-time",nullable:!0},modified:{type:"string",format:"date-time",nullable:!0},created_by:{type:"string",format:"uuid",nullable:!0},data:{anyOf:[{type:"string",maxLength:1e7,pattern:/^-----BEGIN PGP MESSAGE-----([\r\n])([ -9;-~]{1,76}: [ -~]{1,76}([\r\n]))*\n([a-zA-Z0-9\/+=]{1,76}([\r\n]))*=[a-zA-Z0-9\/+=]{4}([\r\n])-----END PGP MESSAGE-----([\r\n]*)$/},vn.getSchema()]}}}}validateBuildRules(){if(Boolean(this._props.data)&&Boolean(this._data)){const e=new R,t="The property data and _data cannot be set at the same time";throw e.addError("data","only-one-defined",t),e}}get id(){return this._props.id||null}get data(){return this.isDecrypted?this._data:this._props.data}get userId(){return this._props.user_id||null}get modified(){return this._props.modified||null}set data(e){e instanceof vn?(this._data=new vn(e.toDto(),{validate:!1}),delete this._props.data):"object"==typeof e?(this._data=new vn(e),delete this._props.data):(U.validateProp("data",e,Sn.getSchema().properties.data.anyOf[0]),this._props.data=e,delete this._data)}get isDecrypted(){return Boolean(this._data)}toDto(){const e=Object.assign({},this._props);return e.data=e.data||this._data.toDto(),e}}const bn=Sn;const En=class extends dt{constructor(e){super(e,"metadata/session-keys")}async findAll(){const e=await this.apiClient.findAll();return e.body&&e.body.length?e.body:[]}async create(e){be(e,bn,"The parameter 'sessionKeysBundleEntity' should be a SessionKeysBundleEntity");return(await this.apiClient.create(e.toDto())).body}async delete(e){he(e,"The parameter 'id' should be a UUID.");return(await this.apiClient.delete(e)).body}async update(e,t){he(e,"The parameter 'id' should be a UUID."),be(t,bn,"The parameter 'sessionKeysBundleEntity' should be a SessionKeysBundleEntity");return(await this.apiClient.update(e,t)).body}};const kn=class extends Xt{get entityClass(){return bn}static getSchema(){return{type:"array",items:bn.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertSameUserId(e)}assertSameUserId(e){if(!this.items.length)return;if(void 0===e._props.user_id)return;const t=this.items[0].userId;if(e._props.user_id!==t){const r=new R,s=`The collection has different user id: ${t} != ${e._props.user_id}.`;throw r.addError("user_id","different_user_id",s),r}}toDto(e={}){return this._items.map((t=>t.toDto(e)))}pushMany(e,t={},r={}){const s=new Set(this.extract("id"));r={onItemPushed:e=>{s.add(e._props.id)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s},...r},super.pushMany(e,t,r)}hasSomeDecryptedSessionKeysBundles(){return this.items.some((e=>e.isDecrypted))}hasSomeEncryptedSessionKeysBundles(){return this.items.some((e=>!e.isDecrypted))}sortByModified(){this._items.sort(((e,t)=>e.modified?t.modified&&t.modified>e.modified?1:-1:1))}getByLatestModified(){if(this.length)return this.items.reduce(((e,t)=>t.modified>e.modified?t:e))}};const An=class{constructor(e){this.account=e}async decryptOne(e,t=null){if(be(e,bn,"The given entity is not a SessionKeysBundleEntity"),e.isDecrypted)return;const r=await Ge(e.data);t=t||await this.getPassphraseFromLocalStorageOrFail();const s=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t),i=await Mi.decrypt(r,s),a=JSON.parse(i),o=new vn(a);e.data=o}async decryptAll(e,t=null){be(e,kn,"The given collection is not of the type SessionKeysBundlesCollection"),t=t||await this.getPassphraseFromLocalStorageOrFail();const r=e.items;for(let e=0;e<r.length;e++){const s=r[e];await this.decryptOne(s,t)}}async getPassphraseFromLocalStorageOrFail(){const e=await Wi.get();if(!e)throw new $i;return e}};const Tn=class{constructor(e,t){this.sesionKeysBundlesApiService=new En(e),this.decryptSessionKeysBundlesService=new An(t)}async findAllBundles(){const e=await this.sesionKeysBundlesApiService.findAll(),t=new kn(e);if(t.hasSomeDecryptedSessionKeysBundles())throw new Error("The session keys bundles should not be decrypted.");return await this.decryptSessionKeysBundlesService.decryptAll(t),t}};var In=r(7946);class Rn{static _runtimeCachedData={};constructor(e){if(!(e&&e instanceof Ys))throw new TypeError("Parameter `account` should be of type AccountEntity.");this.account=e,this.storageKey=this.getStorageKey(e)}getStorageKey(e){return`session_keys_bundles-${e.id}`}hasCachedData(){return Boolean(Rn._runtimeCachedData[this.account.id])}async flush(){await In.storage.session.remove(this.storageKey),delete Rn._runtimeCachedData[this.account.id],console.debug(`SessionKeysBundlesSessionStorageStorage flushed for (${this.account.id})`)}async get(){if(!Rn._runtimeCachedData[this.account.id]){const e=await In.storage.session.get(this.storageKey);if(!e[this.storageKey])return;Rn._runtimeCachedData[this.account.id]=e[this.storageKey]}return Rn._runtimeCachedData[this.account.id]}async set(e){if(!(e&&e instanceof kn))throw new TypeError("Parameter `sessionKeysBundles` should be of type SessionKeysBundlesCollection");if(e.length>0&&e.hasSomeEncryptedSessionKeysBundles())throw new TypeError("The parameter `collection` should contain only decrypted keys.");await navigator.locks.request(this.storageKey,(async()=>{const t=e.toDto();await this._setBrowserStorage({[this.storageKey]:t}),Rn._runtimeCachedData[this.account.id]=t}))}async _setBrowserStorage(e){await In.storage.session.set(e)}}const Cn=Rn;class On{constructor(e,t){this.account=e,this.findSessionKeysService=new Tn(t,e),this.sessionKeysBundlesSessionStorageService=new Cn(e)}async findAndUpdateAllBundles(){const e=`FIND_AND_UPDATE_SESSION_KEYS_SS_LOCK-${this.account.id}`;return await navigator.locks.request(e,{ifAvailable:!0},(async t=>{if(!t){const t=this.sessionKeysBundlesSessionStorageService.hasCachedData();return await navigator.locks.request(e,{mode:"shared"},(async()=>new kn(await this.sessionKeysBundlesSessionStorageService.get(),{validate:!t})))}const r=await this.findSessionKeysService.findAllBundles();return await this.sessionKeysBundlesSessionStorageService.set(r),r}))}}class xn{constructor(e,t){this.findAndUpdateSessionKeysService=new On(e,t),this.sessionKeysBundlesSessionStorageService=new Cn(e)}async getOrFindAllBundles(){const e=this.sessionKeysBundlesSessionStorageService.hasCachedData(),t=await this.sessionKeysBundlesSessionStorageService.get();return t?new kn(t,{validate:!e}):this.findAndUpdateSessionKeysService.findAndUpdateAllBundles()}async getOrFindAll(){const e=await this.getOrFindAllBundles();if(!e.length)return new _n([]);e.sortByModified();const t=e.items[0].data.sessionKeys;for(let r=1;r<e.length;r++)t.pushMany(e.items[r].data.sessionKeys.items,{validate:!1,ignoreInvalidEntity:!0});return t}async getOrFindAllByForeignModelAndForeignIds(e,t){Se(e,'The parameter "foreignModel" should not be an empty string'),Ie(t,'The parameter "foreignIds" should contain only uuid');const r=await this.getOrFindAll();return r.filterOutSessionKeysNotMatchingForeignModelAndForeignIds(e,t),r}}const Pn=class{static getFromGpgMessage(e){Fe(e);const t=e.packets.findPacket(ae.vP.packet.publicKeyEncryptedSessionKey),r=de.toHex(t.sessionKey);return`${t.sessionKeyAlgorithm}:${r}`}};const Nn=class{constructor(e){this.account=e}async encryptOne(e,t=null){if(be(e,bn,'The parameter "sessionKeysBundle" should be a SessionKeysBundleEntity.'),null!==t&&ve(t,'The parameter "passphrase" should be a string.'),!e.isDecrypted)throw new TypeError("The session key bundle should be decrypted.");t=t||await this.getPassphraseFromSessionStorageOrFail();const r=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t),s=await Je(this.account.userPublicArmoredKey),i=JSON.stringify(e.data.toDto());e.data=await Rs.encrypt(i,s,[r])}async getPassphraseFromSessionStorageOrFail(){const e=await Wi.get();if(!e)throw new $i;return e}};const Un=class{constructor(e,t){this.account=e,this.getOrFindSessionKeysService=new xn(e,t),this.encryptSessionKeysBundle=new Nn(e),this.sessionKeysBundleApiService=new En(t),this.sessionKeysBundlesSessionStorageService=new Cn(e)}async save(e,t=null,r=!1){be(e,_n,'The parameter "sessionKeys" should be a SessionKeysCollection.'),null!==t&&ve(t,'The parameter "passphrase" should be a string.'),ke(r,'The parameter "retryUpdate" should be a boolean.'),t=t||await Wi.getOrFail();const s=await this.getOrFindSessionKeysService.getOrFindAllBundles(),i=vn.createFromSessionKeys(e),a=await this.buildOrGetAndUpdateSessionKeysBundleToSave(s,i);await this.encryptSessionKeysBundle.encryptOne(a,t);const o=await this.saveOrUpdateSessionKeysBundle(s,a,i);await this.deleteOldSessionKeysBundle(s,o),await this.sessionKeysBundlesSessionStorageService.set(s)}async buildOrGetAndUpdateSessionKeysBundleToSave(e,t){if(!e.length)return new bn({data:t.toDto()});const r=e.getByLatestModified();return r.data=t,r}async saveOrUpdateSessionKeysBundle(e,t,r){let s;s=t.id?await this.sessionKeysBundleApiService.update(t.id,t):await this.sessionKeysBundleApiService.create(t);const i=new bn(s);return i.data=r,e.pushOrReplace(i),i}async deleteOldSessionKeysBundle(e,t){for(let r=e.length-1;r>=0;r--){const s=e.items[r];s.id!==t.id&&(await this.sessionKeysBundleApiService.delete(s.id),e.items.splice(r,1))}}};const Dn=class{constructor(e,t){this.account=t,this.getOrFindSessionKeysService=new xn(t,e),this.getOrFindMetadataKeysService=new yn(t,e),this.saveSessionKeysService=new Un(t,e)}async decryptAllFromForeignModels(e,t=null,r={}){be(e,po,'The parameter "collection" should be a ResourcesCollection.');const s=r?.ignoreDecryptionError||!1,i=r?.updateSessionKeys||!1,a=await this.decryptAllFromForeignModelsWithSessionKeys(e),o=await this.decryptAllFromForeignModelsWithSharedKey(e,{ignoreDecryptionError:s}),n=await this.decryptAllFromForeignModelsWithUserKey(e,t,{ignoreDecryptionError:s});await this.assertMetadataDecrypted(e,r),i&&await this.saveSessionKeys(a,o,n)}async decryptAllFromForeignModelsWithSessionKeys(e){let t=new _n;const r=e.items.filter((e=>!e.isMetadataDecrypted()));if(!r.length)return t;try{t=await this.getOrFindSessionKeysService.getOrFindAllByForeignModelAndForeignIds("Resource",e.ids);for(const r of t)try{const t=e.getFirst("id",r.foreignId);await this.decryptMetadataWithSessionKey(t,r.sessionKey)}catch(e){t.remove(r),console.debug(`Metadata of the entity "${r.foreignModel}:${r.foreignId}" cannot be decrypted with session key.`,{cause:e})}}catch(e){console.warn("An unexpected error occurred when decrypting the metadata with the session keys.",{cause:e})}return t}async decryptMetadataWithSessionKey(e,t){const r=Ze(t),s=await Ge(e.metadata),i=await Mi.decryptWithSessionKey(s,r);e.metadata=JSON.parse(i)}async decryptAllFromForeignModelsWithSharedKey(e,t={}){const r=e.items.filter((e=>e.metadataKeyType===no.METADATA_KEY_TYPE_METADATA_KEY&&!e.isMetadataDecrypted()));if(!r.length)return[];const s=await this.getOrFindMetadataKeysService.getOrFindAll(),i={},a=[];for(const e of r)try{const r=i[e.metadataKeyId]||(i[e.metadataKeyId]=await this.getAndReadMetadataPrivateKey(e,s,t)),o=await this.decryptMetadataWithGpgKey(e,r);a.push(this.extractSessionKeyDtoForEntity(e,o))}catch(r){const s=new Error(`Unable to decrypt the metadata of the resource (${e?.id}) using the shared key (${e?.metadataKeyId}).`,{cause:r});this.handleError(s,t)}return a}async getAndReadMetadataPrivateKey(e,t){const r=t.getFirst("id",e.metadataKeyId);if(!r)throw new Error(`No metadata key found with the id (${e.metadataKeyId}).`);const s=r.metadataPrivateKeys?.items[0];if(!s)throw new Error(`No metadata private key found for the metadata key id (${e.metadataKeyId}).`);if(!s.isDecrypted)throw new Error(`The metadata private key for the metadata key id (${e.metadataKeyId}) should be decrypted.`);return Je(s.data.armoredKey)}async decryptAllFromForeignModelsWithUserKey(e,t,r={}){const s=e.items.filter((e=>e.metadataKeyType===no.METADATA_KEY_TYPE_USER_KEY&&!e.isMetadataDecrypted()));if(!s.length)return[];t=t||await Wi.getOrFail();const i=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t),a=[];for(const e of s)try{const t=await this.decryptMetadataWithGpgKey(e,i);a.push(this.extractSessionKeyDtoForEntity(e,t))}catch(t){const s=new Error(`Unable to decrypt the metadata of the resource (${e?.id}) using the user key.`,{cause:t});this.handleError(s,r)}return a}async decryptOneWithSharedKey(e){const t=await this.getOrFindMetadataKeysService.getOrFindAll(),r=await this.getAndReadMetadataPrivateKey(e,t);await this.decryptMetadataWithGpgKey(e,r)}async decryptMetadataWithGpgKey(e,t){const r=await Ge(e.metadata),s=await Mi.decrypt(r,t);return e.metadata=JSON.parse(s),r}extractSessionKeyDtoForEntity(e,t){const r=Pn.getFromGpgMessage(t);return{foreign_model:"Resource",foreign_id:e.id,session_key:r}}async assertMetadataDecrypted(e,t){e.items.forEach((e=>{if(!e.isMetadataDecrypted()){const r=new Error(`Unable to decrypt the metadata of the entity (${e?.id}).`);this.handleError(r,t)}}))}handleError(e,t={}){if(!t.ignoreDecryptionError)throw e;console.error(e)}async saveSessionKeys(e,t,r){try{const s=[...t,...r];if(0===s.length)return;e.pushMany(s,{ignoreInvalidEntity:!0}),await this.saveSessionKeysService.save(e)}catch(e){console.warn("Unable to save the metadata session keys.",{cause:e})}}};class Mn{constructor(e,t){this.account=e,this.resourceService=new Go(t),this.resourceTypeModel=new Qo(t),this.decryptMetadataService=new Dn(t,e)}async findAll(e,t,r){const s=Go.getSupportedContainOptions(),i=Go.getSupportedFiltersOptions();if(e&&!Object.keys(e).every((e=>s.includes(e))))throw new Error("Unsupported contains parameter used, please check supported contains");if(t&&!Object.keys(t).every((e=>i.includes(e))))throw new Error("Unsupported filter parameter used, please check supported filters");const a=await this.resourceService.findAll(e,t);return new po(a,{clone:!1,ignoreInvalidEntity:r})}async findAllByIds(e,t={}){Ie(e);const r=en(e,80).map((e=>{const r={"has-id":e};return async()=>await this.findAll(t,r)})),s=new Xo,i=await s.execute(r,5),a=new po;return i.forEach((e=>{a._items=a._items.concat(e._items)})),a}async findAllForLocalStorage(){const e=await this.findAll(Vo.DEFAULT_CONTAIN,null,!0),t=await this.resourceTypeModel.getOrFindAll();return e.filterByResourceTypes(t),await this.decryptMetadataService.decryptAllFromForeignModels(e,void 0,{ignoreDecryptionError:!0,updateSessionKeys:!0}),e.filterOutMetadataEncrypted(),e}async findAllByIsSharedWithGroupForLocalStorage(e){const t=await this.findAll(Vo.DEFAULT_CONTAIN,{"is-shared-with-group":e},!0),r=await this.resourceTypeModel.getOrFindAll();return t.filterByResourceTypes(r),t}async findAllByIdsForShare(e){Ie(e);const t=await this.findAllByIds(e,{secret:!0});return await this.decryptMetadataService.decryptAllFromForeignModels(t),t}async findAllByIdsWithPermissions(e){Ie(e);return this.findAllByIds(e,{permission:!0,permissions:!0})}async findAllByIdsForDisplayPermissions(e){Ie(e);const t=await this.findAllByIds(e,{permission:!0,"permissions.user.profile":!0,"permissions.group":!0});return await this.decryptMetadataService.decryptAllFromForeignModels(t),t}async findAllForDecrypt(e){Ie(e);return await this.findAllByIds(e,{secret:!0})}async findOneById(e,t={}){he(e);const r=Go.getSupportedContainOptions();if(t&&!Object.keys(t).every((e=>r.includes(e))))throw new Error("Unsupported contains parameter used, please check supported contains");const s=await this.resourceService.get(e,t);return new no(s)}async findOneByIdForDetails(e){he(e);return this.findOneById(e,{creator:!0,modifier:!0})}}class Ln{static lastUpdateAllTimes={};constructor(e,t){this.account=e,this.findResourcesServices=new Mn(e,t)}async findAndUpdateAll({updatePeriodThreshold:e}={}){Re(e,"Parameter updatePeriodThreshold should be a number.");const t=`RESOURCES_UPDATE_LS_LOCK_${this.account.id}`,r=Ln.lastUpdateAllTimes[this.account.id]??null,s=Vo.hasCachedData(),i=await Vo.get();return e&&r&&Boolean(i)&&Date.now()-r<e?new po(i,{validate:!s}):await navigator.locks.request(t,{ifAvailable:!0},(async e=>{if(!e)return await navigator.locks.request(t,{mode:"shared"},(async()=>new po(i,{validate:!s})));const r=await this.findResourcesServices.findAllForLocalStorage();return await Vo.set(r),Ln.lastUpdateAllTimes[this.account.id]=Date.now(),r}))}async findAndUpdateByIsSharedWithGroup(e){const t=await this.findResourcesServices.findAllByIsSharedWithGroupForLocalStorage(e);return await Vo.addOrReplaceResourcesCollection(t),t}}const Fn=Ln;class qn{constructor(e,t){this.account=e,this.resourceTypeModel=new Qo(t),this.findAndUpdateResourcesLocalStorage=new Fn(e,t)}async getOrFindAll(){const e=Vo.hasCachedData(),t=await Vo.get();if(t)return new po(t,{validate:!e});return await this.findAndUpdateResourcesLocalStorage.findAndUpdateAll()}async getOrFindSuggested(e){if(!e)return new po([]);const t=await this.getOrFindAll(),r=await this.resourceTypeModel.getOrFindAll();return r.filterByPasswordResourceTypes(),t.filterByResourceTypes(r),t.filterBySuggestResources(e),t}async getOrFindByIds(e){Ie(e);const t=await this.getOrFindAll();return t.filterByPropertyValueIn("id",e),t}}var Kn=r(7946);const Bn=new class{constructor(){this.bindCallbacks(),this.addEventListeners(),this.tabUrl=null}bindCallbacks(){this.handleShortcutPressed=this.handleShortcutPressed.bind(this),this.handleUserLoggedOut=this.handleUserLoggedOut.bind(this),this.handleUserLoggedIn=this.handleUserLoggedIn.bind(this),this.handleSuggestedResourcesOnUpdatedTab=this.handleSuggestedResourcesOnUpdatedTab.bind(this),this.handleSuggestedResourcesOnActivatedTab=this.handleSuggestedResourcesOnActivatedTab.bind(this),this.handleSuggestedResourcesOnFocusedWindow=this.handleSuggestedResourcesOnFocusedWindow.bind(this)}addEventListeners(){Kn.commands.onCommand.addListener(this.handleShortcutPressed)}handleShortcutPressed(e){"passbolt-open"===e&&this.openPassboltTab()}async handleUserLoggedIn(){Zi.activate(),await this.updateSuggestedResourcesBadge()}handleUserLoggedOut(){this.tabUrl=null,Zi.deactivate()}async handleSuggestedResourcesOnUpdatedTab(e,t){t.url&&await this.updateSuggestedResourcesBadge()}async handleSuggestedResourcesOnActivatedTab(){await this.updateSuggestedResourcesBadge()}async handleSuggestedResourcesOnFocusedWindow(e){e===Kn.windows.WINDOW_ID_NONE?await this.resetSuggestedResourcesBadge():await this.updateSuggestedResourcesBadge()}openPassboltTab(){const e=Xi.getToolbarUrl();ea(e)}async resetSuggestedResourcesBadge(){this.tabUrl=null,await this.isUserAuthenticated()&&Zi.setSuggestedResourcesCount(0)}async updateSuggestedResourcesBadge(){try{const e=await Ro.get(),t=ta.buildFromAccount(e);if(!await this.isUserAuthenticated())return;this.getOrFindResourcesService=new qn(e,t);const r=await Kn.tabs.query({active:!0,lastFocusedWindow:!0}),s=r?.[0],i=s?.url;let a=0;if(this.tabUrl===i)return;this.tabUrl=i,this.isUrlPassboltDomain(this.tabUrl,e)||this.isUrlPassboltExtension(this.tabUrl)||(a=(await this.getOrFindResourcesService.getOrFindSuggested(this.tabUrl)).length),Zi.setSuggestedResourcesCount(a)}catch(e){console.error(e)}}async isUserAuthenticated(){try{const e=new Fo;return(await e.checkAuthStatus(!1)).isAuthenticated}catch(e){return m.write({level:"debug",message:"Could not check if the user is authenticated, the service is unavailable."}),!1}}isUrlPassboltDomain(e,t){const r=new URL(t.domain),s=e&&new URL(e);return r.hostname===s?.hostname}isUrlPassboltExtension(e){return Boolean(e?.startsWith(Kn.runtime.getURL("/")))}},jn=Bn;const zn=class{async main(){const e=re.getInstance();await this._syncUserSettings(e),await this._finishSsoServerKitCreation(e)}async _syncUserSettings(e){try{await e.settings.sync()}catch(t){e.settings.setDefaults()}}async _finishSsoServerKitCreation(e){try{const t=await Ri.getAndFlush();if(!t)return;const r=new Pi(await e.getApiClientOptions()),s=await r.setupSsoKit(t),i=await _i.get();i.id=s.id,await _i.updateLocalKitIdWith(i)}catch(e){console.error(e),await _i.flush(),await Ri.flush()}}};const $n=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.accountRecoveryModel.findOrganizationPolicy({creator:!0,"creator.gpgkey":!0})}};class Vn extends T{constructor(e,t={}){if(super(U.validate(Vn.ENTITY_NAME,e,Vn.getSchema()),t),!e.policy&&!e.account_recovery_organization_public_key)throw new R("AccountRecoveryOrganizationPolicyChangeEntity expects a policy or an account_recovery_organization_public_key set to be valid.");if(e.policy===hr.POLICY_DISABLED&&e.account_recovery_organization_public_key)throw new R("AccountRecoveryOrganizationPolicyChangeEntity expects not to have an account recovery organization public key if the policy type is disabled.");this._props.account_recovery_organization_public_key&&(this._account_recovery_organization_public_key=new dr(this._props.account_recovery_organization_public_key,{clone:!1}),hr.assertValidAccountRecoveryOrganizationPublicKey(this._account_recovery_organization_public_key,this.public_key_id),delete this._props.account_recovery_organization_public_key)}static getSchema(){return{type:"object",required:[],properties:{policy:hr.getSchema().properties.policy,account_recovery_organization_public_key:dr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._account_recovery_organization_public_key&&e.account_recovery_organization_public_key&&(t.account_recovery_organization_public_key=this._account_recovery_organization_public_key.toDto()),t):t}toJSON(){return this.toDto({account_recovery_organization_public_key:!0})}get policy(){return this._props.policy||null}get accountRecoveryOrganizationPublicKey(){return this._account_recovery_organization_public_key||null}get armoredKey(){return this._account_recovery_organization_public_key?.armoredKey||null}get isDisabled(){return!!this.policy&&this.policy===hr.POLICY_DISABLED}static get ENTITY_NAME(){return"AccountRecoveryOrganizationChangePolicy"}}const Yn=Vn;const Gn=class{static async sign(e,t){return ze(e),Ke(t),e.signAllUsers(t)}};const Wn=class{static async revoke(e){Be(e);const{publicKey:t}=await ae.CB({key:e,format:"object"});return t}};var Hn=r(7946);const Jn={openInDetachedMode:async function(e=[]){const t=(0,w.A)(),r=await async function(e,t){const r=await Hn.action.getPopup({}),s=new URL(r);return s.searchParams.set("passbolt",t),e.forEach((e=>s.searchParams.append(e.name,e.value))),s.href}(e,t),{top:s,left:i}=await async function(){const e=await Hn.windows.getCurrent(),t=e.left+e.width-380,r=e.top;return{top:r,left:t}}(),a={url:r,type:"popup",left:i,top:s,width:380,height:400},o=await Hn.windows.create(a);return await async function(e,t){const r={id:e,name:"QuickAccess",tabId:t,frameId:0,status:q.STATUS_WAITING_CONNECTION};await j.addWorker(new q(r))}(t,o.tabs[0].id),Hn.windows.update(o.id,{left:i,top:s}),o}};class Zn extends Error{constructor(e){super(e),this.name="UserAbortsOperationError"}}const Qn=Zn;class Xn extends T{constructor(e,t={}){super(U.validate(Xn.ENTITY_NAME,e,Xn.getSchema()),t)}static getSchema(){return{type:"object",required:["duration"],properties:{duration:{type:"integer",minimum:-1}}}}get props(){return this._props}get duration(){return this._props.duration}static get ENTITY_NAME(){return"UserRememberMeLatestChoice"}}const ec=Xn;var tc=r(7946);const rc=class{constructor(e){this.storageKey=this.getStorageKey(e)}getStorageKey(e){if(!e.id)throw new Error("Cannot retrieve account id, necessary to get a rememberMe storage key.");return`userRememberMeLatestChoice-${e.id}`}async flush(){m.write({level:"debug",message:"UserRememberMeLatestChoiceLocalStorage flushed"}),await tc.storage.local.remove(this.storageKey)}async get(){const e=await tc.storage.local.get([this.storageKey]);if(!e||!e[this.storageKey])return null;try{return new ec(e[this.storageKey])}catch(e){return console.error(e),null}}async set(e){await navigator.locks.request(this.storageKey,(async()=>{await tc.storage.local.set({[this.storageKey]:e.toDto()})}))}};var sc=r(7946);class ic{static async start(){await ic.isStarted()||await sc.alarms.create(ic.ALARM_NAME,{delayInMinutes:15,periodInMinutes:15})}static async isStarted(){return Boolean(await sc.alarms.get(ic.ALARM_NAME))}static async stop(){await sc.alarms.clear(ic.ALARM_NAME)}static async handleKeepSessionAlive(e){if(e.name!==ic.ALARM_NAME)return;if(null===await Wi.get())return;const t=await Ro.get(),r=ta.buildFromAccount(t);new Fs(r).keepSessionAlive()}static get ALARM_NAME(){return"SessionKeepAlive"}}const ac=ic;class oc{constructor(e){this.userRememberMeLatestChoiceStorage=new rc(e)}async getPassphrase(e){const t=await Wi.get();return t||this.requestPassphrase(e)}async requestPassphrase(e){const t=await e.port.request("passbolt.passphrase.request"),{passphrase:r,rememberMe:s}=t;return await this.validatePassphrase(r),await this.rememberPassphrase(r,s),r}async requestPassphraseFromQuickAccess(){const e=await Wi.get();if(e)return e;const t=Math.round(Math.random()*Math.pow(2,32)).toString(),r=[{name:"uiMode",value:"detached"},{name:"feature",value:"request-passphrase"},{name:"requestId",value:t}],s=await Jn.openInDetachedMode(r),{passphrase:i,rememberMe:a}=await this.listenToDetachedQuickaccessPassphraseRequestResponse(t,s);return await this.validatePassphrase(i),await this.rememberPassphrase(i,a),i}async listenToDetachedQuickaccessPassphraseRequestResponse(e,t){const r=t?.tabs?.[0]?.id;await zs.waitExists("QuickAccess",r);const s=await zs.get("QuickAccess",r);let i=!1;return new Promise(((t,r)=>{s.port.on(e,((e,s)=>{i=!0,"SUCCESS"===e?t(s):r(s)})),s.port._port.onDisconnect.addListener((()=>{if(!i){i=!0;const e=new Qn("The dialog has been closed.");r(e)}}))}))}async rememberPassphrase(e,t){if(!t||!Number.isInteger(t))return;await Promise.all([Wi.set(e,t),ac.start()]);const r=new ec({duration:parseInt(t,10)});this.userRememberMeLatestChoiceStorage.set(r)}async validatePassphrase(e){ye(e);const t=(new xt).findPrivate().armoredKey,r=await Je(t);await Fr.decrypt(r,e)}}class nc extends T{constructor(e,t={}){super(U.validate(nc.ENTITY_NAME,e,nc.getSchema()),t)}static getSchema(){return{type:"object",required:["type","version","domain","private_key_user_id","private_key_fingerprint","private_key_secret","created"],properties:{type:{type:"string",enum:["account-recovery-private-key-password-decrypted-data"]},version:{type:"string",enum:["v1"]},domain:{type:"string"},private_key_user_id:{type:"string",format:"uuid"},private_key_fingerprint:{type:"string",minLength:40,maxLength:40},private_key_secret:{type:"string",minLength:128,maxLength:128},created:{type:"string",format:"date-time"}}}}get type(){return this._props.type}get version(){return this._props.version}get domain(){return this._props.domain}get privateKeyUserId(){return this._props.private_key_user_id}get privateKeyFingerprint(){return this._props.private_key_fingerprint}get privateKeySecret(){return this._props.private_key_secret}get created(){return this._props.created}static get ENTITY_NAME(){return"AccountRecoveryPrivateKeyPasswordDecryptedData"}}const cc=nc;const lc=class{static async decrypt(e,t,r,s,i){let a;if(t.getFingerprint().toUpperCase()!==e.recipientFingerprint)throw new Error("The decryption key fingerprint does not match the private key password recipient fingerprint.");const o=await Ge(e.data),n=await Mi.decrypt(o,t);try{a=JSON.parse(n)}catch(e){throw new Error("Unable to parse the decrypted private key password data.")}const c=new cc(a);if(c.domain!==r)throw console.debug("The decrypted private key password data domain does not match the organization domain: ",{privateKeyPasswordId:e.id,userId:c.privateKeyUserId,domain:c.domain}),new Error("The domain contained in the private key password data does not match the expected target domain.");if(s&&c.privateKeyUserId!==s)throw new Error("The user id contained in the private key password data does not match the private key target used id.");if(i&&c.privateKeyFingerprint!==i.getFingerprint().toUpperCase())throw new Error("The private key password data fingerprint should match the user public fingerprint.");return c}};class uc extends T{constructor(e,t={}){super(U.validate(uc.ENTITY_NAME,e,uc.getSchema()),t)}static getSchema(){return{type:"object",required:["armored_key","passphrase"],properties:{armored_key:{type:"string"},passphrase:{type:"string"}}}}get armoredKey(){return this._props.armored_key}get passphrase(){return this._props.passphrase}static get ENTITY_NAME(){return"PrivateGpgkey"}}const dc=uc;const pc=class{constructor(e,t){this.worker=e,this._title=t,this._progress=0,this.lastTimeCall=null,this.message=null,this.isClose=!1}set title(e){this._title=e}get progress(){return this._progress}get goals(){return this._goals}start(e,t){this._progress=0,this._goals=e,this.isClose=!1,this.worker.port.emit("passbolt.progress.open-progress-dialog",this._title,e,t),this.lastTimeCall=(new Date).getTime()}updateGoals(e){this._goals=e,this.worker.port.emit("passbolt.progress.update-goals",e)}finishStep(e=null,t=!1){this.finishSteps(1,e,t)}finishSteps(e,t=null,r=!1){this._progress+=e,null!==t&&(this.message=t),this._debounceAction((()=>this._updateProgressBar()),r)}updateStepMessage(e){this.message=e,this._debounceAction((()=>this._updateProgressBar()))}close(){this.isClose=!0,this.worker.port.emit("passbolt.progress.close-progress-dialog")}_updateProgressBar(){this.worker.port.emit("passbolt.progress.update",this.message,this._progress)}_debounceAction(e,t=!1){if(this.isClose)return;const r=(new Date).getTime(),s=r-this.lastTimeCall;!t&&s<80||(this.lastTimeCall=r,e())}};const hc=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r),this.progressService=new pc(this.worker,ue.t("Rekeying users' key")),this.keyring=new xt,this.account=s,this.getPassphraseService=new oc(s)}async _exec(e,t=null){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t=null){const r=await this.getPassphraseService.getPassphrase(this.worker),s=new Yn(e),i=t?new dc(t):null,a=await this.accountRecoveryModel.findOrganizationPolicy(),o=Boolean(s.accountRecoveryOrganizationPublicKey),n=this._hasToRevokedCurrentORK(s,a),c=o?await Je(s.accountRecoveryOrganizationPublicKey.armoredKey):null,l=s.toDto({account_recovery_organization_public_key:!0});l.policy=l.policy||a.policy;const u=this.keyring.findPrivate().armoredKey,d=await Je(u),p=await Fr.decrypt(d,r);if(o){const e=await Gn.sign(c,[p]);l.account_recovery_organization_public_key.fingerprint=c.getFingerprint().toUpperCase(),l.account_recovery_organization_public_key.armored_key=e.armor()}else l.public_key_id=a.publicKeyId;if(n){const e=await Je(i.armoredKey),t=e.isDecrypted()?e:await Fr.decrypt(e,i.passphrase),r=await Wn.revoke(t);if(l.account_recovery_organization_revoked_key={armored_key:r.armor(),fingerprint:t.getFingerprint().toUpperCase()},o){const e=this.account.domain,r=await this._reEncryptPrivateKeyPasswords(c,t,p,e),s=await Gn.sign(c,[t]);l.account_recovery_organization_public_key.armored_key=s.armor(),l.account_recovery_private_key_passwords=r.toDto()}}const h=new hr(l);return this.accountRecoveryModel.saveOrganizationPolicy(h)}_hasToRevokedCurrentORK(e,t){return!t.isDisabled&&(!!e.isDisabled||Boolean(e.accountRecoveryOrganizationPublicKey)&&t.armoredKey!==e.armoredKey)}async _reEncryptPrivateKeyPasswords(e,t,r,s){const i=await this.accountRecoveryModel.findAccountRecoveryPrivateKeyPasswords();if(0===i.length)return new zt([]);this.progressService.start(i.length,ue.t("Updating users' key..."));const a=[];try{for(const o of i){const i=await this._reEncryptPrivateKeyPassword(o,e,t,r,s);a.push(i),await this.progressService.finishStep()}}catch(e){throw console.error(e),await this.progressService.close(),e}return await this.progressService.close(),new zt(a)}async _reEncryptPrivateKeyPassword(e,t,r,s,i){const a=await lc.decrypt(e,r,i),o=JSON.stringify(a),n=await Rs.encrypt(o,t,[r,s]);return new Kt({data:n,private_key_id:e.privateKeyId,recipient_fingerprint:t.getFingerprint().toUpperCase(),recipient_foreign_model:Kt.FOREIGN_MODEL_ORGANIZATION_KEY})}};const gc=class{constructor(e){this.authVerifyServerKeyService=new Us(e),this.keyring=new xt}async validatePublicKey(e,t){const r=await Je(e),s=await Ct.getKeyInfo(r);if(!s.isValid)throw new Error("The key should be a valid openpgp key.");if(s.algorithm!==vs.TYPE_RSA)throw new Error("The key algorithm should be RSA.");if(s.private)throw new Error("The key should be public.");if(s.revoked)throw new Error("The key should not be revoked.");if("Infinity"!==s.expires)throw new Error("The key should not have an expiry date.");if(s.length<4096)throw new Error("The key should be at least 4096 bits.");if((await this.authVerifyServerKeyService.getServerKey()).fingerprint.toUpperCase()===s.fingerprint)throw new Error("The key is the current server key, the organization recovery key must be a new one.");await this.keyring.sync();const i=this.keyring.getPublicKeysFromStorage();for(const e in i){if(i[e].fingerprint.toUpperCase()===s.fingerprint)throw new Error("The key is already being used, the organization recovery key must be a new one.")}if(!t)return;if((await Je(t)).getFingerprint().toUpperCase()===s.fingerprint)throw new Error("The key is the current organization recovery key, you must provide a new one.")}};const yc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r),this.validateOrganizationPublicKeyService=new gc(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this.accountRecoveryModel.findOrganizationPolicy();await this.validateOrganizationPublicKeyService.validatePublicKey(e,t.armoredKey)}};class mc extends Error{constructor(e,t){super(e),this.name="WrongOrganizationRecoveryKeyError",this.expectedFingerprint=t}}const wc=mc;const _c=class{static async validate(e,t){const r=await Je(e.accountRecoveryOrganizationPublicKey.armoredKey),s=await Je(t.armoredKey),i=r.getFingerprint().toUpperCase();if(i!==s.getFingerprint().toUpperCase())throw new wc(`Error, this is not the current organization recovery key. Expected fingerprint: ${i}`,i);s.isDecrypted()||await Fr.decrypt(s,t.passphrase)}};const fc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new dc(e),r=await this.accountRecoveryModel.findOrganizationPolicy();if(!r)throw new Error("Account recovery organization policy not found.");await _c.validate(r,t)}};const vc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!O().isUUID(e))throw new Error("The user id is not valid");const t={"has-users":[e]};return this.accountRecoveryModel.findUserRequests(t)}};const Sc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(void 0===e)throw new Error("An account recovery request id is required.");if("string"!=typeof e)throw new Error("The account recovery request should be a string.");if(!O().isUUID(e))throw new Error("The account recovery request should be a valid uuid.");return this.accountRecoveryModel.findRequestById(e,{creator:!0,"creator.gpgkey":!0})}};const bc=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.accountRecoveryModel=new Ur(r),this.keyringModel=new xt,this.getPassphraseService=new oc(s)}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t,r=null){if("string"!=typeof e||!O().isUUID(e))throw new TypeError("requestId should be a valid uuid.");let s;const i=await this.accountRecoveryModel.findOrganizationPolicy();if(i.isDisabled)throw new Error("Sorry the account recovery feature is not enabled for this organization.");const a=await this._findAndAssertRequest(e);if(t===Ir.STATUS_APPROVED){const e=new dc(r),t=await this.getPassphraseService.getPassphrase(this.worker);s=await this._buildApprovedResponse(a,i,e,t)}else{if(t!==Ir.STATUS_REJECTED)throw new Error("The provided status should be either approved or rejected.");s=this._buildRejectedResponse(e,i)}const o=await this.accountRecoveryModel.saveReview(s);return await this._updateUserLocalStorage(a.userId),o}_buildRejectedResponse(e,t){const r={status:Ir.STATUS_REJECTED,account_recovery_request_id:e,responder_foreign_key:t.publicKeyId,responder_foreign_model:Ir.RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY};return new Ir(r)}async _buildApprovedResponse(e,t,r,s){const i=await Je(r.armoredKey),a=await Je(this.account.userPrivateArmoredKey),o=i.isDecrypted()?i:await Fr.decrypt(i,r.passphrase),n=await Fr.decrypt(a,s),c=await Je(await this._findUserPublicKey(e.userId)),l=await this._encryptResponseData(e,o,c,n),u={status:Ir.STATUS_APPROVED,account_recovery_request_id:e.id,responder_foreign_key:t.publicKeyId,responder_foreign_model:Ir.RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY,data:l};return new Ir(u)}async _findAndAssertRequest(e){const t=await this.accountRecoveryModel.findRequestById(e,{account_recovery_private_key_passwords:!0,armored_key:!0}),r=t.accountRecoveryPrivateKey;if(!r)throw new Error("The request should have an associated private key.");if(r.userId!==t.userId)throw new Error("The request user should match the request associated private key user.");if(!r.accountRecoveryPrivateKeyPasswords)throw new Error("The account recovery request private key should have a collection of private key passwords.");if(1!==r.accountRecoveryPrivateKeyPasswords.length)throw new Error("The account recovery request private key should have a collection containing exactly one private key password.");const s=r.accountRecoveryPrivateKeyPasswords.items[0];if(s.recipientForeignModel!==Kt.FOREIGN_MODEL_ORGANIZATION_KEY)throw new Error("The request private key password should be encrypted for the organization key.");if(s.privateKeyId!==r.id)throw new Error("The request private key password private key id should match the request private key id.");return t}async _findUserPublicKey(e){let t=this.keyringModel.findPublic(e);if(!t&&(await this.keyringModel.sync(),t=this.keyringModel.findPublic(e),!t))throw new Error("Cannot find the public key of the user requesting an account recovery.");return t.armoredKey}async _encryptResponseData(e,t,r,s){const i=this.account.domain,a=e.accountRecoveryPrivateKey.accountRecoveryPrivateKeyPasswords.items[0],o=await lc.decrypt(a,t,i,e.userId,r),n=JSON.stringify(o),c=await Je(e.armoredKey);return Rs.encrypt(n,c,[t,s])}async _updateUserLocalStorage(e){const t=await oa.getUserById(e);t.pending_account_recovery_request=null;const r=new lr(t);await oa.updateUser(r)}};const Ec=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.apiClientOptions=r}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e={}){const t={type:vs.TYPE_RSA,keySize:4096,date:await _s.getDate(this.apiClientOptions)};Object.assign(e,t);const r=new vs(e);return ks.generateKeyPair(r)}};var kc=r(6142),Ac=r.n(kc);const Tc=class{static async build(e,t,r){if(Be(t),!(r&&r instanceof hr))throw new Error("The provided organizationPolicy must be a valid AccountRecoveryOrganizationPolicyEntity.");const s=Ac().random(512),i=await this._encryptPrivateKey(s,t),a=await this._encryptPrivateKeyPasswordsForOrganizationKey(e,s,r,t);i.account_recovery_private_key_passwords=[a];const o={user_id:e.userId,status:ar.STATUS_APPROVED,account_recovery_private_key:i};return new ar(o)}static async _encryptPrivateKey(e,t){return{data:await Rs.encryptSymmetrically(t.armor(),[e],[t])}}static async _encryptPrivateKeyPasswordsForOrganizationKey(e,t,r,s){const i=await Je(r.armoredKey),a=this._buildPrivateKeyPasswordDecryptedData(e,t),o=JSON.stringify(a.toDto());return{data:await Rs.encrypt(o,i,[s]),recipient_foreign_model:Kt.FOREIGN_MODEL_ORGANIZATION_KEY,recipient_fingerprint:i.getFingerprint().toUpperCase()}}static _buildPrivateKeyPasswordDecryptedData(e,t){const r={domain:e.domain,type:"account-recovery-private-key-password-decrypted-data",version:"v1",private_key_user_id:e.userId,private_key_fingerprint:e.userKeyFingerprint,private_key_secret:t,created:(new Date).toISOString()};return new cc(r)}};const Ic=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.keyring=new xt,this.account=s,this.accountRecoveryModel=new Ur(r),this.getPassphraseService=new oc(s)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this.accountRecoveryModel.findOrganizationPolicy();if(!t)throw new Error("Account recovery organization policy not found.");if(t.isDisabled)throw new Error("The Account recovery organization policy should be enabled.");let r;if(e.status===ar.STATUS_APPROVED)r=await this.buildApprovedUserSetting(t);else{const e={user_id:re.getInstance().get().id,status:ar.STATUS_REJECTED};r=new ar(e)}return this.accountRecoveryModel.saveUserSetting(r)}async buildApprovedUserSetting(e){const t=await this.getPassphraseService.requestPassphrase(this.worker),r=this.keyring.findPrivate().armoredKey,s=await Je(r),i=await Fr.decrypt(s,t);return Tc.build(this.account,i,e)}};let Rc=!1,Cc=!1;const Oc=class{static hasPostponedAccountRecovery(){return Rc}static hasPostponedMFAPolicy(){return Cc}static postponeAccountRecovery(){Rc=!0}static postponeMFAPolicy(){Cc=!0}static reset(){Rc=!1,Cc=!1}};const xc=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return Oc.hasPostponedAccountRecovery()}};const Pc=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){Oc.postponeAccountRecovery()}};var Nc=r(7946);const Uc=class{static async saveFile(e,t,r,s){r||(r="text/plain"),t=new Blob([t],{type:r});const i=await this.blobToDataURL(t);if(chrome.downloads){const t=new E(s),r=await t.injectBase64UrlToCreateObjectURL(i);await Nc.downloads.download({url:r,filename:e}),t.injectURLToRevoke(r)}else{(await zs.get("FileIframe",s)).port.emit("passbolt.file-iframe.download",e,i)}}static blobToDataURL(e){return new Promise((t=>{const r=new FileReader;r.onload=function(e){t(e.target.result)},r.readAsDataURL(e)}))}},Dc={[ri.PROVIDER_ID]:ri.SUPPORTED_URLS,[ai.PROVIDER_ID]:ai.SUPPORTED_URLS};class Mc extends T{constructor(e,t){super(U.validate(Mc.ENTITY_NAME,e,Mc.getSchema(t)))}static getSchema(e){return{type:"object",required:["url"],properties:{url:{type:"x-custom",validationCallback:t=>Mc.validateUrl(t,e)}}}}static validateUrl(e,t){if("string"!=typeof e)throw new TypeError("The url should be a string.");let r;try{r=new URL(e)}catch(e){throw new Error("The url should be a valid url.")}if(t===ci.PROVIDER_ID||t===di.PROVIDER_ID){if("https:"!==r.protocol)throw new Error("The url protocol should be HTTPS.");return}if(!Dc[t])throw new Error("The url should be part of the list of supported single sign-on urls.");if(!Dc[t].some((e=>r.origin===e)))throw new Error("The url should be part of the list of supported single sign-on urls.")}get url(){return this._props.url}static get ENTITY_NAME(){return"SsoLoginUrl"}}const Lc=Mc;var Fc=r(7946);const qc=class{constructor(e,t,r){this.popup=null,this.popupTabId=null,this.verifyCodeInTab=this.verifyCodeInTab.bind(this),this.verifyPopupClosed=this.verifyPopupClosed.bind(this);const s=r?"/sso/login/dry-run/success":"/sso/login/success";this.expectedUrl=`${e}${s}`,this.originTabIdCall=t}async getSsoTokenFromThirdParty(e){if(!(e instanceof Lc))throw new Error("The login URL should be a valid instance of a SsoLoginUrlEntity");return this.popup=await this.openPopup(e.url),this.popupTabId=this.popup.tabs[0].id,new Promise(((e,t)=>{this.resolvePromise=e,this.rejectPromise=t,Fc.tabs.onUpdated.addListener(this.verifyCodeInTab),Fc.tabs.onRemoved.addListener(this.verifyPopupClosed)}))}async verifyCodeInTab(e,t,r){if(e===this.originTabIdCall)return this.rejectPromise(new Qn("The user navigated away from the tab where the SSO sign-in initiated")),void await this.closeHandler();if(e!==this.popupTabId)return;if("complete"!==r.status)return;const s=this.grabSsoTokenFromUrl(r.url);null!==s&&this.resolvePromise(s)}async verifyPopupClosed(e){e===this.originTabIdCall?(this.rejectPromise(new Qn("The user closed the tab from where the SSO sign-in initiated")),await this.closeHandler()):e===this.popupTabId&&this.rejectPromise(new Qn("The user closed the SSO sign-in popup"))}async closeHandler(){Fc.tabs.onUpdated.removeListener(this.verifyCodeInTab),Fc.tabs.onRemoved.removeListener(this.verifyPopupClosed),this.rejectPromise=null,this.resolvePromise=null,this.codeFound=null,this.popup&&!this.popup.closed&&Fc.tabs.remove(this.popupTabId),this.popup=null}async openPopup(e){const t={url:e,type:"popup",width:380,height:600};return await Fc.windows.create(t)}grabSsoTokenFromUrl(e){if(!e.startsWith(this.expectedUrl))return null;const t=new URL(e).searchParams.get("token")||null;return t?(he(t,"The SSO token should be a valid uuid."),t):void 0}};class Kc{constructor(e){this.apiClientOptions=e}static get RESOURCE_NAME(){return"/sso/${providerId}/login/dry-run"}async getUrl(e,t){return(await this.getApiClient(e).create(t)).body}getApiClient(e){if("string"!=typeof e)throw new Error("The provider identifier should be a string");const t=Kc.RESOURCE_NAME.replace("${providerId}",e);return this.apiClientOptions.setResourceName(t),new ut(this.apiClientOptions)}}const Bc=Kc;const jc=class{constructor(e){this.ssoDryRunService=new Bc(e)}async getUrl(e,t){if(he(t,"The SSO settings id should be a valid uuid."),"string"!=typeof e)throw new Error("The provider identifier should be a valid string");const r={sso_settings_id:t},s=await this.ssoDryRunService.getUrl(e,r);return new Lc(s,e)}};const zc=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.ssoSettingsModel=new gi(r),this.ssoDryRunModel=new jc(r),this.popupHandler=new qc(s.domain,e?.tab?.id,!0)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){he(e,"The SSO settings id should be a valid uuid.");try{const t=await this.ssoSettingsModel.getById(e),r=await this.ssoDryRunModel.getUrl(t.provider,t.id),s=await this.popupHandler.getSsoTokenFromThirdParty(r);return await this.popupHandler.closeHandler(),s}catch(e){throw console.error("An error occured while attempting sign in with a third party provider:",e),e}}};const $c=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new gi(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.ssoSettingsModel.getCurrent({data:!0})}};const Vc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new gi(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new hi(e);return this.ssoSettingsModel.saveDraft(t)}};const Yc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new gi(r)}async _exec(e,t){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){return he(e,"The SSO settings id should be a valid uuid."),he(t,"The SSO activation token should be a valid uuid."),await this.ssoSettingsModel.activate(e,t)}};const Gc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new gi(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){he(e,"The SSO settings id should be a valid uuid."),await this.ssoSettingsModel.delete(e)}};const Wc=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.ssoKitServerPartModel=new Pi(r),this.getPassphraseService=new oc(s)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await _i.get();if(t)return void(t?.provider!==e&&(t.provider=e,await _i.updateLocalKitProviderWith(t)));const r=await this.getPassphraseService.getPassphrase(this.worker),s=await Ci.generateSsoKits(r,e),i=await this.ssoKitServerPartModel.setupSsoKit(s.serverPart);s.clientPart.id=i.id,await _i.save(s.clientPart)}};class Hc extends T{constructor(e,t={}){super(U.validate(Hc.ENTITY_NAME,e,Hc.getSchema()),t)}static getSchema(){return{type:"object",required:["id","name"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",maxLength:255}}}}get id(){return this._props.id}get name(){return this._props.name}static get ENTITY_NAME(){return"Action"}}const Jc=Hc;class Zc extends T{constructor(e,t={}){super(U.validate(Zc.ENTITY_NAME,e,Zc.getSchema()),t)}static getSchema(){return{type:"object",required:["id","name"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",maxLength:255}}}}get id(){return this._props.id}get name(){return this._props.name}static get ENTITY_NAME(){return"UiAction"}}const Qc=Zc;const Xc="Allow",el="Deny",tl="AllowIfGroupManagerInOneGroup";class rl extends T{constructor(e,t={}){super(U.validate(rl.ENTITY_NAME,e,rl.getSchema()),t),this._props.action&&(this._action=new Jc(this._props.action,{clone:!1})),delete this._props.action,this._props.ui_action&&(this._ui_action=new Qc(this._props.ui_action,{clone:!1})),delete this._props.ui_action}static getSchema(){return{type:"object",required:["id","role_id","foreign_model","foreign_id","control_function"],properties:{id:{type:"string",format:"uuid"},role_id:{type:"string",format:"uuid"},foreign_model:{type:"string",enum:[rl.FOREIGN_MODEL_ACTION,rl.FOREIGN_MODEL_UI_ACTION]},foreign_id:{type:"string",format:"uuid"},control_function:{type:"string",enum:[Xc,el,tl]},action:Jc.getSchema(),ui_action:Qc.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._action&&e.action&&(t.action=this._action.toDto()),this._ui_action&&e.ui_action&&(t.ui_action=this._ui_action.toDto()),t):t}toUpdateDto(){return{id:this.id,control_function:this.controlFunction}}toJSON(){return this.toDto(rl.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id}get roleId(){return this._props.role_id}get foreignModel(){return this._props.foreign_model}get foreignId(){return this._props.foreign_id}get controlFunction(){return this._props.control_function}set controlFunction(e){U.validateProp("control_function",e,rl.getSchema().properties.control_function),this._props.control_function=e}get action(){return this._action||null}get uiAction(){return this._ui_action||null}static get ENTITY_NAME(){return"Rbac"}static get ALL_CONTAIN_OPTIONS(){return{action:!0,ui_action:!0}}static get FOREIGN_MODEL_ACTION(){return"Action"}static get FOREIGN_MODEL_UI_ACTION(){return"UiAction"}}const sl=rl;class il extends Ft{constructor(e,t=!1){super(U.validate(il.ENTITY_NAME,e,il.getSchema())),this._props.forEach((e=>{try{this._items.push(new sl(e))}catch(e){if(!t)throw e}})),this._props=null}static getSchema(){return{type:"array",items:sl.getSchema()}}get rbacs(){return this._items}toBulkUpdateDto(){return this.items.map((e=>e.toUpdateDto()))}findRbacByRoleAndUiActionName(e,t){if(!(e instanceof Yt))throw new Error("The role parameter should be a role entity.");if("string"!=typeof t&&!(t instanceof String))throw new Error("The name parameter should be a valid string.");return this.rbacs.find((r=>r.roleId===e.id&&r.uiAction?.name===t))}findRbacByActionName(e){if("string"!=typeof e&&!(e instanceof String))throw new Error("The name parameter should be a valid string.");return this.rbacs.find((t=>t.uiAction?.name===e))}push(e){if(!e||"object"!=typeof e)throw new TypeError("The function expect an object as parameter");e instanceof sl&&(e=e.toDto(sl.ALL_CONTAIN_OPTIONS));const t=new sl(e);super.push(t)}addOrReplace(e){const t=this.items.findIndex((t=>t.id===e.id));t>-1?this._items[t]=e:this.push(e)}remove(e){const t=this.items.length;let r=0;for(;r<t;r++){if(this.items[r].id===e.id)return void this._items.splice(r,1)}}static get ENTITY_NAME(){return"Rbacs"}static get RULE_UNIQUE_ID(){return"unique_id"}}const al=il;const ol=class{constructor(e,t){e.setResourceName(t),this.apiClient=new ut(e)}formatContainOptions(e,t){const r={};for(const s in e){if("string"!=typeof s){const t=JSON.stringify(e);throw new TypeError(`Invalid contain ${t}, items should be a string.`)}t.includes(s)&&(r[`contain[${s}]`]=e[s]?"1":"0")}return r}formatFilterOptions(e,t){const r={};for(const s in e)if(Object.prototype.hasOwnProperty.call(e,s)&&t.includes(s))if("boolean"==typeof e[s])r[`filter[${s}]`]=e[s]?"1":"0";else if("string"==typeof e[s])r[`filter[${s}]`]=e[s];else{if(!Array.isArray(e[s]))throw new TypeError("Service error. Filter option should be an array or a string.");r[`filter[${s}][]`]=e[s]}return r}formatOrderOptions(e,t){const r={};for(const s in e)t.includes(s)&&(r["order[]"]=s);return r}assertValidId(e){if(!e||"string"!=typeof e||!O().isUUID(e))throw new TypeError(`Service error. The id '${e}' is not a valid uuid.`)}assertNonEmptyData(e){if(!e)throw new TypeError("Service error. Data cannot be empty.")}};class nl extends ol{constructor(e){super(e,nl.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/rbacs"}static getSupportedContainOptions(){return["action","ui_action"]}async findAll(e){const t=e?this.formatContainOptions(e,nl.getSupportedContainOptions()):null;return(await this.apiClient.findAll(t)).body}async updateAll(e,t={}){const r=t?this.formatContainOptions(t,nl.getSupportedContainOptions()):null;return(await this.apiClient.updateAll(e,r)).body}}const cl=nl;class ll extends ol{constructor(e){super(e,ll.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/rbacs/me"}static getSupportedContainOptions(){return["action","ui_action"]}async findMe(e){const t=e?this.formatContainOptions(e,ll.getSupportedContainOptions()):null;return(await this.apiClient.findAll(t)).body}}const ul=ll;var dl=r(7946);class pl{constructor(e){this.storageKey=this.getStorageKey(e)}getStorageKey(e){if(!e.id)throw new Error("Cannot retrieve account id, necessary to get a rbac storage key.");return`rbac-${e.id}`}async flush(){return m.write({level:"debug",message:"RbacLocalStorage flushed"}),await dl.storage.local.remove(this.storageKey)}async get(){return(await dl.storage.local.get([this.storageKey]))[this.storageKey]}async set(e){await navigator.locks.request(this.storageKey,(async()=>{const t=[];if(e){if(!(e instanceof al))throw new TypeError("RbacsLocalStorage::set expects a RbacsCollection");for(const r of e)pl.assertEntityBeforeSave(r),t.push(r.toDto(sl.ALL_CONTAIN_OPTIONS))}await dl.storage.local.set({[this.storageKey]:t})}))}static assertEntityBeforeSave(e){if(!e)throw new TypeError("RolesLocalStorage expects a RbacEntity to be set");if(!(e instanceof sl))throw new TypeError("RolesLocalStorage expects an object of type RbacEntity");if(!e.id)throw new TypeError("RolesLocalStorage expects RbacEntity id to be set")}}const hl=pl;const gl=class{constructor(e,t){this.userModel=new To(e,t),this.rbacService=new cl(e),this.rbacMeService=new ul(e),this.rbacsLocalStorage=new hl(t)}async findAll(e={}){const t=await this.rbacService.findAll(e);return new al(t,!0)}async updateLocalStorage(e={}){const t=await this.rbacMeService.findMe(e),r=new al(t,!0);return this.rbacsLocalStorage.set(r),r}async getOrFindMe(e={}){const t=await this.rbacsLocalStorage.get();return void 0!==t?new al(t,!0):this.updateLocalStorage(e)}};const yl=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.rbacModel=new gl(r,s)}async _exec(){try{const e=await this.exec.apply(this,arguments);this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.rbacModel.getOrFindMe({ui_action:!0})}},ml=["abdominal","acclimate","accompany","activator","acuteness","aerospace","affecting","affection","affidavit","affiliate","afflicted","afterglow","afterlife","aftermath","aftermost","afternoon","aggregate","agonizing","agreeable","agreeably","agreement","alabaster","albatross","algorithm","alienable","alongside","amazingly","ambiguity","ambiguous","ambitious","ambulance","amendable","amendment","amplifier","amusement","anaerobic","anatomist","angelfish","angriness","anguished","animating","animation","animosity","announcer","answering","antarctic","anthology","antiquely","antiquity","antitoxic","antitrust","antiviral","antivirus","appealing","appeasing","appendage","appetizer","appliance","applicant","appointee","appraisal","appraiser","apprehend","arbitrary","arbitrate","armadillo","arrogance","ascension","ascertain","asparagus","astrology","astronaut","astronomy","atrocious","attendant","attention","attentive","attractor","attribute","audacious","augmented","authentic","autograph","automaker","automated","automatic","autopilot","available","avalanche","backboard","backboned","backfield","backlands","backlight","backpedal","backshift","backspace","backstage","backtrack","backwater","bacterium","bagginess","balancing","bannister","barometer","barracuda","barricade","bartender","basically","battalion","battering","blanching","blandness","blaspheme","blasphemy","blatantly","blunderer","bodacious","boogeyman","boogieman","boondocks","borrowing","botanical","boundless","bountiful","breeching","brilliant","briskness","broadband","broadcast","broadness","broadside","broadways","bronchial","brownnose","brutishly","buccaneer","bucktooth","buckwheat","bulginess","bulldozer","bullfight","bunkhouse","cabdriver","calculate","calibrate","camcorder","canopener","capillary","capricorn","captivate","captivity","cardboard","cardstock","carefully","caregiver","caretaker","carnation","carnivore","carpenter","carpentry","carrousel","cartridge","cartwheel","catatonic","catchable","cathedral","cattishly","caucasian","causation","cauterize","celestial","certainly","certainty","certified","challenge","chamomile","chaperone","character","charbroil","chemicals","cherisher","chihuahua","childcare","childhood","childless","childlike","chokehold","circulate","clamshell","clergyman","clubhouse","clustered","coagulant","coastland","coastline","cofounder","cognition","cognitive","coherence","collected","collector","collision","commodity","commodore","commotion","commuting","compacted","compacter","compactly","compactor","companion","component","composite","composure","comprised","computing","concerned","concierge","condiment","condition","conducive","conductor","confidant","confident","confiding","configure","confining","confusing","confusion","congenial","congested","conjoined","connected","connector","consensus","consoling","consonant","constable","constrain","constrict","construct","consuming","container","contented","contently","contusion","copartner","cornbread","cornfield","cornflake","cornstalk","corporate","corroding","corrosive","cosmetics","cosponsor","countable","countdown","countless","crabgrass","craftsman","craftwork","cranberry","craziness","creamlike","creatable","crestless","crispness","crudeness","cruelness","crummiest","crunching","crushable","cubbyhole","culminate","cultivate","cupbearer","curliness","curvature","custodian","customary","customize","cytoplasm","cytoplast","dandelion","daredevil","darkening","darwinism","dastardly","deafening","dealmaker","debatable","decathlon","deceiving","deception","deceptive","decidable","decimeter","decompose","decorated","decorator","dedicator","defection","defective","defendant","defensive","deflation","deflected","deflector","degrading","dehydrate","delegator","delicious","delighted","delirious","deliverer","demanding","demeaning","democracy","demystify","denatured","deodorant","deodorize","departure","depletion","depravity","deprecate","desecrate","deserving","designate","designing","deskbound","destitute","detection","detective","detention","detergent","detonator","deviation","devotedly","devouring","dexterity","dexterous","diagnoses","diagnosis","diaphragm","dictation","difficult","diffusion","diffusive","diligence","dinginess","direction","directive","directory","dirtiness","disbelief","discharge","discourse","disengage","disfigure","disinfect","disliking","dislocate","dismantle","disparate","disparity","dispersal","dispersed","disperser","displease","disregard","dividable","divisible","divisibly","dizziness","dollhouse","doorframe","dormitory","dragonfly","dragonish","drainable","drainpipe","dramatize","dreadlock","dreamboat","dreamland","dreamless","dreamlike","drinkable","drop-down","dubiously","duplicate","duplicity","dwindling","earthlike","earthling","earthworm","eastbound","eastcoast","eccentric","ecologist","economist","ecosphere","ecosystem","education","effective","efficient","eggbeater","egomaniac","egotistic","elaborate","eldercare","electable","elevating","elevation","eliminate","elongated","eloquence","elsewhere","embattled","embellish","embroider","emergency","emphasize","empirical","emptiness","enactment","enchanted","enchilada","enclosure","encounter","encourage","endearing","endocrine","endorphin","endowment","endurable","endurance","energetic","engraving","enigmatic","enjoyable","enjoyably","enjoyment","enlarging","enlighten","entangled","entertain","entourage","enunciate","epidermal","epidermis","epileptic","equipment","equivocal","eradicate","ergonomic","escalator","escapable","esophagus","espionage","essential","establish","estimator","estranged","ethically","euphemism","evaluator","evaporate","everglade","evergreen","everybody","evolution","excavator","exceeding","exception","excitable","excluding","exclusion","exclusive","excretion","excretory","excursion","excusable","excusably","exemplary","exemplify","exemption","exerciser","exfoliate","exonerate","expansion","expansive","expectant","expedited","expediter","expensive","expletive","exploring","exposable","expulsion","exquisite","extending","extenuate","extortion","extradite","extrovert","extruding","exuberant","facecloth","faceplate","facsimile","factsheet","fanciness","fantasize","fantastic","favorable","favorably","ferocious","festivity","fidgeting","financial","finishing","flagstick","flagstone","flammable","flashback","flashbulb","flashcard","flattered","flatterer","flavorful","flavoring","footboard","footprint","fragility","fragrance","fraternal","freemason","freestyle","freezable","frequency","frightful","frigidity","frivolous","frostbite","frostlike","frugality","frustrate","gainfully","gallantly","gallstone","galvanize","gathering","gentleman","geography","geologist","geometric","geriatric","germicide","germinate","germproof","gestation","gibberish","giddiness","gigahertz","gladiator","glamorous","glandular","glorified","glorifier","glutinous","goldsmith","goofiness","graceless","gradation","gradually","grappling","gratified","gratitude","graveness","graveyard","gravitate","greedless","greyhound","grievance","grimacing","griminess","grumbling","guacamole","guileless","gumminess","habitable","hamburger","hamstring","handbrake","handclasp","handcraft","handiness","handiwork","handlebar","handprint","handsfree","handshake","handstand","handwoven","handwrite","hankering","haphazard","happening","happiness","hardcover","hardening","hardiness","hardwired","harmonica","harmonics","harmonize","hastiness","hatchback","hatchling","headboard","headcount","headdress","headfirst","headphone","headpiece","headscarf","headstand","headstone","heaviness","heftiness","hemstitch","herbicide","hesitancy","humiliate","humongous","humorless","hunchback","hundredth","hurricane","huskiness","hydration","hydroxide","hyperlink","hypertext","hypnotism","hypnotist","hypnotize","hypocrisy","hypocrite","ibuprofen","idealness","identical","illicitly","imaginary","imitation","immersion","immorally","immovable","immovably","impatient","impending","imperfect","implement","implicate","implosion","implosive","important","impotence","impotency","imprecise","impromptu","improving","improvise","imprudent","impulsive","irregular","irritable","irritably","isolating","isolation","italicize","itinerary","jackknife","jailbreak","jailhouse","jaywalker","jeeringly","jockstrap","jolliness","joylessly","jubilance","judgingly","judiciary","juiciness","justifier","kilometer","kinswoman","laborious","landowner","landscape","landslide","lankiness","legislate","legwarmer","lethargic","levitator","liability","librarian","limelight","litigator","livestock","lubricant","lubricate","luckiness","lucrative","ludicrous","luminance","lumpiness","lunchroom","lunchtime","luridness","lustfully","lustiness","luxurious","lyrically","machinist","magnesium","magnetism","magnetize","magnifier","magnitude","majorette","makeshift","malformed","mammogram","mandatory","manhandle","manicotti","manifesto","manliness","marauding","margarine","margarita","marmalade","marshland","marsupial","marvelous","masculine","matchbook","matchless","maternity","matriarch","matrimony","mayflower","modulator","moistness","molecular","monastery","moneybags","moneyless","moneywise","monologue","monstrous","moodiness","moonlight","moonscape","moonshine","moonstone","morbidity","mortality","mortician","mortified","mothproof","motivator","motocross","mountable","mousiness","moustache","multitask","multitude","mummified","municipal","murkiness","murmuring","mushiness","muskiness","mustiness","mutilated","mutilator","mystified","nanometer","nastiness","navigator","nebulizer","neglector","negligent","negotiate","neurology","ninetieth","numerator","nuttiness","obedience","oblivious","obnoxious","obscurity","observant","observing","obsession","obsessive","obstinate","obtrusive","occultist","occupancy","onslaught","operating","operation","operative","oppressed","oppressor","opulently","outnumber","outplayed","outskirts","outsource","outspoken","overblown","overboard","overbuilt","overcrowd","overdraft","overdrawn","overdress","overdrive","overeager","overeater","overexert","overgrown","overjoyed","overlabor","overlying","overnight","overplant","overpower","overprice","overreach","overreact","overshoot","oversight","oversized","oversleep","overspend","overstate","overstock","overstuff","oversweet","overthrow","overvalue","overwrite","oxidation","oxidizing","pacemaker","palatable","palpitate","panhandle","panoramic","pantomime","pantyhose","paparazzi","parachute","paragraph","paralegal","paralyses","paralysis","paramedic","parameter","paramount","parasitic","parchment","partition","partridge","passenger","passivism","patchwork","paternity","patriarch","patronage","patronize","pavestone","pediatric","pedometer","penholder","penniless","pentagram","percolate","perennial","perfected","perfectly","periscope","perkiness","perpetual","perplexed","persecute","persevere","persuaded","persuader","pessimism","pessimist","pesticide","petroleum","petticoat","pettiness","phonebook","phoniness","phosphate","plausible","plausibly","playgroup","playhouse","playmaker","plaything","plentiful","plexiglas","plutonium","pointless","polyester","polygraph","porcupine","portfolio","postnasal","powdering","prankster","preaching","precision","predefine","preflight","preformed","pregnancy","preheated","prelaunch","preoccupy","preschool","prescribe","preseason","president","presuming","pretended","pretender","prevalent","prewashed","primarily","privatize","proactive","probation","probiotic","procedure","procreate","profanity","professed","professor","profusely","prognosis","projector","prolonged","promenade","prominent","promotion","pronounce","proofread","propeller","proponent","protector","prototype","protozoan","providing","provoking","provolone","proximity","prudishly","publisher","pulmonary","pulverize","punctuate","punctured","pureblood","purgatory","purposely","pursuable","pushchair","pushiness","pyromania","qualified","qualifier","quartered","quarterly","quickness","quicksand","quickstep","quintuple","quizzical","quotation","radiantly","radiation","rancidity","ravishing","reacquire","reanalyze","reappoint","reapprove","rearrange","rebalance","recapture","recharger","recipient","reclining","reclusive","recognize","recollect","reconcile","reconfirm","reconvene","rectangle","rectified","recycling","reexamine","referable","reference","refinance","reflected","reflector","reformist","refueling","refurbish","refurnish","refutable","registrar","regretful","regulator","rehydrate","reimburse","reiterate","rejoicing","relapsing","relatable","relenting","relieving","reluctant","remindful","remission","remodeler","removable","rendering","rendition","renewable","renewably","renovator","repackage","repacking","repayment","repossess","repressed","reprimand","reprocess","reproduce","reprogram","reptilian","repugnant","repulsion","repulsive","repurpose","reputable","reputably","requisite","reshuffle","residence","residency","resilient","resistant","resisting","resurface","resurrect","retaining","retaliate","retention","retrieval","retriever","reverence","reversing","reversion","revisable","revivable","revocable","revolving","riverbank","riverboat","riverside","rockiness","rockslide","roundness","roundworm","runaround","sacrament","sacrifice","saddlebag","safeguard","safehouse","salvaging","salvation","sanctuary","sandblast","sandpaper","sandstone","sandstorm","sanitizer","sappiness","sarcastic","sasquatch","satirical","satisfied","sauciness","saxophone","scapegoat","scarecrow","scariness","scavenger","schematic","schilling","scientist","scorebook","scorecard","scoreless","scoundrel","scrambled","scrambler","scrimmage","scrounger","sculpture","secluding","seclusion","sectional","selection","selective","semicolon","semifinal","semisweet","sensation","sensitive","sensitize","sensually","september","sequester","serotonin","sevenfold","seventeen","shadiness","shakiness","sharpener","sharpness","shiftless","shininess","shivering","shortcake","shorthand","shortlist","shortness","shortwave","showpiece","showplace","shredding","shrubbery","shuffling","silliness","similarly","simmering","sincerity","situation","sixtyfold","skedaddle","skintight","skyrocket","slackness","slapstick","sliceable","slideshow","slighting","slingshot","slouching","smartness","smilingly","smokeless","smokiness","smuggling","snowboard","snowbound","snowdrift","snowfield","snowflake","snowiness","snowstorm","spearfish","spearhead","spearmint","spectacle","spectator","speculate","spellbind","spendable","spherical","spiritism","spiritual","splashing","spokesman","spotlight","sprinkled","sprinkler","squatting","squealing","squeamish","squeezing","squishier","stability","stabilize","stainable","stainless","stalemate","staleness","starboard","stargazer","starlight","startling","statistic","statutory","steadfast","steadying","steerable","steersman","stegosaur","sterility","sterilize","sternness","stiffness","stillness","stimulant","stimulate","stipulate","stonewall","stoneware","stonework","stoplight","stoppable","stopwatch","storeroom","storewide","straggler","straining","strangely","strategic","strenuous","strongbox","strongman","structure","stumbling","stylishly","subarctic","subatomic","subdivide","subheader","submarine","submersed","submitter","subscribe","subscript","subsector","subsiding","subsidize","substance","subsystem","subwoofer","succulent","suffering","suffocate","sulphuric","superbowl","superglue","superhero","supernova","supervise","supremacy","surcharge","surfacing","surfboard","surrender","surrogate","surviving","sustained","sustainer","swaddling","swampland","swiftness","swimmable","symphonic","synthesis","synthetic","tableware","tackiness","taekwondo","tarantula","tastiness","theatrics","thesaurus","thickness","thirstily","thirsting","threefold","throbbing","throwaway","throwback","thwarting","tightness","tightrope","tinderbox","tiptoeing","tradition","trailside","transform","translate","transpire","transport","transpose","trapezoid","treachery","treadmill","trembling","tribesman","tributary","trickster","trifocals","trimester","troubling","trustable","trustless","turbulent","twentieth","twiddling","twistable","ultimatum","umbilical","unabashed","unadorned","unadvised","unaligned","unaltered","unarmored","unashamed","unaudited","unbalance","unblended","unblessed","unbounded","unbraided","unbuckled","uncertain","unchanged","uncharted","unclaimed","unclamped","unclothed","uncolored","uncorrupt","uncounted","uncrushed","uncurious","undamaged","undaunted","undecided","undefined","undercoat","undercook","underdone","underfeed","underfoot","undergrad","underhand","underline","underling","undermine","undermost","underpaid","underpass","underrate","undertake","undertone","undertook","underwear","underwent","underwire","undesired","undiluted","undivided","undrafted","undrilled","uneatable","unelected","unengaged","unethical","unexpired","unexposed","unfailing","unfeeling","unfitting","unfixable","unfocused","unfounded","unfrosted","ungreased","unguarded","unhappily","unhealthy","unhearing","unhelpful","unhitched","uniformed","uniformly","unimpeded","uninjured","uninstall","uninsured","uninvited","unisexual","universal","unknotted","unknowing","unlearned","unleveled","unlighted","unlikable","unlimited","unlivable","unlocking","unlovable","unluckily","unmanaged","unmasking","unmatched","unmindful","unmixable","unmovable","unnamable","unnatural","unnerving","unnoticed","unopposed","unpainted","unpiloted","unplanned","unplanted","unpleased","unpledged","unpopular","unraveled","unreached","unreeling","unrefined","unrelated","unretired","unrevised","unrivaled","unroasted","unruffled","unscathed","unscented","unsecured","unselfish","unsettled","unshackle","unsheathe","unshipped","unsightly","unskilled","unspoiled","unstaffed","unstamped","unsterile","unstirred","unstopped","unstuffed","unstylish","untainted","untangled","untoasted","untouched","untracked","untrained","untreated","untrimmed","unvarying","unveiling","unvisited","unwarlike","unwatched","unwelcome","unwilling","unwitting","unwomanly","unworldly","unworried","unwrapped","unwritten","upcountry","uplifting","urologist","uselessly","vagrantly","vagueness","valuables","vaporizer","vehicular","veneering","ventricle","verbalize","vertebrae","viability","viewpoint","vindicate","violation","viscosity","vivacious","vividness","wackiness","washbasin","washboard","washcloth","washhouse","washstand","whimsical","wieldable","wikipedia","willfully","willpower","wolverine","womanhood","womankind","womanless","womanlike","worrisome","worsening","worshiper","wrongdoer","wrongness","yesterday","zestfully","zigzagged","zookeeper","zoologist","abnormal","abrasion","abrasive","abruptly","absentee","absently","absinthe","absolute","abstract","accuracy","accurate","accustom","achiness","acquaint","activate","activism","activist","activity","aeration","aerobics","affected","affluent","aflutter","agnostic","agreeing","alienate","alkaline","alkalize","almighty","alphabet","although","altitude","aluminum","amaretto","ambiance","ambition","amicably","ammonium","amniotic","amperage","amusable","anaconda","aneurism","animator","annotate","annoying","annually","anointer","anteater","antelope","antennae","antibody","antidote","antihero","antiques","antirust","anyplace","anything","anywhere","appendix","appetite","applause","approach","approval","aptitude","aqueduct","ardently","arguable","arguably","armchair","arrogant","aspirate","astonish","atlantic","atonable","attendee","attitude","atypical","audacity","audience","audition","autistic","avenging","aversion","aviation","babbling","backache","backdrop","backfire","backhand","backlash","backless","backpack","backrest","backroom","backside","backslid","backspin","backstab","backtalk","backward","backwash","backyard","bacteria","baffling","baguette","bakeshop","balsamic","banister","bankable","bankbook","banknote","bankroll","barbecue","bargraph","baritone","barrette","barstool","barterer","battered","blatancy","blighted","blinking","blissful","blizzard","bloating","bloomers","blooming","blustery","boastful","boasting","bondless","bonehead","boneless","bonelike","bootlace","borrower","botanist","bottling","bouncing","bounding","breeches","breeding","brethren","broiling","bronzing","browbeat","browsing","bruising","brunette","brussels","bubbling","buckshot","buckskin","buddhism","buddhist","bullfrog","bullhorn","bullring","bullseye","bullwhip","bunkmate","busybody","cadillac","calamari","calamity","calculus","camisole","campfire","campsite","canister","cannabis","capacity","cardigan","cardinal","careless","carmaker","carnival","cartload","cassette","casually","casualty","catacomb","catalyst","catalyze","catapult","cataract","catching","catering","catfight","cathouse","cautious","cavalier","celibacy","celibate","ceramics","ceremony","cesarean","cesspool","chaffing","champion","chaplain","charcoal","charging","charting","chastise","chastity","chatroom","chatting","cheating","chewable","childish","chirping","chitchat","chivalry","chloride","chlorine","choosing","chowtime","cilantro","cinnamon","circling","circular","citation","clambake","clanking","clapping","clarinet","clavicle","clerical","climatic","clinking","closable","clothing","clubbing","clumsily","coasting","coauthor","coeditor","cogwheel","coherent","cohesive","coleslaw","coliseum","collapse","colonial","colonist","colonize","colossal","commence","commerce","composed","composer","compound","compress","computer","conceded","conclude","concrete","condense","confetti","confider","confined","conflict","confound","confront","confused","congrats","congress","conjuror","constant","consumer","contempt","contents","contrite","cornball","cornhusk","cornmeal","coronary","corporal","corridor","cosigner","counting","covenant","coveting","coziness","crabbing","crablike","crabmeat","cradling","craftily","crawfish","crawlers","crawling","crayfish","creasing","creation","creative","creature","credible","credibly","crescent","cresting","crewless","crewmate","cringing","crisping","criteria","crumpled","cruncher","crusader","crushing","cucumber","cufflink","culinary","culpable","cultural","customer","cylinder","daffodil","daintily","dallying","dandruff","dangling","daringly","darkened","darkness","darkroom","datebook","daughter","daunting","daybreak","daydream","daylight","dazzling","deafness","debating","debtless","deceased","deceiver","december","decipher","declared","decrease","dedicate","deepness","defacing","defender","deferral","deferred","defiance","defiling","definite","deflator","deforest","degraded","degrease","dejected","delegate","deletion","delicacy","delicate","delirium","delivery","delusion","demeanor","democrat","demotion","deniable","departed","deplored","depraved","deputize","deranged","designed","designer","deskwork","desolate","destruct","detached","detector","detonate","detoxify","deviancy","deviator","devotion","devourer","devoutly","diabetes","diabetic","diabolic","diameter","dictator","diffused","diffuser","dilation","diligent","diminish","directed","directly","direness","disabled","disagree","disallow","disarray","disaster","disburse","disclose","discolor","discount","discover","disgrace","dislodge","disloyal","dismount","disorder","dispatch","dispense","displace","disposal","disprove","dissuade","distance","distaste","distinct","distract","distress","district","distrust","dividend","dividers","dividing","divinely","divinity","division","divisive","divorcee","doctrine","document","domelike","domestic","dominion","dominoes","donation","doorbell","doorknob","doornail","doorpost","doorstep","doorstop","doubling","dragging","dragster","drainage","dramatic","dreadful","dreamily","drearily","drilling","drinking","dripping","drivable","driveway","dropkick","drowsily","duckbill","duckling","ducktail","dullness","dumpling","dumpster","duration","dwelling","dynamite","dyslexia","dyslexic","earphone","earpiece","earplugs","easiness","eastward","economic","edginess","educated","educator","eggplant","eggshell","election","elective","elephant","elevator","eligible","eligibly","elliptic","eloquent","embezzle","embolism","emission","emoticon","empathic","emphases","emphasis","emphatic","employed","employee","employer","emporium","encircle","encroach","endanger","endeared","endpoint","enduring","energize","enforced","enforcer","engaging","engraved","engraver","enjoying","enlarged","enlisted","enquirer","entering","enticing","entrench","entryway","envelope","enviable","enviably","envision","epidemic","epidural","epilepsy","epilogue","epiphany","equation","erasable","escalate","escapade","escapist","escargot","espresso","esteemed","estimate","estrogen","eternity","evacuate","evaluate","everyday","everyone","evidence","excavate","exchange","exciting","existing","exorcism","exorcist","expenses","expiring","explicit","exponent","exporter","exposure","extended","exterior","external","fabulous","facebook","facedown","faceless","facelift","facility","familiar","famished","fastball","fastness","favoring","favorite","felt-tip","feminine","feminism","feminist","feminize","fernlike","ferocity","festival","fiddling","fidelity","fiftieth","figurine","filtrate","finalist","finalize","fineness","finished","finisher","fiscally","flagpole","flagship","flanking","flannels","flashily","flashing","flatfoot","flatness","flattery","flatware","flatworm","flavored","flaxseed","flogging","flounder","flypaper","follicle","fondling","fondness","football","footbath","footgear","foothill","foothold","footless","footnote","footpath","footrest","footsore","footwear","footwork","founding","fountain","fraction","fracture","fragment","fragrant","freckled","freckles","freebase","freefall","freehand","freeload","freeness","freeware","freewill","freezing","frenzied","frequent","friction","frighten","frigidly","frostily","frosting","fructose","frugally","galleria","gambling","gangrene","gatherer","gauntlet","generous","genetics","geologic","geometry","geranium","germless","gigabyte","gigantic","giggling","giveaway","glancing","glaucoma","gleaming","gloating","gloomily","glorious","glowworm","goatskin","goldfish","goldmine","goofball","gorgeous","graceful","gracious","gradient","graduate","graffiti","grafting","granddad","grandkid","grandson","granular","gratuity","greasily","greedily","greeting","grieving","grievous","grinning","groggily","grooving","grudging","grueling","grumpily","guidable","guidance","gullible","gurgling","gyration","habitant","habitual","handball","handbook","handcart","handclap","handcuff","handgrip","handheld","handling","handmade","handpick","handrail","handwash","handwork","handyman","hangnail","hangover","happiest","hardcopy","hardcore","harddisk","hardened","hardener","hardhead","hardness","hardship","hardware","hardwood","harmless","hatchery","hatching","hazelnut","haziness","headache","headband","headgear","headlamp","headless","headlock","headrest","headroom","headsman","headwear","helpless","helpline","henchman","heritage","hesitant","hesitate","hexagram","huddling","humbling","humility","humorist","humorous","humpback","hungrily","huntress","huntsman","hydrated","hydrogen","hypnoses","hypnosis","hypnotic","idealism","idealist","idealize","identify","identity","ideology","ignition","illusion","illusive","imagines","imbecile","immature","imminent","immobile","immodest","immortal","immunity","immunize","impaired","impeding","imperial","implicit","impolite","importer","imposing","impotent","imprison","improper","impurity","irrigate","irritant","irritate","islamist","isolated","jailbird","jalapeno","jaundice","jingling","jokester","jokingly","joyfully","joystick","jubilant","judicial","juggling","junction","juncture","junkyard","justness","juvenile","kangaroo","keenness","kerchief","kerosene","kilobyte","kilogram","kilowatt","kindling","kindness","kissable","knapsack","knickers","laboring","labrador","ladylike","landfall","landfill","landlady","landless","landline","landlord","landmark","landmass","landmine","landside","language","latitude","latticed","lavender","laxative","laziness","lecturer","leggings","lethargy","leverage","levitate","licorice","ligament","likeness","likewise","limpness","linguini","linguist","linoleum","litigate","luckless","lukewarm","luminous","lunchbox","luncheon","lushness","lustrous","lyricism","lyricist","macarena","macaroni","magazine","magician","magnetic","magnolia","mahogany","majestic","majority","makeover","managing","mandarin","mandolin","manicure","manpower","marathon","marbling","marigold","maritime","massager","matchbox","matching","material","maternal","maturely","maturing","maturity","maverick","maximize","mobility","mobilize","modified","moisture","molasses","molecule","molehill","monetary","monetize","mongoose","monkhood","monogamy","monogram","monopoly","monorail","monotone","monotype","monoxide","monsieur","monument","moonbeam","moonlike","moonrise","moonwalk","morality","morbidly","morphine","morphing","mortally","mortuary","mothball","motivate","mountain","mounting","mournful","mulberry","multiple","multiply","mumbling","munchkin","muscular","mushroom","mutation","national","nativity","naturist","nautical","navigate","nearness","neatness","negation","negative","negligee","neurosis","neurotic","nickname","nicotine","nineteen","nintendo","numbness","numerate","numerous","nuptials","nutrient","nutshell","obedient","obituary","obligate","oblivion","observer","obsessed","obsolete","obstacle","obstruct","occupant","occupier","ointment","olympics","omission","omnivore","oncoming","onlooker","onscreen","operable","operator","opponent","opposing","opposite","outboard","outbound","outbreak","outburst","outclass","outdated","outdoors","outfield","outflank","outgoing","outhouse","outlying","outmatch","outreach","outright","outscore","outshine","outshoot","outsider","outsmart","outtakes","outthink","outweigh","overarch","overbill","overbite","overbook","overcast","overcoat","overcome","overcook","overfeed","overfill","overflow","overfull","overhand","overhang","overhaul","overhead","overhear","overheat","overhung","overkill","overlaid","overload","overlook","overlord","overpass","overplay","overrate","override","overripe","overrule","overshot","oversold","overstay","overstep","overtake","overtime","overtone","overture","overturn","overview","oxymoron","pacifier","pacifism","pacifist","paddling","palpable","pampered","pamperer","pamphlet","pancreas","pandemic","panorama","parabola","parakeet","paralyze","parasail","parasite","parmesan","passable","passably","passcode","passerby","passover","passport","password","pastrami","paternal","patience","pavement","pavilion","paycheck","payphone","peculiar","peddling","pedicure","pedigree","pegboard","penalize","penknife","pentagon","perceive","perjurer","peroxide","petition","phrasing","placidly","platform","platinum","platonic","platypus","playable","playback","playlist","playmate","playroom","playtime","pleading","plethora","plunging","pointing","politely","popsicle","populace","populate","porridge","portable","porthole","portside","possible","possibly","postcard","pouncing","powdered","praising","prancing","prankish","preacher","preamble","precinct","predator","pregnant","premiere","premises","prenatal","preorder","pretense","previous","prideful","princess","pristine","probable","probably","proclaim","procurer","prodigal","profound","progress","prologue","promoter","prompter","promptly","proofing","properly","property","proposal","protegee","protract","protrude","provable","provided","provider","province","prowling","punctual","punisher","purchase","purebred","pureness","purifier","purplish","pursuant","purveyor","pushcart","pushover","puzzling","quadrant","quaintly","quarters","quotable","radiance","radiated","radiator","railroad","rambling","reabsorb","reaction","reactive","reaffirm","reappear","rearview","reassign","reassure","reattach","reburial","rebuttal","reckless","recliner","recovery","recreate","recycled","recycler","reemerge","refinery","refining","refinish","reforest","reformat","reformed","reformer","refreeze","refusing","register","registry","regulate","rekindle","relation","relative","reliable","reliably","reliance","relocate","remedial","remember","reminder","removing","renderer","renegade","renounce","renovate","rentable","reoccupy","repaying","repeated","repeater","rephrase","reporter","reproach","resample","research","reselect","reseller","resemble","resident","residual","resigned","resolute","resolved","resonant","resonate","resource","resubmit","resupply","retainer","retiring","retorted","reusable","reverend","reversal","revision","reviving","revolver","richness","riddance","ripeness","ripening","rippling","riverbed","riveting","robotics","rockband","rockfish","rocklike","rockstar","roulette","rounding","roundish","rumbling","sabotage","saddling","safeness","salaried","salutary","sampling","sanction","sanctity","sandbank","sandfish","sandworm","sanitary","satiable","saturate","saturday","scalding","scallion","scalping","scanning","scarcity","scarring","schedule","scheming","schnapps","scolding","scorpion","scouring","scouting","scowling","scrabble","scraggly","scribble","scribing","scrubbed","scrubber","scrutiny","sculptor","secluded","securely","security","sedation","sedative","sediment","seducing","selected","selector","semantic","semester","semisoft","senorita","sensuous","sequence","serrated","sessions","settling","severity","shakable","shamrock","shelving","shifting","shoplift","shopping","shoptalk","shortage","shortcut","showcase","showdown","showgirl","showroom","shrapnel","shredder","shrewdly","shrouded","shucking","siberian","silenced","silencer","simplify","singular","sinister","situated","sixtieth","sizzling","skeletal","skeleton","skillful","skimming","skimpily","skincare","skinhead","skinless","skinning","skipping","skirmish","skydiver","skylight","slacking","slapping","slashing","slighted","slightly","slimness","slinging","slobbery","sloppily","smashing","smelting","smuggler","smugness","sneezing","snipping","snowbird","snowdrop","snowfall","snowless","snowplow","snowshoe","snowsuit","snugness","spearman","specimen","speckled","spectrum","spelling","spending","spinning","spinster","spirited","splashed","splatter","splendid","splendor","splicing","splinter","splotchy","spoilage","spoiling","spookily","sporting","spotless","spotting","spyglass","squabble","squander","squatted","squatter","squealer","squeegee","squiggle","squiggly","stagnant","stagnate","staining","stalling","stallion","stapling","stardust","starfish","starless","starring","starship","starting","starving","steadier","steadily","steering","sterling","stifling","stimulus","stingily","stinging","stingray","stinking","stoppage","stopping","storable","stowaway","straddle","strained","strainer","stranger","strangle","strategy","strength","stricken","striking","striving","stroller","strongly","struggle","stubborn","stuffing","stunning","sturdily","stylized","subduing","subfloor","subgroup","sublease","sublevel","submerge","subpanel","subprime","subsonic","subtitle","subtotal","subtract","sufferer","suffrage","suitable","suitably","suitcase","sulphate","superior","superjet","superman","supermom","supplier","sureness","surgical","surprise","surround","survival","survivor","suspense","swapping","swimming","swimsuit","swimwear","swinging","sycamore","sympathy","symphony","syndrome","synopses","synopsis","tableful","tackling","tactical","tactless","talisman","tameness","tapeless","tapering","tapestry","tartness","tattered","tattling","theology","theorize","thespian","thieving","thievish","thinness","thinning","thirteen","thousand","threaten","thriving","throttle","throwing","thumping","thursday","tidiness","tightwad","tingling","tinkling","tinsmith","traction","trailing","tranquil","transfer","trapdoor","trapping","traverse","travesty","treading","trespass","triangle","tribunal","trickery","trickily","tricking","tricolor","tricycle","trillion","trimming","trimness","tripping","trolling","trombone","tropical","trousers","trustful","trusting","tubeless","tumbling","turbofan","turbojet","tweezers","twilight","twisting","ultimate","umbrella","unafraid","unbeaten","unbiased","unbitten","unbolted","unbridle","unbroken","unbundle","unburned","unbutton","uncapped","uncaring","uncoated","uncoiled","uncombed","uncommon","uncooked","uncouple","uncurled","underage","underarm","undercut","underdog","underfed","underpay","undertow","underuse","undocked","undusted","unearned","uneasily","unedited","unending","unenvied","unfasten","unfilled","unfitted","unflawed","unframed","unfreeze","unfrozen","unfunded","unglazed","ungloved","ungraded","unguided","unharmed","unheated","unhidden","unicycle","uniquely","unissued","universe","unjustly","unlawful","unleaded","unlinked","unlisted","unloaded","unloader","unlocked","unlovely","unloving","unmanned","unmapped","unmarked","unmasked","unmolded","unmoving","unneeded","unopened","unpadded","unpaired","unpeeled","unpicked","unpinned","unplowed","unproven","unranked","unrented","unrigged","unrushed","unsaddle","unsalted","unsavory","unsealed","unseated","unseeing","unseemly","unselect","unshaken","unshaved","unshaven","unsigned","unsliced","unsmooth","unsocial","unsoiled","unsolved","unsorted","unspoken","unstable","unsteady","unstitch","unsubtle","unsubtly","unsuited","untagged","untapped","unthawed","unthread","untimely","untitled","unturned","unusable","unvalued","unvaried","unveiled","unvented","unviable","unwanted","unwashed","unwieldy","unworthy","upcoming","upheaval","uplifted","uprising","upstairs","upstream","upstroke","upturned","urethane","vacation","vagabond","vagrancy","vanquish","variable","variably","vascular","vaseline","vastness","velocity","vendetta","vengeful","venomous","verbally","vertical","vexingly","vicinity","viewable","viewless","vigorous","vineyard","violator","virtuous","viselike","visiting","vitality","vitalize","vitamins","vocalist","vocalize","vocation","volatile","washable","washbowl","washroom","waviness","whacking","whenever","whisking","whomever","whooping","wildcard","wildfire","wildfowl","wildland","wildlife","wildness","winnings","wireless","wisplike","wobbling","wreckage","wrecking","wrongful","yearbook","yearling","yearning","zeppelin","abdomen","abiding","ability","abreast","abridge","absence","absolve","abstain","acclaim","account","acetone","acquire","acrobat","acronym","actress","acutely","aerosol","affront","ageless","agility","agonize","aground","alfalfa","algebra","almanac","alright","amenity","amiable","ammonia","amnesty","amplify","amusing","anagram","anatomy","anchovy","ancient","android","angelic","angling","angrily","angular","animate","annuity","another","antacid","anthill","antonym","anybody","anymore","anytime","apostle","appease","applaud","applied","approve","apricot","armband","armhole","armless","armoire","armored","armrest","arousal","arrange","arrival","ashamed","aspirin","astound","astride","atrophy","attempt","auction","audible","audibly","average","aviator","awkward","backing","backlit","backlog","badland","badness","baggage","bagging","bagpipe","balance","balcony","banking","banshee","barbell","barcode","barista","barmaid","barrack","barrier","battery","batting","bazooka","blabber","bladder","blaming","blazing","blemish","blinked","blinker","bloated","blooper","blubber","blurred","boaster","bobbing","bobsled","bobtail","bolster","bonanza","bonding","bonfire","booting","bootleg","borough","boxlike","breeder","brewery","brewing","bridged","brigade","brisket","briskly","bristle","brittle","broaden","broadly","broiler","brought","budding","buffalo","buffing","buffoon","bulldog","bullion","bullish","bullpen","bunkbed","busload","cabbage","caboose","cadmium","cahoots","calcium","caliber","caloric","calorie","calzone","camping","candied","canning","canteen","capable","capably","capital","capitol","capsize","capsule","caption","captive","capture","caramel","caravan","cardiac","carless","carload","carnage","carpool","carport","carried","cartoon","carving","carwash","cascade","catalog","catcall","catcher","caterer","catfish","catlike","cattail","catwalk","causing","caution","cavalry","certify","chalice","chamber","channel","chapped","chapter","charger","chariot","charity","charred","charter","chasing","chatter","cheddar","chemist","chevron","chewing","choking","chooser","chowder","citable","citadel","citizen","clapped","clapper","clarify","clarity","clatter","cleaver","clicker","climate","clobber","cloning","closure","clothes","clubbed","clutter","coastal","coaster","cobbler","coconut","coexist","collage","collide","comfort","commend","comment","commode","commute","company","compare","compile","compost","comrade","concave","conceal","concept","concert","concise","condone","conduit","confess","confirm","conform","conical","conjure","consent","console","consult","contact","contend","contest","context","contort","contour","control","convene","convent","copilot","copious","corncob","coroner","correct","corrode","corsage","cottage","country","courier","coveted","coyness","crafter","cranial","cranium","craving","crazily","creamed","creamer","crested","crevice","crewman","cricket","crimson","crinkle","crinkly","crisped","crisply","critter","crouton","crowbar","crucial","crudely","cruelly","cruelty","crumpet","crunchy","crushed","crusher","cryptic","crystal","cubical","cubicle","culprit","culture","cupcake","cupping","curable","curator","curling","cursive","curtain","custard","custody","customs","cycling","cyclist","dancing","darkish","darling","dawdler","daycare","daylong","dayroom","daytime","dazzler","dealing","debrief","decency","decibel","decimal","decline","default","defense","defiant","deflate","defraud","defrost","delouse","density","dentist","denture","deplete","depress","deprive","derived","deserve","desktop","despair","despise","despite","destiny","detract","devalue","deviant","deviate","devious","devotee","diagram","dictate","dimness","dingbat","diocese","dioxide","diploma","dipping","disband","discard","discern","discuss","disdain","disjoin","dislike","dismiss","disobey","display","dispose","dispute","disrupt","distant","distill","distort","divided","dolphin","donated","donator","doorman","doormat","doorway","drained","drainer","drapery","drastic","dreaded","dribble","driller","driving","drizzle","drizzly","dropbox","droplet","dropout","dropper","duchess","ducking","dumping","durable","durably","dutiful","dwelled","dweller","dwindle","dynamic","dynasty","earache","eardrum","earflap","earlobe","earmark","earmuff","earring","earshot","earthen","earthly","easeful","easiest","eatable","eclipse","ecology","economy","edition","effects","egotism","elastic","elderly","elevate","elitism","ellipse","elusive","embargo","embassy","emblaze","emerald","emotion","empathy","emperor","empower","emptier","enclose","encrust","encrypt","endless","endnote","endorse","engaged","engorge","engross","enhance","enjoyer","enslave","ensnare","entitle","entrust","entwine","envious","episode","equator","equinox","erasure","erratic","esquire","essence","etching","eternal","ethanol","evacuee","evasion","evasive","evident","exalted","example","exclaim","exclude","exhaust","expanse","explain","explode","exploit","explore","express","extinct","extrude","faceted","faction","factoid","factual","faculty","failing","falsify","fanatic","fancied","fanfare","fanning","fantasy","fascism","fasting","favored","federal","fencing","ferment","festive","fiction","fidgety","fifteen","figment","filling","finally","finance","finicky","finless","finlike","flaccid","flagman","flakily","flanked","flaring","flatbed","flatten","flattop","fleshed","florist","flyable","flyaway","flyover","footage","footing","footman","footpad","footsie","founder","fragile","framing","frantic","fraying","freebee","freebie","freedom","freeing","freeway","freight","fretful","fretted","frisbee","fritter","frosted","gaining","gallery","gallows","gangway","garbage","garland","garment","garnish","gauging","generic","gentile","geology","gestate","gesture","getaway","getting","giddily","gimmick","gizzard","glacial","glacier","glamour","glaring","glazing","gleeful","gliding","glimmer","glimpse","glisten","glitter","gloater","glorify","glowing","glucose","glutton","goggles","goliath","gondola","gosling","grading","grafted","grandly","grandma","grandpa","granite","granola","grapple","gratify","grating","gravity","grazing","greeter","grimace","gristle","grouped","growing","gruffly","grumble","grumbly","guiding","gumball","gumdrop","gumming","gutless","guzzler","habitat","hacking","hacksaw","haggler","halogen","hammock","hamster","handbag","handful","handgun","handled","handler","handoff","handsaw","handset","hangout","happier","happily","hardhat","harmful","harmony","harness","harpist","harvest","hastily","hatchet","hatless","heading","headset","headway","heavily","heaving","hedging","helpful","helping","hemlock","heroics","heroism","herring","herself","hexagon","humming","hunting","hurling","hurried","husband","hydrant","iciness","ideally","imaging","imitate","immerse","impeach","implant","implode","impound","imprint","improve","impulse","islamic","isotope","issuing","italics","jackpot","janitor","january","jarring","jasmine","jawless","jawline","jaybird","jellied","jitters","jittery","jogging","joining","joyride","jugular","jujitsu","jukebox","juniper","junkman","justice","justify","karaoke","kindred","kinetic","kinfolk","kinship","kinsman","kissing","kitchen","kleenex","krypton","labored","laborer","ladybug","lagging","landing","lantern","lapping","latrine","launder","laundry","legible","legibly","legroom","legwork","leotard","letdown","lettuce","liberty","library","licking","lifting","liftoff","limeade","limping","linseed","liquefy","liqueur","livable","lividly","luckily","lullaby","lumping","lumpish","lustily","machine","magenta","magical","magnify","majesty","mammary","manager","manatee","mandate","manhole","manhood","manhunt","mankind","manlike","manmade","mannish","marbled","marbles","marital","married","marxism","mashing","massive","mastiff","matador","matcher","maximum","moaning","mobster","modular","moisten","mollusk","mongrel","monitor","monsoon","monthly","moocher","moonlit","morally","mortify","mounted","mourner","movable","mullets","mummify","mundane","mushily","mustang","mustard","mutable","myspace","mystify","napping","nastily","natural","nearest","nemeses","nemesis","nervous","neutron","nuclear","nucleus","nullify","numbing","numeral","numeric","nursery","nursing","nurture","nutcase","nutlike","obliged","obscure","obvious","octagon","october","octopus","ominous","onboard","ongoing","onshore","onstage","opacity","operate","opossum","osmosis","outback","outcast","outcome","outgrow","outlast","outline","outlook","outmost","outpost","outpour","outrage","outrank","outsell","outward","overact","overall","overbid","overdue","overfed","overlap","overlay","overpay","overrun","overtly","overuse","oxidant","oxidize","pacific","padding","padlock","pajamas","pampers","pancake","panning","panther","paprika","papyrus","paradox","parched","parking","parkway","parsley","parsnip","partake","parting","partner","passage","passing","passion","passive","pastime","pasture","patient","patriot","payable","payback","payment","payroll","pelican","penalty","pendant","pending","pennant","pension","percent","perfume","perjury","petunia","phantom","phoenix","phonics","placard","placate","planner","plaster","plastic","plating","platter","playful","playing","playoff","playpen","playset","pliable","plunder","plywood","pointed","pointer","polygon","polymer","popcorn","popular","portion","postage","postbox","posting","posture","postwar","pouring","powdery","pranker","praying","preachy","precise","precook","predict","preface","pregame","prelude","premium","prepaid","preplan","preshow","presoak","presume","preteen","pretext","pretzel","prevail","prevent","preview","primary","primate","privacy","private","probing","problem","process","prodigy","produce","product","profane","profile","progeny","program","propose","prorate","proving","provoke","prowess","prowler","pruning","psychic","pulsate","pungent","purging","puritan","pursuit","pushing","pushpin","putdown","pyramid","quaking","qualify","quality","quantum","quarrel","quartet","quicken","quickly","quintet","ragweed","railcar","railing","railway","ranging","ranking","ransack","ranting","rasping","ravioli","reactor","reapply","reawake","rebirth","rebound","rebuild","rebuilt","recital","reclaim","recluse","recolor","recount","rectify","reenact","reenter","reentry","referee","refined","refocus","refract","refrain","refresh","refried","refusal","regalia","regally","regress","regroup","regular","reissue","rejoice","relapse","related","relearn","release","reliant","relieve","relight","remarry","rematch","remnant","remorse","removal","removed","remover","renewal","renewed","reoccur","reorder","repaint","replace","replica","reprint","reprise","reptile","request","require","reroute","rescuer","reshape","reshoot","residue","respect","rethink","retinal","retired","retiree","retouch","retrace","retract","retrain","retread","retreat","retrial","retying","reunion","reunite","reveler","revenge","revenue","revered","reverse","revisit","revival","reviver","rewrite","ribcage","rickety","ricotta","rifling","rigging","rimless","rinsing","ripcord","ripping","riptide","risotto","ritalin","riveter","roaming","robbing","rocking","rotting","rotunda","roundup","routine","routing","rubbing","rubdown","rummage","rundown","running","rupture","sabbath","saddled","sadness","saffron","sagging","salvage","sandbag","sandbar","sandbox","sanding","sandlot","sandpit","sapling","sarcasm","sardine","satchel","satisfy","savanna","savings","scabbed","scalded","scaling","scallop","scandal","scanner","scarily","scholar","science","scooter","scoring","scoured","scratch","scrawny","scrooge","scruffy","scrunch","scuttle","secrecy","secular","segment","seismic","seizing","seltzer","seminar","senator","serpent","service","serving","setback","setting","seventh","seventy","shadily","shading","shakily","shaking","shallot","shallow","shampoo","shaping","sharper","sharpie","sharply","shelter","shifter","shimmer","shindig","shingle","shining","shopper","shorten","shorter","shortly","showbiz","showing","showman","showoff","shrivel","shudder","shuffle","siamese","sibling","sighing","silicon","sincere","singing","sinless","sinuous","sitting","sixfold","sixteen","sixties","sizable","sizably","skating","skeptic","skilled","skillet","skimmed","skimmer","skipper","skittle","skyline","skyward","slacked","slacker","slander","slashed","slather","slicing","sliding","sloping","slouchy","smartly","smasher","smashup","smitten","smoking","smolder","smother","snagged","snaking","snippet","snooper","snoring","snorkel","snowcap","snowman","snuggle","species","specked","speller","spender","spinach","spindle","spinner","spinout","spirits","splashy","splurge","spoiled","spoiler","sponsor","spotted","spotter","spousal","sputter","squeeze","squishy","stadium","staging","stained","stamina","stammer","stardom","staring","starlet","starlit","starter","startle","startup","starved","stature","statute","staunch","stellar","stencil","sterile","sternum","stiffen","stiffly","stimuli","stinger","stipend","stoning","stopped","stopper","storage","stowing","stratus","stretch","strudel","stubbed","stubble","stubbly","student","studied","stuffed","stumble","stunned","stunner","styling","stylist","subdued","subject","sublime","subplot","subside","subsidy","subsoil","subtext","subtype","subzero","suction","suffice","suggest","sulfate","sulfide","sulfite","support","supreme","surface","surgery","surging","surname","surpass","surplus","surreal","survive","suspect","suspend","swagger","swifter","swiftly","swimmer","swinger","swizzle","swooned","symptom","synapse","synergy","t-shirt","tabasco","tabloid","tacking","tactful","tactics","tactile","tadpole","tainted","tannery","tanning","tantrum","tapered","tapioca","tapping","tarnish","tasting","theater","thermal","thermos","thicken","thicket","thimble","thinner","thirsty","thrower","thyself","tidings","tighten","tightly","tigress","timothy","tinfoil","tinwork","tipping","tracing","tractor","trading","traffic","tragedy","traitor","trapeze","trapped","trapper","treason","trekker","tremble","tribune","tribute","triceps","trickle","trident","trilogy","trimmer","trinity","triumph","trivial","trodden","tropics","trouble","truffle","trustee","tubular","tucking","tuesday","tuition","turbine","turmoil","twiddle","twisted","twister","twitter","unaired","unawake","unaware","unbaked","unblock","unboxed","uncanny","unchain","uncheck","uncivil","unclasp","uncloak","uncouth","uncover","uncross","uncrown","uncured","undated","undergo","undoing","undress","undying","unearth","uneaten","unequal","unfazed","unfiled","unfixed","ungodly","unhappy","unheard","unhinge","unicorn","unified","unifier","unkempt","unknown","unlaced","unlatch","unleash","unlined","unloved","unlucky","unmixed","unmoral","unmoved","unnamed","unnerve","unpaved","unquote","unrated","unrobed","unsaved","unscrew","unstuck","unsworn","untaken","untamed","untaxed","untimed","untried","untruth","untwist","untying","unusual","unvocal","unweave","unwired","unwound","unwoven","upchuck","upfront","upgrade","upright","upriver","upscale","upstage","upstart","upstate","upswing","uptight","uranium","urgency","urology","useable","utensil","utility","utilize","vacancy","vaguely","valiant","vanilla","vantage","variety","various","varmint","varnish","varsity","varying","vending","venture","verbose","verdict","version","vertigo","veteran","victory","viewing","village","villain","vintage","violate","virtual","viscous","visible","visibly","visitor","vitally","vividly","vocally","voicing","voltage","volumes","voucher","walmart","wannabe","wanting","washday","washing","washout","washtub","wasting","whoever","whoopee","wielder","wildcat","willing","wincing","winking","wistful","womanly","worried","worrier","wrangle","wrecker","wriggle","wriggly","wrinkle","wrinkly","writing","written","wronged","wrongly","wrought","yanking","yapping","yelling","yiddish","zealous","zipfile","zipping","zoology","abacus","ablaze","abroad","absurd","accent","aching","acting","action","active","affair","affirm","afford","aflame","afloat","afraid","agency","agenda","aghast","agreed","aliens","almost","alumni","always","ambush","amends","amount","amulet","amused","amuser","anchor","anemia","anemic","angled","angler","angles","animal","anthem","antics","antler","anyhow","anyone","anyway","apache","appear","armful","arming","armory","around","arrest","arrive","ascend","ascent","asleep","aspect","aspire","astute","atrium","attach","attain","attest","attire","august","author","autism","avatar","avenge","avenue","awaken","awhile","awning","babble","babied","baboon","backed","backer","backup","badass","baffle","bagful","bagged","baggie","bakery","baking","bamboo","banana","banish","banked","banker","banner","banter","barbed","barber","barley","barman","barrel","basics","basket","batboy","battle","bauble","blazer","bleach","blinks","blouse","bluish","blurry","bobbed","bobble","bobcat","bogged","boggle","bonded","bonnet","bonsai","booted","bootie","boring","botany","bottle","bottom","bounce","bouncy","bovine","boxcar","boxing","breach","breath","breeze","breezy","bright","broken","broker","bronco","bronze","browse","brunch","bubble","bubbly","bucked","bucket","buckle","budget","buffed","buffer","bulgur","bundle","bungee","bunion","busboy","busily","cabana","cabbie","cackle","cactus","caddie","camera","camper","campus","canary","cancel","candle","canine","canned","cannon","cannot","canola","canopy","canyon","capped","carbon","carded","caress","caring","carrot","cartel","carton","casing","casino","casket","catchy","catnap","catnip","catsup","cattle","caucus","causal","caviar","cavity","celery","celtic","cement","census","chance","change","chaste","chatty","cheese","cheesy","cherub","chewer","chirpy","choice","choosy","chosen","chrome","chubby","chummy","cinema","circle","circus","citric","citrus","clammy","clamor","clause","clench","clever","client","clinic","clique","clover","clumsy","clunky","clutch","cobalt","cobweb","coerce","coffee","collar","collie","colony","coming","common","compel","comply","concur","copied","copier","coping","copper","cornea","corned","corner","corral","corset","cortex","cosmic","cosmos","cotton","county","cozily","cradle","crafty","crayon","crazed","crease","create","credit","creole","cringe","crispy","crouch","crummy","crying","cuddle","cuddly","cupped","curdle","curfew","curing","curled","curler","cursor","curtly","curtsy","cussed","cyclic","cymbal","dagger","dainty","dander","danger","dangle","dating","daybed","deacon","dealer","debate","debtor","debunk","decade","deceit","decent","decode","decree","deduce","deduct","deepen","deeply","deface","defame","defeat","defile","define","deftly","defuse","degree","delete","deluge","deluxe","demise","demote","denial","denote","dental","depict","deploy","deport","depose","deputy","derail","detail","detest","device","diaper","dicing","dilute","dimmed","dimmer","dimple","dinghy","dining","dinner","dipped","dipper","disarm","dismay","disown","diving","doable","docile","dollar","dollop","domain","doodle","dorsal","dosage","dotted","douche","dreamt","dreamy","dreary","drench","drippy","driven","driver","drudge","dubbed","duffel","dugout","duller","duplex","duress","during","earful","earthy","earwig","easily","easing","easter","eatery","eating","eclair","edging","editor","effort","egging","eggnog","either","elated","eldest","eleven","elixir","embark","emblem","embody","emboss","enable","enamel","encode","encore","ending","energy","engine","engulf","enrage","enrich","enroll","ensure","entail","entire","entity","entomb","entrap","entree","enzyme","equate","equity","erased","eraser","errand","errant","eskimo","estate","ethics","evolve","excess","excuse","exhale","exhume","exodus","expand","expend","expert","expire","expose","extent","extras","fabric","facial","facing","factor","fading","falcon","family","famine","faster","faucet","fedora","feeble","feisty","feline","fender","ferret","ferris","fervor","fester","fiddle","figure","filing","filled","filler","filter","finale","finite","flashy","flatly","fleshy","flight","flinch","floral","flying","follow","fondly","fondue","footer","fossil","foster","frayed","freely","french","frenzy","friday","fridge","friend","fringe","frolic","frosty","frozen","frying","galley","gallon","galore","gaming","gander","gangly","garage","garden","gargle","garlic","garnet","garter","gating","gazing","geiger","gender","gently","gerbil","giblet","giggle","giggly","gigolo","gilled","girdle","giving","gladly","glance","glider","glitch","glitzy","gloomy","gluten","gnarly","google","gopher","gorged","gossip","gothic","gotten","graded","grader","granny","gravel","graves","greedy","grinch","groggy","groove","groovy","ground","grower","grudge","grunge","gurgle","gutter","hacked","hacker","halved","halves","hamlet","hamper","handed","hangup","hankie","harbor","hardly","hassle","hatbox","hatred","hazard","hazily","hazing","headed","header","helium","helmet","helper","herald","herbal","hermit","hubcap","huddle","humble","humbly","hummus","humped","humvee","hunger","hungry","hunter","hurdle","hurled","hurler","hurray","husked","hybrid","hyphen","idiocy","ignore","iguana","impale","impart","impish","impose","impure","iodine","iodize","iphone","itunes","jackal","jacket","jailer","jargon","jersey","jester","jigsaw","jingle","jockey","jogger","jovial","joyous","juggle","jumble","junior","junkie","jurist","justly","karate","keenly","kennel","kettle","kimono","kindle","kindly","kisser","kitten","kosher","ladder","ladies","lagged","lagoon","landed","lapdog","lapped","laptop","lather","latter","launch","laurel","lavish","lazily","legacy","legend","legged","legume","length","lesser","letter","levers","liable","lifter","likely","liking","lining","linked","liquid","litmus","litter","little","lively","living","lizard","lugged","lumber","lunacy","lushly","luster","luxury","lyrics","maggot","maimed","making","mammal","manger","mangle","manila","manned","mantis","mantra","manual","margin","marina","marine","marlin","maroon","marrow","marshy","mascot","mashed","masses","mating","matrix","matron","matted","matter","mayday","moaner","mobile","mocker","mockup","modify","module","monday","mooing","mooned","morale","mosaic","motion","motive","moving","mowing","mulled","mumble","muppet","museum","musket","muster","mutate","mutiny","mutual","muzzle","myself","naming","napkin","napped","narrow","native","nature","nearby","nearly","neatly","nebula","nectar","negate","nephew","neuron","neuter","nibble","nimble","nimbly","nuclei","nugget","number","numbly","nutmeg","nuzzle","object","oblong","obtain","obtuse","occupy","ocelot","octane","online","onward","oppose","outage","outbid","outfit","outing","outlet","output","outwit","oxford","oxygen","oyster","pacify","padded","paddle","paging","palace","paltry","panama","pantry","papaya","parade","parcel","pardon","parish","parlor","parole","parrot","parted","partly","pasted","pastel","pastor","patchy","patrol","pauper","paving","pawing","payday","paying","pebble","pebbly","pectin","pellet","pelvis","pencil","penpal","perish","pester","petite","petted","phobia","phoney","phrase","plasma","plated","player","pledge","plenty","plural","pointy","poison","poking","police","policy","polish","poncho","poplar","popper","porous","portal","portly","posing","possum","postal","posted","poster","pounce","powwow","prance","prayer","precut","prefix","prelaw","prepay","preppy","preset","pretty","prewar","primal","primer","prison","prissy","pronto","proofs","proton","proved","proven","prozac","public","pucker","pueblo","pumice","pummel","puppet","purely","purify","purist","purity","purple","pusher","pushup","puzzle","python","quarry","quench","quiver","racing","racism","racoon","radial","radish","raffle","ragged","raging","raider","raisin","raking","ramble","ramrod","random","ranged","ranger","ranked","rarity","rascal","ravage","ravine","raving","reason","rebate","reboot","reborn","rebuff","recall","recant","recast","recede","recent","recess","recite","recoil","recopy","record","recoup","rectal","refill","reflex","reflux","refold","refund","refuse","refute","regain","reggae","regime","region","reheat","rehire","rejoin","relish","relive","reload","relock","remake","remark","remedy","remold","remote","rename","rental","rented","renter","reopen","repair","repave","repeal","repent","replay","repose","repost","resale","reseal","resend","resent","resize","resort","result","resume","retail","retake","retold","retool","return","retype","reveal","reverb","revert","revise","revoke","revolt","reward","rewash","rewind","rewire","reword","rework","rewrap","ribbon","riches","richly","ridden","riding","rimmed","ripple","rising","roamer","robust","rocker","rocket","roping","roster","rotten","roving","rubbed","rubber","rubble","ruckus","rudder","ruined","rumble","runner","runway","sacred","sadden","safari","safely","salami","salary","saline","saloon","salute","sample","sandal","sanded","savage","savior","scabby","scarce","scared","scenic","scheme","scorch","scored","scorer","scotch","scouts","screen","scribe","script","scroll","scurvy","second","secret","sector","sedate","seduce","seldom","senate","senior","septic","septum","sequel","series","sermon","sesame","settle","shabby","shaded","shadow","shanty","sheath","shelve","sherry","shield","shifty","shimmy","shorts","shorty","shower","shrank","shriek","shrill","shrimp","shrine","shrink","shrubs","shrunk","siding","sierra","siesta","silent","silica","silver","simile","simple","simply","singer","single","sinner","sister","sitcom","sitter","sizing","sizzle","skater","sketch","skewed","skewer","skiing","skinny","slacks","sleeve","sliced","slicer","slider","slinky","sliver","slogan","sloped","sloppy","sludge","smoked","smooth","smudge","smudgy","smugly","snazzy","sneeze","snitch","snooze","snugly","specks","speech","sphere","sphinx","spider","spiffy","spinal","spiral","spleen","splice","spoils","spoken","sponge","spongy","spooky","sports","sporty","spotty","spouse","sprain","sprang","sprawl","spring","sprint","sprite","sprout","spruce","sprung","squall","squash","squeak","squint","squire","squirt","stable","staple","starch","starry","static","statue","status","stench","stereo","stifle","stingy","stinky","stitch","stooge","streak","stream","street","stress","strewn","strict","stride","strife","strike","strive","strobe","strode","struck","strung","stucco","studio","stuffy","stupor","sturdy","stylus","sublet","subpar","subtly","suburb","subway","sudden","sudoku","suffix","suitor","sulfur","sullen","sultry","supper","supply","surely","surfer","survey","swerve","switch","swivel","swoosh","system","tables","tablet","tackle","taking","talcum","tamale","tamper","tanned","target","tarmac","tartar","tartly","tassel","tattle","tattoo","tavern","thesis","thinly","thirty","thrash","thread","thrift","thrill","thrive","throat","throng","tidbit","tiling","timing","tingle","tingly","tinker","tinsel","tipoff","tipped","tipper","tiptop","tiring","tissue","trance","travel","treble","tremor","trench","triage","tricky","trifle","tripod","trophy","trough","trowel","trunks","tumble","turban","turkey","turret","turtle","twelve","twenty","twisty","twitch","tycoon","umpire","unable","unbend","unbent","unclad","unclip","unclog","uncork","undead","undone","unease","uneasy","uneven","unfair","unfold","unglue","unholy","unhook","unison","unkind","unless","unmade","unpack","unpaid","unplug","unread","unreal","unrest","unripe","unroll","unruly","unsafe","unsaid","unseen","unsent","unsnap","unsold","unsure","untidy","untold","untrue","unused","unwary","unwell","unwind","unworn","upbeat","update","upheld","uphill","uphold","upload","uproar","uproot","upside","uptake","uptown","upward","upwind","urchin","urgent","urging","usable","utmost","utopia","vacant","vacate","valium","valley","vanish","vanity","varied","vastly","veggie","velcro","velvet","vendor","verify","versus","vessel","viable","viewer","violet","violin","vision","volley","voting","voyage","waffle","waggle","waking","walnut","walrus","wanted","wasabi","washed","washer","waving","whacky","whinny","whoops","widely","widget","wilder","wildly","willed","willow","winner","winter","wiring","wisdom","wizard","wobble","wobbly","wooing","wreath","wrench","yearly","yippee","yogurt","yonder","zodiac","zombie","zoning","abide","acorn","affix","afoot","agent","agile","aging","agony","ahead","alarm","album","alias","alibi","alike","alive","aloft","aloha","alone","aloof","amaze","amber","amigo","amino","amiss","among","ample","amply","amuck","anger","anime","ankle","annex","antsy","anvil","aorta","apple","apply","april","apron","aptly","arena","argue","arise","armed","aroma","arose","array","arson","ashen","ashes","aside","askew","atlas","attic","audio","avert","avoid","await","award","aware","awoke","bacon","badge","badly","bagel","baggy","baked","balmy","banjo","barge","basil","basin","basis","batch","baton","blade","blame","blank","blast","bleak","bleep","blend","bless","blimp","bling","blitz","bluff","blunt","blurb","blurt","blush","bogus","boned","boney","bonus","booth","boots","boozy","borax","botch","boxer","briar","bribe","brick","bride","bring","brink","brook","broom","brunt","brush","brute","buddy","buggy","bulge","bully","bunch","bunny","cable","cache","cacti","caddy","cadet","cameo","canal","candy","canon","carat","cargo","carol","carry","carve","catty","cause","cedar","chafe","chain","chair","chant","chaos","chaps","charm","chase","cheek","cheer","chemo","chess","chest","chevy","chewy","chief","chili","chill","chimp","chive","chomp","chuck","chump","chunk","churn","chute","cider","cinch","civic","civil","claim","clamp","clang","clash","clasp","class","clean","clear","cleat","cleft","clerk","cling","cloak","clock","clone","cloud","clump","coach","cocoa","comfy","comic","comma","conch","coral","corny","couch","cough","could","cover","cramp","crane","crank","crate","crave","crazy","creed","creme","crepe","crept","cried","crier","crimp","croak","crock","crook","croon","cross","crowd","crown","crumb","crust","cupid","curly","curry","curse","curve","curvy","cushy","cycle","daily","dairy","daisy","dance","dandy","dares","dealt","debit","debug","decaf","decal","decay","decoy","defog","deity","delay","delta","denim","dense","depth","derby","deuce","diary","dimly","diner","dingo","dingy","ditch","ditto","ditzy","dizzy","dodge","dodgy","doily","doing","dolly","donor","donut","doozy","dowry","drank","dress","dried","drier","drift","drone","drool","droop","drove","drown","ducky","duvet","dwarf","dweeb","eagle","early","easel","eaten","ebony","ebook","ecard","eject","elbow","elite","elope","elude","elves","email","ember","emcee","emote","empty","ended","envoy","equal","error","erupt","essay","ether","evade","evict","evoke","exact","exert","exile","expel","fable","false","fancy","feast","femur","fence","ferry","fetal","fetch","fever","fiber","fifth","fifty","filth","finch","finer","flail","flaky","flame","flask","flick","flier","fling","flint","flirt","float","flock","floss","flyer","folic","foyer","frail","frame","frays","fresh","fried","frill","frisk","front","froth","frown","fruit","gaffe","gains","gamma","gauze","gecko","genre","gents","getup","giant","giddy","gills","given","giver","gizmo","glade","glare","glass","glory","gloss","glove","going","gonad","gooey","goofy","grain","grant","grape","graph","grasp","grass","gravy","green","grief","grill","grime","grimy","groin","groom","grope","grout","grove","growl","grunt","guide","guise","gully","gummy","gusto","gusty","haiku","hanky","happy","hardy","harsh","haste","hasty","haunt","haven","heave","hedge","hefty","hence","henna","herbs","hertz","human","humid","hurry","icing","idiom","igloo","image","imply","irate","issue","ivory","jaunt","jawed","jelly","jiffy","jimmy","jolly","judge","juice","juicy","jumbo","juror","kabob","karma","kebab","kitty","knelt","knoll","koala","kooky","kudos","ladle","lance","lanky","lapel","large","lasso","latch","legal","lemon","level","lilac","lilly","limes","limit","lingo","lived","liver","lucid","lunar","lurch","lusty","lying","macaw","magma","maker","mango","mangy","manly","manor","march","mardi","marry","mauve","maybe","mocha","molar","moody","morse","mossy","motor","motto","mouse","mousy","mouth","movie","mower","mulch","mumbo","mummy","mumps","mural","murky","mushy","music","musky","musty","nacho","nanny","nappy","nervy","never","niece","nifty","ninja","ninth","nutty","nylon","oasis","ocean","olive","omega","onion","onset","opium","other","otter","ought","ounce","outer","ovary","ozone","paced","pagan","pager","panda","panic","pants","paper","parka","party","pasta","pasty","patio","paver","payee","payer","pecan","penny","perch","perky","pesky","petal","petri","petty","phony","photo","plank","plant","plaza","pleat","pluck","poach","poise","poker","polar","polio","polka","poppy","poser","pouch","pound","power","press","pried","primp","print","prior","prism","prize","probe","prone","prong","props","proud","proxy","prude","prune","pulse","punch","pupil","puppy","purge","purse","pushy","quack","quail","quake","qualm","query","quiet","quill","quilt","quirk","quote","rabid","radar","radio","rally","ranch","rants","raven","reach","rebel","rehab","relax","relay","relic","remix","reply","rerun","reset","retry","reuse","rhyme","rigid","rigor","rinse","ritzy","rival","roast","robin","rocky","rogue","roman","rover","royal","rumor","runny","rural","sadly","saggy","saint","salad","salon","salsa","sandy","santa","sappy","sassy","satin","saucy","sauna","saved","savor","scale","scant","scarf","scary","scion","scoff","scone","scoop","scope","scorn","scrap","scuba","scuff","sedan","sepia","serve","setup","shack","shady","shaft","shaky","shale","shame","shank","shape","share","shawl","sheep","sheet","shelf","shell","shine","shiny","shirt","shock","shone","shore","shout","shove","shown","showy","shrug","shush","silly","siren","sixth","skied","skier","skies","skirt","skype","slain","slang","slate","sleek","sleep","sleet","slept","slick","slimy","slurp","slush","small","smell","smile","smirk","smite","smith","smock","smoky","snack","snare","snarl","sneak","sneer","snide","sniff","snore","snort","snout","snowy","snuff","speak","speed","spent","spied","spill","spilt","spiny","spoof","spool","spoon","spore","spout","spray","spree","sprig","squad","squid","stack","staff","stage","stamp","stand","stank","stark","stash","state","stays","steam","steed","steep","stick","stilt","stock","stoic","stoke","stole","stomp","stony","stood","stool","stoop","storm","stout","stove","straw","stray","strep","strum","strut","stuck","study","stump","stung","stunt","suave","sugar","suing","sushi","swarm","swear","sweat","sweep","swell","swept","swipe","swirl","swoop","swore","sworn","swung","syrup","tabby","tacky","talon","tamer","tarot","taste","tasty","taunt","thank","theft","theme","these","thigh","thing","think","thong","thorn","those","thumb","tiara","tibia","tidal","tiger","timid","trace","track","trade","train","traps","trash","treat","trend","trial","tried","trout","truce","truck","trump","truth","tubby","tulip","tummy","tutor","tweak","tweed","tweet","twerp","twice","twine","twins","twirl","tying","udder","ultra","uncle","uncut","unify","union","unlit","untie","until","unwed","unzip","upper","urban","usage","usher","usual","utter","valid","value","vegan","venue","venus","verse","vibes","video","viper","viral","virus","visor","vista","vixen","voice","voter","vowed","vowel","wafer","waged","wager","wages","wagon","waltz","watch","water","wharf","wheat","whiff","whiny","whole","widen","widow","width","wince","wired","wispy","woozy","worry","worst","wound","woven","wrath","wrist","xerox","yahoo","yeast","yield","yo-yo","yodel","yummy","zebra","zesty","zippy","able","acid","acre","acts","afar","aged","ahoy","aide","aids","ajar","aloe","alto","amid","anew","aqua","area","army","ashy","atom","atop","avid","awry","axis","barn","bash","bath","bats","blah","blip","blob","blog","blot","boat","body","boil","bolt","bony","book","boss","both","boxy","brim","bulb","bulk","bunt","bush","bust","buzz","cage","cake","calm","cane","cape","case","cash","chef","chip","chop","chug","city","clad","claw","clay","clip","coat","coil","coke","cola","cold","colt","coma","come","cone","cope","copy","cork","cost","cozy","crib","crop","crux","cube","cure","cusp","darn","dart","dash","data","dawn","dean","deck","deed","deem","defy","deny","dial","dice","dill","dime","dish","disk","dock","dole","dork","dose","dove","down","doze","drab","draw","drew","drum","duct","dude","duke","duly","dupe","dusk","dust","duty","each","eats","ebay","echo","edge","edgy","emit","envy","epic","even","evil","exes","exit","fade","fall","fame","fang","feed","feel","film","five","flap","fled","flip","flop","foam","foil","folk","font","food","fool","from","gala","game","gave","gawk","gear","geek","gift","glue","gnat","goal","goes","golf","gone","gong","good","goon","gore","gory","gout","gown","grab","gray","grew","grid","grip","grit","grub","gulf","gulp","guru","gush","guts","half","halt","hash","hate","hazy","heap","heat","huff","hula","hulk","hull","hunk","hurt","hush","icky","icon","idly","ipad","ipod","iron","item","java","jaws","jazz","jeep","jinx","john","jolt","judo","july","jump","june","jury","keep","kelp","kept","kick","kiln","kilt","king","kite","kiwi","knee","kung","lair","lake","lard","lark","lash","last","late","lazy","left","lego","lend","lens","lent","life","lily","limb","line","lint","lion","lisp","list","lung","lure","lurk","mace","malt","mama","many","math","mold","most","move","much","muck","mule","mute","mutt","myth","nail","name","nape","navy","neon","nerd","nest","next","oboe","ogle","oink","okay","omen","omit","only","onto","onyx","oops","ooze","oozy","opal","open","ouch","oval","oven","palm","pang","path","pelt","perm","peso","plod","plop","plot","plow","ploy","plug","plus","poem","poet","pogo","polo","pond","pony","pope","pork","posh","pout","pull","pulp","puma","punk","purr","putt","quit","race","rack","raft","rage","rake","ramp","rare","rash","ream","rely","reps","rice","ride","rift","rind","rink","riot","rise","risk","robe","romp","rope","rosy","ruby","rule","runt","ruse","rush","rust","saga","sage","said","sake","salt","same","sank","sash","scam","self","send","shed","ship","shun","shut","sift","silk","silo","silt","size","skid","slab","slam","slaw","sled","slip","slit","slot","slug","slum","smog","snap","snub","spew","spry","spud","spur","stem","step","stew","stir","such","suds","sulk","swab","swan","sway","taco","take","tall","tank","taps","task","that","thaw","thee","thud","thus","tidy","tile","till","tilt","tint","tiny","tray","tree","trio","turf","tusk","tutu","twig","tyke","unit","upon","used","user","veal","very","vest","veto","vice","visa","void","wake","walk","wand","wasp","wavy","wham","wick","wife","wifi","wilt","wimp","wind","wing","wipe","wiry","wise","wish","wolf","womb","woof","wool","word","work","xbox","yard","yarn","yeah","yelp","yoga","yoyo","zero","zips","zone","zoom","aim","art","bok","cod","cut","dab","dad","dig","dry","duh","duo","eel","elf","elk","elm","emu","fax","fit","foe","fog","fox","gab","gag","gap","gas","gem","guy","had","hug","hut","ice","icy","ion","irk","ivy","jab","jam","jet","job","jot","keg","lid","lip","map","mom","mop","mud","mug","nag","net","oaf","oak","oat","oil","old","opt","owl","pep","pod","pox","pry","pug","rug","rut","say","shy","sip","sly","tag","try","tug","tux","wad","why","wok","wow","yam","yen","yin","zap","zen","zit"];var wl=r(2052),_l=r.n(wl);const fl=[{id:"not_available",label:"n/a",strength:0},{id:"very-weak",label:"Very weak",strength:1},{id:"weak",label:"Weak",strength:60},{id:"fair",label:"Fair",strength:80},{id:"strong",label:"Strong",strength:112},{id:"very-strong",label:"Very strong",strength:128}],vl={mask_upper:{label:"A-Z",characters:["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"]},mask_lower:{label:"a-z",characters:["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]},mask_digit:{label:"0-9",characters:["0","1","2","3","4","5","6","7","8","9"]},mask_char1:{label:"# $ % & @ ^ ~",characters:["#","$","%","&","@","^","~"]},mask_parenthesis:{label:"{ [ ( | ) ] }",characters:["{","(","[","|","]",")","}"]},mask_char2:{label:". , : ;",characters:[".",",",":",";"]},mask_char3:{label:"' \" `",characters:["'",'"',"`"]},mask_char4:{label:"/ \\ _ -",characters:["/","\\","_","-"]},mask_char5:{label:"< * + ! ? =",characters:["<","*","+","!","?","="]},mask_emoji:{label:"😘",characters:["😀","😁","😂","😃","😄","😅","😆","😇","😈","😉","😊","😋","😌","😍","😎","😏","😐","😑","😒","😓","😔","😕","😖","😗","😘","😙","😚","😛","😜","😝","😞","😟","😠","😡","😢","😣","😤","😥","😦","😧","😨","😩","😪","😫","😬","😭","😮","😯","😰","😱","😲","😳","😴","😵","😶","😷","😸","😹","😺","😻","😼","😽","😾","😿","🙀","🙁","🙂","🙃","🙄","🙅","🙆","🙇","🙈","🙉","🙊","🙋","🙌","🙍","🙎","🙏"]}},Sl=["O","l","|","I","0","1"],bl=Object.values(vl).flatMap((e=>e.characters)),El={evaluateMaxPasswordEntropy:e=>{const t=Object.entries(vl).filter((([t])=>e[t])).reduce(((e,[t])=>[...e,...vl[t].characters]),[]).filter((t=>!e.exclude_look_alike_chars||!Sl.includes(t)));return kl(e.length,t.length)},entropyPassword:(e="")=>{const t=(new(_l())).splitGraphemes(e);let r=0;for(const[e]of Object.entries(vl)){const s=vl[e];t.some((e=>s.characters.includes(e)))&&(r+=s.characters.length)}const s=new Set(t.filter((e=>!bl.includes(e))));return kl(t.length,r+s.size)},entropyPassphrase:(e=0,t="")=>kl(e,3*ml.length)+El.entropyPassword(t),strength:(e=0)=>fl.reduce(((t,r)=>t?r.strength>t.strength&&e>=r.strength?r:t:r)),calculEntropy:kl};function kl(e,t){return e&&t?e*(Math.log(t)/Math.log(2)):0}class Al extends T{constructor(e,t={}){super(U.validate(Al.ENTITY_NAME,e,Al.getSchema()),t)}static getSchema(){return{type:"object",required:["length","mask_upper","mask_lower","mask_digit","mask_parenthesis","mask_emoji","mask_char1","mask_char2","mask_char3","mask_char4","mask_char5","exclude_look_alike_chars","min_length","max_length"],properties:{length:{type:"integer",minimum:8,maximum:128},mask_upper:{type:"boolean"},mask_lower:{type:"boolean"},mask_digit:{type:"boolean"},mask_parenthesis:{type:"boolean"},mask_emoji:{type:"boolean"},mask_char1:{type:"boolean"},mask_char2:{type:"boolean"},mask_char3:{type:"boolean"},mask_char4:{type:"boolean"},mask_char5:{type:"boolean"},exclude_look_alike_chars:{type:"boolean"},min_length:{type:"integer"},max_length:{type:"integer"}}}}static get ENTITY_NAME(){return"PasswordGeneratorSettings"}static createFromDefault(e={},t={}){const r=Object.assign({length:18,min_length:8,max_length:128,mask_upper:!0,mask_lower:!0,mask_digit:!0,mask_parenthesis:!0,mask_char1:!0,mask_char2:!0,mask_char3:!0,mask_char4:!0,mask_char5:!0,mask_emoji:!1,exclude_look_alike_chars:!0},e);return new Al(r,t)}}const Tl=Al,Il="lowercase";class Rl extends T{constructor(e,t={}){super(U.validate(Rl.ENTITY_NAME,e,Rl.getSchema()),t)}static getSchema(){return{type:"object",required:["words","word_separator","word_case","min_words","max_words"],properties:{words:{type:"integer",minimum:4,maximum:40},word_separator:{type:"string",maxLength:10},word_case:{type:"string",enum:["uppercase",Il,"camelcase"]},min_words:{type:"integer"},max_words:{type:"integer"}}}}static get ENTITY_NAME(){return"PassphraseGeneratorSettings"}static createFromDefault(e={},t={}){const r=Object.assign({words:9,min_words:4,max_words:40,word_separator:" ",word_case:Il},e);return new Rl(r,t)}}const Cl=Rl,Ol="passphrase",xl="password";class Pl extends T{constructor(e,t={}){super(U.validate(Pl.ENTITY_NAME,e,Pl.getSchema()),t),this._props.password_generator_settings&&(this._password_generator_settings=Tl.createFromDefault(this._props.password_generator_settings,{clone:!1}),delete this._props.password_generator_settings),this._props.passphrase_generator_settings&&(this._passphrase_generator_settings=Cl.createFromDefault(this._props.passphrase_generator_settings,{clone:!1}),delete this._props.passphrase_generator_settings)}static getSchema(){return{type:"object",required:["default_generator","external_dictionary_check","password_generator_settings","passphrase_generator_settings"],properties:{id:{type:"string",format:"uuid"},external_dictionary_check:{type:"boolean"},default_generator:{type:"string",enum:[xl,Ol]},password_generator_settings:Tl.getSchema(),passphrase_generator_settings:Cl.getSchema(),source:{type:"string"},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"}}}}toDto(e){const t=Object.assign({},this._props);return e?(this._passphrase_generator_settings&&e.passphrase_generator_settings&&(t.passphrase_generator_settings=this._passphrase_generator_settings.toDto()),this._password_generator_settings&&e.password_generator_settings&&(t.password_generator_settings=this._password_generator_settings.toDto()),t):t}toJSON(){return this.toDto(Pl.ALL_CONTAIN_OPTIONS)}get passwordGeneratorSettings(){return this._password_generator_settings}get passphraseGeneratorSettings(){return this._passphrase_generator_settings}static get ENTITY_NAME(){return"PasswordPolicies"}static get ALL_CONTAIN_OPTIONS(){return{passphrase_generator_settings:!0,password_generator_settings:!0}}static createFromDefault(e={}){const t=Tl.createFromDefault(e?.password_generator_settings),r=Cl.createFromDefault(e?.passphrase_generator_settings);delete e?.password_generator_settings,delete e?.passphrase_generator_settings;const s={default_generator:xl,external_dictionary_check:!0,password_generator_settings:t.toDto(),passphrase_generator_settings:r.toDto()};e?.default_generator&&(e.default_generator=e.default_generator===Ol?Ol:xl);const i=Object.assign(s,e);return new Pl(i)}}const Nl=Pl;class Ul extends dt{constructor(e){super(e,Ul.RESOURCE_NAME)}async find(){try{return(await this.apiClient.findAll()).body}catch(e){if(404===e?.data?.code)return console.error("The endpoint `password-policies` cannot be find; Falling back to the deprecated endpoint.",e),this.findLegacy();throw e}}async findLegacy(){let e=this.apiClient.options.getBaseUrl().toString();e.endsWith("/")||(e+="/");const t=this.apiClient.buildUrl(`${e}password-generator/settings`);return(await this.apiClient.fetchAndHandleResponse("GET",t)).body}async save(e){if(!e)throw new TypeError("Password policies creation failed, invalid policies data.");return(await this.apiClient.create(e)).body}static get RESOURCE_NAME(){return"password-policies/settings"}}const Dl=Ul;var Ml=r(7946);class Ll{constructor(e){this.storageKey=this.getStorageKey(e)}getStorageKey(e){if(!e.id)throw new Error("Cannot retrieve account id, necessary to get a rbac storage key.");return`passwordPolicies-${e.id}`}async flush(){return m.write({level:"debug",message:"PasswordPoliciesLocalStorage flushed"}),await Ml.storage.local.remove(this.storageKey)}async get(){return(await Ml.storage.local.get([this.storageKey]))[this.storageKey]}async set(e){Ll.assertEntityBeforeSave(e),await navigator.locks.request(this.storageKey,(async()=>{const t=e.toDto(Nl.ALL_CONTAIN_OPTIONS);await Ml.storage.local.set({[this.storageKey]:t})}))}static assertEntityBeforeSave(e){if(!e)throw new TypeError("PasswordPoliciesLocalStorage expects a PasswordPoliciesEntity to be set");if(!(e instanceof Nl))throw new TypeError("PasswordPoliciesLocalStorage expects an object of type PasswordPoliciesEntity")}}const Fl=Ll;const ql=class{constructor(e,t){this.passwordPoliciesService=new Dl(t),this.passwordPoliciesLocalStorage=new Fl(e)}async find(){try{const e=await this.passwordPoliciesService.find();return Nl.createFromDefault(e)}catch(e){console.error(e)}return null}async get(){const e=await this.passwordPoliciesLocalStorage.get();if(!e)return null;const t=e;return Nl.createFromDefault(t)}async getOrFind(){let e=await this.get();return e||(e=await this.find(),await this.passwordPoliciesLocalStorage.set(e)),e}async save(e){const t=e.toDto(Nl.ALL_CONTAIN_OPTIONS),r=await this.passwordPoliciesService.save(t),s=new Nl(r);return await this.passwordPoliciesLocalStorage.set(s),s}};const Kl=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.passwordPoliciesModel=new ql(r,s)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;try{e=await this.passwordPoliciesModel.getOrFind()}catch(e){console.error(e)}if(!e)return Nl.createFromDefault();return this.getLowestEntropy(e)>=80?e:Nl.createFromDefault()}getLowestEntropy(e){const t=El.evaluateMaxPasswordEntropy(e.passwordGeneratorSettings.toDto()),r=e.passphraseGeneratorSettings.toDto(),s=El.entropyPassphrase(r.words,r.word_separator);return t<s?t:s}};const Bl=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.passwordPoliciesModel=new ql(r,s)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new Nl(e);return this.passwordPoliciesModel.save(t)}};const jl=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.passwordPoliciesModel=new ql(r,s)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;try{e=await this.passwordPoliciesModel.find()}catch(e){console.error(e)}return e??Nl.createFromDefault()}},zl=1e4;class $l extends Vr{constructor(e,t={}){super(U.validate($l.ENTITY_NAME,e,$l.getSchema()),t)}static getSchema(){const e=Vr.getSchema();return{type:"object",required:["domain","user_id","username","first_name","last_name","user_private_armored_key","server_public_armored_key","user_public_armored_key","security_token"],properties:{domain:e.properties.domain,user_id:e.properties.user_id,username:e.properties.username,first_name:e.properties.first_name,last_name:e.properties.last_name,security_token:e.properties.security_token,user_private_armored_key:{type:"string",maxLength:zl},user_public_armored_key:{type:"string",maxLength:zl},server_public_armored_key:{type:"string",maxLength:zl}}}}toDto(){const e=Object.assign({},this._props);return e.security_token=this._security_token.toDto(),e}static get ENTITY_NAME(){return"AccountKit"}static get TYPE_ACCOUNT(){return"account-kit"}}const Vl=$l;const Yl=class{async getAccountKit(e){const t=e.toDto({user_private_armored_key:!0,security_token:!0});return new Vl(t)}};const Gl=class{static async signMessage(e,t){Me(e),Ke(t);return await ae._S({message:e,signingKeys:t})}static async signClearMessage(e,t){Le(e),Ke(t);return await ae._S({message:e,signingKeys:t})}};const Wl=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.desktopTransferModel=new Yl,this.account=r,this.getPassphraseService=new oc(r)}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await this.getPassphraseService.requestPassphrase(this.worker),t=(await this.desktopTransferModel.getAccountKit(this.account)).toDto(),r=await We(JSON.stringify(t)),s=await Je(t.user_private_armored_key),i=await Fr.decrypt(s,e),a=await Gl.signClearMessage(r,[i]),o=fi.hp.from(a).toString("base64");await Uc.saveFile("account-kit.passbolt",o,"application/passbolt",this.worker.tab.id)}};class Hl extends dt{constructor(e){super(e,Hl.RESOURCE_NAME)}async find(){return(await this.apiClient.findAll()).body}async create(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}static get RESOURCE_NAME(){return"user-passphrase-policies/settings"}}const Jl=Hl;const Zl=class{constructor(e){this.userPassphrasePoliciesService=new Jl(e)}async findOrDefault(){let e=null;try{return e=await this.userPassphrasePoliciesService.find(),us.createFromDefault(e)}catch(e){console.error(e)}return us.createFromDefault()}async save(e){be(e,us,"The given entity is not a UserPassphrasePoliciesEntity");const t=await this.userPassphrasePoliciesService.create(e);return us.createFromDefault(t)}};const Ql=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.userPassphrasePoliciesModel=new Zl(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return await this.userPassphrasePoliciesModel.findOrDefault()}};const Xl=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.userPassphrasePoliciesModel=new Zl(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new us(e);return await this.userPassphrasePoliciesModel.save(t)}};class eu extends T{constructor(e,t={}){super(U.validate(eu.ENTITY_NAME,e,eu.getSchema()),t)}static getSchema(){return{type:"object",required:["automatic_expiry","automatic_update"],properties:{id:{type:"string",format:"uuid"},default_expiry_period:{type:"null"},policy_override:{type:"boolean"},automatic_expiry:{type:"boolean"},automatic_update:{type:"boolean"},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"}}}}static get ENTITY_NAME(){return"PasswordExpirySettings"}static createFromDefault(e={}){const t={default_expiry_period:null,policy_override:!1,automatic_expiry:!1,automatic_update:!1,...e};return new eu(t)}}const tu=eu;class ru extends dt{constructor(e){super(e,ru.RESOURCE_NAME)}async find(){return(await this.apiClient.findAll()).body}async create(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}async delete(e){await this.apiClient.delete(e)}static get RESOURCE_NAME(){return"password-expiry/settings"}}const su=ru;class iu extends T{constructor(e,t={}){super(U.validate(iu.ENTITY_NAME,e,iu.getSchema()),t)}static getSchema(){return{type:"object",required:["automatic_expiry","automatic_update","policy_override"],properties:{id:{type:"string",format:"uuid"},default_expiry_period:{type:"integer",minimum:1,maximum:999,nullable:!0},policy_override:{type:"boolean"},automatic_expiry:{type:"boolean"},automatic_update:{type:"boolean"},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"}}}}static get ENTITY_NAME(){return"passwordExpiryProSettingsEntity"}static createFromDefault(e={}){const t={default_expiry_period:null,policy_override:!1,automatic_expiry:!0,automatic_update:!0,...e};return new iu(t)}}const au=iu;var ou=r(7946);const nu=class{constructor(e){this.storageKey=this.getStorageKey(e)}getStorageKey(e){if(!e.id)throw new Error("Cannot retrieve account id, necessary to get the password expiry settings storage key.");return`passwordExpirySettings-${e.id}`}async flush(){return m.write({level:"debug",message:"PasswordExpirySettingsLocalStorage flushed"}),await ou.storage.local.remove(this.storageKey)}async get(){return(await ou.storage.local.get([this.storageKey]))[this.storageKey]}async set(e){await navigator.locks.request(this.storageKey,(async()=>{await ou.storage.local.set({[this.storageKey]:e})}))}};const cu=class{constructor(e,t){this.passwordExpirySettingsLocalStorage=new nu(e),this.passwordExpirySettingsService=new su(t),this.organisationSettingsModel=new wt(t)}async getOrFindOrDefault(e=!1){try{e&&await this.passwordExpirySettingsLocalStorage.flush();let t=await this.passwordExpirySettingsLocalStorage.get();t||(t=await this.passwordExpirySettingsService.find());const r=await this.createFromDefault(t);return this.passwordExpirySettingsLocalStorage.set(r.toDto()),r}catch(e){console.error(e)}const t=await this.createFromDefault();return this.passwordExpirySettingsLocalStorage.set(t.toDto()),t}async save(e){(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("passwordExpiryPolicies")?be(e,au,"The given entity is not a PasswordExpiryProSettingsEntity"):be(e,tu,"The given entity is not a PasswordExpirySettingsEntity");const t=await this.passwordExpirySettingsService.create(e),r=await this.createFromDefault(t);return this.passwordExpirySettingsLocalStorage.set(r.toDto()),r}async delete(e){he(e,"The password expiry settings id should be a valid uuid."),await this.passwordExpirySettingsService.delete(e),await this.passwordExpirySettingsLocalStorage.flush()}async createFromDefault(e={}){return(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("passwordExpiryPolicies")?au.createFromDefault(e):tu.createFromDefault(e)}};const lu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.passwordExpirySettingsModel=new cu(r,s),this.organisationSettingsModel=new wt(s)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("passwordExpiryPolicies")?new au(e):new tu(e);return await this.passwordExpirySettingsModel.save(t)}};const uu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.passwordExpirySettingsModel=new cu(r,s)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){await this.passwordExpirySettingsModel.delete(e)}};const du=class{constructor(e,t){this.storageKey=this.getStorageKey(e),this.passwordExpirySettingsModel=new cu(e,t)}getStorageKey(e){if(!e.id)throw new Error("Cannot retrieve account id, necessary to lock the password expiry settings get or find service.");return`passwordExpirySettingsLock-${e.id}`}async exec(e=!1){return await navigator.locks.request(this.storageKey,(async()=>await this.passwordExpirySettingsModel.getOrFindOrDefault(e)))}};const pu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.passwordExpirySettingsGetOrFindService=new du(r,s)}async _exec(e=!1){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e=!1){return await this.passwordExpirySettingsGetOrFindService.exec(e)}};var hu=r(7946);class gu{static _runtimeCachedData={};constructor(e){if(!(e&&e instanceof Ys))throw new TypeError("Parameter `account` should be of type AccountEntity.");this.account=e,this.storageKey=this.getStorageKey(e)}getStorageKey(e){return`metadata_types_settings-${e.id}`}async flush(){await hu.storage.local.remove(this.storageKey),delete gu._runtimeCachedData[this.account.id],console.debug(`MetadataTypesSettingsLocalStorage flushed for (${this.account.id})`)}async get(){if(!gu._runtimeCachedData[this.account.id]){const e=await hu.storage.local.get([this.storageKey]);if(!e[this.storageKey])return;gu._runtimeCachedData[this.account.id]=e[this.storageKey]}return gu._runtimeCachedData[this.account.id]}async set(e){if(!(e&&e instanceof fa))throw new TypeError("Parameter `settings` should be of type MetadataTypesSettingsEntity");await navigator.locks.request(this.storageKey,(async()=>{const t=e.toDto();await this._setBrowserStorage({[this.storageKey]:t}),gu._runtimeCachedData[this.account.id]=t}))}async _setBrowserStorage(e){await hu.storage.local.set(e)}}const yu=gu;const mu=class extends dt{constructor(e){super(e,"metadata/types/settings")}async findSettings(){return(await this.apiClient.findAll()).body}};const wu=class extends dt{constructor(e){super(e,"metadata/keys/settings")}async findSettings(){return(await this.apiClient.findAll()).body}};class _u extends $t{static getSchema(){return{type:"object",required:["allow_usage_of_personal_keys","zero_knowledge_key_share"],properties:{allow_usage_of_personal_keys:{type:"boolean"},zero_knowledge_key_share:{type:"boolean"}}}}static createFromDefault(e={}){return new _u({allow_usage_of_personal_keys:!0,zero_knowledge_key_share:!1,...e})}get allowUsageOfPersonalKeys(){return this._props.allow_usage_of_personal_keys}get zeroKnowledgeKeyShare(){return this._props.zero_knowledge_key_share}}const fu=_u;class vu{constructor(e){this.metadataTypesSettingsApiService=new mu(e),this.metadataKeysSettingsApiService=new wu(e)}async findTypesSettings(){const e=await this.metadataTypesSettingsApiService.findSettings();return fa.createFromDefault(e)}async findKeysSettings(){const e=await this.metadataKeysSettingsApiService.findSettings();return fu.createFromDefault(e)}}var Su=r(7946);class bu{static _runtimeCachedData={};constructor(e){if(!(e&&e instanceof Ys))throw new TypeError("Parameter `account` should be of key AccountEntity.");this.account=e,this.storageKey=this.getStorageKey(e)}getStorageKey(e){return`metadata_keys_settings-${e.id}`}async flush(){await Su.storage.local.remove(this.storageKey),delete bu._runtimeCachedData[this.account.id],console.debug(`MetadataKeysSettingsLocalStorage flushed for (${this.account.id})`)}async get(){if(!bu._runtimeCachedData[this.account.id]){const e=await Su.storage.local.get([this.storageKey]);if(!e[this.storageKey])return;bu._runtimeCachedData[this.account.id]=e[this.storageKey]}return bu._runtimeCachedData[this.account.id]}async set(e){if(!(e&&e instanceof fu))throw new TypeError("Parameter `settings` should be of key MetadataKeysSettingsEntity");await navigator.locks.request(this.storageKey,(async()=>{const t=e.toDto();await this._setBrowserStorage({[this.storageKey]:t}),bu._runtimeCachedData[this.account.id]=t}))}async _setBrowserStorage(e){await Su.storage.local.set(e)}}const Eu=bu;class ku{constructor(e,t){this.account=e,this.findMetadataSettingsService=new vu(t),this.metadataTypesSettingsLocalStorage=new yu(e),this.metadataKeysSettingsLocalStorage=new Eu(e),this.organisationSettingsModel=new wt(t)}async findAndUpdateTypesSettings(){const e=`FIND_AND_UPDATE_METADATA_TYPES_SETTINGS_LS_LOCK-${this.account.id}`;return await navigator.locks.request(e,{ifAvailable:!0},(async t=>{if(!t)return await navigator.locks.request(e,{mode:"shared"},(async()=>new fa(await this.metadataTypesSettingsLocalStorage.get())));let r;return r=(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("metadata")?await this.findMetadataSettingsService.findTypesSettings():fa.createFromV4Default(),await this.metadataTypesSettingsLocalStorage.set(r),r}))}async findAndUpdateKeysSettings(){const e=`FIND_AND_UPDATE_METADATA_KEYS_SETTINGS_LS_LOCK-${this.account.id}`;return await navigator.locks.request(e,{ifAvailable:!0},(async t=>{if(!t)return await navigator.locks.request(e,{mode:"shared"},(async()=>new fu(await this.metadataKeysSettingsLocalStorage.get())));const r=await this.findMetadataSettingsService.findKeysSettings();return await this.metadataKeysSettingsLocalStorage.set(r),r}))}}class Au{constructor(e,t){this.findAndUpdateMetadataSettingsLocalStorageService=new ku(e,t),this.metadataTypesSettingsLocalStorage=new yu(e),this.metadataKeysSettingsLocalStorage=new Eu(e)}async getOrFindTypesSettings(){const e=await this.metadataTypesSettingsLocalStorage.get();return e?fa.createFromDefault(e):this.findAndUpdateMetadataSettingsLocalStorageService.findAndUpdateTypesSettings()}async getOrFindKeysSettings(){const e=await this.metadataKeysSettingsLocalStorage.get();return e?fu.createFromDefault(e):this.findAndUpdateMetadataSettingsLocalStorageService.findAndUpdateKeysSettings()}}const Tu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.getOrFindMetadaSettingsService=new Au(s,r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.getOrFindMetadaSettingsService.getOrFindTypesSettings()}},Iu={listen:function(e,t,r){e.port.on("passbolt.app.route-changed",(async t=>{if(/^\/[A-Za-z0-9\-\/]*$/.test(t)){(await zs.get("AppBootstrap",e.tab.id)).port.emit("passbolt.app-bootstrap.change-route",t)}})),e.port.on("passbolt.account-recovery.get-organization-policy",(async t=>{const r=await re.getInstance().getApiClientOptions(),s=new $n(e,t,r);await s._exec()})),e.port.on("passbolt.account-recovery.save-organization-policy",(async(t,s,i)=>{const a=await re.getInstance().getApiClientOptions(),o=new hc(e,t,a,r);await o._exec(s,i)})),e.port.on("passbolt.account-recovery.validate-organization-key",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new yc(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.generate-organization-key",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new Ec(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.download-organization-generated-key",(async(t,r)=>{try{const s=(new Date).toISOString().slice(0,10);await Uc.saveFile(`organization-recovery-private-key-${s}.asc`,r,"text/plain",e.tab.id),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.account-recovery.validate-organization-private-key",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new fc(e,t,s);return await i._exec(r)})),e.port.on("passbolt.account-recovery.get-user-requests",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new vc(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.get-request",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new Sc(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.save-user-settings",(async(t,s)=>{const i=await re.getInstance().getApiClientOptions(),a=new Ic(e,t,i,r);await a._exec(s)})),e.port.on("passbolt.account-recovery.review-request",(async(t,s,i,a)=>{const o=await re.getInstance().getApiClientOptions(),n=new bc(e,t,o,r);await n._exec(s,i,a)})),e.port.on("passbolt.account-recovery.has-user-postponed-user-setting-invitation",(async t=>{const r=new xc(e,t);await r._exec()})),e.port.on("passbolt.account-recovery.postpone-user-setting-invitation",(async t=>{const r=new Pc(e,t);await r._exec()})),e.port.on("passbolt.sso.get-current",(async t=>{const r=await re.getInstance().getApiClientOptions(),s=new $c(e,t,r);await s._exec()})),e.port.on("passbolt.sso.save-draft",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new Vc(e,t,s);await i._exec(r)})),e.port.on("passbolt.sso.dry-run",(async(t,s)=>{const i=await re.getInstance().getApiClientOptions(),a=new zc(e,t,i,r);await a._exec(s)})),e.port.on("passbolt.sso.activate-settings",(async(t,r,s)=>{const i=await re.getInstance().getApiClientOptions(),a=new Yc(e,t,i);await a._exec(r,s)})),e.port.on("passbolt.sso.delete-settings",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new Gc(e,t,s);await i._exec(r)})),e.port.on("passbolt.sso.generate-sso-kit",(async(t,s)=>{const i=await re.getInstance().getApiClientOptions(),a=new Wc(e,t,i,r);await a._exec(s)})),e.port.on("passbolt.rbacs.find-me",(async(t,s)=>{const i=await re.getInstance().getApiClientOptions(),a=new yl(e,t,i,r);await a._exec(s)})),e.port.on("passbolt.password-policies.get",(async t=>{const s=await re.getInstance().getApiClientOptions(),i=new Kl(e,t,r,s);await i._exec()})),e.port.on("passbolt.password-policies.save",(async(t,s)=>{const i=await re.getInstance().getApiClientOptions(),a=new Bl(e,t,r,i);await a._exec(s)})),e.port.on("passbolt.password-policies.get-admin-settings",(async t=>{const s=await re.getInstance().getApiClientOptions(),i=new jl(e,t,r,s);await i._exec()})),e.port.on("passbolt.user-passphrase-policies.find",(async t=>{const r=await re.getInstance().getApiClientOptions(),s=new Ql(e,t,r);await s._exec()})),e.port.on("passbolt.user-passphrase-policies.save",(async(t,r)=>{const s=await re.getInstance().getApiClientOptions(),i=new Xl(e,t,s);await i._exec(r)})),e.port.on("passbolt.password-expiry.get-or-find",(async(s,i=!1)=>{const a=new pu(e,s,r,t);await a._exec(i)})),e.port.on("passbolt.password-expiry.save",(async(s,i)=>{const a=new lu(e,s,r,t);await a._exec(i)})),e.port.on("passbolt.password-expiry.delete",(async(s,i)=>{const a=new uu(e,s,r,t);await a._exec(i)})),e.port.on("passbolt.desktop.export-account",(async t=>{const r=await Io.get(),s=new Wl(e,t,r);await s._exec()})),e.port.on("passbolt.metadata.get-or-find-metadata-types-settings",(async s=>{const i=new Tu(e,s,t,r);await i._exec()}))}};class Ru extends Error{constructor(e){super(e),this.name="KeyIsExpiredError"}}const Cu=Ru;class Ou extends Error{constructor(e){super(e),this.name="ServerKeyChangedError"}}const xu=Ou;const Pu=class{static async areKeysTheSame(e,t){Ye(e),Ye(t);const r=await Ct.getKeyInfo(e),s=await Ct.getKeyInfo(t);return r.fingerprint===s.fingerprint&&r.expires===s.expires}};const Nu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.authVerifyServerChallengeService=new Ds(r),this.authVerifyServerKeyService=new Us(r),this.account=s}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{await this.authVerifyServerChallengeService.verifyAndValidateServerChallenge(this.account.userKeyFingerprint,this.account.serverPublicArmoredKey)}catch(e){await this.onVerifyError(e)}}async onVerifyError(e){if(500===e.data?.code||0===e.data?.code)throw e;if(e.message&&-1!==e.message.indexOf("no user associated"))(await zs.get("AuthBootstrap",this.worker.tab.id)).port.emit("passbolt.auth-bootstrap.remove-iframe");else try{await this.canParseServerKey()?await this.serverKeyChanged()?e=new xu(ue.t("The server key has changed.")):await this.serverKeyIsExpired()&&(e=new Cu(ue.t("The server key is expired."))):e=new xu(ue.t("The server key cannot be parsed."))}catch(t){e=new Error(ue.t("Server internal error. Check with your administrator."))}throw e.message=`${ue.t("Could not verify the server key.")} ${e.message}`,e}async canParseServerKey(){try{await Je(this.account.serverPublicArmoredKey)}catch(e){return!1}return!0}async serverKeyChanged(){const e=(await this.authVerifyServerKeyService.getServerKey()).armored_key,t=await Je(e),r=await Je(this.account.serverPublicArmoredKey);return!await Pu.areKeysTheSame(t,r)}async serverKeyIsExpired(){const e=await Je(this.account.serverPublicArmoredKey);return(await Ct.getKeyInfo(e)).isExpired}};const Uu=class{constructor(e,t){this.worker=e,this.requestId=t,this.checkAuthStatusService=new Fo}async _exec(e=!0){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return await this.checkAuthStatusService.checkAuthStatus(e)}};const Du=class{constructor(e,t){this.worker=e,this.requestId=t,this.checkAuthStatusService=new Fo}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return(await this.checkAuthStatusService.checkAuthStatus(!0)).isMfaRequired}};const Mu=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new xt,this.checkPassphraseService=new Js(this.keyring)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){await this.checkPassphraseService.checkPassphrase(e)}};const Lu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.userModel=new To(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.userModel.requestHelpCredentialsLost(this.account)}};var Fu=r(7946);const qu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.authVerifyLoginChallengeService=new ji(r),this.updateSsoCredentialsService=new Ni(r),this.checkPassphraseService=new Js(new xt),this.userRememberMeLatestChoiceLocalStorage=new rc(s)}async _exec(e,t,r=!1){try{await this.exec(e,t,r),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t,r){if(void 0===e)throw new Error("A passphrase is required.");if("string"!=typeof e)throw new Error("The passphrase should be a string.");if(void 0!==t&&"boolean"!=typeof t)throw new Error("The rememberMe should be a boolean.");await this.checkPassphraseService.checkPassphrase(e);try{await this.updateSsoCredentialsService.updateSsoKitIfNeeded(e)}catch(e){console.error(e)}try{await this.authVerifyLoginChallengeService.verifyAndValidateLoginChallenge(this.account.userKeyFingerprint,this.account.userPrivateArmoredKey,e),t?await Promise.all([Wi.set(e,-1),ac.start()]):await Wi.set(e,60),await Vw.exec(),await this.registerRememberMeOption(t)}catch(e){if(!(e instanceof Os))throw e}r&&await this.redirectToApp()}async redirectToApp(){const e=this.account.domain;Fu.tabs.update(this.worker.tab.id,{url:e})}async registerRememberMeOption(e){const t=new ec({duration:e?-1:0});await this.userRememberMeLatestChoiceLocalStorage.set(t)}};const Ku=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;try{e=await _i.get()}catch(e){return console.error(e),null}return e?.isRegistered()?e.provider:null}};class Bu extends Error{constructor(e){super(e),this.name="OutdatedSsoKitError"}}const ju=Bu;const zu=class{static async decrypt(e,t,r,s,i){ge(e),we(t),_e(r),fe(s),fe(i);const a=fi.hp.from(e,"base64"),o={name:r.algorithm.name,iv:i},n={name:t.algorithm.name,iv:s};let c=null;try{c=await crypto.subtle.decrypt(o,r,a)}catch(e){throw console.error(e),new ju(`Unable to decrypt passphrase from the server SSO kit: ${e.message}`)}let l=null;try{l=await crypto.subtle.decrypt(n,t,c)}catch(e){throw console.error(e),new Error(`Unable to decrypt passphrase with the local SSO kit: ${e.message}`)}return fi.hp.from(l).toString()}};class $u{constructor(e){this.apiClientOptions=e}static get RESOURCE_NAME(){return"/sso/${providerId}/login"}async getLoginUrl(e,t){return(await this.getApiClient(e).create(t)).body}getApiClient(e){if("string"!=typeof e)throw new Error("The provider identifier should be a string");const t=$u.RESOURCE_NAME.replace("${providerId}",e);return this.apiClientOptions.setResourceName(t),new ut(this.apiClientOptions)}}const Vu=$u;const Yu=class{constructor(e){this.ssoLoginService=new Vu(e)}async getLoginUrl(e,t){he(t,"The user id should be a valid uuid.");const r=await this.ssoLoginService.getLoginUrl(e,{user_id:t});return new Lc(r,e)}};class Gu extends Error{constructor(e){super(e),this.name="SsoSettingsChangedError"}}const Wu=Gu;class Hu extends Error{constructor(e){super(e),this.name="SsoDisabledError"}}const Ju=Hu;class Zu extends Error{constructor(e,t){super(e),this.name="SsoProviderMismatchError",this.configuredProvider=t}}const Qu=Zu,Xu=new Error("Unexpected SSO Login error");const ed=class{static async qualifyErrorFromConfiguration(e){const t=await _i.get();return t?e.provider?e.provider!==t.provider?new Qu("The request SSO provider is not corresponding to the configured one",e.provider):Xu:new Ju("The SSO is disabled"):Xu}};const td=class{static exec(e,t=500){return new Promise(((r,s)=>{const i=setTimeout(s,t);e.then(r).catch(s).finally((()=>clearTimeout(i)))}))}};var rd=r(7946);const sd=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.ssoKitServerPartModel=new Pi(r),this.ssoLoginModel=new Yu(r),this.popupHandler=new qc(s.domain,e?.tab?.id,!1),this.authVerifyLoginChallengeService=new ji(r),this.ssoSettingsModel=new gi(r)}async _exec(e,t=!1){try{await this.exec(e,t),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){const r=await _i.get();if(!r)throw new Error("The Single Sign-On cannot proceed as there is no SSO kit registered on this browser profile.");const s=this.account.userId;let i;try{i=await this.ssoLoginModel.getLoginUrl(e,s)}catch(e){throw await this.qualifyGetLoginUrlError(e,t)}try{const e=await this.popupHandler.getSsoTokenFromThirdParty(i),a=await this.ssoKitServerPartModel.getSsoKit(r.id,s,e),o=await crypto.subtle.importKey("jwk",a.key,"AES-GCM",!0,["encrypt","decrypt"]),n=await zu.decrypt(r.secret,r.nek,o,r.iv1,r.iv2);await this.popupHandler.closeHandler(),await this.authVerifyLoginChallengeService.verifyAndValidateLoginChallenge(this.account.userKeyFingerprint,this.account.userPrivateArmoredKey,n),await Promise.all([Wi.set(n,-1),ac.start()]),await Vw.exec(),t&&await this.ensureRedirectionInQuickaccessMode()}catch(e){throw console.error("An error occured while attempting sign in with a third party provider:",e),this.handleSpecificErrors(e),e}}async ensureRedirectionInQuickaccessMode(){try{return void await td.exec(this.worker.port.request("passbolt.port.check"))}catch(e){console.debug("The port from the quickaccess is not connected anymore"),console.error(e)}const e=[{name:"uiMode",value:"detached"},{name:"feature",value:"login"},{name:"tabId",value:(await Bs.getCurrent()).id}];await Jn.openInDetachedMode(e)}handleSpecificErrors(e){switch(e.name){case"InvalidMasterPasswordError":case"OutdatedSsoKitError":_i.flush();break;case"PassboltApiFetchError":403===e?.data?.code||_i.flush()}}async qualifyGetLoginUrlError(e,t){if(400!==e.data.code)return e;if(t){const e=`${this.account.domain}/auth/login?case=sso-login-error`;return await rd.tabs.create({url:e,active:!0}),new Wu("The quickaccess cannot proceed with the SSO login.")}const r=await this.ssoSettingsModel.getCurrent();return ed.qualifyErrorFromConfiguration(r)}};const id=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await _i.flush()}};const ad=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await _i.get();t.provider=e,await _i.updateLocalKitProviderWith(t)}};const od=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return"sso-login-error"===(new URL(this.worker.tab.url).searchParams.get("case")||null)}};const nd=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new gi(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await this.ssoSettingsModel.getCurrent();return await ed.qualifyErrorFromConfiguration(e)}};const cd=class{constructor(e){e.setResourceName("auth"),this.apiClient=new ut(e)}async logout(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/logout`,{}),t=await this.apiClient.sendRequest("POST",e,null,{redirect:"manual"});if(!(t.ok||0===t.status))return this._logoutLegacy()}async _logoutLegacy(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/logout`,{}),t=await this.apiClient.sendRequest("GET",e,null,{redirect:"manual"});if(!(t.ok||0===t.status))throw new it("An unexpected error happened during the legacy logout process",{code:t.status})}};const ld=class{constructor(e){this.authLogoutService=new cd(e)}async logout(){await this.authLogoutService.logout(),await Kw.exec()}};var ud=r(7946);const dd=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.apiClientOptions=r,this.authModel=new ld(this.apiClientOptions)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(await this.authModel.logout(),!e)return;const t=this.apiClientOptions.getBaseUrl().toString();await ud.tabs.update(this.worker.tab.id,{url:t})}};const pd=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.authVerifyServerKeyService=new Us(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.authVerifyServerKeyService.getServerKey()}};const hd=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.authVerifyServerKeyService=new Us(r),this.account=s}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=new xt,t=await this.authVerifyServerKeyService.getServerKey();await e.importServerPublicKey(t.armored_key,this.account.domain)}};const gd=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await Bs.reloadTab(this.worker.tab.id)}},yd={listen:function(e,t,r){e.port.on("passbolt.auth.is-mfa-required",(async t=>{new Du(e,t)._exec()})),e.port.on("passbolt.auth.check-status",(async t=>{new Uu(e,t)._exec()})),e.port.on("passbolt.auth.logout",(async(r,s)=>{const i=new dd(e,r,t);await i._exec(s)})),e.port.on("passbolt.auth.verify-server-key",(async s=>{const i=new Nu(e,s,t,r);await i._exec()})),e.port.on("passbolt.auth.get-server-key",(async r=>{const s=new pd(e,r,t);await s._exec()})),e.port.on("passbolt.auth.replace-server-key",(async s=>{const i=new hd(e,s,t,r);await i._exec()})),e.port.on("passbolt.auth.verify-passphrase",(async(t,r)=>{const s=new Mu(e,t);await s._exec(r)})),e.port.on("passbolt.auth.login",(async(s,i,a)=>{const o=new qu(e,s,t,r);await o._exec(i,a)})),e.port.on("passbolt.auth.post-login-redirect",(t=>{let s=r.domain;const i=new URL(e.tab.url).searchParams.get("redirect");/^\/[A-Za-z0-9\-\/]*$/.test(i)&&(s=`${s}${i}`),chrome.tabs.update(e.tab.id,{url:s}),e.port.emit(t,"SUCCESS")})),e.port.on("passbolt.auth.request-help-credentials-lost",(async s=>{const i=new Lu(e,s,t,r);await i._exec()})),e.port.on("passbolt.sso.sign-in",(async(s,i,a)=>{const o=new sd(e,s,t,r);await o._exec(i,a)})),e.port.on("passbolt.sso.get-local-configured-provider",(async t=>{const r=new Ku(e,t);await r._exec()})),e.port.on("passbolt.sso.delete-local-kit",(async t=>{const r=new id(e,t);await r._exec()})),e.port.on("passbolt.sso.update-provider-local-kit",(async(t,r)=>{const s=new ad(e,t);await s._exec(r)})),e.port.on("passbolt.sso.has-sso-login-error",(async t=>{const r=new od(e,t);await r._exec()})),e.port.on("passbolt.sso.get-qualified-sso-login-error",(async r=>{const s=new nd(e,r,t);await s._exec()})),e.port.on("passbolt.tab.reload",(async t=>{const r=new gd(e,t);await r._exec()}))}};var md=r(7946);const wd=new k,_d="folders";class fd{static _cachedData=null;static hasCachedData(){return null!==fd._cachedData}static async flush(){m.write({level:"debug",message:"FolderLocalStorage flushed"}),await md.storage.local.remove(_d),fd._cachedData=null}static async get(){if(!fd._cachedData){const{folders:e}=await md.storage.local.get([_d]);fd._cachedData=e}return fd._cachedData}static async set(e){await wd.acquire();try{const t=[];if(!(e instanceof mo))throw new TypeError("FolderLocalStorage::set expects a FoldersCollection");for(const r of e)fd.assertEntityBeforeSave(r),t.push(r.toDto(fd.DEFAULT_CONTAIN));await md.storage.local.set({folders:t}),fd._cachedData=t}finally{wd.release()}}static async getFolderById(e){const t=await fd.get();return t?.find((t=>t.id===e))}static async getFolderByParentId(e){const t=await fd.get();return t?.find((t=>t.folder_parent_id===e))}static async addFolder(e){await wd.acquire();try{fd.assertEntityBeforeSave(e);const t=await fd.get()||[];t.push(e.toDto(fd.DEFAULT_CONTAIN)),await md.storage.local.set({folders:t}),fd._cachedData=t}finally{wd.release()}}static async addFolders(e){Ae(e,"The parameter foldersEntities should be an array"),await wd.acquire();try{const t=await fd.get()||[];e.forEach((e=>{fd.assertEntityBeforeSave(e),t.push(e.toDto(fd.DEFAULT_CONTAIN))})),await md.storage.local.set({folders:t}),fd._cachedData=t}finally{wd.release()}}static async updateFolder(e){await wd.acquire();try{fd.assertEntityBeforeSave(e);const t=await fd.get()||[],r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The folder could not be found in the local storage");t[r]=e.toDto(fd.DEFAULT_CONTAIN),await md.storage.local.set({folders:t}),fd._cachedData=t}finally{wd.release()}}static async delete(e){he(e,"The parameter folderId should be a UUID."),await wd.acquire();try{const t=await fd.get()||[];if(t.length>0){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await md.storage.local.set({folders:t}),fd._cachedData=t}}finally{wd.release()}}static get DEFAULT_CONTAIN(){return{permission:!0}}static assertEntityBeforeSave(e){if(!e)throw new TypeError("FolderLocalStorage expects a FolderEntity to be set");if(!(e instanceof go))throw new TypeError("FolderLocalStorage expects an object of type FolderEntity");if(!e.id)throw new TypeError("FolderLocalStorage expects FolderEntity id to be set");if(!e.permission)throw new TypeError("FolderLocalStorage::set expects FolderEntity permission to be set")}}const vd=fd;class Sd extends T{constructor(e,t={}){super(U.validate(Sd.ENTITY_NAME,e,Sd.getSchema()),t)}static getSchema(){const e=da.getSchema(),t=e.required,r={type:"object",required:e.required,properties:{id:{type:"string",format:"uuid"},delete:{type:"boolean"}}};return t.forEach((t=>{r.properties[t]=e.properties[t]})),r}static createFromPermission(e,t){if(!(e&&e instanceof da))throw new TypeError("PermissionChangeEntity createFromPermission expect a permission entity.");const r={aco:e.aco,aro:e.aro,aco_foreign_key:e.acoForeignKey,aro_foreign_key:e.aroForeignKey,type:e.type};switch(t){case Sd.PERMISSION_CHANGE_CREATE:break;case Sd.PERMISSION_CHANGE_UPDATE:if(!e.id)throw new TypeError("PermissionChangeEntity createFromPermission update expect a permission id.");r.id=e.id;break;case Sd.PERMISSION_CHANGE_DELETE:if(!e.id)throw new TypeError("PermissionChangeEntity createFromPermission delete expect a permission id.");r.id=e.id,r.delete=!0;break;default:throw new TypeError("PermissionChangeEntity createFromPermission unsupported operation")}return new Sd(r)}copyForAnotherAco(e,t){return new da({aro:this.aro,aro_foreign_key:this.aroForeignKey,aco:e,aco_foreign_key:t,type:this.type})}get id(){return this._props.id||null}get aco(){return this._props.aco}get aro(){return this._props.aro}get aroForeignKey(){return this._props.aro_foreign_key}get acoForeignKey(){return this._props.aco_foreign_key}get type(){return this._props.type}get isDeleted(){return void 0===this._props.delete?null:this._props.delete}get scenario(){return this.isDeleted?Sd.PERMISSION_CHANGE_DELETE:this.id?Sd.PERMISSION_CHANGE_UPDATE:Sd.PERMISSION_CHANGE_CREATE}static get ENTITY_NAME(){return"PermissionChange"}static get PERMISSION_CHANGE_CREATE(){return"create"}static get PERMISSION_CHANGE_UPDATE(){return"update"}static get PERMISSION_CHANGE_DELETE(){return"delete"}}const bd=Sd;class Ed extends Ft{constructor(e,t={}){super(U.validate(Ed.ENTITY_NAME,e,Ed.getSchema()),t),this._props.forEach((e=>{this.push(e)})),this._props=null}static getSchema(){return{type:"array",items:bd.getSchema()}}static get ENTITY_NAME(){return"PermissionChanges"}filterByAcoForeignKey(e){const t=this._items.filter((t=>t.acoForeignKey===e));return new Ed(t)}filterByAroForeignKey(e){const t=this._items.filter((t=>t.aroForeignKey===e));return new Ed(t)}push(e){if(!e||"object"!=typeof e)throw new TypeError("PermissionChangesCollection push parameter should be an object.");e instanceof bd&&(e=e.toDto()),e=new bd(e),super.push(e)}merge(e){for(const t of e)this.push(t)}copyForAnotherAco(e,t){const r=new Ed([]);for(const s of this.items)r.push(s.copyForAnotherAco(e,t));return r}static reuseChanges(e,t,r,s,i){if(!(e&&t&&r&&i&&s))throw new TypeError("PermissionChangesCollection reuseChanges call is missing parameter(s).");const a=new Ed([]);for(const o of s){const s=r.getByAro(o.aro,o.aroForeignKey);switch(o.scenario){case bd.PERMISSION_CHANGE_DELETE:s&&s.type===o.type&&a.push(bd.createFromPermission(s,bd.PERMISSION_CHANGE_DELETE));break;case bd.PERMISSION_CHANGE_CREATE:s||a.push(new bd({aco:e,aco_foreign_key:t,aro:o.aro,aro_foreign_key:o.aroForeignKey,type:o.type}));break;case bd.PERMISSION_CHANGE_UPDATE:if(s&&s.type!==o.type){if(i.items.find((e=>e.id===o.id)).type===s.type){const e=new da(s.toDto());e.type=o.type,a.push(bd.createFromPermission(e,bd.PERMISSION_CHANGE_UPDATE))}}}}return a}static calculateChanges(e,t){if(!(e&&e instanceof ha&&t&&t instanceof ha))throw new TypeError("PermissionChangesCollection calculateChanges invalid parameters");const r=new Ed([]);for(const s of t){const t=e.getByAroMatchingPermission(s);if(t){if(s.type!==t.type){s.id=t.id;const e=bd.createFromPermission(s,bd.PERMISSION_CHANGE_UPDATE);r.push(e)}}else{const e=bd.createFromPermission(s,bd.PERMISSION_CHANGE_CREATE);r.push(e)}}for(const s of e)if(!t.getByAroMatchingPermission(s)){const e=bd.createFromPermission(s,bd.PERMISSION_CHANGE_DELETE);r.push(e)}return r}}const kd=Ed;class Ad extends dt{constructor(e){super(e,Ad.RESOURCE_NAME)}static get RESOURCE_NAME(){return"move"}async move(e){let t;if(e instanceof go)t="Folder";else{if(!(e instanceof no))throw new TypeError("The entity must be a FolderEntity or a ResourceEntity");t="Resource"}const r=`${t.toLowerCase()}/${e.id}`,s=e.toDto();return(await this.apiClient.update(r,s)).body}async moveResource(e,t){he(e,"The parameter 'id' should be a UUID."),null!==t&&he(t,"The parameter 'destinationFolderId' should be a UUID or null.");const r=`resource/${e}`,s={folder_parent_id:t};return(await this.apiClient.update(r,s)).body}}const Td=Ad;class Id extends dt{constructor(e){super(e,Id.RESOURCE_NAME)}static get RESOURCE_NAME(){return"folders"}static getSupportedContainOptions(){return["children_resources","children_folders","creator","modifier","permission","permissions","permissions.user.profile","permissions.group"]}static getSupportedFiltersOptions(){return["has-id","has-parent","search"]}async get(e,t){this.assertValidId(e);const r=t?this.formatContainOptions(t,Id.getSupportedContainOptions()):null;return(await this.apiClient.get(e,r)).body}async findAll(e,t){e=e?this.formatContainOptions(e,Id.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(t,Id.getSupportedFiltersOptions()):null;const r={...e,...t},s=await this.apiClient.findAll(r);return s.body&&s.body.length?s.body:[]}async create(e,t){this.assertNonEmptyData(e);const r=t?this.formatContainOptions(t,Id.getSupportedContainOptions()):null;return(await this.apiClient.create(e,r)).body}async update(e,t,r){this.assertValidId(e),this.assertNonEmptyData(t);const s=r?this.formatContainOptions(r,Id.getSupportedContainOptions()):null;return(await this.apiClient.update(e,t,s)).body}async delete(e,t){this.assertValidId(e);const r={};t&&(r.cascade="1");return(await this.apiClient.delete(e,null,r)).body}async findAllForShare(e){if(e.length>80){let t=[];const r=Math.ceil(e.length/80);for(let s=0;s<r;s++){const r=e.splice(0,80),s=await this.findAllForShare(r);t=[...t,...s]}return t}const t=this.apiClient.buildUrl(this.apiClient.baseUrl.toString());e.forEach((e=>{t.searchParams.append("filter[has-id][]",e)})),t.searchParams.append("contain[permission]","1"),t.searchParams.append("contain[permissions.user.profile]","1"),t.searchParams.append("contain[permissions.group]","1");return(await this.apiClient.fetchAndHandleResponse("GET",t)).body}}const Rd=Id;class Cd extends dt{constructor(e){super(e,Cd.RESOURCE_NAME)}static getSupportedSearchArosFiltersOptions(){return["search"]}static getSupportedSearchArosContainOptions(){return["profile","user_count","role"]}static get RESOURCE_NAME(){return"share"}async shareFolder(e,t){this.assertValidId(e),this.assertNonEmptyData(t);const r=`folder/${e}`;return(await this.apiClient.update(r,t)).body}async simulateShareResource(e,t){const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/simulate/resource/${e}`,{}),s=this.apiClient.buildBody({permissions:t});return(await this.apiClient.fetchAndHandleResponse("POST",r,s)).body}async shareResource(e,t){this.assertValidId(e),this.assertNonEmptyData(t);const r=`resource/${e}`;return(await this.apiClient.update(r,t)).body}async searchUsersAndGroups(e,t){ve(e,"keyword is not a valid string");const r=this.formatFilterOptions({search:e},Cd.getSupportedSearchArosFiltersOptions());t=this.formatContainOptions(t,Cd.getSupportedSearchArosContainOptions());const s={...r,...t};return(await this.apiClient.get("search-aros",s)).body}}const Od=Cd;class xd{constructor(e){this.folderService=new Rd(e)}async findById(e,t){he(e);const r=Rd.getSupportedContainOptions();if(t&&!Object.keys(t).every((e=>r.includes(e))))throw new Error("Unsupported contains parameter used, please check supported contains");const s=await this.folderService.get(e,t);return new go(s)}async findByIdWithPermissions(e){he(e);const t=await this.findById(e,{"permissions.user.profile":!0,"permissions.group":!0,permission:!0});return new go(t)}async findByIdWithCreatorAndModifier(e){he(e);const t=await this.findById(e,{creator:!0,modifier:!0});return new go(t)}async findAll(e,t,r){const s=Rd.getSupportedContainOptions(),i=Rd.getSupportedFiltersOptions();if(e&&!Object.keys(e).every((e=>s.includes(e))))throw new Error("Unsupported contains parameter used, please check supported contains");if(t&&!Object.keys(t).every((e=>i.includes(e))))throw new Error("Unsupported filters parameter used, please check supported filters");ke(r?.ignoreInvalidEntity);const a=await this.folderService.findAll(e,t);return new mo(a,{clone:!1,ignoreInvalidEntity:r?.ignoreInvalidEntity})}async findAllForLocalStorage(){return this.findAll(vd.DEFAULT_CONTAIN,null,{ignoreInvalidEntity:!0})}async findAllByIds(e,t={}){Ie(e);const r=en(e,80).map((e=>{const r={"has-id":e};return async()=>await this.findAll(t,r)})),s=new Xo,i=await s.execute(r,5),a=new mo;return i.forEach((e=>{a._items=a._items.concat(e._items)})),a}async findAllByIdsWithPermissions(e){Ie(e);return this.findAllByIds(e,{permission:!0,permissions:!0})}}class Pd{static lastUpdateAllTimes={};constructor(e,t){this.account=e,this.findFoldersServices=new xd(t)}async findAndUpdateAll({updatePeriodThreshold:e}={}){Re(e,"Parameter updatePeriodThreshold should be a number.");const t=`FOLDERS_UPDATE_LS_LOCK_${this.account.id}`,r=Pd.lastUpdateAllTimes[this.account.id]??null,s=vd.hasCachedData(),i=await vd.get();return e&&r&&Boolean(i)&&Date.now()-r<e?new mo(i,{validate:!s}):await navigator.locks.request(t,{ifAvailable:!0},(async e=>{if(!e)return navigator.locks.request(t,{mode:"shared"},(async()=>new mo(await vd.get(),{validate:!1})));const r=await this.findFoldersServices.findAllForLocalStorage();return await vd.set(r),Pd.lastUpdateAllTimes[this.account.id]=Date.now(),r}))}}const Nd=Pd;const Ud=class{constructor(e,t){this.folderService=new Rd(e),this.moveService=new Td(e),this.shareService=new Od(e),this.findAndUpdateFoldersLocalStorageService=new Nd(t,e)}async getById(e){const t=await vd.getFolderById(e);return t?new go(t):null}async getAllByIds(e,t){const r=new mo([]),s=await vd.get();if(s){const i=new mo(s);if(i.items.forEach((t=>{e.includes(t.id)&&r.push(t)})),t)for(const t in e){const s=e[t],a=mo.getAllChildren(s,i,r);r.merge(a)}}return r}async getAllChildren(e){const t=await vd.get(),r=new mo(t),s=new mo([]);for(const t in e){const i=e[t],a=mo.getAllChildren(i,r,s);s.merge(a)}return s}async findAllForShare(e){const t=await this.folderService.findAllForShare(e);return new mo(t)}async findForShare(e){const t=await this.folderService.findAllForShare([e]);if(!t.length)throw new Error(`Folder ${e} not found`);return new go(t[0])}calculatePermissionsChangesForMove(e,t,r){let s=new ha([],{assertAtLeastOneOwner:!1});if(t){if(!e.permissions||!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires permissions to be set.");s=ha.diff(e.permissions,t.permissions,!1)}let i=new ha([],{assertAtLeastOneOwner:!1});if(r){if(!r.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");i=r.permissions.cloneForAco(da.ACO_FOLDER,e.id,!1)}const a=ha.sum(s,i,!1);return r||a.addOrReplace(new da({aco:da.ACO_FOLDER,aco_foreign_key:e.id,aro:e.permission.aro,aro_foreign_key:e.permission.aroForeignKey,type:da.PERMISSION_OWNER})),a.assertAtLeastOneOwner(),kd.calculateChanges(e.permissions,a)}async calculatePermissionsChangesForCreate(e,t){let r=null;if(e.folderParentId){if(!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");const s=new ha([e.permission]),i=t.permissions.cloneForAco(da.ACO_FOLDER,e.id);r=kd.calculateChanges(s,i)}return r}async create(e){const t=await this.folderService.create(e.toDto(),{permission:!0}),r=new go(t);return await vd.addFolder(r),r}async move(e,t){const r=await vd.getFolderById(e),s=new go(r);return s.folderParentId=t,await this.moveService.move(s),await vd.updateFolder(s),s}async update(e){const t=await this.folderService.update(e.id,e.toDto(),{permission:!0}),r=new go(t);return await vd.updateFolder(r),r}async share(e,t,r){return await this.shareService.shareFolder(e.id,{permissions:t.toDto()}),(void 0===r||r)&&await this.findAndUpdateFoldersLocalStorageService.findAndUpdateAll(),e}async delete(e,t){await this.folderService.delete(e,t),await vd.delete(e),t&&await this.findAndUpdateFoldersLocalStorageService.findAndUpdateAll()}async bulkCreate(e,t){let r=[];const s=en(e.folders,5);for(const e in s){const i=s[e].map((async(r,s)=>{const i=5*e+s;return this._bulkCreate_createFolder(r,i,t)})),a=(await Promise.allSettled(i)).map((e=>e.value));r=[...r,...a]}const i=r.filter((e=>e instanceof go));return await vd.addFolders(i),r}async _bulkCreate_createFolder(e,t,r){const s=(r=r||{}).successCallback||(()=>{}),i=r.errorCallback||(()=>{});try{const r=await this.folderService.create(e.toDto(),{permission:!0}),i=new go(r);return s(i,t),i}catch(e){throw console.error(e),i(e,t),e}}async assertFolderExists(e){if(null===e)return;he(e,"Folder exists check expect a uuid.");if(!await vd.getFolderById(e))throw new Error(`Folder with id ${e} does not exist.`)}};const Dd=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.folderModel=new Ud(r,s),this.progressService=new pc(this.worker,ue.t("Creating folder..."))}async main(e){const t=e.folderParentId?3:1;try{const r=`Creating folder ${e.name}`;this.progressService.start(t,r);const s=await this.folderModel.create(e);if(s.folderParentId){await this.progressService.finishStep(ue.t("Fetching parent permissions"),!0);const e=await this.folderModel.findForShare(s.folderParentId);await this.progressService.finishStep(ue.t("Saving permissions..."),!0);const t=await this.folderModel.calculatePermissionsChangesForCreate(s,e);t&&await this.folderModel.share(s,t)}return await this.progressService.finishStep(ue.t("Done!"),!0),await this.progressService.close(),s}catch(e){throw console.error(e),await this.progressService.close(),e}}};const Md=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.findAndUpdateFoldersLocalStorageService=new Nd(s,r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.findAndUpdateFoldersLocalStorageService.findAndUpdateAll({updatePeriodThreshold:1e4})}};const Ld=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.findFolderService=new xd(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return he(e),this.findFolderService.findByIdWithCreatorAndModifier(e)}};class Fd{constructor(e,t){this.account=e,this.findAndUpdateFoldersLocalStorage=new Nd(e,t)}async getOrFindAll(){const e=vd.hasCachedData(),t=await vd.get();return t?new mo(t,{validate:!e}):this.findAndUpdateFoldersLocalStorage.findAndUpdateAll()}async getOrFindById(e){he(e);return(await this.getOrFindAll()).getById(e)}}const qd=class{constructor(e,t){this.getOrFindMetadataSettingsService=new Au(t,e),this.getOrFindMetadataKeysService=new yn(t,e),this.resourceTypesModel=new Qo(e),this.account=t}async encryptOneForForeignModel(e,t=null){if(Ee(e,[no,go],"The given data type is not a ResourceEntity or a FolderEntity"),!e.isMetadataDecrypted())throw new Error("Unable to encrypt the entity metadata, metadata is already encrypted.");t=t||await this.getPassphraseFromLocalStorageOrFail();const r=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t),s=JSON.stringify(e.metadata.toDto());let i;if(e.isPersonal()&&await this.allowUsageOfPersonalKeys()){const t=await Je(this.account.userPublicArmoredKey);i=await Rs.encrypt(s,t,[r]),e._props.metadata_key_id=null,e.metadataKeyType=no.METADATA_KEY_TYPE_USER_KEY}else{const{metadataKeyId:t,metadataPublicKey:a,metadataPrivateKey:o}=await this.getLatestMetadataKeysAndId();i=await Rs.encrypt(s,a,[r,o]),e.metadataKeyId=t,e.metadataKeyType=no.METADATA_KEY_TYPE_METADATA_KEY}e.metadata=i}async encryptAllFromForeignModels(e,t=null){if(Ee(e,[po,mo],"The given data type is not a ResourcesCollection or a FoldersCollection"),e.items.some((e=>!e.isMetadataDecrypted())))throw new Error("Unable to encrypt the collection metadata, a resource metadata is already encrypted.");const r=await this.resourceTypesModel.getOrFindAll();if(r.filterByResourceTypeVersion(wa),!e.items.some((e=>Boolean(r.getFirstById(e.resourceTypeId)))))return;const s=await this.allowUsageOfPersonalKeys();t=t||await this.getPassphraseFromLocalStorageOrFail();const i=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t);s&&await this.encryptAllFromForeignModelsWithUserKey(e,r,i),await this.encryptAllFromForeignModelsWithSharedKey(e,r,i)}async encryptAllFromForeignModelsWithSharedKey(e,t,r){const{metadataKeyId:s,metadataPublicKey:i,metadataPrivateKey:a}=await this.getLatestMetadataKeysAndId();for(const o of e){if(!t.getFirstById(o.resourceTypeId))return;if(!o.isMetadataDecrypted())continue;const e=JSON.stringify(o.metadata.toDto()),n=await Rs.encrypt(e,i,[r,a]);o.metadataKeyId=s,o.metadataKeyType=no.METADATA_KEY_TYPE_METADATA_KEY,o.metadata=n}}async encryptAllFromForeignModelsWithUserKey(e,t,r){const s=await Je(this.account.userPublicArmoredKey);for(const i of e){if(!i.isPersonal())continue;if(!t.getFirstById(i.resourceTypeId))return;const e=JSON.stringify(i.metadata.toDto()),a=await Rs.encrypt(e,s,[r]);i._props.metadata_key_id=null,i.metadataKeyType=no.METADATA_KEY_TYPE_USER_KEY,i.metadata=a}}async getLatestMetadataKeysAndId(){const e=(await this.getOrFindMetadataKeysService.getOrFindAll()).getFirstByLatestCreated();if(null===e)throw new Error("Unable to encrypt the entity metadata, no metadata key found.");const t=e.metadataPrivateKeys?.items[0];if(!t?.isDecrypted)throw new Error("Unable to encrypt the entity metadata, metadata private key is not decrypted.");const r=await Je(e.armoredKey),s=await Je(t.data.armoredKey);return{metadataKeyId:e.id,metadataPublicKey:r,metadataPrivateKey:s}}async getPassphraseFromLocalStorageOrFail(){const e=await Wi.get();if(!e)throw new $i;return e}async allowUsageOfPersonalKeys(){return(await this.getOrFindMetadataSettingsService.getOrFindKeysSettings()).allowUsageOfPersonalKeys}};const Kd=class extends $t{static getSchema(){return{type:"object",required:["user_id","resource_id"],properties:{user_id:{type:"string",format:"uuid"},resource_id:{type:"string",format:"uuid"}}}}get userId(){return this._props.user_id}get resourceId(){return this._props.resource_id}};const Bd=class extends Xt{get entityClass(){return Kd}static getSchema(){return{type:"array",items:Kd.getSchema()}}};const jd=class extends Xt{get entityClass(){return Ga}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:Ga.getSchema()}}validateBuildRules(e,t){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertUniqueResourceIdUserId(e,{haystackSet:t?.uniqueResourceIdUserIdSetCache})}assertUniqueResourceIdUserId(e,t){if(!e.userId||!e.resourceId)return;let r=t?.haystackSet;r||(r=new Set(this.items.map((e=>`${e.resourceId}:${e.userId}`))));const s=`${e.resourceId}:${e.userId}`;if(r.has(s)){const e=new R,t=`The collection already includes an element that has a couple resource_id:user_id (${s}) with an identical value.`;throw e.addError("resource_id:user_id","unique",t),e}}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.items.map((e=>`${e.id}:${e.userId}`)));r={onItemPushed:e=>{s.add(e.id),i.add(`${e.resourceId}:${e.userId}`)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueResourceIdUserIdSetCache:i},...r},super.pushMany(e,t,r)}};const zd=class{constructor(e,t,r){this.account=t,this.progressService=r,this.shareService=new Od(e),this.findResourcesService=new Mn(t,e),this.findAndUpdateResourcesLocalStorage=new Fn(t,e),this.resourceTypeModel=new Qo(e),this.resourceService=new Go(e),this.encryptMetadataService=new qd(e,t),this.getOrFindResourcesService=new qn(t,e)}async shareAll(e,t,r){Ae(e,'The parameter "resourcesIds" should be an array'),Te(e,'The parameter "resourcesIds" should be a non empty array'),Ie(e,'The parameter "resourcesIds" should contain only uuid'),be(t,kd,'The parameter "permissionChanges" should be of type PermissionChangesCollection'),ve(r,'The parameter "passphrase" should be a string'),Se(r,'The parameter "passphrase" should not be empty');const s=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,r);await this.updatePersonalMetadataToSharedMetadata(e,t,r);const i=await this.simulateShare(t),a=await this.encryptSecrets(i,s);await this.saveChanges(t,a),this.progressService.finishStep(ue.t("Updating resources local storage"),!0),await this.findAndUpdateResourcesLocalStorage.findAndUpdateAll()}async updatePersonalMetadataToSharedMetadata(e,t,r){this.progressService.finishStep(ue.t("Updating resources metadata"),!0);const s=await this.getOrFindResourcesService.getOrFindByIds(e),i=await this.resourceTypeModel.getOrFindAll(),a=t.items.filter((e=>!e.isDeleted)).map((e=>e.acoForeignKey));if(i.filterByResourceTypeVersion(wa),s.filterByResourceTypes(i),s.filterOutMetadataNotEncryptedWithUserKey(),s.filterByPropertyValueIn("id",a),!s.length)return;for(const e of s)e.personal=!1;await this.encryptMetadataService.encryptAllFromForeignModels(s,r);const o=new Xo;let n=0;const c=e=>(this.progressService.updateStepMessage(ue.t("Updating resources metadata {{counter}}/{{total}}",{counter:++n,total:s.length})),this.resourceService.update(e.id,e.toDto(),Vo.DEFAULT_CONTAIN)),l=s.items.map((e=>()=>c(e)));await o.execute(l,5)}async simulateShare(e){this.progressService.finishStep(ue.t("Calculating secrets"),!0);const t=new Xo,r=[],s=[...new Set(e.extract("aco_foreign_key"))];let i=0;const a=async t=>{this.progressService.updateStepMessage(ue.t("Calculating secrets {{counter}}/{{total}}",{counter:++i,total:s.length}));const a=e.items.filter((e=>e.acoForeignKey===t)),o=await this.shareService.simulateShareResource(t,a);o.changes.added?.forEach((e=>r.push({resource_id:t,user_id:e.User.id})))},o=s.map((e=>()=>a(e)));return await t.execute(o,5),new Bd(r)}async encryptSecrets(e,t){if(!e.length)return new jd([]);const r=[],s=await this.retrieveAndDecryptNeededSecrets(e,t),i=await this.retrieveAndReadUserPublicKeys(e);let a=0;this.progressService.finishStep(ue.t("Encrypting secrets"),!0);for(const o of e){this.progressService.updateStepMessage(`Encrypting secrets ${++a}/${e.length}`);const n=await Rs.encrypt(s[o.resourceId],i[o.userId],[t]);r.push({...o.toDto(),data:n})}return new jd(r)}async retrieveAndDecryptNeededSecrets(e,t){this.progressService.finishStep(ue.t("Retrieving secrets"),!0);const r=[],s=[...new Set(e.extract("resource_id"))],i=await this.findResourcesService.findAllByIdsForShare(s);this.progressService.finishStep(ue.t("Decrypting secrets"),!0);let a=0;for(const e of i){this.progressService.updateStepMessage(ue.t("Decrypting secrets {{counter}}/{{total}}",{counter:++a,total:i.length}));const s=await Ge(e.secrets.items[0].data);r[e.id]=await Mi.decrypt(s,t)}return r}async retrieveAndReadUserPublicKeys(e){const t={},r=[...new Set(e.extract("user_id"))],s=new xt;this.progressService.finishStep(ue.t("Synchronizing keyring"),!0),await s.sync();for(const e of r){const r=s.findPublic(e).armoredKey;t[e]=await Je(r)}return t}async saveChanges(e,t){this.progressService.finishStep(ue.t("Sharing resources"),!0);const r=new Xo,s=[...new Set(e.extract("aco_foreign_key"))];let i=0;const a=r=>{this.progressService.updateStepMessage(ue.t("Sharing resources {{counter}}/{{total}}",{counter:++i,total:s.length}));const a=e.items.filter((e=>e.acoForeignKey===r)),o=t.items.filter((e=>e.resourceId===r));return this.shareService.shareResource(r,{permissions:a,secrets:o})},o=s.map((e=>()=>a(e)));await r.execute(o,5)}};const $d=class{constructor(e,t,r){this.account=t,this.progressService=r,this.shareService=new Od(e),this.getOrFindFoldersService=new Fd(t,e),this.getOrFindResourcesService=new qn(t,e),this.findFoldersService=new xd(e),this.findResourcesService=new Mn(t,e),this.shareResourcesService=new zd(e,t,r),this.findAndUpdateFoldersLocalStorageService=new Nd(t,e)}async shareOneWithContent(e,t,r){he(e,'The parameter "folderId" should be a UUID'),be(t,kd,'The parameter "permissionChanges" should be of type PermissionChangesCollection'),ve(r,'The parameter "passphrase" should be a string');const s=await this.findFoldersToShareWithPermissions(e),i=await this.findResourcesToShareWithPermissions(e),a=this.calculateFoldersPermissionChanges(e,t,s),o=this.calculateResourcesPermissionChanges(e,t,s,i);await this.saveFoldersPermissionsChanges(a),o.length&&await this.shareResourcesService.shareAll(i.ids,o,r),this.progressService.finishStep(ue.t("Updating folders local storage"),!0),await this.findAndUpdateFoldersLocalStorageService.findAndUpdateAll()}async findFoldersToShareWithPermissions(e){this.progressService.finishStep(ue.t("Retrieving folders permissions"),!0);const t=await this.getOrFindFoldersService.getOrFindAll(),r=[e,...mo.getAllChildren(e,t,new mo([])).filterByIsOwner().ids];return this.findFoldersService.findAllByIdsWithPermissions(r)}async findResourcesToShareWithPermissions(e){this.progressService.finishStep(ue.t("Retrieving resources permissions"),!0);const t=await this.getOrFindFoldersService.getOrFindAll(),r=mo.getAllChildren(e,t,new mo([])),s=await this.getOrFindResourcesService.getOrFindAll();s.filterByPropertyValueIn("folder_parent_id",[e,...r.ids]);const i=[...s.filterByIsOwner().ids];return i?.length?this.findResourcesService.findAllByIdsWithPermissions(i):new po([])}calculateFoldersPermissionChanges(e,t,r){this.progressService.finishStep(ue.t("Calculating folders permissions changes"),!0);const s=new kd([]),i=r.getById(e).permissions;s.merge(t);for(const a of r.items)a.id!==e&&s.merge(kd.reuseChanges(a.permission.aco,a.id,a.permissions,t,i));return s}calculateResourcesPermissionChanges(e,t,r,s){this.progressService.finishStep(ue.t("Calculating resources permissions changes"),!0);const i=new kd([]),a=r.getById(e).permissions;for(const e of s.items)i.merge(kd.reuseChanges(e.permission.aco,e.id,e.permissions,t,a));return i}async saveFoldersPermissionsChanges(e){be(e,kd,'The parameter "permissionChanges" should be of type PermissionChangesCollection'),this.progressService.finishStep(ue.t("Sharing folders"),!0);const t=[...new Set(e.extract("aco_foreign_key"))];let r=0;for(const s of t){this.progressService.updateStepMessage(ue.t("Sharing folders {{counter}}/{{total}}",{counter:++r,total:t.length}));const i=e.items.filter((e=>e.acoForeignKey===s));await this.shareService.shareFolder(s,{permissions:i})}}},Vd={type:"object",required:["password"],properties:{password:Ra.secret}};class Yd extends $t{static createFromLegacyPlaintextSecret(e){return new Yd({password:e},{schema:Vd})}static getSchema(){throw new TypeError("Plaintext only support dynamic schemas, defined from resource type.")}get password(){return this._props.password||null}get description(){return this._props.description||null}get totp(){return this._props.totp||null}}const Gd=Yd;const Wd=class{constructor(e){this.resourceService=new Go(e),this.resourceTypeModel=new Qo(e)}async getAllByParentIds(e){const t=await Vo.get(),r=new po([]);for(const s in t){const i=t[s];e.includes(i.folder_parent_id)&&r.push(i)}return r}async getAllByIds(e){const t=(await Vo.get()).filter((t=>e.includes(t.id)));return new po(t)}async getById(e){const t=await Vo.getResourceById(e);return new no(t)}calculatePermissionsChangesForMove(e,t,r){let s=new ha([],{assertAtLeastOneOwner:!1});if(null!==t){if(!e.permissions||!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires permissions to be set.");s=ha.diff(e.permissions,t.permissions,!1)}let i=new ha([],{assertAtLeastOneOwner:!1});if(r){if(!r.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");i=r.permissions.cloneForAco(da.ACO_RESOURCE,e.id,!1)}const a=ha.sum(s,i,!1);return r||a.addOrReplace(new da({aco:da.ACO_RESOURCE,aro:e.permission.aro,aco_foreign_key:e.id,aro_foreign_key:e.permission.aroForeignKey,type:da.PERMISSION_OWNER})),a.assertAtLeastOneOwner(),kd.calculateChanges(e.permissions,a)}async calculatePermissionsChangesForCreate(e,t){let r=null;if(t){if(!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");const s=new ha([e.permission]),i=t.permissions.cloneForAco(da.ACO_RESOURCE,e.id);r=kd.calculateChanges(s,i)}return r}async findAll(e,t,r,s){let i=await this.resourceService.findAll(e,t,r);return i=await this.keepResourcesSupported(i),new po(i,{clone:!1,ignoreInvalidEntity:s})}async updateCollection(e){await Vo.updateResourcesCollection(e)}async delete(e){await this.resourceService.delete(e),await Vo.delete(e)}async bulkCreate(e,t){let r=[];const s=en(e.resources,5);for(const e in s){const i=s[e].map((async(r,s)=>{const i=5*e+s;return this._bulkCreate_createResource(r,i,t)})),a=(await Promise.allSettled(i)).map((e=>e.value));r=[...r,...a]}const i=r.filter((e=>e instanceof no));return await Vo.addResources(i),r}async _bulkCreate_createResource(e,t,r){const s=(r=r||{}).successCallback||(()=>{}),i=r.errorCallback||(()=>{});try{const r=e.toV4Dto({secrets:!0}),i={permission:!0,favorite:!0,tags:!0,folder:!0},a=await this.resourceService.create(r,i),o=new no(a);return s(o,t),o}catch(e){throw console.error(e),i(e,t),e}}async bulkDelete(e,t){let r=[];const s=en(e,5);for(const e in s){const i=s[e].map((async(r,s)=>{const i=5*e+s;return this._bulkDelete_deleteResource(r,i,t)})),a=(await Promise.allSettled(i)).map((e=>e.value));r=[...r,...a]}return r}async _bulkDelete_deleteResource(e,t,r){const s=(r=r||{}).successCallback||(()=>{}),i=r.errorCallback||(()=>{});try{await this.delete(e),s(t)}catch(e){throw console.error(e),i(e,t),e}}async serializePlaintextDto(e,t){if(!e||"string"==typeof t){if(t.length>4096)throw new TypeError("The secret should be maximum 4096 characters in length.");return t}const r=await this.resourceTypeModel.getSecretSchemaById(e);if(!r)throw new TypeError("Could not find the schema definition for the requested resource type.");const s=new Gd(t,{schema:r});return JSON.stringify(s)}async replaceTagLocally(e,t){const r=await Vo.get(),s=new po(r);return!!s.replaceTag(e,t)&&(await Vo.set(s),!0)}async replaceResourceTagsLocally(e,t){const r=await Vo.getResourceById(e),s=new no(r);return s.tags=t,await Vo.updateResource(s),s}async bulkReplaceResourceTagsLocally(e,t){const r=await Vo.get(),s=new po(r);await s.bulkReplaceTagsCollection(e,t),await Vo.set(s)}async deleteTagsLocally(e){const t=await Vo.get(),r=new po(t);return!!r.removeTagById(e)&&(await Vo.set(r),!0)}async updateFavoriteLocally(e,t){const r=await Vo.getResourceById(e),s=new no(r);s.favorite=t,await Vo.updateResource(s)}async assertResourcesExist(e){const t=await Vo.get();if(!Array.isArray(e))throw new TypeError("Resources exist check expect an array of uuid.");for(const r in e)if(!t.find((t=>t.id===e[r])))throw new Error(`Resource with id ${e[r]} does not exist.`)}};const Hd=class{constructor(e){this.worker=e}async confirm(e,t){return"keep"!==(await this.worker.port.request("passbolt.folders.move-strategy.request",e,[t],[],[])).moveOption}};const Jd=class{constructor(e,t,r){this.account=t,this.progressService=r,this.shareResourceService=new zd(e,t,this.progressService),this.shareFolderService=new $d(e,t,this.progressService),this.getOrFindFoldersService=new Fd(t,e),this.getOrFindResourcesService=new qn(t,e),this.findFoldersService=new xd(e),this.findResourcesService=new Mn(t,e),this.folderModel=new Ud(e,t),this.resourceModel=new Wd(e),this.findAndUpdateFoldersLocalStorage=new Nd(t,e)}async moveOne(e,t,r,s){if(he(e,'The parameter "folderId" should be a UUID'),null!==t&&he(t,'The parameter "destinationFolderId" should be a UUID'),e===t)throw new Error(ue.t("The folder cannot be moved inside itself."));be(r,Hd,'The parameter "moveStrategyService" should be MoveStrategy service instance.'),s&&ve(s,'The parameter "passphrase" should be a string');const i=await this.getOrFindFoldersService.getOrFindById(e),a=await this.findFoldersToShareWithPermissions(i),o=i.folderParentId?await this.findFoldersService.findByIdWithPermissions(i.folderParentId):null,n=t?await this.findFoldersService.findByIdWithPermissions(t):null,c=await this.findResourcesToShareWithPermissions(e);this.assertFolderCanBeMoved(i,n,o);if(this.checkCouldOverridePermissions(i,n,o)){const e=this.calculateFoldersPermissionChanges(i,a,n,o),t=this.calculateResourcesPermissionsChanges(c,n,o);await this.confirmShareOperation(i,n,r,e,t)?(await this.shareResources(t,s),await this.shareFolders(e)):this.progressService.finishSteps(9)}else this.progressService.finishSteps(12);await this.move(i,t),this.progressService.finishStep(ue.t("Updating folders local storage"),!0),await this.findAndUpdateFoldersLocalStorage.findAndUpdateAll()}async findFoldersToShareWithPermissions(e){this.progressService.finishStep(ue.t("Retrieving folders permissions"),!0);const t=await this.getOrFindFoldersService.getOrFindAll(),r=mo.getAllChildren(e.id,t,new mo([])).filterByIsOwner().ids;return e.isOwner()&&r.unshift(e.id),r.length?this.findFoldersService.findAllByIdsWithPermissions(r):new mo}async findResourcesToShareWithPermissions(e){this.progressService.finishStep(ue.t("Retrieving resources permissions"),!0);const t=await this.getOrFindFoldersService.getOrFindAll(),r=mo.getAllChildren(e,t,new mo([])),s=await this.getOrFindResourcesService.getOrFindAll();s.filterByPropertyValueIn("folder_parent_id",[e,...r.ids]);const i=[...s.filterByIsOwner().ids];return i?.length?this.findResourcesService.findAllByIdsWithPermissions(i):new po([])}assertFolderCanBeMoved(e,t,r){if(null===t&&null===r){const t=ue.t("Folder {{name}} is already in the root folder.",{name:e.name});throw new Error(t)}if(t&&e.folderParentId===t.id){const r=ue.t("Folder {{name}} is already in folder {{destination}}.",{name:e.name,destination:t.name});throw new Error(r)}if(!go.canFolderMove(e,r,t)){const t=ue.t("Folder {{name}} can not be moved.",{name:e.name});throw new Error(t)}}checkCouldOverridePermissions(e,t,r){const s=null===t||t.isPersonal(),i=null===r||r.isPersonal();return!(e.isShared()&&s&&i)}calculateFoldersPermissionChanges(e,t,r,s){this.progressService.finishStep(ue.t("Calculating folders permissions changes"),!0);const i=null===r||r.isPersonal(),a=null===s||s.isPersonal();if(e.isShared()&&i&&a)return new kd([]);const o=new kd([]);for(const e of t){const t=this.folderModel.calculatePermissionsChangesForMove(e,s,r);o.merge(t)}return o}calculateResourcesPermissionsChanges(e,t,r){this.progressService.finishStep(ue.t("Calculating resources permissions changes"),!0);const s=new kd([]);for(const i of e){const e=this.resourceModel.calculatePermissionsChangesForMove(i,r,t);s.merge(e)}return s}async confirmShareOperation(e,t,r,s,i){return this.progressService.finishStep(ue.t("Confirming share operation"),!0),!(!s.length&&!i.length)&&await r.confirm(t?.id,e.id)}async shareResources(e,t){const r=new Set;e.items.forEach((e=>r.add(e.acoForeignKey))),r.size?await this.shareResourceService.shareAll([...r],e,t):this.progressService.finishSteps(8)}async shareFolders(e){e.length?await this.shareFolderService.saveFoldersPermissionsChanges(e):this.progressService.finishSteps(1)}async move(e,t){this.progressService.finishStep(ue.t("Moving folder"),!0),await this.folderModel.move(e.id,t)}};const Zd=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.progressService=new pc(this.worker),this.getPassphraseService=new oc(s),this.moveOneFolderService=new Jd(r,s,this.progressService),this.confirmMoveStrategyService=new Hd(e),this.folderModel=new Ud(r,s)}async _exec(e,t){try{await this.exec(e,t),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t=null){if(he(e,'The parameter "folderId" should be a UUID'),null!==t&&he(t,'The parameter "destinationFolderId" should be a UUID'),e===t)throw new Error(ue.t("The folder cannot be moved inside itself."));const r=await this.getPassphraseService.getPassphrase(this.worker);this.progressService.start(16,ue.t("Initialize"));try{await this.moveOneFolderService.moveOne(e,t,this.confirmMoveStrategyService,r),this.progressService.finishStep(ue.t("Done!"),!0)}finally{this.progressService.close()}}},Qd={listen:function(e,t,r){e.port.on("passbolt.folders.create",(async(s,i)=>{try{const a=new Dd(e,s,t,r),o=await a.main(new go(i));e.port.emit(s,"SUCCESS",o)}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.folders.update",(async(s,i)=>{try{const a=new Ud(t,r),o=await a.update(new go(i));e.port.emit(s,"SUCCESS",o)}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.folders.delete",(async(s,i,a)=>{try{const o=new Ud(t,r),n=new Fn(r,t);await o.delete(i,a),await n.findAndUpdateAll(),e.port.emit(s,"SUCCESS",i)}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.folders.update-local-storage",(async s=>{const i=new Md(e,s,t,r);await i._exec()})),e.port.on("passbolt.folders.find-details",(async(r,s)=>{const i=new Ld(e,r,t);await i._exec(s)})),e.port.on("passbolt.folders.move-by-id",(async(s,i,a)=>{const o=new Zd(e,s,t,r);await o.exec(i,a)}))}};const Xd=class extends $t{marshall(){Object.prototype.hasOwnProperty.call(this._props,"user_count")&&"string"==typeof this._props.user_count&&(this._props.user_count=parseInt(this._props.user_count,10)),super.marshall()}static getSchema(){const e=lr.getSchema(),t=ca.getSchema();return{type:"object",required:["id"],properties:{id:{type:"string",format:"uuid"},username:e.properties.username,profile:e.properties.profile,name:t.properties.name,user_count:{type:"integer"}}}}static get ENTITY_NAME(){return"UserAndGroupSearchResult"}};const ep=class extends Xt{get entityClass(){return Xd}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:Xd.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache})}pushMany(e,t={},r={}){const s=new Set(this.extract("id"));r={onItemPushed:e=>{s.add(e.id)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s},...r},super.pushMany(e,t,r)}static get ENTITY_NAME(){return"UserAndGroupSearchResult"}};const tp=class{constructor(e){this.shareService=new Od(e)}async bulkShareResources(e,t,r,s){const i=this.bulkShareAggregateChanges(e,t),a=await this.bulkShareSimulate(e,i,s),o=await this.bulkShareEncrypt(e,a,r,s);for(const t in i)if(Object.prototype.hasOwnProperty.call(i,t)){const r=e.find((e=>e.id===t)),a=i[t],n=o[t]||[];s(`Sharing password ${r.metadata.name}`),await this.shareService.shareResource(t,{permissions:a,secrets:n})}}async bulkShareFolders(e,t,r){for(const s of e){const e=t.filterByAcoForeignKey(s.id);e&&e.length&&(await r(`Updating folder ${s.name} permissions`),await this.shareService.shareFolder(s.id,{permissions:e.toDto()}))}}bulkShareAggregateChanges(e,t){if(!e||!Array.isArray(e)||!e.length)throw new TypeError("bulkShareAggregateChanges expect an array of ACOs");if(!t||!Array.isArray(t)||!t.length)throw new TypeError("bulkShareAggregateChanges expect an array of changes");const r={};return e.forEach((e=>{const s=t.filter((t=>t.aco_foreign_key===e.id));s.length&&(r[e.id]=s)})),r}async bulkShareSimulate(e,t,r){const s={};for(const i in t){r(`Validating share operation for ${e.find((e=>e.id===i)).metadata.name}`);const a=(await this.shareService.simulateShareResource(i,t[i])).changes.added;a.length&&(s[i]=a.reduce(((e,t)=>[...e,t.User.id]),[]))}return s}async bulkShareEncrypt(e,t,r,s){const i=new xt,a={};for(const o in t){const n=e.find((e=>e.id===o)),c=await Ge(n.secrets[0].data),l=t[o];if(s(`Encrypting for ${n.metadata.name}`),l&&l.length){const e=await Mi.decrypt(c,r),t=l.reduce(((t,r)=>[...t,{userId:r,message:e}]),[]),s=[];for(const e in t){const a=t[e],n=i.findPublic(a.userId).armoredKey,c=await Je(n),l=await Rs.encrypt(a.message,c,[r]);s.push({resource_id:o,user_id:a.userId,data:l})}a[o]=s}}return a}async search(e){ve(e,"keyword is not a valid string");const t=await this.shareService.searchUsersAndGroups(e,{profile:!0,user_count:!0});return new ep(t)}};const rp=class{constructor(e,t,r){this.account=e,this.resourceService=new Go(t),this.resourceTypeModel=new Qo(t),this.folderModel=new Ud(t,e),this.shareModel=new tp(t),this.keyring=new xt,this.progressService=r,this.resourceModel=new Wd(t,this.account),this.encryptMetadataKeysService=new qd(t,this.account),this.findAndUpdateResourcesLocalStorage=new Fn(e,t)}async create(e,t,r){const s=new no(e),i=(await this.resourceTypeModel.getOrFindAll()).getFirstById(s.resourceTypeId),a=s.metadata,o=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,r);let n,c=new kd([]);s.folderParentId&&(n=await this.folderModel.findForShare(s.folderParentId),(n.permissions.length>1||n.permissions.items[0].aroForeignKey!==this.account.userId)&&(c=n.permissions)),this.updateGoals(i.isV5(),c.length),await this.encryptMetadata(s,i,c,r),await this.buildAndEncryptUserSecret(s,t,o);const l=await this.save(s,i);return i.isV5()&&(l.metadata=a),await Vo.addResource(l),await this.share(l,o,n,c),l}async save(e,t){await this.progressService.finishStep(ue.t("Creating password"),!0);const r=t.isV5()?e.toDto({secrets:!0}):e.toV4Dto({secrets:!0}),s=await this.resourceService.create(r,{permission:!0,favorite:!0,tags:!0,folder:!0});return new no(s)}async buildAndEncryptUserSecret(e,t,r){const s=await this.resourceModel.serializePlaintextDto(e.resourceTypeId,t);await this.progressService.finishStep(ue.t("Encrypting secret"),!0);const i=await Je(this.account.userPublicArmoredKey),a=await Rs.encrypt(s,i,[r]);e.secrets=new Ha([{data:a}])}async share(e,t,r,s){if(!r||!s.length)return;await this.progressService.finishStep(ue.t("Calculate permissions"),!0);const i=await this.resourceModel.calculatePermissionsChangesForCreate(e,r);await(this.progressService?.finishStep(ue.t("Synchronizing keys"),!0)),await this.keyring.sync(),await(this.progressService?.finishStep(ue.t("Start sharing"),!0));const a=[e.toDto({secrets:!0})];await this.shareModel.bulkShareResources(a,i.toDto(),t,(async e=>await(this.progressService?.finishStep(e)))),await this.findAndUpdateResourcesLocalStorage.findAndUpdateAll()}async encryptMetadata(e,t,r,s){t.isV5()&&(await this.progressService.finishStep(ue.t("Encrypting Metadata"),!0),e.personal=!r.length,await this.encryptMetadataKeysService.encryptOneForForeignModel(e,s))}updateGoals(e,t=0){const r=e?4:3,s=t>0?3:0;this.progressService.updateGoals(3*t+s+r)}};const sp=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.progressService=new pc(this.worker,ue.t("Creating password")),this.resourceCreateService=new rp(s,r,this.progressService),this.getPassphraseService=new oc(s)}async _exec(e,t){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){try{const r=e.folder_parent_id?10:3,s=await this.getPassphraseService.getPassphrase(this.worker);this.progressService.start(r,ue.t("Initializing"));const i=await this.resourceCreateService.create(e,t,s);return await this.progressService.finishStep(ue.t("Done!"),!0),i}finally{await this.progressService.close()}}};const ip=class{constructor(e,t,r){this.account=e,this.resourceService=new Go(t),this.resourceTypeModel=new Qo(t),this.progressService=r,this.resourceModel=new Wd(t),this.encryptMetadataKeysService=new qd(t,this.account),this.userModel=new To(t),this.keyring=new xt}async exec(e,t,r){const s=new no(e),i=(await this.resourceTypeModel.getOrFindAll()).getFirstById(s.resourceTypeId),a=await this.userModel.findAllIdsForResourceUpdate(s.id);s.personal=1===a.length;const o=this.calculateGoals(t,i,a.length);this.progressService.updateGoals(o);const n=s.metadata;return i.isV5()&&(await this.progressService.finishStep(ue.t("Encrypting Metadata"),!0),await this.encryptMetadataKeysService.encryptOneForForeignModel(s,r)),null!==t&&await this.updateSecret(s,t,r,a),this.update(s,i,n)}async updateSecret(e,t,r,s){const i=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,r);await this.progressService.finishStep(ue.t("Synchronizing keyring"),!0),await this.keyring.sync();const a=await this.resourceModel.serializePlaintextDto(e.resourceTypeId,t);e.secrets=await this.encryptSecrets(a,s,i)}async update(e,t,r){await this.progressService.finishStep(ue.t("Saving resource"),!0);const s=t.isV5()?e.toDto({secrets:!0}):e.toV4Dto({secrets:!0}),i=await this.resourceService.update(e.id,s,Vo.DEFAULT_CONTAIN),a=new no(i);return a.isMetadataDecrypted()||(a.metadata=r),await Vo.updateResource(a),a}async encryptSecrets(e,t,r){const s=[];for(let i=0;i<t.length;i++)if(Object.prototype.hasOwnProperty.call(t,i)){const a=t[i],o=this.keyring.findPublic(a).armoredKey,n=await Je(o),c=await Rs.encrypt(e,n,[r]);s.push({user_id:a,data:c}),await this.progressService.finishStep(ue.t("Encrypting Secret"),!0)}return new Ha(s)}calculateGoals(e,t,r){return t.isV5()?null===e?3:r+4:t.isV4()?null===e?2:r+3:void 0}};const ap=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.userModel=new To(r),this.keyring=new xt,this.progressService=new pc(this.worker,ue.t("Updating password")),this.getPassphraseService=new oc(s),this.resourceUpdateService=new ip(s,r,this.progressService)}async _exec(e,t){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){try{const r=await this.getPassphraseService.getPassphrase(this.worker);this.progressService.start(1,ue.t("Updating resource"));const s=await this.resourceUpdateService.exec(e,t,r);return await this.progressService.finishStep(ue.t("Done!"),!0),s}finally{await this.progressService.close()}}};class op extends T{constructor(e,t={}){super(U.validate(op.ENTITY_NAME,e,op.getSchema()),t)}static getSchema(){return{type:"object",required:["id","label"],properties:{id:{type:"string",pattern:/^[a-zA-Z]+$/,maxLength:255},label:{type:"string",pattern:/^[a-zA-Z]+$/,maxLength:255},width:{type:"number"},position:{type:"integer"},show:{type:"boolean"}}}}get id(){return this._props.id}get label(){return this._props.label}get width(){return this._props.width}get position(){return this._props.position}get show(){return this._props.show}static get ENTITY_NAME(){return"ColumnSetting"}}const np=op;class cp extends Ft{constructor(e,t={}){super(U.validate(cp.ENTITY_NAME,e,cp.getSchema()),t),this._props.forEach((e=>{this.push(e)})),this._props=null}static getSchema(){return{type:"array",items:np.getSchema()}}push(e){if(!e||"object"!=typeof e)throw new TypeError("ColumnsSettingCollection push parameter should be an object.");e instanceof np&&(e=e.toDto());const t=new np(e);this.assertUniqueId(t),super.push(t)}removeById(e){this._items=this.items.filter((t=>t.id!==e))}toHashTable(){return this.items.reduce(((e,t)=>(e[t.id]=t.toDto(),e)),{})}deepMerge(e){const t=e.toDto().reduce(((e,t)=>{const r=e.findIndex((e=>e.id===t.id));return r>-1?(e[r]=Object.assign(e[r],t),e):[...e,t]}),this.toDto());return new this.constructor(t)}updateColumnShowValueFromDefault(e,t){const r=t=>t.id===e,s=this.constructor.DEFAULT.items.find(r).toDto();s.show=t;const i=this.items.findIndex(r);this.items[i]=new np(s)}hasDifferentShowValue(e){return!e||this.items.some(((t,r)=>t?.show!==e.items[r]?.show))}assertUniqueId(e){this.items.forEach(((t,r)=>{if(t.id&&t.id===e.id)throw new Mt(r,cp.RULE_UNIQUE_ID,`ColumnSetting id ${e.id} already exists.`)}))}static get ENTITY_NAME(){return"ColumnsSetting"}static get RULE_UNIQUE_ID(){return"unique_id"}static get DEFAULT(){return new cp([])}static createFromDefault(e=null){return null!==e?this.DEFAULT.deepMerge(e):this.DEFAULT}}const lp=cp;class up extends T{constructor(e,t={}){super(U.validate(up.ENTITY_NAME,e,up.getSchema()),t)}static getSchema(){return{type:"object",required:["propertyName","asc"],properties:{propertyName:{type:"string"},asc:{type:"boolean"}}}}get propertyName(){return this._props.propertyName}get asc(){return this._props.asc}static get ENTITY_NAME(){return"Sorter"}}const dp=up;class pp extends T{constructor(e,t={}){super(U.validate(pp.ENTITY_NAME,e,pp.getSchema()),t),this._props.columns_setting&&(this._columns_setting=new lp(this._props.columns_setting,{clone:!1})),delete this._props._columns_setting,this._props.sorter&&(this._sorter=new dp(this._props.sorter,{clone:!1})),delete this._props.sorter}static getSchema(){return{type:"object",required:["columns_setting","sorter"],properties:{columns_setting:lp.getSchema(),sorter:dp.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.columnsSetting&&e.columns_setting&&(t.columns_setting=this.columnsSetting.toDto()),this.sorter&&e.sorter&&(t.sorter=this.sorter.toDto()),t):t}toJSON(){return this.toDto(pp.ALL_CONTAIN_OPTIONS)}get columnsSetting(){return this._columns_setting}get sorter(){return this._sorter}static get ENTITY_NAME(){return"GridUserSetting"}static get ALL_CONTAIN_OPTIONS(){return{columns_setting:!0,sorter:!0}}}const hp=pp;var gp=r(7946);const yp=class{constructor(e){this.storageKey=this.getStorageKey(e)}getStorageKey(e){if(!e.id)throw new Error("Cannot retrieve account id, necessary to get the resource columns setting storage key.");return`resourceGridUserSetting-${e.id}`}async get(){const e=await gp.storage.local.get([this.storageKey]);if(!e||!e[this.storageKey])return null;try{return new hp(e[this.storageKey])}catch(e){return console.error(e),null}}async set(e){await navigator.locks.request(this.storageKey,(async()=>{await gp.storage.local.set({[this.storageKey]:e.toJSON()})}))}};const mp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.resourceGridUserSettingLocalStorage=new yp(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.resourceGridUserSettingLocalStorage.get()}};const wp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.resourceGridUserSettingLocalStorage=new yp(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new hp(e);await this.resourceGridUserSettingLocalStorage.set(t)}};class _p extends dt{constructor(e){super(e,_p.RESOURCE_NAME)}async update(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}static get RESOURCE_NAME(){return"password-expiry/resources"}}const fp=_p;class vp extends Ft{constructor(e,t={}){super(U.validate(vp.ENTITY_NAME,e,vp.getSchema()),t),this._props.forEach((e=>{this.push(new Ko(e,{clone:!1}))})),this._props=null}static getSchema(){return{type:"array",items:Ko.getSchema()}}get passwordExpiryResources(){return this._items}assertUniqueId(e){if(!e.id)return;const t=this.passwordExpiryResources.length;let r=0;for(;r<t;r++){const t=this.passwordExpiryResources[r];if(t.id&&t.id===e.id)throw new Mt(r,vp.RULE_UNIQUE_ID,`PasswordExpiryResource id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("PasswordExpiryResourcesCollection push parameter should be an object.");e instanceof Ko&&(e=e.toDto());const t=new Ko(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}static get ENTITY_NAME(){return"PasswordExpiryResources"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Sp=vp;const bp=class{constructor(e){this.passwordExpiryResourceService=new fp(e)}async update(e){be(e,Sp,"The given entity is not a PasswordExpiryResourceCollection");try{await this.passwordExpiryResourceService.update(e.toDto()),await Vo.updateResourcesExpiryDate(e.passwordExpiryResources)}catch(e){throw console.error(e),e}}};const Ep=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.passwordExpiryResourceModel=new bp(r),this.progressService=new pc(this.worker,ue.t("Mark as expired ..."))}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){this.progressService.start(2,ue.t("Initialize"));const t=new Sp(e);await this.progressService.finishStep(ue.t("Expiry date will be updated on {{count}} resource.",{count:e.length}),!0);try{await this.passwordExpiryResourceModel.update(t),await this.progressService.finishStep(ue.t("Done"),!0),await this.progressService.close(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){throw await this.progressService.close(),e}}};const kp=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.findResourcesService=new Mn(s,r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return he(e),this.findResourcesService.findOneByIdForDetails(e)}};const Ap=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.findAndUpdateResourcesLocalStorage=new Fn(s,r),this.getPassphraseService=new oc(s)}async _exec(e={}){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{await this.findAndUpdateResourcesLocalStorage.findAndUpdateAll({updatePeriodThreshold:1e4})}catch(e){if(!(e instanceof $i))throw e;const t=await this.getPassphraseService.getPassphrase(this.worker);await Wi.set(t,60),await this.findAndUpdateResourcesLocalStorage.findAndUpdateAll()}}};const Tp=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.findAndUpdateResourcesLocalStorage=new Fn(s,r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return he(e),(await this.findAndUpdateResourcesLocalStorage.findAndUpdateByIsSharedWithGroup(e)).extract("id")}};const Ip=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.findResourcesService=new Mn(s,r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return Ie(e),this.findResourcesService.findAllByIdsForDisplayPermissions(e)}};const Rp=class{constructor(e,t,r){this.progressService=r,this.folderModel=new Ud(e,t),this.resourceModel=new Wd(e),this.findResourcesService=new Mn(t,e),this.shareResourceService=new zd(e,t,r),this.findFoldersService=new xd(e),this.moveApiService=new Td(e)}async moveAll(e,t,r){Te(e,"Could not move, expecting at least a resource to be provided."),Ie(e,"Could not move, expecting resourcesIds to be an array of UUIDs."),t&&he(t,"Could not move, expecting destinationFolderId to be a valid UUID."),r&&ve(r);const s=await this.findDestinationFolderWithPermissions(t),i=await this.findAllResourcesWithPermissions(e),a=await this.findAllFoldersWithPermissions([...new Set(i.folderParentIds)]);this.filterOutResourcesThatWontMove(i,a,s);const o=await this.calculateChanges(i,a,s);await this.move(i,t),await this.share(i,o,r)}async findDestinationFolderWithPermissions(e){if(this.progressService.finishStep(ue.t("Retrieving destination folder permissions"),!0),!e)return null;const t=await this.findFoldersService.findByIdWithPermissions(e);if(!t)throw new Error("Could not move, the destination folder does not exist.");return t}async findAllResourcesWithPermissions(e){this.progressService.finishStep(ue.t("Retrieving resources permissions"),!0);const t=await this.findResourcesService.findAllByIdsWithPermissions(e);if(e.some((e=>!t.getFirstById(e))))throw new Error("Could not move, some resources do not exist.");return t}async findAllFoldersWithPermissions(e){return this.progressService.finishStep(ue.t("Retrieving all resources parent folders permissions"),!0),0===e.length?new mo([]):await this.findFoldersService.findAllByIdsWithPermissions(e)}filterOutResourcesThatWontMove(e,t,r){e.filterByCallback((e=>{const s=e.folderParentId?t.getById(e.folderParentId):null,i=e.canMove(s,r);return i||console.warn(`Resource "${e.id}" cannot be moved, skipping.`),i}))}async calculateChanges(e,t,r){this.progressService.finishStep(ue.t("Calculating resources permissions changes"),!0);const s=new kd([]);for(const i of e){if(this.progressService.updateStepMessage(ue.t("Calculating changes for {{name}}",{name:i.metadata.name})),!i.isOwner())break;if(i.isShared()&&(null===r||r.isPersonal())&&(null===i.folderParentId||i.isPersonal()))break;const e=i.folderParentId?t.getById(i.folderParentId):null,a=this.resourceModel.calculatePermissionsChangesForMove(i,e,r);s.merge(a)}return s}async move(e,t){if(e.filterByCallback((e=>{const r=e.folderParentId!==t;return r||console.debug(`Resource "${e.id}" is already in the destination folder, skipping.`),r})),0!==e.length){this.progressService.finishStep(ue.t("Moving resources"),!0);for(const r of e)this.progressService.updateStepMessage(ue.t("Moving {{name}}",{name:r.metadata.name})),await this.moveApiService.moveResource(r.id,t);await this.resourceModel.updateCollection(e)}else this.progressService.finishSteps(1)}async share(e,t,r){t.length?await this.shareResourceService.shareAll(e.ids,t,r):this.progressService.finishSteps(8)}};const Cp=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.progressService=new pc(this.worker),this.getPassphraseService=new oc(s),this.moveResourcesService=new Rp(r,s,this.progressService),this.getOrFindFoldersService=new Fd(s,r)}async _exec(e,t){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t=null){Ie(e,"The resourceIds should be a valid array of UUID"),null!==t&&he(t,"The destinationFolderId should be a valid UUID"),this.progressService.start(13,ue.t("Initializing ...")),this.progressService.title=ue.t("Moving {{count}} resources",{count:e.length});try{const r=await this.getPassphraseService.getPassphrase(this.worker);await this.moveResourcesService.moveAll(e,t,r)}finally{this.progressService.close()}}},Op={listen:function(e,t,r){e.port.on("passbolt.resources.update-local-storage",(async s=>{m.write({level:"debug",message:"ResourceEvent listen passbolt.resources.update-local-storage"});const i=new Ap(e,s,t,r);await i._exec()})),e.port.on("passbolt.resources.find-details",(async(s,i)=>{const a=new kp(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.resources.find-all-ids-by-is-shared-with-group",(async(s,i)=>{const a=new Tp(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.resources.create",(async(s,i,a)=>{const o=new sp(e,s,t,r);await o._exec(i,a)})),e.port.on("passbolt.resources.delete-all",(async(s,i)=>{try{const a=new Wd(t,r);await a.bulkDelete(i),e.port.emit(s,"SUCCESS")}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.resources.update",(async(s,i,a)=>{const o=new ap(e,s,t,r);await o._exec(i,a)})),e.port.on("passbolt.resources.get-grid-setting",(async t=>{const s=new mp(e,t,r);await s._exec()})),e.port.on("passbolt.resources.set-grid-setting",(async(t,s)=>{const i=new wp(e,t,r);await i._exec(s)})),e.port.on("passbolt.resources.set-expiration-date",(async(r,s)=>{const i=new Ep(e,r,t);await i._exec(s)})),e.port.on("passbolt.resources.find-all-by-ids-for-display-permissions",(async(s,i)=>{const a=new Ip(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.resources.move-by-ids",(async(s,i,a)=>{const o=new Cp(e,s,t,r);await o.exec(i,a)}))}};const xp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.resourceTypeModel=new Qo(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.resourceTypeModel.getOrFindAll()}},Pp={listen:function(e,t){e.port.on("passbolt.resource-type.get-or-find-all",(async r=>{const s=new xp(e,r,t);await s._exec()}))}};class Np extends Ft{constructor(e,t={}){super(U.validate(Np.ENTITY_NAME,e,Np.getSchema()),t),this._props.forEach((e=>{this.push(new Yt(e,{clone:!1}))})),this._props=null}static getSchema(){return{type:"array",items:Yt.getSchema()}}get roles(){return this._items}get ids(){return this._items.map((e=>e.id))}assertUniqueId(e){if(!e.id)return;const t=this.roles.length;let r=0;for(;r<t;r++){const t=this.roles[r];if(t.id&&t.id===e.id)throw new Mt(r,Np.RULE_UNIQUE_ID,`Role id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("RolesCollection push parameter should be an object.");e instanceof Yt&&(e=e.toDto());const t=new Yt(e);this.assertUniqueId(t),super.push(t)}static get ENTITY_NAME(){return"Roles"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Up=Np;var Dp=r(7946);const Mp=new k,Lp="roles";class Fp{static async flush(){return m.write({level:"debug",message:"RolesLocalStorage flushed"}),await Dp.storage.local.remove(Lp)}static async get(){const{roles:e}=await Dp.storage.local.get([Lp]);return e}static async set(e){await Mp.acquire();const t=[];if(e){if(!(e instanceof Up))throw new TypeError("RolesLocalStorage::set expects a RolesCollection");for(const r of e)Fp.assertEntityBeforeSave(r),t.push(r.toDto())}await Dp.storage.local.set({roles:t}),Mp.release()}static async getResourceById(e){return(await Fp.get()).find((t=>t.id===e))}static assertEntityBeforeSave(e){if(!e)throw new TypeError("RolesLocalStorage expects a RoleEntity to be set");if(!(e instanceof Yt))throw new TypeError("RolesLocalStorage expects an object of type RoleEntity");if(!e.id)throw new TypeError("RolesLocalStorage expects RoleEntity id to be set")}}const qp=Fp;class Kp extends dt{constructor(e){super(e,Kp.RESOURCE_NAME)}static get RESOURCE_NAME(){return"roles"}async findAll(){const e=await this.apiClient.findAll();return e.body&&e.body.length?e.body:[]}}const Bp=Kp;const jp=class{constructor(e){this.roleService=new Bp(e)}async updateLocalStorage(){const e=await this.roleService.findAll(),t=new Up(e);return await qp.set(t),t}async getOrFindAll(){const e=await qp.get();return void 0!==e?new Up(e):this.updateLocalStorage()}},zp={listen:function(e,t){e.port.on("passbolt.role.get-all",(async r=>{try{const s=new jp(t),i=await s.getOrFindAll();e.port.emit(r,"SUCCESS",i)}catch(t){e.port.emit(r,"ERROR",t)}}))}};const $p=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new xt}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){let t=this.keyring.findPublic(e);if(!t&&(await this.keyring.sync(),t=this.keyring.findPublic(e),!t))throw new Error("User key not found");const r=await Je(t.armoredKey);return Ct.getKeyInfo(r)}};const Vp=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new xt}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=this.keyring.findPrivate()?.armoredKey;if(!e)throw new Rt(ue.t("Public key can't be found."));const t=await Je(e);je(t);const r=await t.toPublic().armor();await Uc.saveFile("passbolt_public.asc",r,"text/plain",this.worker.tab.id)}};const Yp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.keyring=new xt,this.getPassphraseService=new oc(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;await this.getPassphraseService.requestPassphrase(this.worker);try{e=this.keyring.findPrivate().armoredKey}catch(e){throw new Rt(ue.t("Private key not found."))}await Uc.saveFile("passbolt_private.asc",e,"text/plain",this.worker.tab.id)}};const Gp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.keyring=new xt,this.getPassphraseService=new oc(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.getPassphraseService.requestPassphrase(this.worker);const e=(new xt).findPrivate();if(!e)throw new Rt(ue.t("Private key not found."));return e.armoredKey}},Wp={listen:function(e,t,r){e.port.on("passbolt.keyring.get-public-key-info-by-user",(async(t,r)=>{const s=new $p(e,t);await s._exec(r)})),e.port.on("passbolt.keyring.get-key-info",(async(t,r)=>{const s=new Pt(e,t);await s._exec(r)})),e.port.on("passbolt.keyring.private.checkpassphrase",(async(t,r)=>{const s=new Mu(e,t);await s._exec(r)})),e.port.on("passbolt.keyring.download-my-public-key",(async t=>{const r=new Vp(e,t);await r._exec()})),e.port.on("passbolt.keyring.download-my-private-key",(async t=>{const s=new Yp(e,t,r);await s._exec()})),e.port.on("passbolt.keyring.get-private-key",(async t=>{const s=new Gp(e,t,r);await s._exec()}))}};const Hp=class{static async getKey(e){const t=new xt,r=t.findPrivate()?.armoredKey;if(!r)throw new Error("Can't find current user's private key.");const s=await Je(r);return Fr.decrypt(s,e)}};const Jp=class{static async decryptAndParse(e,t,r){const s=await Ge(e.data),i=await Mi.decrypt(s,r);return this.parse(i,t)}static async parse(e,t){if("string"===t.type)return Gd.createFromLegacyPlaintextSecret(e);let r;try{r=JSON.parse(e)}catch(e){throw console.error(e),new Error("Unable to parse the secret.")}return new Gd(r,{schema:t})}};class Zp extends dt{constructor(e){super(e,Zp.RESOURCE_NAME)}static get RESOURCE_NAME(){return"secrets/resource"}async findByResourceId(e){this.assertValidId(e);return(await this.apiClient.get(e)).body}}const Qp=Zp;const Xp=class{constructor(e,t){this.account=e,this.secretService=new Qp(t)}async findByResourceId(e){he(e);const t=await this.secretService.findByResourceId(e);return new Ga(t)}};const eh=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.resourceModel=new Wd(r,s),this.findSecretService=new Xp(s,r),this.resourceTypeModel=new Qo(r),this.progressService=new pc(this.worker,ue.t("Decrypting ...")),this.getPassphraseService=new oc(s)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){he(e);const t=await this.getPassphraseService.getPassphrase(this.worker),r=this.resourceModel.getById(e),s=await this.findSecretService.findByResourceId(e),i=await Hp.getKey(t),a=await r,o=await this.resourceTypeModel.getSecretSchemaById(a.resourceTypeId);return Jp.decryptAndParse(s,o,i)}},th={listen:function(e,t,r){e.port.on("passbolt.secret.find-by-resource-id",(async(s,i)=>{const a=new eh(e,s,t,r);await a._exec(i)}))}},rh={listen:function(e){e.port.on("passbolt.organization-settings.get",(async(t,r=!0)=>{try{const s=await re.getInstance().getApiClientOptions(),i=new wt(s),a=await i.getOrFind(r);e.port.emit(t,"SUCCESS",a)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};const sh=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.progressService=new pc(this.worker),this.shareResourceService=new zd(r,s,this.progressService),this.getPassphraseService=new oc(s)}async _exec(e,t){try{await this.exec(e,t),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){Ae(e,'The parameter "resourcesIds" should be an array'),Te(e,'The parameter "resourcesIds" should be a non empty array'),Ie(e,'The parameter "resourcesIds" should contain only uuid'),Ae(t,'The parameter "permissionChangesDto" should be an array'),Te(t,'The parameter "permissionChangesDto" should be a non empty array');const r=new kd(t),s=await this.getPassphraseService.getPassphrase(this.worker);this.progressService.title=ue.t("Share {{count}} resource",{count:e.length}),this.progressService.start(8,ue.t("Initialize"));try{await this.shareResourceService.shareAll(e,r,s),this.progressService.finishStep(ue.t("Done!"),!0)}finally{this.progressService.close()}}};const ih=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.progressService=new pc(this.worker),this.shareFoldersService=new $d(r,s,this.progressService),this.getPassphraseService=new oc(s),this.getOrFindFoldersService=new Fd(s,r)}async _exec(e,t){try{await this.exec(e,t),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){he(e,'The parameter "folderId" should be a UUID'),Ae(t,'The parameter "permissionChangesDto" should be an array'),Te(t,'The parameter "permissionChangesDto" should be a non empty array');const r=new kd(t),s=await this.getPassphraseService.getPassphrase(this.worker),i=(await this.getOrFindFoldersService.getOrFindAll()).getById(e);this.progressService.title=ue.t("Sharing folder {{name}}",{name:i.name});this.progressService.start(14,ue.t("Initialize"));try{await this.shareFoldersService.shareOneWithContent(e,r,s),this.progressService.finishStep(ue.t("Done!"),!0)}finally{this.progressService.close()}}};const ah=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.shareModel=new tp(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return ve(e,"keyword is not a valid string"),await this.shareModel.search(e)}},oh={listen:function(e,t,r){e.port.on("passbolt.share.get-folders",(async(s,i)=>{try{const a=new Ud(t,r),o=await a.findAllForShare(i);e.port.emit(s,"SUCCESS",o)}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.share.resources.save",(async(s,i,a)=>{const o=new sh(e,s,t,r);await o._exec(i,a)})),e.port.on("passbolt.share.folders.save",(async(s,i,a)=>{const o=new ih(e,s,t,r);await o._exec(i,a)})),e.port.on("passbolt.share.search-aros",(async(r,s)=>{const i=new ah(e,r,t);await i._exec(s)}))}};class nh extends dt{constructor(e){super(e,nh.RESOURCE_NAME)}static get RESOURCE_NAME(){return"ee/subscription"}async find(){return(await this.apiClient.get("key")).body}async update(e){return(await this.apiClient.update("key",e)).body}}const ch=nh;class lh extends T{constructor(e,t={}){super(U.validate(lh.ENTITY_NAME,e,lh.getSchema()),t)}static getSchema(){return{type:"object",required:["subscription_id","users","expiry","created","data"],properties:{customer_id:{type:"string"},subscription_id:{type:"string"},users:{type:"integer"},email:{type:"string",format:"email"},created:{type:"string"},expiry:{type:"string"},data:{type:"string"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}static get ENTITY_NAME(){return"Subscription"}}const uh=lh;class dh extends Error{constructor(e,t={}){super(e),this.name="PassboltSubscriptionError",this.subscription=t}}const ph=dh;const hh=class{constructor(e){this.subscriptionService=new ch(e)}async find(){try{const e=await this.subscriptionService.find();return new uh(e)}catch(e){if(e.data&&402===e.data.code){const t=new uh(e.data.body);throw new ph(e.message,t)}throw e}}async update(e){try{const t=await this.subscriptionService.update(e.toDto());return new uh(t)}catch(e){if(e.data&&402===e.data.code){const t=new uh(e.data.body);throw new ph(e.message,t)}throw e}}};class gh extends T{constructor(e,t={}){super(U.validate(gh.ENTITY_NAME,e,gh.getSchema()),t)}static getSchema(){return{type:"object",required:["data"],properties:{data:{type:"string"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get data(){return this._props.data}set data(e){U.validateProp("data",e,gh.getSchema().properties.data),this._props.data=e}static get ENTITY_NAME(){return"UpdateSubscription"}}const yh=gh;const mh=class{constructor(e,t){this.worker=e,this.subscriptionModel=new hh(t)}async getSubscription(){return await this.subscriptionModel.find()}async updateSubscription(e){const t=new yh(e);return await this.subscriptionModel.update(t)}},wh={listen:function(e,t){e.port.on("passbolt.subscription.get",(async r=>{const s=new mh(e,t);try{const t=await s.getSubscription();e.port.emit(r,"SUCCESS",t)}catch(t){e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.subscription.update",(async(r,s)=>{const i=new mh(e,t);try{const t=await i.updateSubscription(s);e.port.emit(r,"SUCCESS",t)}catch(t){e.port.emit(r,"ERROR",t)}}))}};const _h=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountModel=new Kr,this.organisationSettingsModel=new wt(r),this.ssoKitServerPartModel=new Pi(r)}async _exec(e,t){try{await this.exec(e,t),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){if("string"!=typeof e||"string"!=typeof t)throw new Error("The old and new passphrase have to be string");const r=(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("sso"),s=await this.accountModel.rotatePrivateKeyPassphrase(e,t);r&&await this.regenerateSsoKit(t),await this.accountModel.updatePrivateKey(s),await Wi.flushPassphrase(),ac.isStarted()&&await Wi.set(t),await Uc.saveFile("passbolt-recovery-kit.asc",s,"text/plain",this.worker.tab.id)}async regenerateSsoKit(e){let t;try{t=await _i.get()}catch(e){return void console.log(e)}if(!t)return;t.isRegistered()&&await this.deleteServerPartSsoKit(t.id);const r=await Ci.generateSsoKits(e,t.provider),s=await this.ssoKitServerPartModel.setupSsoKit(r.serverPart);r.clientPart.id=s.id,await _i.save(r.clientPart)}async deleteServerPartSsoKit(e){try{await this.ssoKitServerPartModel.deleteSsoKit(e)}catch(e){if(!(e instanceof it&&404===e?.data?.code))throw e}}};const fh=class{static base64ToBlob(e,t="",r=512){const s=atob(e),i=[];for(let e=0;e<s.length;e+=r){const t=s.slice(e,e+r),a=new Array(t.length);for(let e=0;e<t.length;e++)a[e]=t.charCodeAt(e);const o=new Uint8Array(a);i.push(o)}return new Blob(i,{type:t})}static blobToBase64(e){return new Promise((t=>{const r=new FileReader;r.onloadend=()=>t(r.result),r.readAsDataURL(e)}))}};class vh extends T{constructor(e,t={}){super(U.validate(vh.ENTITY_NAME,e,vh.getSchema()),t),this.file=e.file}static createFromFileBase64(e){if(!e||"object"!=typeof e)throw new TypeError("AvatarUpdateEntity createFromFileBase64 parameter should be an object.");const t=e.filename,r=e.fileBase64,s=e.mimeType,i=fh.base64ToBlob(r,s);return new vh({file:i,filename:t,mimeType:s})}static getSchema(){return{type:"object",required:["file","filename","mime"],properties:{file:{type:"blob"},filename:{type:"string"},mimeType:{type:"string"}}}}get file(){return this._props.file}set file(e){this._props.file=e}get filename(){return this._props.filename}get mimeType(){return this._props.mimeType}static get ENTITY_NAME(){return"AvatarUpdate"}}const Sh=vh;const bh=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.userModel=new To(r,s)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.userModel.updateLocalStorage()}};const Eh=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.userModel=new To(r,s)}async _exec(){try{const e=await this.exec.apply(this,arguments);this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e=!1){return this.userModel.getOrFindMe(e)}};const kh=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.userModel=new To(r,s)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new lr(e);return await this.userModel.update(t,!0)}},Ah={listen:function(e,t,r){e.port.on("passbolt.users.get-all",(async s=>{try{const i=new To(t,r),a=await i.getOrFindAll();e.port.emit(s,"SUCCESS",a)}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.users.create",(async(s,i)=>{try{const a=new To(t,r),o=new lr(i),n=await a.create(o);e.port.emit(s,"SUCCESS",n)}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.users.find-logged-in-user",(async(s,i)=>{const a=new Eh(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.users.update",(async(s,i)=>{const a=new kh(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.users.update-avatar",(async(s,i,a)=>{try{const o=new To(t,r),n=Sh.createFromFileBase64(a),c=await o.updateAvatar(i,n,!0);e.port.emit(s,"SUCCESS",c)}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.users.update-security-token",(async(s,i)=>{try{const a=new Kr(t,r),o=new jr(i);await a.changeSecurityToken(o),e.port.emit(s,"SUCCESS")}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.user.update-private-key",(async(r,s,i)=>{const a=new _h(e,r,t);await a._exec(s,i)})),e.port.on("passbolt.users.delete-dry-run",(async(s,i,a)=>{try{const o=new To(t,r),n=a?new Eo(a):null;await o.deleteDryRun(i,n),e.port.emit(s,"SUCCESS")}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.users.delete",(async(s,i,a)=>{try{const o=new To(t,r),n=a?new Eo(a):null;await o.delete(i,n),e.port.emit(s,"SUCCESS")}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.users.update-local-storage",(async s=>{const i=new bh(e,s,t,r);await i._exec()})),e.port.on("passbolt.users.resend-invite",(async(r,s)=>{try{const i=new To(t);await i.resendInvite(s),e.port.emit(r,"SUCCESS")}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}}))}};var Th=r(7946);const Ih=new k;class Rh{static async flush(){return m.write({level:"debug",message:"GroupLocalStorage flushed"}),await Th.storage.local.remove(Rh.GROUP_LOCAL_STORAGE_KEY)}static async get(){const{groups:e}=await Th.storage.local.get([Rh.GROUP_LOCAL_STORAGE_KEY]);return e}static async set(e){await Ih.acquire();const t=[];if(!(e instanceof la))throw new TypeError("GroupLocalStorage::set expects a GroupsCollection");for(const r of e)Rh.assertEntityBeforeSave(r),t.push(r.toDto(Rh.DEFAULT_CONTAIN));await Th.storage.local.set({groups:t}),Ih.release()}static async getGroupById(e){return(await Rh.get()).find((t=>t.id===e))}static async addGroup(e){await Ih.acquire();try{Rh.assertEntityBeforeSave(e);const t=await Rh.get();t.push(e.toDto(Rh.DEFAULT_CONTAIN)),await Th.storage.local.set({groups:t}),Ih.release()}catch(e){throw Ih.release(),e}}static async updateGroup(e){await Ih.acquire();try{Rh.assertEntityBeforeSave(e);const t=await Rh.get(),r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The group could not be found in the local storage");t[r]=Object.assign(t[r],e.toDto(Rh.DEFAULT_CONTAIN)),await Th.storage.local.set({groups:t}),Ih.release()}catch(e){throw Ih.release(),e}}static async delete(e){await Ih.acquire();try{const t=await Rh.get();if(t){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await Th.storage.local.set({groups:t}),Ih.release()}}catch(e){throw Ih.release(),e}}static get DEFAULT_CONTAIN(){return{my_group_user:!0,groups_users:!0}}static get GROUP_LOCAL_STORAGE_KEY(){return"groups"}static assertEntityBeforeSave(e){if(!e)throw new TypeError("GroupLocalStorage expects a GroupEntity to be set");if(!(e instanceof ca))throw new TypeError("GroupLocalStorage expects an object of type GroupEntity");if(!e.id)throw new TypeError("GroupLocalStorage expects GroupEntity id to be set")}}const Ch=Rh;class Oh extends dt{constructor(e){super(e,Oh.RESOURCE_NAME)}static get RESOURCE_NAME(){return"groups"}static getSupportedContainOptions(){return["modifier","modifier.profile","my_group_user","groups_users","groups_users.user","groups_users.user.profile","groups_users.user.gpgkey","group_user","group_user.user","group_user.user.profile","group_user.user.gpgkey"]}static getSupportedFiltersOptions(){return["has-users","has-managers"]}static getSupportedOrdersOptions(){return["Group.name DESC","Group.name ASC"]}async get(e){this.assertValidId(e);return(await this.apiClient.get(e)).body}async findAll(e,t,r){const s=Oh.remapLegacyContain(e);e=s?this.formatContainOptions(s,Oh.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(t,Oh.getSupportedFiltersOptions()):null,r=r?this.formatOrderOptions(r,Oh.getSupportedFiltersOptions()):null;const i={...e,...t,...r},a=await this.apiClient.findAll(i);return a.body&&a.body.length?a.body:[]}async create(e){this.assertNonEmptyData(e),e=Oh.remapV2DataToV1(e);return(await this.apiClient.create(e)).body}async update(e,t){this.assertValidId(e),this.assertNonEmptyData(t);return(await this.apiClient.update(e,t)).body}async updateDryRun(e,t){this.assertValidId(e),this.assertNonEmptyData(t);const{body:r}=await this.apiClient.update(e,t,{},!0);if(r)return r["dry-run"]?this.remapUpdateDryRunDataV1tov2(r["dry-run"]):r}async delete(e,t,r){this.assertValidId(e);const s=t?{transfer:t}:{};return(await this.apiClient.delete(e,s,{},r)).body}static remapV2DataToV1(e){if(!e||!e.name||!e.groups_users)return;const t=[];for(const r of e.groups_users){const e={};Object.prototype.hasOwnProperty.call(r,"user_id")&&(e.user_id=r.user_id),Object.prototype.hasOwnProperty.call(r,"is_admin")&&(e.is_admin=r.is_admin?1:0),t.push({GroupUser:e})}return{Group:{name:e.name},GroupUsers:t}}static remapLegacyContain(e){if(e)return Object.prototype.hasOwnProperty.call(e,"groups_users")&&("boolean"==typeof e.groups_users?e.group_user=e.groups_users:e.group_user=Object.assign({},e.groups_users),delete e.groups_users),e}remapUpdateDryRunDataV1tov2(e){let t=[],r=[];if(e.Secrets&&Array.isArray(e.Secrets)){const r=e=>e.Secret&&Array.isArray(e.Secret)?e.Secret[0]:null;t=e.Secrets.map(r)}if(e.SecretsNeeded&&Array.isArray(e.SecretsNeeded)){const t=e=>e.Secret;r=e.SecretsNeeded.map(t)}return{secrets:t,needed_secrets:r}}}const xh=Oh;class Ph extends Xt{get entityClass(){return Ga}constructor(e,t={}){super(e,t)}static getSchema(){return{type:"array",items:Ga.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,{haystackSet:t?.uniqueIdsSetCache}),this.assertUniqueResourceIdUserId(e,{haystackSet:t?.uniqueResourceIdsUserIdsOrNullSetCache})}assertUniqueResourceIdUserId(e,t){if(!e.userId||!e.resourceId)return;let r=t?.haystackSet;r||(r=new Set(this.extractUserIdResourceId()));const s=Ph.getResourceIdUserIdKey(e);if(r.has(s)){const e=new R,r=t?.message||`The collection already includes an element that has a couple resource_id:user_id (${s}) with an identical value.`;throw e.addError("resource_id:user_id","unique",r),e}}extractUserIdResourceId(){return this._items.reduce(((e,t)=>(void 0!==t._props.user_id&&void 0!==t._props.resource_id&&e.push(Ph.getResourceIdUserIdKey(t)),e)),[])}pushMany(e,t={},r={}){const s=new Set(this.extract("id")),i=new Set(this.extractUserIdResourceId());r={onItemPushed:e=>{s.add(e.id),i.add(Ph.getResourceIdUserIdKey(e))},validateBuildRules:{...r?.validateBuildRules,uniqueIdsSetCache:s,uniqueResourceIdsUserIdsOrNullSetCache:i},...r},super.pushMany(e,t,r)}static getResourceIdUserIdKey(e){return`${e.resourceId}:${e.userId}`}}const Nh=Ph;const Uh=class extends $t{constructor(e,t={}){super(e,t),this._props.secrets&&(this._secrets=new Nh(this._props.secrets,{clone:!1}),delete this._props.secrets),this._props.needed_secrets&&(this._needed_secrets=new Bd(this._props.needed_secrets,{clone:!1}),delete this._props.needed_secrets)}static getSchema(){return{type:"object",required:[],properties:{secrets:Nh.getSchema(),needed_secrets:Bd.getSchema()}}}toDto(){const e=Object.assign({},this._props);return this._secrets&&(e.secrets=this._secrets.toDto()),this._needed_secrets&&(e.needed_secrets=this._needed_secrets.toDto()),e}toJSON(){return this.toDto()}get secrets(){return this._secrets||null}get neededSecrets(){return this._needed_secrets||null}};const Dh=class extends $t{constructor(e,t={}){super(e,t),this._props.owners&&(this._owners=new bo(this._props.owners,{clone:!1}),delete this._props.owners)}static getSchema(){return{type:"object",required:["owners"],properties:{owners:bo.getSchema()}}}toDto(){const e={};return this._owners&&(e.owners=this._owners.toDto()),e}};const Mh=class{constructor(e){this.groupService=new xh(e)}async updateLocalStorage(){const e=await this.findAll({groups_users:!0,my_group_user:!0,modifier:!1},null,null,!0);return await Ch.set(e),e}async getById(e){const t=await Ch.getGroupById(e);if(t)return new ca(t)}async findAll(e,t,r,s){const i=await this.groupService.findAll(e,t,r);return new la(i,{clone:!1,ignoreInvalidEntity:s})}async create(e){const t=e.toDto({groups_users:!0}),r=await this.groupService.create(t),s=new ca(r);return await Ch.addGroup(s),s}async updateDryRun(e){const t=e.toDto(),r=await this.groupService.updateDryRun(e.id,t);return new Uh(r)}async update(e,t){const r=e.toDto(),s=await this.groupService.update(e.id,r),i=new ca(s,{ignoreInvalidEntity:t});return await Ch.updateGroup(i),i}async deleteDryRun(e,t){try{const r=t&&t instanceof Dh?t.toDto():{};await this.groupService.delete(e,r,!0)}catch(e){if(e instanceof it&&400===e.data.code&&e.data.body.errors)throw new _o(e.message,e.data.body.errors);throw e}}async delete(e,t){try{const r=t&&t instanceof Dh?t.toDto():{};await this.groupService.delete(e,r)}catch(e){if(e instanceof it&&400===e.data.code&&e.data.body.errors)throw new _o(e.message,e.data.body.errors);throw e}await Ch.delete(e)}};class Lh extends T{constructor(e,t={}){super(U.validate(Lh.ENTITY_NAME,e,Lh.getSchema()),t)}static getSchema(){const e=er.getSchema(),t={type:"object",required:[],properties:{delete:{type:"boolean"}}};return["id","user_id","is_admin"].forEach((r=>{t.properties[r]=e.properties[r]})),t}static createFromGroupUser(e,t){if(!(e&&e instanceof er))throw new TypeError("GroupUserChangeEntity createFromGroupUser expect a GroupUser entity.");const r={};switch(t){case Lh.GROUP_USER_CHANGE_CREATE:if(!e.userId)throw new TypeError("GroupUserChangeEntity createFromGroupUser update expect a group user user_id.");r.user_id=e.userId,r.is_admin=e.isAdmin;break;case Lh.GROUP_USER_CHANGE_UPDATE:if(!e.id)throw new TypeError("GroupUserChangeEntity createFromGroupUser update expect a group user id.");r.id=e.id,r.is_admin=e.isAdmin;break;case Lh.GROUP_USER_CHANGE_DELETE:if(!e.id)throw new TypeError("GroupUserChangeEntity createFromGroupUser delete expect a group user id.");r.id=e.id,r.delete=!0;break;default:throw new TypeError("GroupUserChangeEntity createFromGroupUser unsupported operation")}return new Lh(r)}get id(){return this._props.id||null}get userId(){return this._props.user_id||null}get isAdmin(){return this._props.is_admin||null}get isDeleted(){return void 0===this._props.delete?null:this._props.delete}get scenario(){return this.isDeleted?Lh.GROUP_USER_CHANGE_DELETE:this.id?Lh.GROUP_USER_CHANGE_UPDATE:Lh.GROUP_USER_CHANGE_CREATE}static get ENTITY_NAME(){return"GroupUser"}static get GROUP_USER_CHANGE_CREATE(){return"create"}static get GROUP_USER_CHANGE_UPDATE(){return"update"}static get GROUP_USER_CHANGE_DELETE(){return"delete"}}const Fh=Lh;class qh extends Ft{constructor(e,t={}){super(U.validate(qh.ENTITY_NAME,e,qh.getSchema()),t),this._props.forEach((e=>{this.push(e)})),this._props=null}static getSchema(){return{type:"array",items:Fh.getSchema()}}static createFromGroupsUsersCollectionsChanges(e,t){if(!(e&&e instanceof tr&&t&&t instanceof tr))throw new TypeError("GroupUserChangesCollection createFromGroupsUsersCollectionsChanges invalid parameters");const r=new qh([]);for(const s of t){const t=e.getGroupUserByUserId(s.userId);if(t){if(s.isAdmin!==t.isAdmin){s.id=t.id;const e=Fh.createFromGroupUser(s,Fh.GROUP_USER_CHANGE_UPDATE);r.push(e)}}else{const e=Fh.createFromGroupUser(s,Fh.GROUP_USER_CHANGE_CREATE);r.push(e)}}for(const s of e)if(!t.getById(s.id)){const e=Fh.createFromGroupUser(s,Fh.GROUP_USER_CHANGE_DELETE);r.push(e)}return r}push(e){if(!e||"object"!=typeof e)throw new TypeError("GroupUserChangesCollection push parameter should be an object.");e instanceof Fh&&(e=e.toDto()),e=new Fh(e),super.push(e)}static get ENTITY_NAME(){return"GroupUserChanges"}}const Kh=qh;class Bh extends T{constructor(e,t={}){super(U.validate(Bh.ENTITY_NAME,e,Bh.getSchema()),t),this._props.groups_users&&(this._groups_users=new Kh(this._props.groups_users,{clone:!1}),delete this._props.groups_users),this._props.secrets&&(this._secrets=new Nh(this._props.secrets,{clone:!1}),delete this._props.secrets)}static getSchema(){const e=ca.getSchema();return{type:"object",required:["id","name"],properties:{id:e.properties.id,name:e.properties.name,groups_users:Kh.getSchema(),secrets:Nh.getSchema()}}}static createFromGroupsDiff(e,t){const r={id:e.id,name:t.name,groups_users:Kh.createFromGroupsUsersCollectionsChanges(e.groupsUsers,t.groupsUsers).toDto()};return new Bh(r)}toDto(){const e=Object.assign({},this._props);return this._groups_users&&(e.groups_users=this._groups_users.toDto()),this._secrets&&(e.secrets=this._secrets.toDto()),e}toJSON(){return this.toDto()}get id(){return this._props.id||null}get name(){return this._props.name}get groupsUsers(){return this._groups_users||null}get secrets(){return this._secrets||null}set secrets(e){this._secrets=e}static get ENTITY_NAME(){return"GroupUpdate"}}const jh=Bh;const zh=class{constructor(e,t,r){this.apiClientOptions=e,this.account=t,this.progressService=r,this.groupModel=new Mh(e),this.decryptPrivateKeyService=new Fr}async exec(e,t){be(e,ca),ve(t);const r=await this.groupModel.getById(e.id),s=jh.createFromGroupsDiff(r,e);this.progressService.start(10,ue.t("Initialize")),this.progressService.finishStep(null,!0);const i=await this.simulateUpdateGroup(s);if(i.neededSecrets.length>0){const e=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t);s.secrets=await this.encryptNeededSecrets(e,i)}await this.updateGroup(s),this.progressService.finishStep(null,!0)}async simulateUpdateGroup(e){const t=await this.groupModel.updateDryRun(e),r=t.neededSecrets.length+t.secrets.length;return this.progressService.updateGoals(this.progressService.goals+r),this.progressService.finishStep(null,!0),t}async encryptNeededSecrets(e,t){const r=await this.decryptSecrets(e,t.secrets);return await this.encryptSecrets(e,t.neededSecrets,r)}async encryptSecrets(e,t,r){const s=new Nh([]);this.progressService.finishStep(ue.t("Synchronizing keyring"),!0);const i=await this.retrieveAndReadUserPublicKeys(t),a=t.length;for(let o=0;o<a;o++){const n=t.items[o],c=n.userId,l=n.resourceId;await this.progressService.finishStep(ue.t("Encrypting {{counter}}/{{total}}",{counter:o+1,total:a}));const u=await Rs.encrypt(r[l],i[c],[e]),d=new Ga({resource_id:l,user_id:c,data:u});s.push(d)}return s}async decryptSecrets(e,t){const r=[],s=t.length;for(let i=0;i<s;i++){const a=t.items[i],o=await Ge(a.data);this.progressService.finishStep(ue.t("Decrypting {{counter}}/{{total}}",{counter:i+1,total:s})),r[a.resourceId]=await Mi.decrypt(o,e)}return r}async updateGroup(e){this.progressService.finishStep(ue.t("Updating group"),!0),await this.groupModel.update(e,!0)}async retrieveAndReadUserPublicKeys(e){const t={},r=[...new Set(e.extract("user_id"))],s=new xt;await s.sync();for(const e of r){const r=s.findPublic(e).armoredKey;t[e]=await Je(r)}return t}};const $h=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.groupModel=new Mh(r),this.keyring=new xt,this.getPassphraseService=new oc(s),this.progressService=new pc(this.worker,ue.t("Updating group ...")),this.groupUpdateService=new zh(r,s,this.progressService)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this.getPassphraseService.getPassphrase(this.worker),r=new ca(e);try{await this.groupUpdateService.exec(r,t)}finally{this.progressService.close()}}};const Vh=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.groupModel=new Mh(r)}async _exec(){try{const e=await this.exec.apply(this,arguments);this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e={"has-users":re.getInstance().get().id};return await this.groupModel.findAll(null,e)}},Yh={listen:function(e,t,r){e.port.on("passbolt.groups.update-local-storage",(async r=>{try{const s=new Mh(t);await s.updateLocalStorage(),e.port.emit(r,"SUCCESS")}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.groups.find-all",(async(r,s)=>{try{const i=new Mh(t),{contains:a,filters:o,orders:n}=s,c=await i.findAll(a,o,n);e.port.emit(r,"SUCCESS",c)}catch(t){e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.groups.find-my-groups",(async r=>{new Vh(e,r,t)._exec()})),e.port.on("passbolt.groups.create",(async(r,s)=>{try{const i=new Mh(t),a=new ca(s),o=await i.create(a);e.port.emit(r,"SUCCESS",o)}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.groups.update",(async(s,i)=>{new $h(e,s,t,r)._exec(i)})),e.port.on("passbolt.groups.delete-dry-run",(async(r,s,i)=>{try{const a=new Mh(t),o=i?new Dh(i):null;await a.deleteDryRun(s,o),e.port.emit(r,"SUCCESS")}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.groups.delete",(async(r,s,i)=>{try{const a=new Mh(t),o=i?new Dh(i):null;await a.delete(s,o),e.port.emit(r,"SUCCESS")}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}}))}},Gh=["Resource"];class Wh extends $t{constructor(e,t={}){super(e,t),this._props.creator&&(this._creator=new lr(this._props.creator,{clone:!1}),delete this._props.creator),this._props.modifier&&(this._modifier=new lr(this._props.modifier,{clone:!1}),delete this._props.modifier)}static getSchema(){return{type:"object",required:["user_id","foreign_key","foreign_model","content"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},foreign_key:{type:"string",format:"uuid"},foreign_model:{type:"string",enum:Wh.ALLOWED_FOREIGN_MODELS},parent_id:{type:"string",format:"uuid",nullable:!0},content:{type:"string",minLength:1,maxLength:Wh.COMMENT_CONTENT_MAX_LENGTH},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"},creator:lr.getSchema(),modifier:lr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.creator&&e.creator&&(t.creator=this.creator.toDto(lr.ALL_CONTAIN_OPTIONS)),this.modifier&&e.modifier&&(t.modifier=this.modifier.toDto(lr.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(Wh.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get foreignKey(){return this._props.foreign_key}get foreignModel(){return this._props.foreign_model}get userId(){return this._props.user_id}get content(){return this._props.content}get parentId(){return this._props.parent_id||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get creator(){return this._creator||null}get modifier(){return this._modifier||null}static get COMMENT_CONTENT_MAX_LENGTH(){return 255}static get ALLOWED_FOREIGN_MODELS(){return Gh}static get ALL_CONTAIN_OPTIONS(){return{creator:lr.ALL_CONTAIN_OPTIONS,modifier:lr.ALL_CONTAIN_OPTIONS}}}const Hh=Wh;class Jh extends Xt{get entityClass(){return Hh}static getSchema(){return{type:"array",items:Hh.getSchema()}}validateBuildRules(e){this.assertNotExist("id",e._props.id),this.assertSameForeignEntity(e)}get comments(){return this._items}get ids(){return this._items.map((e=>e.id))}get userIds(){return this._items.map((e=>e.userId))}get foreignKey(){return this._items.map((e=>e.foreignKey))}assertSameForeignEntity(e){if(!this.comments.length)return;if(!(e.foreignKey===this.comments[0].foreignKey&&e.foreignModel===this.comments[0].foreignModel)){const e=new P,t=`The collection is already used for another model with id ${this.comments[0].resourceId} (${this.comments[0].foreignKey}).`;throw e.addCollectionValidationError(Jh.RULE_SAME_FOREIGN_MODEL,t),e}}static get RULE_SAME_FOREIGN_MODEL(){return"same_foreign_model"}}const Zh=Jh;class Qh extends dt{constructor(e){super(e,Qh.RESOURCE_NAME)}static get RESOURCE_NAME(){return"comments"}static getSupportedContainOptions(){return["creator","modifier"]}async findAll(e,t,r){this.assertValidId(t),this.assertValidForeignModel(e),r=r?this.formatContainOptions(r,Qh.getSupportedContainOptions()):null;const s={...r},i=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e.toLowerCase()}/${t}`,s||{}),a=await this.apiClient.fetchAndHandleResponse("GET",i);return a.body&&a.body.length?a.body:[]}async create(e){if(!e||!e.foreign_key||!e.foreign_model)throw new TypeError("Comment creation failed, invalid comment data.");const t=e.foreign_model;this.assertValidForeignModel(t);const r=e.foreign_key;this.assertValidId(r);const s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${t.toLowerCase()}/${r}`,{}),i={content:e.content};e.parent_id&&(i.parent_id=e.parent_id);const a=this.apiClient.buildBody(i);return(await this.apiClient.fetchAndHandleResponse("POST",s,a)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}assertValidForeignModel(e){if(!e||"string"!=typeof e)throw new TypeError("Comment foreign model should be a valid string.");if(!Hh.ALLOWED_FOREIGN_MODELS.includes(e))throw new TypeError(`Comment foreign model ${e} in not in the list of supported models.`)}}const Xh=Qh;const eg=class{constructor(e){this.commentService=new Xh(e)}async findAllByResourceId(e){const t=await this.commentService.findAll("Resource",e,{creator:!0,modifier:!1});return new Zh(t)}async create(e){const t=await this.commentService.create(e.toDto({creator:!1,modifier:!1}));return new Hh(t)}async delete(e){await this.commentService.delete(e)}};const tg=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.commentModel=new eg(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return this.commentModel.create(new Hh(e))}};const rg=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.commentModel=new eg(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!e)throw new Error("A comment id is required.");if("string"!=typeof e)throw new Error("The comment id should be a valid string.");if(!O().isUUID(e))throw new Error("The comment id should be a valid uuid.");await this.commentModel.delete(e)}};const sg=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.commentModel=new eg(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!e)throw new TypeError("A resource id is required.");if("string"!=typeof e)throw new TypeError("The resource id should be a string.");if(!O().isUUID(e))throw new TypeError("The resource id should be a valid uuid.");return this.commentModel.findAllByResourceId(e)}},ig={listen:function(e,t){e.port.on("passbolt.comments.find-all-by-resource",(async(r,s)=>{const i=new sg(e,r,t);await i._exec(s)})),e.port.on("passbolt.comments.create",(async(r,s)=>{const i=new tg(e,r,t);await i._exec(s)})),e.port.on("passbolt.comments.delete",(async(r,s)=>{const i=new rg(e,r,t);await i._exec(s)}))}};class ag extends dt{constructor(e){super(e,ag.RESOURCE_NAME)}static get RESOURCE_NAME(){return"tags"}async findAll(){const e=await this.apiClient.findAll();return e.body&&e.body.length?e.body:[]}async updateResourceTags(e,t){this.assertValidId(e);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e}`),s={Tags:t.map((e=>e.slug))},i=this.apiClient.buildBody(s);return(await this.apiClient.fetchAndHandleResponse("POST",r,i)).body}async update(e,t){this.assertValidId(e);return(await this.apiClient.update(e,t)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}}const og=ag;const ng=class{constructor(e,t){this.tagService=new og(e),this.resourceModel=new Wd(e,t)}async findAll(){const e=await this.tagService.findAll();return new Va(e)}async updateResourceTags(e,t){const r=await this.tagService.updateResourceTags(e,t.toDto()),s=new Va(r);return await this.resourceModel.replaceResourceTagsLocally(e,s)}async update(e){const t=await this.tagService.update(e.id,e.toDto()),r=new $a(t);return await this.resourceModel.replaceTagLocally(e.id,r),r}async delete(e){await this.tagService.delete(e),await this.resourceModel.deleteTagsLocally(e)}async bulkTagResources(e,t,r){let s=[];const i=en(e,5);for(const e in i){const a=i[e].map((async(s,i)=>{const a=5*e+i;return this._bulkTagResources_tagResource(s,t,a,r)})),o=(await Promise.allSettled(a)).map((e=>e.value));s=[...s,...o]}await this.resourceModel.bulkReplaceResourceTagsLocally(e,s)}async _bulkTagResources_tagResource(e,t,r,s){const i=(s=s||{}).successCallback||(()=>{}),a=s.errorCallback||(()=>{});try{const s=await this.resourceModel.getById(e),a=new Va([...t.tags,...s.tags||[]]),o=await this.tagService.updateResourceTags(e,a.toDto()),n=new Va(o);return i(n,r),n}catch(e){return console.error(e),a(e,r),e}}};const cg=class{constructor(e,t,r){this.worker=e,this.resourceModel=new Wd(t,r),this.tagModel=new ng(t,r),this.progressService=new pc(this.worker,ue.t("Adding tag..."))}async addTagResources(e,t){const r=2+e.length;this.progressService.start(r,ue.t("Initialize"));try{const r=await this._keepResourcesTagNotPresent(e,t.id);r.length>0&&await this._taggingResources(r,t),await this.progressService.finishStep(ue.t("Done!"),!0),await this.progressService.close()}catch(e){throw await this.progressService.close(),e}}async _keepResourcesTagNotPresent(e,t){await this.progressService.finishStep(ue.t("Preparing..."),!0);return(await this.resourceModel.getAllByIds(e)).filterByTagNotPresent(t).map((e=>e.id))}async _taggingResources(e,t){await this.progressService.finishStep(ue.t("Updating resource"),!0);const r=new Va([t]),s=e.length;let i=0;await this.tagModel.bulkTagResources(e,r,{successCallback:()=>this._handleTagResourceSuccess(s,++i),errorCallback:()=>this._handleTagResourceError(s,++i)})}async _handleTagResourceSuccess(e,t){await this.progressService.finishStep(ue.t(`Tagging passwords ${t}/${e}`))}async _handleTagResourceError(e,t){await this.progressService.finishStep(ue.t(`Tagging passwords ${t}/${e}`))}},lg={listen:function(e,t,r){e.port.on("passbolt.tags.find-all",(async s=>{try{const i=new ng(t,r),a=await i.findAll();e.port.emit(s,"SUCCESS",a)}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.tags.update-resource-tags",(async(s,i,a)=>{try{const o=new ng(t,r),n=new Va(a),c=await o.updateResourceTags(i,n);e.port.emit(s,"SUCCESS",c)}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.tags.add-resources-tag",(async(s,i)=>{try{const a=new cg(e,t,r);await a.addTagResources(i.resources,i.tag),e.port.emit(s,"SUCCESS")}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.tags.update",(async(s,i)=>{try{const a=new ng(t,r),o=new $a(i),n=await a.update(o);e.port.emit(s,"SUCCESS",n)}catch(t){e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.tags.delete",(async(s,i)=>{try{const a=new ng(t,r);await a.delete(i),e.port.emit(s,"SUCCESS")}catch(t){e.port.emit(s,"ERROR",t)}}))}};class ug extends dt{constructor(e){super(e,ug.RESOURCE_NAME)}static get RESOURCE_NAME(){return"favorites"}async create(e,t){this.assertValidForeignModel(e),this.assertValidId(t);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e.toLowerCase()}/${t}`,{});return(await this.apiClient.fetchAndHandleResponse("POST",r)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}assertValidForeignModel(e){if(!e||"string"!=typeof e)throw new TypeError("Favorite foreign model should be a valid string.");if(!ya.ALLOWED_FOREIGN_MODELS.includes(e))throw new TypeError(`Favorite foreign model ${e} in not in the list of supported models.`)}}const dg=ug;const pg=class{constructor(e,t){this.favoriteService=new dg(e),this.resourceModel=new Wd(e,t)}async addResourceToFavorite(e){const t=await this.favoriteService.create("Resource",e),r=new ya(t);return await this.resourceModel.updateFavoriteLocally(e,r),r}async removeResourceFromFavorite(e){const t=await this.resourceModel.getById(e);t.favorite&&(await this.favoriteService.delete(t.favorite.id),await this.resourceModel.updateFavoriteLocally(e,null))}},hg={listen:function(e,t,r){e.port.on("passbolt.favorite.add",(async(s,i)=>{try{const a=new pg(t,r),o=await a.addResourceToFavorite(i);e.port.emit(s,"SUCCESS",o)}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}})),e.port.on("passbolt.favorite.delete",(async(s,i)=>{try{const a=new pg(t,r);await a.removeResourceFromFavorite(i),e.port.emit(s,"SUCCESS")}catch(t){console.error(t),e.port.emit(s,"ERROR",t)}}))}};class gg extends $t{marshall(){"string"==typeof this._props.folder_parent_path?this._props.folder_parent_path=gg.sanitizePath(this._props.folder_parent_path):void 0===this._props.folder_parent_path&&(this._props.folder_parent_path="")}static getSchema(){const e=go.getSchema();return{type:"object",required:["name"],properties:{id:e.properties.id,name:e.properties.name,folder_parent_id:e.properties.folder_parent_id,folder_parent_path:{type:"string"}}}}static createFromPath(e){e=gg.sanitizePath(e);const t=gg.splitFolderPath(e),r={name:t.pop(),folder_parent_path:t.join("/")};return new gg(r)}static sanitizePath(e){return(e=e||"").replace(/^(\/{2,})|(\/{2,})$/g,"/").replace(/^(\/(?! ))|((?<! )\/)$/g,"").replace(/(?<! )(\/{2,})(?! )/g,"/")}static splitFolderPath(e){return e.split(/(?<! )\/(?! )/g)}static escapeName(e){return(e=e||"").trim().replace(/^\//,"/ ").replace(/\/$/," /").replace(/(.)\/(.)/g,"$1 / $2")}static resolveEscapedName(e){return(e=e||"").replace(/ \/ | \/|\/ /g,"/")}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get id(){return this._props.id||null}set id(e){const t=this.cachedSchema.properties.id;this._props.id=U.validateProp("id",e,t)}get name(){return this._props.name}get folderParentId(){return this._props.folder_parent_id||null}set folderParentId(e){const t=this.cachedSchema.properties.folder_parent_id;this._props.folder_parent_id=U.validateProp("folder_parent_id",e,t)}get folderParentPath(){return this._props.folder_parent_path||""}get path(){return this.folderParentPath?`${this.folderParentPath}/${this.name}`:this.name}get depth(){return this.folderParentPath?gg.splitFolderPath(this.folderParentPath).length:0}changeRootPath(e){this._props.folder_parent_path.length?this._props.folder_parent_path=`${e.path}/${this._props.folder_parent_path}`:this._props.folder_parent_path=e.path}}const yg=gg;class mg extends Xt{get entityClass(){return yg}static getSchema(){return{type:"array",items:yg.getSchema()}}static constructFromFoldersCollection(e){be(e,mo);const t=e.folders.map((t=>{const r=mg.getEscapedFolderParentPath(e,t),s=r.length?t.folderParentId:null;return Object.assign(t.toDto(),{name:yg.escapeName(t.name),folder_parent_id:s,folder_parent_path:r})}));return new mg(t)}static getEscapedFolderParentPath(e,t){return e.getAllParents(t).items.reverse().map((e=>yg.escapeName(e.name))).join("/")}static toFoldersCollection(e){const t=[];return e.forEach((e=>{const r=Object.assign(e.toDto(),{name:yg.resolveEscapedName(e.name)});t.push(r)})),new mo(t)}hasPath(e){return e=yg.sanitizePath(e),this._items.some((t=>t.path===e))}getById(e){return this._items.find((t=>t.id===e))||null}getByDepth(e){return this._items.filter((t=>t.depth===e))}getByPath(e){return this._items.find((t=>t.path===e))||null}getByFolderParentId(e){return e?this._items.filter((t=>t.folderParentId===e)):[]}pushFromPath(e){if(!(e=yg.sanitizePath(e)).length)return;const t=[],r=yg.splitFolderPath(e);let s="";for(const e of r){if(s=s.length?`${s}/${e}`:e,this.hasPath(s))continue;const r=yg.createFromPath(s);t.push(r)}this.pushMany(t)}setFolderParentIdsByPath(e,t){for(const r of this._items)r.folderParentPath===e&&(r.folderParentId=t)}changeRootPath(e){this._items.forEach((t=>t.changeRootPath(e)))}removeByPath(e){for(let t=this._items.length-1;t>=0;t--){const r=this._items[t],s=e.replace(/[.*+\-?^${}()|[\]\\\/]/g,"\\$&");new RegExp(`^${s}($|/)`).exec(r.path)&&this._items.splice(t,1)}}}const wg=mg,_g=["SHA1","SHA256","SHA512"],fg=_g[0];class vg extends $t{static getSchema(){return{type:"object",required:["secret_key","period","digits","algorithm"],properties:{secret_key:{type:"string",minLength:1,pattern:/^[A-Z2-7]+=*$/,maxLength:1024},period:{type:"integer",minimum:1},digits:{type:"integer",minimum:6,maximum:8},algorithm:{type:"string",enum:_g}}}}marshall(){"string"==typeof this._props.secret_key&&(this._props.secret_key=this._props.secret_key?.replace(/(\W|_|\s)/g,"").toUpperCase()),"string"==typeof this._props.algorithm&&(this._props.algorithm=this._props.algorithm?.toUpperCase()),super.marshall()}get secretKey(){return this._props.secret_key}get period(){return this._props.period}get digits(){return this._props.digits}get algorithm(){return this._props.algorithm}createUrlFromExternalResource(e){const t=e.username?`${e.name}:${e.username}`:e.name,r=new URL(`otpauth://totp/${encodeURIComponent(t)}`);return r.searchParams.append("secret",this.secretKey),e.uri?.length>0&&r.searchParams.append("issuer",encodeURIComponent(e.uri)),r.searchParams.append("algorithm",this.algorithm),r.searchParams.append("digits",this.digits.toString()),r.searchParams.append("period",this.period.toString()),r}static createTotpFromUrl(e){const t={secret_key:e.searchParams.get("secret"),algorithm:e.searchParams.get("algorithm")||fg,digits:parseInt(e.searchParams.get("digits"),10)||6,period:parseInt(e.searchParams.get("period"),10)||30};return new vg(t)}static createTotpFromKdbxWindows(e){const t={secret_key:e.get("TimeOtp-Secret-Base32").getText(),algorithm:e.get("TimeOtp-Algorithm")?.slice(5).replace("-","")||fg,digits:parseInt(e.get("TimeOtp-Length"),10)||6,period:parseInt(e.get("TimeOtp-Period"),10)||30};return new vg(t)}}const Sg=vg;class bg extends $t{constructor(e,t={}){super(e,t),this._props.secrets&&(this._secrets=new Ha(this._props.secrets,{clone:!1}),no.assertValidSecrets(this._secrets,this.id),delete this._props.secrets),this._props.totp&&(this._totp=new Sg(this._props.totp,{clone:!1}),delete this._props.totp)}marshall(){this._props.name=this._props.name||bg.DEFAULT_RESOURCE_NAME,this._props.secret_clear=this._props.secret_clear||"","string"==typeof this._props.folder_parent_path?this._props.folder_parent_path=yg.sanitizePath(this._props.folder_parent_path):this._props.folder_parent_path||(this._props.folder_parent_path=""),super.marshall()}static getSchema(){const e=no.getSchema(),t=ro.getSchema();return{type:"object",required:["name","secret_clear"],properties:{id:e.properties.id,name:t.properties.name,username:t.properties.username,uri:{type:"string",maxLength:ro.URI_MAX_LENGTH},description:t.properties.description,secrets:e.properties.secrets,folder_parent_id:e.properties.folder_parent_id,resource_type_id:e.properties.resource_type_id,secret_clear:{type:"string"},totp:{...Sg.getSchema(),nullable:!0},folder_parent_path:{type:"string"},expired:e.properties.expired}}}toDto(){const e=Object.assign({},this._props);return this._secrets&&(e.secrets=this._secrets.toDto()),this._totp&&(e.totp=this._totp.toDto()),e}toJSON(){return this.toDto()}static buildDtoFromResourceEntityDto(e,t){return{id:e.id,name:e.metadata.name,username:e.metadata.username,uri:e.metadata.uris?.[0]||"",description:e.metadata.description||null,secrets:e.secrets||[],folder_parent_id:t?.id||null,resource_type_id:e.resource_type_id,folder_parent_path:t?.path||"",expired:e.expired||null}}toResourceEntityImportDto(){return{metadata:{object_type:ro.METADATA_OBJECT_TYPE,name:this.name,username:this.username,uris:[this.uri||""],description:this.description,resource_type_id:this.resourceTypeId},secrets:this._secrets.toDto(),folder_parent_id:this.folderParentId,resource_type_id:this.resourceTypeId,expired:this.expired}}get id(){return this._props.id||null}get name(){return this._props.name}get username(){return this._props.username||null}get uri(){return this._props.uri||null}get description(){return this._props.description||null}get secretClear(){return this._props.secret_clear}get folderParentId(){return this._props.folder_parent_id||null}get folderParentPath(){return this._props.folder_parent_path||""}get resourceTypeId(){return this._props.resource_type_id||null}get expired(){return this._props.expired||null}get path(){return this.folderParentPath?`${this.folderParentPath}/${this.name}`:this.name}get depth(){return this.folderParentPath?yg.splitFolderPath(this.folderParentPath).length:0}set id(e){const t=this.cachedSchema.properties.id;this._props.id=U.validateProp("id",e,t)}set folderParentId(e){const t=this.cachedSchema.properties.folder_parent_id;this._props.folder_parent_id=U.validateProp("folder_parent_id",e,t)}set description(e){const t=this.cachedSchema.properties.description;this._props.description=U.validateProp("description",e,t)}set secretClear(e){const t=this.cachedSchema.properties.secret_clear;this._props.secret_clear=U.validateProp("secret_clear",e,t)}set folderParentPath(e){const t=this.cachedSchema.properties.folder_parent_path;this._props.folder_parent_path=U.validateProp("folder_parent_path",e,t)}changeRootPath(e){be(e,yg),this.folderParentPath.length?this.folderParentPath=`${e.path}/${this.folderParentPath}`:this.folderParentPath=e.path}get secrets(){return this._secrets||null}set secrets(e){be(e,Ha),this._secrets=e}get totp(){return this._totp||null}set totp(e){null!==e?(be(e,Sg),this._totp=e):this._totp=null}static get DEFAULT_RESOURCE_NAME(){return"(no name)"}}const Eg=bg;class kg extends Xt{get entityClass(){return Eg}constructor(e=[],t={}){super(e,t)}static getSchema(){return{type:"array",items:Eg.getSchema()}}validateBuildRules(e,t={}){this.assertNotExist("id",e._props.id,t)}static constructFromResourcesCollection(e,t){be(e,po),be(t,wg);const r=e.resources.map((e=>{const r=t.getById(e.folderParentId),s=e.toDto({secrets:!0,metadata:!0});return Eg.buildDtoFromResourceEntityDto(s,r)}));return new kg(r)}toResourceCollectionImportDto(){return this._items.map((e=>e.toResourceEntityImportDto()))}getByDepth(e){return this._items.filter((t=>t.depth===e))}getByFolderParentId(e){return e?this._items.filter((t=>t.folderParentId===e)):[]}pushMany(e,t={},r={}){const s=new Set(this.extract("id"));r={onItemPushed:e=>{s.add(e.id)},validateBuildRules:{...r?.validateBuildRules,uniqueIdsOrNullSetCache:s},...r},super.pushMany(e,t,r)}setFolderParentIdsByPath(e,t){for(const r of this._items)r.folderParentPath===e&&(r.folderParentId=t)}changeRootPath(e){this._items.forEach((t=>t.changeRootPath(e)))}removeByPath(e){for(let t=this._items.length-1;t>=0;t--){const r=this._items[t],s=e.replace(/[.*+\-?^${}()|[\]\\\/]/g,"\\$&");new RegExp(`^${s}/`).exec(r.path)&&this._items.splice(t,1)}}}const Ag=kg,Tg="kdbx",Ig=["csv",Tg];class Rg extends $t{constructor(e,t={}){if(super(e,t),this._props.options){const t=this.cachedSchema.properties.options;this._props.options=U.validate(this.constructor.name,this._props.options,t),e.options.credentials&&(this._props.options.credentials=U.validate(this.constructor.name,this._props.options.credentials,t.properties.credentials))}this._import_resources=new Ag([]),this._import_folders=new wg([]),this._import_resources_errors=[],this._import_folders_errors=[]}static getSchema(){return{type:"object",required:["ref","file","file_type"],properties:{ref:{type:"string",pattern:/^[a-zA-Z0-9\-_]*$/},file:{type:"string",format:"x-base64"},file_type:{type:"string",enum:Ig},options:{type:"object",required:[],properties:{folders:{type:"boolean"},tags:{type:"boolean"},credentials:{type:"object",required:[],properties:{password:{type:"string",nullable:!0},keyfile:{type:"string",format:"x-base64",nullable:!0}}}}}}}}toDto(){return{created:{resourcesCount:this.importResources.items.filter((e=>e.id)).length,foldersCount:this.importFolders.items.filter((e=>e.id)).length},errors:{resources:this.importResourcesErrors.map((e=>e.toJSON())),folders:this.importFoldersErrors.map((e=>e.toJSON()))},options:{folders:this.mustImportFolders,tags:this.mustTag},references:{folder:this.referenceFolder?this.referenceFolder.toJSON():null,tag:this.referenceTag?this.referenceTag.toJSON():null}}}toJSON(){return this.toDto()}get ref(){return this._props.ref}get file(){return this._props.file}get fileType(){return this._props.file_type}get mustImportFolders(){return Boolean(this._props.options?.folders)}get mustTag(){return Boolean(this._props.options?.tags)}get password(){return this._props.options?.credentials?.password??null}get keyfile(){return this._props.options?.credentials?.keyfile??null}get referenceFolder(){return this._referenceFolder||null}set referenceFolder(e){be(e,go),this._referenceFolder=e}get referenceTag(){return this._referenceTag||null}set referenceTag(e){be(e,$a),this._referenceTag=e}get importResources(){return this._import_resources}set importResources(e){be(e,Ag),this._import_resources=e}get importFolders(){return this._import_folders}set importFolders(e){be(e,wg),this._import_folders=e}get importResourcesErrors(){return this._import_resources_errors}get importFoldersErrors(){return this._import_folders_errors}static get SUPPORTED_FILE_TYPES(){return Ig}static get FILE_TYPE_CSV(){return"csv"}static get FILE_TYPE_KDBX(){return Tg}static buildImportEntity(e,t,r){const s=(new Date).toISOString().split(".")[0].replace(/\D/g,"");return new Rg({file_type:e,file:t,options:r,ref:`import-${s}`})}}const Cg=Rg;class Og extends Error{constructor(e,t,r){super(e),this.name="ImportError",this.data=t,this.sourceError=r||{}}toJSON(){const e=this.sourceError&&"function"==typeof this.sourceError.toJSON?this.sourceError.toJSON():this.sourceError,t=this.data&&"function"==typeof this.data.toJSON?this.data.toJSON():this.data;return{name:this.name,message:this.message,data:t,sourceError:e}}}const xg=Og;var Pg=r(8593);const Ng=class{static parseResourceType(e,t,r){t.filterByResourceTypeVersion(r.defaultResourceTypes);const s=this.getScores(e,t).filter((e=>e.value>0)).filter((e=>e.hasRequiredFields)).sort(((e,t)=>t.value-e.value))[0];if(!s)throw new Error("No resource type associated to this row.");return t.getFirst("slug",s.slug)}static getScores(e,t){const r=[];for(let s=0;s<t.length;s++){const i=t.items[s];if(i.slug===va||i.slug===Aa)continue;const a=Object.entries(e).filter((([,e])=>"string"!=typeof e||e.length>0)).map((([e])=>"secret_clear"===e?"password":e));(i.slug===ba||i.slug===Ta)&&a.includes("totp")&&a.includes("description")&&a.push("password");const o=Object.keys(i.definition.secret.properties),n=i.definition.secret.required,c=a.filter((e=>o.includes(e))),l=n.every((e=>c.includes(e)));r.push({slug:i.slug,value:c.length,hasRequiredFields:l,match:c.length===o.length})}return r}};const Ug=class{constructor(e,t,r){this.importEntity=e,this.resourceTypesCollection=t,this.metadataTypesSettings=r}async parseImport(){const e=await this.readKdbxDb();this.parseFolder(e.getDefaultGroup()),this.createAndChangeRootFolder()}async readKdbxDb(){const e=Pg.ByteUtils.base64ToBytes(this.importEntity.file),t=this.readKdbxCredentials();return Pg.Kdbx.load(e.buffer,t)}readKdbxCredentials(){let e=null,t=null;return this.importEntity.password&&(e=Pg.ProtectedValue.fromString(this.importEntity.password)),this.importEntity.keyfile&&(t=Pg.ByteUtils.base64ToBytes(this.importEntity.keyfile)),new Pg.Credentials(e,t)}parseFolder(e){const t={name:yg.escapeName(e.name),folder_parent_path:this.getKdbxEntryPath(e)};try{this.importEntity.importFolders.push(t),this.getGroupChildrenGroups(e).forEach(this.parseFolder.bind(this)),this.getGroupChildrenEntries(e).forEach(this.parseResource.bind(this))}catch(e){this.importEntity.importFoldersErrors.push(new xg("Cannot parse folder",t,e))}}getGroupChildrenGroups(e){return e.groups.filter((e=>e.parentGroup.id===e.id))}getGroupChildrenEntries(e){return e.entries.filter((t=>t.parentGroup.id===e.id))}getKdbxEntryPath(e){let t=[];if(e.parentGroup){const r=e=>e.parentGroup?[...r(e.parentGroup),yg.escapeName(e.name)]:[yg.escapeName(e.name)];t=r(e.parentGroup)}return t.join("/")}parseResource(e){const t={name:e.fields.get("Title")?e.fields.get("Title").trim():"",uri:e.fields.get("URL")?e.fields.get("URL").trim():"",username:e.fields.get("UserName")?e.fields.get("UserName").trim():"",description:e.fields.get("Notes")?e.fields.get("Notes").trim():"",folder_parent_path:this.getKdbxEntryPath(e),secret_clear:"",expired:e.times.expires?e.times.expiryTime?.toISOString():null};"object"==typeof e.fields.get("Password")&&(t.secret_clear=e.fields.get("Password").getText());try{const r=this.getTotp(e);r&&(t.totp=r);const s=Ng.parseResourceType(t,this.resourceTypesCollection,this.metadataTypesSettings);s&&(t.resource_type_id=s.id),t.name.length||(t.name=Eg.DEFAULT_RESOURCE_NAME),this.importEntity.importResources.push(t)}catch(e){this.importEntity.importResourcesErrors.push(new xg("Cannot parse resource",t,e))}}getTotp(e){if(e.fields.get("otp")){const t="object"==typeof e.fields.get("otp")?e.fields.get("otp").getText():e.fields.get("otp"),r=new URL(decodeURIComponent(t));return Sg.createTotpFromUrl(r).toDto()}if("object"==typeof e.fields.get("TimeOtp-Secret-Base32")){return Sg.createTotpFromKdbxWindows(e.fields).toDto()}}getScores(e,t){const r=[];for(let s=0;s<t.length;s++){const i=t.items[s];if("password-string"===i.slug)continue;const a=Object.entries(e).filter((([,e])=>"string"!=typeof e||e.length>0)).map((([e])=>"secret_clear"===e?"password":e));"password-description-totp"===i.slug&&a.includes("totp")&&a.includes("description")&&(e.password="");const o=Object.keys(i.definition.secret.properties),n=i.definition.secret.required,c=a.filter((e=>o.includes(e))),l=n.every((e=>c.includes(e)));r.push({slug:i.slug,value:c.length,hasRequiredFields:l,match:c.length===o.length})}return r}createAndChangeRootFolder(){const e=new yg({name:this.importEntity.ref});this.importEntity.importFolders.changeRootPath(e),this.importEntity.importResources.changeRootPath(e),this.importEntity.importFolders.push(e)}};const Dg=class{static get mapping(){throw new Error("mapping should be overridden by the inherited csv row parser.")}static parse(e,t){throw new Error("parse should be overridden by the inherited csv row parser.")}static canParse(e){const t=t=>e.some((e=>this.mapping[t]===e));if(!["name","secret_clear"].reduce(((e,r)=>e&&t(r)),!0))return 0;return 2+["username","uri","description","folder_parent_path"].reduce(((e,r)=>t(r)?++e:e),0)}};const Mg=class extends Dg{static get mapping(){return{name:"Title",username:"Username",uri:"URL",secret_clear:"Password",description:"Notes",folder_parent_path:"Group",totp:"TOTP"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&("totp"===t.toLowerCase()?s.totp=this.parseTotp(e[this.mapping[t]]):s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return i&&(s.resource_type_id=i.id),new Eg(s)}static parseTotp(e){const t=new URL(decodeURIComponent(e));return Sg.createTotpFromUrl(t).toDto()}};const Lg=class extends Dg{static get mapping(){return{name:"Title",username:"Username",uri:"Url",secret_clear:"Password",description:"Notes",folder_parent_path:"Type"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}};const Fg=class extends Dg{static get mapping(){return{uri:"url",username:"username",secret_clear:"password",totp:"totp",description:"extra",name:"name",folder_parent_path:"grouping",fav:"fav"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}};class qg extends Error{constructor(e){super(e),this.name="FileFormatError"}}const Kg=qg;const Bg=class{static fromBinary(e){const t=new Uint8Array(e.length);for(let r=0;r<t.length;r++)t[r]=e.charCodeAt(r);return new Uint16Array(t.buffer).reduce(((e,t)=>e+String.fromCharCode(t)),"")}static toBinary(e){const t=new Uint16Array(e.length);for(let r=0;r<t.length;r++)t[r]=e.charCodeAt(r);return new Uint8Array(t.buffer).reduce(((e,t)=>e+String.fromCharCode(t)),"")}};var jg=r(4809),zg=r.n(jg);const $g=class extends Dg{static get mapping(){return{name:"name",uri:"url",username:"username",secret_clear:"password"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}};const Vg=class extends Dg{static get mapping(){return{name:"name",username:"login_username",uri:"login_uri",secret_clear:"login_password",description:"notes",folder_parent_path:"folder"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}};const Yg=class extends Dg{static get mapping(){return{name:"Title",uri:"URL",username:"Username",secret_clear:"Password",description:"Notes",OTPAuth:"OTPAuth"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}};const Gg=class extends Dg{static get mapping(){return{username:"username",username2:"username2",username3:"username3",name:"title",secret_clear:"password",description:"note",uri:"url",category:"category",otpSecret:"otpSecret"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}};const Wg=class extends Dg{static get mapping(){return{name:"url",username:"username",uri:"url",secret_clear:"password"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}};const Hg=class extends Dg{static get mapping(){return{name:"name",uri:"url",username:"username",secret_clear:"password",description:"note",cardholdername:"cardholername",cardnumber:"cardnumber",cvc:"cvc",expirydate:"expirydate",zipcode:"zipcode",folder_parent_path:"folder",full_name:"full_name",phone_number:"phone_number",email:"email",address1:"address1",address2:"address2",city:"city",country:"country",state:"state",type:"type"}}static parse(e,t,r){const s={},i=Ng.parseResourceType(e,t,r);i&&(s.resource_type_id=i.id);for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);return new Eg(s)}};const Jg=class extends Dg{static get mapping(){return{name:"name",uri:"url",description:"note",folder_parent_path:"group",username:"username",secret_clear:"password",extra:"extra"}}static parse(e,t,r){const s={};for(const t in this.mapping)e[this.mapping[t]]&&(s[t]=e[this.mapping[t]]);const i=Ng.parseResourceType(s,t,r);return s.resource_type_id=i.id,new Eg(s)}},Zg=[Lg,Mg,Fg,$g,Vg,Yg,Gg,Wg,Hg,Jg];const Qg=class{constructor(e,t,r){this.importEntity=e,this.resourceTypesCollection=t,this.metadataTypesSettings=r}static get register(){return Zg}async parseImport(){const{data:e,fields:t}=this.readCsv(),r=this.getRowParser(t);if(!r)throw new Kg("This csv format is not supported.");const s=this.parseResources(r,e),i=this.parseFolders(s);this.createAndChangeRootFolder(i,s),this.importEntity.importFolders=i,this.importEntity.importResources=s}readCsv(){const e=atob(this.importEntity.file),t=Bg.fromBinary(e),{data:r,meta:{fields:s}}=zg().parse(t,{header:!0,skipEmptyLines:!0});return{data:r,fields:s}}getRowParser(e){let t=null,r=0;for(const s of Zg){const i=s.canParse(e);i>r&&(t=s,r=i)}return t}parseResources(e,t){const r=new Ag([]);return t.forEach((t=>{try{const s=e.parse(t,this.resourceTypesCollection,this.metadataTypesSettings);r.push(s)}catch(e){this.importEntity.importResourcesErrors.push(new xg("Cannot parse resource",t,e))}})),r}parseFolders(e){const t=new wg([]);for(const r of e)try{t.pushFromPath(r.folderParentPath)}catch(e){this.handleParseFolderValidationError(e,r)}return t}handleParseFolderValidationError(e,t){const r={path:t.folderParentPath};this.importEntity.importFoldersErrors.push(new xg("Cannot parse folder",r,e)),t.folderParentPath=""}createAndChangeRootFolder(e,t){const r=new yg({name:this.importEntity.ref});e.changeRootPath(r),t.changeRootPath(r),e.push(r)}};class Xg extends Error{constructor(e){super(e),this.name="FileTypeError"}}const ey=Xg;const ty=class{parseImport(e,t,r){return new(this.getParser(e))(e,t,r).parseImport()}getParser(e){switch(e.fileType.toLowerCase()){case Cg.FILE_TYPE_CSV:return Qg;case Cg.FILE_TYPE_KDBX:return Ug;default:throw new ey(`The file type ${e.fileType} is not supported`)}}};const ry=class{constructor(e,t,r){this.keyring=new xt,this.resourceModel=new Wd(t,e),this.folderModel=new Ud(t,e),this.tagModel=new ng(t,e),this.resourceTypeModel=new Qo(t),this.resourceService=new Go(t),this.executeConcurrentlyService=new Xo,this.progressService=r,this.getOrFindMetadataSettingsService=new Au(e,t),this.encryptService=new qd(t,e),this.account=e}async importFile(e,t){const r=re.getInstance().get().id,s=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t);await this.encryptSecrets(e,r,s),e.mustImportFolders&&await this.bulkImportFolders(e);const i=new po(e.importResources.toResourceCollectionImportDto());return await this.encryptService.encryptAllFromForeignModels(i,t),await this.bulkImportResources(e,i),e.mustTag&&await this.bulkTagResources(e),await this.progressService.finishStep(null,!0),e}async parseFile(e){const t=await this.getOrFindMetadataSettingsService.getOrFindTypesSettings(),r=new ty,s=await this.resourceTypeModel.getOrFindAll();await r.parseImport(e,s,t);const i=1+(e.mustImportFolders?e.importFolders.items.length:0)+2*e.importResources.items.length+(e.mustTag?e.importResources.items.length:0);this.progressService.updateGoals(i)}async encryptSecrets(e,t,r){let s=0;for(const i of e.importResources){s++,await this.progressService.finishStep(ue.t("Encrypting {{counter}}/{{total}}",{counter:s,total:e.importResources.items.length}));const a=this.buildSecretDto(i),o=await this.resourceModel.serializePlaintextDto(i.resourceTypeId,a),n=this.keyring.findPublic(t).armoredKey,c=await Je(n),l=await Rs.encrypt(o,c,[r]),u=new Ga({data:l});i.secrets=new Ha([u])}}buildSecretDto(e){if(e.resourceTypeId){const t={password:e.secretClear||"",description:e.description||"",totp:e.totp||""};return e.secretClear="",e.description="",e.totp=null,t}return e.secretClear}async bulkImportFolders(e){let t=0,r=0;do{const s=e.importFolders.getByDepth(r);if(!s.length)break;const i=wg.toFoldersCollection(s),a=(r,i)=>this.handleImportFolderSuccess.bind(this)(e,++t,r,s[i]),o=(r,i)=>this.handleImportFolderError.bind(this)(e,++t,r,s[i]);await this.folderModel.bulkCreate(i,{successCallback:a,errorCallback:o})}while(++r);const s=e.importFolders.getByPath(e.ref);if(s){const t=await this.folderModel.getById(s.id);e.referenceFolder=t}}async handleImportFolderSuccess(e,t,r,s){s.id=r.id,e.importFolders.setFolderParentIdsByPath(s.path,s.id),e.importResources.setFolderParentIdsByPath(s.path,s.id),await this.progressService.finishStep(ue.t("Importing folders {{importedCount}}/{{total}}",{importedCount:t,total:e.importFolders.items.length}))}async handleImportFolderError(e,t,r,s){await this.progressService.finishStep(ue.t("Importing folders {{importedCount}}/{{total}}",{importedCount:t,total:e.importFolders.items.length})),e.importFoldersErrors.push(new xg("Cannot import folder",s,r)),e.importFolders.removeByPath(s.path),e.importResources.removeByPath(s.path)}async bulkTagResources(e){const t=new Va([{slug:e.ref}]),r=e.importResources.items.filter((e=>e.id)).map((e=>e.id));if(!r.length)return;if(await this.tagModel.updateResourceTags(r[0],t),r.splice(0,1),!r.length)return;let s=0;await this.tagModel.bulkTagResources(r,t,{successCallback:()=>this.handleTagResourceSuccess(e,++s),errorCallback:()=>this.handleTagResourceError(e,++s)})}async handleTagResourceSuccess(e,t){await this.progressService.finishStep(ue.t("Tagging passwords {{taggedCount}}/{{total}}",{taggedCount:t,total:e.importResources.items.length}))}async handleTagResourceError(e,t){await this.progressService.finishStep(ue.t("Tagging passwords {{taggedCount}}/{{total}}",{taggedCount:t,total:e.importResources.items.length}))}async bulkImportResources(e,t){let r=0;const s=await this.resourceTypeModel.getOrFindAll(),i=t.items.map(((t,i)=>async()=>{try{let a;a=s.getFirstById(t.resourceTypeId).isV4()?t.toV4Dto({secrets:!0}):t.toDto({secrets:!0});const o={permission:!0,favorite:!0,tags:!0,folder:!0},n=await this.resourceService.create(a,o),c=new no(n);return this.handleImportResourceSuccess(e,++r,c,e.importResources.items[i]),c}catch(t){console.error(t),this.handleImportResourceError(e,++r,t,e.importResources.items[i])}}));if(i.length>0){const e=await this.executeConcurrentlyService.execute(i,5);await Vo.addResources(e)}}async handleImportResourceSuccess(e,t,r,s){s.id=r.id,await this.progressService.finishStep(ue.t("Importing passwords {{importedCount}}/{{total}}",{importedCount:t,total:e.importResources.items.length}))}async handleImportResourceError(e,t,r,s){await this.progressService.finishStep(ue.t("Importing passwords {{importedCount}}/{{total}}",{importedCount:t,total:e.importResources.items.length})),e.importResourcesErrors.push(new xg("Cannot import resource",s,r))}};const sy=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.progressService=new pc(this.worker,ue.t("Importing ...")),this.getPassphraseService=new oc(s),this.importResourcesService=new ry(s,r,this.progressService)}async _exec(e,t,r){try{const s=await this.exec(e,t,r);this.worker.port.emit(this.requestId,"SUCCESS",s)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t,r){if(!Cg.SUPPORTED_FILE_TYPES.includes(e))throw new ey("The file type is not supported");ge(t),this.progressService.start(100,ue.t("Initialize")),await this.progressService.finishStep(null,!0);try{const s=Cg.buildImportEntity(e,t,r);await this.importResourcesService.parseFile(s);const i=await this.getPassphraseService.getPassphrase(this.worker);return await this.importResourcesService.importFile(s,i)}finally{await this.progressService.close()}}},iy={listen:function(e,t,r){e.port.on("passbolt.import-resources.import-file",(async(s,i,a,o)=>{const n=new sy(e,s,t,r);await n._exec(i,a,o)}))}},ay="kdbx",oy="kdbx-others",ny=[ay,oy,"csv-kdbx","csv-lastpass","csv-1password","csv-chromium","csv-bitwarden","csv-mozilla","csv-safari","csv-dashlane","csv-nordpass","csv-logmeonce"];const cy=class extends $t{constructor(e,t={}){super(e,t),this._props.export_resources&&(this._export_resources=new Ag(this._props.export_resources,{clone:!1}),delete this._props.export_resources),this._props.export_folders&&(this._export_folders=new wg(this._props.export_folders,{clone:!1}),delete this._props.export_folders)}static getSchema(){return{type:"object",required:["format"],properties:{format:{type:"string",enum:ny},resources_ids:{type:"array",nullable:!0,items:{type:"string",format:"uuid"}},folders_ids:{type:"array",nullable:!0,items:{type:"string",format:"uuid"}},export_resources:Ag.getSchema(),export_folders:wg.getSchema(),options:{type:"object",required:[],properties:{credentials:{type:"object",required:[],properties:{password:{type:"string",nullable:!0},keyfile:{type:"string",format:"x-base64",nullable:!0}}}}}}}}get format(){return this._props.format}get foldersIds(){return this._props.folders_ids||null}get resourcesIds(){return this._props.resources_ids||null}get password(){return this._props.options?.credentials?.password||null}get keyfile(){return this._props.options?.credentials?.keyfile||null}get fileType(){return this.format.split("-")[0]}get exportResources(){return this._export_resources||new Ag([])}set exportResources(e){be(e,Ag),this._export_resources=e}get exportFolders(){return this._export_folders||new wg([])}set exportFolders(e){be(e,wg),this._export_folders=e}static get FORMAT_KDBX(){return ay}static get FORMAT_KDBX_OTHERS(){return oy}toBlob(e){return new Blob([this.file],{type:e})}};const ly=class{static get format(){throw new Error("format should be overridden by the inherited class.")}static get mapping(){throw new Error("mapping should be overridden by the inherited class.")}static compose(e){throw new Error("compose should be overridden by the inherited class.")}};const uy=class extends ly{static get format(){return"csv-kdbx"}static get mapping(){return Mg.mapping}static compose(e){const t={},r=e.toDto();for(const s in this.mapping)if("totp"===s&&e.totp){const r=e.totp.createUrlFromExternalResource(e);t[this.mapping[s]]=r.toString()}else t[this.mapping[s]]=r[s]||"";return t}};const dy=class extends ly{static get format(){return"csv-1password"}static get mapping(){return Lg.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const py=class extends ly{static get format(){return"csv-lastpass"}static get mapping(){return Fg.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const hy=class extends ly{static get format(){return"csv-chromium"}static get mapping(){return $g.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const gy=class extends ly{static get format(){return"csv-bitwarden"}static get mapping(){return Vg.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const yy=class extends ly{static get format(){return"csv-mozilla"}static get mapping(){return{uri:"url",username:"username",secret_clear:"password",httpRealm:"httpRealm",formActionOrigin:"formActionOrigin",guid:"guid",timeCreated:"timeCreated",timeLastUsed:"timeLastUsed",timePasswordChanged:"timePasswordChanged"}}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const my=class extends ly{static get format(){return"csv-safari"}static get mapping(){return Yg.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const wy=class extends ly{static get format(){return"csv-dashlane"}static get mapping(){return Gg.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const _y=class extends ly{static get format(){return"csv-nordpass"}static get mapping(){return Hg.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const fy=class extends ly{static get format(){return"csv-logmeonce"}static get mapping(){return Jg.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}},vy=[uy,py,dy,hy,gy,yy,my,wy,_y,fy];const Sy=class{constructor(e){this.exportEntity=e}static get register(){return vy}async export(){const e=this.getRowComposer();if(!e)throw new Kg("This csv format is not supported.");const t=this.exportResources(e),r=Object.values(e.mapping);let s=`"${r.join('","')}"\r\n`;s+=zg().unparse(t,{header:!1,quotes:!0,columns:r}),this.exportEntity.file=s}getRowComposer(){return vy.find((e=>e.format===this.exportEntity.format))||null}exportResources(e){const t=[];for(const r of this.exportEntity.exportResources){const s=e.compose(r);t.push(s)}return t}};const by=class{constructor(e){this.exportEntity=e}async export(){const e=await this.createKdbxDb();this.exportEntity.exportFolders.getByDepth(0).forEach((t=>this.createKdbxGroup(e,t,e.getDefaultGroup())));this.exportEntity.exportResources.getByDepth(0).forEach((t=>this.createKdbxEntry(e,t,e.getDefaultGroup()))),this.exportEntity.file=await e.save()}async createKdbxDb(){const e=this.createKdbxCredentials(),t=Pg.Kdbx.create(e,"passbolt export");return t.setVersion(3),t}createKdbxCredentials(){let e=null,t=null;return this.exportEntity.password&&(e=Pg.ProtectedValue.fromString(this.exportEntity.password)),this.exportEntity.keyfile&&(t=Pg.ByteUtils.base64ToBytes(this.exportEntity.keyfile)),new Pg.Credentials(e,t)}createKdbxGroup(e,t,r){const s=e.createGroup(r,yg.resolveEscapedName(t.name));this.exportEntity.exportFolders.getByFolderParentId(t.id).forEach((t=>this.createKdbxGroup(e,t,s)));this.exportEntity.exportResources.getByFolderParentId(t.id).forEach((t=>this.createKdbxEntry(e,t,s)))}createKdbxEntry(e,t,r){const s=e.createEntry(r);s.fields.set("Title",t.name),s.fields.set("UserName",t.username),t.secretClear&&s.fields.set("Password",Pg.ProtectedValue.fromString(t.secretClear)),t.totp&&this.setTotpField(s,t),s.fields.set("URL",t.uri),s.fields.set("Notes",t.description),t.expired?(s.times.expiryTime=new Date(t.expired),s.times.expires=!0):(s.times.expiryTime=void 0,s.times.expires=!1)}setTotpField(e,t){const r=t.totp;switch(this.exportEntity.format){case cy.FORMAT_KDBX:{e.fields.set("TimeOtp-Secret-Base32",Pg.ProtectedValue.fromString(r.secretKey));const t=`HMAC-${r.algorithm.substring(0,3)}-${r.algorithm.substring(3)}`;e.fields.set("TimeOtp-Algorithm",t),e.fields.set("TimeOtp-Length",r.digits.toString()),e.fields.set("TimeOtp-Period",r.period.toString());break}case cy.FORMAT_KDBX_OTHERS:{const s=r.createUrlFromExternalResource(t);e.fields.set("otp",Pg.ProtectedValue.fromString(s.toString()));break}}}};const Ey=class{export(e){return this.getExporter(e).export()}getExporter(e){switch(e.fileType){case"csv":return new Sy(e);case"kdbx":return new by(e);default:throw new ey(`The format ${e.format} is not supported.`)}}};const ky=class{constructor(e,t,r){this.apiClientOptions=t,this.progressService=r,this.account=e,this.findResourcesService=new Mn(e,t),this.resourceTypeModel=new Qo(t),this.folderModel=new Ud(t,e)}async exportToFile(e,t){const r=await Fr.decryptArmoredKey(this.account.userPrivateArmoredKey,t);await this.decryptSecrets(e,r),await this.export(e)}async prepareExportContent(e){const t=e.resourcesIds.length+2;this.progressService.updateGoals(t),await this.progressService.finishStep(ue.t("Initialize"),!0);const r=await this.folderModel.getAllByIds(e.foldersIds),s=wg.constructFromFoldersCollection(r),i=await this.findResourcesService.findAllForDecrypt(e.resourcesIds),a=Ag.constructFromResourcesCollection(i,s);e.exportFolders=s,e.exportResources=a}async decryptSecrets(e,t){let r=0;const s=await this.resourceTypeModel.getOrFindAll();for(const i of e.exportResources.items){r++,await this.progressService.finishStep(ue.t("Decrypting {{counter}}/{{total}}",{counter:r,total:e.exportResources.items.length}));const a=s.getFirst("id",i.resourceTypeId),o=a?.definition?.secret,n=await Jp.decryptAndParse(i.secrets.items[0],o,t);i.secretClear=n.password||"",i.description=n?.description||i.description||"",n.totp&&(i.totp=new Sg(n.totp))}}async export(e){const t=new Ey;await t.export(e)}};const Ay=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.progressService=new pc(this.worker,ue.t("Exporting ...")),this.getPassphraseService=new oc(s),this.exportResourcesService=new ky(s,r,this.progressService)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new cy(e);this.progressService.start(100,ue.t("Generate file"));try{await this.exportResourcesService.prepareExportContent(t);const e=await this.getPassphraseService.getPassphrase(this.worker);await this.exportResourcesService.exportToFile(t,e);const r=`passbolt-export-${(new Date).toISOString().slice(0,10)}.${t.fileType}`,s={kdbx:"application/x-keepass",csv:"text/csv"}[t.fileType]||"text/plain",i=t.toBlob(s);return await Uc.saveFile(r,i,s,this.worker.tab.id),await this.progressService.finishStep(ue.t("Done"),!0),t}finally{await this.progressService.close()}}},Ty={listen:function(e,t,r){e.port.on("passbolt.export-resources.export-to-file",(async(s,i)=>{const a=new Ay(e,s,t,r);await a._exec(i)}))}};class Iy extends T{constructor(e,t={}){super(U.validate(Iy.ENTITY_NAME,e,Iy.getSchema()),t),this._props.profile&&(this._profile=new Zt(this._props.profile,{clone:!1}),delete this._props.profile)}static getSchema(){const e=lr.getSchema();return e.required=["id","username","profile"],e}toDto(e){const t=Object.assign({},this._props);return e?(this.profile&&e.profile&&(!0===e.profile?t.profile=this.profile.toDto():t.profile=this.profile.toDto(e.profile)),t):t}toJSON(){return this.toDto(Iy.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get username(){return this._props.username}get profile(){return this._profile||null}static get ENTITY_NAME(){return"LoggedUser"}static get ALL_CONTAIN_OPTIONS(){return lr.ALL_CONTAIN_OPTIONS}}const Ry=Iy,Cy=[no.ENTITY_NAME,go.ENTITY_NAME];const Oy=class extends T{constructor(e,t={}){super(e,t),this._props.creator&&(this._creator=new Ry(this._props.creator,{clone:!1}),delete this._props.creator)}static getSchema(){return{type:"object",required:["id","action_log_id","type","creator"],properties:{id:{type:"string",format:"uuid"},action_log_id:{type:"string",format:"uuid"},type:{type:"string",maxLength:100},created:{type:"string",format:"date-time"},creator:Ry.getSchema()}}}toDto(){const e=Object.assign({},this._props);return this._creator&&(e.creator=this.creator.toDto(Ry.ALL_CONTAIN_OPTIONS)),e}toJSON(){return this.toDto()}get id(){return this._props.id||null}get type(){return this._props.type}get actionLogId(){return this._props.action_log_id||null}get created(){return this._props.created||null}get creator(){return this._creator||null}static get ENTITY_NAME(){return"AbstractActionLog"}static get ALLOWED_FOREIGN_MODELS(){return Cy}};class xy extends Oy{constructor(e,t={}){super(U.validate(xy.ENTITY_NAME,e,xy.getSchema()),t)}static get ENTITY_NAME(){return"DefaultActionLog"}}const Py=xy;class Ny extends T{constructor(e,t={}){super(U.validate(Ny.ENTITY_NAME,e,Ny.getSchema()),t),this._props.user&&(this._user=new Ry(this._props.user,{clone:!1}),delete this._props.user),this._props.group&&(this._group=new ca(this._props.group,{clone:!1}),delete this._props.group)}static getSchema(){return{type:"object",required:["id","type"],properties:{id:{type:"string",format:"uuid"},type:{type:"integer",enum:[da.PERMISSION_READ,da.PERMISSION_UPDATE,da.PERMISSION_OWNER]},user:Ry.getSchema(),group:ca.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.user&&e.user&&(!0===e.user?t.user=this.user.toDto():t.user=this.user.toDto(e.user)),this.group&&e.group&&(!0===e.group?t.group=this.group.toDto():t.group=this.group.toDto(e.group)),t):t}toJSON(){return this.toDto(Ny.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get type(){return this._props.type}get user(){return this._user||null}get group(){return this._group||null}static get ENTITY_NAME(){return"UpdatedPermission"}static get ALL_CONTAIN_OPTIONS(){return da.ALL_CONTAIN_OPTIONS}}const Uy=Ny;class Dy extends Ft{constructor(e,t={}){super(U.validate(Dy.ENTITY_NAME,e,Dy.getSchema()),t),this._props.forEach((e=>{const t=new Uy(e,{clone:!1});this.push(t)})),this._props=null}static getSchema(){return{type:"array",items:Uy.getSchema()}}get updatedPermissions(){return this._items}get ids(){return this._items.map((e=>e.id))}assertUniqueId(e){if(!e.id)return;const t=this.updatedPermissions.length;let r=0;for(;r<t;r++){const t=this.updatedPermissions[r];if(t.id&&t.id===e.id)throw new Mt(r,Dy.RULE_UNIQUE_ID,`Updated permission id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("UpdatePermissionsCollection push parameter should be an object.");e instanceof Uy&&(e=e.toDto(Uy.ALL_CONTAIN_OPTIONS));const t=new Uy(e);this.assertUniqueId(t),super.push(t)}static get ENTITY_NAME(){return"UpdatedPermissions"}static get RULE_UNIQUE_ID(){return"unique_id"}}const My=Dy;class Ly extends Oy{constructor(e,t={}){super(U.validate(Ly.ENTITY_NAME,e,Ly.getSchema()),t);let r=[],s=[],i=[];this._props.data&&(this._props.data.permissions&&(this._props.data.permissions.added&&(r=this._props.data.permissions.added),this._props.data.permissions.updated&&(s=this._props.data.permissions.updated),this._props.data.permissions.removed&&(i=this._props.data.permissions.removed)),delete this._props.data),this._permissionsAdded=new My(r,{clone:!1}),this._permissionsUpdated=new My(s,{clone:!1}),this._permissionsRemoved=new My(i,{clone:!1})}static getSchema(){const e=Oy.getSchema();return e.required=[...e.required,"data"],e.properties.type={type:"string",enum:Ly.ALLOWED_TYPES},e.properties.data={type:"object",required:["permissions"],properties:{permissions:{type:"object",properties:{added:My.getSchema(),updated:My.getSchema(),removed:My.getSchema()}}}},e}toDto(){const e=super.toDto();return e.data={permissions:{added:this.permissionsAdded.toDto(),updated:this.permissionsUpdated.toDto(),removed:this.permissionsRemoved.toDto()}},e}toJSON(){return this.toDto()}get permissionsAdded(){return this._permissionsAdded}get permissionsUpdated(){return this._permissionsUpdated}get permissionsRemoved(){return this._permissionsRemoved}static get ENTITY_NAME(){return"PermissionsUpdatedActionLog"}static get ALLOWED_TYPES(){return["Permissions.updated"]}}const Fy=Ly;class qy extends Ft{constructor(e,t={}){super(U.validate(qy.ENTITY_NAME,e,qy.getSchema()),t),this._props.forEach((e=>{const t=this.constructActionLogEntityFromDto(e,{clone:!1});this.push(t)})),this._props=null}static getSchema(){return{type:"array",items:Oy.getSchema()}}constructActionLogEntityFromDto(e,t={}){return Fy.ALLOWED_TYPES.includes(e.type)?new Fy(e,t):new Py(e,t)}get actionLogs(){return this._items}get ids(){return this._items.map((e=>e.id))}assertUniqueId(e){if(!e.id)return;const t=this.actionLogs.length;let r=0;for(;r<t;r++){const t=this.actionLogs[r];if(t.id&&t.id===e.id)throw new Mt(r,qy.RULE_UNIQUE_ID,`Action log id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("ActionLogsCollection push parameter should be an object.");e instanceof Oy&&(e=e.toDto(Object.getPrototypeOf(e).ALL_CONTAIN_OPTIONS));const t=this.constructActionLogEntityFromDto(e);this.assertUniqueId(t),super.push(t)}static get ENTITY_NAME(){return"ActionLogs"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Ky=qy;class By extends dt{constructor(e){super(e,By.RESOURCE_NAME)}static get RESOURCE_NAME(){return"actionlog"}static getSupportedContainOptions(){return[]}static getSupportedFiltersOptions(){return[]}static getSupportedOrdersOptions(){return[]}async findAllFor(e,t,r,s){if(this.assertValidForeignModel(e),this.assertValidId(t),!r||"number"!=typeof r)throw new TypeError("ActionLog page should be a valid integer.");if(!s||"number"!=typeof s)throw new TypeError("ActionLog limit should be a valid integer.");const i=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e.toLowerCase()}/${t}`);i.searchParams.append("page",r.toString()),i.searchParams.append("limit",s.toString());const a=await this.apiClient.fetchAndHandleResponse("GET",i);return a.body&&a.body.length?a.body:[]}assertValidForeignModel(e){if(!e||"string"!=typeof e)throw new TypeError("ActionLog foreign model should be a valid string.");if(!Oy.ALLOWED_FOREIGN_MODELS.includes(e))throw new TypeError(`ActionLog foreign model ${e} in not in the list of supported models.`)}}const jy=By;const zy=class{constructor(e){this.actionLogService=new jy(e)}async findAllFor(e,t,r,s){const i=await this.actionLogService.findAllFor(e,t,r,s);return new Ky(i)}},$y={listen:function(e,t){e.port.on("passbolt.actionlogs.find-all-for",(async(r,s,i,a)=>{try{const o=new zy(t),{limit:n,page:c}=a,l=await o.findAllFor(s,i,c,n);e.port.emit(r,"SUCCESS",l)}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}}))}};class Vy extends dt{constructor(e){super(e,Vy.RESOURCE_NAME)}static get RESOURCE_NAME(){return"mfa"}async disableMfaForUser(e){this.assertValidId(e);const t=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/${e}`);return this.apiClient.fetchAndHandleResponse("DELETE",t)}async getSettings(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/select`);return(await this.apiClient.fetchAndHandleResponse("GET",e)).body}async getMfaToTpSetupInfo(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/totp`);return(await this.apiClient.fetchAndHandleResponse("GET",e)).body}async setupTotp(e){const t=this.apiClient.buildBody(e),r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/totp`);await this.apiClient.fetchAndHandleResponse("POST",r,t)}async setupYubikey(e){const t=this.apiClient.buildBody(e),r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/yubikey`);await this.apiClient.fetchAndHandleResponse("POST",r,t)}async verifyProvider(e){const t=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/${e}`);return(await this.apiClient.fetchAndHandleResponse("GET",t)).body}async removeProvider(e){const t=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/${e}`);return(await this.apiClient.fetchAndHandleResponse("DELETE",t)).body}}const Yy=Vy;class Gy extends dt{constructor(e){super(e,Gy.RESOURCE_NAME)}static get RESOURCE_NAME(){return"mfa-policies"}async find(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/settings`);return(await this.apiClient.fetchAndHandleResponse("GET",e)).body}}const Wy=Gy;class Hy extends T{constructor(e,t={}){super(U.validate(Hy.ENTITY_NAME,e,Hy.getSchema()),t)}static getSchema(){return{type:"object",required:["policy","remember_me_for_a_month"],properties:{policy:{type:"string",enum:Hy.SUPPORTED_POLICY_TYPE},remember_me_for_a_month:{type:"boolean"}}}}get policy(){return this._props.policy}get rememberMeForAMonth(){return this._props.remember_me_for_a_month}static get ENTITY_NAME(){return"Mfa-Policy"}static get SUPPORTED_POLICY_TYPE(){return[Hy.OPTIN,Hy.MANDATORY]}static get OPTIN(){return"opt-in"}static get MANDATORY(){return"mandatory"}}const Jy=Hy;class Zy extends T{constructor(e,t={}){super(U.validate(Zy.ENTITY_NAME,e,Zy.getSchema()),t)}static getSchema(){return{type:"object",required:["totp","duo","yubikey"],properties:{yubikey:{type:"boolean"},totp:{type:"boolean"},duo:{type:"boolean"}}}}get yubikey(){return this._props.yubikey}get totp(){return this._props.totp}get duo(){return this._props.duo}static get ENTITY_NAME(){return"MfaEnabledProvider"}}const Qy=Zy;class Xy extends T{constructor(e,t={}){super(U.validate(Xy.ENTITY_NAME,e,Xy.getSchema()),t),this._props.MfaOrganizationSettings&&(this._mfaOrganizationSettings=new Qy(this._props.MfaOrganizationSettings,{clone:!1}),delete this._props.MfaOrganizationSettings),this._props.MfaAccountSettings&&(this._mfaAccountSettings=new Qy(this._props.MfaAccountSettings,{clone:!1}),delete this._props.MfaAccountSettings)}static getSchema(){return{type:"object",required:["MfaOrganizationSettings","MfaAccountSettings"],properties:{MfaOrganizationSettings:Qy.getSchema(),MfaAccountSettings:Qy.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._mfaAccountSettings&&e.MfaAccountSettings&&(t.MfaAccountSettings=this._mfaAccountSettings.toDto()),this._mfaOrganizationSettings&&e.MfaOrganizationSettings&&(t.MfaOrganizationSettings=this._mfaOrganizationSettings.toDto()),t):t}toJSON(){return this.toDto(Xy.ALL_CONTAIN_OPTIONS)}get MfaOrganizationSettings(){return this._mfaOrganizationSettings}get MfaAccountSettings(){return this._mfaAccountSettings}static get ENTITY_NAME(){return"MfaCombinedEnabledProviders"}static get ALL_CONTAIN_OPTIONS(){return{MfaOrganizationSettings:!0,MfaAccountSettings:!0}}}const em=Xy;class tm extends T{constructor(e,t={}){super(U.validate(tm.ENTITY_NAME,e,tm.getSchema()),t)}static getSchema(){return{type:"object",required:["verified"],properties:{verified:{type:"string",format:"date-time"}}}}static get ENTITY_NAME(){return"MfaVerifyProvider"}}const rm=tm;class sm extends T{constructor(e,t={}){super(U.validate(sm.ENTITY_NAME,e,sm.getSchema()),t)}static getSchema(){return{type:"object",required:["otpProvisioningUri"],properties:{otpProvisioningUri:{type:"string",pattern:/^otpauth:\/\/totp\/([^?]+)\?issuer=([^&]+)&secret=([A-Za-z0-9]+)$/}}}}static get ENTITY_NAME(){return"MfaTotpSetupInfoEntity"}}const im=sm;const am=class{constructor(e){this.multiFactorAuthenticationService=new Yy(e),this.multiFactorAuthenticationPolicyService=new Wy(e)}async disableForUser(e){await this.multiFactorAuthenticationService.disableMfaForUser(e);const t=await oa.getUserById(e);if(t){t.is_mfa_enabled=!1;const e=new lr(t);await oa.updateUser(e)}}async getPolicy(){const e=await this.multiFactorAuthenticationPolicyService.find();return new Jy(e)}async getMfaToTpSetupInfo(){const e=await this.multiFactorAuthenticationService.getMfaToTpSetupInfo();return new im(e).toDto().otpProvisioningUri}async getMfaSettings(){const e=await this.multiFactorAuthenticationService.getSettings();return new em(e)}async setupTotp(e){await this.multiFactorAuthenticationService.setupTotp(e.toDto())}async setupYubikey(e){await this.multiFactorAuthenticationService.setupYubikey(e.toDto())}async verifyProvider(e){const t=await this.multiFactorAuthenticationService.verifyProvider(e.provider);return new rm(t)}async removeProvider(e){await this.multiFactorAuthenticationService.removeProvider(e.provider)}},om={listen:function(e,t){e.port.on("passbolt.mfa.disable-for-user",(async(r,s)=>{try{const i=new am(t);await i.disableForUser(s),e.port.emit(r,"SUCCESS")}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}}))}};class nm extends dt{constructor(e){super(e,nm.RESOURCE_NAME)}static get RESOURCE_NAME(){return"account/settings"}async findAll(){return this.apiClient.findAll().body}async findAllThemes(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/themes`);return(await this.apiClient.fetchAndHandleResponse("GET",e)).body}async updateTheme(e){const t={value:e},r=this.apiClient.buildBody(t),s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/themes`);return(await this.apiClient.fetchAndHandleResponse("POST",s,r)).body}async updateLocale(e){const t={value:e},r=this.apiClient.buildBody(t),s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/locales`);return(await this.apiClient.fetchAndHandleResponse("POST",s,r)).body}}const cm=nm;class lm extends T{constructor(e,t={}){super(U.validate(lm.ENTITY_NAME,e,lm.getSchema()),t)}static getSchema(){return{type:"object",required:["id","name","preview"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",pattern:/^[a-zA-Z0-9-_]*$/},preview:{type:"string",format:"x-url"}}}}get id(){return this._props.id}get name(){return this._props.name}get preview(){return this._props.preview}static get ENTITY_NAME(){return"Theme"}}const um=lm;class dm extends Ft{constructor(e,t={}){super(U.validate(dm.ENTITY_NAME,e,dm.getSchema()),t),this._props.forEach((e=>{this.push(new um(e,{clone:!1}))})),this._props=null}static getSchema(){return{type:"array",items:um.getSchema()}}get themes(){return this._items}assertUniqueId(e){if(!e.id)return;const t=this.items.findIndex((t=>t.id===e.id));if(-1!==t)throw new Mt(t,dm.RULE_UNIQUE_ID,`Theme id ${e.id} already exists.`)}assertUniqueName(e){if(!e.name)return;const t=this.items.findIndex((t=>t.name===e.name));if(-1!==t)throw new Mt(t,dm.RULE_UNIQUE_NAME,`Theme name ${e.name} already exists.`)}push(e){if(!e||"object"!=typeof e)throw new TypeError("ThemesCollection push parameter should be an object.");e instanceof um&&(e=e.toDto());const t=new um(e);this.assertUniqueId(t),this.assertUniqueName(t),super.push(t)}static get ENTITY_NAME(){return"Themes"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_NAME(){return"unique_name"}}const pm=dm;const hm=class{constructor(e){this.accountSettingsService=new cm(e)}async findAll(){const e=await this.accountSettingsService.findAllThemes();return new pm(e)}async change(e){await this.accountSettingsService.updateTheme(e.name),u("user.settings.theme",e.name)}};class gm extends T{constructor(e,t={}){super(U.validate(gm.ENTITY_NAME,e,gm.getSchema()),t)}static getSchema(){return{type:"object",required:["name"],properties:{name:um.getSchema().properties.name}}}get name(){return this._props.name}static get ENTITY_NAME(){return"ChangeTheme"}}const ym=gm,mm={listen:function(e,t){e.port.on("passbolt.themes.find-all",(async r=>{try{const s=new hm(t),i=await s.findAll();e.port.emit(r,"SUCCESS",i)}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.themes.change",(async(r,s)=>{try{const i=new hm(t),a=new ym({name:s});await i.change(a),e.port.emit(r,"SUCCESS")}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}}))}};class wm extends T{constructor(e,t={}){super(U.validate(wm.ENTITY_NAME,e,wm.getSchema()),t)}static getSchema(){return{type:"object",required:["locale"],properties:{locale:{type:"string",pattern:/^[a-z]{2}-[A-Z]{2}$/},label:{type:"string"}}}}get locale(){return this._props.locale}get label(){return this._props.label}static get ENTITY_NAME(){return"Locale"}}const _m=wm;class fm extends Ft{constructor(e,t={}){super(U.validate(fm.ENTITY_NAME,e,fm.getSchema()),t),this._props.forEach((e=>{this._items.push(new _m(e,{clone:!1}))})),this._props=null}static getSchema(){return{type:"array",items:_m.getSchema()}}get locales(){return this._items}push(e){if(!e||"object"!=typeof e)throw new TypeError("LocalesCollection push parameter should be an object.");e instanceof _m&&(e=e.toDto());const t=new _m(e);super.push(t)}static get ENTITY_NAME(){return"Locales"}}const vm=fm;class Sm{static get DEFAULT_LOCALE(){return new _m({locale:"en-UK",label:"English"})}static get DEFAULT_SUPPORTED_LOCALES(){return new vm([Sm.DEFAULT_LOCALE])}constructor(e){this.accountSettingsService=new cm(e),this.organizationSettingsModel=new wt(e)}async initializeI18next(e){const t=(await this.getSupportedOrganizationLocales()).locales.map((e=>e.locale));ue.init(e.locale,t)}async getOrganizationLocale(){const e=await this.organizationSettingsModel.getOrFind();return this.getSupportedLocale(e.locale)}async getSupportedOrganizationLocales(){const e=await this.organizationSettingsModel.getOrFind();if(e.isPluginEnabled("locale")){const t=e.getPluginSettings("locale");return new vm(t.options||[])}return Sm.DEFAULT_SUPPORTED_LOCALES}async getSupportedLocale(e){return(await this.getSupportedOrganizationLocales()).locales.find((t=>t.locale===e))}async getLocaleWithSimilarLanguage(e){const t=e.split("-")[0];return(await this.getSupportedOrganizationLocales()).locales.find((e=>t===e.locale.split("-")[0]))}async updateUserLocale(e){await this.accountSettingsService.updateLocale(e.locale),u("user.settings.locale",e.locale)}}const bm=Sm;const Em=class{constructor(e,t){this.worker=e,this.localeModel=new bm(t)}async getLocale(){let e;const t=await l("user.settings.locale");t&&(e=new _m({locale:t}));const r=e||await this.localeModel.getOrganizationLocale()||bm.DEFAULT_LOCALE;return this.localeModel.initializeI18next(r),r}},km={listen:function(e,t){e.port.on("passbolt.locale.get",(async r=>{const s=new Em(e,t);try{const t=await s.getLocale();e.port.emit(r,"SUCCESS",t)}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.locale.update-user-locale",(async(r,s)=>{const i=new bm(t);try{const t=new _m(s);await i.updateUserLocale(t),e.port.emit(r,"SUCCESS")}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}}))}};class Am extends dt{constructor(e){super(e,Am.RESOURCE_NAME)}static get RESOURCE_NAME(){return"mobile/transfers"}async get(e){this.assertValidId(e);return(await this.apiClient.get(e)).body}async create(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}async update(e,t){this.assertValidId(e),this.assertNonEmptyData(t);return(await this.apiClient.update(e,t)).body}}const Tm=Am;class Im extends T{constructor(e,t={}){super(U.validate(Im.ENTITY_NAME,e,Im.getSchema()),t),this._props.authentication_token&&(this._authentication_token=new es(this._props.authentication_token,{clone:!1}),delete this._props.authentication_token)}static getSchema(){return{type:"object",required:["total_pages"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},hash:{type:"string"},current_page:{type:"integer"},total_pages:{type:"integer"},status:{type:"string",enum:[Im.TRANSFER_STATUS_START,Im.TRANSFER_STATUS_COMPLETE,Im.TRANSFER_STATUS_IN_PROGRESS,Im.TRANSFER_STATUS_ERROR,Im.TRANSFER_STATUS_CANCEL]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},authentication_token:es.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._authentication_token&&e.authentication_token&&(t.authentication_token=this._authentication_token.toDto()),t):t}toJSON(){return this.toDto(Im.ALL_CONTAIN_OPTIONS)}static get ALL_CONTAIN_OPTIONS(){return{authentication_token:!0}}get id(){return this._props.id}get created(){return this._props.created||null}get modified(){return this._props.modified||null}static get ENTITY_NAME(){return"transfer"}static get TRANSFER_STATUS_START(){return"start"}static get TRANSFER_STATUS_IN_PROGRESS(){return"in progress"}static get TRANSFER_STATUS_COMPLETE(){return"complete"}static get TRANSFER_STATUS_CANCEL(){return"cancel"}static get TRANSFER_STATUS_ERROR(){return"error"}}const Rm=Im;const Cm=class{constructor(e){this.mobileTransferService=new Tm(e)}async get(e){const t=await this.mobileTransferService.get(e);return new Rm(t)}async create(e){const t=await this.mobileTransferService.create(e.toDto());return new Rm(t)}async update(e){const t=await this.mobileTransferService.update(e.id,e.toDto());return new Rm(t)}},Om={listen:function(e,t){e.port.on("passbolt.mobile.transfer.get",(async(r,s)=>{try{const i=new Cm(t),a=await i.get(s);e.port.emit(r,"SUCCESS",a)}catch(t){e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.mobile.transfer.create",(async(r,s)=>{try{const i=new Cm(t),a=new Rm(s),o=await i.create(a);e.port.emit(r,"SUCCESS",o)}catch(t){e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.mobile.transfer.update",(async(r,s)=>{try{const i=new Cm(t),a=new Rm(s),o=await i.update(a);e.port.emit(r,"SUCCESS",o)}catch(t){e.port.emit(r,"ERROR",t)}}))}};class xm extends Error{constructor(e){super(e=e||ue.t("The external service is unavailable")),this.name="ExternalServiceUnavailableError"}}const Pm=xm;class Nm extends Error{constructor(e){super(e=e||ue.t("The external service raised an error")),this.name="ExternalServiceError"}}const Um=Nm;const Dm=class{static async checkIfPasswordIsPowned(e){if("string"!=typeof e){const e=new Error("Input password must be a string.");return Promise.reject(e)}const t=new Qe.A("SHA-1","TEXT");t.update(e);const r=t.getHash("HEX"),s=r.substr(0,5),i=r.substr(5),a="https://api.pwnedpasswords.com/range/"+s;let o;try{o=await fetch(a)}catch(e){throw new Pm("pwnedpasswords API service is not available")}if(200!==o.status)throw new Um(`Failed to request pwnedpasswords API: ${o.status}`);return(await o.text()).split("\n").map((e=>e.split(":"))).filter((e=>e[0].toLowerCase()===i)).map((e=>Number(e[1]))).shift()||0}};const Mm=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return Dm.checkIfPasswordIsPowned(e)}},Lm={listen:function(e){e.port.on("passbolt.secrets.powned-password",(async(t,r)=>{const s=new Mm(e,t);await s._exec(r)}))}};const Fm=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){Oc.postponeMFAPolicy()}};const qm=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new am(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return this.multiFactorAuthenticationModel.getPolicy()}};const Km=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new am(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return this.multiFactorAuthenticationModel.getMfaSettings()}};const Bm=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return Oc.hasPostponedMFAPolicy()}};class jm extends T{constructor(e,t={}){super(U.validate(jm.ENTITY_NAME,e,jm.getSchema()),t)}static getSchema(){return{type:"object",required:["otpProvisioningUri","totp"],properties:{totp:{type:"string",pattern:/^[a-z0-9]{6}$/},otpProvisioningUri:{type:"string"}}}}static get ENTITY_NAME(){return"MfaSetupTotp"}}const zm=jm;const $m=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new am(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new zm(e);await this.multiFactorAuthenticationModel.setupTotp(t)}};class Vm extends T{constructor(e,t={}){super(U.validate(Vm.ENTITY_NAME,e,Vm.getSchema()),t)}static getSchema(){return{type:"object",required:["provider"],properties:{provider:{type:"string",enum:["yubikey","totp","duo"]}}}}get provider(){return this._props.provider}static get ENTITY_NAME(){return"MfaProviderEntity"}}const Ym=Vm;const Gm=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new am(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new Ym(e);return await this.multiFactorAuthenticationModel.verifyProvider(t)}};const Wm=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new am(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new Ym(e);await this.multiFactorAuthenticationModel.removeProvider(t)}};class Hm extends T{constructor(e,t={}){super(U.validate(Hm.ENTITY_NAME,e,Hm.getSchema()),t)}static getSchema(){return{type:"object",required:["hotp"],properties:{hotp:{type:"string",pattern:/^[cbdefghijklnrtuv]{44}$/}}}}static get ENTITY_NAME(){return"MfaSetupYubikeyEntity"}}const Jm=Hm;const Zm=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new am(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new Jm(e);return await this.multiFactorAuthenticationModel.setupYubikey(t)}};const Qm=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new am(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return await this.multiFactorAuthenticationModel.getMfaToTpSetupInfo()}},Xm={listen:function(e,t){e.port.on("passbolt.mfa-policy.has-user-postponed-user-setting-invitation",(async t=>{const r=new Bm(e,t);await r._exec()})),e.port.on("passbolt.mfa-policy.postpone-user-setting-invitation",(async t=>{const r=new Fm(e,t);await r._exec()})),e.port.on("passbolt.mfa-policy.get-policy",(async r=>{const s=new qm(e,r,t);await s._exec()})),e.port.on("passbolt.mfa-policy.get-mfa-settings",(async r=>{const s=new Km(e,r,t);await s._exec()})),e.port.on("passbolt.mfa-setup.verify-provider",(async(r,s)=>{const i=new Gm(e,r,t);await i._exec(s)})),e.port.on("passbolt.mfa-setup.verify-totp-code",(async(r,s)=>{const i=new $m(e,r,t);await i._exec(s)})),e.port.on("passbolt.mfa-setup.verify-yubikey-code",(async(r,s)=>{const i=new Zm(e,r,t);await i._exec(s)})),e.port.on("passbolt.mfa-setup.remove-provider",(async(r,s)=>{const i=new Wm(e,r,t);await i._exec(s)})),e.port.on("passbolt.mfa-setup.get-totp-code",(async(r,s)=>{const i=new Qm(e,r,t);await i._exec(s)}))}};const ew=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){await navigator.clipboard.writeText(e)}},tw={listen:function(e){e.port.on("passbolt.clipboard.copy",(async(t,r)=>{const s=new ew(e,t,r);await s._exec(r)}))}};const rw=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.userRememberMeLatestChoiceLocalStorage=new rc(r)}async _exec(){try{const e=await this.exec.apply(this,arguments);this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await this.userRememberMeLatestChoiceLocalStorage.get();return-1===e?.duration}},sw={listen:function(e,t,r){e.port.on("passbolt.remember-me.get-user-latest-choice",(async t=>{const s=new rw(e,t,r);await s._exec()}))}};class iw extends dt{constructor(e){super(e,iw.RESOURCE_NAME)}static get RESOURCE_NAME(){return"permissions/resource"}static getSupportedContainOptions(){return["user","user.profile","group"]}async findAllByAcoForeignKey(e,t){this.assertValidId(e);const r=t?this.formatContainOptions(t,iw.getSupportedContainOptions()):null;return(await this.apiClient.get(e,r)).body}}const aw=iw;class ow{constructor(e,t){this.account=e,this.permissionService=new aw(t)}async findAllByAcoForeignKeyForDisplay(e){he(e,`Service error. The id '${e}' is not a valid uuid.`);const t=await this.permissionService.findAllByAcoForeignKey(e,ow.DEFAULT_CONTAIN);return new ha(t)}static get DEFAULT_CONTAIN(){return{user:!0,"user.profile":!0,group:!0}}}const nw=ow;const cw=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.findPermissionService=new nw(s,r),this.findFolderService=new xd(r)}async _exec(e,t){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){if(he(e),ve(t),t===da.ACO_RESOURCE)return this.findPermissionService.findAllByAcoForeignKeyForDisplay(e);if(t===da.ACO_FOLDER){return(await this.findFolderService.findByIdWithPermissions(e)).permissions}}},lw={listen:function(e,t,r){e.port.on("passbolt.permissions.find-aco-permissions-for-display",(async(s,i,a)=>{const o=new cw(e,s,t,r);await o._exec(i,a)}))}};const uw=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.account.toDto({security_token:!0})}},dw={listen:function(e,t,r){e.port.on("passbolt.account.get",(async t=>{const s=new uw(e,t,r);await s._exec()}))}};const pw=new class extends z{get appName(){return"App"}get events(){return[ie,Iu,yd,Qd,Op,Pp,zp,Wp,th,rh,oh,wh,Ah,Yh,ig,lg,hg,iy,Ty,$y,om,mm,km,Om,Lm,Xm,tw,sw,lw,dw]}async attachEvents(e){try{const t=e._port.sender.tab,r=new Fo,s=await r.checkAuthStatus(!0);if(!s.isAuthenticated||s.isMfaRequired)return void console.error("Can not attach application if user is not logged in.");const i=new zn;await i.main();const a=await Ro.get({role:!0}),o=ta.buildFromAccount(a);for(const r of this.events)r.listen({port:e,tab:t},o,a)}catch(e){console.error("appPagemod::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}}};var hw=r(7946);const gw=class{static async flush(){return m.write({level:"debug",message:"PasswordGeneratorLocalStorage flushed"}),await hw.storage.local.remove("passwordGenerator")}};class yw{static async flush(){Vo.flush(),Ho.flush(),vd.flush(),Lo.flush(),oa.flush(),Ch.flush(),qp.flush(),gw.flush(),Oc.reset(),Wi.flush(),Ri.flush(),ac.stop(),yw.flushAccountBasedStorages()}static async flushAccountBasedStorages(){if(!re.getInstance().isValid())return;const e=await Io.get();new hl(e).flush(),new Fl(e).flush(),new nu(e).flush(),new yu(e).flush(),new hn(e).flush(),new Cn(e).flush(),Ao.remove(e)}}const mw=yw;var ww=r(7946);const _w="resourceInProgress";const fw=new class{constructor(){this.bindCallbacks(),this.timeoutId=null}bindCallbacks(){this.reset=this.reset.bind(this)}async consume(){const e=await ww.storage.session.get(_w);return this.reset(),e?.[_w]||null}async set(e,t=6e3){if(!(e instanceof Eg))throw new TypeError("ResourceInProgressCacheService::set expects a ExternalResourceEntity");this.reset(),await ww.storage.session.set({[_w]:e.toDto()}),this.timeoutId=setTimeout(this.reset,t)}reset(){ww.storage.session.remove(_w),clearTimeout(this.timeoutId)}};const vw=class{constructor(e){this.worker=e}async autosave(e){const t=new URL(e.url),r={name:e.name,uri:`${t.protocol}//${t.host}${t.pathname}`,username:e.username,secret_clear:e.password},s=new Eg(r);await fw.set(s),Jn.openInDetachedMode([{name:"uiMode",value:"detached"},{name:"feature",value:"autosave-credentials"}])}},Sw={WebIntegration:["InFormCallToAction","InFormMenu"]};const bw=class{constructor(e){this.worker=e}async _exec(e){try{await this.exec(e)}catch(e){console.error(e)}}async exec(e){if("string"!=typeof e)throw new Error("The application name should be a string");if(!this.isAllowedToRemovePort(this.worker.name,e))throw new Error(`The application is not allowed to close the application ${e}`);const t=this.worker.tab,r=await j.getWorkersByNameAndTabId(e,t.id);if(1===r.length){const e=r[0].id;W_.removePort(e,{reason:"disconnected"}),await j.deleteById(e)}else r.length>1&&await Promise.all(r.map((e=>this.removePortReference(e.id))))}isAllowedToRemovePort(e,t){return Sw[e]?.includes(t)}async removePortReference(e){if(W_.isPortExist(e)){const t=W_.getPortById(e);try{t.emit("passbolt.port.check")}catch(t){console.debug("The port is not connected, remove references"),W_.removePort(e,{reason:"disconnected"}),await j.deleteById(e)}}else await j.deleteById(e)}},Ew={listen:function(e){e.port.on("passbolt.web-integration.autosave",(async t=>{const r=new vw(e);await r.autosave(t)})),e.port.on("passbolt.port.disconnect",(async t=>{const r=new bw(e);await r._exec(t)}))}};const kw=class{static get regex(){const e=re.getInstance().settings.getDomain().replace(/\W/g,"\\$&");return new RegExp(`^(?!(${e}|chrome:|about:|https://(www.passbolt|mail.google).com)).*$`)}static test(e){try{return new URL(e),this.regex.test(e)}catch(e){return!1}}};const Aw=new class extends z{get appName(){return"WebIntegration"}get contentStyleFiles(){return[]}get contentScriptFiles(){return["contentScripts/js/dist/browser-integration/vendors.js","contentScripts/js/dist/browser-integration/browser-integration.js"]}get events(){return[ie,Ew,rh,G]}async canBeAttachedTo(e){return this.assertTopFrameAttachConstraint(e)&&await this.assertUrlAttachConstraint(e)}assertTopFrameAttachConstraint(e){return e.frameId===z.TOP_FRAME_ID}async assertUrlAttachConstraint(e){try{return await Ro.get(),kw.test(e.url)}catch(e){return console.log(e),!1}}};const Tw=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){chrome.tabs.update(this.worker.tab.id,{url:this.account.domain})}},Iw={listen:function(e,t,r){e.port.on("passbolt.extension.sign-in-url",(async t=>{const s=new Tw(e,t,r);await s._exec()}))}};const Rw=class{static get regex(){return new RegExp("^https://(www.)?passbolt.com(/.*|#.*)?$")}static test(e){return this.regex.test(e)}};const Cw=new class extends z{get appName(){return"PublicWebsiteSignIn"}get contentScriptFiles(){return["contentScripts/js/dist/public-website-sign-in/vendors.js","contentScripts/js/dist/public-website-sign-in/public-website-sign-in.js"]}get events(){return[Iw]}async canBeAttachedTo(e){return this.assertTopFrameAttachConstraint(e)&&this.assertUrlAttachConstraint(e)&&await this.assertUserValidConstraint()}async attachEvents(e){try{const t=e._port.sender.tab,r=await Ro.get();for(const s of this.events)s.listen({port:e,tab:t},null,r)}catch(e){console.error("PublicWebsiteSignIn::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}}assertTopFrameAttachConstraint(e){return e.frameId===z.TOP_FRAME_ID}assertUrlAttachConstraint(e){return Rw.test(e.url)}async assertUserValidConstraint(){try{return await Ro.get(),!0}catch(e){return console.log(e),!1}}};var Ow=r(7946);const xw="passboltExtensionUpdate";class Pw{static async exec(){await Nw()?await Ow.storage.session.set({[xw]:!0}):await Pw.cleanAndReload()}static async cleanAndReload(){await zs.destroyWorkersByName([Aw.appName,Cw.appName]),Ow.runtime.reload()}static async handleUserLoggedOut(){const e=await Ow.storage.session.get(xw);e&&e[xw]&&(await Ow.storage.session.remove(xw),await Pw.cleanAndReload())}}const Nw=async()=>{if(re.getInstance().isValid())try{return await Do.isAuthenticated()}catch(e){if(e instanceof Oo)return!0;console.debug("The Service is unavailable to check if the user is authenticated"),console.error(e)}return!1},Uw=Pw;var Dw=r(7946);const Mw=class{constructor(e,t,r){this.worker=e,this.resourceModel=new Wd(t,r),this.checkAuthStatusService=new Fo,this.getOrFindResourcesService=new qn(r,t)}async countSuggestedResourcesCount(e){try{const t=await this.getOrFindResourcesService.getOrFindSuggested(this.worker.tab.url);this.worker.port.emit(e,"SUCCESS",t.length)}catch(t){console.error(t),this.worker.port.emit(e,"ERROR",t)}}async execute(e){try{const t=await this.checkAuthStatusService.checkAuthStatus(!1);if(t.isAuthenticated)if(t.isMfaRequired)Dw.tabs.create({url:re.getInstance().settings.getDomain(),active:!0}),this.worker.port.emit(e,"SUCCESS");else{(await zs.get("WebIntegration",this.worker.tab.id)).port.emit("passbolt.in-form-menu.open")}else{const t=[{name:"uiMode",value:"detached"},{name:"feature",value:"login"}];await Jn.openInDetachedMode(t),this.worker.port.emit(e,"SUCCESS")}}catch(t){console.error(t),this.worker.port.emit(e,"ERROR",t)}}},Lw={listen:function(e,t,r){e.port.on("passbolt.in-form-cta.check-status",(async(t,r=!1)=>{const s=new Uu(e,t);await s._exec(r)})),e.port.on("passbolt.in-form-cta.suggested-resources",(async s=>{const i=new Mw(e,t,r);await i.countSuggestedResourcesCount(s)})),e.port.on("passbolt.in-form-cta.execute",(async s=>{const i=new Mw(e,t,r);await i.execute(s)}))}};const Fw=new class extends z{get appName(){return"InFormCallToAction"}get events(){return[Lw]}async attachEvents(e){try{const t=e._port.sender.tab,r=await Ro.get(),s=ta.buildFromAccount(r),i=this.appName;for(const a of this.events)a.listen({port:e,tab:t,name:i},s,r)}catch(e){console.error("InFormMenu::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}}};class qw{static async exec(){await qw.sendLogoutEventForWorkers(),await mw.flush(),await zw.clearAlarm(),jn.handleUserLoggedOut(),fw.reset(),Uw.handleUserLoggedOut()}static async sendLogoutEventForWorkers(){await zs.emitOnWorkersWithName("passbolt.auth.after-logout",[pw.appName,Fw.appName])}}const Kw=qw;var Bw=r(7946);class jw{static async exec(){await Bw.alarms.create(jw.ALARM_NAME,{periodInMinutes:1,when:Date.now()+6e4})}static async clearAlarm(){await Bw.alarms.clear(jw.ALARM_NAME)}static async handleAuthStatusCheckAlarm(e){if(e.name!==jw.ALARM_NAME)return;const t=new Fo;(await t.checkAuthStatus(!0)).isAuthenticated||Kw.exec()}static get ALARM_NAME(){return"AuthSessionCheck"}}const zw=jw;class $w{static async exec(){await $w.sendLoginEventForWorkers(),await zw.exec(),jn.handleUserLoggedIn()}static async sendLoginEventForWorkers(){await zs.emitOnWorkersWithName("passbolt.auth.after-login",[Fw.appName])}}const Vw=$w;var Yw=r(7946);const Gw=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.authVerifyLoginChallengeService=new ji(r),this.updateSsoCredentialsService=new Ni(r),this.checkPassphraseService=new Js(new xt)}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e=!1){const t=await ms.exec(this.worker.port._port.name);if(void 0===t.passphrase)throw new Error("A passphrase is required.");if("string"!=typeof t.passphrase)throw new Error("The passphrase should be a string.");if(void 0!==e&&"boolean"!=typeof e)throw new Error("The rememberMe should be a boolean.");await this.checkPassphraseService.checkPassphrase(t.passphrase),await this.updateSsoCredentialsService.forceUpdateSsoKit(t.passphrase),await this.authVerifyLoginChallengeService.verifyAndValidateLoginChallenge(t.account.userKeyFingerprint,t.account.userPrivateArmoredKey,t.passphrase),e?await Promise.all([Wi.set(t.passphrase,-1),ac.start()]):await Wi.set(t.passphrase,60),await Vw.exec(),await this.redirectToApp(t.account.domain),await ys.remove()}async redirectToApp(e){Yw.tabs.update(this.worker.tab.id,{url:e})}};const Ww=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.localeModel=new bm(r),this.account=s}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this.localeModel.getSupportedLocale(e.locale);if(!t)throw new Error("Unsupported locale.");const r=await ys.get(this.worker.port._port.name);r&&(r.account.locale=t.locale,await ys.set(r)),this.account.locale=t.locale,await this.localeModel.initializeI18next(t)}};const Hw=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.organizationSettingsModel=new wt(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.organizationSettingsModel.getOrFind(!0)}};const Jw=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.localeModel=new bm(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;this.account.locale&&(e=await this.localeModel.getSupportedLocale(this.account.locale));const t=e||await this.localeModel.getOrganizationLocale()||bm.DEFAULT_LOCALE;return this.localeModel.initializeI18next(t),t}};const Zw=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return-1!==this.worker.tab.url.indexOf("first-install")}};const Qw=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return"lost-passphrase"===new URL(this.worker.tab.url).searchParams.get("case")}};const Xw=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await ms.exec(this.worker.port._port.name);t.account.securityToken=new jr(e),await ys.set(t)}};const e_=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ms.exec(this.worker.port._port.name);return!0===e.account?.user?.accountRecoveryUserSetting?.isApproved}};const t_=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ys.get(this.worker.port._port.name),t=e?.userPassphrasePolicies;return t||us.createFromDefault()}},r_={listen:(e,t,r)=>{e.port.on("passbolt.recover.first-install",(async t=>{const r=new Zw(e,t);await r._exec()})),e.port.on("passbolt.recover.lost-passphrase-case",(async t=>{const r=new Qw(e,t);await r._exec()})),e.port.on("passbolt.organization-settings.get",(async r=>{const s=new Hw(e,r,t);await s._exec()})),e.port.on("passbolt.recover.start",(async s=>{const i=new $s(e,s,t,r);await i._exec()})),e.port.on("passbolt.locale.get",(async s=>{const i=new Jw(e,s,t,r);await i._exec()})),e.port.on("passbolt.locale.update-user-locale",(async(s,i)=>{const a=new Ww(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.recover.has-user-enabled-account-recovery",(async t=>{const r=new e_(e,t);await r._exec()})),e.port.on("passbolt.recover.import-key",(async(r,s)=>{const i=new Ms(e,r,t);await i._exec(s)})),e.port.on("passbolt.recover.verify-passphrase",(async(t,r)=>{const s=new Ts(e,t);await s._exec(r)})),e.port.on("passbolt.recover.set-security-token",(async(t,r)=>{const s=new Xw(e,t);await s._exec(r)})),e.port.on("passbolt.recover.complete",(async r=>{const s=new Gs(e,r,t);await s._exec()})),e.port.on("passbolt.recover.sign-in",(async(r,s)=>{const i=new Gw(e,r,t);await i._exec(s)})),e.port.on("passbolt.recover.generate-account-recovery-request-key",(async(r,s)=>{const i=new As(e,r,t);await i._exec(s)})),e.port.on("passbolt.recover.initiate-account-recovery-request",(async r=>{const s=new ws(e,t,r);await s._exec()})),e.port.on("passbolt.keyring.get-key-info",(async(t,r)=>{const s=new Pt(e,t);await s._exec(r)})),e.port.on("passbolt.recover.validate-private-key",(async(t,r)=>{const s=new Ws(e,t);await s._exec(r)})),e.port.on("passbolt.recover.request-help-credentials-lost",(async r=>{const s=new Hs(e,r,t);await s._exec()})),e.port.on("passbolt.recover.get-user-passphrase-policies",(async t=>{const r=new t_(e,t);await r._exec()})),e.port.on("passbolt.tab.reload",(async t=>{const r=new gd(e,t);await r._exec()}))}};const s_=class{static buildFromRecoverUrl(e){if("string"!=typeof e)throw new TypeError("Url should be a valid string.");const t=$.parse(e);return new is(t)}};const i_=new class extends z{get appName(){return"Recover"}get events(){return[ie,r_,Lm]}async attachEvents(e){try{const t=e._port.sender.tab,r=s_.buildFromRecoverUrl(t.url),s=ta.buildFromAccount(r);await new wt(s).getOrFind(!0);for(const i of this.events)i.listen({port:e,tab:t},s,r)}catch(e){console.error(e)}}};const a_=class{static parse(e){const t="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}",r=new RegExp(`(.*)/setup/(install|start)/(${t})/(${t})`);if(!r.test(e))throw new Error("Cannot parse setup url. The url does not match the pattern.");const s=e.match(r);let[,i]=s;const[,,,a,o]=s;i=i.replace(/\/*$/g,"");try{new URL(i)}catch(e){throw new Error("Cannot parse setup url. The domain is not valid.")}return{domain:i,user_id:a,authentication_token_token:o}}static test(e){try{return this.parse(e),!0}catch(e){return!1}}};const o_=new class extends z{get appName(){return"SetupBootstrap"}get contentStyleFiles(){return["webAccessibleResources/css/themes/default/ext_external.min.css"]}get contentScriptFiles(){return["contentScripts/js/dist/vendors.js","contentScripts/js/dist/setup.js"]}get events(){return[G]}get mustReloadOnExtensionUpdate(){return!0}async canBeAttachedTo(e){return this.assertTopFrameAttachConstraint(e)&&this.assertUrlAttachConstraint(e)}assertTopFrameAttachConstraint(e){return e.frameId===z.TOP_FRAME_ID}assertUrlAttachConstraint(e){return a_.test(e.url)}};const n_=class{constructor(e,t){this.worker=e,this.requestId=t,this.temporaryAccount=null}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){let t;this.temporaryAccount=await ms.exec(this.worker.port._port.name);t=e===ar.STATUS_APPROVED?await this.buildApprovedUserSetting():await this.buildRejectedUserSetting(),this.temporaryAccount.account.accountRecoveryUserSetting=t,await ys.set(this.temporaryAccount)}async buildApprovedUserSetting(){if(!this.temporaryAccount?.passphrase)throw new Error("A passphrase is required.");const e=await Je(this.temporaryAccount.account.userPrivateArmoredKey),t=await Fr.decrypt(e,this.temporaryAccount.passphrase),r=this.temporaryAccount.accountRecoveryOrganizationPolicy;return Tc.build(this.temporaryAccount.account,t,r)}async buildRejectedUserSetting(){const e={user_id:this.temporaryAccount.account.userId,status:ar.STATUS_REJECTED};return new ar(e)}};const c_=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.authVerifyServerChallengeService=new Ds(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await ms.exec(this.worker.port._port.name),r=await Je(e);je(r);const s=r.getFingerprint().toUpperCase();await this._assertImportKeyNotUsed(s,t.account.serverPublicArmoredKey),t.account.userKeyFingerprint=s,t.account.userPrivateArmoredKey=r.armor(),t.account.userPublicArmoredKey=r.toPublic().armor(),await ys.set(t)}async _assertImportKeyNotUsed(e,t){if(!t)throw new Error("The server public key should have been provided before importing a private key");let r=!1;try{await this.authVerifyServerChallengeService.verifyAndValidateServerChallenge(e,t),r=!0}catch(e){console.error(e)}if(r)throw new Rt(ue.t("This key is already used by another user."))}};const l_=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.authVerifyServerKeyService=new Us(r),this.setupModel=new qs(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{await this._buildTemporaryAccountEntity(),await this._findAndSetAccountSetupServerPublicKey(),await this._findAndSetAccountSetupMeta(),await ys.set(this.temporaryAccount)}catch(e){await this._handleUnexpectedError(e)}}async _buildTemporaryAccountEntity(){const e={account:this.account.toDto(cs.ALL_CONTAIN_OPTIONS),worker_id:this.worker.port._port.name};this.temporaryAccount=new ps(e)}async _findAndSetAccountSetupServerPublicKey(){const e=await this.authVerifyServerKeyService.getServerKey(),t=await Je(e.armored_key);ze(t),this.temporaryAccount.account.serverPublicArmoredKey=t.armor()}async _findAndSetAccountSetupMeta(){const{user:e,accountRecoveryOrganizationPolicy:t,userPassphrasePolicies:r}=await this.setupModel.startSetup(this.temporaryAccount.account.userId,this.temporaryAccount.account.authenticationTokenToken);this.temporaryAccount.account.username=e?.username,this.temporaryAccount.account.firstName=e?.profile.firstName,this.temporaryAccount.account.lastName=e?.profile.lastName,this.temporaryAccount.account.user=e,t&&(this.temporaryAccount.accountRecoveryOrganizationPolicy=t),r&&(this.temporaryAccount.userPassphrasePolicies=r)}async _handleUnexpectedError(e){throw(await zs.get("SetupBootstrap",this.worker.tab.id)).port.emit("passbolt.setup-bootstrap.remove-iframe"),e}};const u_=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ms.exec(this.worker.port._port.name);if(!e.account?.userPrivateArmoredKey)throw new Error("An account user private armored key is required.");const t=e.account.userPrivateArmoredKey;await Uc.saveFile("passbolt-recovery-kit.asc",t,"text/plain",this.worker.tab.id)}};const d_=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountModel=new Kr(r),this.setupModel=new qs(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ms.exec(this.worker.port._port.name),t=new Ys(e.account.toDto(cs.ALL_CONTAIN_OPTIONS));await this.setupModel.completeSetup(e.account),await this.accountModel.add(t)}};class p_{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await Je(e);je(t),qe(t);const r=await Ct.getKeyInfo(t);if(!r.isValid)throw new Error(ue.t("The private key should be a valid openpgp key."));if(r.revoked)throw new Error(ue.t("The private key should not be revoked."));if(r.isExpired)throw new Error(ue.t("The private key should not be expired."));if("Infinity"!==r.expires)throw new Error(ue.t("The private key should not have an expiry date."));if(r.algorithm===vs.TYPE_RSA){if(r.length<vs.DEFAULT_KEY_SIZE)throw new Error(ue.t("An RSA key should have a length of {{size}} bits minimum.",{size:vs.DEFAULT_KEY_SIZE}))}else{if(!r.curve)throw new Error(ue.t("The private key should use a supported algorithm: RSA, ECDSA OR EDDSA."));if(!p_._isCurveSupported(r.curve))throw new Error(ue.t("An ECC key should be based on a supported curve."))}}static _isCurveSupported(e){return["p256","p384","p521","secp256k1","ed25519","curve25519","brainpoolP256r1","brainpoolP384r1","brainpoolP512r1"].indexOf(e)>-1}}const h_=p_;const g_=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.apiClientOptions=r,this.temporaryAccount=null}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){this.temporaryAccount=await ms.exec(this.worker.port._port.name);const t=await this._buildGenerateKeyPairOptionsEntity(e.passphrase),r=await ks.generateKeyPair(t),s=await Je(r.publicKey.armoredKey);this.temporaryAccount.account.userKeyFingerprint=s.getFingerprint().toUpperCase(),this.temporaryAccount.account.userPrivateArmoredKey=r.privateKey.armoredKey,this.temporaryAccount.account.userPublicArmoredKey=r.publicKey.armoredKey,this.temporaryAccount.passphrase=e.passphrase,await ys.set(this.temporaryAccount)}async _buildGenerateKeyPairOptionsEntity(e){return new vs({name:`${this.temporaryAccount.account.firstName} ${this.temporaryAccount.account.lastName}`,email:this.temporaryAccount.account.username,passphrase:e,date:await _s.getDate(this.apiClientOptions)})}};const y_=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.localeModel=new bm(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){if(!this.account.locale){const e=await this.localeModel.getSupportedLocale(navigator.language)||await this.localeModel.getLocaleWithSimilarLanguage(navigator.language)||await this.localeModel.getOrganizationLocale()||bm.DEFAULT_LOCALE;this.account.locale=e.locale}const e=new _m({locale:this.account.locale});return this.localeModel.initializeI18next(e),e}};const m_=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=await ys.get(this.worker.port._port.name);return e?.accountRecoveryOrganizationPolicy}},w_={listen:function(e,t,r){e.port.on("passbolt.setup.is-first-install",(async t=>{const r=new Zw(e,t);await r._exec()})),e.port.on("passbolt.organization-settings.get",(async r=>{const s=new Hw(e,r,t);await s._exec()})),e.port.on("passbolt.setup.start",(async s=>{const i=new l_(e,s,t,r);await i._exec()})),e.port.on("passbolt.setup.get-and-init-locale",(async s=>{const i=new y_(e,s,t,r);await i._exec()})),e.port.on("passbolt.setup.update-locale",(async(s,i)=>{const a=new Ww(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.setup.generate-key",(async(r,s)=>{const i=new g_(e,r,t);await i._exec(s)})),e.port.on("passbolt.setup.download-recovery-kit",(async t=>{const r=new u_(e,t);await r._exec()})),e.port.on("passbolt.setup.get-account-recovery-organization-policy",(async t=>{const r=new m_(e,t);await r._exec()})),e.port.on("passbolt.setup.set-account-recovery-user-setting",(async(t,r)=>{const s=new n_(e,t);await s._exec(r)})),e.port.on("passbolt.setup.import-key",(async(r,s)=>{const i=new c_(e,r,t);await i._exec(s)})),e.port.on("passbolt.setup.verify-passphrase",(async(t,r)=>{const s=new Ts(e,t);await s._exec(r)})),e.port.on("passbolt.setup.set-security-token",(async(t,r)=>{const s=new Xw(e,t);await s._exec(r)})),e.port.on("passbolt.setup.complete",(async r=>{const s=new d_(e,r,t);await s._exec()})),e.port.on("passbolt.keyring.get-key-info",(async(t,r)=>{const s=new Pt(e,t);await s._exec(r)})),e.port.on("passbolt.setup.sign-in",(async(r,s)=>{const i=new Gw(e,r,t);await i._exec(s)})),e.port.on("passbolt.setup.validate-private-key",(async(t,r)=>{const s=new h_(e,t);await s._exec(r)})),e.port.on("passbolt.setup.get-user-passphrase-policies",(async t=>{const r=new t_(e,t);await r._exec()})),e.port.on("passbolt.tab.reload",(async t=>{const r=new gd(e,t);await r._exec()}))}};const __=class{static buildFromSetupUrl(e){if("string"!=typeof e)throw new TypeError("Url should be a valid string.");const t=a_.parse(e);return new cs(t)}};const f_=new class extends z{get appName(){return"Setup"}get events(){return[ie,w_,Lm]}async attachEvents(e){try{const t=e._port.sender.tab,r=__.buildFromSetupUrl(t.url),s=ta.buildFromAccount(r);await new wt(s).getOrFind(!0);for(const i of this.events)i.listen({port:e,tab:t},s,r)}catch(e){console.error(e)}}};const v_=class{static get regex(){const e=re.getInstance().settings.getDomain().replace(/\W/g,"\\$&");return new RegExp(`^${e}/auth/login/?(#.*)?(\\?.*)?$`)}static test(e){return this.regex.test(e)}};const S_=new class extends z{get appName(){return"AuthBootstrap"}get contentStyleFiles(){return["webAccessibleResources/css/themes/default/ext_external.min.css"]}get contentScriptFiles(){return["contentScripts/js/dist/vendors.js","contentScripts/js/dist/login.js"]}get events(){return[G]}get mustReloadOnExtensionUpdate(){return!0}async canBeAttachedTo(e){return this.assertTopFrameAttachConstraint(e)&&await this.assertUrlAttachConstraint(e)}assertTopFrameAttachConstraint(e){return e.frameId===z.TOP_FRAME_ID}async assertUrlAttachConstraint(e){try{return await Ro.get(),v_.test(e.url)}catch(e){return console.log(e),!1}}};const b_=new class extends z{get appName(){return"Auth"}get events(){return[ie,Ah,Wp,yd,rh,km,sw]}async attachEvents(e){try{const t=e._port.sender.tab,r=await Ro.get(),s=ta.buildFromAccount(r);for(const i of this.events)i.listen({port:e,tab:t},s,r)}catch(e){console.error("authPagemod::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}}},E_={listen:function(e,t,r){e.port.on("passbolt.app-boostrap.navigate-to-logout",(async()=>{const t=`${r.domain}/auth/logout`;try{await chrome.tabs.update(e.tab.id,{url:t}),await Kw.exec()}catch(e){console.error(e)}}))}};const k_=class{static getRegex(){return`^${re.getInstance().settings.getDomain().replace(/\W/g,"\\$&")}/?(/app.*)?(#.*)?$`}static parse(e){if(!new RegExp(this.getRegex()).test(e))throw new Error("Cannot parse application url. The url does not match the pattern.");e=e.replace(/\/*$/g,"");try{new URL(e)}catch(e){throw new Error("Cannot parse application url. The domain is not valid.")}}static test(e){try{return this.parse(e),!0}catch(e){return!1}}};const A_=new class extends z{get appName(){return"AppBootstrap"}get contentStyleFiles(){return["webAccessibleResources/css/themes/default/ext_external.min.css"]}get contentScriptFiles(){return["contentScripts/js/dist/vendors.js","contentScripts/js/dist/app.js"]}get events(){return[E_,G]}get mustReloadOnExtensionUpdate(){return!0}async canBeAttachedTo(e){return this.assertTopFrameAttachConstraint(e)&&await this.assertUrlAttachConstraint(e)&&await this.assertUserAuthenticated()}assertTopFrameAttachConstraint(e){return e.frameId===z.TOP_FRAME_ID}async assertUrlAttachConstraint(e){try{return await Ro.get(),k_.test(e.url)}catch(e){return console.log(e),!1}}async assertUserAuthenticated(){const e=new Fo;return(await e.checkAuthStatus(!0)).isAuthenticated}};const T_=class{constructor(e,t,r){this.worker=e,this.resourceModel=new Wd(t,r),this.resourceTypeModel=new Qo(t),this.getPassphraseService=new oc(r),this.getOrFindResourcesService=new qn(r,t)}async getInitialConfiguration(e){try{const t=await zs.get("WebIntegration",this.worker.tab.id),r=await t.port.request("passbolt.web-integration.last-performed-call-to-action-input"),s=await this.getOrFindResourcesService.getOrFindSuggested(this.worker.tab.url),i={inputType:r.type,inputValue:r.value,suggestedResources:s.toDto()};this.worker.port.emit(e,"SUCCESS",i)}catch(t){console.error(t),this.worker.port.emit(e,"ERROR",t)}}async createNewCredentials(e){const t=[{name:"uiMode",value:"detached"},{name:"feature",value:"create-new-credentials"},{name:"tabId",value:this.worker.tab.id}];await Jn.openInDetachedMode(t);(await zs.get("WebIntegration",this.worker.tab.id)).port.emit("passbolt.in-form-menu.close"),this.worker.port.emit(e,"SUCCESS")}async saveCredentials(e){const t=await zs.get("WebIntegration",this.worker.tab.id),{username:r,password:s}=await t.port.request("passbolt.web-integration.get-credentials"),i=await Bs.getCurrent(),a=i.title,o=i.url.substr(0,ro.URI_MAX_LENGTH),n=new Eg({name:a,username:r,uri:o,secret_clear:s});await fw.set(n);const c=[{name:"uiMode",value:"detached"},{name:"feature",value:"save-credentials"},{name:"tabId",value:this.worker.tab.id}];await Jn.openInDetachedMode(c),this.worker.port.emit(e,"SUCCESS"),t.port.emit("passbolt.in-form-menu.close")}async browseCredentials(e){const t=[{name:"uiMode",value:"detached"},{name:"feature",value:"browse-credentials"},{name:"tabId",value:this.worker.tab.id}];await Jn.openInDetachedMode(t);(await zs.get("WebIntegration",this.worker.tab.id)).port.emit("passbolt.in-form-menu.close"),this.worker.port.emit(e,"SUCCESS")}async fillPassword(e,t){(await zs.get("WebIntegration",this.worker.tab.id)).port.emit("passbolt.web-integration.fill-password",t),this.worker.port.emit(e,"SUCCESS")}async close(e){(await zs.get("WebIntegration",this.worker.tab.id)).port.emit("passbolt.in-form-menu.close"),this.worker.port.emit(e,"SUCCESS")}},I_={listen:function(e,t,r){e.port.on("passbolt.in-form-menu.init",(async s=>{const i=new T_(e,t,r);await i.getInitialConfiguration(s)})),e.port.on("passbolt.in-form-menu.create-new-credentials",(async s=>{const i=new T_(e,t,r);await i.createNewCredentials(s)})),e.port.on("passbolt.in-form-menu.save-credentials",(async s=>{const i=new T_(e,t,r);await i.saveCredentials(s)})),e.port.on("passbolt.in-form-menu.use-suggested-resource",(async(s,i)=>{const a=new C_(e,s,t,r);await a._exec(i,e.tab.id)})),e.port.on("passbolt.in-form-menu.browse-credentials",(async s=>{new T_(e,t,r).browseCredentials(s)})),e.port.on("passbolt.in-form-menu.fill-password",(async(s,i)=>{const a=new T_(e,t,r);await a.fillPassword(s,i)})),e.port.on("passbolt.in-form-menu.close",(async s=>{const i=new T_(e,t,r);await i.close(s)})),e.port.on("passbolt.locale.get",(async r=>{const s=new Em(e,t);try{const t=await s.getLocale();e.port.emit(r,"SUCCESS",t)}catch(t){console.error(t),e.port.emit(r,"ERROR",t)}})),e.port.on("passbolt.password-policies.get",(async s=>{const i=new Kl(e,s,r,t);await i._exec()}))}};const R_=new class extends z{get appName(){return"InFormMenu"}get events(){return[I_,dw]}async attachEvents(e){try{const t=e._port.sender.tab,r=await Ro.get(),s=ta.buildFromAccount(r),i=this.appName;for(const a of this.events)a.listen({port:e,tab:t,name:i},s,r)}catch(e){console.error("InFormMenu::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}}};const C_=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.resourceModel=new Wd(r,s),this.findSecretService=new Xp(s,r),this.resourceTypeModel=new Qo(r),this.getPassphraseService=new oc(s)}async _exec(e,t){try{await this.exec(e,t),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){const r=await zs.get("WebIntegration",t);try{const t=await this.getPassphrase(),s=await this.resourceModel.getById(e),i=await this.findSecretService.findByResourceId(e),a=await this.resourceTypeModel.getSecretSchemaById(s.resourceTypeId),o=await Hp.getKey(t),n=await Jp.decryptAndParse(i,a,o),c=s.metadata?.username||"",l=n?.password;this.fillCredential(r,{username:c,password:l})}finally{this.isInformMenuWorker&&r.port.emit("passbolt.in-form-menu.close")}}get isInformMenuWorker(){return this.worker.name===R_.appName}get isQuickAccessWorker(){return this.worker.name===N_.appName}async getPassphrase(){return this.isInformMenuWorker?await this.getPassphraseService.requestPassphraseFromQuickAccess():await this.getPassphraseService.getPassphrase(this.worker)}fillCredential(e,t){if(this.isInformMenuWorker)e.port.emit("passbolt.web-integration.fill-credentials",t);else if(this.isQuickAccessWorker){const r=e.port._port.sender.url;e.port.request("passbolt.quickaccess.fill-form",t.username,t.password,r)}}};var O_=r(7946);const x_={listen:function(e,t,r){e.port.on("passbolt.quickaccess.use-resource-on-current-tab",(async(s,i,a)=>{let o;if(!e.port){const t=new Error(ue.t("Inactive worker on the page."));e.port.emit(s,"ERROR",t)}try{if(o=a?await Bs.getById(a):await Bs.getCurrent(),!o){const t=new Error(ue.t("Autofill failed. Could not find the active tab."));e.port.emit(s,"ERROR",t)}}catch(t){e.port.emit(s,"ERROR",t)}const n=new C_(e,s,t,r);await n._exec(i,o.id)})),e.port.on("passbolt.quickaccess.prepare-resource",(async(t,r)=>{try{const s=await fw.consume();if(null===s){const s=r?await Bs.getById(r):await Bs.getCurrent(),i=s.title,a=s.url;e.port.emit(t,"SUCCESS",{name:i,uri:a})}else e.port.emit(t,"SUCCESS",s)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.quickaccess.prepare-autosave",(async t=>{try{const r=await fw.consume()||{};e.port.emit(t,"SUCCESS",r)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.quickaccess.update-window-height",(async t=>{try{const r=await Bs.getById(e.tab.id);O_.windows.update(r.windowId,{height:t+30})}catch(e){console.error(e)}})),e.port.on("passbolt.users.find-logged-in-user",(async(s,i=!1)=>{const a=new Eh(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.rbacs.find-me",(async(s,i)=>{const a=new yl(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.password-policies.get",(async s=>{const i=new Kl(e,s,r,t);await i._exec()})),e.port.on("passbolt.password-expiry.get-or-find",(async(s,i=!1)=>{const a=new pu(e,s,r,t);await a._exec(i)})),e.port.on("passbolt.metadata.get-or-find-metadata-types-settings",(async s=>{const i=new Tu(e,s,t,r);await i._exec()}))}},P_={listen:function(e){e.port.on("passbolt.active-tab.get-url",(async(t,r)=>{const s=r?await Bs.getById(r):await Bs.getCurrent();s?e.port.emit(t,"SUCCESS",s.url):e.port.emit(t,"ERROR",new Error(ue.t("Unable to retrieve the active tab info.")))}))}};const N_=new class extends z{get appName(){return"QuickAccess"}get events(){return[yd,ie,Wp,x_,Yh,lg,Op,th,rh,P_,km,Lm,sw,Pp,dw]}async attachEvents(e){let t,r;try{t=await Ro.get(),r=ta.buildFromAccount(t)}catch(e){console.error("quickaccessPagemod::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}const s={port:e,tab:e._port.sender.tab,name:this.appName};for(const e of this.events)e.listen(s,r,t)}};const U_=class{static parse(e){const t="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}",r=new RegExp(`(.*)/account-recovery/continue/(${t})/(${t})`);if(!r.test(e))throw new Error("Cannot parse account recovery url. The url does not match the pattern.");const s=e.match(r);let[,i]=s;const[,,a,o]=s;i=i.replace(/\/*$/g,"");try{new URL(i)}catch(e){throw new Error("Cannot parse account recovery url. The domain is not valid.")}return{domain:i,user_id:a,authentication_token_token:o}}static test(e){try{return this.parse(e),!0}catch(e){return!1}}};const D_=class{static async getAccountMatchingContinueUrl(e){const{domain:t,user_id:r,authentication_token_token:s}=U_.parse(e),i=await Qr.getAccountByUserIdAndType(r,os.TYPE_ACCOUNT_ACCOUNT_RECOVERY);if(!i)throw new Error("No account found for the given user in the local storage.");const a=new os(i,{validateUsername:!1});if(a.domain!==t||a.authenticationTokenToken!==s||a.userId!==r)throw new Error("The account found in the local storage does not match the account recovery request url parameters.");return a}};const M_=new class extends z{get appName(){return"AccountRecoveryBootstrap"}get contentScriptFiles(){return["contentScripts/js/dist/vendors.js","contentScripts/js/dist/account-recovery.js"]}get events(){return[G]}get mustReloadOnExtensionUpdate(){return!0}async canBeAttachedTo(e){return this.assertTopFrameAttachConstraint(e)&&this.assertUrlAttachConstraint(e)&&this.assertAccountInLocalStorage(e)}assertTopFrameAttachConstraint(e){return e.frameId===z.TOP_FRAME_ID}assertUrlAttachConstraint(e){return U_.test(e.url)}async assertAccountInLocalStorage(e){try{return Boolean(await D_.getAccountMatchingContinueUrl(e.url))}catch(e){return console.error(e),!1}}};const L_=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r),this.account=s}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{const e=await this._buildTemporaryAccountEntity();await this.accountRecoveryModel.continue(e.account.userId,e.account.authenticationTokenToken),await ys.set(e)}catch(e){throw(await zs.get("AccountRecoveryBootstrap",this.worker.tab.id)).port.emit("passbolt.account-recovery-bootstrap.remove-iframe"),e}}async _buildTemporaryAccountEntity(){const e={account:this.account.toDto(os.ALL_CONTAIN_OPTIONS),worker_id:this.worker.port._port.name};return new ps(e)}};const F_=class{static async decrypt(e,t,r,s,i){let a;const o=await Ge(e.data),n=await Mi.decrypt(o,t);try{a=JSON.parse(n)}catch(e){throw new Error("Unable to parse the decrypted response data.")}const c=new cc(a);if(c.privateKeyUserId!==r)throw new Error("The user id contained in the response data does not match the verification user id.");if(c.domain!==s)throw new Error("The domain contained in the private key password data does not match the expected target domain.");if(i&&c.privateKeyFingerprint!==i.getFingerprint().toUpperCase())throw new Error("The response data fingerprint should match the verification fingerprint.");return c}};const q_=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new Ur(r),this.setupModel=new qs(r),this.accountModel=new Kr(r),this.updateSsoCredentialsService=new Ni(r),this.temporaryAccount=null}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(this.temporaryAccount=await ms.exec(this.worker.port._port.name),void 0===e)throw new Error("A passphrase is required.");if("string"!=typeof e)throw new Error("The passphrase should be a string.");const t=await this._findAndAssertRequest(this.temporaryAccount.account),r=await this._recoverPrivateKey(t.accountRecoveryPrivateKey,t.accountRecoveryResponses.items[0],e);await this._completeRecover(r);const s=await this._addRecoveredAccountToStorage(this.temporaryAccount.account);this._updateWorkerAccount(s),await this._refreshSsoKit(e),await ys.set(this.temporaryAccount)}async _findAndAssertRequest(e){const t=await this.accountRecoveryModel.findRequestByIdAndUserIdAndAuthenticationToken(e.accountRecoveryRequestId,e.userId,e.authenticationTokenToken);if(t.id!==e.accountRecoveryRequestId)throw new Error("The account recovery request id should match the request id associated to the account being recovered.");if(!t.accountRecoveryPrivateKey)throw new Error("The account recovery request should have a private key.");if(!t.accountRecoveryResponses)throw new Error("The account recovery request should have a collection of responses.");if(1!==t.accountRecoveryResponses.length)throw new Error("The account recovery request responses should contain exactly one response.");return t}async _recoverPrivateKey(e,t,r){const s=await Je(this.temporaryAccount.account.userPrivateArmoredKey),i=await Fr.decrypt(s,r),a=await F_.decrypt(t,i,this.temporaryAccount.account.userId,this.temporaryAccount.account.domain),o=await Ge(e.data),n=await Mi.decryptSymmetrically(o,a.privateKeySecret),c=await Je(n);return qr.encrypt(c,r)}async _completeRecover(e){je(e),this.temporaryAccount.account.userPrivateArmoredKey=e.armor(),this.temporaryAccount.account.userPublicArmoredKey=e.toPublic().armor(),this.temporaryAccount.account.userKeyFingerprint=e.getFingerprint().toUpperCase(),await this.setupModel.completeRecover(this.temporaryAccount.account)}async _addRecoveredAccountToStorage(e){const t=new Ys(e.toDto(os.ALL_CONTAIN_OPTIONS));return await this.accountModel.add(t),t}_updateWorkerAccount(e){this.temporaryAccount.account.userPublicArmoredKey=e.userPublicArmoredKey,this.temporaryAccount.account.userPrivateArmoredKey=e.userPrivateArmoredKey,this.temporaryAccount.account.userKeyFingerprint=e.userKeyFingerprint}async _refreshSsoKit(e){await _i.flush(),await this.updateSsoCredentialsService.updateSsoKitIfNeeded(e)}};const K_=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=this.account?.userPrivateArmoredKey;if(!t)throw new Error("An account user private key is required.");if("string"!=typeof e)throw new TypeError("The passphrase should be a string.");const r=await Je(t);await Fr.decrypt(r,e)}};const B_=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.setupModel=new qs(r),this.userModel=new To(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.setupModel.abortRecover(this.account),await Qr.deleteByUserIdAndType(this.account.userId,os.TYPE_ACCOUNT_ACCOUNT_RECOVERY),await this.userModel.requestHelpCredentialsLost(this.account)}};var j_=r(7946);const z_=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.authVerifyLoginChallengeService=new ji(r),this.updateSsoCredentialsService=new Ni(r),this.checkPassphraseService=new Js(new xt),this.userRememberMeLatestChoiceLocalStorage=new rc(s)}async _exec(e,t,r=!1){try{await this.exec(e,t,r),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){const r=await ms.exec(this.worker.port._port.name);if(void 0===e)throw new Error("A passphrase is required.");if("string"!=typeof e)throw new Error("The passphrase should be a string.");if(void 0!==t&&"boolean"!=typeof t)throw new Error("The rememberMe should be a boolean.");await this.checkPassphraseService.checkPassphrase(e);try{await this.updateSsoCredentialsService.updateSsoKitIfNeeded(e)}catch(e){console.error(e)}try{await this.authVerifyLoginChallengeService.verifyAndValidateLoginChallenge(r.account.userKeyFingerprint,r.account.userPrivateArmoredKey,e),t?await Promise.all([Wi.set(e,-1),ac.start()]):await Wi.set(e,60),await Vw.exec(),await this.registerRememberMeOption(t)}catch(e){if(!(e instanceof Os))throw e}await this.redirectToApp(r.account.domain),await Qr.deleteByUserIdAndType(r.account.userId,os.TYPE_ACCOUNT_ACCOUNT_RECOVERY),await ys.remove()}async redirectToApp(e){j_.tabs.update(this.worker.tab.id,{url:e})}async registerRememberMeOption(e){const t=new ec({duration:e?-1:0});await this.userRememberMeLatestChoiceLocalStorage.set(t)}},$_={listen:function(e,t,r){e.port.on("passbolt.organization-settings.get",(async r=>{const s=new Hw(e,r,t);await s._exec()})),e.port.on("passbolt.locale.get",(async s=>{const i=new Jw(e,s,t,r);await i._exec()})),e.port.on("passbolt.addon.get-version",(async t=>{const r=new se(e,t);await r._exec()})),e.port.on("passbolt.account-recovery.continue",(async s=>{const i=new L_(e,s,t,r);await i._exec()})),e.port.on("passbolt.account-recovery.get-account",(async t=>{const s=new uw(e,t,r);await s._exec()})),e.port.on("passbolt.account-recovery.verify-passphrase",(async(t,s)=>{const i=new K_(e,t,r);await i._exec(s)})),e.port.on("passbolt.account-recovery.recover-account",(async(r,s)=>{const i=new q_(e,r,t);await i._exec(s)})),e.port.on("passbolt.account-recovery.sign-in",(async(s,i,a)=>{const o=new z_(e,s,t,r);await o._exec(i,a)})),e.port.on("passbolt.account-recovery.request-help-credentials-lost",(async s=>{const i=new B_(e,s,t,r);await i._exec()})),e.port.on("passbolt.account-recovery.download-recovery-kit",(async t=>{const r=new u_(e,t);await r._exec()})),e.port.on("passbolt.locale.update-user-locale",(async(s,i)=>{const a=new Ww(e,s,t,r);await a._exec(i)})),e.port.on("passbolt.tab.reload",(async t=>{const r=new gd(e,t);await r._exec()}))}};const V_=new class extends z{get appName(){return"AccountRecovery"}get events(){return[$_]}async attachEvents(e){try{const t=e._port.sender.tab,r=await D_.getAccountMatchingContinueUrl(t.url),s=ta.buildFromAccount(r);for(const i of this.events)i.listen({port:e,tab:t},s,r)}catch(t){console.error(t),e.disconnect()}}};const Y_=new class{constructor(){this.pagemods=[W,o_,S_,A_,M_,Cw,Aw,i_,f_,b_,pw,N_,Fw,R_,V_],this.exec=this.exec.bind(this)}async exec(e){const t=await this.getPagemodThatCanBeAttachedTo(e);await(t?.injectFiles(e.tabId,e.frameId))}async getPagemodThatCanBeAttachedTo(e){return Promise.all(this.pagemods.map((t=>t.canBeAttachedTo(e)))).then((e=>this.pagemods.find(((t,r)=>e[r]))))}async attachEventToPort(e,t){const r=this.findPagemodByAppName(t);await(r?.attachEvents(e))}findPagemodByAppName(e){return this.pagemods.find((t=>t.appName===e))}async hasPagemodMatchUrlToReload(e){for(const t of this.pagemods)if(t.mustReloadOnExtensionUpdate&&await t.assertUrlAttachConstraint({url:e}))return!0}};var G_=r(7946);const W_=new class{constructor(){this._ports={},this.onPortConnect=this.onPortConnect.bind(this),this.onTabRemoved=this.onTabRemoved.bind(this)}async onPortConnect(e){await this.isQuickAccessPort(e.sender)?await this.registerAndAttachEvent(e,"QuickAccess"):await this.connectPortFromTab(e)}async connectPortFromTab(e){const t=await j.getWorkerById(e.name);if(t){const r=new q(t);!this.isPortExist(e.name)&&await this.isKnownPortSender(r,e.sender)?(await this.updateWorkerStatus(r),await this.registerAndAttachEvent(e,r.name)):console.debug(`A known port has been denied connection or reconnection with name=${e.name}, tabUrl=${e.sender.tab.url}, tabId=${e.sender.tab.id}, frameId=${e.sender.frameId}`)}else console.debug(`An unknown port has been denied connection with name=${e.name}, tabUrl=${e.sender.tab.url}, tabId=${e.sender.tab.id}, frameId=${e.sender.frameId}`)}async isQuickAccessPort(e){if(e.tab)return!1;{const t=await G_.action.getPopup({});return e.url===t}}async isKnownPortSender(e,t){return null===e.frameId&&(e.frameId=t.frameId),e.tabId===t.tab.id&&e.frameId===t.frameId}async registerAndAttachEvent(e,t){const r=new _(e);this.registerPort(r),await Y_.attachEventToPort(r,t),r.emit("passbolt.port.ready")}async updateWorkerStatus(e){e.status=q.STATUS_CONNECTED,await j.updateWorker(e)}registerPort(e){this._ports[e._port.name]=e}removePort(e,t=null){t||this._ports[e]?.disconnect(),delete this._ports[e]}isPortExist(e){return Boolean(this._ports[e])}getPortById(e){return this._ports[e]}async flush(){this._ports={},await j.flush()}async onTabRemoved(e,t=null){if(void 0===e)throw new Error("A tab identifier is required.");if(!Number.isInteger(e))throw new Error("The tab identifier should be a valid integer.");(await j.getWorkersByTabId(e)).forEach((e=>this.removePort(e.id,t))),await j.deleteByTabId(e)}};const H_=class{static async get(){await a.init(),c(),m.init(),ae.$W.allowInsecureDecryptionWithSigningKeys=!0}};var J_=r(7946);class Z_{static async exec(e){switch(0===Object.keys(a._data).length&&(await a.init(),c()),e.reason){case J_.runtime.OnInstalledReason.INSTALL:await Z_.onInstall();break;case J_.runtime.OnInstalledReason.UPDATE:await Z_.onUpdate();break;case J_.runtime.OnInstalledReason.CHROME_UPDATE:case J_.runtime.OnInstalledReason.BROWSER_UPDATE:await Z_.onBrowserUpdate();break;default:console.debug(`The install reason ${e.reason} is not supported`)}}static async onInstall(){await J_.tabs.query({currentWindow:!0}).then(Q_).then(X_)}static async onUpdate(){await J_.tabs.query({}).then(tf),await Z_.updateToolbarIcon()}static async onBrowserUpdate(){const e=re.getInstance();if(!e.isValid())return;let t;try{const e=new Fo;t=await e.checkAuthStatus(!1)}catch(e){return void m.write({level:"debug",message:"Could not check if the user is authenticated, the service is unavailable."})}if(!t.isAuthenticated)return;const r=await e.getApiClientOptions(),s=new ld(r);await s.logout(),await J_.tabs.query({}).then(ef)}static async updateToolbarIcon(){if(!re.getInstance().isValid())return;let e;try{const t=new Fo;e=await t.checkAuthStatus(!1)}catch(e){return void m.write({level:"debug",message:"Could not check if the user is authenticated, the service is unavailable."})}e.isAuthenticated?Zi.activate():Zi.deactivate()}}const Q_=e=>Promise.all(e.map((e=>{if(e&&(a_.test(e.url)||$.test(e.url))){const t=new URL(e.url);return t.searchParams.set("first-install",1),J_.tabs.update(e.id,{url:t.href,active:!0})}return e}))),X_=e=>Promise.all(e.map((e=>e.url.match("https://(chromewebstore.google.com|addons.mozilla.org)/(.*)/passbolt")?J_.tabs.remove(e.id):e))),ef=async e=>{for(const t of e)await A_.assertUrlAttachConstraint(t)&&J_.tabs.reload(t.id)},tf=async e=>{for(const t of e)if(await Y_.hasPagemodMatchUrlToReload(t.url))J_.tabs.reload(t.id);else{const e={frameId:0,tabId:t.id,url:t.url};js.exec(e)}},rf=Z_;const sf=function(e,t){const r=new URL(e),s=new URL(t);return r.origin===s.origin};const af=class{static async exec(e,t,r){if("complete"!==t.status)return;if("about:blank"===r.url)return;if(!r?.url?.startsWith("http://")&&!r?.url?.startsWith("https://"))return;console.debug(`TabService::exec(id: ${e}, url: ${r.url}): Navigation detected.`);const s=await j.getWorkerOnMainFrame(e);if(s){const t=new q(s);if(t.isWaitingConnection||t.isReconnecting)return console.debug(`TabService::exec(id: ${e}): Waiting content script port initial connection or reconnection.`),void await zs.checkAndExecNavigationForWorkerWaitingConnection(t);if(W_.isPortExist(s.id)){const s=W_.getPortById(t.id);if(sf(s._port.sender.url,r.url))try{return await td.exec(s.request("passbolt.port.check")),void console.debug(`TabService::exec(id: ${e}):  Content script application acknowledged presence on worker runtime memory port.`)}catch(t){console.debug(`TabService::exec(id: ${e}): No content script application acknowledged presence on worker runtime memory port.`,t)}}else try{return t.status=q.STATUS_RECONNECTING,await j.updateWorker(t),await Bs.sendMessage(t,"passbolt.port.connect",t.id),void console.debug(`TabService::exec(id: ${e}): A content script application reconnected its port.`)}catch(t){console.debug(`TabService::exec(id: ${e}): No content script application was able to reconnect its port.`,t)}}const i=function(e){return{frameId:0,tabId:e.id,url:e.url}}(r);await js.exec(i),console.debug(`TabService::exec(id: ${e}): Trigger pagemods identification process.`)}},of={[zw.ALARM_NAME]:zw.handleAuthStatusCheckAlarm,[Wi.ALARM_NAME]:Wi.handleFlushEvent,[ac.ALARM_NAME]:ac.handleKeepSessionAlive};class nf{static exec(e){const t=of[e.name];t&&t(e)}}const cf=class{static async exec(){0===Object.keys(a._data).length&&(await a.init(),c()),mw.flush();re.getInstance().isValid()&&Zi.deactivate()}};var lf=r(7946);const uf=async()=>{if(!re.getInstance().isValid())return;let e;try{const t=new Fo;e=await t.checkAuthStatus(!0)}catch(e){return void m.write({level:"debug",message:"The Service is unavailable to check if the user is authenticated"})}e.isAuthenticated?Vw.exec():Kw.exec()};(async()=>{await H_.get(),uf()})(),lf.runtime.onInstalled.addListener(rf.exec),lf.runtime.onUpdateAvailable.addListener(Uw.exec),lf.runtime.onStartup.addListener(cf.exec),lf.tabs.onUpdated.addListener(af.exec),lf.runtime.onConnect.addListener(W_.onPortConnect),lf.tabs.onRemoved.addListener(W_.onTabRemoved),lf.alarms.onAlarm.removeListener(nf.exec),lf.alarms.onAlarm.addListener(nf.exec),lf.tabs.onUpdated.addListener(jn.handleSuggestedResourcesOnUpdatedTab),lf.tabs.onActivated.addListener(jn.handleSuggestedResourcesOnActivatedTab),lf.windows.onFocusChanged.addListener(jn.handleSuggestedResourcesOnFocusedWindow)},7946:(e,t,r)=>{const s=r(6815),i=r(5207),a=r(5627);s.scripting||(s.scripting=new i(s)),s.storage.session||(s.storage.session=new a),s.action||(s.action=s.browserAction),e.exports=s},5207:e=>{e.exports=class{constructor(e){this.browser=e}async executeScript(e){return e.func?await this._insertJsFunc(e):this._insertJsFiles(e)}insertCSS(e){let t=null;const r=e.files;for(let s=r.length-1;s>=0;--s){const i={file:r[s],runAt:"document_end",frameId:e.target?.frameIds[0]};t=this._createCssCallback(e.target.tabId,i,t)}t&&t()}_createJsCallback(e,t,r){return()=>chrome.tabs.executeScript(e,t,r)}_createCssCallback(e,t,r){return()=>chrome.tabs.insertCSS(e,t,r)}_insertJsFiles(e){let t=null;const r=e.files;for(let s=r.length-1;s>=0;--s){const i={file:r[s],runAt:"document_end",frameId:e.target?.frameIds[0]};t=this._createJsCallback(e.target.tabId,i,t)}t&&t()}async _insertJsFunc(e){const t=JSON.stringify(e.args),r=`;${e.func.name}.apply(window, ${t});`,s={code:e.func.toString()+r,runAt:"document_end",frameId:e.target?.frameIds[0]},i=await this.browser.tabs.executeScript(e.target.tabId,s);return i?.map((e=>({result:e})))}}},5627:e=>{e.exports=class{constructor(){this._storedData={}}async get(e){const t=typeof e;if("string"!==t&&"undefined"!==t)throw new Error(`Expected keys type of "string" but received an unsopprted type: ${t}`);if(!e)return this._storedData;return this._storedData[e]?{[e]:this._storedData[e]}:{}}async set(e){if("object"!=typeof e)throw new Error('Expected keys type of "object" but received an unsopprted type: '+typeof e);for(const t in e)this._storedData[t]=JSON.parse(JSON.stringify(e[t]))}async remove(e){delete this._storedData[e]}async clear(){this._storedData={}}}},7874:()=>{}},i={};function a(e){var t=i[e];if(void 0!==t)return t.exports;var r=i[e]={exports:{}};return s[e].call(r.exports,r,r.exports,a),r.exports}a.m=s,e=[],a.O=(t,r,s,i)=>{if(!r){var o=1/0;for(u=0;u<e.length;u++){for(var[r,s,i]=e[u],n=!0,c=0;c<r.length;c++)(!1&i||o>=i)&&Object.keys(a.O).every((e=>a.O[e](r[c])))?r.splice(c--,1):(n=!1,i<o&&(o=i));if(n){e.splice(u--,1);var l=s();void 0!==l&&(t=l)}}return t}i=i||0;for(var u=e.length;u>0&&e[u-1][2]>i;u--)e[u]=e[u-1];e[u]=[r,s,i]},a.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return a.d(t,{a:t}),t},r=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,a.t=function(e,s){if(1&s&&(e=this(e)),8&s)return e;if("object"==typeof e&&e){if(4&s&&e.__esModule)return e;if(16&s&&"function"==typeof e.then)return e}var i=Object.create(null);a.r(i);var o={};t=t||[null,r({}),r([]),r(r)];for(var n=2&s&&e;"object"==typeof n&&!~t.indexOf(n);n=r(n))Object.getOwnPropertyNames(n).forEach((t=>o[t]=()=>e[t]));return o.default=()=>e,a.d(i,o),i},a.d=(e,t)=>{for(var r in t)a.o(t,r)&&!a.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},a.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e={57:0};a.O.j=t=>0===e[t];var t=(t,r)=>{var s,i,[o,n,c]=r,l=0;if(o.some((t=>0!==e[t]))){for(s in n)a.o(n,s)&&(a.m[s]=n[s]);if(c)var u=c(a)}for(t&&t(r);l<o.length;l++)i=o[l],a.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return a.O(u)},r=self.backgroundPageIndexChunkLoadingGlobal=self.backgroundPageIndexChunkLoadingGlobal||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var o=a.O(void 0,[96],(()=>a(9891)));o=a.O(o)})();