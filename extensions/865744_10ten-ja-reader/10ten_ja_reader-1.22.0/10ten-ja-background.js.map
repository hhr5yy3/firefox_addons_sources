{"version":3,"file":"10ten-ja-background.js","sources":["webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+json-equalish@1.1.2/node_modules/@birchill/json-equalish/src/index.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/lru_map@0.4.1/node_modules/lru_map/dist/lru.js","webpack://10ten-ja-reader/./node_modules/.pnpm/webextension-polyfill@0.12.0/node_modules/webextension-polyfill/dist/browser-polyfill.js","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/fetch-delivery.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/safe-filter.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/is-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/is-object.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/parse-stack.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/to-exceptions.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/browser-unhandled-exceptions.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/browser-unhandled-rejections.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/console-breadcrumbs.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/error-breadcrumbs.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/fetch-breadcrumbs.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/interaction-breadcrumbs.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/navigation-breadcrumbs.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/app-duration.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/simple-ua-parser.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/browser-context.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/deviceorientation.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/limit-events.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/stringify.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/stringify-values.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/browser-handled-rejection-breadcrumbs.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+bugsnag-zero@0.6.9/node_modules/@birchill/src/index.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/superstruct@2.0.2/node_modules/superstruct/dist/index.mjs","webpack://10ten-ja-reader/./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/expand-choon.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/kana-to-hiragana.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/kyuujitai.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/numbers.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+normal-jp@1.5.2/node_modules/@birchill/normal-jp/src/to-normalized.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/abort-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/data-series.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/is-object.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/error-parsing.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/fetch.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/validation-helpers.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-version-info.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/ljson-stream.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/utils.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/version-number.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/quota-exceeded-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/japanese.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/store-types.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/store.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-state-reducer.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/download-types.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/database.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/offline-error.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/words.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/to-word-result.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/word-result-sorting.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/query.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-error-state.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/request-idle-callback.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/uuid.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-key.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+jpdict-idb@2.6.1/node_modules/@birchill/jpdict-idb/src/update-with-retry.ts","webpack://10ten-ja-reader/./src/background/fx-data.ts","webpack://10ten-ja-reader/./src/utils/is-object.ts","webpack://10ten-ja-reader/./src/utils/strip-fields.ts","webpack://10ten-ja-reader/./src/utils/ua-utils.ts","webpack://10ten-ja-reader/./src/common/db-languages.ts","webpack://10ten-ja-reader/./src/common/extension-storage-error.ts","webpack://10ten-ja-reader/./src/common/popup-keys.ts","webpack://10ten-ja-reader/./src/common/refs.ts","webpack://10ten-ja-reader/./src/common/config.ts","webpack://10ten-ja-reader/./src/common/db-listener-messages.ts","webpack://10ten-ja-reader/./src/utils/release-stage.ts","webpack://10ten-ja-reader/./src/utils/bugsnag.ts","webpack://10ten-ja-reader/./src/utils/request-idle-callback.ts","webpack://10ten-ja-reader/./node_modules/.pnpm/@birchill+discriminator@0.3.0_superstruct@2.0.2/node_modules/@birchill/discriminator/src/index.ts","webpack://10ten-ja-reader/./src/content/popup-state.ts","webpack://10ten-ja-reader/./src/background/background-request.ts","webpack://10ten-ja-reader/./src/background/all-tab-manager.ts","webpack://10ten-ja-reader/./src/common/data-series-labels.ts","webpack://10ten-ja-reader/./src/utils/throttle.ts","webpack://10ten-ja-reader/./src/background/browser-action.ts","webpack://10ten-ja-reader/./src/background/context-menus.ts","webpack://10ten-ja-reader/./src/utils/fetch.ts","webpack://10ten-ja-reader/./src/utils/is-error.ts","webpack://10ten-ja-reader/./src/background/fx-fetcher.ts","webpack://10ten-ja-reader/./src/background/is-current-tab-enabled.ts","webpack://10ten-ja-reader/./src/utils/normalize-input.ts","webpack://10ten-ja-reader/./src/utils/serialize-error.ts","webpack://10ten-ja-reader/./src/background/jpdict-events.ts","webpack://10ten-ja-reader/./src/worker/jpdict-worker-backend.ts","webpack://10ten-ja-reader/./src/background/word-match-sorting.ts","webpack://10ten-ja-reader/./src/background/flat-file.ts","webpack://10ten-ja-reader/./src/background/jpdict-backend.ts","webpack://10ten-ja-reader/./src/utils/char-range.ts","webpack://10ten-ja-reader/./src/background/yoon.ts","webpack://10ten-ja-reader/./src/background/name-search.ts","webpack://10ten-ja-reader/./src/utils/romaji.ts","webpack://10ten-ja-reader/./src/background/deinflect.ts","webpack://10ten-ja-reader/./src/background/word-search.ts","webpack://10ten-ja-reader/./src/background/jpdict.ts","webpack://10ten-ja-reader/./src/background/quota-management.ts","webpack://10ten-ja-reader/./src/background/background.ts"],"sourcesContent":["export function jsonEqualish(actual: any, expected: any) {\n  if (Object.is(actual, expected)) {\n    return true;\n  }\n\n  // For non-objects, use Object.is. This will cause 'undefined' and 'null' to\n  // be different, as desired.\n  if (\n    !actual ||\n    !expected ||\n    (typeof actual !== 'object' && typeof expected !== 'object')\n  ) {\n    // Except for numbers, since we want '-0' and '+0' to be equivalent\n    //\n    // (We should really just use JSON.stringify here. Might be slower but would\n    // it matter?)\n    return typeof actual === 'number'\n      ? actual === expected\n      : Object.is(actual, expected);\n  }\n\n  return objEquiv(actual, expected);\n}\n\nfunction objEquiv(a: any, b: any) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a instanceof Date) {\n    return b instanceof Date && a.getTime() == b.getTime();\n  }\n\n  if (Array.isArray(a) !== Array.isArray(b)) {\n    return false;\n  }\n\n  // We only deal with POD at the moment.\n  if (\n    (a.constructor && a.constructor !== Object && a.constructor !== Array) ||\n    (b.constructor && b.constructor !== Object && b.constructor !== Array)\n  ) {\n    throw new Error('Trying to compare something fancy');\n  }\n\n  const aKeys = definedKeys(a);\n  const bKeys = definedKeys(b);\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  aKeys.sort();\n  bKeys.sort();\n\n  // Compare keys first\n  for (let i = 0; i < aKeys.length; ++i) {\n    if (aKeys[i] != bKeys[i]) {\n      return false;\n    }\n  }\n\n  // Compare values\n  for (const key of aKeys) {\n    if (!jsonEqualish(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction definedKeys(a: any) {\n  return Object.keys(a).filter(key => typeof a[key] !== 'undefined');\n}\n\nexport default jsonEqualish;\n","/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n!function(g,f){\n  if (typeof exports == 'object' && typeof module != \"undefined\") {\n    f(exports)\n  } else if (typeof define == 'function' && define.amd) {\n    define([\"exports\"], f)\n  } else {\n    f((g = g || self)[\"lru_map\"] = (g[\"lru_map\"] || {}))\n  }\n}(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nclass LRUMap {\n  constructor(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  _markEntryAsUsed(entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n    entry[NEWER] = undefined; // D --x\n    entry[OLDER] = this.newest; // D. --> E\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n    this.newest = entry;\n  }\n\n  assign(entries) {\n    let entry, limit = this.limit || Number.MAX_VALUE;\n    this._keymap.clear();\n    let it = entries[Symbol.iterator]();\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n      this._keymap.set(e.key, e);\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n      entry = e;\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n    this.newest = entry;\n    this.size = this._keymap.size;\n  }\n\n  get(key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n    this._markEntryAsUsed(entry);\n    return entry.value;\n  }\n\n  set(key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n      this._markEntryAsUsed(entry);\n      return this;\n    }\n\n    // new entry\n    this._keymap.set(key, (entry = new Entry(key, value)));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    }\n\n    // add new entry to the end of the linked list -- it's now the freshest entry.\n    this.newest = entry;\n    ++this.size;\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  }\n\n  shift() {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      }\n      // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n      entry[NEWER] = entry[OLDER] = undefined;\n      this._keymap.delete(entry.key);\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  }\n\n  // -------------------------------------------------------------------------------------\n  // Following code (until end of class definition) is optional and can be removed without\n  // breaking the core functionality.\n\n  find(key) {\n    let e = this._keymap.get(key);\n    return e ? e.value : undefined;\n  }\n\n  has(key) {\n    return this._keymap.has(key);\n  }\n\n  delete(key) {\n    var entry = this._keymap.get(key);\n    if (!entry) return;\n    this._keymap.delete(entry.key);\n    if (entry[NEWER] && entry[OLDER]) {\n      // relink the older entry with the newer entry\n      entry[OLDER][NEWER] = entry[NEWER];\n      entry[NEWER][OLDER] = entry[OLDER];\n    } else if (entry[NEWER]) {\n      // remove the link to us\n      entry[NEWER][OLDER] = undefined;\n      // link the newer entry to head\n      this.oldest = entry[NEWER];\n    } else if (entry[OLDER]) {\n      // remove the link to us\n      entry[OLDER][NEWER] = undefined;\n      // link the newer entry to head\n      this.newest = entry[OLDER];\n    } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n      this.oldest = this.newest = undefined;\n    }\n\n    this.size--;\n    return entry.value;\n  }\n\n  clear() {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n    this._keymap.clear();\n  }\n\n  keys() {\n    return new KeyIterator(this.oldest);\n  }\n\n  values() {\n    return new ValueIterator(this.oldest);\n  }\n\n  entries() {\n    return this;\n  }\n\n  [Symbol.iterator]() {\n    return new EntryIterator(this.oldest);\n  }\n\n  forEach(fun, thisObj) {\n    if (typeof thisObj !== 'object') {\n      thisObj = this;\n    }\n    let entry = this.oldest;\n    while (entry) {\n      fun.call(thisObj, entry.value, entry.key, this);\n      entry = entry[NEWER];\n    }\n  }\n\n  /** Returns a JSON (array) representation */\n  toJSON() {\n    var s = new Array(this.size), i = 0, entry = this.oldest;\n    while (entry) {\n      s[i++] = { key: entry.key, value: entry.value };\n      entry = entry[NEWER];\n    }\n    return s;\n  }\n\n  /** Returns a String representation */\n  toString() {\n    var s = '', entry = this.oldest;\n    while (entry) {\n      s += String(entry.key)+':'+entry.value;\n      entry = entry[NEWER];\n      if (entry) {\n        s += ' < ';\n      }\n    }\n    return s;\n  }\n}\n\nexports.LRUMap = LRUMap\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n});\n","/* webextension-polyfill - v0.12.0 - Tue May 14 2024 18:01:29 */\n/* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n/* vim: set sts=2 sw=2 et tw=80: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\"use strict\";\n\nif (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {\n  throw new Error(\"This script should only be loaded in a browser extension.\");\n}\n\nif (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {\n  const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\";\n\n  // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n  // optimization for Firefox. Since Spidermonkey does not fully parse the\n  // contents of a function until the first time it's called, and since it will\n  // never actually need to be called, this allows the polyfill to be included\n  // in Firefox nearly for free.\n  const wrapAPIs = extensionAPIs => {\n    // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n    // at build time by replacing the following \"include\" with the content of the\n    // JSON file.\n    const apiMetadata = {\n      \"alarms\": {\n        \"clear\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"clearAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"get\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"bookmarks\": {\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getChildren\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getRecent\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getSubTree\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTree\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"move\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeTree\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"browserAction\": {\n        \"disable\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"enable\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"getBadgeBackgroundColor\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getBadgeText\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"openPopup\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"setBadgeBackgroundColor\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setBadgeText\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"setPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"browsingData\": {\n        \"remove\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"removeCache\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeCookies\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeDownloads\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeFormData\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeHistory\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeLocalStorage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removePasswords\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removePluginData\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"settings\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"commands\": {\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"contextMenus\": {\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"cookies\": {\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAllCookieStores\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"set\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"devtools\": {\n        \"inspectedWindow\": {\n          \"eval\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2,\n            \"singleCallbackArg\": false\n          }\n        },\n        \"panels\": {\n          \"create\": {\n            \"minArgs\": 3,\n            \"maxArgs\": 3,\n            \"singleCallbackArg\": true\n          },\n          \"elements\": {\n            \"createSidebarPane\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        }\n      },\n      \"downloads\": {\n        \"cancel\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"download\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"erase\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getFileIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"open\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"pause\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeFile\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"resume\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"show\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"extension\": {\n        \"isAllowedFileSchemeAccess\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"isAllowedIncognitoAccess\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"history\": {\n        \"addUrl\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"deleteAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"deleteRange\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"deleteUrl\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getVisits\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"search\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"i18n\": {\n        \"detectLanguage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAcceptLanguages\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"identity\": {\n        \"launchWebAuthFlow\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"idle\": {\n        \"queryState\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"management\": {\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getSelf\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"setEnabled\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"uninstallSelf\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        }\n      },\n      \"notifications\": {\n        \"clear\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getPermissionLevel\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      },\n      \"pageAction\": {\n        \"getPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"hide\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setIcon\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"setPopup\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"setTitle\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        },\n        \"show\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1,\n          \"fallbackToNoCallback\": true\n        }\n      },\n      \"permissions\": {\n        \"contains\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"request\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"runtime\": {\n        \"getBackgroundPage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getPlatformInfo\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"openOptionsPage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"requestUpdateCheck\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"sendMessage\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 3\n        },\n        \"sendNativeMessage\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"setUninstallURL\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"sessions\": {\n        \"getDevices\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getRecentlyClosed\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"restore\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        }\n      },\n      \"storage\": {\n        \"local\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"managed\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"sync\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getBytesInUse\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        }\n      },\n      \"tabs\": {\n        \"captureVisibleTab\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 2\n        },\n        \"create\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"detectLanguage\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"discard\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"duplicate\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"executeScript\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getCurrent\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        },\n        \"getZoom\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getZoomSettings\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"goBack\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"goForward\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"highlight\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"insertCSS\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"move\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        },\n        \"query\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"reload\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 2\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"removeCSS\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"sendMessage\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 3\n        },\n        \"setZoom\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"setZoomSettings\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"update\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        }\n      },\n      \"topSites\": {\n        \"get\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"webNavigation\": {\n        \"getAllFrames\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"getFrame\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        }\n      },\n      \"webRequest\": {\n        \"handlerBehaviorChanged\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 0\n        }\n      },\n      \"windows\": {\n        \"create\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"get\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 2\n        },\n        \"getAll\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getCurrent\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"getLastFocused\": {\n          \"minArgs\": 0,\n          \"maxArgs\": 1\n        },\n        \"remove\": {\n          \"minArgs\": 1,\n          \"maxArgs\": 1\n        },\n        \"update\": {\n          \"minArgs\": 2,\n          \"maxArgs\": 2\n        }\n      }\n    };\n\n    if (Object.keys(apiMetadata).length === 0) {\n      throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n    }\n\n    /**\n     * A WeakMap subclass which creates and stores a value for any key which does\n     * not exist when accessed, but behaves exactly as an ordinary WeakMap\n     * otherwise.\n     *\n     * @param {function} createItem\n     *        A function which will be called in order to create the value for any\n     *        key which does not exist, the first time it is accessed. The\n     *        function receives, as its only argument, the key being created.\n     */\n    class DefaultWeakMap extends WeakMap {\n      constructor(createItem, items = undefined) {\n        super(items);\n        this.createItem = createItem;\n      }\n\n      get(key) {\n        if (!this.has(key)) {\n          this.set(key, this.createItem(key));\n        }\n\n        return super.get(key);\n      }\n    }\n\n    /**\n     * Returns true if the given object is an object with a `then` method, and can\n     * therefore be assumed to behave as a Promise.\n     *\n     * @param {*} value The value to test.\n     * @returns {boolean} True if the value is thenable.\n     */\n    const isThenable = value => {\n      return value && typeof value === \"object\" && typeof value.then === \"function\";\n    };\n\n    /**\n     * Creates and returns a function which, when called, will resolve or reject\n     * the given promise based on how it is called:\n     *\n     * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n     *   the promise is rejected with that value.\n     * - If the function is called with exactly one argument, the promise is\n     *   resolved to that value.\n     * - Otherwise, the promise is resolved to an array containing all of the\n     *   function's arguments.\n     *\n     * @param {object} promise\n     *        An object containing the resolution and rejection functions of a\n     *        promise.\n     * @param {function} promise.resolve\n     *        The promise's resolution function.\n     * @param {function} promise.reject\n     *        The promise's rejection function.\n     * @param {object} metadata\n     *        Metadata about the wrapped method which has created the callback.\n     * @param {boolean} metadata.singleCallbackArg\n     *        Whether or not the promise is resolved with only the first\n     *        argument of the callback, alternatively an array of all the\n     *        callback arguments is resolved. By default, if the callback\n     *        function is invoked with only a single argument, that will be\n     *        resolved to the promise, while all arguments will be resolved as\n     *        an array if multiple are given.\n     *\n     * @returns {function}\n     *        The generated callback function.\n     */\n    const makeCallback = (promise, metadata) => {\n      return (...callbackArgs) => {\n        if (extensionAPIs.runtime.lastError) {\n          promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n        } else if (metadata.singleCallbackArg ||\n                   (callbackArgs.length <= 1 && metadata.singleCallbackArg !== false)) {\n          promise.resolve(callbackArgs[0]);\n        } else {\n          promise.resolve(callbackArgs);\n        }\n      };\n    };\n\n    const pluralizeArguments = (numArgs) => numArgs == 1 ? \"argument\" : \"arguments\";\n\n    /**\n     * Creates a wrapper function for a method with the given name and metadata.\n     *\n     * @param {string} name\n     *        The name of the method which is being wrapped.\n     * @param {object} metadata\n     *        Metadata about the method being wrapped.\n     * @param {integer} metadata.minArgs\n     *        The minimum number of arguments which must be passed to the\n     *        function. If called with fewer than this number of arguments, the\n     *        wrapper will raise an exception.\n     * @param {integer} metadata.maxArgs\n     *        The maximum number of arguments which may be passed to the\n     *        function. If called with more than this number of arguments, the\n     *        wrapper will raise an exception.\n     * @param {boolean} metadata.singleCallbackArg\n     *        Whether or not the promise is resolved with only the first\n     *        argument of the callback, alternatively an array of all the\n     *        callback arguments is resolved. By default, if the callback\n     *        function is invoked with only a single argument, that will be\n     *        resolved to the promise, while all arguments will be resolved as\n     *        an array if multiple are given.\n     *\n     * @returns {function(object, ...*)}\n     *       The generated wrapper function.\n     */\n    const wrapAsyncFunction = (name, metadata) => {\n      return function asyncFunctionWrapper(target, ...args) {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          if (metadata.fallbackToNoCallback) {\n            // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n            // and so the polyfill will try to call it with a callback first, and it will fallback\n            // to not passing the callback if the first call fails.\n            try {\n              target[name](...args, makeCallback({resolve, reject}, metadata));\n            } catch (cbError) {\n              console.warn(`${name} API method doesn't seem to support the callback parameter, ` +\n                           \"falling back to call it without a callback: \", cbError);\n\n              target[name](...args);\n\n              // Update the API method metadata, so that the next API calls will not try to\n              // use the unsupported callback anymore.\n              metadata.fallbackToNoCallback = false;\n              metadata.noCallback = true;\n\n              resolve();\n            }\n          } else if (metadata.noCallback) {\n            target[name](...args);\n            resolve();\n          } else {\n            target[name](...args, makeCallback({resolve, reject}, metadata));\n          }\n        });\n      };\n    };\n\n    /**\n     * Wraps an existing method of the target object, so that calls to it are\n     * intercepted by the given wrapper function. The wrapper function receives,\n     * as its first argument, the original `target` object, followed by each of\n     * the arguments passed to the original method.\n     *\n     * @param {object} target\n     *        The original target object that the wrapped method belongs to.\n     * @param {function} method\n     *        The method being wrapped. This is used as the target of the Proxy\n     *        object which is created to wrap the method.\n     * @param {function} wrapper\n     *        The wrapper function which is called in place of a direct invocation\n     *        of the wrapped method.\n     *\n     * @returns {Proxy<function>}\n     *        A Proxy object for the given method, which invokes the given wrapper\n     *        method in its place.\n     */\n    const wrapMethod = (target, method, wrapper) => {\n      return new Proxy(method, {\n        apply(targetMethod, thisObj, args) {\n          return wrapper.call(thisObj, target, ...args);\n        },\n      });\n    };\n\n    let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    /**\n     * Wraps an object in a Proxy which intercepts and wraps certain methods\n     * based on the given `wrappers` and `metadata` objects.\n     *\n     * @param {object} target\n     *        The target object to wrap.\n     *\n     * @param {object} [wrappers = {}]\n     *        An object tree containing wrapper functions for special cases. Any\n     *        function present in this object tree is called in place of the\n     *        method in the same location in the `target` object tree. These\n     *        wrapper methods are invoked as described in {@see wrapMethod}.\n     *\n     * @param {object} [metadata = {}]\n     *        An object tree containing metadata used to automatically generate\n     *        Promise-based wrapper functions for asynchronous. Any function in\n     *        the `target` object tree which has a corresponding metadata object\n     *        in the same location in the `metadata` tree is replaced with an\n     *        automatically-generated wrapper function, as described in\n     *        {@see wrapAsyncFunction}\n     *\n     * @returns {Proxy<object>}\n     */\n    const wrapObject = (target, wrappers = {}, metadata = {}) => {\n      let cache = Object.create(null);\n      let handlers = {\n        has(proxyTarget, prop) {\n          return prop in target || prop in cache;\n        },\n\n        get(proxyTarget, prop, receiver) {\n          if (prop in cache) {\n            return cache[prop];\n          }\n\n          if (!(prop in target)) {\n            return undefined;\n          }\n\n          let value = target[prop];\n\n          if (typeof value === \"function\") {\n            // This is a method on the underlying object. Check if we need to do\n            // any wrapping.\n\n            if (typeof wrappers[prop] === \"function\") {\n              // We have a special-case wrapper for this method.\n              value = wrapMethod(target, target[prop], wrappers[prop]);\n            } else if (hasOwnProperty(metadata, prop)) {\n              // This is an async method that we have metadata for. Create a\n              // Promise wrapper for it.\n              let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n              value = wrapMethod(target, target[prop], wrapper);\n            } else {\n              // This is a method that we don't know or care about. Return the\n              // original method, bound to the underlying object.\n              value = value.bind(target);\n            }\n          } else if (typeof value === \"object\" && value !== null &&\n                     (hasOwnProperty(wrappers, prop) ||\n                      hasOwnProperty(metadata, prop))) {\n            // This is an object that we need to do some wrapping for the children\n            // of. Create a sub-object wrapper for it with the appropriate child\n            // metadata.\n            value = wrapObject(value, wrappers[prop], metadata[prop]);\n          } else if (hasOwnProperty(metadata, \"*\")) {\n            // Wrap all properties in * namespace.\n            value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n          } else {\n            // We don't need to do any wrapping for this property,\n            // so just forward all access to the underlying object.\n            Object.defineProperty(cache, prop, {\n              configurable: true,\n              enumerable: true,\n              get() {\n                return target[prop];\n              },\n              set(value) {\n                target[prop] = value;\n              },\n            });\n\n            return value;\n          }\n\n          cache[prop] = value;\n          return value;\n        },\n\n        set(proxyTarget, prop, value, receiver) {\n          if (prop in cache) {\n            cache[prop] = value;\n          } else {\n            target[prop] = value;\n          }\n          return true;\n        },\n\n        defineProperty(proxyTarget, prop, desc) {\n          return Reflect.defineProperty(cache, prop, desc);\n        },\n\n        deleteProperty(proxyTarget, prop) {\n          return Reflect.deleteProperty(cache, prop);\n        },\n      };\n\n      // Per contract of the Proxy API, the \"get\" proxy handler must return the\n      // original value of the target if that value is declared read-only and\n      // non-configurable. For this reason, we create an object with the\n      // prototype set to `target` instead of using `target` directly.\n      // Otherwise we cannot return a custom object for APIs that\n      // are declared read-only and non-configurable, such as `chrome.devtools`.\n      //\n      // The proxy handlers themselves will still use the original `target`\n      // instead of the `proxyTarget`, so that the methods and properties are\n      // dereferenced via the original targets.\n      let proxyTarget = Object.create(target);\n      return new Proxy(proxyTarget, handlers);\n    };\n\n    /**\n     * Creates a set of wrapper functions for an event object, which handles\n     * wrapping of listener functions that those messages are passed.\n     *\n     * A single wrapper is created for each listener function, and stored in a\n     * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n     * retrieve the original wrapper, so that  attempts to remove a\n     * previously-added listener work as expected.\n     *\n     * @param {DefaultWeakMap<function, function>} wrapperMap\n     *        A DefaultWeakMap object which will create the appropriate wrapper\n     *        for a given listener function when one does not exist, and retrieve\n     *        an existing one when it does.\n     *\n     * @returns {object}\n     */\n    const wrapEvent = wrapperMap => ({\n      addListener(target, listener, ...args) {\n        target.addListener(wrapperMap.get(listener), ...args);\n      },\n\n      hasListener(target, listener) {\n        return target.hasListener(wrapperMap.get(listener));\n      },\n\n      removeListener(target, listener) {\n        target.removeListener(wrapperMap.get(listener));\n      },\n    });\n\n    const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n      if (typeof listener !== \"function\") {\n        return listener;\n      }\n\n      /**\n       * Wraps an onRequestFinished listener function so that it will return a\n       * `getContent()` property which returns a `Promise` rather than using a\n       * callback API.\n       *\n       * @param {object} req\n       *        The HAR entry object representing the network request.\n       */\n      return function onRequestFinished(req) {\n        const wrappedReq = wrapObject(req, {} /* wrappers */, {\n          getContent: {\n            minArgs: 0,\n            maxArgs: 0,\n          },\n        });\n        listener(wrappedReq);\n      };\n    });\n\n    const onMessageWrappers = new DefaultWeakMap(listener => {\n      if (typeof listener !== \"function\") {\n        return listener;\n      }\n\n      /**\n       * Wraps a message listener function so that it may send responses based on\n       * its return value, rather than by returning a sentinel value and calling a\n       * callback. If the listener function returns a Promise, the response is\n       * sent when the promise either resolves or rejects.\n       *\n       * @param {*} message\n       *        The message sent by the other end of the channel.\n       * @param {object} sender\n       *        Details about the sender of the message.\n       * @param {function(*)} sendResponse\n       *        A callback which, when called with an arbitrary argument, sends\n       *        that value as a response.\n       * @returns {boolean}\n       *        True if the wrapped listener returned a Promise, which will later\n       *        yield a response. False otherwise.\n       */\n      return function onMessage(message, sender, sendResponse) {\n        let didCallSendResponse = false;\n\n        let wrappedSendResponse;\n        let sendResponsePromise = new Promise(resolve => {\n          wrappedSendResponse = function(response) {\n            didCallSendResponse = true;\n            resolve(response);\n          };\n        });\n\n        let result;\n        try {\n          result = listener(message, sender, wrappedSendResponse);\n        } catch (err) {\n          result = Promise.reject(err);\n        }\n\n        const isResultThenable = result !== true && isThenable(result);\n\n        // If the listener didn't returned true or a Promise, or called\n        // wrappedSendResponse synchronously, we can exit earlier\n        // because there will be no response sent from this listener.\n        if (result !== true && !isResultThenable && !didCallSendResponse) {\n          return false;\n        }\n\n        // A small helper to send the message if the promise resolves\n        // and an error if the promise rejects (a wrapped sendMessage has\n        // to translate the message into a resolved promise or a rejected\n        // promise).\n        const sendPromisedResult = (promise) => {\n          promise.then(msg => {\n            // send the message value.\n            sendResponse(msg);\n          }, error => {\n            // Send a JSON representation of the error if the rejected value\n            // is an instance of error, or the object itself otherwise.\n            let message;\n            if (error && (error instanceof Error ||\n                typeof error.message === \"string\")) {\n              message = error.message;\n            } else {\n              message = \"An unexpected error occurred\";\n            }\n\n            sendResponse({\n              __mozWebExtensionPolyfillReject__: true,\n              message,\n            });\n          }).catch(err => {\n            // Print an error on the console if unable to send the response.\n            console.error(\"Failed to send onMessage rejected reply\", err);\n          });\n        };\n\n        // If the listener returned a Promise, send the resolved value as a\n        // result, otherwise wait the promise related to the wrappedSendResponse\n        // callback to resolve and send it as a response.\n        if (isResultThenable) {\n          sendPromisedResult(result);\n        } else {\n          sendPromisedResult(sendResponsePromise);\n        }\n\n        // Let Chrome know that the listener is replying.\n        return true;\n      };\n    });\n\n    const wrappedSendMessageCallback = ({reject, resolve}, reply) => {\n      if (extensionAPIs.runtime.lastError) {\n        // Detect when none of the listeners replied to the sendMessage call and resolve\n        // the promise to undefined as in Firefox.\n        // See https://github.com/mozilla/webextension-polyfill/issues/130\n        if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n          resolve();\n        } else {\n          reject(new Error(extensionAPIs.runtime.lastError.message));\n        }\n      } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n        // Convert back the JSON representation of the error into\n        // an Error instance.\n        reject(new Error(reply.message));\n      } else {\n        resolve(reply);\n      }\n    };\n\n    const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n      if (args.length < metadata.minArgs) {\n        throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n      }\n\n      if (args.length > metadata.maxArgs) {\n        throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n      }\n\n      return new Promise((resolve, reject) => {\n        const wrappedCb = wrappedSendMessageCallback.bind(null, {resolve, reject});\n        args.push(wrappedCb);\n        apiNamespaceObj.sendMessage(...args);\n      });\n    };\n\n    const staticWrappers = {\n      devtools: {\n        network: {\n          onRequestFinished: wrapEvent(onRequestFinishedWrappers),\n        },\n      },\n      runtime: {\n        onMessage: wrapEvent(onMessageWrappers),\n        onMessageExternal: wrapEvent(onMessageWrappers),\n        sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {minArgs: 1, maxArgs: 3}),\n      },\n      tabs: {\n        sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {minArgs: 2, maxArgs: 3}),\n      },\n    };\n    const settingMetadata = {\n      clear: {minArgs: 1, maxArgs: 1},\n      get: {minArgs: 1, maxArgs: 1},\n      set: {minArgs: 1, maxArgs: 1},\n    };\n    apiMetadata.privacy = {\n      network: {\"*\": settingMetadata},\n      services: {\"*\": settingMetadata},\n      websites: {\"*\": settingMetadata},\n    };\n\n    return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n  };\n\n  // The build process adds a UMD wrapper around this file, which makes the\n  // `module` variable available.\n  module.exports = wrapAPIs(chrome);\n} else {\n  module.exports = globalThis.browser;\n}\n","import { Delivery, EventForDelivery, ExtendedClientApi } from './client';\nimport { Notifier } from './notifier';\n\nexport class FetchDelivery implements Delivery {\n  constructor(private client: ExtendedClientApi) {}\n\n  async sendEvent({\n    apiKey,\n    events,\n    notifier,\n    payloadVersion,\n  }: {\n    apiKey: string;\n    events: Array<EventForDelivery>;\n    notifier: Notifier;\n    payloadVersion: string;\n  }): Promise<void> {\n    const sentAt = new Date().toISOString();\n\n    const body = JSON.stringify({\n      apiKey,\n      payloadVersion,\n      notifier,\n      events,\n    });\n\n    await fetch(this.client.endpoints.notify, {\n      method: 'POST',\n      mode: 'cors',\n      credentials: 'omit',\n      headers: {\n        'Content-Type': 'application/json',\n        'Bugsnag-Api-Key': apiKey,\n        'Bugsnag-Payload-Version': payloadVersion,\n        'Bugsnag-Sent-At': sentAt,\n      },\n      referrerPolicy: 'no-referrer',\n      body,\n    });\n  }\n}\n","export type Replacer = (key: string | number, value: unknown) => unknown;\n\nexport const CircularReference = Symbol('Circular');\nexport const AccessError = Symbol('AccessError');\n\n/**\n * Iterate through an object's properties and return a copy with the values\n * replaced by the result of the replacer function.\n *\n * Detects circular references and replaces them with the `CircularReference`\n * symbol.\n *\n * Detects errors accessing properties and replaces them with the `AccessError`\n * symbol.\n *\n * For any objects with a `toJSON` function, it will be called instead of\n * traversing the object's properties.\n */\nexport function safeFilter(\n  input: unknown,\n  replacer?: Replacer | null,\n  options?: { depthLimit?: number; edgesLimit?: number }\n): unknown {\n  return filter({\n    key: '',\n    value: input,\n    replacer,\n    seen: [],\n    depth: 0,\n    depthLimit: options?.depthLimit,\n    edgeIndex: 0,\n    edgesLimit: options?.edgesLimit,\n  });\n}\n\nfunction filter({\n  key,\n  value,\n  replacer,\n  seen,\n  depthLimit = Infinity,\n  depth,\n  edgeIndex,\n  edgesLimit = Infinity,\n}: {\n  key: string | number;\n  value: unknown;\n  replacer?: Replacer | null;\n  seen: unknown[];\n  depth: number;\n  depthLimit?: number;\n  edgeIndex: number;\n  edgesLimit?: number;\n}): unknown {\n  let replacement = value;\n\n  if (seen.includes(replacement)) {\n    replacement = CircularReference;\n  }\n\n  if (replacer) {\n    replacement = replacer(key, replacement);\n  }\n\n  if (hasToJson(replacement)) {\n    replacement = safeAccess(() =>\n      (replacement as withToJson).toJSON(String(key))\n    );\n  }\n\n  // TODO: We really should re-run our cyclic dependency check at this point in\n  // case the replacer or toJSON has created a new cyclic dependency.\n  //\n  // Surely no-one would do that though, right?\n\n  if (replacement === null || typeof replacement !== 'object') {\n    return replacement;\n  }\n\n  if (depth > depthLimit || edgeIndex + 1 > edgesLimit) {\n    return '[...]';\n  }\n\n  seen.push(value);\n\n  if (Array.isArray(replacement)) {\n    const copy: unknown[] = [];\n    const limit = Math.min(replacement.length, edgesLimit);\n\n    for (let i = 0; i < limit; i++) {\n      const item = safeAccess(() => (replacement as unknown[])[i]);\n\n      copy.push(\n        filter({\n          key: i,\n          value: item,\n          replacer,\n          seen,\n          depth,\n          depthLimit,\n          edgeIndex: i,\n          edgesLimit,\n        })\n      );\n    }\n\n    if (limit < replacement.length) {\n      copy.push('[...]');\n    }\n\n    replacement = copy;\n  } else {\n    const copy: Record<string, unknown> = {};\n\n    const keys = Object.keys(replacement as object);\n    for (let i = 0; i < keys.length; i++) {\n      const currentKey = keys[i];\n      const value = safeAccess(\n        () => (replacement as Record<string, unknown>)[currentKey]\n      );\n\n      copy[currentKey] = filter({\n        key: currentKey,\n        value,\n        replacer,\n        seen,\n        depth,\n        depthLimit,\n        edgeIndex: i,\n        edgesLimit,\n      });\n    }\n\n    replacement = copy;\n  }\n\n  seen.pop();\n\n  return replacement;\n}\n\nexport function safeAccess<T>(accessor: () => T): T | typeof AccessError {\n  try {\n    return accessor();\n  } catch {\n    return AccessError;\n  }\n}\n\ntype withToJson = { toJSON: (key?: string) => unknown };\n\nfunction hasToJson(value: unknown): value is withToJson {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'toJSON' in value &&\n    typeof (value as { toJSON: unknown }).toJSON === 'function'\n  );\n}\n","// Based heavily on: https://github.com/mk-pmb/is-error-js\n//\n// which has the following license:\n//\n// Copyright (c) 2015 is-error.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nconst objectToString = Object.prototype.toString;\nconst getPrototypeOf = Object.getPrototypeOf;\nconst ERROR_TYPE = '[object Error]';\n\nexport function isError(a: unknown): a is Error {\n  if (a instanceof Error) {\n    return true;\n  }\n\n  let err = a;\n  while (err) {\n    if (objectToString.call(err) === ERROR_TYPE) {\n      return true;\n    }\n    err = getPrototypeOf(err);\n  }\n\n  return false;\n}\n","export function isObject(a: unknown): a is Record<string, any> {\n  return typeof a === 'object' && a !== null && !Array.isArray(a);\n}\n","import { StackFrame } from './event';\n\n// The following code is based on:\n//\n// https://github.com/stacktracejs/error-stack-parser/blob/master/error-stack-parser.js\n//\n// which is released under the MIT license. Its copyright and license terms\n// are as follows:\n//\n// Copyright (c) 2017 Eric Wendelin and other contributors\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// It has been modified to match Bugsnag's stackframe format, remove unneeded\n// Opera stackframe handling, and use TypeScript and more modern JavaScript.\n\nconst CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\nconst SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n\nexport function parseStack(stackString: string): Array<StackFrame> {\n  const partialResult = stackString.match(CHROME_IE_STACK_REGEXP)\n    ? parseV8OrIE(stackString)\n    : parseFFOrSafari(stackString);\n\n  return partialResult.reduce<StackFrame[]>((result, stack) => {\n    // Drop empty stack frames\n    if (JSON.stringify(stack) === '{}') {\n      return result;\n    }\n\n    // If we have no file or method but we _do_ have a line number, it must be\n    // global code.\n    let file =\n      !stack.file && !stack.method && typeof stack.lineNumber === 'number'\n        ? 'global code'\n        : stack.file || '(unknown file)';\n\n    // Strip the query string / fragment from filenames\n    file = file.replace(/\\?.*$/, '').replace(/#.*$/, '');\n\n    // Case normalize \"global code\" function names\n    let method = stack.method || '(unknown function)';\n    method = /^global code$/i.test(method) ? 'global code' : method;\n\n    return result.concat([\n      {\n        file,\n        lineNumber: stack.lineNumber,\n        columnNumber: stack.columnNumber,\n        method,\n      },\n    ]);\n  }, []);\n}\n\nfunction parseV8OrIE(stackString: string): Array<Partial<StackFrame>> {\n  const filtered = stackString\n    .split('\\n')\n    .filter((line) => !!line.match(CHROME_IE_STACK_REGEXP));\n\n  return filtered.map((line) => {\n    // Bugsnag stack frames don't have a way of representing eval origins\n    // so we just throw that information away for now.\n    //\n    // stacktrace.js can represent this but it still throws this information\n    // away.\n    if (line.indexOf('(eval ') > -1) {\n      line = line\n        .replace(/eval code/g, 'eval')\n        .replace(/(\\(eval at [^()]*)|(\\),.*$)/g, '');\n    }\n    let sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n    // Capture and preserve the parenthesized location \"(/foo/my bar.js:12:87)\"\n    // in case it has spaces in it, as the string is split on \\s+ later on.\n    const location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n    // Remove the parenthesized location from the line, if it was matched.\n    sanitizedLine = location\n      ? sanitizedLine.replace(location[0], '')\n      : sanitizedLine;\n\n    const tokens = sanitizedLine.split(/\\s+/).slice(1);\n\n    // If a location was matched, pass it to extractLocation(), otherwise pop\n    // the last token.\n    const locationParts = extractLocation(\n      location ? location[1] : tokens.pop() || '(no location)'\n    );\n\n    const method = tokens.join(' ') || undefined;\n    const file =\n      ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1\n        ? undefined\n        : locationParts[0];\n\n    return {\n      file,\n      lineNumber: locationParts[1],\n      columnNumber: locationParts[2],\n      method,\n    };\n  });\n}\n\nfunction parseFFOrSafari(stackString: string): Array<Partial<StackFrame>> {\n  const filtered = stackString\n    .split('\\n')\n    .filter((line) => !line.match(SAFARI_NATIVE_CODE_REGEXP));\n\n  return filtered.map((line) => {\n    // Bugsnag stack frames don't have a way of representing eval origins\n    // so we just throw that information away for now.\n    //\n    // stacktrace.js can represent this but it still throws this information\n    // away.\n    if (line.indexOf(' > eval') > -1) {\n      line = line.replace(\n        / line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g,\n        ':$1'\n      );\n    }\n\n    if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n      // Safari eval frames only have function names and nothing else\n      return {\n        method: line,\n      };\n    } else {\n      const functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n      const matches = line.match(functionNameRegex);\n      const method = matches && matches[1] ? matches[1] : undefined;\n      const locationParts = extractLocation(\n        line.replace(functionNameRegex, '')\n      );\n\n      return {\n        file: locationParts[0],\n        lineNumber: locationParts[1],\n        columnNumber: locationParts[2],\n        method,\n      };\n    }\n  });\n}\n\n// Separate line and column numbers from a string of the form: (URI:Line:Column)\nfunction extractLocation(\n  urlLike: string\n): [uri: string, line?: number | undefined, col?: number | undefined] {\n  // Fail-fast but return locations like \"(native)\"\n  if (urlLike.indexOf(':') === -1) {\n    return [urlLike];\n  }\n\n  const regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n  const parts = regExp.exec(urlLike.replace(/[()]/g, ''));\n  if (!parts) {\n    return [urlLike];\n  }\n\n  const line = parts[2] ? parseInt(parts[2], 10) : undefined;\n  const col = parts[3] ? parseInt(parts[3], 10) : undefined;\n\n  return [parts[1], line, col];\n}\n","import type { BugsnagException, StackFrame } from './event';\nimport { isError } from './is-error';\nimport { isObject } from './is-object';\nimport { parseStack } from './parse-stack';\nimport { NonEmptyArray } from './type-helpers';\n\nexport function toExceptions(\n  maybeError: unknown,\n  component: string\n): {\n  exceptions: NonEmptyArray<BugsnagException>;\n  metadata?: Record<string, any>;\n} {\n  const error = normalizeError(maybeError, component);\n\n  // Add metadata for non-errors\n  let metadata: Record<string, any> | undefined;\n  if (error.name === 'InvalidError') {\n    metadata = {\n      [component]: {\n        'non-error parameter': maybeError,\n      },\n    };\n  }\n\n  // Merge any metadata defined on the object itself\n  if (\n    typeof (error as any).metadata !== 'undefined' &&\n    isObject((error as any).metadata)\n  ) {\n    metadata = { ...metadata, [error.name]: (error as any).metadata };\n  }\n\n  const exceptions: NonEmptyArray<BugsnagException> = [makeException(error)];\n\n  // Add any causes\n  exceptions.push(\n    ...getCauses(error).map((cause) =>\n      makeException(cause, { backtrace: false })\n    )\n  );\n\n  return { exceptions, metadata };\n}\n\nfunction normalizeError(maybeError: unknown, component: string): Error {\n  if (isError(maybeError)) {\n    return maybeError;\n  }\n\n  let error = fromSimpleError(maybeError);\n  if (error) {\n    return error;\n  }\n\n  switch (typeof error) {\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return new Error(String(maybeError));\n\n    default: {\n      error = new Error(\n        `${component} received a non-error. See \"${component}\" tab for more detail.`\n      );\n      error.name = 'InvalidError';\n      return error;\n    }\n  }\n}\n\nfunction fromSimpleError(error: unknown): Error | null {\n  if (!isObject(error)) {\n    return null;\n  }\n\n  const getStringMember = (field: string) =>\n    typeof error[field] === 'string' && error[field].length\n      ? error[field]\n      : undefined;\n\n  const name = getStringMember('name') || getStringMember('errorClass');\n  const message = getStringMember('message') || getStringMember('errorMessage');\n  if (!name || !message) {\n    return null;\n  }\n\n  const newError = new Error(message);\n  newError.name = name;\n  return newError;\n}\n\nfunction makeException(\n  error: Error,\n  stackOptions: { backtrace: boolean } = { backtrace: false }\n): BugsnagException {\n  return {\n    errorClass: error.name,\n    message: error.message,\n    stacktrace: getStacktrace(error, stackOptions),\n    type:\n      typeof self === 'object' && (self as Window).navigator\n        ? 'browserjs'\n        : 'nodejs',\n  };\n}\n\nfunction getStacktrace(\n  error: Error,\n  { backtrace }: { backtrace: boolean }\n): Array<StackFrame> {\n  const stackString = getStackString(error);\n  if (stackString) {\n    return parseStack(stackString);\n  } else if (backtrace) {\n    // TODO: We'll probably want to trim this to remove some of our own\n    // frames from it but let's wait until we actually have some examples of\n    // that to work with.\n    return generateBacktrace();\n  } else {\n    return [];\n  }\n}\n\nfunction getStackString(error: Error): string | undefined {\n  const stack = error.stack || (error as any).stacktrace;\n  return typeof stack === 'string' &&\n    stack.length &&\n    stack !== `${error.name}: ${error.message}`\n    ? stack\n    : undefined;\n}\n\nconst MAX_STACK_SIZE = 20;\n\n// The following is based on\n//\n// https://github.com/stacktracejs/stack-generator/blob/master/stack-generator.js\n//\n// which is licensed to the Public Domain.\nfunction generateBacktrace(): Array<StackFrame> {\n  const stack: Array<StackFrame> = [];\n\n  // arguments.callee cannot be accessed in strict mode.\n  let curr: Function;\n  try {\n    // eslint-disable-next-line no-caller\n    curr = arguments.callee;\n  } catch (_e) {\n    return [];\n  }\n\n  while (curr && stack.length < MAX_STACK_SIZE) {\n    if (curr.name) {\n      stack.push({ method: curr.name, file: '(unknown file)' });\n    } else if (/function(?:\\s+([\\w$]+))+\\s*\\(/.test(curr.toString())) {\n      stack.push({ method: RegExp.$1, file: '(unknown file)' });\n    }\n\n    try {\n      curr = curr.caller;\n    } catch (e) {\n      break;\n    }\n  }\n\n  return stack;\n}\n\nfunction getCauses(error: Error): Array<Error> {\n  if (!error.cause) {\n    return [];\n  }\n\n  const cause = normalizeError(error.cause, 'cause');\n  if (cause.name === 'InvalidError') {\n    return [];\n  }\n\n  return [cause].concat(getCauses(cause));\n}\n","import type { ExtendedClientApi, Plugin } from './client';\nimport type { BugsnagException } from './event';\nimport { toExceptions } from './to-exceptions';\nimport { NonEmptyArray } from './type-helpers';\n\nexport const browserNotifyUnhandledExceptions: Plugin = {\n  name: 'browserNotifyUnhandledExceptions',\n  load(client: ExtendedClientApi) {\n    self.addEventListener('error', (evt: ErrorEvent | Event) => {\n      let exceptions: NonEmptyArray<BugsnagException>;\n      let metadata: Record<string, any> | undefined;\n\n      if (evt instanceof ErrorEvent) {\n        const { message, filename: file, lineno, colno, error } = evt;\n        const lineNumber = Number.isSafeInteger(lineno) ? lineno : undefined;\n        if (lineNumber === 0 && /Script error\\.?/.test(message)) {\n          console.log('Ignoring cross-domain or eval script error.');\n          return;\n        }\n\n        ({ exceptions, metadata } = toExceptions(error, 'window onerror'));\n\n        // Augment first stacktrace if we have more info in the ErrorEvent than\n        // the stack trace we got.\n        const columnNumber = Number.isSafeInteger(colno) ? colno : undefined;\n        const { stacktrace } = exceptions[0];\n        if (!stacktrace.length) {\n          stacktrace.push({\n            file,\n            lineNumber,\n            columnNumber,\n            method: '(unknown file)',\n          });\n        } else {\n          const firstStackFrame = stacktrace[0];\n          firstStackFrame.file = firstStackFrame.file || file;\n          firstStackFrame.lineNumber = firstStackFrame.lineNumber ?? lineNumber;\n          firstStackFrame.columnNumber =\n            firstStackFrame.columnNumber ?? columnNumber;\n        }\n      } else {\n        ({ exceptions, metadata } = toExceptions(evt, 'window onerror'));\n      }\n\n      client.notifyEvent(\n        {\n          exceptions,\n          unhandled: true,\n          severity: 'error',\n          severityReason: {\n            type: 'unhandledException',\n          },\n          metadata,\n        },\n        evt\n      );\n    });\n  },\n};\n","import { ExtendedClientApi, Plugin } from './client';\nimport { toExceptions } from './to-exceptions';\n\nexport const browserNotifyUnhandledRejections: Plugin = {\n  name: 'browserNotifyUnhandledRejections',\n  load(client: ExtendedClientApi) {\n    self.addEventListener(\n      'unhandledrejection',\n      (evt: PromiseRejectionEvent) => {\n        const error = evt.reason;\n\n        const { exceptions, metadata } = toExceptions(\n          error,\n          'unhandledrejection'\n        );\n\n        // The official bugsnag client digs into `error` and, if it has no\n        // stack, but is an Error object, it pulls out the name, message, code\n        // and adds them to a metadata tab called 'unhandledRejection handler'.\n        //\n        // I don't understand this. Surely we'll have the same information in\n        // our exception object already?\n\n        client.notifyEvent(\n          {\n            exceptions,\n            unhandled: true,\n            severity: 'error',\n            severityReason: {\n              type: 'unhandledPromiseRejection',\n            },\n            metadata,\n          },\n          error\n        );\n      }\n    );\n  },\n};\n","import { ExtendedClientApi, Plugin } from './client';\n\nexport const consoleBreadcrumbs: Plugin = {\n  name: 'consoleBreadcrumbs',\n  load(client: ExtendedClientApi) {\n    // We need to exclude the 'Console' ctor function because it's in Node's\n    // Console interface but not the DOM one.\n    type nonCtorKeys = Exclude<keyof Console, 'Console'>;\n    const methodsToHook = (\n      ['log', 'debug', 'info', 'warn', 'error'] as Array<nonCtorKeys>\n    ).filter(\n      (method) =>\n        typeof console !== 'undefined' && typeof console[method] === 'function'\n    );\n\n    for (const method of methodsToHook) {\n      const original = console[method];\n      console[method] = (...args: Array<any>) => {\n        client.leaveBreadcrumb(\n          'Console output',\n          args.reduce(\n            (metadata: Record<string, any>, arg: any, i: number) => {\n              // Try to stringify each argument\n              let stringified = '[Unknown value]';\n\n              // Try to use toString.\n              //\n              // This may fail if the input is:\n              //\n              // - an object whose [[Prototype]] is null (no toString), or\n              // - an object with a broken toString or @@toPrimitive\n              //   implementation\n              try {\n                stringified = String(arg);\n              } catch (_e) {\n                /* Ignore */\n              }\n\n              // If it stringifies to [object Object] attempt to JSON stringify\n              if (stringified === '[object Object]') {\n                // But catch any stringify errors (falling back to\n                // [object Object])\n                try {\n                  stringified = JSON.stringify(arg);\n                } catch (_e) {\n                  /* Ignore */\n                }\n              }\n\n              metadata[`[${i}]`] = stringified;\n              return metadata;\n            },\n            {\n              // The official client attempts to map console.group to 'log' here\n              // but it never actually hooks console.group.\n              severity: method,\n            }\n          ),\n          'log'\n        );\n        original.apply(console, args);\n      };\n    }\n  },\n};\n","import { ExtendedClientApi, Plugin } from './client';\nimport { BugsnagEvent } from './event';\n\nexport const errorBreadcrumbs: Plugin = {\n  name: 'errorBreadcrumbs',\n  load(client: ExtendedClientApi) {\n    client.addOnPostError((event: BugsnagEvent) => {\n      client.leaveBreadcrumb(\n        event.exceptions[0].errorClass,\n        {\n          errorClass: event.exceptions[0].errorClass,\n          errorMessage: event.exceptions[0].message,\n          severity: event.severity,\n        },\n        'error'\n      );\n    });\n  },\n};\n","import { ExtendedClientApi, Plugin } from './client';\nimport { isObject } from './is-object';\n\n// Unlike the official bugsnag JS client this does NOT cover XHR.\n// Furthermore, it does not provide a way to be cleaned up.\nexport const fetchBreadcrumbs: Plugin = {\n  name: 'fetchBreadcrumbs',\n  load(client: ExtendedClientApi) {\n    if (!('fetch' in self)) {\n      return;\n    }\n\n    const oldFetch = self.fetch;\n    self.fetch = function fetch(input: RequestInfo | URL, init?: RequestInit) {\n      let method = 'GET';\n      let url: string;\n\n      if (isRequest(input)) {\n        url = input.url;\n        method = input.method;\n      } else {\n        url = input.toString();\n      }\n\n      // Per the fetch algorithm, the method specified in the RequestInit takes\n      // precedence over the method specified in the Request.\n      if (init && typeof init.method === 'string' && init.method.length) {\n        method = init.method;\n      }\n\n      const leaveBreadcrumb = client.leaveBreadcrumb.bind(client);\n      return new Promise((resolve, reject) => {\n        oldFetch(input, init)\n          .then((response) => {\n            handleFetchSuccess({ response, method, url, leaveBreadcrumb });\n            resolve(response);\n          })\n          .catch((error) => {\n            handleFetchError({ method, url, leaveBreadcrumb });\n            reject(error);\n          });\n      });\n    };\n  },\n};\n\nfunction isRequest(input: RequestInfo | URL): input is Request {\n  // instanceof alone won't work for objects from different realms\n  return input instanceof Request || (isObject(input) && 'url' in input);\n}\n\nfunction handleFetchSuccess({\n  response,\n  method,\n  url,\n  leaveBreadcrumb,\n}: {\n  response: Response;\n  method: string;\n  url: string;\n  leaveBreadcrumb: ExtendedClientApi['leaveBreadcrumb'];\n}) {\n  // The official bugsnag client ignores bugsnag requests for XHR but not for\n  // fetch. I think it means to ignore it for fetch, though.\n  if (url.startsWith('https://notify.bugsnag.com')) {\n    return;\n  }\n\n  const metadata = {\n    status: response.status,\n    request: `${method} ${url}`,\n  };\n\n  if (response.status >= 400) {\n    leaveBreadcrumb('fetch() failed', metadata, 'request');\n  } else {\n    leaveBreadcrumb('fetch() succeeded', metadata, 'request');\n  }\n}\n\nfunction handleFetchError({\n  method,\n  url,\n  leaveBreadcrumb,\n}: {\n  method: string;\n  url: string;\n  leaveBreadcrumb: ExtendedClientApi['leaveBreadcrumb'];\n}) {\n  if (url.startsWith('https://notify.bugsnag.com')) {\n    return;\n  }\n\n  leaveBreadcrumb('fetch() error', { request: `${method} ${url}` }, 'request');\n}\n","import { isObject } from './is-object';\nimport { ExtendedClientApi, Plugin } from './client';\n\nexport const interactionBreadcrumbs: Plugin = {\n  name: 'interactionBreadcrumbs',\n  load(client: ExtendedClientApi) {\n    if (!('addEventListener' in self)) {\n      return;\n    }\n\n    self.addEventListener(\n      'click',\n      (event) => {\n        let targetText, targetSelector;\n        try {\n          targetText = isHtmlElement(event.target)\n            ? getNodeText(event.target)\n            : '(Non-HTML Element)';\n          targetSelector = isElement(event.target)\n            ? getNodeSelector(event.target)\n            : '(Non-element target)';\n        } catch (e) {\n          targetText = '[hidden]';\n          targetSelector = '[hidden]';\n        }\n        client.leaveBreadcrumb(\n          'UI click',\n          { targetText, targetSelector },\n          'user'\n        );\n      },\n      true\n    );\n  },\n};\n\nfunction isElement(target: EventTarget | null): target is Element {\n  return isObject(target) && (target as Node).nodeType === Node.ELEMENT_NODE;\n}\n\nfunction isHtmlElement(target: EventTarget | null): target is HTMLElement {\n  return (\n    isElement(target) && target.namespaceURI === 'http://www.w3.org/1999/xhtml'\n  );\n}\n\nfunction getNodeText(elem: HTMLElement): string {\n  let text = elem.textContent || elem.innerText || '';\n  if (\n    !text &&\n    ((elem as HTMLInputElement).type === 'submit' ||\n      (elem as HTMLInputElement).type === 'button')\n  ) {\n    text = (elem as HTMLInputElement).value;\n  }\n  return truncate(text.trim(), 140);\n}\n\n// Create a label from tagname, id and css class of the element\nfunction getNodeSelector(elem: Element): string {\n  // Generate an initial selector using ID + class names\n  //\n  // (This is particularly unsuitable for utility CSS frameworks like Tailwind\n  // but oh well)\n  const parts = [elem.tagName];\n  if (elem.id) {\n    parts.push('#' + elem.id);\n  }\n  if (elem.className && elem.className.length) {\n    parts.push(`.${elem.className.split(' ').join('.')}`);\n  }\n\n  // We can't try out the selector in this context so just return it as-is.\n  if (!self.document.querySelectorAll) {\n    return parts.join('');\n  }\n\n  // See if the selector we have generated is sufficiently specific\n  try {\n    if (self.document.querySelectorAll(parts.join('')).length === 1) {\n      return parts.join('');\n    }\n  } catch {\n    // Sometimes the query selector can be invalid just return it as-is.\n    return parts.join('');\n  }\n\n  // Try to get a more specific selector if this one matches more than one\n  // element.\n  if (elem.parentNode && elem.parentNode.childNodes.length > 1) {\n    const index = Array.from(elem.parentNode.children).indexOf(elem) + 1;\n    parts.push(`:nth-child(${index})`);\n  }\n\n  if (self.document.querySelectorAll(parts.join('')).length === 1) {\n    return parts.join('');\n  }\n\n  // Try prepending the parent element selector\n  if (elem.parentElement) {\n    return `${getNodeSelector(elem.parentElement)} > ${parts.join('')}`;\n  }\n\n  return parts.join('');\n}\n\nfunction truncate(value: string, length: number): string {\n  const ommision = '(...)';\n  return value.length <= length\n    ? value\n    : value.slice(0, length - ommision.length) + ommision;\n}\n","import { ExtendedClientApi, Plugin } from './client';\n\nexport const navigationBreadcrumbs: Plugin = {\n  name: 'navigationBreadcrumbs',\n  load(client: ExtendedClientApi) {\n    if (!('addEventListener' in self)) {\n      return;\n    }\n\n    const drop = (name: string) => () =>\n      client.leaveBreadcrumb(name, undefined, 'navigation');\n\n    self.addEventListener('pagehide', drop('Page hidden'), true);\n    self.addEventListener('pageshow', drop('Page shown'), true);\n    self.addEventListener('load', drop('Page loaded'), true);\n    if (self.document) {\n      self.document.addEventListener(\n        'DOMContentLoaded',\n        drop('DOMContentLoaded'),\n        true\n      );\n    }\n\n    // Some browsers like to emit popstate when the page loads, so only add the\n    // popstate listener after that\n    self.addEventListener('load', () =>\n      self.addEventListener('popstate', drop('Navigated back'), true)\n    );\n\n    // hashchange has some metadata that we care about\n    if (self.location) {\n      self.addEventListener(\n        'hashchange',\n        (event: HashChangeEvent) => {\n          const metadata = event.oldURL\n            ? {\n                from: relativeLocation(event.oldURL),\n                to: relativeLocation(event.newURL),\n                state: getCurrentState(self),\n              }\n            : { to: relativeLocation(self.location.href) };\n          client.leaveBreadcrumb('Hash changed', metadata, 'navigation');\n        },\n        true\n      );\n    }\n\n    // Wrap replaceState/pushState\n    const leaveBreadcrumb = client.leaveBreadcrumb.bind(client);\n    if (self.history && self instanceof Window) {\n      if (typeof self.history.replaceState === 'function') {\n        wrapHistoryFn({\n          fn: 'replaceState',\n          target: self.history,\n          leaveBreadcrumb,\n          win: self,\n        });\n      }\n      if (typeof self.history.pushState === 'function') {\n        wrapHistoryFn({\n          fn: 'pushState',\n          target: self.history,\n          leaveBreadcrumb,\n          win: self,\n        });\n      }\n    }\n  },\n};\n\n// Takes a full url like http://foo.com:1234/pages/01.html?yes=no#section-2 and\n// returns just the path and hash parts, e.g. /pages/01.html?yes=no#section-2\n//\n// Compatibility: This uses the URL constructor which is not available in IE\n// or Edge < 12.\nfunction relativeLocation(url: string): string {\n  try {\n    const urlObj = new URL(url);\n    return `${urlObj.pathname}${urlObj.search}${urlObj.hash}`;\n  } catch (e) {\n    return url;\n  }\n}\n\nfunction getCurrentState(win: Window): any {\n  try {\n    return win.history.state;\n  } catch (e) {\n    return {};\n  }\n}\n\nfunction wrapHistoryFn({\n  fn,\n  leaveBreadcrumb,\n  target,\n  win,\n}: {\n  fn: 'replaceState' | 'pushState';\n  leaveBreadcrumb: ExtendedClientApi['leaveBreadcrumb'];\n  target: History;\n  win: Window;\n}) {\n  const orig = target[fn];\n  target[fn] = (state: any, title: string, url?: string | null | undefined) => {\n    leaveBreadcrumb(\n      `History ${fn}`,\n      stateChangeToMetadata({ win, state, title, url }),\n      'navigation'\n    );\n\n    // TODO: If we implement maxEvents, reset that count here.\n\n    orig.apply(target, [state, title, url]);\n  };\n}\n\nfunction stateChangeToMetadata({\n  win,\n  state,\n  title,\n  url,\n}: {\n  win: Window;\n  state: any;\n  title: string;\n  url?: string | null | undefined;\n}) {\n  const currentPath = relativeLocation(win.location.href);\n\n  return {\n    title,\n    state,\n    prevState: getCurrentState(win),\n    to: url || currentPath,\n    from: currentPath,\n  };\n}\n","import { ExtendedClientApi, Plugin } from './client';\nimport { BugsnagEvent } from './event';\n\nlet appStart = Date.now();\nconst reset = () => {\n  appStart = Date.now();\n};\n\nexport const appDuration: Plugin = {\n  name: 'appDuration',\n  load(client: ExtendedClientApi) {\n    client.addOnError((event: BugsnagEvent) => {\n      const now = Date.now();\n      event.app = event.app || {};\n      event.app.duration = now - appStart;\n    });\n\n    return { reset };\n  },\n};\n","import { UserAgentInfo } from './browser-context';\n\n// The Bugsnag v5 API requires doing your own UA string parsing, requiring a\n// `browserName`, `browserVersion`, `osName`, `osVersion`, etc.\n//\n// That's very unfriendly and probably why the official client still uses the v4\n// API which takes a `userAgent` parameter and appears to parse it on the\n// server.\n//\n// Nevertheless, we're using the v5 API for now so we should do the parsing\n// ourselves.\n//\n// Note that UA parser libraries typically are very heavyweight since they try\n// to cover every user agent that ever existed including various bots etc.\n//\n// However, all we really care about is differentiating between the most common\n// _browsers_ and their respective platforms / OSes.\n//\n// Furthermore, we want this to be as lightweight as possible so this is very\n// deliberately a very barebones approach. We can add other user agents if and\n// when they become interesting.\n//\n// This is based on\n// https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts but\n// adapted quite heavily.\n\nexport function parseUserAgent(userAgent: string): UserAgentInfo {\n  const matchedRule: UserAgentMatch = matchUserAgent(userAgent);\n\n  if (!matchedRule) {\n    return {};\n  }\n\n  const [name, match] = matchedRule;\n  const os = detectOS(userAgent);\n  const device = os?.osName === 'iOS' ? detectAppleDevice(userAgent) : {};\n\n  return {\n    browserName: name,\n    browserVersion: match[1],\n    osName: os?.osName,\n    osVersion: os?.osVersion,\n    manufacturer: device?.manufacturer,\n    model: device?.model,\n  };\n}\n\ntype UserAgentRule = [string, RegExp];\nconst userAgentRules: UserAgentRule[] = [\n  ['Edge (EdgeHTML)', /Edge\\/([0-9._]+)/],\n  ['Edge (iOS)', /EdgiOS\\/([0-9._]+)/],\n  ['Yandex', /YaBrowser\\/([0-9._]+)/],\n  ['KakaoTalk', /KAKAOTALK\\s([0-9.]+)/],\n  ['Samsung', /SamsungBrowser\\/([0-9.]+)/],\n  ['Silk', /\\bSilk\\/([0-9._-]+)\\b/],\n  ['MIUI', /MiuiBrowser\\/([0-9.]+)$/],\n  ['Beaker', /BeakerBrowser\\/([0-9.]+)/],\n  ['Edge (Chromium)', /EdgA?\\/([0-9.]+)/],\n  ['Chromium WebView', /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9.]+)(:?\\s|$)/],\n  ['Chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9.]+)(:?\\s|$)/],\n  ['Chrome (iOS)', /CriOS\\/([0-9.]+)(:?\\s|$)/],\n  ['Firefox', /Firefox\\/([0-9.]+)(?:\\s|$)/],\n  ['Firefox (iOS)', /FxiOS\\/([0-9.]+)/],\n  ['Opera Mini', /Opera Mini.*Version\\/([0-9.]+)/],\n  ['Opera', /Opera\\/([0-9.]+)(?:\\s|$)/],\n  ['Opera', /OPR\\/([0-9.]+)(:?\\s|$)/],\n  ['Internet Explorer', /Trident\\/7\\.0.*rv:([0-9.]+).*\\).*Gecko$/],\n  ['Internet Explorer', /MSIE\\s([0-9.]+);.*Trident\\/[4-7].0/],\n  ['Internet Explorer', /MSIE\\s(7\\.0)/],\n  ['Blackberry', /BB10;\\sTouch.*Version\\/([0-9.]+)/],\n  ['Android', /Android\\s([0-9.]+)/],\n  ['Safari (iOS)', /Version\\/([0-9._]+).*Mobile.*Safari.*/],\n  ['Safari', /Version\\/([0-9._]+).*Safari/],\n  ['Facebook', /FB[AS]V\\/([0-9.]+)/],\n  ['Instagram', /Instagram\\s([0-9.]+)/],\n  ['iOS WebView', /AppleWebKit\\/([0-9.]+).*Mobile/],\n  ['iOS WebView', /AppleWebKit\\/([0-9.]+).*Gecko\\)$/],\n];\n\ntype UserAgentMatch = [string, RegExpExecArray] | false;\n\nfunction matchUserAgent(userAgent: string): UserAgentMatch {\n  return (\n    userAgent !== '' &&\n    userAgentRules.reduce<UserAgentMatch>(\n      (matched: UserAgentMatch, [browser, regex]) => {\n        if (matched) {\n          return matched;\n        }\n\n        const uaMatch = regex.exec(userAgent);\n        return !!uaMatch && [browser, uaMatch];\n      },\n      false\n    )\n  );\n}\n\ntype OperatingSystemRule = [string, string | undefined, RegExp];\n\nconst operatingSystemRules: OperatingSystemRule[] = [\n  ['iOS', undefined, /iP(hone|od|ad)/],\n  ['Android', undefined, /Android/],\n  ['BlackBerry', undefined, /BlackBerry|BB10/],\n  ['Windows Mobile', undefined, /IEMobile/],\n  ['Kindle', undefined, /Kindle/],\n  ['Windows', '3.11', /Win16/],\n  ['Windows', '95', /(Windows 95)|(Win95)|(Windows_95)/],\n  ['Windows', '98', /(Windows 98)|(Win98)/],\n  ['Windows', '2000', /(Windows NT 5.0)|(Windows 2000)/],\n  ['Windows', 'XP', /(Windows NT 5.1)|(Windows XP)/],\n  ['Windows', 'Server 2003', /(Windows NT 5.2)/],\n  ['Windows', 'Vista', /(Windows NT 6.0)/],\n  ['Windows', '7', /(Windows NT 6.1)/],\n  ['Windows', '8', /(Windows NT 6.2)/],\n  ['Windows', '8.1', /(Windows NT 6.3)/],\n  ['Windows', '10+', /(Windows NT 10.0)/],\n  ['Windows', 'ME', /Windows ME/],\n  ['Open BSD', undefined, /OpenBSD/],\n  ['Sun OS', undefined, /SunOS/],\n  ['Chrome OS', undefined, /CrOS/],\n  ['Linux', undefined, /(Linux)|(X11)/],\n  ['Mac OS', undefined, /(Mac_PowerPC)|(Macintosh)/],\n  ['QNX', undefined, /QNX/],\n  ['BeOS', undefined, /BeOS/],\n  ['OS/2', undefined, /OS\\/2/],\n];\n\nfunction detectOS(\n  userAgent: string\n): { osName: string; osVersion?: string } | null {\n  for (const [osName, osVersion, regex] of operatingSystemRules) {\n    const match = regex.exec(userAgent);\n    if (match) {\n      return { osName, osVersion };\n    }\n  }\n\n  return null;\n}\n\nfunction detectAppleDevice(userAgent: string): {\n  manufacturer?: string;\n  model?: string;\n} | null {\n  const matches = /iPad|iPhone|iPod/.exec(userAgent);\n  if (matches) {\n    return { manufacturer: 'Apple', model: matches[0] };\n  }\n\n  if (\n    /MacIntel/.test(userAgent) &&\n    self.navigator &&\n    self.navigator.maxTouchPoints &&\n    self.navigator.maxTouchPoints > 2\n  ) {\n    return { manufacturer: 'Apple', model: 'iPad' };\n  }\n\n  return null;\n}\n","import { ExtendedClientApi, Plugin } from './client';\nimport { BugsnagEvent } from './event';\nimport { parseUserAgent } from './simple-ua-parser';\n\nexport type UserAgentInfo = {\n  browserName?: string;\n  browserVersion?: string;\n  osName?: string;\n  osVersion?: string;\n  manufacturer?: string;\n  model?: string;\n  modelNumber?: string;\n};\n\nexport type UserAgentParserFn = (userAgent: string) => UserAgentInfo;\n\nexport const browserContextWithUaParser = (\n  uaParser: UserAgentParserFn\n): Plugin => {\n  return {\n    name: 'browserContext',\n    load(client: ExtendedClientApi) {\n      client.addOnError((event: BugsnagEvent) => {\n        event.request = { ...event.request, url: self.location.href };\n        event.context = event.context || self.location.pathname;\n\n        event.device = {\n          ...event.device,\n          ...uaParser(self.navigator.userAgent),\n          locale: self.navigator.language,\n          userAgent: self.navigator.userAgent,\n        };\n\n        let languages: ReadonlyArray<string> = ['n/a'];\n        try {\n          languages = self.navigator.languages;\n        } catch {\n          /* Ignore */\n        }\n\n        event.metaData = {\n          ...event.metaData,\n          language: {\n            language: self.navigator.language,\n            languages,\n          },\n        };\n      });\n    },\n  };\n};\n\nexport const browserContext: Plugin =\n  browserContextWithUaParser(parseUserAgent);\n","import { ExtendedClientApi, Plugin } from './client';\nimport { BugsnagEvent, DeviceOrientation } from './event';\n\nexport const deviceOrientation: Plugin = {\n  name: 'deviceOrientation',\n  load(client: ExtendedClientApi) {\n    client.addOnError((event: BugsnagEvent) => {\n      let orientation: DeviceOrientation | undefined;\n\n      const screen = self.screen;\n      if (screen && screen.orientation && screen.orientation.type) {\n        orientation = screen.orientation.type;\n      } else if (self.document && self.document.documentElement) {\n        orientation =\n          self.document.documentElement.clientWidth >\n          self.document.documentElement.clientHeight\n            ? 'landscape'\n            : 'portrait';\n      }\n\n      if (orientation) {\n        event.device = { ...event.device, orientation };\n      }\n    });\n  },\n};\n","import { ExtendedClientApi, Plugin } from './client';\n\nexport const limitEvents = (limit: number): Plugin => {\n  let n = 0;\n\n  const reset = () => {\n    n = 0;\n  };\n\n  if (typeof window !== 'undefined') {\n    window.addEventListener('popstate', reset);\n  }\n\n  return {\n    name: 'limitEvents',\n    load(client: ExtendedClientApi) {\n      client.addOnError(function throttle(): boolean | void {\n        if (n >= limit) {\n          return false;\n        }\n        n++;\n      });\n\n      return { reset };\n    },\n  };\n};\n","import {\n  AccessError,\n  CircularReference,\n  safeAccess,\n  safeFilter,\n} from './safe-filter';\n\nexport function stringify(\n  input: unknown,\n  options?: {\n    depthLimit?: number;\n    edgesLimit?: number;\n  }\n): unknown {\n  return safeFilter(\n    input,\n    (_key: string | number, value: unknown) => {\n      if (value === CircularReference) {\n        return '[Circular]';\n      }\n\n      if (value === AccessError) {\n        return '[Error]';\n      }\n\n      if (\n        typeof value === 'bigint' ||\n        typeof value === 'symbol' ||\n        value instanceof RegExp\n      ) {\n        return safeAccess(() => (value as any).toString());\n      }\n\n      if (value instanceof Map) {\n        return {\n          type: 'Map',\n          value: safeAccess(() => [...(value as Map<any, any>).entries()]),\n        };\n      }\n\n      if (value instanceof Set) {\n        return {\n          type: 'Set',\n          value: safeAccess(() => [...(value as Set<any>).values()]),\n        };\n      }\n\n      if (typeof value === 'function') {\n        return safeAccess(() =>\n          truncateString(\n            (value as Function).toString().replace(/\\s+/g, ' '),\n            50\n          )\n        );\n      }\n\n      if (value instanceof Error) {\n        const replacement = {};\n        for (const key of Object.getOwnPropertyNames(value)) {\n          (replacement as Record<string, any>)[key] = safeAccess(\n            () => (value as any)[key]\n          );\n        }\n        return replacement;\n      }\n\n      if (value instanceof ArrayBuffer) {\n        return `ArrayBuffer(${value.byteLength})`;\n      }\n\n      return value;\n    },\n    options\n  );\n}\n\nfunction truncateString(input: string, maxLength: number) {\n  return input.length > maxLength\n    ? input.substring(0, maxLength - 3) + '...'\n    : input;\n}\n","import type { ExtendedClientApi, Plugin } from './client';\nimport type { BugsnagEvent } from './event';\nimport { stringify } from './stringify';\n\n/**\n * Plugin to try to stringify various unserializable JS objects (e.g. bigints,\n * Maps, Sets, functions, Error objects, Regexps) in Bugsnag events.\n */\nexport const stringifyValues: Plugin = {\n  name: 'stringifyValues',\n  load(client: ExtendedClientApi) {\n    client.addOnError(function stringifyValues(event: BugsnagEvent) {\n      if (event.metaData) {\n        event.metaData = stringify(event.metaData) as BugsnagEvent['metaData'];\n      }\n\n      if (event.breadcrumbs) {\n        event.breadcrumbs = event.breadcrumbs.map((breadcrumb) => ({\n          ...breadcrumb,\n          metaData: stringify(breadcrumb.metaData),\n        })) as BugsnagEvent['breadcrumbs'];\n      }\n    });\n  },\n};\n","import { ExtendedClientApi, Plugin } from './client';\nimport { toExceptions } from './to-exceptions';\n\nexport const browserHandledRejectionBreadcrumbs: Plugin = {\n  name: 'browserHandledRejectionBreadcrumbs',\n  load(client: ExtendedClientApi) {\n    self.addEventListener('rejectionhandled', (evt: PromiseRejectionEvent) => {\n      const error = evt.reason;\n\n      const { exceptions } = toExceptions(error, 'handledrejection');\n      const message = `Handled Promise rejection: [${exceptions[0].errorClass}] ${exceptions[0].message}`;\n\n      client.leaveBreadcrumb(\n        message,\n        { stacktrace: exceptions[0].stacktrace },\n        'error'\n      );\n    });\n  },\n};\n","import {\n  Client,\n  Delivery,\n  EventForDelivery,\n  ExtendedClientApi,\n  OnErrorCallback,\n  OnPostErrorCallback,\n  PartialEvent,\n} from './client';\nimport { Config } from './config';\nimport { Breadcrumb, BreadcrumbType, BugsnagEvent, User } from './event';\nimport { FetchDelivery } from './fetch-delivery';\nimport { Notifier } from './notifier';\nimport { safeFilter } from './safe-filter';\nimport { toExceptions } from './to-exceptions';\n\n// eslint-disable-next-line typescript-eslint(no-unsafe-declaration-merging)\nclass BugsnagStatic implements ExtendedClientApi {\n  private breadcrumbs: Array<Breadcrumb> = [];\n  private config: Config | undefined;\n  private delivery: Delivery = new FetchDelivery(this);\n  private errorCallbacks: Set<OnErrorCallback> = new Set();\n  private postErrorCallbacks: Set<OnPostErrorCallback> = new Set();\n  private plugins: Array<{ name: string; plugin: any }> = [];\n\n  start(config: Config): Client {\n    if (this.config) {\n      console.error(\n        'Bugsnag.start called multiple times. Subsequent invocations will be ignored'\n      );\n      return this;\n    }\n\n    this.config = config;\n\n    let errorCallbacks: Array<OnErrorCallback> | undefined = undefined;\n    if (this.config.onError) {\n      errorCallbacks =\n        typeof this.config.onError === 'function'\n          ? [this.config.onError]\n          : this.config.onError;\n    }\n    this.errorCallbacks = new Set(errorCallbacks);\n\n    for (const plugin of this.config.plugins || []) {\n      this.plugins.push({\n        name: plugin.name || 'unknown',\n        plugin: plugin.load(this),\n      });\n    }\n\n    this.leaveBreadcrumb('Bugsnag loaded', {}, 'state');\n\n    return this;\n  }\n\n  get endpoints() {\n    return {\n      notify: this.config?.endpoints?.notify || 'https://notify.bugsnag.com/',\n    };\n  }\n\n  notify<ErrorType = unknown>(\n    error: ErrorType,\n    options:\n      | {\n          metadata?: Record<string, any>;\n          severity?: BugsnagEvent['severity'];\n        }\n      | OnErrorCallback = {}\n  ): Promise<void> {\n    let { exceptions, metadata } = toExceptions(error, 'notify');\n\n    let onError: OnErrorCallback | undefined;\n    let severity: BugsnagEvent['severity'] | undefined;\n\n    if (typeof options === 'function') {\n      onError = options;\n    } else {\n      severity = options.severity;\n      if (options.metadata) {\n        metadata = { ...metadata, ...options.metadata };\n      }\n    }\n\n    return this.notifyEvent(\n      {\n        exceptions,\n        metadata,\n        severity,\n        onError,\n      },\n      error\n    );\n  }\n\n  leaveBreadcrumb(\n    message: string,\n    metadata?: Record<string, any>,\n    type?: BreadcrumbType\n  ): void {\n    if (!this.config) {\n      // The official bugsnag client will produce a console eror in this case\n      // but that's annoying since often unit tests will exercise code that\n      // calls notify/leaveBreadcrumb and we don't want to have to either:\n      //\n      // (a) wrap each call to bugsnag in an \"isTest\" conditional, or\n      // (b) ensure the bugsnag client is initialized at the start of each\n      //     test\n      return;\n    }\n\n    // It appears we sometimes get non-string `message` values here.\n    if (typeof message !== 'string') {\n      try {\n        message = String(message);\n      } catch {\n        message = 'Unable to stringify breadcrumb message';\n      }\n    }\n\n    if (!message.length) {\n      return;\n    }\n\n    this.breadcrumbs.push({\n      name: message,\n      metaData: metadata,\n      type: type || 'manual',\n      timestamp: new Date().toISOString(),\n    });\n\n    const { maxBreadcrumbs = 25 } = this.config;\n    if (this.breadcrumbs.length > maxBreadcrumbs) {\n      this.breadcrumbs.splice(0, this.breadcrumbs.length - maxBreadcrumbs);\n    }\n  }\n\n  async notifyEvent(\n    {\n      exceptions,\n      unhandled,\n      severity,\n      severityReason,\n      metadata,\n      onError,\n    }: PartialEvent,\n    originalError: unknown\n  ): Promise<void> {\n    if (!this.config) {\n      // The official bugsnag client will produce a console eror in this case\n      // but that's annoying since often unit tests will exercise code that\n      // calls notify/leaveBreadcrumb and we don't want to have to either:\n      //\n      // (a) wrap each call to bugsnag in an \"isTest\" conditional, or\n      // (b) ensure the bugsnag client is initialized at the start of each\n      //     test\n      return;\n    }\n\n    // Check if the current release stage is enabled\n    const releaseStage = this.config.releaseStage || 'production';\n    if (\n      this.config.enabledReleaseStages &&\n      !this.config.enabledReleaseStages.includes(releaseStage)\n    ) {\n      return;\n    }\n\n    const event: BugsnagEvent = {\n      exceptions,\n      breadcrumbs: this.breadcrumbs.length ? this.breadcrumbs : undefined,\n      originalError,\n      unhandled: typeof unhandled !== 'boolean' ? false : unhandled,\n      severity: severity || 'warning',\n      severityReason,\n      user: this.config.user || undefined,\n      app: {\n        releaseStage,\n        version: this.config.appVersion,\n        type:\n          this.config.appType ||\n          (typeof window === 'object' ? 'browser' : 'node'),\n      },\n      device: { time: new Date().toISOString() },\n      metaData: metadata || {},\n    };\n\n    // Error callbacks\n\n    const errorCallbacks = [...this.errorCallbacks];\n    if (onError) {\n      errorCallbacks.push(onError);\n    }\n\n    // Make sure the redact and stringifyValues callbacks come last\n    const sortLast = ['stringifyValues', 'redact'];\n    errorCallbacks.sort((a, b) => {\n      if (sortLast.includes(a.name) && sortLast.includes(b.name)) {\n        return 0;\n      } else if (sortLast.includes(a.name)) {\n        return 1;\n      } else if (sortLast.includes(b.name)) {\n        return -1;\n      } else {\n        return 0;\n      }\n    });\n\n    for (const callback of errorCallbacks) {\n      const callbackResult = await callback(event);\n      if (typeof callbackResult === 'boolean' && !callbackResult) {\n        return;\n      }\n    }\n\n    const notifier: Notifier = {\n      name: '@birchill/bugsnag-zero',\n      version: '1',\n      url: 'https://github.com/birchill/bugsnag-zero',\n    };\n\n    const eventForDelivery = safeFilter(\n      event,\n      (key, value) => {\n        if (key === 'originalError') {\n          return undefined;\n        }\n        return value;\n      },\n      { depthLimit: 20, edgesLimit: 500 }\n    ) as EventForDelivery;\n\n    let body: string;\n    const payload = {\n      apiKey: this.config.apiKey,\n      payloadVersion: '5',\n      notifier,\n      events: [eventForDelivery],\n    };\n\n    try {\n      body = JSON.stringify(payload);\n    } catch {\n      eventForDelivery.metaData = {\n        notifier: 'Unable to serialize metadata',\n      };\n\n      body = JSON.stringify(payload);\n    }\n\n    // Check the size of the payload\n    if (body.length > 10e5) {\n      eventForDelivery.metaData = {\n        notifier: `Payload was ${body.length / 10e5}Mb. Metadata removed.`,\n      };\n      body = JSON.stringify(payload);\n      if (body.length > 10e5) {\n        throw new Error('Payload exceeded 1Mb limit');\n      }\n    }\n\n    // Although it's called \"post error\" we run these callbacks before we\n    // actually send the event over the network since sending is async and if\n    // the callback is logging the fact that an error was recorded then we want\n    // that log entry to appear in the correct sequence, particularly if other\n    // things take place while the fetch is still happenning.\n    for (const callback of this.postErrorCallbacks) {\n      callback(event);\n    }\n\n    try {\n      await this.delivery.sendEvent(payload);\n    } catch (e) {\n      console.error('Failed to post report to Bugsnag', e);\n    }\n  }\n\n  getUser(): User {\n    return this.config?.user || {};\n  }\n\n  setUser(id?: string, email?: string, name?: string): void {\n    if (!this.config) {\n      return;\n    }\n\n    this.config.user = { id, email, name };\n  }\n\n  addOnError(fn: OnErrorCallback): void {\n    this.errorCallbacks.add(fn);\n  }\n\n  removeOnError(fn: OnErrorCallback): void {\n    this.errorCallbacks.delete(fn);\n  }\n\n  addOnPostError(fn: OnPostErrorCallback): void {\n    this.postErrorCallbacks.add(fn);\n  }\n\n  removeOnPostError(fn: OnPostErrorCallback): void {\n    this.postErrorCallbacks.delete(fn);\n  }\n\n  getPlugin(name: string): unknown {\n    return this.plugins.find((plugin) => plugin.name === name)?.plugin;\n  }\n\n  setDelivery(delivery: Delivery) {\n    this.delivery = delivery;\n  }\n}\n\nconst Bugsnag = new BugsnagStatic();\n\nexport default Bugsnag;\nexport {\n  Client,\n  Delivery,\n  ExtendedClientApi,\n  NotifiableError,\n  Plugin,\n} from './client';\nexport { Config } from './config';\nexport { fromLegacyConfig, LegacyConfig } from './legacy-config';\nexport { BugsnagEvent as Event } from './event';\nexport { Notifier } from './notifier';\n\n// Breadcrumb loggers\nexport { consoleBreadcrumbs } from './console-breadcrumbs';\nexport { errorBreadcrumbs } from './error-breadcrumbs';\nexport { fetchBreadcrumbs } from './fetch-breadcrumbs';\nexport { interactionBreadcrumbs } from './interaction-breadcrumbs';\nexport { navigationBreadcrumbs } from './navigation-breadcrumbs';\nexport { browserHandledRejectionBreadcrumbs } from './browser-handled-rejection-breadcrumbs';\n\n// Error notifiers\nexport { browserNotifyUnhandledExceptions } from './browser-unhandled-exceptions';\nexport { browserNotifyUnhandledRejections } from './browser-unhandled-rejections';\nexport { nodeNotifyUnhandledRejections } from './node-unhandled-rejections';\nexport { nodeNotifyUnhandledExceptions } from './node-unhandled-exceptions';\n\n// Other plugins\nexport { appDuration } from './app-duration';\nexport {\n  browserContext,\n  browserContextWithUaParser,\n  UserAgentParserFn,\n  UserAgentInfo,\n} from './browser-context';\nexport { deviceOrientation } from './deviceorientation';\nexport { limitEvents } from './limit-events';\nexport {\n  ReactPlugin,\n  ReactPluginResult,\n  ErrorBoundaryProps,\n  FallbackComponentProps,\n} from './react';\nexport {\n  redactEvent,\n  redactKeys,\n  RedactKeysPluginResult,\n  redactObject,\n} from './redact-keys';\nexport { stringifyValues } from './stringify-values';\n\n// Delivery plugins\nexport { FetchDelivery } from './fetch-delivery';\n\ninterface BugsnagStatic {\n  getPlugin(id: 'react'): import('./react').ReactPluginResult | undefined;\n  getPlugin(\n    id: 'redactKeys'\n  ): import('./redact-keys').RedactKeysPluginResult | undefined;\n  getPlugin(\n    id: 'lambdaContext'\n  ): import('./lambda-context').LambdaContextPlugin | undefined;\n  getPlugin(id: string): unknown;\n}\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch, mask };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = { ...value };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for (const key in coerced) {\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value, ctx) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask,\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","/**\n * Expands the  character to equivalent kana.\n *\n * Note that for some combinations there are multiple possible expansions.\n * e.g.  could be  but  is .\n *\n * (Technically,  represents an extended vowel sound and  is actually\n * pronounced _differently_ to , as two separate sounds, but people still\n * write  so we should recognize it.)\n *\n * This function returns an empty array if the input string contains no\n *  characters.\n */\nexport function expandChoon(input: string): Array<string> {\n  if (input.indexOf('') === -1) {\n    return [];\n  }\n\n  const replacer = (vowel: string) => (match: string, start: string) =>\n    `${start}${vowel.repeat(match.length - 1)}`;\n\n  // Expand the simple cases\n  const initialResult = input\n    .replace(/([])+/g, replacer(''))\n    .replace(/([])+/g, replacer(''))\n    .replace(/([])+/g, replacer(''))\n    .replace(/([])+/g, replacer(''))\n    .replace(/([])+/g, replacer(''))\n    .replace(/([])+/g, replacer(''))\n    .replace(/([])+/g, replacer(''))\n    .replace(/([])+/g, replacer(''));\n\n  // Now generate a result for each possible expansion of \n  const result: Array<string> = [];\n  const matchO = /([])+/;\n  const matchKatakanaO = /([])+/;\n  const expandO = (base: string) => {\n    let expandedWithU = base.replace(matchO, replacer(''));\n    if (expandedWithU === base) {\n      expandedWithU = base.replace(matchKatakanaO, replacer(''));\n    }\n\n    // If there have been no changes, then there are no more substitutions to\n    // make for this string.\n    if (expandedWithU === base) {\n      // Check that there is _some_ change from the original input, however.\n      if (base !== input) {\n        result.push(expandedWithU);\n      }\n      return;\n    }\n\n    // Continue expanding with this base\n    expandO(expandedWithU);\n\n    // Also, in \"parallel\", try expanding using \n    let expandedWithO = base.replace(matchO, replacer(''));\n    if (expandedWithO === base) {\n      expandedWithO = base.replace(matchKatakanaO, replacer(''));\n    }\n    expandO(expandedWithO);\n  };\n\n  expandO(initialResult);\n\n  return result;\n}\n","export function kanaToHiragana(input: string): string {\n  let result = '';\n\n  for (const char of input) {\n    let c = char.codePointAt(0)!;\n\n    if ((c >= 0x30a1 && c <= 0x30f6) || c === 0x30fd || c === 0x30fe) {\n      c -= 0x60;\n    }\n\n    result += String.fromCodePoint(c);\n  }\n\n  return result;\n}\n","/**\n * Converts various  (kyuujitai, old character forms) to \n * (shinjitai, new character forms).\n *\n * Based on the data in https://en.wikipedia.org/wiki/Kyjitai but does not\n * handle kyuujitai represented using variation selectors since these are\n * stripped by `toNormalized`.\n */\nexport function kyuujitaiToShinjitai(input: string): string {\n  const inputCodePoints = [...input].map((c) =>\n    c.codePointAt(0)\n  ) as Array<number>;\n  const outputCodePoints: Array<number> = [];\n\n  for (const c of inputCodePoints) {\n    outputCodePoints.push(KYUU_TO_SHIN[c] || c);\n  }\n\n  return String.fromCodePoint(...outputCodePoints);\n}\n\nconst KYUU_TO_SHIN: { [c: number]: number } = {\n  20056: 20055,\n  20098: 20081,\n  20121: 20120,\n  20126: 20124,\n  20315: 20175,\n  20358: 26469,\n  20482: 20341,\n  20551: 20206,\n  20659: 20253,\n  20702: 20605,\n  20729: 20385,\n  20745: 20537,\n  20818: 20816,\n  20841: 20001,\n  20839: 20869,\n  20904: 23500,\n  20937: 28092,\n  20955: 20956,\n  21097: 21104,\n  21133: 21091,\n  21137: 21092,\n  21214: 21172,\n  21235: 21234,\n  21237: 21169,\n  21240: 21223,\n  21312: 21306,\n  21367: 24059,\n  21373: 21363,\n  21443: 21442,\n  21854: 21782,\n  21934: 21336,\n  22169: 22107,\n  22196: 21427,\n  22225: 22065,\n  22280: 22287,\n  22283: 22269,\n  22285: 22258,\n  22291: 20870,\n  22294: 22259,\n  22296: 22243,\n  22492: 37326,\n  22575: 23597,\n  22686: 22679,\n  22702: 22549,\n  22739: 22311,\n  22744: 22593,\n  22750: 22730,\n  22756: 22732,\n  22767: 22766,\n  22777: 22769,\n  22781: 23551,\n  22887: 22885,\n  22892: 22888,\n  23363: 23330,\n  23416: 23398,\n  23522: 23517,\n  23526: 23455,\n  23531: 20889,\n  23532: 23515,\n  23542: 23453,\n  23559: 23558,\n  23560: 23554,\n  23565: 23550,\n  23622: 23626,\n  23643: 23631,\n  23660: 23646,\n  23791: 23792,\n  23805: 23777,\n  23947: 23798,\n  23997: 23731,\n  24022: 24012,\n  24034: 24035,\n  24118: 24111,\n  24183: 24182,\n  24290: 24259,\n  24291: 24195,\n  24307: 24193,\n  24392: 24382,\n  24396: 24357,\n  24398: 24367,\n  24465: 24452,\n  24478: 24467,\n  24501: 24500,\n  24503: 24499,\n  24646: 24658,\n  24800: 24693,\n  24801: 24746,\n  24817: 24745,\n  24892: 24910,\n  24920: 24808,\n  25033: 24540,\n  25079: 25040,\n  25088: 24651,\n  25136: 25126,\n  25138: 25135,\n  25142: 25144,\n  25150: 25147,\n  25282: 25173,\n  25300: 25244,\n  25308: 25309,\n  25406: 25375,\n  25554: 25407,\n  25581: 25522,\n  25620: 25531,\n  25622: 25594,\n  25628: 25436,\n  25799: 25246,\n  25802: 25731,\n  25812: 25285,\n  25818: 25312,\n  25831: 25369,\n  25844: 25313,\n  25885: 25666,\n  25898: 25785,\n  25910: 21454,\n  25928: 21177,\n  25933: 21465,\n  25941: 21189,\n  25976: 25968,\n  26039: 26029,\n  26180: 26179,\n  26202: 26217,\n  26205: 26172,\n  26310: 26278,\n  26313: 26241,\n  26366: 26365,\n  26371: 20250,\n  26781: 26465,\n  26855: 26719,\n  27054: 26628,\n  27079: 27097,\n  27114: 27010,\n  27138: 27005,\n  27155: 27004,\n  27166: 26530,\n  27171: 27096,\n  27243: 27178,\n  27292: 26727,\n  27298: 26908,\n  27387: 26716,\n  27402: 27177,\n  27472: 27431,\n  27489: 27475,\n  27493: 27497,\n  27511: 27508,\n  27512: 24112,\n  27544: 27531,\n  27580: 27579,\n  27590: 27572,\n  27599: 27598,\n  27683: 27671,\n  28041: 28169,\n  28122: 28057,\n  28136: 27972,\n  28154: 27973,\n  28212: 28167,\n  28330: 28179,\n  28331: 28201,\n  28399: 28382,\n  28415: 28288,\n  28497: 28300,\n  28507: 28508,\n  28545: 28171,\n  28580: 27810,\n  28629: 28287,\n  28639: 28168,\n  28657: 27996,\n  28670: 27818,\n  28711: 28381,\n  28712: 28716,\n  28771: 28286,\n  28976: 28948,\n  29128: 28783,\n  29138: 28988,\n  29151: 21942,\n  29200: 28809,\n  29229: 20105,\n  29234: 28858,\n  29351: 29344,\n  29376: 29366,\n  29433: 29421,\n  29518: 22888,\n  29544: 29420,\n  29557: 29471,\n  29560: 29539,\n  29563: 29486,\n  29923: 24321,\n  29953: 29942,\n  30059: 30011,\n  30070: 24403,\n  30090: 30067,\n  30246: 30185,\n  30305: 30196,\n  30332: 30330,\n  30403: 26479,\n  30428: 30423,\n  30433: 23613,\n  30494: 30495,\n  30799: 30740,\n  30862: 30741,\n  31014: 30783,\n  31061: 31192,\n  31103: 31108,\n  31146: 31109,\n  31150: 31036,\n  31152: 31074,\n  31153: 31095,\n  31281: 31216,\n  31291: 31282,\n  31310: 38964,\n  31319: 31298,\n  31337: 31311,\n  31344: 31331,\n  31434: 31363,\n  31453: 20006,\n  31929: 31883,\n  32114: 31992,\n  32147: 32076,\n  32160: 32209,\n  32214: 32210,\n  32227: 32257,\n  32291: 30476,\n  32305: 32294,\n  32317: 32207,\n  32353: 32333,\n  32361: 32260,\n  32362: 32117,\n  32363: 32331,\n  32380: 32153,\n  32396: 32154,\n  32406: 32330,\n  32570: 27424,\n  32592: 32566,\n  32882: 22768,\n  32893: 32884,\n  32901: 31899,\n  33126: 33075,\n  33213: 32966,\n  33247: 33235,\n  33274: 21488,\n  33287: 19982,\n  33290: 26087,\n  33399: 33398,\n  33674: 33624,\n  33686: 33550,\n  33824: 33804,\n  33836: 19975,\n  34083: 33931,\n  34199: 22290,\n  34224: 34219,\n  34255: 34101,\n  34269: 33464,\n  34277: 34220,\n  34310: 33446,\n  34389: 20966,\n  34395: 34394,\n  34399: 21495,\n  34722: 34509,\n  34802: 34411,\n  34847: 34635,\n  34870: 34453,\n  34875: 34542,\n  34910: 34907,\n  35037: 35013,\n  35139: 35090,\n  35258: 35226,\n  35261: 35239,\n  35264: 35251,\n  35320: 35302,\n  35616: 35617,\n  35657: 35388,\n  35695: 35379,\n  35709: 35465,\n  35712: 35501,\n  35722: 22793,\n  35731: 35698,\n  35738: 35715,\n  35920: 35914,\n  35924: 33398,\n  35947: 20104,\n  36019: 24336,\n  36067: 22770,\n  36084: 38972,\n  36106: 36059,\n  36368: 36341,\n  36544: 36527,\n  36629: 36605,\n  36635: 36620,\n  36681: 36578,\n  36776: 24321,\n  36781: 36766,\n  36783: 24321,\n  36953: 36965,\n  36958: 36883,\n  36978: 36933,\n  37002: 36794,\n  37086: 37070,\n  37141: 37111,\n  37257: 37204,\n  37291: 21307,\n  37292: 37284,\n  37297: 37271,\n  37312: 37304,\n  37323: 37320,\n  37636: 37682,\n  37666: 37549,\n  37706: 37676,\n  37805: 37806,\n  37941: 37444,\n  37956: 37619,\n  37979: 37489,\n  38364: 38306,\n  38519: 38501,\n  38568: 38543,\n  38570: 38522,\n  38577: 38560,\n  38617: 21452,\n  38620: 38609,\n  38712: 35207,\n  38728: 38666,\n  38748: 38745,\n  39002: 39003,\n  39023: 38997,\n  39132: 32763,\n  39192: 20313,\n  39200: 39173,\n  39368: 39366,\n  39479: 39442,\n  39493: 39366,\n  39511: 39443,\n  39515: 39365,\n  39635: 39620,\n  39636: 20307,\n  39662: 39658,\n  39725: 38360,\n  40388: 40335,\n  40407: 40206,\n  40572: 40568,\n  40573: 22633,\n  40613: 40614,\n  40628: 40633,\n  40629: 40634,\n  40643: 40644,\n  40657: 40658,\n  40664: 40665,\n  40670: 28857,\n  40680: 20826,\n  40778: 25993,\n  40779: 25998,\n  40786: 27503,\n  40801: 40802,\n  40845: 31452,\n  40860: 20096,\n};\n","export function halfToFullWidthNum(input: string): string {\n  let result = '';\n\n  for (const char of input) {\n    let c = char.codePointAt(0)!;\n\n    if (c >= 0x30 && c <= 0x39) {\n      c += 0xff10 - 0x30;\n    } else if (c >= 0x2c && c <= 0x2e) {\n      c += 0xff0c - 0x2c;\n    }\n\n    result += String.fromCodePoint(c);\n  }\n\n  return result;\n}\n","// prettier-ignore\nconst HANKAKU_KATAKANA_TO_ZENKAKU = [\n 0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1, 0x30a3, 0x30a5,\n 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7, 0x30c3, 0x30fc, 0x30a2, 0x30a4,\n 0x30a6, 0x30a8, 0x30aa, 0x30ab, 0x30ad, 0x30af, 0x30b1, 0x30b3, 0x30b5,\n 0x30b7, 0x30b9, 0x30bb, 0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6, 0x30c8,\n 0x30ca, 0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf, 0x30d2, 0x30d5, 0x30d8,\n 0x30db, 0x30de, 0x30df, 0x30e0, 0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8,\n 0x30e9, 0x30ea, 0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x3099, 0x309a,\n];\n\n// prettier-ignore\nconst VOICED_TO_COMPOSED = new Map([\n  [0x3046, 0x3094], [0x304b, 0x304c], [0x304d, 0x304e], [0x304f, 0x3050],\n  [0x3051, 0x3052], [0x3053, 0x3054], [0x3055, 0x3056], [0x3057, 0x3058],\n  [0x3059, 0x305a], [0x305b, 0x305c], [0x305d, 0x305e], [0x305f, 0x3060],\n  [0x3061, 0x3062], [0x3064, 0x3065], [0x3066, 0x3067], [0x3068, 0x3069],\n  [0x306f, 0x3070], [0x3072, 0x3073], [0x3075, 0x3076], [0x3078, 0x3079],\n  [0x307b, 0x307c], [0x309d, 0x309e], [0x30ab, 0x30ac], [0x30ad, 0x30ae],\n  [0x30a6, 0x30f4], [0x30af, 0x30b0], [0x30b1, 0x30b2], [0x30b3, 0x30b4],\n  [0x30b5, 0x30b6], [0x30b7, 0x30b8], [0x30b9, 0x30ba], [0x30bb, 0x30bc],\n  [0x30bd, 0x30be], [0x30bf, 0x30c0], [0x30c1, 0x30c2], [0x30c4, 0x30c5],\n  [0x30c6, 0x30c7], [0x30c8, 0x30c9], [0x30cf, 0x30d0], [0x30d2, 0x30d3],\n  [0x30d5, 0x30d6], [0x30d8, 0x30d9], [0x30db, 0x30dc], [0x30ef, 0x30f7],\n  [0x30f0, 0x30f8], [0x30f1, 0x30f9], [0x30f2, 0x30fa], [0x30fd, 0x30fe]\n]);\n\n// prettier-ignore\nconst SEMIVOICED_TO_COMPOSED = new Map([\n  [0x306f, 0x3071], [0x3072, 0x3074], [0x3075, 0x3077], [0x3078, 0x307a],\n  [0x307b, 0x307d], [0x30cf, 0x30d1], [0x30d2, 0x30d4], [0x30d5, 0x30d7],\n  [0x30d8, 0x30da], [0x30db, 0x30dd]\n]);\n\n// First part of the CJK Compatibility block: 0x3300-0x3370\n// prettier-ignore\nconst COMBINED_CHARS_A = [\n '', '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '',\n  '', '0', '1', '2', '3', '4', '5', '6', '7', '8',\n  '9', '10', '11', '12', '13', '14', '15', '16', '17', '18',\n  '19', '20', '21', '22', '23', '24'\n];\n\n// Second part of the CJK Compatibility block: 0x337b-0x337f\n// prettier-ignore\nconst COMBINED_CHARS_B = ['', '', '', '', ''];\n\n// First part of Enclosed CJK letters and motnhs block: 0x3220-0x3247\n// prettier-ignore\nconst ENCLOSED_CHARS_A = [\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  ''\n];\n\n// Second part of Enclosed CJK letters and motnhs block: 0x3280-0x32b0\n// prettier-ignore\nconst ENCLOSED_CHARS_B = [\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', ''\n];\n\n// Third part of Enclosed CJK letters and motnhs block: 0x32c0-0x32cb\n// prettier-ignore\nconst ENCLOSED_CHARS_C = [\n  '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11',\n  '12'\n];\n\n// Fourth part of Enclosed CJK letters and motnhs block: 0x32d0-0x32ff\n// prettier-ignore\nconst ENCLOSED_CHARS_D = [\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', '', '', '', '', '',\n  '', '', '', '', '', '', '', '', ''\n];\n\n// We should handle the Enclosed Ideographic Supplement too\n// (https://en.wikipedia.org/wiki/Enclosed_Ideographic_Supplement)\n// but it's in the SMP so it makes processing more complicated.\n//\n// We'll wait until it's actually needed.\n\n// The following is a mapping from radical characters in the Kangxi Radicals\n// and _some_ of the radicals in the CJK Radicals Supplement block.\n//\n// The purpose of this mapping is to help in looking up mis-encoded characters.\n// Therefore, we have deliberately _not_ included some characters where even\n// where there's a possible mapping because the characters don't necessarily\n// look similar or are ambiguous (e.g. the different variants on ).\n//\n// We've also avoided using equivalents that are not in the BMP even if they're\n// better because it seems unlikely someone would have wanted to encode a\n// non-BMP character and used a radical character instead.\nconst RADICAL_TO_KANJI_CHARS: ReadonlyArray<[number, number]> = [\n  //   \n  [0x2f00, 0x4e00],\n  //   \n  [0x2f01, 0x4e28],\n  //   \n  [0x2f02, 0x4e36],\n  //   \n  [0x2f03, 0x4e3f],\n  //   \n  [0x2f04, 0x4e59],\n  //   \n  [0x2f05, 0x4e85],\n  //   \n  [0x2f06, 0x4e8c],\n  //   \n  [0x2f07, 0x4ea0],\n  //   \n  [0x2f08, 0x4eba],\n  //   \n  [0x2f09, 0x513f],\n  //   \n  [0x2f0a, 0x5165],\n  //   \n  [0x2f0b, 0x516b],\n  //   \n  [0x2f0c, 0x5182],\n  //   \n  [0x2f0d, 0x5196],\n  //   \n  [0x2f0e, 0x51ab],\n  //   \n  [0x2f0f, 0x51e0],\n  //   \n  [0x2f10, 0x51f5],\n  //   \n  [0x2f11, 0x5200],\n  //   \n  [0x2f12, 0x529b],\n  //   \n  [0x2f13, 0x52f9],\n  //   \n  [0x2f14, 0x5315],\n  //   \n  [0x2f15, 0x531a],\n  //   \n  [0x2f16, 0x5338],\n  //   \n  [0x2f17, 0x5341],\n  //   \n  [0x2f18, 0x535c],\n  //   \n  [0x2f19, 0x5369],\n  //   \n  [0x2f1a, 0x5382],\n  //   \n  [0x2f1b, 0x53b6],\n  //   \n  [0x2f1c, 0x53c8],\n  //   \n  [0x2f1d, 0x53e3],\n  //   \n  [0x2f1e, 0x56d7],\n  //   \n  [0x2f1f, 0x571f],\n  //   \n  [0x2f20, 0x58eb],\n  //   \n  [0x2f21, 0x5902],\n  //   \n  [0x2f22, 0x590a],\n  //   \n  [0x2f23, 0x5915],\n  //   \n  [0x2f24, 0x5927],\n  //   \n  [0x2f25, 0x5973],\n  //   \n  [0x2f26, 0x5b50],\n  //   \n  [0x2f27, 0x5b80],\n  //   \n  [0x2f28, 0x5bf8],\n  //   \n  [0x2f29, 0x5c0f],\n  //   \n  [0x2f2a, 0x5c22],\n  //   \n  [0x2f2b, 0x5c38],\n  //   \n  [0x2f2c, 0x5c6e],\n  //   \n  [0x2f2d, 0x5c71],\n  //   \n  [0x2f2e, 0x5ddb],\n  //   \n  [0x2f2f, 0x5de5],\n  //   \n  [0x2f30, 0x5df1],\n  //   \n  [0x2f31, 0x5dfe],\n  //   \n  [0x2f32, 0x5e72],\n  //   \n  [0x2f33, 0x5e7a],\n  //   \n  [0x2f34, 0x5e7f],\n  //   \n  [0x2f35, 0x5ef4],\n  //   \n  [0x2f36, 0x5efe],\n  //   \n  [0x2f37, 0x5f0b],\n  //   \n  [0x2f38, 0x5f13],\n  //   \n  [0x2f39, 0x5f50],\n  //   \n  [0x2f3a, 0x5f61],\n  //   \n  [0x2f3b, 0x5f73],\n  //   \n  [0x2f3c, 0x5fc3],\n  //   \n  [0x2f3d, 0x6208],\n  //   \n  [0x2f3e, 0x6236],\n  //   \n  [0x2f3f, 0x624b],\n  //   \n  [0x2f40, 0x652f],\n  //   \n  [0x2f41, 0x6534],\n  //   \n  [0x2f42, 0x6587],\n  //   \n  [0x2f43, 0x6597],\n  //   \n  [0x2f44, 0x65a4],\n  //   \n  [0x2f45, 0x65b9],\n  //   \n  [0x2f46, 0x65e0],\n  //   \n  [0x2f47, 0x65e5],\n  //   \n  [0x2f48, 0x66f0],\n  //   \n  [0x2f49, 0x6708],\n  //   \n  [0x2f4a, 0x6728],\n  //   \n  [0x2f4b, 0x6b20],\n  //   \n  [0x2f4c, 0x6b62],\n  //   \n  [0x2f4d, 0x6b79],\n  //   \n  [0x2f4e, 0x6bb3],\n  //   \n  [0x2f4f, 0x6bcb],\n  //   \n  [0x2f50, 0x6bd4],\n  //   \n  [0x2f51, 0x6bdb],\n  //   \n  [0x2f52, 0x6c0f],\n  //   \n  [0x2f53, 0x6c14],\n  //   \n  [0x2f54, 0x6c34],\n  //   \n  [0x2f55, 0x706b],\n  //   \n  [0x2f56, 0x722a],\n  //   \n  [0x2f57, 0x7236],\n  //   \n  [0x2f58, 0x723b],\n  //   \n  [0x2f59, 0x723f],\n  //   \n  [0x2f5a, 0x7247],\n  //   \n  [0x2f5b, 0x7259],\n  //   \n  [0x2f5c, 0x725b],\n  //   \n  [0x2f5d, 0x72ac],\n  //   \n  [0x2f5e, 0x7384],\n  //   \n  [0x2f5f, 0x7389],\n  //   \n  [0x2f60, 0x74dc],\n  //   \n  [0x2f61, 0x74e6],\n  //   \n  [0x2f62, 0x7518],\n  //   \n  [0x2f63, 0x751f],\n  //   \n  [0x2f64, 0x7528],\n  //   \n  [0x2f65, 0x7530],\n  //   \n  [0x2f66, 0x758b],\n  //   \n  [0x2f67, 0x7592],\n  //   \n  [0x2f68, 0x7676],\n  //   \n  [0x2f69, 0x767d],\n  //   \n  [0x2f6a, 0x76ae],\n  //   \n  [0x2f6b, 0x76bf],\n  //   \n  [0x2f6c, 0x76ee],\n  //   \n  [0x2f6d, 0x77db],\n  //   \n  [0x2f6e, 0x77e2],\n  //   \n  [0x2f6f, 0x77f3],\n  //   \n  [0x2f70, 0x793a],\n  //   \n  [0x2f71, 0x79b8],\n  //   \n  [0x2f72, 0x79be],\n  //   \n  [0x2f73, 0x7a74],\n  //   \n  [0x2f74, 0x7acb],\n  //   \n  [0x2f75, 0x7af9],\n  //   \n  [0x2f76, 0x7c73],\n  //   \n  [0x2f77, 0x7cf8],\n  //   \n  [0x2f78, 0x7f36],\n  //   \n  [0x2f79, 0x7f51],\n  //   \n  [0x2f7a, 0x7f8a],\n  //   \n  [0x2f7b, 0x7fbd],\n  //   \n  [0x2f7c, 0x8001],\n  //   \n  [0x2f7d, 0x800c],\n  //   \n  [0x2f7e, 0x8012],\n  //   \n  [0x2f7f, 0x8033],\n  //   \n  [0x2f80, 0x807f],\n  //   \n  [0x2f81, 0x8089],\n  //   \n  [0x2f82, 0x81e3],\n  //   \n  [0x2f83, 0x81ea],\n  //   \n  [0x2f84, 0x81f3],\n  //   \n  [0x2f85, 0x81fc],\n  //   \n  [0x2f86, 0x820c],\n  //   \n  [0x2f87, 0x821b],\n  //   \n  [0x2f88, 0x821f],\n  //   \n  [0x2f89, 0x826e],\n  //   \n  [0x2f8a, 0x8272],\n  //   \n  [0x2f8b, 0x8278],\n  //   \n  [0x2f8c, 0x864d],\n  //   \n  [0x2f8d, 0x866b],\n  //   \n  [0x2f8e, 0x8840],\n  //   \n  [0x2f8f, 0x884c],\n  //   \n  [0x2f90, 0x8863],\n  //   \n  [0x2f91, 0x897e],\n  //   \n  [0x2f92, 0x898b],\n  //   \n  [0x2f93, 0x89d2],\n  //   \n  [0x2f94, 0x8a00],\n  //   \n  [0x2f95, 0x8c37],\n  //   \n  [0x2f96, 0x8c46],\n  //   \n  [0x2f97, 0x8c55],\n  //   \n  [0x2f98, 0x8c78],\n  //   \n  [0x2f99, 0x8c9d],\n  //   \n  [0x2f9a, 0x8d64],\n  //   \n  [0x2f9b, 0x8d70],\n  //   \n  [0x2f9c, 0x8db3],\n  //   \n  [0x2f9d, 0x8eab],\n  //   \n  [0x2f9e, 0x8eca],\n  //   \n  [0x2f9f, 0x8f9b],\n  //   \n  [0x2fa0, 0x8fb0],\n  //   \n  [0x2fa1, 0x8fb5],\n  //   \n  [0x2fa2, 0x9091],\n  //   \n  [0x2fa3, 0x9149],\n  //   \n  [0x2fa4, 0x91c6],\n  //   \n  [0x2fa5, 0x91cc],\n  //   \n  [0x2fa6, 0x91d1],\n  //   \n  [0x2fa7, 0x9577],\n  //   \n  [0x2fa8, 0x9580],\n  //   \n  [0x2fa9, 0x961c],\n  //   \n  [0x2faa, 0x96b6],\n  //   \n  [0x2fab, 0x96b9],\n  //   \n  [0x2fac, 0x96e8],\n  //   \n  [0x2fad, 0x9751],\n  //   \n  [0x2fae, 0x975e],\n  //   \n  [0x2faf, 0x9762],\n  //   \n  [0x2fb0, 0x9769],\n  //   \n  [0x2fb1, 0x97cb],\n  //   \n  [0x2fb2, 0x97ed],\n  //   \n  [0x2fb3, 0x97f3],\n  //   \n  [0x2fb4, 0x9801],\n  //   \n  [0x2fb5, 0x98a8],\n  //   \n  [0x2fb6, 0x98db],\n  //   \n  [0x2fb7, 0x98df],\n  //   \n  [0x2fb8, 0x9996],\n  //   \n  [0x2fb9, 0x9999],\n  //   \n  [0x2fba, 0x99ac],\n  //   \n  [0x2fbb, 0x9aa8],\n  //   \n  [0x2fbc, 0x9ad8],\n  //   \n  [0x2fbd, 0x9adf],\n  //   \n  [0x2fbe, 0x9b25],\n  //   \n  [0x2fbf, 0x9b2f],\n  //   \n  [0x2fc0, 0x9b32],\n  //   \n  [0x2fc1, 0x9b3c],\n  //   \n  [0x2fc2, 0x9b5a],\n  //   \n  [0x2fc3, 0x9ce5],\n  //   \n  [0x2fc4, 0x9e75],\n  //   \n  [0x2fc5, 0x9e7f],\n  //   \n  [0x2fc6, 0x9ea5],\n  //   \n  [0x2fc7, 0x9ebb],\n  //   \n  [0x2fc8, 0x9ec3],\n  //   \n  [0x2fc9, 0x9ecd],\n  //   \n  [0x2fca, 0x9ed1],\n  //   \n  [0x2fcb, 0x9ef9],\n  //   \n  [0x2fcc, 0x9efd],\n  //   \n  [0x2fcd, 0x9f0e],\n  //   \n  [0x2fce, 0x9f13],\n  //   \n  [0x2fcf, 0x9f20],\n  //   \n  [0x2fd0, 0x9f3b],\n  //   \n  [0x2fd1, 0x9f4a],\n  //   \n  [0x2fd2, 0x9f52],\n  //   \n  [0x2fd3, 0x9f8d],\n  //   \n  [0x2fd4, 0x9f9c],\n  //   \n  [0x2fd5, 0x9fa0],\n  //   \n  [0x2e81, 0x5382],\n  //   \n  [0x2e83, 0x4e5a],\n  //   \n  [0x2e85, 0x4ebb],\n  //   \n  [0x2e86, 0x5182],\n  //   \n  [0x2e87, 0x51e0],\n  //   \n  [0x2e89, 0x5202],\n  //   \n  [0x2e8e, 0x5140],\n  //   \n  [0x2e8f, 0x5c23],\n  //   \n  [0x2e90, 0x5c22],\n  //   \n  [0x2e91, 0x5c23],\n  //   \n  [0x2e92, 0x5df3],\n  //   \n  [0x2e93, 0x5e7a],\n  //   \n  [0x2e94, 0x5f51],\n  //   \n  [0x2e95, 0x5f50],\n  //   \n  [0x2e96, 0x5fc4],\n  //   \n  [0x2e98, 0x624c],\n  //   \n  [0x2e99, 0x6535],\n  //   \n  [0x2e9b, 0x65e1],\n  //   \n  [0x2e9d, 0x6708],\n  //   \n  [0x2e9e, 0x6b7a],\n  //   \n  [0x2e9f, 0x6bcd],\n  //   \n  [0x2ea0, 0x6c11],\n  //   \n  [0x2ea1, 0x6c35],\n  //   \n  [0x2ea2, 0x6c3a],\n  //   \n  [0x2ea3, 0x706c],\n  //   \n  [0x2ea4, 0x722b],\n  //   \n  [0x2ea5, 0x722b],\n  //   \n  [0x2ea6, 0x4e2c],\n  //   \n  [0x2ea8, 0x72ad],\n  //   \n  [0x2eab, 0x7f52],\n  //   \n  [0x2eaf, 0x7cf9],\n  //   \n  [0x2eb0, 0x7e9f],\n  //   \n  [0x2eb1, 0x7f53],\n  //   \n  [0x2eb4, 0x34c1],\n  //   \n  [0x2eb8, 0x7f8b],\n  //   \n  [0x2eb9, 0x8002],\n  //   \n  [0x2eba, 0x8080],\n  //   \n  [0x2ebd, 0x81fc],\n  //   \n  [0x2ebe, 0x8279],\n  //   \n  [0x2ec1, 0x864e],\n  //   \n  [0x2ec2, 0x8864],\n  //   \n  [0x2ec3, 0x8980],\n  //   \n  [0x2ec4, 0x897f],\n  //   \n  [0x2ec5, 0x89c1],\n  //   \n  [0x2ec6, 0x89d2],\n  //   \n  [0x2ec8, 0x8ba0],\n  //   \n  [0x2ec9, 0x8d1d],\n  //   \n  [0x2ecb, 0x8f66],\n  //   \n  [0x2ed0, 0x9485],\n  //   \n  [0x2ed1, 0x9577],\n  //   \n  [0x2ed2, 0x9578],\n  //   \n  [0x2ed3, 0x957f],\n  //   \n  [0x2ed4, 0x95e8],\n  //   \n  [0x2ed6, 0x961d],\n  //   \n  [0x2ed8, 0x9752],\n  //   \n  [0x2ed9, 0x97e6],\n  //   \n  [0x2eda, 0x9875],\n  //   \n  [0x2edb, 0x98ce],\n  //   \n  [0x2edc, 0x98de],\n  //   \n  [0x2edd, 0x98df],\n  //   \n  [0x2edf, 0x98e0],\n  //   \n  [0x2ee0, 0x9963],\n  //   \n  [0x2ee2, 0x9a6c],\n  //   \n  [0x2ee3, 0x9aa8],\n  //   \n  [0x2ee4, 0x9b3c],\n  //   \n  [0x2ee5, 0x9c7c],\n  //   \n  [0x2ee6, 0x9e1f],\n  //   \n  [0x2ee7, 0x5364],\n  //   \n  [0x2ee8, 0x9ea6],\n  //   \n  [0x2ee9, 0x9ec4],\n  //   \n  [0x2eea, 0x9efe],\n  //   \n  [0x2eeb, 0x6589],\n  //   \n  [0x2eec, 0x9f50],\n  //   \n  [0x2eed, 0x6b6f],\n  //   \n  [0x2eee, 0x9f7f],\n  //   \n  [0x2eef, 0x7adc],\n  //   \n  [0x2ef0, 0x9f99],\n  //   \n  [0x2ef1, 0x9f9c],\n  //   \n  [0x2ef2, 0x4e80],\n  //   \n  [0x2ef3, 0x9f9f],\n];\n\nlet RADICAL_TO_KANJI: Map<number, number> | undefined;\n\n// Converts:\n//\n// - half-width katakana to full-width katakana (e.g.   )\n// - decomposed characters to their composed equivalents\n//   (e.g.   )\n// - various enclosed characters into their plain form\n//   (e.g.   )\n// - various combined characters into their expanded form\n//   (e.g.   ,   )\n// - characters with variation selectors into the base character only\n// - radicals into the equivalent kanji character\n//\n// while maintaining a mapping from output character offsets to input\n// offsets.\nexport function toNormalized(input: string): [string, number[]] {\n  // Lazily create the radical map to that RADICAL_TO_KANJI_CHARS can be\n  // tree-shaken when this function is not being used (unlike arrays, Maps()\n  // always seem to be included because presumably the ctor could have\n  // side-effects).\n  if (!RADICAL_TO_KANJI) {\n    RADICAL_TO_KANJI = new Map(RADICAL_TO_KANJI_CHARS);\n  }\n\n  let inputLengths = [0];\n  let result = '';\n\n  for (let i = 0; i < input.length; ++i) {\n    let c = input.charCodeAt(i);\n\n    // Drop Unicode variation selectors\n    if ((c >= 0xfe00 && c <= 0xfe0f) || (c >= 0xe0100 && c <= 0xe011f)) {\n      inputLengths[result.length] = i + 1;\n      continue;\n    }\n\n    // Half-width to full-width katakana\n    if (c >= 0xff61 && c <= 0xff9f) {\n      c = HANKAKU_KATAKANA_TO_ZENKAKU[c - 0xff61]!;\n    }\n\n    // Decomposed characters (including any half-width katakana which we just\n    // converted since half-width katakana is always decomposed).\n    const prevChar = result.length ? result.charCodeAt(result.length - 1) : 0;\n    if (c === 0x3099) {\n      const composed = VOICED_TO_COMPOSED.get(prevChar);\n      if (composed) {\n        result = result.slice(0, -1);\n        c = composed;\n      }\n    } else if (c === 0x309a) {\n      // Decomposed semi-voiced mark (full-width or half-width)\n      const composed = SEMIVOICED_TO_COMPOSED.get(prevChar);\n      if (composed) {\n        result = result.slice(0, -1);\n        c = composed;\n      }\n    }\n\n    // Look for an expanded character\n    let expanded: string | undefined;\n    if (c >= 0x3300 && c <= 0x3370) {\n      expanded = COMBINED_CHARS_A[c - 0x3300];\n    } else if (c >= 0x337b && c <= 0x337f) {\n      expanded = COMBINED_CHARS_B[c - 0x337b];\n    } else if (c >= 0x3220 && c <= 0x3247) {\n      expanded = ENCLOSED_CHARS_A[c - 0x3220];\n    } else if (c >= 0x3280 && c <= 0x32b0) {\n      expanded = ENCLOSED_CHARS_B[c - 0x3280];\n    } else if (c >= 0x32c0 && c <= 0x32cb) {\n      expanded = ENCLOSED_CHARS_C[c - 0x32c0];\n    } else if (c >= 0x32d0 && c <= 0x32ff) {\n      expanded = ENCLOSED_CHARS_D[c - 0x32d0];\n    }\n\n    // Look for radical characters to map to kanji\n    const radical = !expanded ? RADICAL_TO_KANJI.get(c) : undefined;\n    if (radical) {\n      expanded = String.fromCodePoint(radical);\n    }\n\n    if (expanded) {\n      result += expanded;\n      inputLengths.push(...Array(expanded.length - 1).fill(i));\n    } else {\n      result += String.fromCharCode(c);\n    }\n    inputLengths[result.length] = i + 1;\n  }\n\n  return [result, inputLengths];\n}\n","export class AbortError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, AbortError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n","export type DataSeries = 'words' | 'kanji' | 'radicals' | 'names';\n\nexport const allDataSeries: ReadonlyArray<DataSeries> = [\n  'words',\n  'kanji',\n  'radicals',\n  'names',\n];\n\nexport function isDataSeries(a: unknown): a is DataSeries {\n  return typeof a === 'string' && allDataSeries.includes(a as DataSeries);\n}\n\n// For certain interface actions we lump kanji and radicals together.\n// e.g. If you want to update the kanji data set, you need to update the\n// radicals too since we cross-reference the two.\n//\n// We call the combined set a \"major\" data series.\nexport type MajorDataSeries = 'words' | 'kanji' | 'names';\n\nexport const allMajorDataSeries: ReadonlyArray<MajorDataSeries> = [\n  'words',\n  'kanji',\n  'names',\n];\n\nexport function isMajorDataSeries(a: unknown): a is MajorDataSeries {\n  return (\n    typeof a === 'string' && allMajorDataSeries.includes(a as MajorDataSeries)\n  );\n}\n","export type DownloadErrorCode =\n  | 'VersionFileNotFound'\n  | 'VersionFileNotAccessible'\n  | 'VersionFileInvalid'\n  | 'MajorVersionNotFound'\n  | 'DatabaseFileNotFound'\n  | 'DatabaseFileNotAccessible'\n  | 'DatabaseFileHeaderMissing'\n  | 'DatabaseFileHeaderDuplicate'\n  | 'DatabaseFileVersionMismatch'\n  | 'DatabaseFileInvalidJSON'\n  | 'DatabaseFileInvalidRecord'\n  | 'DatabaseTooOld'\n  | 'Timeout';\n\ntype DownloadErrorOptions = {\n  code: DownloadErrorCode;\n  url?: string;\n};\n\nexport class DownloadError extends Error {\n  code: DownloadErrorCode;\n  url?: string;\n\n  constructor({ code, url }: DownloadErrorOptions, ...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, DownloadError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, DownloadError);\n    }\n\n    this.name = 'DownloadError';\n    this.code = code;\n    this.url = url;\n  }\n}\n","export function isObject(a: unknown): a is Record<string, any> {\n  return typeof a === 'object' && a !== null && !Array.isArray(a);\n}\n","import { AbortError } from './abort-error';\nimport { DownloadError } from './download-error';\nimport { isObject } from './is-object';\n\nexport function isAbortError(e: unknown): e is AbortError {\n  return isObject(e) && 'name' in e && e.name === 'AbortError';\n}\n\nexport function isDownloadError(e: unknown): e is DownloadError {\n  return isObject(e) && 'name' in e && e.name === 'DownloadError';\n}\n\nexport function getErrorMessage(e: unknown): string {\n  return isObject(e) && typeof e.message === 'string' ? e.message : String(e);\n}\n","import { DownloadError } from './download-error';\nimport { isAbortError } from './error-parsing';\n\n// Utility function for fetch that allows setting a timeout as well as taking an\n// AbortController so that the callee can abort the request before that point\n// too.\n//\n// If it times out the `response` Promise will reject with a TimeoutError\n// so that a timeout can be distinguished from a deliberate abort.\nexport async function fetchWithTimeout(\n  resource: RequestInfo,\n  options: {\n    timeout: number | null;\n  } & RequestInit\n): Promise<Response> {\n  // Set up abort controller\n  const controller = new AbortController();\n  const onAbort = () => controller.abort();\n  options?.signal?.addEventListener('abort', onAbort);\n\n  // Set up timeout callback\n  const { timeout } = options;\n  let didTimeout = false;\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  if (timeout && timeout !== Infinity) {\n    timeoutId = setTimeout(() => {\n      didTimeout = true;\n      controller.abort();\n    }, timeout);\n  }\n\n  try {\n    const response = await fetch(resource, {\n      ...options,\n      signal: controller.signal,\n    });\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    return response;\n  } catch (e) {\n    // Check for a timeout\n    if (didTimeout && isAbortError(e)) {\n      throw new DownloadError(\n        {\n          code: 'Timeout',\n          url: typeof resource === 'string' ? resource : resource.url,\n        },\n        `Download timed out after ${timeout! / 1000} second(s).`\n      );\n    }\n\n    throw e;\n  } finally {\n    options?.signal?.removeEventListener('abort', onAbort);\n  }\n}\n","import * as s from 'superstruct';\n\nexport const safeInteger = (): s.Struct<number, null> =>\n  s.refine(s.integer(), 'safeInteger', (value) => Number.isSafeInteger(value));\n","import * as s from 'superstruct';\n\nimport { AbortError } from './abort-error';\nimport { DownloadError } from './download-error';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\nimport { fetchWithTimeout } from './fetch';\nimport { safeInteger } from './validation-helpers';\n\nexport type VersionInfo = s.Infer<typeof VersionInfoStruct>;\n\nexport async function getVersionInfo({\n  baseUrl,\n  series,\n  lang,\n  majorVersion,\n  timeout,\n  signal,\n}: {\n  baseUrl: string;\n  series: string;\n  lang: string;\n  majorVersion: number;\n  timeout: number;\n  signal?: AbortSignal;\n}): Promise<VersionInfo> {\n  const versionInfoFile = await getVersionInfoFile({\n    baseUrl,\n    lang,\n    timeout,\n    signal,\n  });\n\n  // Extract the appropriate database version information\n  const dbVersionInfo = getCurrentVersionInfo(\n    versionInfoFile,\n    series,\n    majorVersion\n  );\n  if (!dbVersionInfo) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      `Invalid version object: the requested series, ${series} was not available in this language ('${lang}')`\n    );\n  }\n\n  return dbVersionInfo;\n}\n\nexport function clearCachedVersionInfo() {\n  cachedVersionInfo = undefined;\n}\n\nconst CACHE_TIMEOUT = 3_000 * 60; // Cache version file contents for 3 minutes\n\nlet cachedVersionInfo:\n  | { lang: string; versionInfoFile: VersionInfoFile; accessTime: number }\n  | undefined;\n\nasync function getVersionInfoFile({\n  baseUrl,\n  lang,\n  timeout,\n  signal,\n}: {\n  baseUrl: string;\n  lang: string;\n  timeout: number;\n  signal?: AbortSignal;\n}): Promise<VersionInfoFile> {\n  if (\n    cachedVersionInfo?.lang === lang &&\n    cachedVersionInfo.accessTime > Date.now() - CACHE_TIMEOUT\n  ) {\n    return cachedVersionInfo.versionInfoFile;\n  }\n  cachedVersionInfo = undefined;\n  const accessTime = Date.now();\n\n  let rawVersionInfoFile;\n\n  const url = `${baseUrl}jpdict/reader/version-${lang}.json`;\n\n  let response;\n  try {\n    response = await fetchWithTimeout(url, { signal, timeout });\n  } catch (e) {\n    if (isAbortError(e) || isDownloadError(e)) {\n      throw e;\n    }\n\n    throw new DownloadError(\n      { code: 'VersionFileNotAccessible', url },\n      `Version file ${url} not accessible (${getErrorMessage(e)})`\n    );\n  }\n\n  // Fetch rejects the promise for network errors, but not for HTTP errors :(\n  if (!response.ok) {\n    const code =\n      response.status === 404\n        ? 'VersionFileNotFound'\n        : 'VersionFileNotAccessible';\n    throw new DownloadError(\n      { code, url },\n      `Version file ${url} not accessible (status: ${response.status})`\n    );\n  }\n\n  // Try to parse it\n  try {\n    rawVersionInfoFile = await response.json();\n  } catch (e) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid', url },\n      `Invalid version object: ${\n        getErrorMessage(e) || '(No detailed error message)'\n      }`\n    );\n  }\n\n  if (signal?.aborted) {\n    throw new AbortError();\n  }\n\n  const versionInfoFile = parseVersionInfoFile(rawVersionInfoFile);\n\n  cachedVersionInfo = { lang, versionInfoFile, accessTime };\n\n  return versionInfoFile;\n}\n\nconst VersionInfoStruct = s.type({\n  major: s.min(safeInteger(), 1),\n  minor: s.min(safeInteger(), 0),\n  patch: s.min(safeInteger(), 0),\n  parts: s.optional(s.min(safeInteger(), 1)),\n  databaseVersion: s.optional(s.string()),\n  dateOfCreation: s.nonempty(s.string()),\n});\n\nconst VersionInfoFileStruct = s.record(\n  s.string(),\n  s.record(s.string(), VersionInfoStruct)\n);\n\ntype VersionInfoFile = s.Infer<typeof VersionInfoFileStruct>;\n\nfunction parseVersionInfoFile(rawVersionInfoFile: unknown): VersionInfoFile {\n  if (!rawVersionInfoFile) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      'Empty version info file'\n    );\n  }\n\n  const [error, versionInfoFile] = s.validate(\n    rawVersionInfoFile,\n    VersionInfoFileStruct\n  );\n\n  if (error) {\n    throw new DownloadError(\n      { code: 'VersionFileInvalid' },\n      `Version file was invalid: ${error}`\n    );\n  }\n\n  return versionInfoFile;\n}\n\nfunction getCurrentVersionInfo(\n  versionInfoFile: VersionInfoFile,\n  series: string,\n  majorVersion: number\n): VersionInfo | null {\n  if (!(series in versionInfoFile)) {\n    return null;\n  }\n\n  if (!(majorVersion in versionInfoFile[series])) {\n    throw new DownloadError(\n      { code: 'MajorVersionNotFound' },\n      `No ${majorVersion}.x version information for ${series} data`\n    );\n  }\n\n  return versionInfoFile[series][majorVersion];\n}\n","import { AbortError } from './abort-error';\nimport { DownloadError } from './download-error';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\n\nexport async function* ljsonStreamIterator({\n  stream,\n  signal,\n  timeout,\n  url,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  signal: AbortSignal;\n  timeout: number;\n  url: string;\n}): AsyncIterableIterator<object> {\n  const reader = stream.getReader();\n  const lineEnd = /\\n|\\r|\\r\\n/m;\n  const decoder = new TextDecoder('utf-8');\n  let buffer = '';\n\n  const parseLine = (line: string): any => {\n    try {\n      return JSON.parse(line);\n    } catch {\n      try {\n        reader.releaseLock();\n      } catch {\n        // Ignore\n      }\n      throw new DownloadError(\n        { code: 'DatabaseFileInvalidJSON', url },\n        `Could not parse JSON in database file: ${line}`\n      );\n    }\n  };\n\n  while (true) {\n    let readResult: ReadableStreamReadResult<Uint8Array>;\n    try {\n      readResult = await waitWithTimeout({\n        promise: reader.read(),\n        timeout,\n        url,\n      });\n    } catch (e) {\n      try {\n        reader.releaseLock();\n      } catch {\n        // Ignore\n      }\n\n      if (isAbortError(e) || isDownloadError(e)) {\n        throw e;\n      }\n\n      throw new DownloadError(\n        { code: 'DatabaseFileNotAccessible', url },\n        `Could not read database file (${getErrorMessage(e)})`\n      );\n    }\n\n    const { done, value } = readResult;\n\n    if (done) {\n      buffer += decoder.decode();\n      if (buffer) {\n        yield parseLine(buffer);\n        buffer = '';\n      }\n\n      return;\n    }\n\n    buffer += decoder.decode(value, { stream: true });\n    const lines = buffer.split(lineEnd);\n\n    // We don't know if the last line is actually the last line of the\n    // input or not until we get done: true so we just assume it is\n    // a partial line for now.\n    buffer = lines.length ? lines.splice(lines.length - 1, 1)[0] : '';\n\n    for (const line of lines) {\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      if (!line) {\n        continue;\n      }\n\n      yield parseLine(line);\n    }\n  }\n}\n\nfunction waitWithTimeout<T>({\n  promise,\n  timeout,\n  url,\n}: {\n  promise: Promise<T>;\n  timeout: number;\n  url?: string;\n}): Promise<T> {\n  let timeoutId: number;\n\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    timeoutId = self.setTimeout(() => {\n      clearTimeout(timeoutId);\n      reject(\n        new DownloadError(\n          { code: 'Timeout', url },\n          `Download timed out after ${timeout / 1000} seconds.`\n        )\n      );\n    }, timeout);\n  });\n\n  return Promise.race([promise, timeoutPromise]).then((val: T) => {\n    clearTimeout(timeoutId);\n    return val;\n  });\n}\n","/**\n * A helper to remove certain fields from an object.\n */\nexport function stripFields<T extends object, K extends keyof T>(\n  o: T,\n  fields: K[]\n): Omit<T, K> {\n  const result: Partial<T> = { ...(<object>o) };\n  for (const field of fields) {\n    delete result[field];\n  }\n  return <Omit<T, K>>result;\n}\n","export type VersionNumber = {\n  major: number;\n  minor: number;\n  patch: number;\n};\n\nexport function compareVersions(\n  a: Readonly<VersionNumber>,\n  b: Readonly<VersionNumber>\n): number {\n  if (a.major < b.major) {\n    return -1;\n  }\n  if (a.major > b.major) {\n    return 1;\n  }\n  if (a.minor < b.minor) {\n    return -1;\n  }\n  if (a.minor > b.minor) {\n    return 1;\n  }\n  if (a.patch < b.patch) {\n    return -1;\n  }\n  if (a.patch > b.patch) {\n    return 1;\n  }\n  return 0;\n}\n","import * as s from 'superstruct';\n\nimport { DataSeries } from './data-series';\nimport { DataVersion } from './data-version';\nimport { DownloadError } from './download-error';\nimport { getVersionInfo } from './download-version-info';\nimport {\n  getErrorMessage,\n  isAbortError,\n  isDownloadError,\n} from './error-parsing';\nimport { fetchWithTimeout } from './fetch';\nimport { isObject } from './is-object';\nimport { ljsonStreamIterator } from './ljson-stream';\nimport { PartInfo } from './part-info';\nimport { stripFields } from './utils';\nimport { safeInteger } from './validation-helpers';\nimport { compareVersions, VersionNumber } from './version-number';\n\n// Produces an async interator of DownloadEvents\n\n//\n// Event types\n//\n\nexport type DownloadEvent =\n  | ResetEvent\n  | DownloadStartEvent\n  | DownloadEndEvent\n  | FileStartEvent\n  | FileEndEvent\n  | RecordEvent;\n\nexport type ResetEvent = { type: 'reset' };\nexport type DownloadStartEvent = { type: 'downloadstart'; files: number };\nexport type DownloadEndEvent = { type: 'downloadend' };\nexport type FileStartEvent = {\n  type: 'filestart';\n  version: DataVersion;\n  totalRecords: number;\n};\nexport type FileEndEvent = { type: 'fileend' };\nexport type RecordEvent = {\n  type: 'record';\n  mode: 'add' | 'change' | 'delete';\n  record: Record<string, unknown>;\n};\n\n//\n// Helper types\n//\n\nexport type CurrentVersion = VersionNumber & {\n  partInfo?: PartInfo;\n};\n\n//\n// Configuration constants\n//\n\nconst BASE_URL = 'https://data.10ten.life/';\n\nconst DOWNLOAD_TIMEOUT = 20_000;\n\nexport type DownloadOptions = {\n  series: DataSeries;\n  majorVersion: number;\n  currentVersion?: CurrentVersion;\n  lang: string;\n  signal: AbortSignal;\n};\n\nexport async function hasLanguage({\n  series,\n  majorVersion,\n  lang,\n  signal,\n}: {\n  baseUrl?: string;\n  series: DataSeries;\n  majorVersion: number;\n  lang: string;\n  signal?: AbortSignal;\n}): Promise<boolean> {\n  try {\n    const result = await getVersionInfo({\n      baseUrl: BASE_URL,\n      series,\n      lang,\n      majorVersion,\n      timeout: DOWNLOAD_TIMEOUT,\n      signal,\n    });\n    return !!result;\n  } catch {\n    return false;\n  }\n}\n\nexport async function* download({\n  series,\n  majorVersion,\n  currentVersion,\n  lang,\n  signal,\n}: DownloadOptions): AsyncIterableIterator<DownloadEvent> {\n  const versionInfo = await getVersionInfo({\n    baseUrl: BASE_URL,\n    series,\n    lang,\n    majorVersion,\n    timeout: DOWNLOAD_TIMEOUT,\n    signal,\n  });\n\n  const { files, type } = getDownloadList({\n    currentVersion,\n    latestVersion: versionInfo,\n  });\n\n  if (type === 'reset' && currentVersion) {\n    yield { type: 'reset' };\n  }\n\n  yield { type: 'downloadstart', files: files.length };\n\n  for (const file of files) {\n    yield* getEvents({\n      baseUrl: BASE_URL,\n      series,\n      lang,\n      version: file.version,\n      signal,\n      format: file.format,\n      partInfo: file.partInfo,\n    });\n  }\n\n  yield { type: 'downloadend' };\n}\n\ntype DownloadFileSpec =\n  | {\n      format: 'full';\n      version: VersionNumber;\n      partInfo?: PartInfo;\n    }\n  | {\n      format: 'patch';\n      version: VersionNumber;\n      partInfo?: never;\n    };\n\nfunction getDownloadList({\n  currentVersion,\n  latestVersion,\n}: {\n  currentVersion?: CurrentVersion;\n  latestVersion: {\n    major: number;\n    minor: number;\n    patch: number;\n    parts?: number;\n  };\n}): {\n  type: 'reset' | 'update';\n  files: Array<DownloadFileSpec>;\n} {\n  // Check the local database is not ahead of what we're about to download\n  //\n  // This can happen when the version file gets cached because we can\n  // download a more recent version (e.g. we have DevTools open with \"skip\n  // cache\" ticked) and then try again to fetch the file but get the older\n  // version.\n  if (currentVersion && compareVersions(currentVersion, latestVersion) > 0) {\n    const versionToString = ({ major, minor, patch }: VersionNumber) =>\n      `${major}.${minor}.${patch}`;\n    throw new DownloadError(\n      { code: 'DatabaseTooOld' },\n      `Database version (${versionToString(\n        latestVersion\n      )}) is older than the current version (${versionToString(\n        currentVersion\n      )})`\n    );\n  }\n\n  // If there's no current version or if there's been a change in major/minor\n  // version, reset any existing data.\n  let downloadType =\n    !currentVersion ||\n    compareVersions(currentVersion, { ...latestVersion, patch: 0 }) < 0\n      ? ('reset' as const)\n      : ('update' as const);\n\n  // Furthermore, if we're resuming a multi-part initial download but there have\n  // since been more than 10 new patches to that minor version, we should just\n  // start over.\n  //\n  // This will probably be faster and, more importantly, it means we can archive\n  // the full (i.e. non-patch) version files of any minor version that is more\n  // than 10 patches old without having to worry about really out-of-date\n  // clients later requesting those parts.\n  if (\n    downloadType === 'update' &&\n    currentVersion?.partInfo &&\n    latestVersion.patch - currentVersion.patch > 10\n  ) {\n    downloadType = 'reset';\n  }\n\n  // There are four cases to consider:\n  //\n  // 1. We are doing a full download of a partitioned data series\n  //    i.e. we need to download all the parts from 0 to `parts - 1`.\n  //\n  // 2. We are doing a full download of an unpartitioned data series\n  //    i.e. we simply need to download the data file for the current patch\n  //    level.\n  //\n  // 3. We are resuming a full download\n  //    i.e. we need to download all the remaining parts _and_ any\n  //    subsequent patches.\n  //\n  // 4. We are patching an existing series\n  //    i.e. we need to download each patch from the one after the current\n  //    version up to and including the latest patch.\n\n  // Case 1: Partitioned series\n  if (downloadType === 'reset' && latestVersion.parts) {\n    const files: Array<DownloadFileSpec> = [];\n    let nextPart = 1;\n\n    while (nextPart <= latestVersion.parts) {\n      files.push({\n        format: 'full',\n        version: {\n          major: latestVersion.major,\n          minor: latestVersion.minor,\n          patch: latestVersion.patch,\n        },\n        partInfo: {\n          part: nextPart,\n          parts: latestVersion.parts,\n        },\n      });\n      nextPart++;\n    }\n\n    return { type: downloadType, files };\n  }\n\n  // Case 2: Unpartitioned series\n  if (downloadType === 'reset') {\n    return {\n      type: downloadType,\n      files: [\n        {\n          format: 'full',\n          version: {\n            major: latestVersion.major,\n            minor: latestVersion.minor,\n            patch: latestVersion.patch,\n          },\n        },\n      ],\n    };\n  }\n\n  // The following is just to help TypeScript realise that `currentVersion` must\n  // be defined if `downloadType` is 'update'.\n  if (!currentVersion) {\n    throw new Error(\n      'We should have already dealt with the initial download case'\n    );\n  }\n\n  // Case 3 (part 1): Resumed partitioned series\n  const files: Array<DownloadFileSpec> = [];\n  if (currentVersion.partInfo) {\n    let nextPart = currentVersion.partInfo.part + 1;\n\n    while (nextPart <= currentVersion.partInfo.parts) {\n      files.push({\n        format: 'full',\n        version: {\n          major: currentVersion.major,\n          minor: currentVersion.minor,\n          patch: currentVersion.patch,\n        },\n        partInfo: {\n          part: nextPart,\n          parts: currentVersion.partInfo.parts,\n        },\n      });\n      nextPart++;\n    }\n  }\n\n  // Case 3 (part 2) and case 4: Updating a series\n  let nextPatch = currentVersion.patch + 1;\n  while (nextPatch <= latestVersion.patch) {\n    files.push({\n      format: 'patch',\n      version: {\n        major: latestVersion.major,\n        minor: latestVersion.minor,\n        patch: nextPatch,\n      },\n    });\n    nextPatch++;\n  }\n\n  return { type: downloadType, files };\n}\n\ntype GetEventsOptions = {\n  baseUrl: string;\n  series: DataSeries;\n  lang: string;\n  version: VersionNumber;\n  signal: AbortSignal;\n  format: 'full' | 'patch';\n  partInfo?: PartInfo;\n};\n\nconst HeaderLineStruct = s.type({\n  type: s.literal('header'),\n  version: s.type({\n    major: s.min(safeInteger(), 1),\n    minor: s.min(safeInteger(), 0),\n    patch: s.min(safeInteger(), 0),\n    databaseVersion: s.optional(s.string()),\n    dateOfCreation: s.nonempty(s.string()),\n  }),\n  records: s.min(safeInteger(), 0),\n  part: s.optional(s.min(safeInteger(), 0)),\n  format: s.enums(['patch', 'full']),\n});\n\nconst PatchLineStruct = s.type({\n  _: s.enums(['+', '-', '~']),\n});\n\nasync function* getEvents({\n  baseUrl,\n  series,\n  lang,\n  version,\n  signal,\n  format,\n  partInfo,\n}: GetEventsOptions): AsyncIterableIterator<DownloadEvent> {\n  const dottedVersion = `${version.major}.${version.minor}.${version.patch}`;\n  const commonUrlStart = `${baseUrl}jpdict/reader/${series}/${lang}/${dottedVersion}`;\n  const url =\n    format === 'patch'\n      ? `${commonUrlStart}-patch.jsonl`\n      : partInfo\n        ? `${commonUrlStart}-${partInfo.part}.jsonl`\n        : `${commonUrlStart}.jsonl`;\n\n  let response;\n  try {\n    response = await fetchWithTimeout(url, {\n      signal,\n      timeout: DOWNLOAD_TIMEOUT,\n    });\n  } catch (e) {\n    if (isAbortError(e) || isDownloadError(e)) {\n      throw e;\n    }\n\n    throw new DownloadError(\n      { code: 'DatabaseFileNotFound', url },\n      `Database file ${url} not accessible (${getErrorMessage(e)})`\n    );\n  }\n\n  if (!response.ok) {\n    const code =\n      response.status === 404\n        ? 'DatabaseFileNotFound'\n        : 'DatabaseFileNotAccessible';\n    throw new DownloadError(\n      { code, url },\n      `Database file ${url} not accessible (status: ${response.status})`\n    );\n  }\n\n  if (response.body === null) {\n    throw new DownloadError(\n      { code: 'DatabaseFileNotAccessible', url },\n      'Body is null'\n    );\n  }\n\n  let headerRead = false;\n\n  for await (const line of ljsonStreamIterator({\n    stream: response.body,\n    signal,\n    timeout: DOWNLOAD_TIMEOUT,\n    url,\n  })) {\n    if (s.is(line, HeaderLineStruct)) {\n      if (headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderDuplicate', url },\n          `Got duplicate database header: ${JSON.stringify(line)}`\n        );\n      }\n\n      if (compareVersions(line.version, version) !== 0) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Got mismatched database versions (Expected: ${JSON.stringify(\n            version\n          )} got: ${JSON.stringify(line.version)})`\n        );\n      }\n\n      if (line.part !== partInfo?.part) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Got mismatched database part number (Expected: ${partInfo?.part}, got: ${line.part})`\n        );\n      }\n\n      if (line.format !== format) {\n        throw new DownloadError(\n          { code: 'DatabaseFileVersionMismatch', url },\n          `Expected to get a data file in ${format} format but got '${line.format}' format instead`\n        );\n      }\n\n      let fileStartEvent: FileStartEvent;\n      if (line.part !== undefined) {\n        fileStartEvent = {\n          type: 'filestart',\n          totalRecords: line.records,\n          version: {\n            ...line.version,\n            partInfo: {\n              part: line.part,\n              parts: partInfo!.parts,\n            },\n            lang,\n          },\n        };\n      } else {\n        fileStartEvent = {\n          type: 'filestart',\n          totalRecords: line.records,\n          version: {\n            ...line.version,\n            lang,\n          },\n        };\n      }\n\n      yield fileStartEvent;\n\n      headerRead = true;\n    } else if (format === 'patch' && s.is(line, PatchLineStruct)) {\n      if (!headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderMissing', url },\n          `Expected database version but got ${JSON.stringify(line)}`\n        );\n      }\n\n      const mode =\n        line._ === '+' ? 'add' : line._ === '-' ? 'delete' : 'change';\n      yield { type: 'record', mode, record: stripFields(line, ['_']) };\n    } else if (format === 'full' && isObject(line)) {\n      if (!headerRead) {\n        throw new DownloadError(\n          { code: 'DatabaseFileHeaderMissing', url },\n          `Expected database version but got ${JSON.stringify(line)}`\n        );\n      }\n\n      if ('_' in line) {\n        throw new DownloadError(\n          { code: 'DatabaseFileInvalidRecord', url },\n          `Got patch-like '_' field in non-patch record: ${JSON.stringify(\n            line\n          )}`\n        );\n      }\n\n      yield { type: 'record', mode: 'add', record: line };\n    } else {\n      // If we encounter anything unexpected we should fail.\n      //\n      // It might be tempting to make this \"robust\" by ignoring unrecognized\n      // inputs but that could effectively leave us in an invalid state where\n      // we claim to be update-to-date with database version X but are\n      // actually missing some of the records.\n      //\n      // If anything unexpected shows up we should fail so we can debug\n      // exactly what happenned.\n      throw new DownloadError(\n        { code: 'DatabaseFileInvalidRecord', url },\n        `Got unexpected record: ${JSON.stringify(line)}`\n      );\n    }\n  }\n\n  yield { type: 'fileend' };\n}\n","export class QuotaExceededError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, QuotaExceededError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, QuotaExceededError);\n    }\n\n    this.name = 'QuotaExceededError';\n    this.message = 'The current transaction exceeded its quota limitations.';\n  }\n}\n","export function isKanji(str: string): boolean {\n  const c = str.codePointAt(0) || 0;\n  return (\n    (c >= 0x4e00 && c <= 0x9fea) ||\n    /* Ideographs extension A */\n    (c >= 0x3400 && c <= 0x4dbf) ||\n    /* Ideographs extension B&C&D&E */\n    (c >= 0x20000 && c <= 0x2ebef)\n  );\n}\n\nexport function hasHiragana(str: string): boolean {\n  return [...str]\n    .map((c) => c.codePointAt(0)!)\n    .some((c) => c >= 0x3041 && c <= 0x309f);\n}\n","import { kanaToHiragana } from '@birchill/normal-jp';\n\nimport {\n  KanjiDownloadDeleteRecord,\n  KanjiDownloadRecord,\n  NameDownloadDeleteRecord,\n  NameDownloadRecord,\n  RadicalDownloadDeleteRecord,\n  RadicalDownloadRecord,\n  WordDownloadDeleteRecord,\n  WordDownloadRecord,\n} from './download-types';\nimport { hasHiragana } from './japanese';\nimport { Overwrite } from './type-helpers';\nimport { KanjiMeta, ReadingMeta } from './words';\n\n// ----------------------------------------------------------------------------\n//\n// Words\n//\n// ----------------------------------------------------------------------------\n\nexport type WordStoreRecord = Overwrite<\n  WordDownloadRecord,\n  {\n    // When transporting via JSON we replace nulls with 0s but we store them as\n    // nulls.\n    rm?: Array<null | ReadingMeta>;\n    km?: Array<null | KanjiMeta>;\n\n    // r and k strings with all kana converted to hiragana\n    h: Array<string>;\n    // Individual from k split out into separate strings\n    kc: Array<string>;\n    // Gloss tokens (English and localized)\n    gt_en: Array<string>;\n    gt_l: Array<string>;\n  }\n>;\n\nexport function toWordStoreRecord(record: WordDownloadRecord): WordStoreRecord {\n  const result = {\n    ...record,\n    rm: record.rm\n      ? record.rm.map((elem) => (elem === 0 ? null : elem))\n      : undefined,\n    km: record.km\n      ? record.km.map((elem) => (elem === 0 ? null : elem))\n      : undefined,\n    h: keysToHiragana([...(record.k || []), ...record.r]),\n    kc: [],\n    gt_en: [],\n    gt_l: [],\n  };\n\n  // I'm not sure if IndexedDB preserves properties with undefined values\n  // (I think it does, although JSON does not) but just to be sure we don't\n  // end up storing unnecessary values, drop any undefined properties we may\n  // have just added.\n  if (!result.rm) {\n    delete result.rm;\n  }\n  if (!result.km) {\n    delete result.km;\n  }\n\n  return result;\n}\n\nexport function getStoreIdForWordRecord(\n  record: WordDownloadRecord | WordDownloadDeleteRecord\n): number {\n  return record.id;\n}\n\n// ----------------------------------------------------------------------------\n//\n// Names\n//\n// ----------------------------------------------------------------------------\n\nexport type NameStoreRecord = NameDownloadRecord & {\n  // r and k strings with all kana converted to hiragana\n  h: Array<string>;\n};\n\nexport function toNameStoreRecord(entry: NameDownloadRecord): NameStoreRecord {\n  return {\n    ...entry,\n    h: keysToHiragana([...(entry.k || []), ...entry.r]),\n  };\n}\n\nexport function getStoreIdForNameRecord(\n  record: NameDownloadRecord | NameDownloadDeleteRecord\n): number {\n  return record.id;\n}\n\n// ----------------------------------------------------------------------------\n//\n// Kanji\n//\n// ----------------------------------------------------------------------------\n\nexport type KanjiStoreRecord = Overwrite<\n  KanjiDownloadRecord,\n  {\n    // Define a variant on KanjiEntryLine that turns 'c' into a number\n    c: number;\n  }\n>;\n\nexport function toKanjiStoreRecord(\n  record: KanjiDownloadRecord\n): KanjiStoreRecord {\n  return {\n    ...record,\n    c: record.c.codePointAt(0) as number,\n  };\n}\n\nexport function getStoreIdForKanjiRecord(\n  record: KanjiDownloadRecord | KanjiDownloadDeleteRecord\n): number {\n  return record.c.codePointAt(0) as number;\n}\n\n// ----------------------------------------------------------------------------\n//\n// Radicals\n//\n// ----------------------------------------------------------------------------\n\nexport type RadicalStoreRecord = RadicalDownloadRecord;\n\nexport function toRadicalStoreRecord(\n  record: RadicalDownloadRecord\n): RadicalStoreRecord {\n  return record;\n}\n\nexport function getStoreIdForRadicalRecord(\n  record: RadicalDownloadRecord | RadicalDownloadDeleteRecord\n): string {\n  return record.id;\n}\n\n// ---------------------------------------------------------------------------\n//\n// Common\n//\n// ---------------------------------------------------------------------------\n\nfunction keysToHiragana(values: Array<string>): Array<string> {\n  // We only add hiragana keys for words that actually have some hiragana in\n  // them. Any purely kanji keys should match on the 'k' index and won't benefit\n  // from converting the input and source to hiragana so we can match them.\n  return Array.from(\n    new Set(values.map((value) => kanaToHiragana(value)).filter(hasHiragana))\n  );\n}\n","import {\n  DBSchema,\n  deleteDB,\n  IDBPDatabase,\n  IDBPTransaction,\n  openDB,\n  StoreNames,\n} from 'idb';\n\nimport { DataSeries } from './data-series';\nimport { DataVersion } from './data-version';\nimport { DownloadDeleteRecord, DownloadRecord } from './download-types';\nimport { QuotaExceededError } from './quota-exceeded-error';\nimport {\n  getStoreIdForKanjiRecord,\n  getStoreIdForNameRecord,\n  getStoreIdForRadicalRecord,\n  getStoreIdForWordRecord,\n  KanjiStoreRecord,\n  NameStoreRecord,\n  RadicalStoreRecord,\n  toKanjiStoreRecord,\n  toNameStoreRecord,\n  toRadicalStoreRecord,\n  toWordStoreRecord,\n  WordStoreRecord,\n} from './store-types';\nimport { stripFields } from './utils';\n\ninterface DataVersionRecord extends DataVersion {\n  id: 1 | 2 | 3 | 4;\n}\n\nfunction getVersionKey(series: DataSeries): 1 | 2 | 3 | 4 {\n  switch (series) {\n    case 'words':\n      return 4;\n\n    case 'kanji':\n      return 1;\n\n    case 'radicals':\n      return 2;\n\n    case 'names':\n      return 3;\n  }\n}\n\nexport interface JpdictSchema extends DBSchema {\n  words: {\n    key: number;\n    value: WordStoreRecord;\n    indexes: {\n      k: Array<string>;\n      r: Array<string>;\n      h: Array<string>;\n      kc: Array<string>;\n      gt_en: Array<string>;\n      gt_l: Array<string>;\n    };\n  };\n  kanji: {\n    key: number;\n    value: KanjiStoreRecord;\n    indexes: {\n      'r.on': Array<string>;\n      'r.kun': Array<string>;\n      'r.na': Array<string>;\n    };\n  };\n  radicals: {\n    key: string;\n    value: RadicalStoreRecord;\n    indexes: {\n      r: number;\n      b: string;\n      k: string;\n    };\n  };\n  names: {\n    key: number;\n    value: NameStoreRecord;\n    indexes: {\n      k: Array<string>;\n      r: Array<string>;\n      h: Array<string>;\n    };\n  };\n  version: {\n    key: number;\n    value: DataVersionRecord;\n  };\n}\n\nexport type RecordUpdate<T extends DataSeries> =\n  | {\n      mode: 'add';\n      record: DownloadRecord<T>;\n    }\n  | {\n      mode: 'change';\n      record: DownloadRecord<T>;\n    }\n  | {\n      mode: 'delete';\n      record: DownloadDeleteRecord<T>;\n    };\n\nexport class JpdictStore {\n  private state: 'idle' | 'opening' | 'open' | 'error' | 'deleting' = 'idle';\n  private db: IDBPDatabase<JpdictSchema> | undefined;\n  private openPromise: Promise<IDBPDatabase<JpdictSchema>> | undefined;\n  private deletePromise: Promise<void> | undefined;\n\n  protected toStoreRecord: {\n    [series in DataSeries]: (\n      record: DownloadRecord<series>\n    ) => JpdictSchema[series]['value'];\n  } = {\n    words: toWordStoreRecord,\n    names: toNameStoreRecord,\n    kanji: toKanjiStoreRecord,\n    radicals: toRadicalStoreRecord,\n  };\n\n  protected getStoreId: {\n    [series in DataSeries]: (\n      record: DownloadDeleteRecord<series>\n    ) => JpdictSchema[series]['key'];\n  } = {\n    words: getStoreIdForWordRecord,\n    names: getStoreIdForNameRecord,\n    kanji: getStoreIdForKanjiRecord,\n    radicals: getStoreIdForRadicalRecord,\n  };\n\n  async open(): Promise<IDBPDatabase<JpdictSchema>> {\n    if (this.state === 'open') {\n      return this.db!;\n    }\n\n    if (this.state === 'opening') {\n      return this.openPromise!;\n    }\n\n    if (this.state === 'deleting') {\n      await this.deletePromise!;\n    }\n\n    this.state = 'opening';\n\n    /* eslint @typescript-eslint/no-this-alias: 0 */\n    const self = this;\n\n    this.openPromise = openDB<JpdictSchema>('jpdict', 4, {\n      upgrade(\n        db: IDBPDatabase<JpdictSchema>,\n        oldVersion: number,\n        _newVersion: number | null,\n        transaction: IDBPTransaction<\n          JpdictSchema,\n          StoreNames<JpdictSchema>[],\n          'versionchange'\n        >\n      ) {\n        if (oldVersion < 1) {\n          const kanjiTable = db.createObjectStore<'kanji'>('kanji', {\n            keyPath: 'c',\n          });\n          kanjiTable.createIndex('r.on', 'r.on', { multiEntry: true });\n          kanjiTable.createIndex('r.kun', 'r.kun', { multiEntry: true });\n          kanjiTable.createIndex('r.na', 'r.na', { multiEntry: true });\n\n          const radicalsTable = db.createObjectStore<'radicals'>('radicals', {\n            keyPath: 'id',\n          });\n          radicalsTable.createIndex('r', 'r');\n          radicalsTable.createIndex('b', 'b');\n          radicalsTable.createIndex('k', 'k');\n\n          db.createObjectStore<'version'>('version', {\n            keyPath: 'id',\n          });\n        }\n        if (oldVersion < 2) {\n          const namesTable = db.createObjectStore<'names'>('names', {\n            keyPath: 'id',\n          });\n          namesTable.createIndex('k', 'k', { multiEntry: true });\n          namesTable.createIndex('r', 'r', { multiEntry: true });\n        }\n        if (oldVersion < 3) {\n          const namesTable = transaction.objectStore('names');\n          namesTable.createIndex('h', 'h', { multiEntry: true });\n        }\n        if (oldVersion < 4) {\n          const wordsTable = db.createObjectStore<'words'>('words', {\n            keyPath: 'id',\n          });\n          wordsTable.createIndex('k', 'k', { multiEntry: true });\n          wordsTable.createIndex('r', 'r', { multiEntry: true });\n\n          wordsTable.createIndex('h', 'h', { multiEntry: true });\n\n          wordsTable.createIndex('kc', 'kc', { multiEntry: true });\n          wordsTable.createIndex('gt_en', 'gt_en', { multiEntry: true });\n          wordsTable.createIndex('gt_l', 'gt_l', { multiEntry: true });\n        }\n      },\n      blocked() {\n        console.log('Opening blocked');\n      },\n      blocking() {\n        if (self.db) {\n          try {\n            self.db.close();\n          } catch {\n            // Ignore\n          }\n          self.db = undefined;\n          self.state = 'idle';\n        }\n      },\n    }).then((db) => {\n      self.db = db;\n      self.state = 'open';\n      return db;\n    });\n\n    try {\n      await this.openPromise;\n    } catch (e) {\n      this.state = 'error';\n      throw e;\n    } finally {\n      // This is not strictly necessary, but it doesn't hurt.\n      this.openPromise = undefined;\n    }\n\n    // IndexedDB doesn't provide a way to check if a database exists\n    // so we just unconditionally try to delete the old database, in case it\n    // exists, _every_ _single_ _time_.\n    //\n    // We don't bother waiting on it or reporting errors, however.\n    deleteDB('KanjiStore').catch(() => {});\n\n    return this.db!;\n  }\n\n  async close() {\n    if (this.state === 'idle') {\n      return;\n    }\n\n    if (this.state === 'deleting') {\n      return this.deletePromise;\n    }\n\n    if (this.state === 'opening') {\n      await this.openPromise;\n    }\n\n    this.db?.close();\n    this.db = undefined;\n    this.state = 'idle';\n  }\n\n  async destroy() {\n    if (this.state !== 'idle') {\n      await this.close();\n    }\n\n    this.state = 'deleting';\n\n    this.deletePromise = deleteDB('jpdict', {\n      blocked() {\n        console.log('Deletion blocked');\n      },\n    });\n\n    await this.deletePromise;\n\n    this.deletePromise = undefined;\n    this.state = 'idle';\n  }\n\n  async clearSeries(series: DataSeries) {\n    const db = await this.open();\n\n    const tx = db.transaction([series, 'version'], 'readwrite');\n\n    try {\n      // Drop the table\n      const targetTable = tx.objectStore(series);\n      await targetTable.clear();\n\n      // Drop the version record\n      const versionTable = tx.objectStore('version');\n      const id = getVersionKey(series);\n      void versionTable.delete(id);\n    } catch (e) {\n      console.error(`Error deleting data series '${series}'`, e);\n\n      // Ignore the abort from the transaction\n      tx.done.catch(() => {});\n      try {\n        tx.abort();\n      } catch {\n        // Ignore exceptions from aborting the transaction.\n        // This can happen is the transaction has already been aborted by this\n        // point.\n      }\n\n      throw e;\n    }\n\n    await tx.done;\n  }\n\n  async getDataVersion(series: DataSeries): Promise<DataVersion | null> {\n    await this.open();\n\n    const key = getVersionKey(series);\n    const versionDoc = await this.db!.get('version', key);\n    if (!versionDoc) {\n      return null;\n    }\n\n    return stripFields(versionDoc, ['id']);\n  }\n\n  async updateDataVersion({\n    series,\n    version,\n  }: {\n    series: DataSeries;\n    version: DataVersion;\n  }) {\n    await this.open();\n\n    try {\n      const id = getVersionKey(series);\n      await this.db!.put('version', { ...version, id });\n    } catch (e) {\n      console.error(\n        `Error updating version of '${series}' to ${JSON.stringify(version)}`,\n        e\n      );\n\n      throw e;\n    }\n  }\n\n  async updateSeries<T extends DataSeries>({\n    series,\n    updates,\n  }: {\n    series: T;\n    updates: Array<RecordUpdate<T>>;\n  }) {\n    await this.open();\n\n    const tx = this.db!.transaction(series, 'readwrite', {\n      durability: 'relaxed',\n    });\n    const table = tx.store;\n\n    try {\n      // The important thing here is NOT to wait on the result of each\n      // put/delete. This speeds up the operation by an order of magnitude or\n      // two and is Dexie's secret sauce.\n      //\n      // See: https://jsfiddle.net/birtles/vx4urLkw/17/\n      for (const update of updates) {\n        if (update.mode === 'delete') {\n          void table.delete(this.getStoreId[series](update.record));\n        } else {\n          void table.put(this.toStoreRecord[series](update.record));\n        }\n      }\n\n      await tx.done;\n    } catch (e) {\n      console.error(`Error updating series ${series}`, e);\n\n      // Ignore the abort from the transaction\n      tx.done.catch(() => {});\n      try {\n        tx.abort();\n      } catch {\n        // As above, ignore exceptions from aborting the transaction.\n      }\n\n      // We sometimes encounter a situation where Firefox throws an Error with\n      // an undefined message. All we have to go by is a user's screenshot that\n      // shows the following in the browser console:\n      //\n      //   Error: undefined\n      //\n      // We _think_ this happens in some cases where the disk space quota is\n      // exceeded so we try to detect that case and throw an actual\n      // QuotaExceededError instead.\n      if (isVeryGenericError(e) && (await atOrNearQuota())) {\n        console.info(\n          'Detected generic error masking a quota exceeded situation'\n        );\n        throw new QuotaExceededError();\n      }\n\n      throw e;\n    }\n  }\n\n  // Test API\n  async _getKanji(kanji: Array<number>): Promise<Array<KanjiStoreRecord>> {\n    await this.open();\n\n    const result: Array<KanjiStoreRecord> = [];\n    {\n      const tx = this.db!.transaction('kanji');\n      for (const c of kanji) {\n        const record = await tx.store.get(c);\n        if (record) {\n          result.push(record);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n\n// We occasionally get these obscure errors when running IndexedDB in an\n// extension context where the error returned serializes as simply:\n//\n//   Error: undefined\n//\n// Our current theory is that it occurs when we hit an out-of-quota situation.\nfunction isVeryGenericError(e: any): boolean {\n  if (typeof e === 'undefined') {\n    return true;\n  }\n\n  // Look for an Error without a name or an object with name 'Error' but no\n  // message\n  return (\n    (e instanceof Error && !e?.name) || (e?.name === 'Error' && !e?.message)\n  );\n}\n\nasync function atOrNearQuota(): Promise<boolean> {\n  try {\n    const estimate = await self.navigator.storage.estimate();\n    return (\n      typeof estimate.usage !== 'undefined' &&\n      typeof estimate.quota !== 'undefined' &&\n      estimate.usage / estimate.quota > 0.9\n    );\n  } catch {\n    return false;\n  }\n}\n","import { DataSeries } from './data-series';\nimport { UpdateEvent } from './update-events';\nimport { UpdateState } from './update-state';\n\nexport type UpdateAction =\n  | UpdateEvent\n  | { type: 'start'; series: DataSeries }\n  | { type: 'end'; checkDate: Date }\n  | { type: 'error'; checkDate: Date | null };\n\nexport function reducer(state: UpdateState, action: UpdateAction): UpdateState {\n  switch (action.type) {\n    case 'start':\n      return {\n        type: 'checking',\n        series: action.series,\n        lastCheck: state.lastCheck,\n      };\n\n    case 'end':\n      return {\n        type: 'idle',\n        lastCheck: action.checkDate,\n      };\n\n    case 'error':\n      return { type: 'idle', lastCheck: action.checkDate || state.lastCheck };\n\n    case 'updatestart':\n    case 'updateend':\n      // Nothing to do here since the 'start' and 'end' events take care of\n      // initialization and returning to the 'idle' state.\n      //\n      // (Furthermore, the 'start' event comes before the 'updatestart'\n      // event--which only comes after we've fetched the version file and\n      // confirmed there is something to update--so it's a more suitable queue\n      // for transitioning to the 'checking' state.)\n      return state;\n\n    case 'filestart':\n      if (state.type === 'idle') {\n        console.error('Should not get filestart event in the idle state');\n        return state;\n      }\n\n      return {\n        type: 'updating',\n        series: state.series,\n        version: action.version,\n        fileProgress: 0,\n        totalProgress: state.type === 'updating' ? state.totalProgress : 0,\n        lastCheck: state.lastCheck,\n      };\n\n    case 'fileend':\n      // Nothing to do here -- the 'progress' action will take care of updating\n      // the progress and the 'end' action will take care returning to the\n      // 'idle' state once all is complete.\n      return state;\n\n    case 'progress':\n      if (state.type !== 'updating') {\n        console.error(`Should not get progress event in '${state.type}' state`);\n        return state;\n      }\n\n      return {\n        ...state,\n        fileProgress: action.fileProgress,\n        totalProgress: action.totalProgress,\n      };\n\n    case 'parseerror':\n      // Nothing to do here\n      return state;\n  }\n}\n","import * as s from 'superstruct';\n\nimport { DataSeries } from './data-series';\nimport { KanjiMiscInfo, KanjiReading, KanjiRecord, Radical } from './kanji';\nimport { NameRecord, NameTranslation } from './names';\nimport { RadicalRecord } from './radicals';\nimport { Overwrite } from './type-helpers';\nimport { safeInteger } from './validation-helpers';\nimport {\n  Accent,\n  CrossReference,\n  KanjiMeta,\n  LangSource,\n  ReadingMeta,\n  WordRecord,\n  WordSense,\n} from './words';\n\n// ----------------------------------------------------------------------------\n//\n// Words\n//\n// ----------------------------------------------------------------------------\n\nconst KanjiMetaSchema: s.Describe<KanjiMeta> = s.type({\n  i: s.optional(s.array(s.string())),\n  p: s.optional(s.array(s.string())),\n  bv: s.optional(s.string()),\n  bg: s.optional(s.string()),\n});\n\nconst AccentSchema: s.Describe<Accent> = s.type({\n  i: s.min(safeInteger(), 0),\n  pos: s.optional(s.array(s.string())),\n});\n\nconst ReadingMetaSchema: s.Describe<ReadingMeta> = s.type({\n  i: s.optional(s.array(s.string())),\n  p: s.optional(s.array(s.string())),\n  app: s.optional(s.min(safeInteger(), 0)),\n  a: s.optional(s.union([s.min(safeInteger(), 0), s.array(AccentSchema)])),\n  bv: s.optional(s.string()),\n  bg: s.optional(s.string()),\n});\n\n// The following typing is because Describe struggles with union types\nconst CrossReferenceSchema: s.Struct<s.Describe<CrossReference>['TYPE'], null> =\n  s.union([\n    s.type({\n      k: s.nonempty(s.string()),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n    s.type({\n      r: s.nonempty(s.string()),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n    s.type({\n      k: s.nonempty(s.string()),\n      r: s.string(),\n      sense: s.optional(s.min(safeInteger(), 0)),\n    }),\n  ]);\n\nconst LangSourceSchema: s.Describe<LangSource> = s.type({\n  lang: s.optional(s.nonempty(s.string())),\n  src: s.optional(s.string()),\n  // The following should be:\n  //\n  //   part: s.optional(s.literal(true)),\n  //   wasei: s.optional(s.literal(true)),\n  //\n  // But Describe doesn't seem to handle optional boolean literals so we try\n  // this way for now.\n  part: s.union([s.literal(true), s.literal(undefined)]),\n  wasei: s.union([s.literal(true), s.literal(undefined)]),\n});\n\nconst WordSenseSchema: s.Describe<WordSense> = s.type({\n  g: s.nonempty(s.array(s.nonempty(s.string()))),\n  gt: s.optional(s.min(safeInteger(), 1)),\n  lang: s.optional(s.nonempty(s.string())),\n  kapp: s.optional(s.min(safeInteger(), 0)),\n  rapp: s.optional(s.min(safeInteger(), 0)),\n  pos: s.optional(s.array(s.string())),\n  field: s.optional(s.array(s.string())),\n  misc: s.optional(s.array(s.string())),\n  dial: s.optional(s.array(s.string())),\n  inf: s.optional(s.nonempty(s.string())),\n  xref: s.optional(s.nonempty(s.array(CrossReferenceSchema))),\n  ant: s.optional(s.nonempty(s.array(CrossReferenceSchema))),\n  lsrc: s.optional(s.nonempty(s.array(LangSourceSchema))),\n});\n\nconst WordIdSchema = s.min(safeInteger(), 1);\n\nexport type WordDownloadRecord = Overwrite<\n  WordRecord,\n  {\n    km?: Array<0 | KanjiMeta>;\n    rm?: Array<0 | ReadingMeta>;\n    s: Array<WordSense>;\n  }\n>;\n\nconst WordDownloadRecordSchema: s.Describe<WordDownloadRecord> = s.type({\n  id: WordIdSchema,\n  k: s.optional(s.nonempty(s.array(s.string()))),\n  km: s.optional(s.nonempty(s.array(s.union([s.literal(0), KanjiMetaSchema])))),\n  r: s.array(s.nonempty(s.nonempty(s.string()))),\n  rm: s.optional(\n    s.nonempty(s.array(s.union([s.literal(0), ReadingMetaSchema])))\n  ),\n  s: s.array(WordSenseSchema),\n});\n\nexport function validateWordDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, WordDownloadRecord] {\n  return s.validate(record, WordDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type WordDownloadDeleteRecord = Pick<WordDownloadRecord, 'id'>;\n\nconst WordDownloadDeleteRecordSchema: s.Describe<WordDownloadDeleteRecord> =\n  s.type({\n    id: WordIdSchema,\n  });\n\nexport function validateWordDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, WordDownloadDeleteRecord] {\n  return s.validate(record, WordDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Names\n//\n// ----------------------------------------------------------------------------\n\nconst NameTranslationSchema: s.Describe<NameTranslation> = s.type({\n  type: s.optional(s.array(s.string())),\n  det: s.array(s.nonempty(s.string())),\n  cf: s.optional(s.array(s.nonempty(s.string()))),\n});\n\nconst NameIdSchema = s.min(safeInteger(), 1);\n\nexport type NameDownloadRecord = NameRecord;\n\nconst NameDownloadRecordSchema: s.Describe<NameDownloadRecord> = s.type({\n  id: NameIdSchema,\n  k: s.optional(s.array(s.nonempty(s.string()))),\n  r: s.nonempty(s.array(s.nonempty(s.string()))),\n  tr: s.array(NameTranslationSchema),\n});\n\nexport function validateNameDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, NameDownloadRecord] {\n  return s.validate(record, NameDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type NameDownloadDeleteRecord = Pick<NameDownloadRecord, 'id'>;\n\nconst NameDownloadDeleteRecordSchema: s.Describe<NameDownloadDeleteRecord> =\n  s.type({\n    id: NameIdSchema,\n  });\n\nexport function validateNameDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, NameDownloadDeleteRecord] {\n  return s.validate(record, NameDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Kanji\n//\n// ----------------------------------------------------------------------------\n\nconst ReadingsStruct: s.Describe<KanjiReading> = s.type({\n  on: s.optional(s.array(s.string())),\n  kun: s.optional(s.array(s.string())),\n  na: s.optional(s.array(s.string())),\n  py: s.optional(s.array(s.string())),\n});\n\nconst RadicalStruct: s.Describe<Radical> = s.type({\n  x: s.min(safeInteger(), 0),\n  nelson: s.optional(s.min(safeInteger(), 0)),\n  name: s.optional(s.array(s.string())),\n  var: s.optional(s.string()),\n});\n\nconst MiscSchema: s.Describe<KanjiMiscInfo> = s.type({\n  gr: s.optional(safeInteger()),\n  sc: s.min(safeInteger(), 1),\n  freq: s.optional(s.min(safeInteger(), 0)),\n  // The following three items should really have a minimum value of 1, but in\n  // the interests of being (a bit) forgiving in what we accept, we allow 0 too.\n  jlpt: s.optional(s.min(safeInteger(), 0)),\n  jlptn: s.optional(s.min(safeInteger(), 0)),\n  kk: s.optional(s.min(safeInteger(), 0)),\n  // As with jlpt(n), we allow 0 here even though we expect WaniKani levels to\n  // be between 1 and 60.\n  wk: s.optional(s.min(safeInteger(), 0)),\n  meta: s.optional(s.array(s.string())),\n});\n\nconst KanjiIdSchema = s.nonempty(s.string());\n\nexport type KanjiDownloadRecord = KanjiRecord;\n\nconst KanjiDownloadRecordSchema: s.Describe<KanjiDownloadRecord> = s.type({\n  c: KanjiIdSchema,\n  r: ReadingsStruct,\n  m: s.array(s.string()),\n  m_lang: s.optional(s.string()),\n  rad: RadicalStruct,\n  refs: s.record(s.string(), s.union([s.string(), s.number()])),\n  misc: MiscSchema,\n  st: s.optional(s.string()),\n  comp: s.optional(s.string()),\n  var: s.optional(s.array(s.string())),\n  cf: s.optional(s.union([s.string(), s.array(s.string())])),\n});\n\nexport function validateKanjiDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, KanjiDownloadRecord] {\n  return s.validate(record, KanjiDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type KanjiDownloadDeleteRecord = Pick<KanjiDownloadRecord, 'c'>;\n\nconst KanjiDownloadDeleteRecordSchema: s.Describe<KanjiDownloadDeleteRecord> =\n  s.type({\n    c: KanjiIdSchema,\n  });\n\nexport function validateKanjiDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, KanjiDownloadDeleteRecord] {\n  return s.validate(record, KanjiDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Radicals\n//\n// ----------------------------------------------------------------------------\n\nconst RadicalIdSchema = s.nonempty(s.string());\n\nexport type RadicalDownloadRecord = Overwrite<\n  RadicalRecord,\n  {\n    // We don't validate the posn field for downloaded records because we don't\n    // want to force a major version bump every time we add a posn field.\n    posn?: string;\n  }\n>;\n\nconst RadicalDownloadRecordSchema: s.Describe<RadicalDownloadRecord> = s.type({\n  id: RadicalIdSchema,\n  r: s.min(safeInteger(), 1),\n  b: s.optional(s.nonempty(s.string())),\n  k: s.optional(s.nonempty(s.string())),\n  pua: s.optional(safeInteger()),\n  s: safeInteger(),\n  na: s.array(s.nonempty(s.string())),\n  posn: s.optional(s.nonempty(s.string())),\n  m: s.array(s.nonempty(s.string())),\n  m_lang: s.optional(s.nonempty(s.string())),\n});\n\nexport function validateRadicalDownloadRecord(\n  record: unknown\n): [Error, undefined] | [undefined, RadicalDownloadRecord] {\n  return s.validate(record, RadicalDownloadRecordSchema);\n}\n\n// -- Delete variant --\n\nexport type RadicalDownloadDeleteRecord = Pick<RadicalDownloadRecord, 'id'>;\n\nconst RadicalDownloadDeleteRecordSchema: s.Describe<RadicalDownloadDeleteRecord> =\n  s.type({\n    id: RadicalIdSchema,\n  });\n\nexport function validateRadicalDownloadDeleteRecord(\n  record: unknown\n): [Error, undefined] | [undefined, RadicalDownloadDeleteRecord] {\n  return s.validate(record, RadicalDownloadDeleteRecordSchema);\n}\n\n// ----------------------------------------------------------------------------\n//\n// Combined types\n//\n// ----------------------------------------------------------------------------\n\ntype DownloadRecordMapping = {\n  words: WordDownloadRecord;\n  names: NameDownloadRecord;\n  kanji: KanjiDownloadRecord;\n  radicals: RadicalDownloadRecord;\n};\n\nexport type DownloadRecord<T extends DataSeries> = DownloadRecordMapping[T];\n\nconst validateDownloadRecordMapping: {\n  [Series in DataSeries]: (\n    record: unknown\n  ) => [Error, undefined] | [undefined, DownloadRecord<Series>];\n} = {\n  words: validateWordDownloadRecord,\n  names: validateNameDownloadRecord,\n  kanji: validateKanjiDownloadRecord,\n  radicals: validateRadicalDownloadRecord,\n};\n\nexport function validateDownloadRecord<Series extends DataSeries>({\n  series,\n  record,\n}: {\n  series: Series;\n  record: unknown;\n}) {\n  return validateDownloadRecordMapping[series](record);\n}\n\n// -- Delete variant --\n\ntype DownloadDeleteRecordMapping = {\n  words: WordDownloadDeleteRecord;\n  names: NameDownloadDeleteRecord;\n  kanji: KanjiDownloadDeleteRecord;\n  radicals: RadicalDownloadDeleteRecord;\n};\n\nexport type DownloadDeleteRecord<T extends DataSeries> =\n  DownloadDeleteRecordMapping[T];\n\nconst validateDownloadDeleteRecordMapping: {\n  [Series in DataSeries]: (\n    record: unknown\n  ) => [Error, undefined] | [undefined, DownloadDeleteRecord<Series>];\n} = {\n  words: validateWordDownloadDeleteRecord,\n  names: validateNameDownloadDeleteRecord,\n  kanji: validateKanjiDownloadDeleteRecord,\n  radicals: validateRadicalDownloadDeleteRecord,\n};\n\nexport function validateDownloadDeleteRecord<Series extends DataSeries>({\n  series,\n  record,\n}: {\n  series: Series;\n  record: unknown;\n}) {\n  return validateDownloadDeleteRecordMapping[series](record);\n}\n","import { AbortError } from './abort-error';\nimport { DataSeries } from './data-series';\nimport { DataVersion } from './data-version';\nimport {\n  validateDownloadDeleteRecord,\n  validateDownloadRecord,\n} from './download-types';\nimport { CurrentVersion, download, RecordEvent } from './download';\nimport { JpdictStore, RecordUpdate } from './store';\nimport { UpdateEvent } from './update-events';\n\nexport type UpdateCallback = (action: UpdateEvent) => void;\n\n// The number of records to queue up before updating the store.\n//\n// For IndexedDB, bigger batches are faster since we can just wait on the\n// transaction to complete rather than each individual put or delete and that\n// tends to be dramatically faster.\n//\n// However, making the batches too big introduces janky progress because\n// typically the download speed is faster than the update speed so we try to\n// make sure the batches aren't _too_ big.\n//\n// (In case that doesn't make sense, suppose we use a batch size of 10,000.\n// Often, downloading 10,000 records takes a fraction of a second while on many\n// systems putting 10,000 records into IndexedDB takes a second or two. If we\n// dispatch progress events based on the 'record' events we get from the\n// download and then do a big database update we'll get a series of quick\n// progress events and then a big pause while we update.\n//\n// We could try to dispatch progress events while we're updating too--in fact,\n// we used to do just that--but it's simpler if we can just have one type of\n// progress event and dispatch it fairly consistently.)\nconst BATCH_SIZE = 4000;\n\n// Don't update the progress until it has changed by at least 1%.\nconst MAX_PROGRESS_RESOLUTION = 0.01;\n\nexport async function update({\n  callback,\n  currentVersion,\n  lang,\n  majorVersion,\n  series,\n  signal,\n  store,\n}: {\n  callback: UpdateCallback;\n  currentVersion?: CurrentVersion;\n  lang: string;\n  majorVersion: number;\n  signal: AbortSignal;\n  series: DataSeries;\n  store: JpdictStore;\n}): Promise<void> {\n  return doUpdate({\n    callback,\n    currentVersion,\n    lang,\n    majorVersion,\n    series,\n    signal,\n    store,\n  });\n}\n\nasync function doUpdate<Series extends DataSeries>({\n  callback,\n  currentVersion,\n  lang,\n  majorVersion,\n  series,\n  signal,\n  store,\n}: {\n  callback: UpdateCallback;\n  currentVersion?: CurrentVersion;\n  lang: string;\n  majorVersion: number;\n  signal: AbortSignal;\n  series: Series;\n  store: JpdictStore;\n}) {\n  // Clear the database if the current version is empty in case we have records\n  // lying around from an incomplete initial download.\n  if (!currentVersion) {\n    await store.clearSeries(series);\n  }\n\n  let currentFile = 0;\n  let currentFileVersion: DataVersion | undefined;\n  let totalFiles = 0;\n\n  let currentRecord = 0;\n  let totalRecords = 0;\n  let updates: Array<RecordUpdate<Series>> = [];\n\n  let lastReportedTotalProgress: number | undefined;\n\n  for await (const event of download({\n    series,\n    majorVersion,\n    currentVersion,\n    lang,\n    signal,\n  })) {\n    if (signal.aborted) {\n      throw new AbortError();\n    }\n\n    switch (event.type) {\n      case 'reset':\n        await store.clearSeries(series);\n        break;\n\n      case 'downloadstart':\n        totalFiles = event.files;\n        callback({ type: 'updatestart' });\n        break;\n\n      case 'downloadend':\n        callback({ type: 'updateend' });\n        break;\n\n      case 'filestart':\n        currentFile++;\n        currentRecord = 0;\n        totalRecords = event.totalRecords;\n        currentFileVersion = event.version;\n        callback({ type: 'filestart', version: event.version });\n        if (currentFile === 1) {\n          callback({ type: 'progress', fileProgress: 0, totalProgress: 0 });\n          lastReportedTotalProgress = 0;\n        }\n        break;\n\n      case 'fileend':\n        {\n          // Save remaining batched items\n          if (updates.length) {\n            await store.updateSeries({ series, updates });\n            updates = [];\n          }\n\n          // Commit version info\n          //\n          // If this is the last part in a multi-part series, however, don't\n          // write the part info.\n          const versionToWrite = currentFileVersion!;\n          if (\n            versionToWrite.partInfo &&\n            versionToWrite.partInfo.part === versionToWrite.partInfo.parts\n          ) {\n            delete versionToWrite.partInfo;\n          }\n          await store.updateDataVersion({\n            series,\n            version: versionToWrite,\n          });\n\n          // Final progress event\n          const totalProgress = currentFile / totalFiles;\n          callback({\n            type: 'progress',\n            fileProgress: 1,\n            totalProgress,\n          });\n          lastReportedTotalProgress = totalProgress;\n\n          callback({ type: 'fileend', version: versionToWrite });\n        }\n        break;\n\n      case 'record':\n        {\n          const [error, update] = parseRecordEvent({ series, event });\n          if (error) {\n            callback({\n              type: 'parseerror',\n              message: error.message,\n              record: event.record,\n            });\n          } else {\n            updates.push(update);\n            if (updates.length >= BATCH_SIZE) {\n              await store.updateSeries({ series, updates });\n              updates = [];\n            }\n          }\n\n          // We update the total number of records even if we failed to validate\n          // the incoming record because the progress should continue even if\n          // all the records are bad.\n          currentRecord++;\n\n          // If we have processed enough records to pass the progress event\n          // threshold, dispatch a progress event.\n          const fileProgress = currentRecord / totalRecords;\n          const totalProgress = (currentFile - 1 + fileProgress) / totalFiles;\n          if (\n            // Don't dispatch a 100% file progress event until after we've\n            // updated the version database (as part of processing the 'fileend'\n            // event.)\n            fileProgress < 1 &&\n            (lastReportedTotalProgress === undefined ||\n              totalProgress - lastReportedTotalProgress >\n                MAX_PROGRESS_RESOLUTION)\n          ) {\n            callback({ type: 'progress', fileProgress, totalProgress });\n            lastReportedTotalProgress = totalProgress;\n          }\n        }\n        break;\n    }\n  }\n}\n\nfunction parseRecordEvent<Series extends DataSeries>({\n  series,\n  event,\n}: {\n  series: Series;\n  event: RecordEvent;\n}): [Error, undefined] | [undefined, RecordUpdate<Series>] {\n  const { mode, record: unvalidatedRecord } = event;\n  if (mode === 'delete') {\n    const [err, record] = validateDownloadDeleteRecord({\n      series,\n      record: unvalidatedRecord,\n    });\n    return err ? [err, undefined] : [undefined, { mode, record }];\n  }\n\n  const [err, record] = validateDownloadRecord({\n    series,\n    record: unvalidatedRecord,\n  });\n  return err ? [err, undefined] : [undefined, { mode, record }];\n}\n","import { jsonEqualish } from '@birchill/json-equalish';\n\nimport { AbortError } from './abort-error';\nimport {\n  allDataSeries,\n  allMajorDataSeries,\n  DataSeries,\n  MajorDataSeries,\n} from './data-series';\nimport { DataSeriesState } from './data-series-state';\nimport { DataVersion } from './data-version';\nimport { hasLanguage } from './download';\nimport { JpdictStore } from './store';\nimport { UpdateAction, reducer as updateReducer } from './update-state-reducer';\nimport { UpdateState } from './update-state';\nimport { update } from './update';\n\nconst MAJOR_VERSION: { [series in DataSeries]: number } = {\n  kanji: 4,\n  radicals: 4,\n  names: 3,\n  words: 2,\n};\n\nexport type ChangeTopic = 'stateupdated' | 'deleted';\nexport type ChangeCallback = (topic: ChangeTopic) => void;\n\ntype DataSeriesInfo = {\n  state: DataSeriesState;\n  version: DataVersion | null;\n  updateState: UpdateState;\n};\n\ntype InProgressUpdate = {\n  promise: Promise<void>;\n  controller: AbortController;\n  lang: string;\n};\n\nexport class JpdictIdb {\n  kanji: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n  radicals: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n  names: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n  words: DataSeriesInfo = {\n    state: 'init',\n    version: null,\n    updateState: { type: 'idle', lastCheck: null },\n  };\n\n  // This is currently only public so we can stub it in unit tests\n  store: JpdictStore;\n\n  private verbose = false;\n  private readyPromise: Promise<any>;\n  private changeListeners: ChangeCallback[] = [];\n  private inProgressUpdates: {\n    [series in MajorDataSeries]: InProgressUpdate | undefined;\n  } = { words: undefined, kanji: undefined, names: undefined };\n\n  // -------------------------------------------------------------------------\n  //\n  // Initialization\n  //\n  // -------------------------------------------------------------------------\n\n  constructor({ verbose = false }: { verbose?: boolean } = {}) {\n    this.store = new JpdictStore();\n    this.verbose = verbose;\n\n    // Fetch initial state\n    this.readyPromise = (async () => {\n      try {\n        for (const series of allDataSeries) {\n          // (2022-04-20 w/ TS 4.6.3) The following cast is needed to convince\n          // TS that `store` has been initialized.\n          //\n          // See https://stackoverflow.com/questions/51675833/typescript-error-property-is-used-before-being-assigned\n          const dataVersion = await (this as this).store.getDataVersion(series);\n          this.updateDataVersion(series, dataVersion);\n        }\n      } catch (e) {\n        console.error('Failed to open IndexedDB');\n        console.error(e);\n\n        // Reset state and version information\n        for (const series of allDataSeries) {\n          this[series] = {\n            ...this[series],\n            state: 'unavailable',\n            version: null,\n          };\n        }\n\n        throw e;\n      } finally {\n        this.notifyChanged('stateupdated');\n      }\n    })();\n  }\n\n  get ready() {\n    return this.readyPromise;\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Destruction\n  //\n  // -------------------------------------------------------------------------\n\n  async destroy() {\n    try {\n      await this.ready;\n    } catch {\n      // Ignore, we're going to destroy anyway\n    }\n\n    const hasData = allDataSeries.some(\n      (key: DataSeries) => this[key].state !== 'unavailable'\n    );\n    if (hasData) {\n      await this.store.destroy();\n    }\n\n    const hasInProgressUpdate = allMajorDataSeries.some(\n      (s) => typeof this.inProgressUpdates[s] !== 'undefined'\n    );\n    if (this.verbose && hasInProgressUpdate) {\n      console.info('Destroying database while there is an in-progress update');\n    }\n\n    this.store = new JpdictStore();\n    for (const series of allDataSeries) {\n      this[series] = {\n        state: 'empty',\n        version: null,\n        updateState: { type: 'idle', lastCheck: null },\n      };\n    }\n    this.notifyChanged('deleted');\n  }\n\n  async deleteSeries(series: MajorDataSeries) {\n    if (this.inProgressUpdates[series]) {\n      this.cancelUpdate(series);\n    }\n\n    await this.store.clearSeries(series);\n    this.updateDataVersion(series, null);\n\n    if (series === 'kanji') {\n      await this.store.clearSeries('radicals');\n      this.updateDataVersion('radicals', null);\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Change listeners\n  //\n  // -------------------------------------------------------------------------\n\n  addChangeListener(callback: ChangeCallback) {\n    if (this.changeListeners.indexOf(callback) !== -1) {\n      return;\n    }\n    this.changeListeners.push(callback);\n  }\n\n  removeChangeListener(callback: ChangeCallback) {\n    const index = this.changeListeners.indexOf(callback);\n    if (index === -1) {\n      return;\n    }\n    this.changeListeners.splice(index, 1);\n  }\n\n  private notifyChanged(topic: ChangeTopic) {\n    const changeListeners = this.changeListeners.slice();\n    for (const callback of changeListeners) {\n      callback(topic);\n    }\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Updating\n  //\n  // -------------------------------------------------------------------------\n\n  async update({ series, lang }: { series: MajorDataSeries; lang: string }) {\n    // Check for an existing update\n    const existingUpdate = this.inProgressUpdates[series];\n    if (existingUpdate && existingUpdate.lang === lang) {\n      if (this.verbose) {\n        console.info(\n          `Detected overlapping update for '${series}' series. Re-using existing update.`\n        );\n      }\n\n      return existingUpdate.promise;\n    }\n\n    // Cancel the existing update since the language doesn't match\n    if (existingUpdate) {\n      if (this.verbose) {\n        console.info(\n          `Cancelling existing update for '${series}' series since the requested language (${lang}) doesn't match that of the existing update(${existingUpdate.lang})`\n        );\n      }\n\n      this.cancelUpdate(series);\n    }\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n    const updatePromise = (async () => {\n      await this.ready;\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      switch (series) {\n        case 'words':\n          await this.doUpdate({ series: 'words', signal, lang });\n          break;\n\n        case 'kanji':\n          await this.doUpdate({ series: 'kanji', signal, lang });\n          if (signal.aborted) {\n            throw new AbortError();\n          }\n          await this.doUpdate({ series: 'radicals', signal, lang });\n          break;\n\n        case 'names':\n          await this.doUpdate({ series: 'names', signal, lang });\n          break;\n      }\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n    })();\n\n    this.inProgressUpdates[series] = {\n      lang,\n      controller,\n      promise: updatePromise\n        .catch(() => {}) // Ignore errors from this Promise chain\n        .finally(() => {\n          // Reset the in-progress update but only if the language wasn't\n          // changed (since we don't want to clobber a new request).\n          if (\n            this.inProgressUpdates[series] &&\n            this.inProgressUpdates[series]!.lang === lang\n          ) {\n            this.inProgressUpdates[series] = undefined;\n          }\n          this.notifyChanged('stateupdated');\n        }),\n    };\n\n    return updatePromise;\n  }\n\n  private async doUpdate({\n    series,\n    signal,\n    lang: requestedLang,\n  }: {\n    series: DataSeries;\n    signal: AbortSignal;\n    lang: string;\n  }) {\n    let wroteSomething = false;\n\n    const reducer = (action: UpdateAction) => {\n      this[series].updateState = updateReducer(\n        this[series].updateState,\n        action\n      );\n\n      if (action.type === 'fileend') {\n        wroteSomething = true;\n        this.updateDataVersion(series, action.version);\n      }\n\n      if (action.type === 'parseerror' && this.verbose) {\n        console.warn('Encountered parse error', action.message, action.record);\n      }\n\n      this.notifyChanged('stateupdated');\n    };\n\n    // Check if we have been canceled while waiting to become ready\n    if (signal.aborted) {\n      reducer({ type: 'error', checkDate: null });\n      throw new AbortError();\n    }\n\n    const checkDate = new Date();\n\n    try {\n      reducer({ type: 'start', series });\n\n      // Check if the requested language is available for this series, and\n      // fallback to English if not.\n      const lang =\n        requestedLang !== 'en' &&\n        (await hasLanguage({\n          series,\n          lang: requestedLang,\n          majorVersion: MAJOR_VERSION[series],\n          signal,\n        }))\n          ? requestedLang\n          : 'en';\n\n      // If the language we have stored (if any) differs from the language we\n      // are about to update to, clobber the existing data for this series.\n      const currentLang: string | undefined =\n        this[series].state === 'ok' ? this[series].version?.lang : undefined;\n      if (currentLang && currentLang !== lang) {\n        if (this.verbose) {\n          console.info(\n            `Clobbering '${series}' data to change lang to '${lang}'`\n          );\n        }\n        await this.store.clearSeries(series);\n        this.updateDataVersion(series, null);\n      }\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      if (this.verbose) {\n        console.info(\n          `Requesting download for '${series}' series with current version ${JSON.stringify(\n            this[series].version || undefined\n          )}`\n        );\n      }\n\n      await update({\n        callback: reducer,\n        currentVersion: this[series].version || undefined,\n        lang,\n        majorVersion: MAJOR_VERSION[series],\n        signal,\n        series,\n        store: this.store,\n      });\n\n      if (signal.aborted) {\n        throw new AbortError();\n      }\n\n      reducer({ type: 'end', checkDate });\n    } catch (e) {\n      // We should only update the last-check date if we actually made some\n      // sort of update.\n      reducer({\n        type: 'error',\n        checkDate: wroteSomething ? checkDate : null,\n      });\n      throw e;\n    }\n  }\n\n  private updateDataVersion(series: DataSeries, version: DataVersion | null) {\n    if (\n      this[series].state !== 'init' &&\n      this[series].state !== 'unavailable' &&\n      jsonEqualish(this[series].version, version)\n    ) {\n      return;\n    }\n\n    this[series].version = version;\n    this[series].state = version ? 'ok' : 'empty';\n\n    this.notifyChanged('stateupdated');\n  }\n\n  cancelUpdate(series: MajorDataSeries): boolean {\n    const inProgressUpdate = this.inProgressUpdates[series];\n    if (!inProgressUpdate) {\n      return false;\n    }\n\n    inProgressUpdate.controller.abort();\n\n    return true;\n  }\n\n  // -------------------------------------------------------------------------\n  //\n  // Misc\n  //\n  // -------------------------------------------------------------------------\n\n  get isVerbose() {\n    return this.verbose;\n  }\n}\n","export class OfflineError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, OfflineError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, OfflineError);\n    }\n\n    this.name = 'OfflineError';\n  }\n}\n","export type WordRecord = {\n  id: number;\n\n  // Kanji readings for the entry\n  k?: Array<string>;\n  km?: Array<null | KanjiMeta>;\n\n  // Kana readings for the entry\n  r: Array<string>;\n  rm?: Array<null | ReadingMeta>;\n\n  // Sense information\n  s: Array<WordSense>;\n};\n\nexport type KanjiMeta = {\n  // Information about a kanji headword\n  //\n  // Typically this should be of type KanjiInfo but we allow it to be any string\n  // in case new types are introduced in future and the client has yet to be\n  // updated.\n  i?: Array<string>;\n\n  // Priority information\n  p?: Array<string>;\n\n  // Bunpro vocab fuzzy match source text\n  bv?: string;\n\n  // Bunpro grammar fuzzy match source text\n  bg?: string;\n};\n\nexport type ReadingMeta = {\n  // Information about the reading\n  //\n  // Typically this should be of type ReadingInfo but we allow it to be any\n  // string in case new types are introduced in future and the client has yet to\n  // be updated.\n  i?: Array<string>;\n\n  // Priority information\n  p?: Array<string>;\n\n  // Bitfield representing which kanji entries (based on their order in the k\n  // array) the reading applies to. 0 means it applies to none of them. If the\n  // field is absent, it means the reading applies to all of the kanji entries.\n  app?: number;\n\n  // Pitch accent information.\n  a?: number | Array<Accent>;\n\n  // Bunpro vocab fuzzy match source text\n  bv?: string;\n\n  // Bunpro grammar fuzzy match source text\n  bg?: string;\n};\n\nexport type Accent = {\n  // Syllable number of the accent (after which the drop occurs).\n  // 0 = \n  i: number;\n\n  // This should typically be a PartOfSpeech value.\n  pos?: Array<string>;\n};\n\nexport type WordSense = {\n  g: Array<string>;\n  // A bitfield representing the type of the glosses in `g`. Two bits are used\n  // to represent the type of each item in `g`, where each two-bit value is one\n  // of the GlossType values below.\n  //\n  // Undefined if the value is 0 (i.e. no glosses have a type, the most common\n  // case).\n  gt?: number;\n  // undefined = 'en'\n  lang?: string;\n\n  // Bit field representing the kanji / kana entries this sense applies to.\n  // If the sense applies to all entries the field will be undefined.\n  kapp?: number;\n  rapp?: number;\n\n  // Extra information about the sense.\n\n  // Typically a PartOfSpeech value\n  pos?: Array<string>;\n  // Typically a FieldType value\n  field?: Array<string>;\n  // Typically a MiscType value\n  misc?: Array<string>;\n  // Typically a Dialect value\n  dial?: Array<string>;\n  inf?: string;\n  xref?: Array<CrossReference>;\n  ant?: Array<CrossReference>;\n\n  // Language source information.\n  lsrc?: Array<LangSource>;\n};\n\nexport const GlossTypes = ['none', 'expl', 'lit', 'fig', 'tm'] as const;\nexport type GlossType = (typeof GlossTypes)[number];\nexport const GLOSS_TYPE_MAX = GlossTypes.length;\nexport const BITS_PER_GLOSS_TYPE = Math.floor(Math.log2(GLOSS_TYPE_MAX)) + 1;\n\nexport type CrossReference =\n  | {\n      k: string;\n      sense?: number;\n    }\n  | {\n      r: string;\n      sense?: number;\n    }\n  | {\n      k: string;\n      r: string;\n      sense?: number;\n    };\n\nexport type LangSource = {\n  // undefined = 'en'\n  lang?: string;\n\n  // The term in the source language\n  //\n  // This may be empty in some cases.\n  src?: string;\n\n  // Partial source (i.e. this only represents part of the string)\n  // absent = false\n  part?: true;\n\n  // The Japanese word is made from words from another language but doesn't\n  // actually represent the meaning of those words literally.\n  wasei?: true;\n};\n\n// ----------------------------------------------------------------------------\n//\n// Supplemental types that may be used to further refine the fields above\n//\n// ----------------------------------------------------------------------------\n\n// KanjiInfo\n\nexport type KanjiInfo = (typeof kanjiInfoValues)[number];\n\nconst kanjiInfoValues = [\n  // ateji (phonetic) reading\n  'ateji',\n  // irregular okurigana usage\n  'io',\n  // word containing irregular kanji usage\n  'iK',\n  // word containing irregular kana usage\n  'ik',\n  // word containing out-dated kanji or kanji usage\n  'oK',\n  // rarely-used kanji form\n  'rK',\n  // search-only kanji form\n  'sK',\n] as const;\n\nexport function isKanjiInfo(a: unknown): a is KanjiInfo {\n  return typeof a === 'string' && kanjiInfoValues.includes(a as KanjiInfo);\n}\n\nexport function asKanjiInfo(a: unknown): KanjiInfo | undefined {\n  return isKanjiInfo(a) ? a : undefined;\n}\n\n// ReadingInfo\n\nexport type ReadingInfo = (typeof allReadingInfo)[number];\n\nconst allReadingInfo = [\n  // gikun (meaning as reading) or jukujikun (special kanji reading)\n  'gikun',\n  // word containing irregular kana usage\n  'ik',\n  // out-dated or obsolete kana usage\n  'ok',\n  // rarely-used kana form\n  'rk',\n  // search-only kana form\n  'sk',\n] as const;\n\nexport function isReadingInfo(a: unknown): a is ReadingInfo {\n  return typeof a === 'string' && allReadingInfo.includes(a as ReadingInfo);\n}\n\nexport function asReadingInfo(a: unknown): ReadingInfo | undefined {\n  return isReadingInfo(a) ? a : undefined;\n}\n\n// Part of speech\n\nexport type PartOfSpeech = (typeof allPartsOfSpeech)[number];\n\n// prettier-ignore\nconst allPartsOfSpeech = [\n  'adj-f', 'adj-i', 'adj-ix', 'adj-kari', 'adj-ku', 'adj-na', 'adj-nari',\n  'adj-no', 'adj-pn', 'adj-shiku', 'adj-t', 'adv', 'adv-to', 'aux', 'aux-adj',\n  'aux-v', 'conj', 'cop', 'ctr', 'exp', 'int', 'n', 'n-adv', 'n-pr', 'n-pref',\n  'n-suf', 'n-t', 'num', 'pn', 'pref', 'prt', 'suf', 'unc', 'v-unspec', 'v1',\n  'v1-s', 'v2a-s', 'v2b-k', 'v2b-s', 'v2d-k', 'v2d-s', 'v2g-k', 'v2g-s',\n  'v2h-k', 'v2h-s', 'v2k-k', 'v2k-s', 'v2m-k', 'v2m-s', 'v2n-s', 'v2r-k',\n  'v2r-s', 'v2s-s', 'v2t-k', 'v2t-s', 'v2w-s', 'v2y-k', 'v2y-s', 'v2z-s', 'v4b',\n  'v4g', 'v4h', 'v4k', 'v4m', 'v4n', 'v4r', 'v4s', 'v4t', 'v5aru', 'v5b', 'v5g',\n  'v5k', 'v5k-s', 'v5m', 'v5n', 'v5r', 'v5r-i', 'v5s', 'v5t', 'v5u', 'v5u-s',\n  'v5uru', 'vi', 'vk', 'vn', 'vr', 'vs', 'vs-c', 'vs-i', 'vs-s', 'vt', 'vz',\n] as const;\n\nexport function isPartOfSpeech(a: unknown): a is PartOfSpeech {\n  return typeof a === 'string' && allPartsOfSpeech.includes(a as PartOfSpeech);\n}\n\nexport function asPartOfSpeech(a: unknown): PartOfSpeech | undefined {\n  return isPartOfSpeech(a) ? a : undefined;\n}\n\n// Field\n\nexport type FieldType = (typeof allFieldTypes)[number];\n\n// prettier-ignore\nconst allFieldTypes = [\n  'agric', 'anat', 'archeol', 'archit', 'art', 'astron', 'audvid', 'aviat',\n  'baseb', 'biochem', 'biol', 'bot', 'boxing', 'Buddh', 'bus', 'cards', 'chem',\n  'chmyth', 'Christn', 'civeng', 'cloth', 'comp', 'cryst', 'dent', 'ecol',\n  'econ', 'elec', 'electr', 'embryo', 'engr', 'ent', 'figskt', 'film', 'finc',\n  'fish', 'food', 'gardn', 'genet', 'geogr', 'geol', 'geom', 'go', 'golf',\n  'gramm', 'grmyth', 'hanaf', 'horse', 'internet', 'jpmyth', 'kabuki', 'law',\n  'ling', 'logic', 'MA', 'mahj', 'manga', 'math', 'mech', 'med', 'met', 'mil',\n  'min', 'mining', 'motor', 'music', 'noh', 'ornith', 'paleo', 'pathol',\n  'pharm', 'phil', 'photo', 'physics', 'physiol', 'politics', 'print',\n  'prowres', 'psy', 'psyanal', 'psych', 'rail', 'rommyth', 'Shinto', 'shogi',\n  'ski', 'sports', 'stat', 'stockm', 'sumo', 'surg', 'telec', 'tradem', 'tv',\n  'vet', 'vidg', 'zool',\n] as const;\n\nexport function isFieldType(a: unknown): a is FieldType {\n  return typeof a === 'string' && allFieldTypes.includes(a as FieldType);\n}\n\nexport function asFieldType(a: unknown): FieldType | undefined {\n  return isFieldType(a) ? a : undefined;\n}\n\n// Misc types. A few of these are not used (e.g. male-sl, uK) but they have\n// entity definitions in the upstream XML file so we include them here.\n\nexport type MiscType = (typeof allMiscTypes)[number];\n\n// prettier-ignore\nconst allMiscTypes = [\n  'abbr', 'aphorism', 'arch', 'char', 'chn', 'col', 'company', 'creat', 'dated',\n  'dei', 'derog', 'doc', 'ev', 'euph', 'fam', 'fem', 'fict', 'form', 'given',\n  'group', 'hist', 'hon', 'hum', 'id', 'joc', 'leg', 'm-sl', 'male', 'myth',\n  'net-sl', 'obj', 'obs', 'obsc', 'on-mim', 'organization', 'oth', 'person',\n  'place', 'poet', 'pol', 'product', 'proverb', 'quote', 'rare', 'relig',\n  'sens', 'serv', 'ship', 'sl', 'station', 'surname', 'uk', 'unclass', 'vulg',\n  'work', 'X', 'yoji',\n] as const;\n\nexport function isMiscType(a: unknown): a is MiscType {\n  return typeof a === 'string' && allMiscTypes.includes(a as MiscType);\n}\n\nexport function asMiscType(a: unknown): MiscType | undefined {\n  return isMiscType(a) ? a : undefined;\n}\n\n// Dialects\n\nexport type Dialect = (typeof allDialects)[number];\n\nconst allDialects = [\n  'bra', // Brazilian\n  'ho', // Hokkaido\n  'tsug', // Tsugaru\n  'th', // Tohoku\n  'na', // Nagano\n  'kt', // Kanto\n  'ks', // Kansai\n  'ky', // Kyoto\n  'os', // Osaka\n  'ts', // Tosa\n  '9s', // Kyushu\n  'ok', // Ryuukyuu\n] as const;\n\nexport function isDialect(a: unknown): a is Dialect {\n  return typeof a === 'string' && allDialects.includes(a as Dialect);\n}\n\nexport function asDialect(a: unknown): Dialect | undefined {\n  return isDialect(a) ? a : undefined;\n}\n","import { kanaToHiragana } from '@birchill/normal-jp';\n\nimport {\n  ExtendedKanaEntry,\n  ExtendedKanjiEntry,\n  ExtendedSense,\n  Gloss,\n  WordResult,\n} from './result-types';\nimport { WordStoreRecord } from './store-types';\nimport { stripFields } from './utils';\nimport {\n  BITS_PER_GLOSS_TYPE,\n  CrossReference,\n  GlossType,\n  GlossTypes,\n  KanjiMeta,\n  ReadingMeta,\n  WordRecord,\n  WordSense,\n} from './words';\n\nexport type MatchMode =\n  | 'lexeme'\n  | 'kana-equivalent'\n  | 'starts-with'\n  | 'starts-with-kana-equivalent'\n  | 'kanji';\n\nexport function toWordResult(\n  record: WordStoreRecord,\n  search: string | CrossReference,\n  matchMode: MatchMode\n): WordResult {\n  let kanjiMatches,\n    kanjiMatchRanges,\n    kanaMatches,\n    kanaMatchRanges,\n    senseMatches;\n  if (typeof search !== 'string') {\n    [\n      kanjiMatches,\n      kanjiMatchRanges,\n      kanaMatches,\n      kanaMatchRanges,\n      senseMatches,\n    ] = getMatchMetadataForCrossRefLookup(record, search, matchMode);\n  } else {\n    [\n      kanjiMatches,\n      kanjiMatchRanges,\n      kanaMatches,\n      kanaMatchRanges,\n      senseMatches,\n    ] = getMatchMetadata(record, search, matchMode);\n  }\n\n  return makeWordResult(\n    record,\n    kanjiMatches,\n    kanjiMatchRanges,\n    kanaMatches,\n    kanaMatchRanges,\n    senseMatches,\n    []\n  );\n}\n\ntype MatchedSenseAndGlossRange = [\n  sense: number,\n  gloss: number,\n  start: number,\n  end: number,\n];\n\nexport function toWordResultFromGlossLookup(\n  record: WordStoreRecord,\n  matchedRanges: Array<MatchedSenseAndGlossRange>\n): WordResult {\n  const [kanjiMatches, kanaMatches, senseMatches] =\n    getMatchMetadataForGlossLookup(record, matchedRanges);\n\n  return makeWordResult(\n    record,\n    kanjiMatches,\n    [],\n    kanaMatches,\n    [],\n    senseMatches,\n    matchedRanges\n  );\n}\n\n// ---------------------------------------------------------------------------\n//\n// Helpers\n//\n// ---------------------------------------------------------------------------\n\ntype MatchedHeadwordRange = [index: number, start: number, end: number];\n\nfunction makeWordResult(\n  record: WordRecord,\n  kanjiMatches: number,\n  kanjiMatchRanges: Array<MatchedHeadwordRange>,\n  kanaMatches: number,\n  kanaMatchRanges: Array<MatchedHeadwordRange>,\n  senseMatches: number,\n  matchedGlossRanges: Array<MatchedSenseAndGlossRange>\n) {\n  return {\n    id: record.id,\n    k: mergeMeta(\n      record.k,\n      record.km,\n      kanjiMatches,\n      kanjiMatchRanges,\n      (key, match, matchRange, meta) => {\n        const result: ExtendedKanjiEntry = {\n          ent: key,\n          ...(meta ? stripFields(meta, ['bv', 'bg']) : undefined),\n          match,\n        };\n\n        // WaniKani levels are stored in the `p` (priority) field for simplicity\n        // in the form `wk{N}` where N is the level number.\n        //\n        // We need to extract any such levels and store them in the `wk` field.\n        //\n        // Likewise for Bunpro levels which need to be combined with an `bv` /\n        // `bg` fields since these contain the original source text for a fuzzy\n        // match.\n        let wk: number | undefined;\n        let bv: number | undefined;\n        let bg: number | undefined;\n\n        const p = meta?.p?.filter((p) => {\n          if (/^wk\\d+$/.test(p)) {\n            const wkLevel = parseInt(p.slice(2), 10);\n            if (typeof wk === 'undefined' || wkLevel < wk) {\n              wk = wkLevel;\n            }\n            return false;\n          }\n\n          if (/^bv\\d+$/.test(p)) {\n            const bvLevel = parseInt(p.slice(2), 10);\n            if (typeof bv === 'undefined' || bvLevel < bv) {\n              bv = bvLevel;\n            }\n            return false;\n          }\n\n          if (/^bg\\d+$/.test(p)) {\n            const bgLevel = parseInt(p.slice(2), 10);\n            if (typeof bg === 'undefined' || bgLevel < bg) {\n              bg = bgLevel;\n            }\n            return false;\n          }\n\n          return true;\n        });\n\n        if (p?.length) {\n          result.p = p;\n        } else {\n          delete result.p;\n        }\n\n        if (wk) {\n          result.wk = wk;\n        }\n\n        if (typeof bv === 'number') {\n          result.bv = Object.assign(\n            { l: bv },\n            meta?.bv ? { src: meta?.bv } : undefined\n          );\n        }\n\n        if (typeof bg === 'number') {\n          result.bg = Object.assign(\n            { l: bg },\n            meta?.bg ? { src: meta?.bg } : undefined\n          );\n        }\n\n        if (matchRange) {\n          result.matchRange = matchRange;\n        }\n        return result;\n      }\n    ),\n    r: mergeMeta(\n      record.r,\n      record.rm,\n      kanaMatches,\n      kanaMatchRanges,\n      (key, match, matchRange, meta) => {\n        const result: ExtendedKanaEntry = {\n          ent: key,\n          ...(meta ? stripFields(meta, ['bv', 'bg']) : undefined),\n          match,\n        };\n\n        let bv: number | undefined;\n        let bg: number | undefined;\n\n        const p = meta?.p?.filter((p) => {\n          if (/^bv\\d+$/.test(p)) {\n            const bvLevel = parseInt(p.slice(2), 10);\n            if (typeof bv === 'undefined' || bvLevel < bv) {\n              bv = bvLevel;\n            }\n            return false;\n          }\n\n          if (/^bg\\d+$/.test(p)) {\n            const bgLevel = parseInt(p.slice(2), 10);\n            if (typeof bg === 'undefined' || bgLevel < bg) {\n              bg = bgLevel;\n            }\n            return false;\n          }\n\n          return true;\n        });\n\n        if (p?.length) {\n          result.p = p;\n        } else {\n          delete result.p;\n        }\n\n        if (typeof bv === 'number') {\n          result.bv = Object.assign(\n            { l: bv },\n            meta?.bv ? { src: meta?.bv } : undefined\n          );\n        }\n\n        if (typeof bg === 'number') {\n          result.bg = Object.assign(\n            { l: bg },\n            meta?.bg ? { src: meta?.bg } : undefined\n          );\n        }\n\n        if (matchRange) {\n          result.matchRange = matchRange;\n        }\n        return result;\n      }\n    ),\n    s: expandSenses(record.s, senseMatches, matchedGlossRanges),\n  };\n}\n\nfunction getMatchMetadata(\n  record: WordStoreRecord,\n  search: string,\n  matchMode: MatchMode\n): [\n  kanjiMatches: number,\n  kanjiMatchRanges: Array<MatchedHeadwordRange>,\n  kanaMatches: number,\n  kanaMatchRanges: Array<MatchedHeadwordRange>,\n  senseMatches: number,\n] {\n  // There are three cases:\n  //\n  // 1) We matched on a kanji entry\n  //\n  //    -- All k entries that exactly match `search` should match.\n  //    -- All r entries that apply to the k entry should match.\n  //       (i.e. no app field or one that matches).\n  //    -- All s entries that:\n  //       -- Have a kapp field, and it matches, should match.\n  //       -- Have only a rapp field, and the corresponding r entry matches,\n  //          should match.\n  //       -- Have no kapp or rapp field should match.\n  //       UNLESS the the k entries matched on \"sK\" (search-only kanji) in which\n  //       case we should include all senses.\n  //\n  // 2) We matched on a reading (kana) entry\n  //\n  //    -- All r entries that exactly match `search` should match.\n  //    -- All k entries to which the matching r entries apply should match.\n  //    -- All s entries that:\n  //       -- Have a rapp field, and the corresponding r entry matches,\n  //          should match.\n  //       -- Have a kapp field, and the corresponding k entry matches,\n  //          should match.\n  //       -- Have no rapp or kapp field should match.\n  //       UNLESS the the r entries matched on \"sk\" (search-only kana) in which\n  //       case we should include all senses.\n  //\n  // 3) We matched on a hiragana index\n  //\n  //    -- As above trying (1) first then (2) using the hiragana-converted\n  //       term.\n  //\n  // Because of (3), we just always search both arrays.\n\n  // First build up a bitfield of all kanji matches.\n  const matcher: (str: string) => boolean = (str) => {\n    switch (matchMode) {\n      case 'lexeme':\n        return str === search;\n      case 'kana-equivalent':\n        return kanaToHiragana(str) === search;\n      case 'starts-with':\n        return str.startsWith(search);\n      case 'starts-with-kana-equivalent':\n        return kanaToHiragana(str).startsWith(search);\n      case 'kanji':\n        return [...str].includes(search);\n    }\n  };\n  let kanjiMatches = arrayToBitfield(record.k || [], matcher);\n\n  // Fill out any match information\n  const kanjiMatchRanges: Array<MatchedHeadwordRange> = [];\n  let searchOnlyHeadwordMatch = false;\n  for (let i = 0; i < (record.k?.length || 0); i++) {\n    if (kanjiMatches & (1 << i)) {\n      switch (matchMode) {\n        case 'lexeme':\n        case 'kana-equivalent':\n        case 'starts-with':\n        case 'starts-with-kana-equivalent':\n          kanjiMatchRanges.push([i, 0, search.length]);\n          break;\n\n        case 'kanji':\n          {\n            const index = [...record.k![i]].indexOf(search);\n            kanjiMatchRanges.push([i, index, index + 1]);\n          }\n          break;\n      }\n      searchOnlyHeadwordMatch ||= !!record.km?.[i]?.i?.includes('sK');\n    }\n  }\n\n  let kanaMatches = 0;\n  let senseMatches = 0;\n  const kanaMatchRanges: Array<MatchedHeadwordRange> = [];\n  if (kanjiMatches) {\n    // Case (1) from above: Find corresponding kana matches\n    kanaMatches = kanaMatchesForKanji(record, kanjiMatches);\n    senseMatches = arrayToBitfield(record.s, (sense) => {\n      if (searchOnlyHeadwordMatch) {\n        return true;\n      }\n\n      if (typeof sense.kapp !== 'undefined') {\n        return !!(sense.kapp & kanjiMatches);\n      } else if (typeof sense.rapp !== 'undefined') {\n        return !!(sense.rapp & kanaMatches);\n      } else {\n        return true;\n      }\n    });\n  } else if (\n    matchMode === 'lexeme' ||\n    matchMode === 'kana-equivalent' ||\n    matchMode === 'starts-with' ||\n    matchMode === 'starts-with-kana-equivalent'\n  ) {\n    // Case (2) from above: Find kana matches and the kanji they apply to.\n    kanaMatches = arrayToBitfield(record.r, matcher);\n    kanjiMatches = kanjiMatchesForKana(record, kanaMatches);\n\n    // Fill out kana match range information\n    for (let i = 0; i < record.r.length; i++) {\n      if (kanaMatches & (1 << i)) {\n        kanaMatchRanges.push([i, 0, search.length]);\n        searchOnlyHeadwordMatch ||= !!record.rm?.[i]?.i?.includes('sk');\n      }\n    }\n\n    senseMatches = arrayToBitfield(record.s, (sense) => {\n      if (searchOnlyHeadwordMatch) {\n        return true;\n      }\n\n      if (typeof sense.rapp !== 'undefined') {\n        return !!(sense.rapp & kanaMatches);\n      } else if (typeof sense.kapp !== 'undefined') {\n        return !!(sense.kapp & kanjiMatches);\n      } else {\n        return true;\n      }\n    });\n  }\n\n  return [\n    kanjiMatches,\n    kanjiMatchRanges,\n    kanaMatches,\n    kanaMatchRanges,\n    senseMatches,\n  ];\n}\n\nfunction getMatchMetadataForCrossRefLookup(\n  record: WordStoreRecord,\n  xref: CrossReference,\n  matchMode: MatchMode\n): [\n  kanjiMatches: number,\n  kanjiMatchRanges: Array<MatchedHeadwordRange>,\n  kanaMatches: number,\n  kanaMatchRanges: Array<MatchedHeadwordRange>,\n  senseMatches: number,\n] {\n  let kanjiMatches = 0;\n  let kanjiMatchRanges: Array<MatchedHeadwordRange> = [];\n  let kanaMatches = 0;\n  let kanaMatchRanges: Array<MatchedHeadwordRange> = [];\n  let senseMatches = 0;\n\n  const xRefK = (xref as any).k as string | undefined;\n  const xRefR = (xref as any).r as string | undefined;\n\n  if (xRefK && xRefR) {\n    // Fill out kanji match information\n    kanjiMatches = arrayToBitfield(record.k || [], (k) => k === xRefK);\n    for (let i = 0; i < (record.k?.length || 0); i++) {\n      if (kanjiMatches & (1 << i)) {\n        kanjiMatchRanges.push([i, 0, xRefK.length]);\n      }\n    }\n\n    // Fill out reading match information\n    kanaMatches = arrayToBitfield(record.r, (r) => r === xRefR);\n    for (let i = 0; i < record.r.length; i++) {\n      if (kanaMatches & (1 << i)) {\n        kanaMatchRanges.push([i, 0, xRefR.length]);\n      }\n    }\n\n    // Fill out sense information, although we may end up overwriting this\n    // below.\n    senseMatches = arrayToBitfield(record.s, (sense) => {\n      if (typeof sense.kapp !== 'undefined') {\n        return !!(sense.kapp & kanjiMatches);\n      } else if (typeof sense.rapp !== 'undefined') {\n        return !!(sense.rapp & kanaMatches);\n      } else {\n        return true;\n      }\n    });\n  } else {\n    [\n      kanjiMatches,\n      kanjiMatchRanges,\n      kanaMatches,\n      kanaMatchRanges,\n      senseMatches,\n    ] = getMatchMetadata(record, (xRefK || xRefR)!, matchMode);\n  }\n\n  if (xref.sense) {\n    senseMatches = 1 << (xref.sense - 1);\n  }\n\n  return [\n    kanjiMatches,\n    kanjiMatchRanges,\n    kanaMatches,\n    kanaMatchRanges,\n    senseMatches,\n  ];\n}\n\nfunction getMatchMetadataForGlossLookup(\n  record: WordStoreRecord,\n  matchedRanges: Array<MatchedSenseAndGlossRange>\n): [kanjiMatches: number, kanaMatches: number, senseMatches: number] {\n  const senseMatches = matchedRanges\n    .map(([sense]) => sense)\n    .reduce((value, senseIndex) => value | (1 << senseIndex), 0);\n\n  // Work out which kanji and readings also match\n  let kanjiMatches = 0;\n  let kanaMatches = 0;\n\n  const kanjiWildCard = (1 << (record.k || []).length) - 1;\n  const kanaWildCard = (1 << (record.r || []).length) - 1;\n\n  for (const [i, sense] of record.s.entries()) {\n    if (!(senseMatches & (1 << i))) {\n      continue;\n    }\n\n    if (\n      typeof sense.kapp !== 'undefined' &&\n      typeof sense.rapp !== 'undefined'\n    ) {\n      kanjiMatches |= sense.kapp;\n      kanaMatches |= sense.rapp;\n    } else if (typeof sense.kapp !== 'undefined') {\n      kanjiMatches |= sense.kapp;\n      kanaMatches |= kanaMatchesForKanji(record, kanjiMatches);\n    } else if (typeof sense.rapp !== 'undefined') {\n      kanaMatches |= sense.rapp;\n      kanjiMatches = kanjiMatchesForKana(record, kanaMatches);\n    } else {\n      kanjiMatches = kanjiWildCard;\n      kanaMatches = kanaWildCard;\n      break;\n    }\n  }\n\n  return [kanjiMatches, kanaMatches, senseMatches];\n}\n\nfunction kanaMatchesForKanji(\n  record: WordStoreRecord,\n  kanjiMatches: number\n): number {\n  const kanaIsMatch = (rm: ReadingMeta | null) =>\n    !rm || typeof rm.app === 'undefined' || !!(rm.app & kanjiMatches);\n\n  return arrayToBitfield(\n    // We need to extend the rm array with nulls so that any readings without\n    // meta fields are treated as applying to all kanji.\n    extendWithNulls(record.rm || [], record.r.length),\n    kanaIsMatch\n  );\n}\n\nfunction extendWithNulls<T>(\n  arr: Array<T | null>,\n  len: number\n): Array<T | null> {\n  const extra = Math.max(len - arr.length, 0);\n  return arr.concat(Array(extra).fill(null));\n}\n\nfunction kanjiMatchesForKana(\n  record: WordStoreRecord,\n  kanaMatches: number\n): number {\n  const wildCardMatch = (1 << (record.k || []).length) - 1;\n  const matchingKanjiAtIndex = (i: number): number => {\n    if (!record.rm || record.rm.length < i + 1 || record.rm[i] === null) {\n      return wildCardMatch;\n    }\n\n    return record.rm[i]!.app ?? wildCardMatch;\n  };\n\n  let matches = 0;\n  for (let i = 0; i < record.r.length; i++) {\n    matches |= kanaMatches & (1 << i) ? matchingKanjiAtIndex(i) : 0;\n  }\n  return matches;\n}\n\nfunction arrayToBitfield<T>(arr: Array<T>, test: (elem: T) => boolean): number {\n  return arr.reduce(\n    (value, elem, i) => (test(elem) ? value | (1 << i) : value),\n    0\n  );\n}\n\nfunction mergeMeta<MetaType extends KanjiMeta | ReadingMeta, MergedType>(\n  keys: Array<string> | undefined,\n  metaArray: Array<null | MetaType> | undefined,\n  matches: number,\n  matchRanges: Array<MatchedHeadwordRange>,\n  merge: (\n    key: string,\n    match: boolean,\n    matchRange?: [start: number, end: number] | undefined,\n    meta?: MetaType\n  ) => MergedType\n): Array<MergedType> {\n  const result: Array<MergedType> = [];\n\n  for (const [i, key] of (keys || []).entries()) {\n    const match = !!(matches & (1 << i));\n    const meta =\n      metaArray && metaArray.length >= i + 1 && metaArray[i] !== null\n        ? metaArray[i]!\n        : undefined;\n    const matchRange = matchRanges.find((item) => item[0] === i)?.slice(1) as\n      | [number, number]\n      | undefined;\n    result.push(merge(key, match, matchRange, meta));\n  }\n\n  return result;\n}\n\nfunction expandSenses(\n  senses: Array<WordSense>,\n  senseMatches: number,\n  matchedGlossRanges: Array<MatchedSenseAndGlossRange>\n): Array<ExtendedSense> {\n  const getRangesForSense = (i: number): Array<MatchedRangeForGloss> =>\n    matchedGlossRanges\n      .filter(([senseIndex]) => senseIndex === i)\n      .map(([, gloss, start, end]) => [gloss, start, end]);\n\n  return senses.map((sense, i) => ({\n    g: expandGlosses(sense, getRangesForSense(i)),\n    ...stripFields(sense, ['g', 'gt']),\n    match: !!(senseMatches & (1 << i)),\n  }));\n}\n\ntype MatchedRangeForGloss = [gloss: number, start: number, end: number];\n\nfunction expandGlosses(\n  sense: WordSense,\n  matchedRanges: Array<MatchedRangeForGloss>\n): Array<Gloss> {\n  // Helpers to work out the gloss type\n  const gt = sense.gt || 0;\n  const typeMask = (1 << BITS_PER_GLOSS_TYPE) - 1;\n  const glossTypeAtIndex = (i: number): GlossType => {\n    return GlossTypes[(gt >> (i * BITS_PER_GLOSS_TYPE)) & typeMask];\n  };\n\n  return sense.g.map((gloss, i) => {\n    // This rather convoluted mess is because our test harness differentiates\n    // between properties that are not set and those that are set to\n    // undefined.\n    const result: Gloss = { str: gloss };\n\n    const type = glossTypeAtIndex(i);\n    if (type !== 'none') {\n      result.type = type;\n    }\n\n    let range: MatchedRangeForGloss | undefined;\n    while (matchedRanges.length && matchedRanges[0][0] <= i) {\n      range = matchedRanges.shift();\n    }\n    if (range) {\n      result.matchRange = range.slice(1) as [number, number];\n    }\n\n    return result;\n  });\n}\n","import type { ExtendedKanaEntry, WordResult } from './result-types';\n\n// As with Array.prototype.sort, sorts `results` in-place, but returns the\n// result to support chaining.\nexport function sortWordResults(\n  results: Array<WordResult>,\n  { searchLength }: { searchLength?: number } = {}\n): Array<WordResult> {\n  const sortMeta: Map<\n    number,\n    { excessChars: number | undefined; priority: number; type: number }\n  > = new Map();\n\n  for (const result of results) {\n    // Calculate the number of excess characters in the matching headword\n    const matchingHeadword =\n      result.k.find((k) => k.matchRange) || result.r.find((r) => r.matchRange);\n    const excessChars =\n      searchLength && matchingHeadword\n        ? matchingHeadword.ent.length - searchLength\n        : undefined;\n\n    // Determine the headword match type\n    //\n    // 1 = match on a kanji, or kana which is not just the reading for a kanji\n    // 2 = match on a kana reading for a kanji\n    //\n    // TODO: Don't bother doing this unless the input is all kana\n    const kanaReading = result.r.find((r) => !!r.matchRange);\n    const rt = kanaReading ? getKanaHeadwordType(kanaReading, result) : 1;\n\n    // Priority\n    const priority = getPriority(result);\n\n    sortMeta.set(result.id, { excessChars, priority, type: rt });\n  }\n\n  results.sort((a, b) => {\n    const metaA = sortMeta.get(a.id)!;\n    const metaB = sortMeta.get(b.id)!;\n\n    if (\n      metaA.excessChars !== undefined &&\n      metaB.excessChars !== undefined &&\n      metaA.excessChars !== metaB.excessChars\n    ) {\n      return metaA.excessChars - metaB.excessChars;\n    }\n\n    if (metaA.type !== metaB.type) {\n      return metaA.type - metaB.type;\n    }\n\n    return metaB.priority - metaA.priority;\n  });\n\n  return results;\n}\n\nfunction getKanaHeadwordType(r: ExtendedKanaEntry, result: WordResult): 1 | 2 {\n  // We don't want to prioritize readings marked as `ok` etc. or else we'll end\n  // up prioritizing words like `` and `` being prioritized when searching\n  // for ``.\n  const isReadingObscure =\n    r.i?.includes('ok') ||\n    r.i?.includes('rk') ||\n    r.i?.includes('sk') ||\n    r.i?.includes('ik');\n\n  if (isReadingObscure) {\n    return 2;\n  }\n\n  // Kana headwords are type 1 (i.e. they are a primary headword, not just a\n  // reading for a kanji headword) if:\n  //\n  // (a) the entry has no kanji headwords or all the kanji headwords are marked\n  //     as `rK`, `sK`, or `iK`.\n  if (\n    !result.k.length ||\n    result.k.every(\n      (k) => k.i?.includes('rK') || k.i?.includes('sK') || k.i?.includes('iK')\n    )\n  ) {\n    return 1;\n  }\n\n  // (b) most of the English senses for the entry have a `uk` (usually kana)\n  //     `misc` field and the reading is not marked as `ok` (old kana usage).\n  //\n  // We wanted to make the condition here be just one sense being marked as `uk`\n  // but then you get words like `` being prioritized when searching for ``\n  // because of one sense out of many being usually kana.\n  //\n  // Furthermore, we don't want to require _all_ senses to be marked as `uk` or\n  // else that will mean that  fails to be prioritized when searching for\n  // `` because one sense out of 11 is not marked as `uk`.\n  if (mostMatchedEnSensesAreUk(result.s)) {\n    return 1;\n  }\n\n  // (c) the headword is marked as `nokanji`\n  return r.app === 0 ? 1 : 2;\n}\n\nfunction mostMatchedEnSensesAreUk(senses: WordResult['s']): boolean {\n  const matchedEnSenses = senses.filter(\n    (s) => s.match && (s.lang === undefined || s.lang === 'en')\n  );\n  if (matchedEnSenses.length === 0) {\n    return false;\n  }\n\n  const ukEnSenseCount = matchedEnSenses.filter((s) =>\n    s.misc?.includes('uk')\n  ).length;\n  return ukEnSenseCount >= matchedEnSenses.length / 2;\n}\n\nexport function getPriority(result: WordResult): number {\n  // Go through each _matching_ kanji / reading and look for priority\n  // information and return the highest score.\n  const scores: Array<number> = [0];\n  const isHeadwordSearch =\n    result.k.some((k) => !!k.matchRange) ||\n    result.r.some((r) => !!r.matchRange);\n\n  // Scores from kanji readings\n  for (const k of result.k) {\n    if ((isHeadwordSearch ? !k.matchRange : !k.match) || !k.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(k.p));\n  }\n\n  // Scores from kana readings\n  for (const r of result.r) {\n    if ((isHeadwordSearch ? !r.matchRange : !r.match) || !r.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(r.p));\n  }\n\n  // Return top score\n  return Math.max(...scores);\n}\n\n// Produce an overall priority from a series of priority strings.\n//\n// This should produce a value somewhere in the range 0~67.\n//\n// In general we report the highest priority, but if we have several priority\n// scores we add a decreasing fraction (10%) of the lesser scores as an\n// indication that several sources have attested to the priority.\n//\n// That should typically produce a maximum attainable score of 66.8.\n// Having a bounded range like this makes it easier to combine this value with\n// other metrics when sorting.\nfunction getPrioritySum(priorities: Array<string>): number {\n  const scores = priorities.map(getPriorityScore).sort().reverse();\n  return scores.length\n    ? scores[0] +\n        scores\n          .slice(1)\n          .reduce(\n            (total, score, index) => total + score / Math.pow(10, index + 1),\n            0\n          )\n    : 0;\n}\n\n// This assignment is pretty arbitrary however it's mostly used for sorting\n// entries where all we need to do is distinguish between the really common ones\n// and the obscure academic ones.\n//\n// Entries with (P) are those ones that are marked with (P) in Edict.\nconst PRIORITY_ASSIGNMENTS: Map<string, number> = new Map([\n  ['i1', 50], // Top 10,000 words minus i2 (from 1998) (P)\n  ['i2', 20],\n  ['n1', 40], // Top 12,000 words in newspapers (from 2003?) (P)\n  ['n2', 20], // Next 12,000\n  ['s1', 32], // \"Speculative\" annotations? Seem pretty common to me. (P)\n  ['s2', 20], // (P)\n  ['g1', 30], // (P)\n  ['g2', 15],\n]);\n\nexport function getPriorityScore(p: string): number {\n  if (PRIORITY_ASSIGNMENTS.has(p)) {\n    return PRIORITY_ASSIGNMENTS.get(p)!;\n  }\n\n  if (p.startsWith('nf')) {\n    // The wordfreq scores are groups of 500 words.\n    // e.g. nf01 is the top 500 words, and nf48 is the 23,501 ~ 24,000\n    // most popular words.\n    const wordfreq = parseInt(p.substring(2), 10);\n    if (wordfreq > 0 && wordfreq < 48) {\n      return 48 - wordfreq / 2;\n    }\n  }\n\n  return 0;\n}\n","import { IDBPDatabase, IDBPTransaction, openDB, StoreNames } from 'idb';\nimport { kanaToHiragana } from '@birchill/normal-jp';\n\nimport { JpdictSchema } from './store';\nimport {\n  KanjiStoreRecord,\n  NameStoreRecord,\n  RadicalStoreRecord,\n  WordStoreRecord,\n} from './store-types';\nimport { getTokens } from './tokenizer';\nimport { stripFields } from './utils';\nimport {\n  MatchMode,\n  toWordResult,\n  toWordResultFromGlossLookup,\n} from './to-word-result';\nimport { getPriority, sortWordResults } from './word-result-sorting';\nimport { CrossReference } from './words';\nimport {\n  KanjiResult,\n  NameResult,\n  RelatedKanji,\n  WordResult,\n} from './result-types';\n\n// Database query methods\n//\n// This is in a separate file so that we can include just the query methods\n// in a separate worker / context and tree-shake out the rest of the module.\n//\n// Furthermore, these methods are careful not to read from the version table\n// since that can block when the database is being updated. Instead, these\n// methods are intended to be run on a separate thread to where the database\n// update methods are being run so that it is still possible for the user to\n// user the database while it is being updated.\n\n// -------------------------------------------------------------------------\n//\n// Opening\n//\n// -------------------------------------------------------------------------\n\nlet _state: 'idle' | 'opening' | 'open' = 'idle';\nlet _db: IDBPDatabase<JpdictSchema> | undefined;\nlet _openPromise: Promise<IDBPDatabase<JpdictSchema> | null> | undefined;\n\nfunction open(): Promise<IDBPDatabase<JpdictSchema> | null> {\n  if (_state === 'open') {\n    return Promise.resolve(_db!);\n  }\n\n  if (_state === 'opening') {\n    return _openPromise!;\n  }\n\n  _state = 'opening';\n\n  _openPromise = openDB<JpdictSchema>('jpdict', 4, {\n    upgrade(\n      _db: IDBPDatabase<JpdictSchema>,\n      _oldVersion: number,\n      _newVersion: number | null,\n      transaction: IDBPTransaction<\n        JpdictSchema,\n        StoreNames<JpdictSchema>[],\n        'versionchange'\n      >\n    ) {\n      // If the database does not exist, do not try to create it.\n      // If it is for an old version, do not try to use it.\n      transaction.abort();\n    },\n    blocked() {\n      console.log('Opening blocked');\n    },\n    blocking() {\n      if (_db) {\n        _db.close();\n        _db = undefined;\n        _state = 'idle';\n      }\n    },\n    terminated() {\n      _db = undefined;\n      _state = 'idle';\n    },\n  })\n    .then((db) => {\n      _db = db;\n      _state = 'open';\n      return db;\n    })\n    .catch(() => {\n      _state = 'idle';\n      _db = undefined;\n      return null;\n    })\n    .finally(() => {\n      _openPromise = undefined;\n    });\n\n  return _openPromise!;\n}\n\n// -------------------------------------------------------------------------\n//\n// Words\n//\n// -------------------------------------------------------------------------\n\nexport type MatchType = 'exact' | 'startsWith';\n\nexport async function getWords(\n  search: string,\n  options?: { matchType?: MatchType; limit: number }\n): Promise<Array<WordResult>> {\n  const db = await open();\n  if (!db) {\n    return [];\n  }\n\n  // Resolve match type and limit\n  const matchType = options?.matchType ?? 'exact';\n  const limit = options?.limit ?? Infinity;\n\n  // Normalize search string\n  const lookup = search.normalize();\n\n  // Set up our output value.\n  const addedRecords: Set<number> = new Set();\n  const results: Array<WordResult> = [];\n\n  const maybeAddRecord = (\n    record: WordStoreRecord,\n    term: string,\n    kanaMatching: 'exact' | 'kana-equivalent' = 'exact'\n  ) => {\n    if (addedRecords.has(record.id)) {\n      return;\n    }\n\n    let matchMode: MatchMode;\n    if (matchType === 'exact') {\n      matchMode = kanaMatching === 'exact' ? 'lexeme' : 'kana-equivalent';\n    } else {\n      matchMode =\n        kanaMatching === 'exact'\n          ? 'starts-with'\n          : 'starts-with-kana-equivalent';\n    }\n    results.push(toWordResult(record, term, matchMode));\n    addedRecords.add(record.id);\n  };\n\n  // Try the k (kanji) index first\n  const kanjiIndex = db!.transaction('words').store.index('k');\n  // (We explicitly use IDBKeyRange.only because otherwise the idb TS typings\n  // fail to recognize that these indices are multi-entry and hence it is\n  // valid to supply a single string instead of an array of strings.)\n  const key =\n    matchType === 'exact'\n      ? IDBKeyRange.only(lookup)\n      : IDBKeyRange.bound(lookup, lookup + '\\uFFFF');\n  for await (const cursor of kanjiIndex.iterate(key)) {\n    maybeAddRecord(cursor.value, lookup);\n  }\n\n  // Then the r (reading) index\n  const readingIndex = db!.transaction('words').store.index('r');\n  for await (const cursor of readingIndex.iterate(key)) {\n    maybeAddRecord(cursor.value, lookup);\n  }\n\n  // Then finally try converting to hiragana and using the hiragana index\n  {\n    const hiraganaIndex = db!.transaction('words').store.index('h');\n    const hiragana = kanaToHiragana(lookup);\n    const hiraganaKey =\n      matchType === 'exact'\n        ? IDBKeyRange.only(hiragana)\n        : IDBKeyRange.bound(hiragana, hiragana + '\\uFFFF');\n    for await (const cursor of hiraganaIndex.iterate(hiraganaKey)) {\n      maybeAddRecord(cursor.value, hiragana, 'kana-equivalent');\n    }\n  }\n\n  // Sort using the following arrangement:\n  //\n  // A) For exact searching, sorting by priority is enough.\n  //\n  // B) For prefix (\"starts with\") searching, we want to make sure exact\n  //    matches sort first so we penalize matches where the matched string\n  //    is longer than the search term.\n  //\n  let sortedResult: Array<WordResult>;\n  if (matchType === 'exact') {\n    sortedResult = sortWordResults(results);\n  } else {\n    sortedResult = sortWordResults(results, { searchLength: lookup.length });\n  }\n\n  if (limit) {\n    sortedResult.splice(limit);\n  }\n\n  return sortedResult;\n}\n\nexport async function getWordsByCrossReference(\n  xref: CrossReference\n): Promise<Array<WordResult>> {\n  const db = await open();\n  if (!db) {\n    return [];\n  }\n\n  // Normalize input\n  const k = (xref as any).k?.normalize();\n  const r = (xref as any).r?.normalize();\n\n  // Set up our output value.\n  const results: Array<WordResult> = [];\n\n  // Matches with a kanji key\n  if (k) {\n    const kanjiIndex = db!.transaction('words').store.index('k');\n    const key = IDBKeyRange.only(k);\n    for await (const cursor of kanjiIndex.iterate(key)) {\n      if (r && !cursor.value.r.includes(r)) {\n        continue;\n      }\n      results.push(toWordResult(cursor.value, xref, 'lexeme'));\n    }\n  } else {\n    const readingIndex = db!.transaction('words').store.index('r');\n    const key = IDBKeyRange.only(r);\n    for await (const cursor of readingIndex.iterate(key)) {\n      results.push(toWordResult(cursor.value, xref, 'lexeme'));\n    }\n  }\n\n  return sortWordResults(results);\n}\n\nexport async function getWordsWithKanji(\n  search: string\n): Promise<Array<WordResult>> {\n  const db = await open();\n  if (!db) {\n    return [];\n  }\n\n  // Check input. In future we may allow specifying a series of kanji and\n  // only returning words with all the kanji present, but we don't yet need\n  // that so for now just check we have a single character.\n  if ([...search].length !== 1) {\n    throw new Error(`Search string should be a single character: ${search}`);\n  }\n\n  // Normalize search string\n  const lookup = search.normalize();\n\n  // Set up our output value.\n  const results: Array<WordResult> = [];\n\n  const kanjiComponentIndex = db!.transaction('words').store.index('kc');\n  for await (const cursor of kanjiComponentIndex.iterate(\n    IDBKeyRange.only(lookup)\n  )) {\n    results.push(toWordResult(cursor.value, lookup, 'kanji'));\n  }\n\n  return sortWordResults(results);\n}\n\ntype GlossSearchResultMeta = {\n  // A value between 1 and 10.5 for how much of the gloss matched.\n  confidence: number;\n\n  // A number between 0 and 67 representing the priority of the result.\n  priority: number;\n\n  // Was this a match on a localized gloss, as opposed to falling back to an\n  // English gloss? We weight localized results more highly.\n  localizedMatch: boolean;\n};\n\ntype MatchedRange = [sense: number, gloss: number, start: number, end: number];\n\n// This currently only does substring phrase matching.\n//\n// Unlike a document search where you might want the search phrase\n// `twinkling eye` to match \"in the twinkling of an eye\", when you're looking up\n// a dictionary, you're typically more interested in finding an exact phrase.\n// So, for the example above, you might search for \"twinkling of\" and expect it\n// to match.\n//\n// Furthermore, since we are running locally, we can query as the user types\n// and so we should be able to return suggestions just for \"twink\" etc.\n// If we only return one result (or one particularly popular result?) an app\n// could even offer auto-complete in that case.\n//\n// We have the caller pass in the language since otherwise we would have to\n// look up the database version record which could cause us to block if the\n// database is being updated.\nexport async function getWordsWithGloss(\n  search: string,\n  lang: string,\n  limit?: number\n): Promise<Array<WordResult>> {\n  const db = await open();\n  if (!db) {\n    return [];\n  }\n\n  // Fetch at least 50 initial candidates. For common words we need at least\n  // 40 or 50 or else we'll possibly fail to include the best entries.\n  const numGlossCandidates = Math.max(limit || 0, 50);\n\n  // Set up our output value.\n  const resultMeta: Map<number, GlossSearchResultMeta> = new Map();\n  const results: Array<WordResult> = [];\n\n  // First search using the specified locale (if not English).\n  if (lang !== 'en') {\n    const records = await lookUpGlosses(db, search, lang, numGlossCandidates);\n    for (const [record, confidence, matchedRanges] of records) {\n      const result = toWordResultFromGlossLookup(record, matchedRanges);\n      const priority = getPriority(result);\n\n      results.push(result);\n      resultMeta.set(record.id, {\n        confidence,\n        priority,\n        localizedMatch: true,\n      });\n    }\n  }\n\n  // Look up English fallback glosses\n  //\n  // We do this even if we have enough candidates in results since the search\n  // might be on an English term.\n  {\n    const records = await lookUpGlosses(db, search, 'en', numGlossCandidates);\n    for (const [record, confidence, matchedRanges] of records) {\n      // If we already added this record as a localized match, skip it.\n      if (lang !== 'en' && resultMeta.has(record.id)) {\n        continue;\n      }\n\n      const result = toWordResultFromGlossLookup(record, matchedRanges);\n      const priority = getPriority(result);\n\n      results.push(result);\n      resultMeta.set(record.id, {\n        confidence,\n        priority,\n        localizedMatch: false,\n      });\n    }\n  }\n\n  // Sort using the following scoring:\n  //\n  // * Confidence value (value 0 to 10.5) scaled to a value from 0~105\n  // * Priority value in the range 0~67\n  // * Localized vs English fallback: +50 for a localized result\n  //\n  const recordScore = (id: number): number => {\n    const meta = resultMeta.get(id)!;\n    return (\n      meta.confidence * 10 + meta.priority + (meta.localizedMatch ? 50 : 0)\n    );\n  };\n  results.sort((a, b) => recordScore(b.id) - recordScore(a.id));\n\n  // Limit the results to the requested limit\n  const actualLimit = Math.max(limit || 0, 0) || 100;\n\n  return results.slice(0, actualLimit);\n}\n\nasync function lookUpGlosses(\n  db: IDBPDatabase<JpdictSchema>,\n  term: string,\n  locale: string,\n  limit: number\n): Promise<\n  Array<\n    [\n      record: WordStoreRecord,\n      confidence: number,\n      matchedRanges: Array<MatchedRange>,\n    ]\n  >\n> {\n  // Get search tokens\n  const tokens = getTokens(term.normalize(), locale);\n  if (!tokens || !tokens.length) {\n    return [];\n  }\n\n  // Prepare lowercase version of the term for later substring matching\n  const termLower = term.toLocaleLowerCase(locale);\n\n  // Prepare result\n  const result: Array<[WordStoreRecord, number, Array<MatchedRange>]> = [];\n\n  // Look for any records matching the first token in the appropriate index\n  const indexName = locale === 'en' ? 'gt_en' : 'gt_l';\n  const glossIndex = db!.transaction('words').store.index(indexName);\n  let hasFullMatchOnFirstToken = false;\n  for await (const cursor of glossIndex.iterate(\n    // Prefix match on first token\n    IDBKeyRange.bound(tokens[0], tokens[0] + '\\uFFFF')\n  )) {\n    const record = cursor.value;\n\n    // If we have multiple tokens and completely match the first token, we\n    // should not add any substring matches on that token.\n    //\n    // e.g. if we search on \"stand up\" and get a match on \"stand\" we should not\n    // add any results that match on \"standard\" etc. (but we should add such\n    // results if our search term was \"stand\" or \"stan\" or \"standa\" etc.).\n    const fullMatchOnFirstToken =\n      tokens.length > 1 && record[indexName].includes(tokens[0]);\n    if (!fullMatchOnFirstToken && hasFullMatchOnFirstToken) {\n      break;\n    }\n    hasFullMatchOnFirstToken = fullMatchOnFirstToken;\n\n    // Check if the record has a sense which a substring match on the original\n    // search term.\n    const matchedRanges: Array<MatchedRange> = [];\n    let confidence = 0;\n    for (const [senseIndex, sense] of record.s.entries()) {\n      // We need to skip these here, rather than filtering records, in order\n      // to maintain the original sense indices.\n      if ((sense.lang || 'en') !== locale) {\n        continue;\n      }\n\n      // Look for a substring match\n      for (const [glossIndex, gloss] of sense.g.entries()) {\n        const substringStart = gloss\n          .toLocaleLowerCase(locale)\n          .indexOf(termLower);\n        if (substringStart !== -1) {\n          matchedRanges.push([\n            senseIndex,\n            glossIndex,\n            substringStart,\n            substringStart + term.length,\n          ]);\n\n          // Calculate the confidence for this particular match as follows:\n          //\n          // 1) Percentage of string that matched converted to an integer\n          //    between 1 and 10\n          // 2) Extra 0.5 point if the start token of the search term and gloss\n          //    match.\n          const textConfidence = (term.length / gloss.length) * 10;\n          const tokenConfidence =\n            (tokens.length / getTokens(gloss, locale).length) * 10;\n          let thisConfidence = Math.round(\n            Math.max(textConfidence, tokenConfidence)\n          );\n          if (tokens[0] === record[indexName][0]) {\n            thisConfidence += 0.5;\n          }\n          confidence = Math.max(confidence, thisConfidence);\n        }\n      }\n\n      // Even if we found a match, we need to go through all senses because\n      // there could be multiple matches.\n    }\n\n    if (matchedRanges.length) {\n      result.push([record, confidence, matchedRanges]);\n    }\n\n    if (result.length >= limit) {\n      break;\n    }\n  }\n\n  return result;\n}\n\n// -------------------------------------------------------------------------\n//\n// Kanji\n//\n// -------------------------------------------------------------------------\n\nexport async function getKanji({\n  kanji,\n  lang,\n  logWarningMessage = console.log,\n}: {\n  kanji: Array<string>;\n  lang: string;\n  logWarningMessage?: (msg: string) => void;\n}): Promise<Array<KanjiResult>> {\n  const ids = kanji.map((kanji) => kanji.codePointAt(0)!);\n  const kanjiRecords: Array<KanjiStoreRecord> = await getKanjiById(ids);\n\n  const radicalResults = await getRadicalForKanji({\n    kanjiRecords,\n    lang,\n    logWarningMessage,\n  });\n  if (kanjiRecords.length !== radicalResults.length) {\n    throw new Error(\n      `There should be as many kanji records (${kanjiRecords.length}) as radical blocks (${radicalResults.length})`\n    );\n  }\n\n  const componentResults = await getComponentsForKanji({\n    kanjiRecords,\n    lang,\n    logWarningMessage,\n  });\n  if (kanjiRecords.length !== componentResults.length) {\n    throw new Error(\n      `There should be as many kanji records (${kanjiRecords.length}) as component arrays (${componentResults.length})`\n    );\n  }\n\n  const relatedResults = await getRelatedKanji(kanjiRecords, lang);\n  if (kanjiRecords.length !== relatedResults.length) {\n    throw new Error(\n      `There should be as many kanji records (${kanjiRecords.length}) as related kanji arrays (${relatedResults.length})`\n    );\n  }\n\n  // Zip the arrays together\n  return kanjiRecords.map<KanjiResult>((record, i) =>\n    stripFields(\n      {\n        ...record,\n        c: String.fromCodePoint(record.c),\n        m_lang: record.m_lang || lang,\n        rad: radicalResults[i],\n        comp: componentResults[i],\n        cf: relatedResults[i],\n      },\n      ['var']\n    )\n  );\n}\n\nasync function getKanjiById(\n  ids: Array<number>\n): Promise<Array<KanjiStoreRecord>> {\n  const db = await open();\n  if (!db) {\n    return [];\n  }\n\n  const kanjiRecords: Array<KanjiStoreRecord> = [];\n  {\n    const tx = db!.transaction('kanji');\n    for (const c of ids) {\n      const record = await tx.store.get(c);\n      if (record) {\n        kanjiRecords.push(record);\n      }\n    }\n  }\n\n  return kanjiRecords;\n}\n\nasync function getRadicalForKanji({\n  kanjiRecords,\n  lang,\n  logWarningMessage,\n}: {\n  kanjiRecords: Array<KanjiStoreRecord>;\n  lang: string;\n  logWarningMessage: (msg: string) => void;\n}): Promise<Array<KanjiResult['rad']>> {\n  const radicals = await getRadicals();\n\n  return kanjiRecords.map((record) => {\n    const variantId = getRadicalVariantId(record);\n    const baseId = formatRadicalId(record.rad.x);\n\n    const radicalVariant = radicals.get(variantId || baseId);\n    let rad: KanjiResult['rad'];\n    if (radicalVariant) {\n      rad = {\n        x: record.rad.x,\n        b: radicalVariant.b,\n        k: radicalVariant.k,\n        na: radicalVariant.na,\n        m: radicalVariant.m,\n        m_lang: radicalVariant.m_lang || lang,\n      };\n      if (record.rad.nelson) {\n        rad.nelson = record.rad.nelson;\n      }\n    } else {\n      // The radical was not found. This should basically never happen.\n      // But rather than crash fatally, just fill in some nonsense data\n      // instead.\n      logWarningMessage(`Failed to find radical: ${variantId || baseId}`);\n      rad = {\n        ...record.rad,\n        // We generally maintain the invariant that either 'b' or 'k' is\n        // filled in (or both for a base radical) so even though the TS\n        // typings don't require it, we should provide one here.\n        b: '',\n        na: [''],\n        m: [''],\n        m_lang: lang,\n      };\n    }\n\n    // If this a variant, return the base radical information too\n    if (variantId) {\n      const baseRadical = radicals.get(baseId);\n      if (baseRadical) {\n        const { b, k, na, m, m_lang } = baseRadical;\n        rad.base = { b, k, na, m, m_lang: m_lang || lang };\n      }\n    }\n\n    return rad;\n  });\n}\n\nfunction formatRadicalId(id: number): string {\n  return id.toString().padStart(3, '0');\n}\n\ntype RadicalVariantArray = Array<{ radical: number; id: string }>;\n\nfunction parseVariants(record: KanjiStoreRecord): RadicalVariantArray {\n  const variants: Array<{ radical: number; id: string }> = [];\n\n  if (record.var) {\n    for (const variantId of record.var) {\n      const matches = variantId.match(/^(\\d+)-/);\n      if (matches) {\n        const [, radical] = matches;\n        variants.push({\n          radical: parseInt(radical, 10),\n          id: variantId,\n        });\n      }\n    }\n  }\n\n  return variants;\n}\n\nfunction popVariantForRadical(\n  radical: number,\n  variants: RadicalVariantArray\n): string | undefined {\n  // Add special handling so that if we are searching for a variant for 74 ()\n  // but we find 130-2 () we match that.\n  const variantIndex = variants.findIndex(\n    (a) => a.radical === radical || (radical === 74 && a.id === '130-2')\n  );\n\n  if (variantIndex === -1) {\n    return undefined;\n  }\n\n  const id = variants[variantIndex].id;\n  variants.splice(variantIndex, 1);\n\n  return id;\n}\n\nfunction getRadicalVariantId(record: KanjiStoreRecord): string | undefined {\n  const variants = parseVariants(record);\n  const variant = variants.find((a) => a.radical === record.rad.x);\n  return variant?.id;\n}\n\n// NOTE: This is NOT meant to be a generic romaji utility. It does NOT\n// cover e.g.  or . It is very specifically for filling out component\n// records that use a katakana character and handles exactly the range we use\n// there to detect katakana (which excludes some katakana at the end of the\n// Unicode katakana block like ).\n//\n// It also doesn't differentiate between e.g.  or . In fact, it is only\n// ever expected to cover  and  but we've made it a little bit more generic\n// simply because the kanji components data is expected to be frequently updated\n// and it's completely possible that other katakana symbols might show up there\n// in the future.\nconst katakanaToRoman: Array<[string, string]> = [\n  ['', 'a'],\n  ['', 'a'],\n  ['', 'i'],\n  ['', 'i'],\n  ['', 'u'],\n  ['', 'u'],\n  ['', 'e'],\n  ['', 'e'],\n  ['', 'o'],\n  ['', 'o'],\n  ['', 'ka'],\n  ['', 'ga'],\n  ['', 'ki'],\n  ['', 'gi'],\n  ['', 'ku'],\n  ['', 'gu'],\n  ['', 'ke'],\n  ['', 'ge'],\n  ['', 'ko'],\n  ['', 'go'],\n  ['', 'sa'],\n  ['', 'za'],\n  ['', 'shi'],\n  ['', 'ji'],\n  ['', 'su'],\n  ['', 'zu'],\n  ['', 'se'],\n  ['', 'ze'],\n  ['', 'so'],\n  ['', 'zo'],\n  ['', 'ta'],\n  ['', 'da'],\n  ['', 'chi'],\n  ['', 'di'],\n  ['', 'tsu'],\n  ['', 'tsu'],\n  ['', 'dzu'],\n  ['', 'te'],\n  ['', 'de'],\n  ['', 'to'],\n  ['', 'do'],\n  ['', 'na'],\n  ['', 'ni'],\n  ['', 'nu'],\n  ['', 'ne'],\n  ['', 'no'],\n  ['', 'ha'],\n  ['', 'ba'],\n  ['', 'pa'],\n  ['', 'hi'],\n  ['', 'bi'],\n  ['', 'pi'],\n  ['', 'fu'],\n  ['', 'bu'],\n  ['', 'pu'],\n  ['', 'he'],\n  ['', 'be'],\n  ['', 'pe'],\n  ['', 'ho'],\n  ['', 'bo'],\n  ['', 'po'],\n  ['', 'ma'],\n  ['', 'mi'],\n  ['', 'mu'],\n  ['', 'me'],\n  ['', 'mo'],\n  ['', 'ya'],\n  ['', 'ya'],\n  ['', 'yu'],\n  ['', 'yu'],\n  ['', 'yo'],\n  ['', 'yo'],\n  ['', 'ra'],\n  ['', 'ri'],\n  ['', 'ru'],\n  ['', 're'],\n  ['', 'ro'],\n  ['', 'wa'],\n  ['', 'wa'],\n  ['', 'wi'],\n  ['', 'we'],\n  ['', 'wo'],\n  ['', 'n'],\n  ['', 'vu'],\n  ['', 'ka'],\n  ['', 'ke'],\n  ['', 'ga'],\n  ['', 'vi'],\n  ['', 've'],\n  ['', 'vo'],\n];\n\nasync function getComponentsForKanji({\n  kanjiRecords,\n  lang,\n  logWarningMessage,\n}: {\n  kanjiRecords: Array<KanjiStoreRecord>;\n  lang: string;\n  logWarningMessage: (msg: string) => void;\n}): Promise<Array<KanjiResult['comp']>> {\n  // Collect all the characters together\n  const components = kanjiRecords.reduce<Array<string>>(\n    (components, record) =>\n      components.concat(record.comp ? [...record.comp] : []),\n    []\n  );\n\n  // Work out which kanji characters we need to lookup\n  const radicalMap = await getCharToRadicalMapping();\n  const kanjiToLookup = new Set<number>();\n  for (const c of components) {\n    if (c && !radicalMap.has(c)) {\n      kanjiToLookup.add(c.codePointAt(0)!);\n    }\n  }\n\n  // ... And look them up\n  let kanjiMap: Map<string, KanjiStoreRecord> = new Map();\n  if (kanjiToLookup.size) {\n    const kanjiRecords = await getKanjiById([...kanjiToLookup]);\n    kanjiMap = new Map(\n      kanjiRecords.map((record) => [String.fromCodePoint(record.c), record])\n    );\n  }\n\n  // Now fill out the information\n  const radicals = await getRadicals();\n  const result: Array<KanjiResult['comp']> = [];\n  for (const record of kanjiRecords) {\n    const comp: KanjiResult['comp'] = [];\n    const variants = parseVariants(record);\n\n    for (const c of record.comp ? [...record.comp] : []) {\n      if (radicalMap.has(c)) {\n        let radicalRecord = radicals.get(radicalMap.get(c)!);\n        if (radicalRecord) {\n          // Look for a matching variant\n          const variantId = popVariantForRadical(radicalRecord!.r, variants);\n          if (typeof variantId !== 'undefined') {\n            const variantRadical = radicals.get(variantId);\n            if (variantRadical) {\n              radicalRecord = variantRadical;\n            } else {\n              logWarningMessage(\n                `Couldn't find radical record for variant ${variantId}`\n              );\n            }\n          }\n\n          const component: KanjiResult['comp'][0] = {\n            c,\n            na: radicalRecord.na,\n            m: radicalRecord.m,\n            m_lang: radicalRecord.m_lang || lang,\n          };\n          const baseRadical = radicals.get(formatRadicalId(radicalRecord.r));\n          if (baseRadical && baseRadical.k) {\n            component.k = baseRadical.k;\n          }\n\n          comp.push(component);\n        } else {\n          logWarningMessage(`Couldn't find radical record for ${c}`);\n        }\n      } else if (kanjiMap.has(c)) {\n        const kanjiRecord = kanjiMap.get(c);\n        if (kanjiRecord) {\n          let na: Array<string> = [];\n          if (kanjiRecord.r.kun && kanjiRecord.r.kun.length) {\n            na = kanjiRecord.r.kun.map((reading) => reading.replace('.', ''));\n          } else if (kanjiRecord.r.on && kanjiRecord.r.on.length) {\n            na = kanjiRecord.r.on;\n          }\n\n          comp.push({\n            c,\n            na,\n            m: kanjiRecord.m,\n            m_lang: kanjiRecord.m_lang || lang,\n          });\n        }\n      } else if (c.codePointAt(0)! >= 0x30a1 && c.codePointAt(0)! <= 0x30fa) {\n        // NOTE: If we ever support languages that are not roman-based, or\n        // where it doesn't make sense to convert katakana into a roman\n        // equivalent we should detect that here.\n        //\n        // For now we handle Japanese simply because that seems likely.\n        if (lang === 'ja') {\n          comp.push({\n            c,\n            na: [c],\n            m: [`${c}`],\n            m_lang: lang,\n          });\n        } else {\n          const asRoman = katakanaToRoman[c.codePointAt(0)! - 0x30a1][1];\n          // NOTE: We only currently deal with a very limited number of\n          // languages where it seems legitimate to write  as\n          // \"katakana\" (as best I can tell).\n          //\n          // Once we come to handle languages like Korean and so on we'll\n          // actually want to localize this properly.\n          //\n          // e.g.\n          //\n          //   Korean: \n          //   Chinese (what kind?): \n          //   Arabic:  ?\n          //   Persian:  ?\n          //   Russian:  ?\n          //\n          // Given that all these languages fall back to English anyway,\n          // though, it's probably not so bad if we forget to do this.\n          //\n          // TODO: Update this when we handle word dictionary\n          if (!['en', 'es', 'pt', 'fr'].includes(lang)) {\n            logWarningMessage(\n              `Generating katakana record for unknown language: ${lang}`\n            );\n          }\n          comp.push({\n            c,\n            na: [c],\n            m: [`katakana ${asRoman}`],\n            m_lang: lang,\n          });\n        }\n      } else {\n        logWarningMessage(`Couldn't find a radical or kanji entry for ${c}`);\n      }\n    }\n\n    result.push(comp);\n  }\n\n  return result;\n}\n\nasync function getRelatedKanji(\n  kanjiRecords: Array<KanjiStoreRecord>,\n  lang: string\n): Promise<Array<Array<RelatedKanji>>> {\n  // Collect all the characters together\n  const cf = kanjiRecords.reduce<Array<number>>(\n    (cf, record) =>\n      cf.concat(\n        record.cf ? [...record.cf].map((c) => c.codePointAt(0) || 0) : []\n      ),\n    []\n  );\n  const kanjiToLookup = new Set<number>(cf);\n\n  // ... And look them up\n  let kanjiMap: Map<string, KanjiStoreRecord> = new Map();\n  if (kanjiToLookup.size) {\n    const kanjiRecords = await getKanjiById([...kanjiToLookup]);\n    kanjiMap = new Map(\n      kanjiRecords.map((record) => [String.fromCodePoint(record.c), record])\n    );\n  }\n\n  // Now fill out the information\n  const result: Array<Array<RelatedKanji>> = [];\n  for (const record of kanjiRecords) {\n    const relatedKanji: Array<RelatedKanji> = [];\n    for (const cfChar of record.cf ? [...record.cf] : []) {\n      const kanji = kanjiMap.get(cfChar);\n      if (!kanji) {\n        continue;\n      }\n\n      const { r, m, m_lang, misc } = kanji;\n      relatedKanji.push({ c: cfChar, r, m, m_lang: m_lang || lang, misc });\n    }\n    result.push(relatedKanji);\n  }\n\n  return result;\n}\n\nasync function getRadicals(): Promise<Map<string, RadicalStoreRecord>> {\n  const db = await open();\n  if (!db) {\n    return new Map();\n  }\n\n  return db\n    .getAll('radicals')\n    .then((records) => new Map(records.map((record) => [record.id, record])));\n}\n\nasync function getCharToRadicalMapping(): Promise<Map<string, string>> {\n  const radicals = await getRadicals();\n\n  let baseRadical: RadicalStoreRecord | undefined;\n  const mapping: Map<string, string> = new Map();\n\n  for (const radical of radicals.values()) {\n    if (radical.id.indexOf('-') === -1) {\n      baseRadical = radical;\n      if (radical.b) {\n        mapping.set(radical.b, radical.id);\n      }\n      if (radical.k) {\n        mapping.set(radical.k, radical.id);\n      }\n    } else {\n      if (!baseRadical) {\n        throw new Error('Radicals out of order--no base radical found');\n      }\n      if (radical.r !== baseRadical.r) {\n        throw new Error('Radicals out of order--ID mismatch');\n      }\n      // Skip 130-2. This one is special. It's  which has the same\n      // unicode codepoint as  but we don't want to clobber that record\n      // (which we'll end up doing because they have different base radicals).\n      //\n      // Instead, we'll take care to pick up variants like this in\n      // getComponentsForKanji (or more specifically popVariantForRadical).\n      if (radical.id === '130-2') {\n        continue;\n      }\n      if (radical.b && radical.b !== baseRadical.b) {\n        mapping.set(radical.b, radical.id);\n      }\n      if (radical.k && radical.k !== baseRadical.k) {\n        mapping.set(radical.k, radical.id);\n      }\n    }\n  }\n\n  return mapping;\n}\n\n// -------------------------------------------------------------------------\n//\n// Names\n//\n// -------------------------------------------------------------------------\n\nexport async function getNames(search: string): Promise<Array<NameResult>> {\n  const db = await open();\n  if (!db) {\n    return [];\n  }\n\n  // Normalize search string\n  const lookup = search.normalize();\n\n  // Set up our output value.\n  const addedRecords: Set<number> = new Set();\n  const result: Array<NameResult> = [];\n\n  const maybeAddRecord = (record: NameStoreRecord) => {\n    if (!addedRecords.has(record.id)) {\n      result.push(stripFields(record, ['h']));\n      addedRecords.add(record.id);\n    }\n  };\n\n  // Try the k (kanji) index first\n  const kanjiIndex = db!.transaction('names').store.index('k');\n  // (We explicitly use IDBKeyRange.only because otherwise the idb TS typings\n  // fail to recognize that these indices are multi-entry and hence it is\n  // valid to supply a single string instead of an array of strings.)\n  for await (const cursor of kanjiIndex.iterate(IDBKeyRange.only(lookup))) {\n    maybeAddRecord(cursor.value);\n  }\n\n  // Then the r (reading) index\n  const readingIndex = db!.transaction('names').store.index('r');\n  for await (const cursor of readingIndex.iterate(IDBKeyRange.only(lookup))) {\n    maybeAddRecord(cursor.value);\n  }\n\n  // Then finally try converting to hiragana and using the hiragana index\n  const hiraganaIndex = db!.transaction('names').store.index('h');\n  const hiragana = kanaToHiragana(lookup);\n  for await (const cursor of hiraganaIndex.iterate(\n    IDBKeyRange.only(hiragana)\n  )) {\n    maybeAddRecord(cursor.value);\n  }\n\n  return result;\n}\n","import { DownloadError } from './download-error';\n\n// A flattened representation of error information suitable for postMessaging.\n//\n// For convenience, it includes retry information for when it is used in\n// automatic retry scenarios.\n\nexport interface UpdateErrorState {\n  name: string;\n  message: string;\n  code?: string;\n  url?: string;\n  nextRetry?: Date;\n  retryCount?: number;\n}\n\nexport function toUpdateErrorState({\n  error,\n  nextRetry,\n  retryCount,\n}: {\n  error: Error;\n  nextRetry?: Date;\n  retryCount?: number;\n}): UpdateErrorState {\n  return {\n    name: error.name,\n    message: error.message,\n    code: error instanceof DownloadError ? error.code : undefined,\n    url: error instanceof DownloadError ? error.url : undefined,\n    nextRetry,\n    retryCount,\n  };\n}\n","// This is in part:\n//\n// - Missing typings for requestIdleCallback\n// - Polyfill for browsers that don't support requestIdleCallback\n// - Polyfill for non-Window contexts (e.g. workers)\n\ninterface IdleDeadline {\n  timeRemaining: () => number;\n  readonly didTimeout: boolean;\n}\n\ninterface IdleRequestOptions {\n  timeout: number;\n}\n\ntype IdleCallbackHandle = number;\n\ntype IdleRequestCallback = (deadline: IdleDeadline) => void;\n\nexport let requestIdleCallback: (\n  callback: IdleRequestCallback,\n  options?: IdleRequestOptions\n) => IdleCallbackHandle;\nexport let cancelIdleCallback: (handle: IdleCallbackHandle) => void;\n\nif (\n  typeof self === 'object' &&\n  typeof self.requestIdleCallback === 'function' &&\n  typeof self.cancelIdleCallback === 'function'\n) {\n  requestIdleCallback = (self as any).requestIdleCallback;\n  cancelIdleCallback = (self as any).cancelIdleCallback;\n} else {\n  requestIdleCallback = (\n    callback: IdleRequestCallback,\n    options?: IdleRequestOptions\n  ): IdleCallbackHandle => {\n    // Use half the specified timeout since it probably represents a worst-case\n    // scenario.\n    const timeout = options ? options.timeout / 2 : 0;\n    return self.setTimeout(() => {\n      callback({ timeRemaining: () => 0, didTimeout: true });\n    }, timeout);\n  };\n\n  cancelIdleCallback = (handle: IdleCallbackHandle) => {\n    clearTimeout(handle);\n  };\n}\n","export function uuid(): string {\n  return ((1e7).toString() + -1e3 + -4e3 + -8e3 + -1e11).replace(\n    /[018]/g,\n    (c) =>\n      (\n        Number(c) ^\n        (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (Number(c) / 4)))\n      ).toString(16)\n  );\n}\n","import { DataSeries } from './data-series';\nimport { JpdictIdb } from './database';\nimport { uuid } from './uuid';\n\nconst dbToUuid: Map<JpdictIdb, string> = new Map();\n\nexport function getUpdateKey(obj: JpdictIdb, series: DataSeries): string {\n  if (!dbToUuid.has(obj)) {\n    dbToUuid.set(obj, uuid());\n  }\n  const baseId = dbToUuid.get(obj);\n\n  return `${baseId}-${series}`;\n}\n","import { DataSeries, MajorDataSeries } from './data-series';\nimport { ChangeCallback, ChangeTopic, JpdictIdb } from './database';\nimport { DownloadError } from './download-error';\nimport { OfflineError } from './offline-error';\nimport {\n  cancelIdleCallback,\n  requestIdleCallback,\n} from './request-idle-callback';\nimport { getUpdateKey } from './update-key';\nimport { UpdatingUpdateState } from './update-state';\n\nexport type UpdateCompleteCallback = () => void;\nexport type UpdateErrorCallback = (params: {\n  error: Error;\n  nextRetry?: Date;\n  retryCount?: number;\n}) => void;\n\n// We allow passing in a custom setTimeout implementation so that unit tests\n// can mock it, because overriding the global definition interferes with\n// playwright, and sinon can't mock ES6 dependencies:\n//\n// https://github.com/hugomrdias/playwright-test/issues/426\n// https://github.com/microsoft/playwright/issues/9123\n// https://github.com/sinonjs/sinon/issues/1711\ntype SetTimeoutFn = (cb: () => void, duration: number) => number;\n\n// Updates the passed-in database and retries in the case of failure due to\n// network failures or being offline.\n//\n// Note that if there is an existing call to this function in motion\n// (including waiting to retry) the existing call will be re-used.\n// As a result, if the passed-in callback functions differ between invocations,\n// only the originally passed-in callback functions will be called.\n//\n// (This is fixable but it introduces complexity and currently all clients\n// have a single point where they call into this so it is not necessary to try\n// and store a list of callback functions.)\n//\n// If the `updateNow` parameter is set then an existing call to this function\n// will be canceled first UNLESS it is already running or blocked due to being\n// offline. That is, the `updateNow` flag is meant to say, \"Update now if you\n// are not already.\"\n//\n// Furthermore, note that if an invocation is canceled there is no abort\n// callback or AbortError or anything of the sort. (Again, this is fixable but\n// it requires us to store the callbacks passed-in, and currently no client\n// needs this.)\nexport function updateWithRetry({\n  db,\n  lang,\n  series,\n  onUpdateComplete,\n  onUpdateError,\n  setTimeout = self.setTimeout,\n  updateNow = false,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout?: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n  updateNow?: boolean;\n}) {\n  startUpdate({\n    db,\n    lang,\n    series,\n    setTimeout,\n    onUpdateComplete,\n    onUpdateError,\n    updateNow,\n  });\n}\n\nfunction runUpdate({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}) {\n  // If we are offline, wait until we are online.\n  if (!navigator.onLine) {\n    const onlineCallback = async () => {\n      runUpdate({\n        db,\n        lang,\n        series,\n        setTimeout,\n        onUpdateComplete,\n        onUpdateError,\n      });\n    };\n\n    addEventListener('online', onlineCallback, { once: true });\n    goOffline({ db, series, lang, onlineCallback });\n    onUpdateError?.({ error: new OfflineError() });\n    return;\n  }\n\n  // Transition to updating state.\n  beginUpdating({ db, series, lang });\n\n  // Actually run the update and handle any errors\n  void (async () => {\n    try {\n      await db.update({ series, lang });\n\n      resetUpdate({ db, series });\n\n      if (db.isVerbose) {\n        console.log('Successfully completed update.');\n      }\n\n      onUpdateComplete?.();\n    } catch (e) {\n      if (db.isVerbose) {\n        console.error('Got error while updating', e);\n      }\n\n      let retryCount: number | undefined;\n      let nextRetry: Date | undefined;\n      let suppressError = false;\n\n      // Retry network errors at decreasing intervals\n      const isNetworkError = e instanceof DownloadError;\n      if (isNetworkError) {\n        const scheduleResult = maybeScheduleRetry({\n          db,\n          lang,\n          series,\n          setTimeout,\n          onUpdateComplete,\n          onUpdateError,\n        });\n        if (scheduleResult) {\n          ({ nextRetry, retryCount } = scheduleResult);\n        }\n      } else if (e && e instanceof Error && e.name === 'ConstraintError') {\n        const scheduleResult = maybeScheduleIdleRetry({\n          db,\n          lang,\n          series,\n          setTimeout,\n          onUpdateComplete,\n          onUpdateError,\n        });\n        if (scheduleResult) {\n          ({ retryCount } = scheduleResult);\n        }\n\n        suppressError = !!scheduleResult;\n      } else {\n        resetUpdate({ db, series });\n      }\n\n      if (!suppressError && onUpdateError) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        onUpdateError({ error, nextRetry, retryCount });\n      }\n    }\n  })();\n}\n\nfunction onDatabaseChange({\n  db,\n  series,\n  topic,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n  topic: ChangeTopic;\n}) {\n  // If the database was deleted, cancel any scheduled retries.\n  if (topic === 'deleted') {\n    resetUpdate({ db, series });\n    return;\n  }\n\n  // topic === 'stateupdated'\n  //\n  // If we successfully downloaded *something*, reset the retry interval.\n  //\n  // We should only do this when we have a retry interval set since we DON'T\n  // want to reset the retry count if we are retrying due to a database error.\n  const seriesHasProgress = (series: DataSeries) =>\n    db[series].updateState.type === 'updating' &&\n    (db[series].updateState as UpdatingUpdateState).fileProgress > 0;\n  const downloadedSomething =\n    series === 'kanji'\n      ? seriesHasProgress('kanji') || seriesHasProgress('radicals')\n      : seriesHasProgress(series);\n\n  if (downloadedSomething) {\n    clearRetryInterval({ db, series });\n  }\n}\n\nexport function cancelUpdateWithRetry({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  resetUpdate({ db, series });\n}\n\n// ---------------------------------------------------------------------------\n//\n// State management\n//\n// ---------------------------------------------------------------------------\n\ntype RetryState =\n  | {\n      type: 'offline';\n      lang: string;\n      changeCallback: ChangeCallback;\n      onlineCallback: () => any;\n    }\n  | {\n      type: 'updating';\n      lang: string;\n      changeCallback: ChangeCallback;\n      retryIntervalMs?: number;\n      retryCount?: number;\n    }\n  | {\n      type: 'waiting-for-timeout';\n      lang: string;\n      changeCallback: ChangeCallback;\n      setTimeoutHandle: number;\n      retryIntervalMs: number;\n      retryCount: number;\n    }\n  | {\n      type: 'waiting-for-idle';\n      lang: string;\n      changeCallback: ChangeCallback;\n      requestIdleCallbackHandle: number;\n      retryCount: number;\n    };\n\nconst inProgressUpdates: Map<string, RetryState> = new Map();\n\n// ---------------------------------------------------------------------------\n//\n// State transitions\n//\n// ---------------------------------------------------------------------------\n\nfunction startUpdate({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n  updateNow,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n  updateNow: boolean;\n}) {\n  // Check if we have an in-progress update.\n  const updateKey = getUpdateKey(db, series);\n  let retryState = inProgressUpdates.get(updateKey);\n\n  // If the languages differ, we should cancel the existing update.\n  if (retryState && retryState.lang !== lang) {\n    if (db.isVerbose) {\n      console.info(\n        'Canceling existing call to updateWithRetry because the requested language has changed.'\n      );\n    }\n    resetUpdate({ db, series });\n  }\n\n  // Re-fetch the retry status since we may have canceled it.\n  retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    // If we are not trying to force an update then use the existing in-progress\n    // update.\n    if (!updateNow) {\n      if (db.isVerbose) {\n        console.info(\n          'Overlapping calls to updateWithRetry. Re-using existing invocation. This could be problematic if different callback functions were passed on each invocation.'\n        );\n      }\n      return;\n    }\n\n    // If we're offline, then we're not even going to try updating until we\n    // are online (at which point we will retry immediately).\n    if (retryState.type === 'offline') {\n      if (db.isVerbose) {\n        console.info('Deferring forced update. Currently offline.');\n      }\n      return;\n    }\n\n    // Even if we are trying to force the update, if we just started an update\n    // (or are retrying rapidly) then use the existing update.\n    if (retryState.type === 'updating') {\n      if (db.isVerbose) {\n        console.info('Skipping forced update. Already updating presently.');\n      }\n      return;\n    }\n\n    // Otherwise, cancel the in-progress update.\n    if (db.isVerbose) {\n      console.log('Canceling existing queued retry.');\n    }\n    resetUpdate({ db, series });\n  }\n\n  // If we _still_ have an in-progress update here, it means we got an\n  // overlapping call to this method while we were waiting to cancel the\n  // previous in-progress update.\n  retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    if (db.isVerbose) {\n      console.log('Skipping overlapping auto-retry request.');\n    }\n    return;\n  }\n\n  runUpdate({ db, lang, series, setTimeout, onUpdateComplete, onUpdateError });\n}\n\nfunction resetUpdate({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (!retryState) {\n    return;\n  }\n\n  switch (retryState.type) {\n    case 'offline':\n      removeEventListener('online', retryState.onlineCallback);\n      break;\n\n    case 'waiting-for-timeout':\n      clearTimeout(retryState.setTimeoutHandle);\n      break;\n\n    case 'waiting-for-idle':\n      cancelIdleCallback(retryState.requestIdleCallbackHandle);\n      break;\n  }\n\n  db.removeChangeListener(retryState.changeCallback);\n  inProgressUpdates.delete(updateKey);\n\n  db.cancelUpdate(series);\n}\n\nfunction goOffline({\n  db,\n  lang,\n  onlineCallback,\n  series,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  onlineCallback: () => any;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    resetUpdate({ db, series });\n  }\n\n  inProgressUpdates.set(updateKey, {\n    type: 'offline',\n    lang,\n    onlineCallback,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n  });\n}\n\nfunction beginUpdating({\n  db,\n  lang,\n  series,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  inProgressUpdates.set(updateKey, {\n    type: 'updating',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    retryCount: getRetryCount(retryState),\n    retryIntervalMs: getRetryIntervalMs(retryState),\n  });\n}\n\nfunction maybeScheduleRetry({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}): { retryCount: number; nextRetry: Date } | undefined {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // If we are not updating to begin with, don't schedule a retry since it\n  // probably means we were canceled.\n  if (retryState?.type !== 'updating') {\n    return undefined;\n  }\n\n  let retryIntervalMs = retryState.retryIntervalMs;\n  if (retryIntervalMs) {\n    // Don't let the interval become longer than 12 hours\n    retryIntervalMs = Math.min(retryIntervalMs * 2, 12 * 60 * 60 * 1000);\n  } else {\n    // Randomize the initial interval to somewhere between 3s ~ 6s.\n    retryIntervalMs = 3000 + Math.random() * 3000;\n  }\n\n  let retryCount = retryState.retryCount;\n  retryCount = typeof retryCount === 'number' ? retryCount + 1 : 0;\n\n  if (db.isVerbose) {\n    console.log(`Scheduling retry of update in ${retryIntervalMs}ms`);\n  }\n\n  const setTimeoutHandle = setTimeout(() => {\n    if (db.isVerbose) {\n      console.log('Running automatic retry of update...');\n    }\n\n    runUpdate({\n      db,\n      lang,\n      series,\n      setTimeout,\n      onUpdateComplete,\n      onUpdateError,\n    });\n  }, retryIntervalMs) as unknown as number;\n\n  const nextRetry = new Date(Date.now() + retryIntervalMs);\n\n  inProgressUpdates.set(updateKey, {\n    type: 'waiting-for-timeout',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    retryCount,\n    retryIntervalMs,\n    setTimeoutHandle,\n  });\n\n  return { nextRetry, retryCount };\n}\n\nfunction clearRetryInterval({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}) {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // The check here for `retryIntervalMs` being set ensures we don't clear the\n  // interval when we call this as a result of an idle callback running.\n  if (retryState?.type !== 'updating' || !retryState.retryIntervalMs) {\n    return;\n  }\n\n  inProgressUpdates.set(updateKey, {\n    ...retryState,\n    retryIntervalMs: undefined,\n    retryCount: undefined,\n  });\n}\n\nfunction maybeScheduleIdleRetry({\n  db,\n  lang,\n  series,\n  setTimeout,\n  onUpdateComplete,\n  onUpdateError,\n}: {\n  db: JpdictIdb;\n  lang: string;\n  series: MajorDataSeries;\n  setTimeout: SetTimeoutFn;\n  onUpdateComplete?: UpdateCompleteCallback;\n  onUpdateError?: UpdateErrorCallback;\n}): { retryCount: number } | undefined {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n\n  // If we are not updating to begin with, don't schedule a retry since it\n  // probably means we were canceled.\n  if (retryState?.type !== 'updating') {\n    return undefined;\n  }\n\n  // We only want to do this kind of rapid retry a few times (it's for database\n  // errors).\n  let retryCount = retryState.retryCount;\n  if (retryCount && retryCount >= 2) {\n    return undefined;\n  }\n\n  retryCount = typeof retryCount === 'number' ? retryCount + 1 : 0;\n\n  if (db.isVerbose) {\n    console.log('Retrying update momentarily');\n  }\n\n  const requestIdleCallbackHandle = requestIdleCallback(\n    () => {\n      if (db.isVerbose) {\n        console.log('Running automatic retry of update...');\n      }\n\n      runUpdate({\n        db,\n        lang,\n        series,\n        setTimeout,\n        onUpdateComplete,\n        onUpdateError,\n      });\n    },\n    { timeout: 2000 }\n  );\n\n  inProgressUpdates.set(updateKey, {\n    type: 'waiting-for-idle',\n    lang,\n    changeCallback: getOrRegisterChangeCallback({ db, series }),\n    requestIdleCallbackHandle,\n    retryCount,\n  });\n\n  return { retryCount };\n}\n\n// ----------------------------------------------------------------------------\n//\n// State helpers\n//\n// ----------------------------------------------------------------------------\n\nfunction getOrRegisterChangeCallback({\n  db,\n  series,\n}: {\n  db: JpdictIdb;\n  series: MajorDataSeries;\n}): ChangeCallback {\n  const updateKey = getUpdateKey(db, series);\n  const retryState = inProgressUpdates.get(updateKey);\n  if (retryState) {\n    return retryState.changeCallback;\n  }\n\n  const changeCallback = (topic: ChangeTopic) =>\n    onDatabaseChange({ db, series, topic });\n  db.addChangeListener(changeCallback);\n\n  return changeCallback;\n}\n\nfunction getRetryCount(retryState: RetryState | undefined): number | undefined {\n  return retryState?.type !== 'offline' ? retryState?.retryCount : undefined;\n}\n\nfunction getRetryIntervalMs(\n  retryState: RetryState | undefined\n): number | undefined {\n  return retryState?.type === 'waiting-for-timeout' ||\n    retryState?.type === 'updating'\n    ? retryState?.retryIntervalMs\n    : undefined;\n}\n","import Bugsnag from '@birchill/bugsnag-zero';\nimport * as s from 'superstruct';\nimport browser from 'webextension-polyfill';\n\nconst FxLocalDataSchema = s.type({\n  timestamp: s.min(s.integer(), 0),\n  rates: s.record(s.string(), s.number()),\n  updated: s.min(s.integer(), 0),\n});\n\nexport type FxLocalData = s.Infer<typeof FxLocalDataSchema>;\n\nexport async function getLocalFxData(\n  onUpdate?: (data: FxLocalData) => void\n): Promise<FxLocalData | undefined> {\n  if (onUpdate) {\n    browser.storage.onChanged.addListener(getStorageChangeCallback(onUpdate));\n  }\n\n  try {\n    const fxData = (await browser.storage.local.get('fx'))?.fx;\n    if (!fxData) {\n      return undefined;\n    }\n    const [error, validated] = s.validate(fxData, FxLocalDataSchema);\n\n    if (validated) {\n      return validated;\n    } else {\n      void Bugsnag.notify(error, { severity: 'warning' });\n    }\n  } catch {\n    console.warn('Failed to get fx data from storage');\n  }\n\n  return undefined;\n}\n\nfunction getStorageChangeCallback(onChange: (data: FxLocalData) => void) {\n  return (\n    changes: Record<string, { oldValue?: unknown; newValue?: unknown }>,\n    areaName: string\n  ) => {\n    if (areaName !== 'local') {\n      return;\n    }\n\n    if ('fx' in changes) {\n      const [error, validated] = s.validate(\n        changes.fx.newValue,\n        FxLocalDataSchema\n      );\n\n      if (validated) {\n        onChange(validated);\n      } else {\n        void Bugsnag.notify(error, { severity: 'warning' });\n      }\n    }\n  };\n}\n","export function isObject(a: unknown): a is Record<string, any> {\n  return typeof a === 'object' && a !== null && !Array.isArray(a);\n}\n","/**\n * A helper to strip certain fields from an object.\n */\nexport function stripFields<T, K extends keyof T>(\n  o: T,\n  fields: K[]\n): Omit<T, K> {\n  const result: Partial<T> = { ...o };\n  for (const field of fields) {\n    delete result[field];\n  }\n  return result as Omit<T, K>;\n}\n","export function isFirefox(): boolean {\n  return navigator.userAgent.indexOf('Firefox/') !== -1;\n}\n\nexport function isFenix(): boolean {\n  return isFirefox() && navigator.userAgent.indexOf('Android') !== -1;\n}\n\nexport function isChromium(): boolean {\n  return (\n    navigator.userAgent.indexOf('Chrome/') !== -1 ||\n    navigator.userAgent.indexOf('Chromium/') !== -1\n  );\n}\n\nexport function isEdge(): boolean {\n  return navigator.userAgent.indexOf('Edg/') !== -1;\n}\n\nexport function isSafari(): boolean {\n  return navigator.userAgent.indexOf('Safari/') !== -1 && !isChromium();\n}\n\nexport function isMac(): boolean {\n  return /^Mac/i.test(navigator.platform);\n}\n\nexport function isIOS(): boolean {\n  return (\n    [\n      'iPad Simulator',\n      'iPhone Simulator',\n      'iPod Simulator',\n      'iPad',\n      'iPhone',\n      'iPod',\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n  );\n}\n\n/** @public */\nexport function isThunderbird(): boolean {\n  return navigator.userAgent.indexOf('Thunderbird/') !== -1;\n}\n","export const dbLanguages = [\n  'de',\n  'en',\n  'es',\n  'fr',\n  'hu',\n  'nl',\n  'pt',\n  'ru',\n  'sl',\n  'sv',\n] as const;\n\nexport type DbLanguageId = (typeof dbLanguages)[number];\n\nexport const dbLanguageMeta: Array<\n  [DbLanguageId, { name: string; hasKanji?: boolean; hasWords?: boolean }]\n> = [\n  ['de', { name: 'Deutsch', hasWords: true }],\n  ['en', { name: 'English', hasKanji: true, hasWords: true }],\n  ['es', { name: 'Espaol', hasKanji: true, hasWords: true }],\n  ['fr', { name: 'Franais', hasKanji: true, hasWords: true }],\n  ['hu', { name: 'Magyar', hasWords: true }],\n  ['nl', { name: 'Nederlands', hasWords: true }],\n  ['pt', { name: 'Portugus', hasKanji: true }],\n  ['ru', { name: '', hasWords: true }],\n  ['sl', { name: 'Slovenina', hasWords: true }],\n  ['sv', { name: 'Svenska', hasWords: true }],\n];\n\nexport function isDbLanguageId(id: string): id is DbLanguageId {\n  return dbLanguages.includes(id as DbLanguageId);\n}\n","export class ExtensionStorageError extends Error {\n  key: string;\n  action: 'set' | 'get' | 'remove';\n\n  constructor(\n    { key, action }: { key: string; action: 'set' | 'get' | 'remove' },\n    ...params: any[]\n  ) {\n    super(...params);\n    Object.setPrototypeOf(this, ExtensionStorageError.prototype);\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, ExtensionStorageError);\n    }\n\n    this.name = 'ExtensionStorageError';\n    this.message = `Failed to ${action} '${key}'`;\n    this.key = key;\n    this.action = action;\n  }\n}\n","import { KeyboardKeys } from './content-config-params';\n\n// Although we separate out the keys for moving a pop-up up or down when we\n// report the keys to the content page, we store them as a single setting.\nexport type StoredKeyboardKeys = Omit<\n  KeyboardKeys,\n  'movePopupUp' | 'movePopupDown'\n> & {\n  movePopupDownOrUp: string[];\n};\n\n// A single key description. We use this definition for storing the default keys\n// since it allows storing as an array (so we can determine the order the\n// options are displayed in) and storing a description along with each key.\nexport type KeySetting = {\n  name: keyof StoredKeyboardKeys;\n  keys: string[];\n  enabledKeys: string[];\n  l10nKey: string;\n};\n\nexport const PopupKeys: KeySetting[] = [\n  {\n    name: 'nextDictionary',\n    keys: ['Shift', 'Enter', 'n'],\n    enabledKeys: ['Shift', 'Enter'],\n    l10nKey: 'options_popup_switch_dictionaries',\n  },\n  {\n    name: 'kanjiLookup',\n    keys: ['Shift'],\n    enabledKeys: [],\n    l10nKey: 'options_popup_kanji_lookup',\n  },\n  {\n    name: 'toggleDefinition',\n    keys: ['d'],\n    enabledKeys: [],\n    l10nKey: 'options_popup_toggle_definition',\n  },\n  {\n    name: 'expandPopup',\n    keys: ['x'],\n    enabledKeys: ['x'],\n    l10nKey: 'options_popup_expand_popup',\n  },\n  {\n    name: 'closePopup',\n    keys: ['Esc', 'x'],\n    enabledKeys: ['Esc'],\n    l10nKey: 'options_popup_close_popup',\n  },\n  {\n    name: 'pinPopup',\n    keys: ['Alt', 'Ctrl', 'Space'],\n    enabledKeys: ['Ctrl'],\n    l10nKey: 'options_popup_pin_popup',\n  },\n  {\n    name: 'movePopupDownOrUp',\n    keys: ['j,k'],\n    enabledKeys: [],\n    l10nKey: 'options_popup_move_popup_down_or_up',\n  },\n  {\n    name: 'startCopy',\n    keys: ['c'],\n    enabledKeys: ['c'],\n    l10nKey: 'options_popup_start_copy',\n  },\n];\n","import { DbLanguageId } from './db-languages';\nimport { TranslateFunctionType } from './i18n';\n\nconst SUPPORTED_REFERENCES = [\n  // The radical for the kanji (number and character, from rad field)\n  'radical',\n  // Nelson radical (from rad field)\n  'nelson_r',\n  // Kanji kentei (from misc field)\n  'kk',\n  // WaniKani level (from misc field)\n  'wk',\n  // Pinyin reading\n  'py',\n  // JLPT level (from misc field)\n  'jlpt',\n  // Unicode codepoint (generated)\n  'unicode',\n  // Conning, The Kodansha Kanji Learner's Course\n  'conning',\n  // New Japanese-English Character Dictionary\n  'halpern_njecd',\n  // Learners Dictionary 2nd ed.\n  'halpern_kkld_2ed',\n  // Remembering the Kanji (6th ed.)\n  'heisig6',\n  // A Guide To Remembering Japanese Characters\n  'henshall',\n  // Kanji and Kana (2011 edition)\n  'sh_kk2',\n  // Japanese For Busy People vols I-III\n  'busy_people',\n  // Kanji in Context by Nishiguchi and Kono\n  'kanji_in_context',\n  // the Kodansha Compact Kanji Guide\n  'kodansha_compact',\n  // Yves Maniette's \"Les Kanjis dans la tete\" French adaptation of Heisig\n  // (Only included for lang:fr)\n  'maniette',\n  // \"Classic\" Nelson - Modern Reader's Japanese-English Character Dictionary\n  'nelson_c',\n  // The New Nelson Japanese-English Character Dictionary\n  'nelson_n',\n  // Halpern's SKIP (System of Kanji Indexing by Patterns)\n  'skip',\n  // Descriptor codes for The Kanji Dictionary\n  'sh_desc',\n] as const;\n\nexport type ReferenceAbbreviation = (typeof SUPPORTED_REFERENCES)[number];\n\nexport function getReferencesForLang(lang: DbLanguageId) {\n  if (lang !== 'fr') {\n    return SUPPORTED_REFERENCES.filter((ref) => ref !== 'maniette');\n  }\n  return SUPPORTED_REFERENCES;\n}\n\nconst REFERENCE_ABBREV_MAPPING: {\n  [key: string]: ReferenceAbbreviation;\n} = {\n  CO: 'conning',\n  H: 'halpern_njecd',\n  L: 'heisig6',\n  E: 'henshall',\n  KK: 'kk',\n  DK: 'halpern_kkld_2ed',\n  N: 'nelson_c',\n  NR: 'nelson_r',\n  V: 'nelson_n',\n  P: 'skip',\n  IN: 'sh_kk2',\n  I: 'sh_desc',\n  U: 'unicode',\n  Y: 'py',\n  WK: 'wk',\n} as const;\n\nexport function convertLegacyReference(\n  ref: string\n): ReferenceAbbreviation | undefined {\n  return REFERENCE_ABBREV_MAPPING.hasOwnProperty(ref)\n    ? REFERENCE_ABBREV_MAPPING[ref]\n    : undefined;\n}\n\ntype LocalizedReferences = 'radical' | 'nelson_r' | 'kk' | 'jlpt' | 'unicode';\ntype NotLocalizedReferences = Exclude<\n  ReferenceAbbreviation,\n  LocalizedReferences\n>;\ntype ReferenceLabel = { full: string; short?: string; lang: string };\n\n// Note that when adding or modifying labels here, it is important that the full\n// and short versions sort roughly the same so that they appear to be in\n// alphabetical order in both the popup (where we use the short form) and\n// options page (where we use the long form).\n//\n// We sort by the short label, where available, which enables, for example,\n// showing an initial \"The\" in the long label but still sorting by the short\n// label (which does not include the \"The\"). Such exceptions aside, however, the\n// full and short versions should generally start with the same first few words.\nconst REFERENCE_LABELS: {\n  [key in NotLocalizedReferences]: ReferenceLabel;\n} = {\n  conning: {\n    full: \"Conning - Kodansha Kanji Learner's Course\",\n    short: 'Conning',\n    lang: 'en',\n  },\n  sh_kk2: {\n    full: 'Kanji & Kana (Hadamitzky, Tuttle, 2011)',\n    short: 'Kanji & Kana',\n    lang: 'en',\n  },\n  halpern_njecd: {\n    full: 'Halpern - New Japanese-English Character Dictionary',\n    short: 'Halpern',\n    lang: 'en',\n  },\n  halpern_kkld_2ed: {\n    full: \"Kanji Learner's Dictionary (Halpbern, Kodansha, 2nd ed.)\",\n    short: \"Kanji Learner's Dictionary\",\n    lang: 'en',\n  },\n  heisig6: {\n    full: 'Heisig - Rembering the Kanji (6th ed.)',\n    short: 'Heisig',\n    lang: 'en',\n  },\n  henshall: {\n    full: 'Henshall - A Guide to Remembering Japanese Characters',\n    short: 'Henshall',\n    lang: 'en',\n  },\n  busy_people: { full: 'Japanese for Busy People', lang: 'en' },\n  kanji_in_context: { full: 'Kanji in Context', lang: 'en' },\n  kodansha_compact: {\n    full: 'Compact Kanji Guide (Kodansha)',\n    short: 'Compact Kanji Guide',\n    lang: 'en',\n  },\n  maniette: { full: 'Les Kanjis dans la tete', lang: 'fr' },\n  nelson_c: {\n    full: \"Classic Nelson - Modern Reader's Japanese-English Character Dictionary\",\n    short: 'Classic Nelson',\n    lang: 'en',\n  },\n  nelson_n: {\n    full: 'New Nelson Japanese-English Character Dictionary',\n    short: 'New Nelson',\n    lang: 'en',\n  },\n  py: { full: 'Pinyin', lang: 'en' },\n  skip: { full: 'SKIP', lang: 'en' },\n  sh_desc: {\n    full: 'The Kanji Dictionary (Spahn)',\n    short: 'Kanji Dictionary',\n    lang: 'en',\n  },\n  wk: {\n    full: 'WaniKani level',\n    short: 'WaniKani',\n    lang: 'en',\n  },\n} as const;\n\n// Get an array matching reference abbreviations to suitable names.\n//\n// These two methods return an array, not a map or object, since we try to\n// preserve the same order of references everywhere we present them.\n//\n// For the localized ones (radical, JLPT, kk, unicode), we look up the\n// appropriate string. For the others, we return a fixed string. (This way we\n// keep complete string keys--not concatenated strings--in the source so we can\n// readily determine which strings are in use.)\n\ntype ReferenceAndLabel = { ref: ReferenceAbbreviation } & ReferenceLabel;\n\nexport function getReferenceLabelsForLang(\n  lang: string,\n  t: TranslateFunctionType\n): Array<ReferenceAndLabel> {\n  const result: Array<ReferenceAndLabel> = [];\n\n  for (const ref of SUPPORTED_REFERENCES) {\n    if (lang !== 'fr' && ref === 'maniette') {\n      continue;\n    }\n    result.push({ ref, ...getLabelForReference(ref, t) });\n  }\n\n  // Sort by short version first since this is what will be shown in the pop-up.\n  result.sort((a, b) => (a.short || a.full).localeCompare(b.short || b.full));\n\n  return result;\n}\n\nexport function getSelectedReferenceLabels(\n  selectedRefs: ReadonlyArray<ReferenceAbbreviation>,\n  t: TranslateFunctionType\n): Array<ReferenceAndLabel> {\n  const result: Array<ReferenceAndLabel> = [];\n  const selectedRefsSet = new Set<ReferenceAbbreviation>(selectedRefs);\n\n  for (const ref of SUPPORTED_REFERENCES) {\n    if (!selectedRefsSet.has(ref)) {\n      continue;\n    }\n    result.push({ ref, ...getLabelForReference(ref, t) });\n  }\n\n  // Sort by short version first since this is what will be shown in the pop-up.\n  result.sort((a, b) => (a.short || a.full).localeCompare(b.short || b.full));\n\n  return result;\n}\n\nfunction getLabelForReference(\n  ref: ReferenceAbbreviation,\n  t: TranslateFunctionType\n): ReferenceLabel {\n  const lang = t('lang_tag');\n\n  switch (ref) {\n    case 'radical':\n      return { full: t('ref_label_radical'), lang };\n\n    case 'nelson_r':\n      return { full: t('ref_label_nelson_r'), lang };\n\n    case 'kk':\n      return { full: t('ref_label_kk'), lang };\n\n    case 'jlpt':\n      return { full: t('ref_label_jlpt'), lang };\n\n    case 'py':\n      return { full: t('ref_label_py'), lang };\n\n    case 'unicode':\n      return { full: t('ref_label_unicode'), lang };\n\n    default:\n      return REFERENCE_LABELS[ref];\n  }\n}\n","// This is largely a wrapper about the browser.sync.settings API which provides\n// following important features:\n//\n// * Only options that are explicitly set get saved. (This prevents the\n//   \"FoxClocks problem\" where, when you install the FoxClocks add-on on a new\n//   computer it sets all the settings to their default values before a sync\n//   happens so then all other synchronized computers end up having their\n//   settings reset to their default values.)\n//\n// * Provides a snapshot of all options with their default values filled-in for\n//   passing to the content process.\nimport Bugsnag from '@birchill/bugsnag-zero';\nimport browser from 'webextension-polyfill';\n\nimport { FxLocalData, getLocalFxData } from '../background/fx-data';\nimport { isObject } from '../utils/is-object';\nimport { stripFields } from '../utils/strip-fields';\nimport { isSafari } from '../utils/ua-utils';\n\nimport type {\n  AccentDisplay,\n  AutoExpandableEntry,\n  ContentConfigParams,\n  FontFace,\n  FontSize,\n  HighlightStyle,\n  KeyboardKeys,\n  PartOfSpeechDisplay,\n  TabDisplay,\n} from './content-config-params';\nimport { DbLanguageId, dbLanguages } from './db-languages';\nimport { ExtensionStorageError } from './extension-storage-error';\nimport { PopupKeys, StoredKeyboardKeys } from './popup-keys';\nimport { PuckState } from './puck-state';\nimport {\n  ReferenceAbbreviation,\n  convertLegacyReference,\n  getReferencesForLang,\n} from './refs';\n\n// We represent the set of references that have been turned on as a series\n// of true or false values.\n//\n// It might seem like it's sufficient to just store the _set_ values (or\n// vice-versa) but that complicates matters when we introduce a new reference\n// type or change the default value of an existing reference type. Currently all\n// references as enabled by default, but we may wish to add a new reference type\n// that is disabled by default, or conditionally enabled by default (e.g. if we\n// find data for JLPT Nx levels, we might want to only enable it if the user has\n// already got the existing JLPT data enabled).\n//\n// By recording the references that have actually been changed by the user as\n// being either enabled or disabled we capture the user's intention more\n// accurately. Anything not set should use the default setting.\ntype KanjiReferenceFlagsV2 = { [key in ReferenceAbbreviation]?: boolean };\n\ninterface Settings {\n  accentDisplay?: AccentDisplay;\n  autoExpand?: Array<AutoExpandableEntry>;\n  bunproDisplay?: boolean;\n  contextMenuEnable?: boolean;\n  copyHeadwords?: 'common' | 'regular';\n  copyPos?: 'code' | 'none';\n  copySenses?: 'first' | 'all';\n  dictLang?: DbLanguageId;\n  enableTapLookup?: boolean;\n  fontFace?: FontFace;\n  fontSize?: FontSize;\n  fxCurrency?: string;\n  highlightStyle?: HighlightStyle;\n  holdToShowKeys?: string;\n  holdToShowImageKeys?: string;\n  kanjiReferencesV2?: KanjiReferenceFlagsV2;\n  keys?: Partial<StoredKeyboardKeys>;\n  localSettings?: {\n    canHover?: boolean;\n    popupInteractive?: boolean;\n    showPuck?: 'show' | 'hide';\n    puckState?: PuckState;\n  };\n  noTextHighlight?: boolean;\n  popupStyle?: string;\n  posDisplay?: PartOfSpeechDisplay;\n  preferredUnits?: 'metric' | 'imperial';\n  readingOnly?: boolean;\n  showKanjiComponents?: boolean;\n  showPriority?: boolean;\n  showRomaji?: boolean;\n  tabDisplay?: TabDisplay;\n  toolbarIcon?: 'default' | 'sky';\n  waniKaniVocabDisplay?: 'hide' | 'show-matches';\n}\n\ntype StorageChange = {\n  oldValue?: any;\n  newValue?: any;\n};\ntype ChangeDict = { [field: string]: StorageChange };\nexport type ChangeCallback = (changes: ChangeDict) => void;\n\n// The following references were added to this extension in a later version and\n// so we turn them off by default to avoid overwhelming users with too many\n// references.\nconst OFF_BY_DEFAULT_REFERENCES: Set<ReferenceAbbreviation> = new Set([\n  'busy_people',\n  'kanji_in_context',\n  'kodansha_compact',\n  'maniette',\n  'wk',\n]);\n\nexport class Config {\n  private fxData: FxLocalData | undefined;\n  private settings: Settings = {};\n  private readyPromise: Promise<void>;\n  private changeListeners: ChangeCallback[] = [];\n  private previousDefaultLang: DbLanguageId;\n\n  constructor() {\n    this.readyPromise = this.readSettings().then(async () => {\n      this.fxData = await getLocalFxData(this.onFxDataChange.bind(this));\n    });\n    this.previousDefaultLang = this.getDefaultLang();\n\n    this.onChange = this.onChange.bind(this);\n    browser.storage.onChanged.addListener(this.onChange);\n\n    this.onLanguageChange = this.onLanguageChange.bind(this);\n    self.addEventListener('languagechange', this.onLanguageChange);\n  }\n\n  private async readSettings() {\n    let settings;\n    try {\n      settings = await browser.storage.sync.get(null);\n    } catch {\n      settings = {};\n    }\n    try {\n      settings.localSettings = (\n        await browser.storage.local.get('settings')\n      ).settings;\n    } catch {\n      // Ignore\n    }\n    this.settings = settings;\n    await this.upgradeSettings();\n  }\n\n  private async upgradeSettings() {\n    // If we have old kanji reference settings but not new ones, upgrade them.\n    if (\n      this.settings.hasOwnProperty('kanjiReferences') &&\n      !this.settings.kanjiReferencesV2\n    ) {\n      const newSettings: KanjiReferenceFlagsV2 = {};\n      const existingSettings: { [key: string]: boolean } = (\n        this.settings as any\n      ).kanjiReferences;\n      for (const [ref, enabled] of Object.entries(existingSettings)) {\n        const newRef = convertLegacyReference(ref);\n        if (newRef) {\n          newSettings[newRef] = enabled;\n        }\n      }\n\n      this.settings.kanjiReferencesV2 = newSettings;\n      try {\n        await browser.storage.sync.set({\n          kanjiReferencesV2: newSettings,\n        });\n      } catch {\n        // If we failed to store the upgraded settings that's fine since at\n        // least the in-memory version of the settings has been upgraded.\n        // We'll try upgrading the stored settings next time we're loaded\n        // anyway.\n        console.error('Failed to upgrade kanji references settings');\n      }\n    }\n\n    // If we have old mouse onboarding prefs, drop them\n    if (this.settings.hasOwnProperty('hasDismissedMouseOnboarding')) {\n      try {\n        await browser.storage.sync.remove('hasDismissedMouseOnboarding');\n      } catch {\n        // Ignore\n      }\n    }\n\n    if (\n      this.settings.localSettings?.hasOwnProperty('hasUpgradedFromPreMouse') ||\n      this.settings.localSettings?.hasOwnProperty(\n        'numLookupsWithMouseOnboarding'\n      )\n    ) {\n      const localSettings = { ...this.settings.localSettings };\n      delete (localSettings as Record<string, unknown>).hasUpgradedFromPreMouse;\n      delete (localSettings as Record<string, unknown>)\n        .numLookupsWithMouseOnboarding;\n      this.settings.localSettings = localSettings;\n      try {\n        await browser.storage.local.set({ settings: localSettings });\n      } catch {\n        // Ignore\n      }\n    }\n  }\n\n  get ready(): Promise<void> {\n    return this.readyPromise;\n  }\n\n  private async onChange(changes: ChangeDict, areaName: string) {\n    // Safari bug https://bugs.webkit.org/show_bug.cgi?id=281644 means that\n    // `areaName` is undefined in Safari 18.\n    if (!isSafari() && areaName !== 'sync' && areaName !== 'local') {\n      return;\n    }\n\n    // Re-read settings in case the changes were made by a different instance of\n    // this class.\n    await this.readSettings();\n\n    // Extract the changes in a suitable form\n    //\n    // We should be able to key this on `areaName` but since Safari 18 doesn't\n    // set that properly, we have to inspect the actual changes instead.\n    let updatedChanges = { ...changes };\n    if (typeof updatedChanges.settings !== 'undefined') {\n      const localSettings = updatedChanges.settings;\n      delete updatedChanges.settings;\n      updatedChanges = {\n        ...updatedChanges,\n        ...this.extractLocalSettingChanges(localSettings),\n      };\n    }\n\n    // Fill in default setting values\n    for (const key of Object.keys(updatedChanges)) {\n      switch (key) {\n        case 'dictLang':\n          updatedChanges.dictLang = { ...changes.dictLang };\n          if (!updatedChanges.dictLang.newValue) {\n            updatedChanges.dictLang.newValue = this.dictLang;\n          }\n          if (!updatedChanges.dictLang.oldValue) {\n            updatedChanges.dictLang.oldValue = this.previousDefaultLang;\n          }\n          break;\n\n        // Following is just the set of properties we know we actually inspect\n        // the `newValue` of. We don't have a convenient means of fetching the\n        // default value to fill in the oldValue, but we don't currently need\n        // it either.\n        case 'contextMenuEnable':\n        case 'popupStyle':\n        case 'toolbarIcon':\n          updatedChanges[key] = { ...changes[key] };\n          if (\n            typeof updatedChanges[key].newValue === 'undefined' ||\n            updatedChanges[key].newValue === null\n          ) {\n            updatedChanges[key].newValue = this[key];\n          }\n          break;\n\n        // Rename the kanji reference key since the name we use to store it\n        // differs from the name we expose via our API.\n        case 'kanjiReferencesV2':\n          updatedChanges.kanjiReferences = changes.kanjiReferencesV2;\n          delete updatedChanges.kanjiReferencesV2;\n          break;\n\n        // In some cases, the pinPopup key is calculated from the holdToShowKeys\n        // value so we might need to report that too.\n        case 'holdToShowKeys':\n          // If...\n          if (\n            // We are already reporting a change to `keys`, or\n            Object.keys(updatedChanges).includes('keys') ||\n            // The pinPopup key is already explicitly set\n            this.settings.keys?.pinPopup\n          ) {\n            // ... we don't need to report a change\n            break;\n          }\n          updatedChanges.keys = { newValue: this.keys };\n          break;\n      }\n    }\n\n    if (!Object.keys(updatedChanges).length) {\n      return;\n    }\n\n    Bugsnag.leaveBreadcrumb('Settings change', updatedChanges);\n\n    for (const listener of this.changeListeners) {\n      listener(updatedChanges);\n    }\n  }\n\n  private async onFxDataChange(fxData: FxLocalData) {\n    this.fxData = fxData;\n\n    const updatedChanges: ChangeDict = {\n      fxCurrencies: { newValue: this.fxCurrencies },\n      fx: { newValue: this.contentConfig.fx },\n    };\n\n    for (const listener of this.changeListeners) {\n      listener(updatedChanges);\n    }\n  }\n\n  private extractLocalSettingChanges(\n    settingsChange: StorageChange\n  ): ChangeDict {\n    if (!isObject(settingsChange)) {\n      return {};\n    }\n\n    const settings = [\n      ...new Set([\n        ...Object.keys(settingsChange.newValue || {}),\n        ...Object.keys(settingsChange.oldValue || {}),\n      ]),\n    ];\n\n    const result: ChangeDict = {};\n    for (const setting of settings) {\n      result[setting] = {\n        newValue: settingsChange.newValue?.[setting],\n        oldValue: settingsChange.oldValue?.[setting],\n      };\n    }\n\n    return result;\n  }\n\n  addChangeListener(callback: ChangeCallback) {\n    if (this.changeListeners.indexOf(callback) !== -1) {\n      return;\n    }\n    this.changeListeners.push(callback);\n  }\n\n  removeChangeListener(callback: ChangeCallback) {\n    const index = this.changeListeners.indexOf(callback);\n    if (index === -1) {\n      return;\n    }\n    this.changeListeners.splice(index, 1);\n  }\n\n  //\n  // Property accessors\n  //\n\n  // Ultimately we want to do away with all this boilerplate and use decorators\n  // to generate this code.\n  //\n  // Something like:\n  //\n  //   function syncedPref<T>(defaultValue: T) {\n  //     return (\n  //       _value: {\n  //         get: () => T;\n  //         set: (value: T) => void;\n  //       },\n  //       context: {\n  //         kind: 'accessor';\n  //         name: keyof Settings;\n  //         static: boolean;\n  //         private: boolean;\n  //         access: {\n  //           get: (object: Config) => T;\n  //           set: (object: Config, value: T) => void;\n  //         };\n  //         addInitializer(initializer: () => void): void;\n  //       }\n  //     ): {\n  //       get?: (this: Config) => T;\n  //       set?: (this: Config, value: unknown) => void;\n  //       init?: (this: Config, initialValue: T) => T;\n  //     } | void => {\n  //       return {\n  //         get: () => this.settings[context.name] ?? defaultValue,\n  //         set: (value: T) => {\n  //           if (this.settings[context.name] === value) {\n  //             return;\n  //           }\n  //\n  //           if (value === defaultValue) {\n  //             delete this.settings[context.name];\n  //             void browser.storage.sync.remove(context.name);\n  //           } else {\n  //             this.settings[context.name] = value;\n  //             void browser.storage.sync.set({ [context.name]: value });\n  //           }\n  //         },\n  //       };\n  //     };\n  //   }\n  //\n  // Usage:\n  //\n  //   @syncedPref<'common' | 'regular' | undefined>('regular')\n  //   accessor copyHeadwords: 'common' | 'regular' | undefined;\n  //\n  // (Come to think of it, once we do that each accessor will have its own\n  // storage so we can skip writing to this.settings and just use\n  // _value.get.call(this) etc.)\n  //\n  // (Also, we should make the generated getter/setter exclude `undefined` from\n  // `T`).\n  //\n  // Unfortunately, while TypeScript can transpile that, we use vitest for our\n  // unit tests which uses esbuild under the hood which doesn't yet support\n  // decorators and in any case, won't transpile them:\n  //\n  //   https://github.com/evanw/esbuild/issues/104\n  //\n  // UPDATE: Looks like support was added for decorators as of esbuild v0.21.3\n  // https://github.com/evanw/esbuild/releases/tag/v0.21.3\n  //\n  // Our options are either to use SWC (which runs the risk of behaving a bit\n  // differently to TypeScript) or try to get TSC to transpile the relevant\n  // files, e.g. using https://github.com/thomaschaaf/esbuild-plugin-tsc\n  //\n  // Unfortunately apparently vitest doesn't support esbuild plugins so that\n  // last option probably won't work.\n  //\n  // Decorators are being implemented in browsers (e.g. Firefox bug:\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1781212) so one day they should\n  // be available in esbuild and vitest too.\n\n  // accentDisplay: Defaults to binary\n\n  get accentDisplay(): AccentDisplay {\n    return typeof this.settings.accentDisplay === 'undefined'\n      ? 'binary'\n      : this.settings.accentDisplay;\n  }\n\n  set accentDisplay(value: AccentDisplay) {\n    if (\n      typeof this.settings.accentDisplay !== 'undefined' &&\n      this.settings.accentDisplay === value\n    ) {\n      return;\n    }\n\n    this.settings.accentDisplay = value;\n    void browser.storage.sync.set({ accentDisplay: value });\n  }\n\n  // autoExpand: Defaults to an empty array\n\n  get autoExpand(): Array<AutoExpandableEntry> {\n    return typeof this.settings.autoExpand === 'undefined'\n      ? []\n      : [...new Set(this.settings.autoExpand)];\n  }\n\n  toggleAutoExpand(type: AutoExpandableEntry, value: boolean) {\n    const enabled = new Set(this.settings.autoExpand);\n    if (value === enabled.has(type)) {\n      return;\n    }\n\n    if (value) {\n      enabled.add(type);\n    } else {\n      enabled.delete(type);\n    }\n\n    if (enabled.size) {\n      this.settings.autoExpand = [...enabled];\n      void browser.storage.sync.set({ autoExpand: [...enabled] });\n    } else {\n      delete this.settings.autoExpand;\n      void browser.storage.sync.remove('autoExpand');\n    }\n  }\n\n  // canHover (local): Defaults to true\n\n  get canHover(): boolean {\n    return this.settings.localSettings?.canHover ?? true;\n  }\n\n  set canHover(value: boolean) {\n    const storedSetting = this.settings.localSettings?.canHover;\n    if (storedSetting === value || (storedSetting === undefined && value)) {\n      return;\n    }\n\n    const localSettings = { ...this.settings.localSettings };\n    if (value) {\n      delete localSettings.canHover;\n    } else {\n      localSettings.canHover = false;\n    }\n    this.settings.localSettings = localSettings;\n    void browser.storage.local.set({ settings: localSettings });\n  }\n\n  // bunproDisplay: Defaults to false\n\n  get bunproDisplay(): boolean {\n    return !!this.settings.bunproDisplay;\n  }\n\n  set bunproDisplay(value: boolean) {\n    if (this.settings.bunproDisplay === (value || undefined)) {\n      return;\n    }\n\n    if (!value) {\n      delete this.settings.bunproDisplay;\n      void browser.storage.sync.remove('bunproDisplay');\n    } else {\n      this.settings.bunproDisplay = value;\n      void browser.storage.sync.set({ bunproDisplay: value });\n    }\n  }\n\n  // contextMenuEnable: Defaults to true\n\n  get contextMenuEnable(): boolean {\n    return (\n      typeof this.settings.contextMenuEnable === 'undefined' ||\n      this.settings.contextMenuEnable\n    );\n  }\n\n  set contextMenuEnable(value: boolean) {\n    if (\n      typeof this.settings.contextMenuEnable !== 'undefined' &&\n      this.settings.contextMenuEnable === value\n    ) {\n      return;\n    }\n\n    this.settings.contextMenuEnable = value;\n    void browser.storage.sync.set({ contextMenuEnable: value });\n  }\n\n  // copyHeadwords: Defaults to 'regular'\n\n  get copyHeadwords(): 'common' | 'regular' {\n    return this.settings.copyHeadwords || 'regular';\n  }\n\n  set copyHeadwords(value: 'common' | 'regular') {\n    if (this.settings.copyHeadwords === value) {\n      return;\n    }\n\n    if (value === 'regular') {\n      delete this.settings.copyHeadwords;\n      void browser.storage.sync.remove('copyHeadwords');\n    } else {\n      this.settings.copyHeadwords = value;\n      void browser.storage.sync.set({ copyHeadwords: value });\n    }\n  }\n\n  // copyPos: Defaults to 'code'\n\n  get copyPos(): 'code' | 'none' {\n    return this.settings.copyPos || 'code';\n  }\n\n  set copyPos(value: 'code' | 'none') {\n    if (this.settings.copyPos === value) {\n      return;\n    }\n\n    if (value === 'code') {\n      delete this.settings.copyPos;\n      void browser.storage.sync.remove('copyPos');\n    } else {\n      this.settings.copyPos = value;\n      void browser.storage.sync.set({ copyPos: value });\n    }\n  }\n\n  // copySenses: Defaults to 'all'\n\n  get copySenses(): 'first' | 'all' {\n    return this.settings.copySenses || 'all';\n  }\n\n  set copySenses(value: 'first' | 'all') {\n    if (this.settings.copySenses === value) {\n      return;\n    }\n\n    if (value === 'all') {\n      delete this.settings.copySenses;\n      void browser.storage.sync.remove('copySenses');\n    } else {\n      this.settings.copySenses = value;\n      void browser.storage.sync.set({ copySenses: value });\n    }\n  }\n\n  // dictLang: Defaults to the first match from navigator.languages found in\n  // dbLanguages, or 'en' otherwise.\n\n  get dictLang(): DbLanguageId {\n    return this.useDefaultLang()\n      ? this.getDefaultLang()\n      : this.settings.dictLang!;\n  }\n\n  set dictLang(value: DbLanguageId) {\n    if (this.settings.dictLang && this.settings.dictLang === value) {\n      return;\n    }\n\n    // Note that we don't need to check that `value` is valid since TypeScript\n    // does that for us.\n\n    // If the value to set matches the default we clear the setting. This is so\n    // that if we later support one of the user's more preferred languages we\n    // can update them automatically.\n    if (value === this.getDefaultLang()) {\n      browser.storage.sync.remove('dictLang').catch((e) => {\n        void Bugsnag.notify(\n          new ExtensionStorageError(\n            { key: 'dictLang', action: 'remove' },\n            { cause: e }\n          ),\n          { severity: 'warning' }\n        );\n      });\n      delete this.settings.dictLang;\n    } else {\n      browser.storage.sync.set({ dictLang: value }).catch((e) => {\n        void Bugsnag.notify(\n          new ExtensionStorageError(\n            { key: 'dictLang', action: 'set' },\n            { cause: e }\n          ),\n          { severity: 'warning' }\n        );\n      });\n      this.settings.dictLang = value;\n    }\n  }\n\n  private useDefaultLang(): boolean {\n    // Check that the language that is set is valid. It might be invalid if we\n    // deprecated a language or we synced a value from a newer version of the\n    // extension.\n    if (this.settings.dictLang) {\n      return !dbLanguages.includes(this.settings.dictLang);\n    }\n\n    return true;\n  }\n\n  private getDefaultLang(): DbLanguageId {\n    const availableLanguages = new Set(dbLanguages);\n    for (const lang of navigator.languages) {\n      const langCode = lang.split('-')[0];\n      if (availableLanguages.has(langCode as DbLanguageId)) {\n        return langCode as DbLanguageId;\n      }\n    }\n\n    return 'en';\n  }\n\n  onLanguageChange() {\n    // If the user's accept-languages setting changed AND we are basing the\n    // dictLang value on that we should notify listeners of the change.\n    if (!this.useDefaultLang()) {\n      return;\n    }\n\n    const newValue = this.getDefaultLang();\n    if (this.previousDefaultLang !== newValue) {\n      const oldValue = this.previousDefaultLang;\n      this.previousDefaultLang = newValue;\n      const changes: ChangeDict = { dictLang: { newValue, oldValue } };\n      for (const listener of this.changeListeners) {\n        listener(changes);\n      }\n    }\n  }\n\n  // enableTapLookup: Defaults to true\n\n  get enableTapLookup(): boolean {\n    return this.settings.enableTapLookup ?? true;\n  }\n\n  set enableTapLookup(value: boolean) {\n    const storedSetting = this.settings.enableTapLookup;\n    if (storedSetting === value) {\n      return;\n    }\n\n    if (value) {\n      void browser.storage.sync.remove('enableTapLookup');\n      delete this.settings.enableTapLookup;\n    } else {\n      void browser.storage.sync.set({ enableTapLookup: value });\n      this.settings.enableTapLookup = value;\n    }\n  }\n\n  // fontFace: Defaults to 'bundled'\n\n  get fontFace(): FontFace {\n    return this.settings.fontFace === undefined\n      ? 'bundled'\n      : this.settings.fontFace;\n  }\n\n  set fontFace(value: FontFace) {\n    if (\n      (this.settings.fontFace !== undefined &&\n        this.settings.fontFace === value) ||\n      (typeof this.settings.fontFace === 'undefined' && value === 'bundled')\n    ) {\n      return;\n    }\n\n    if (value !== 'bundled') {\n      this.settings.fontFace = value;\n      void browser.storage.sync.set({ fontFace: value });\n    } else {\n      this.settings.fontFace = undefined;\n      void browser.storage.sync.remove('fontFace');\n    }\n  }\n\n  // fontSize: Defaults to normal\n\n  get fontSize(): FontSize {\n    return typeof this.settings.fontSize === 'undefined'\n      ? 'normal'\n      : this.settings.fontSize;\n  }\n\n  set fontSize(value: FontSize) {\n    if (\n      typeof this.settings.fontSize !== 'undefined' &&\n      this.settings.fontSize === value\n    ) {\n      return;\n    }\n\n    if (value === 'normal') {\n      this.settings.fontSize = undefined;\n      void browser.storage.sync.remove('fontSize');\n    } else {\n      this.settings.fontSize = value;\n      void browser.storage.sync.set({ fontSize: value });\n    }\n  }\n\n  // fxCurrency: Defaults to USD\n\n  get fxCurrency(): string {\n    return typeof this.settings.fxCurrency === 'string'\n      ? this.settings.fxCurrency\n      : 'USD';\n  }\n\n  set fxCurrency(value: string) {\n    const storedSetting = this.settings.fxCurrency;\n    if (value === storedSetting) {\n      return;\n    }\n\n    // Unlike many other settings, we don't reset the setting if the user\n    // chooses the default value ('USD') since in this case we treat it as an\n    // explicit signal they want currencies displayed in USD even if we later\n    // change the default.\n    void browser.storage.sync.set({ fxCurrency: value });\n    this.settings.fxCurrency = value;\n  }\n\n  get fxCurrencies(): Array<string> | undefined {\n    return this.fxData\n      ? Object.keys(this.fxData.rates).sort((a, b) => a.localeCompare(b))\n      : undefined;\n  }\n\n  // highlightStyle: Defaults to 'yellow'\n\n  get highlightStyle(): HighlightStyle {\n    return this.settings.highlightStyle ?? 'yellow';\n  }\n\n  set highlightStyle(value: HighlightStyle) {\n    if (this.highlightStyle === value) {\n      return;\n    }\n\n    if (value === 'yellow') {\n      this.settings.highlightStyle = undefined;\n      void browser.storage.sync.remove('highlightStyle');\n    } else {\n      this.settings.highlightStyle = value;\n      void browser.storage.sync.set({ highlightStyle: value });\n    }\n  }\n\n  // holdToShowKeys: Defaults to null\n\n  get holdToShowKeys(): string | null {\n    return typeof this.settings.holdToShowKeys === 'string'\n      ? this.settings.holdToShowKeys\n      : null;\n  }\n\n  set holdToShowKeys(value: string | null) {\n    const storedSetting = this.settings.holdToShowKeys || null;\n    if (value === storedSetting) {\n      return;\n    }\n\n    if (value === null) {\n      void browser.storage.sync.remove('holdToShowKeys');\n      delete this.settings.holdToShowKeys;\n    } else {\n      void browser.storage.sync.set({ holdToShowKeys: value });\n      this.settings.holdToShowKeys = value;\n    }\n\n    // If holdToShowImageKeys was mirroring this setting, save the previous\n    // value as its own value.\n    if (typeof this.settings.holdToShowImageKeys === 'undefined') {\n      this.holdToShowImageKeys = storedSetting;\n    }\n    // Otherwise, if we have cleared this setting and holdToShowImageKeys was\n    // storing 'none' just to differentiate itself from us, we can clear that\n    // stored value now.\n    else if (!value && this.settings.holdToShowImageKeys === 'none') {\n      this.holdToShowImageKeys = null;\n    }\n  }\n\n  // holdToShowImageKeys: Default is... complicated.\n  //\n  // This setting was introduced after the \"holdToShowKeys\" setting was\n  // introduced and we want the default behavior to be:\n  //\n  // - For new users, nothing, since that's the default for \"holdToShow\" keys\n  //   and it makes sense to surface this by default and let users who find it\n  //   annoying turn it off.\n  //\n  // - For users who have previously configured a \"holdToShowKeys\" setting,\n  //   the same value as the \"holdToShowKeys\" setting since previously that\n  //   setting controlled this behavior.\n  //\n  // But how do we distinguish between a user who has previously configured the\n  // \"holdToShowKeys\" setting (meaning we should mirror that value here) vs one\n  // who has configured the \"holdToShowKeys\" setting _since_ this setting was\n  // introduced and deliberately wants different behavior to that setting?\n  //\n  // We achieve that by deliberately storing \"none\" as the value for this\n  // setting any time we alter the \"holdToShowKeys\" setting while this is null.\n\n  get holdToShowImageKeys(): string | null {\n    // If there is an explicit setting for this value, use that.\n    if (typeof this.settings.holdToShowImageKeys === 'string') {\n      return this.settings.holdToShowImageKeys === 'none'\n        ? null\n        : this.settings.holdToShowImageKeys;\n    }\n\n    // Otherwise, mirror the holdToShowKeys setting\n    return this.holdToShowKeys;\n  }\n\n  set holdToShowImageKeys(value: string | null) {\n    // If this is null AND holdToShowKeys is null, then we can clear the local\n    // setting. We only need to store 'none' if holdToShowKeys is set (in order\n    // to ensure we DON'T mirror that setting).\n    const settingToStore =\n      value === null && this.holdToShowKeys ? 'none' : value;\n\n    // Ignore null-op changes\n    const storedSetting = this.settings.holdToShowImageKeys || null;\n    if (settingToStore === storedSetting) {\n      return;\n    }\n\n    if (settingToStore === null) {\n      void browser.storage.sync.remove('holdToShowImageKeys');\n      delete this.settings.holdToShowImageKeys;\n    } else {\n      void browser.storage.sync.set({ holdToShowImageKeys: settingToStore });\n      this.settings.holdToShowImageKeys = settingToStore;\n    }\n  }\n\n  // kanjiReferences: Defaults to true for all but a few references\n  // that were added more recently.\n\n  get kanjiReferences(): Array<ReferenceAbbreviation> {\n    const setValues = this.settings.kanjiReferencesV2 || {};\n    const result: Array<ReferenceAbbreviation> = [];\n    for (const ref of getReferencesForLang(this.dictLang)) {\n      if (typeof setValues[ref] === 'undefined') {\n        if (!OFF_BY_DEFAULT_REFERENCES.has(ref)) {\n          result.push(ref);\n        }\n      } else if (setValues[ref]) {\n        result.push(ref);\n      }\n    }\n    return result;\n  }\n\n  updateKanjiReferences(updatedReferences: KanjiReferenceFlagsV2) {\n    const existingSettings = this.settings.kanjiReferencesV2 || {};\n    this.settings.kanjiReferencesV2 = {\n      ...existingSettings,\n      ...updatedReferences,\n    };\n    void browser.storage.sync.set({\n      kanjiReferencesV2: this.settings.kanjiReferencesV2,\n    });\n  }\n\n  // keys: Defaults are defined by DEFAULT_KEY_SETTINGS, and particularly the\n  // enabledKeys member.\n\n  private getDefaultEnabledKeys(): StoredKeyboardKeys {\n    return PopupKeys.reduce<Partial<StoredKeyboardKeys>>(\n      (defaultKeys, setting) => {\n        defaultKeys[setting.name] = setting.enabledKeys;\n        return defaultKeys;\n      },\n      {}\n    ) as StoredKeyboardKeys;\n  }\n\n  get keys(): StoredKeyboardKeys {\n    const setValues = this.settings.keys || {};\n    const keys = { ...this.getDefaultEnabledKeys(), ...setValues };\n\n    // If there is no key set for the pin popup key, but there _is_ a suitable\n    // hold-to-show key set, we should use that as the default value.\n    //\n    // (Note that all this complexity might be meaningless. At least on Firefox\n    // on Windows, no one in their right mind would configure Alt as their\n    // hold-to-show key. Every time you release it the menu pops up!)\n    if (!('pinPopup' in setValues)) {\n      // Hold-to-show keys contains a string like `Alt+Ctrl` but we can only\n      // re-use the hold-to-show keys when it's a single item like 'Alt'.\n      const holdToShowKeys = this.holdToShowKeys?.split('+');\n      if (holdToShowKeys?.length === 1) {\n        const holdToShowKey = holdToShowKeys[0];\n        const availableKeys = PopupKeys.find((k) => k.name === 'pinPopup');\n        if (availableKeys?.keys.includes(holdToShowKey)) {\n          keys.pinPopup = [holdToShowKey];\n        }\n      }\n    }\n\n    // When we first released the `expandPopup` key ('x') we didn't notice\n    // that it was already possible to assign 'x' to `closePopup`.\n    //\n    // We _could_ try to make it so that if you assign 'x' to `expandPopup` we\n    // remove it from `closePopup`. But it might be slightly more useful to\n    // allow it to be assigned to both and simply report it as being assigned to\n    // `closePopup` in that case.\n    //\n    // That has the advantages that:\n    //\n    // 1. If you go to enable it for `closePopup` and notice that doing so\n    //    clears it from `expandPopup`, you can just untick it from `closePopup`\n    //    and it will automatically be restored to `expandPopup`.\n    //\n    // 2. We need to handle the case when they're both selected anyway since\n    //    it's already possible to get it into that state in a released version.\n    if (keys.expandPopup.includes('x') && keys.closePopup.includes('x')) {\n      keys.expandPopup = keys.expandPopup.filter((k) => k !== 'x');\n    }\n\n    return keys;\n  }\n\n  get keysNormalized(): KeyboardKeys {\n    const storedKeys = this.keys;\n    const [down, up] = this.keys.movePopupDownOrUp\n      .map((key) => key.split(',', 2))\n      .reduce<[Array<string>, Array<string>]>(\n        ([existingDown, existingUp], [down, up]) => [\n          [...existingDown, down],\n          [...existingUp, up],\n        ],\n        [[], []]\n      );\n\n    return {\n      ...stripFields(storedKeys, ['movePopupDownOrUp']),\n      movePopupDown: down,\n      movePopupUp: up,\n    };\n  }\n\n  updateKeys(keys: Partial<StoredKeyboardKeys>) {\n    const existingSettings = this.settings.keys || {};\n    this.settings.keys = {\n      ...existingSettings,\n      ...keys,\n    };\n\n    void browser.storage.sync.set({ keys: this.settings.keys });\n  }\n\n  // noTextHighlight: Defaults to false\n\n  get noTextHighlight(): boolean {\n    return !!this.settings.noTextHighlight;\n  }\n\n  set noTextHighlight(value: boolean) {\n    if (\n      typeof this.settings.noTextHighlight !== 'undefined' &&\n      this.settings.noTextHighlight === value\n    ) {\n      return;\n    }\n\n    this.settings.noTextHighlight = value;\n    void browser.storage.sync.set({ noTextHighlight: value });\n  }\n\n  // popupInteractive (local): Defaults to true\n\n  get popupInteractive(): boolean {\n    return this.settings.localSettings?.popupInteractive ?? true;\n  }\n\n  set popupInteractive(value: boolean) {\n    const storedSetting = this.settings.localSettings?.popupInteractive;\n    if (storedSetting === value) {\n      return;\n    }\n\n    const localSettings = { ...this.settings.localSettings };\n    if (value) {\n      delete localSettings.popupInteractive;\n    } else {\n      localSettings.popupInteractive = false;\n    }\n    this.settings.localSettings = localSettings;\n    void browser.storage.local.set({ settings: localSettings });\n  }\n\n  // popupStyle: Defaults to 'default'\n\n  get popupStyle(): string {\n    return typeof this.settings.popupStyle === 'undefined'\n      ? 'default'\n      : this.settings.popupStyle;\n  }\n\n  set popupStyle(value: string) {\n    if (\n      (typeof this.settings.popupStyle !== 'undefined' &&\n        this.settings.popupStyle === value) ||\n      (typeof this.settings.popupStyle === 'undefined' && value === 'default')\n    ) {\n      return;\n    }\n\n    if (value !== 'default') {\n      this.settings.popupStyle = value;\n      void browser.storage.sync.set({ popupStyle: value });\n    } else {\n      this.settings.popupStyle = undefined;\n      void browser.storage.sync.remove('popupStyle');\n    }\n  }\n\n  // posDisplay: Defaults to expl\n\n  get posDisplay(): PartOfSpeechDisplay {\n    return typeof this.settings.posDisplay === 'undefined'\n      ? 'expl'\n      : this.settings.posDisplay;\n  }\n\n  set posDisplay(value: PartOfSpeechDisplay) {\n    if (\n      typeof this.settings.posDisplay !== 'undefined' &&\n      this.settings.posDisplay === value\n    ) {\n      return;\n    }\n\n    this.settings.posDisplay = value;\n    void browser.storage.sync.set({ posDisplay: value });\n  }\n\n  // preferredUnits: Defaults to 'metric'\n\n  get preferredUnits(): 'metric' | 'imperial' {\n    return this.settings.preferredUnits || 'metric';\n  }\n\n  set preferredUnits(value: 'metric' | 'imperial') {\n    if (this.settings.preferredUnits === value) {\n      return;\n    }\n\n    this.settings.preferredUnits = value;\n    void browser.storage.sync.set({ preferredUnits: value });\n  }\n\n  // readingOnly: Defaults to false\n\n  get readingOnly(): boolean {\n    return !!this.settings.readingOnly;\n  }\n\n  set readingOnly(value: boolean) {\n    if (\n      typeof this.settings.readingOnly !== 'undefined' &&\n      this.settings.readingOnly === value\n    ) {\n      return;\n    }\n\n    this.settings.readingOnly = value;\n    void browser.storage.sync.set({ readingOnly: value });\n  }\n\n  toggleReadingOnly() {\n    this.readingOnly = !this.settings.readingOnly;\n  }\n\n  // showKanjiComponents: Defaults to true\n\n  get showKanjiComponents(): boolean {\n    return (\n      typeof this.settings.showKanjiComponents === 'undefined' ||\n      this.settings.showKanjiComponents\n    );\n  }\n\n  set showKanjiComponents(value: boolean) {\n    this.settings.showKanjiComponents = value;\n    void browser.storage.sync.set({ showKanjiComponents: value });\n  }\n\n  // showPriority: Defaults to true\n\n  get showPriority(): boolean {\n    return (\n      typeof this.settings.showPriority === 'undefined' ||\n      this.settings.showPriority\n    );\n  }\n\n  set showPriority(value: boolean) {\n    this.settings.showPriority = value;\n    void browser.storage.sync.set({ showPriority: value });\n  }\n\n  // showPuck (local): Defaults to 'auto'\n\n  get showPuck(): 'show' | 'hide' | 'auto' {\n    return this.settings.localSettings?.showPuck || 'auto';\n  }\n\n  set showPuck(value: 'show' | 'hide' | 'auto') {\n    const storedSetting = this.settings.localSettings?.showPuck || 'auto';\n    if (storedSetting === value) {\n      return;\n    }\n\n    const localSettings = { ...this.settings.localSettings };\n    if (value === 'auto') {\n      delete localSettings.showPuck;\n    } else {\n      localSettings.showPuck = value;\n    }\n    this.settings.localSettings = localSettings;\n\n    // If value is 'hide' we should reset the puck state but since that writes\n    // to the same key in local storage we should wait for the current write to\n    // complete first.\n    void browser.storage.local.set({ settings: localSettings }).finally(() => {\n      if (value === 'hide') {\n        this.puckState = undefined;\n      }\n    });\n  }\n\n  get computedShowPuck(): 'show' | 'hide' {\n    return this.showPuck !== 'auto'\n      ? this.showPuck\n      : this.canHover\n        ? 'hide'\n        : 'show';\n  }\n\n  // Puck state (local): Defaults to undefined\n\n  get puckState(): PuckState | undefined {\n    return this.settings.localSettings?.puckState;\n  }\n\n  set puckState(value: PuckState | undefined) {\n    const storedSetting = this.settings.localSettings?.puckState;\n    if (JSON.stringify(storedSetting) === JSON.stringify(value)) {\n      return;\n    }\n\n    const localSettings = { ...this.settings.localSettings };\n    if (!value) {\n      delete localSettings.puckState;\n    } else {\n      localSettings.puckState = value;\n    }\n    this.settings.localSettings = localSettings;\n\n    void browser.storage.local.set({ settings: localSettings });\n  }\n\n  // showRomaji: Defaults to false\n\n  get showRomaji(): boolean {\n    return !!this.settings.showRomaji;\n  }\n\n  set showRomaji(value: boolean) {\n    if (this.settings.showRomaji === value) {\n      return;\n    }\n\n    if (!value) {\n      delete this.settings.showRomaji;\n      void browser.storage.sync.remove('showRomaji');\n    } else {\n      this.settings.showRomaji = value;\n      void browser.storage.sync.set({ showRomaji: value });\n    }\n  }\n\n  // waniKaniVocabDisplay: Defaults to 'hide'\n\n  get waniKaniVocabDisplay(): 'hide' | 'show-matches' {\n    return this.settings.waniKaniVocabDisplay || 'hide';\n  }\n\n  set waniKaniVocabDisplay(value: 'hide' | 'show-matches') {\n    if (this.settings.waniKaniVocabDisplay === value) {\n      return;\n    }\n\n    if (value === 'hide') {\n      delete this.settings.waniKaniVocabDisplay;\n      void browser.storage.sync.remove('waniKaniVocabDisplay');\n    } else {\n      this.settings.waniKaniVocabDisplay = value;\n      void browser.storage.sync.set({ waniKaniVocabDisplay: value });\n    }\n  }\n\n  // tabDisplay: Defaults to 'top'\n\n  get tabDisplay(): TabDisplay {\n    return typeof this.settings.tabDisplay === 'undefined'\n      ? 'top'\n      : this.settings.tabDisplay;\n  }\n\n  set tabDisplay(value: TabDisplay) {\n    if (\n      (typeof this.settings.tabDisplay !== 'undefined' &&\n        this.settings.tabDisplay === value) ||\n      (typeof this.settings.tabDisplay === 'undefined' && value === 'top')\n    ) {\n      return;\n    }\n\n    if (value !== 'top') {\n      this.settings.tabDisplay = value;\n      void browser.storage.sync.set({ tabDisplay: value });\n    } else {\n      this.settings.tabDisplay = undefined;\n      void browser.storage.sync.remove('tabDisplay');\n    }\n  }\n\n  // toolbarIcon: Defaults to 'default'\n\n  get toolbarIcon(): 'default' | 'sky' {\n    return typeof this.settings.toolbarIcon === 'undefined'\n      ? 'default'\n      : this.settings.toolbarIcon;\n  }\n\n  set toolbarIcon(value: 'default' | 'sky') {\n    if (\n      (typeof this.settings.toolbarIcon !== 'undefined' &&\n        this.settings.toolbarIcon === value) ||\n      (typeof this.settings.toolbarIcon === 'undefined' && value === 'default')\n    ) {\n      return;\n    }\n\n    if (value !== 'default') {\n      this.settings.toolbarIcon = value;\n      void browser.storage.sync.set({ toolbarIcon: value });\n    } else {\n      this.settings.toolbarIcon = undefined;\n      void browser.storage.sync.remove('toolbarIcon');\n    }\n  }\n\n  // Get all the options the content process cares about at once\n  get contentConfig(): ContentConfigParams {\n    return {\n      accentDisplay: this.accentDisplay,\n      autoExpand: this.autoExpand,\n      bunproDisplay: this.bunproDisplay,\n      copyHeadwords: this.copyHeadwords,\n      copyPos: this.copyPos,\n      copySenses: this.copySenses,\n      dictLang: this.dictLang,\n      enableTapLookup: this.enableTapLookup,\n      fx:\n        this.fxData && this.fxCurrency in this.fxData.rates\n          ? {\n              currency: this.fxCurrency,\n              rate: this.fxData.rates[this.fxCurrency],\n              timestamp: this.fxData.timestamp,\n            }\n          : undefined,\n      fontFace: this.fontFace,\n      fontSize: this.fontSize,\n      highlightStyle: this.highlightStyle,\n      holdToShowKeys: this.holdToShowKeys\n        ? (this.holdToShowKeys.split('+') as Array<'Ctrl' | 'Alt'>)\n        : [],\n      holdToShowImageKeys: this.holdToShowImageKeys\n        ? (this.holdToShowImageKeys.split('+') as Array<'Ctrl' | 'Alt'>)\n        : [],\n      kanjiReferences: this.kanjiReferences,\n      keys: this.keysNormalized,\n      noTextHighlight: this.noTextHighlight,\n      popupInteractive: this.popupInteractive,\n      popupStyle: this.popupStyle,\n      posDisplay: this.posDisplay,\n      preferredUnits: this.preferredUnits,\n      puckState: this.puckState,\n      readingOnly: this.readingOnly,\n      showKanjiComponents: this.showKanjiComponents,\n      showPriority: this.showPriority,\n      showPuck: this.showPuck,\n      showRomaji: this.showRomaji,\n      tabDisplay: this.tabDisplay,\n      toolbarIcon: this.toolbarIcon,\n      waniKaniVocabDisplay: this.waniKaniVocabDisplay,\n    };\n  }\n}\n","import { JpdictState } from '../background/jpdict';\n\nexport const notifyDbStateUpdated = (state: JpdictState) => ({\n  type: 'dbstateupdated' as const,\n  state,\n});\n\nexport type DbStateUpdatedMessage = ReturnType<typeof notifyDbStateUpdated>;\n\nexport const updateDb = () => ({\n  type: 'updatedb' as const,\n});\n\nexport const cancelDbUpdate = () => ({\n  type: 'cancelupdatedb' as const,\n});\n\nexport const deleteDb = () => ({\n  type: 'deletedb' as const,\n});\n\nexport type DbListenerMessage =\n  | ReturnType<typeof notifyDbStateUpdated>\n  | ReturnType<typeof updateDb>\n  | ReturnType<typeof cancelDbUpdate>\n  | ReturnType<typeof deleteDb>;\n","import browser from 'webextension-polyfill';\n\nlet releaseStage: 'production' | 'development' = 'production';\n\nif (browser.management) {\n  browser.management\n    .getSelf()\n    .then((info) => {\n      if (info.installType === 'development') {\n        releaseStage = 'development';\n      }\n    })\n    .catch((e) => {\n      console.warn(e);\n    });\n}\n\nexport function getReleaseStage(): 'production' | 'development' {\n  return releaseStage;\n}\n","import Bugsnag, {\n  Event as BugsnagEvent,\n  appDuration,\n  browserContext,\n  browserHandledRejectionBreadcrumbs,\n  browserNotifyUnhandledExceptions,\n  browserNotifyUnhandledRejections,\n  consoleBreadcrumbs,\n  deviceOrientation,\n  errorBreadcrumbs,\n  fetchBreadcrumbs,\n  interactionBreadcrumbs,\n  limitEvents,\n  navigationBreadcrumbs,\n  stringifyValues,\n} from '@birchill/bugsnag-zero';\nimport browser from 'webextension-polyfill';\n\nimport { ExtensionStorageError } from '../common/extension-storage-error';\n\nimport { isObject } from './is-object';\nimport { getReleaseStage } from './release-stage';\n\nconst getExtensionInstallId = async (): Promise<string> => {\n  let internalUuid: string | undefined;\n  try {\n    // In Firefox, each install gets a unique internal UUID which differs from\n    // the extension ID (provided it is set through the\n    // browser_specific_settings in manifest.json).\n    //\n    // Specifically:\n    //\n    // browser.runtime.id = Extension ID\n    // browser.runtime.getURL('yer').host = Internal UUID\n    // browser.getMessage('@@extension_id') = Internal UUID\n    //\n    // In other browsers I think all of the above return the Extension ID.\n    // (I haven't checked Safari, however.)\n    //\n    // If that internal UUID is available, we use it because it is sometimes\n    // helpful when Firefox users contact us describing a bug, to be able to\n    // find error reports generated from their installation.\n    //\n    internalUuid = new URL(browser.runtime.getURL('yer')).host;\n  } catch {\n    // Ignore\n  }\n\n  if (internalUuid && internalUuid !== browser.runtime.id) {\n    return internalUuid;\n  }\n\n  // Generate/fetch a unique install ID since the browser doesn't provide one.\n  try {\n    let storedInstallId = (await browser.storage.local.get('installid'))\n      ?.installid;\n    if (typeof storedInstallId !== 'string') {\n      const installId = getRandomId();\n      await browser.storage.local.set({ installid: installId });\n      storedInstallId = installId;\n    }\n\n    return storedInstallId as string;\n  } catch {\n    // Ignore because we are probably already in the middle of reporting an error\n  }\n\n  return 'unknown';\n};\n\nfunction getRandomId() {\n  const number = getRandomNumber(10);\n  return `${'0'.repeat(10)}${number.toString(36)}`.slice(-10);\n}\n\n// |length| here is the maximum number of base-36 digits we want to generate.\nfunction getRandomNumber(length: number): number {\n  if (Math.pow(36, length) > Number.MAX_SAFE_INTEGER) {\n    console.error(\n      `A base-36 number with ${length} digits overflows the range of an integer`\n    );\n  }\n  const values = new Uint8Array(length);\n  crypto.getRandomValues(values);\n  const max = Math.pow(2, 8);\n\n  let result = 0;\n  for (let i = 0; i < values.length; i++) {\n    result *= 36;\n    result += Math.round((values[i] / max) * 35);\n  }\n  return result;\n}\n\nexport function startBugsnag() {\n  const manifest = browser.runtime.getManifest();\n\n  const plugins = [\n    appDuration,\n    browserContext,\n    browserHandledRejectionBreadcrumbs,\n    browserNotifyUnhandledExceptions,\n    browserNotifyUnhandledRejections,\n    deviceOrientation,\n    errorBreadcrumbs,\n    fetchBreadcrumbs,\n    interactionBreadcrumbs,\n    limitEvents(20),\n    navigationBreadcrumbs,\n    stringifyValues,\n  ];\n\n  if (getReleaseStage() !== 'development') {\n    plugins.push(consoleBreadcrumbs);\n  }\n\n  Bugsnag.start({\n    apiKey: 'e707c9ae84265d122b019103641e6462',\n    appVersion: manifest.version_name || manifest.version,\n    collectUserIp: false,\n    onError: async (event: BugsnagEvent) => {\n      // Fill out the user ID\n      event.user = { id: await getExtensionInstallId() };\n\n      // Group download errors by URL and error code\n      if (isDownloadError(event.originalError)) {\n        event.groupingHash =\n          String(event.originalError.code) + event.originalError.url;\n        if (!event.request) {\n          event.request = {};\n        }\n        event.request.url = event.originalError.url;\n      }\n\n      // Group extension errors by action and key\n      if (event.originalError instanceof ExtensionStorageError) {\n        const { key, action } = event.originalError;\n        event.groupingHash = `${action}:${key}`;\n      }\n\n      // Update release stage here since we can only fetch this async but\n      // bugsnag doesn't allow updating the instance after initializing.\n      if (!event.app) {\n        event.app = {};\n      }\n      event.app.releaseStage = getReleaseStage();\n\n      // Update paths in stack trace so that:\n      //\n      // (a) They are the same across installations of the same version (since\n      //     the installed extension ID in the path differs per installation).\n      // (b) They point to where the source is available publicly.\n      //\n      // Note that this is also necessary because Bugsnag's backend discards stack\n      // frames from extensions.\n      //\n      // See: https://docs.bugsnag.com/platforms/javascript/faq/?#how-can-i-get-error-reports-from-browser-extensions\n      const basePath = `https://github.com/birchill/10ten-ja-reader/releases/download/v${manifest.version_name || manifest.version}`;\n      for (const error of event.exceptions) {\n        for (const frame of error.stacktrace) {\n          frame.file = frame.file.replace(\n            /^(moz-extension|chrome-extension|extension|safari-extension|safari-web-extension):\\/\\/[0-9a-z-]+/,\n            basePath\n          );\n        }\n      }\n\n      // If we get a QuotaExceededError, report how much disk space was available.\n      if (event.exceptions[0].errorClass === 'QuotaExceededError') {\n        try {\n          const { quota, usage } = await navigator.storage.estimate();\n          if (!event.metaData) {\n            event.metaData = {};\n          }\n          event.metaData.storage = { quota, usage };\n        } catch {\n          console.warn('Failed to get storage estimate');\n        }\n      }\n\n      return true;\n    },\n    plugins,\n  });\n}\n\n// Common demonimator between jpdict-idb's DownloadError type and\n// fx-fetcher.ts's DownloadError.\ntype CommonDownloadError = {\n  name: 'DownloadError';\n  url?: string;\n  code: number | string;\n};\n\nfunction isDownloadError(error: unknown): error is CommonDownloadError {\n  return (\n    isObject(error) &&\n    typeof error.name === 'string' &&\n    (typeof error.url === 'string' || typeof error.url === 'undefined') &&\n    (typeof error.code === 'number' || typeof error.url === 'string')\n  );\n}\n","// This is in part:\n//\n// - Missing typings for requestIdleCallback\n// - Polyfill for browsers that don't support requestIdleCallback\n// - Polyfill for non-Window contexts (e.g. workers)\n\ninterface IdleDeadline {\n  timeRemaining: () => number;\n  readonly didTimeout: boolean;\n}\n\ninterface IdleRequestOptions {\n  timeout: number;\n}\n\ntype IdleCallbackHandle = number;\n\ntype IdleRequestCallback = (deadline: IdleDeadline) => void;\n\n/** @public */\nexport let requestIdleCallback: (\n  callback: IdleRequestCallback,\n  options?: IdleRequestOptions\n) => IdleCallbackHandle;\n\n/** @public */\nexport let cancelIdleCallback: (handle: IdleCallbackHandle) => void;\n\nif ((self as any).requestIdleCallback && (self as any).cancelIdleCallback) {\n  requestIdleCallback = (self as any).requestIdleCallback.bind(self);\n  cancelIdleCallback = (self as any).cancelIdleCallback.bind(self);\n} else {\n  requestIdleCallback = (\n    callback: IdleRequestCallback,\n    options: IdleRequestOptions\n  ): IdleCallbackHandle => {\n    // Use half the specified timeout since it probably represents a worst-case\n    // scenario.\n    const timeout = options ? options.timeout / 2 : 0;\n    return self.setTimeout(() => {\n      callback({ timeRemaining: () => 0, didTimeout: true });\n    }, timeout);\n  };\n\n  cancelIdleCallback = (handle: IdleCallbackHandle) => {\n    self.clearTimeout(handle);\n  };\n}\n\n/** @public */\nexport function requestIdleCallbackPromise(\n  options?: IdleRequestOptions\n): Promise<void> {\n  return new Promise((resolve) =>\n    requestIdleCallback(() => {\n      resolve();\n    }, options)\n  );\n}\n","import * as s from 'superstruct';\n\ntype ObjectSchema = Record<string, s.Struct<any, any>>;\n\nexport type DiscriminatorSchema<\n  FieldType extends string,\n  MappingType extends Record<string, s.Struct<any, any>>\n> = { field: FieldType; mapping: MappingType };\n\n// Similar to assign() but only takes two arguments and if the first argument\n// is a discriminator(), it merges the properties of an object() or type()\n// into the discriminator()'s various branches.\n//\n// Needed for supporting nested discriminator() types.\nfunction extend<\n  A extends\n    | ObjectSchema\n    | DiscriminatorSchema<any, Record<string, s.Struct<any, any>>>,\n  B extends ObjectSchema\n>(a: s.Struct<any, A>, b: s.Struct<any, B>): s.Struct<any, any> {\n  if (a.type === 'discriminator') {\n    const discriminatorSchema = a.schema as DiscriminatorSchema<\n      any,\n      Record<string, s.Struct<any, any>>\n    >;\n    const mapping: Record<string, s.Struct<any, any>> = {};\n    for (const [key, value] of Object.entries(discriminatorSchema.mapping)) {\n      mapping[key] = s.assign(value, b);\n    }\n    return discriminator(a.schema.field, mapping);\n  }\n\n  return s.assign(a as s.Struct<any, ObjectSchema>, b);\n}\n\n// Infer support for discriminator() objects\n\ntype ConvertToUnion<T> = T[keyof T];\n\ntype Flatten<T> = T extends object\n  ? {\n      [P in keyof T]: Flatten<T[P]>;\n    }\n  : T;\n\ntype DiscriminatorType<\n  FieldType extends string,\n  MappingType\n> = MappingType extends Record<string, any>\n  ? Flatten<\n      ConvertToUnion<\n        {\n          [K in keyof MappingType]: { [P in FieldType]: K } &\n            s.Infer<MappingType[K]>;\n        }\n      >\n    >\n  : never;\n\n// This is a slight tweak on what superstruct does because printing \"[Object\n// object]\" is rarely useful.\nfunction print(value: any): string {\n  // If the value is a string we use JSON.stringify for the quotes.\n  //\n  // For objects we use JSON.stringify as a cheap pretty-print function unless\n  // the object includes its own toString() method.\n  if (\n    typeof value === 'string' ||\n    (typeof value === 'object' && value.toString === Object.prototype.toString)\n  ) {\n    return JSON.stringify(value);\n  }\n  return `${value}`;\n}\n\nfunction isObject(a: unknown): a is Record<string, any> {\n  return typeof a === 'object' && a !== null && !Array.isArray(a);\n}\n\nexport const discriminator = <\n  FieldType extends string,\n  MappingType extends Record<string, s.Struct<any, any>>\n>(\n  field: FieldType,\n  mapping: MappingType\n) => {\n  const keys = Object.keys(mapping);\n\n  const getStructForValue = (\n    value: unknown\n  ): s.Struct<any, any> | undefined => {\n    if (\n      !isObject(value) ||\n      typeof value[field] !== 'string' ||\n      !keys.includes(value[field])\n    ) {\n      return undefined;\n    }\n\n    const branch = value[field];\n    const branchStruct = mapping[branch];\n    if (!branchStruct) {\n      return undefined;\n    }\n\n    return extend(branchStruct, s.object({ [field]: s.literal(branch) }));\n  };\n\n  return new s.Struct<\n    DiscriminatorType<FieldType, MappingType>,\n    DiscriminatorSchema<FieldType, MappingType>\n  >({\n    type: 'discriminator',\n    schema: { field, mapping },\n    *entries(value: unknown, context: s.Context) {\n      const struct = getStructForValue(value);\n      if (struct) {\n        yield* struct.entries(value, context);\n      }\n    },\n    validator(value: unknown, context: s.Context) {\n      if (!isObject(value)) {\n        return `Expected an object, but received: ${print(value)}`;\n      }\n\n      if (!(field in value) || typeof value[field] !== 'string') {\n        return `Expected an object with '${field}' property, but received: ${print(\n          value\n        )}`;\n      }\n\n      if (!keys.includes(value[field])) {\n        return `Expected '${field}' to be one of ${keys\n          .map((key) => `'${key}'`)\n          .join(', ')}, but received: '${value[field]}'`;\n      }\n\n      const struct = getStructForValue(value);\n      if (!struct) {\n        return true;\n      }\n\n      return struct.validator(value, context);\n    },\n  });\n};\n","import { discriminator } from '@birchill/discriminator';\nimport * as s from 'superstruct';\n\nexport const PopupStateSchema = s.type({\n  // Record the position of the window\n  pos: s.optional(\n    s.type({\n      // The frame to which the coordinates are relative.\n      frameId: s.number(),\n      // Page coordinates\n      x: s.number(),\n      y: s.number(),\n      width: s.number(),\n      height: s.number(),\n      direction: s.enums(['vertical', 'horizontal', 'disjoint']),\n      side: s.enums(['before', 'after', 'disjoint']),\n      // Whether or not the popup is allowed to overlap the lookup point.\n      allowOverlap: s.boolean(),\n      // Reference lookup point we should use for determining if a mouse move is\n      // \"between\" the lookup point and the popup.\n      lookupPoint: s.optional(\n        s.type({\n          // Page coordinates\n          x: s.number(),\n          y: s.number(),\n          // Area around the lookup point that should be treated as being \"on\"\n          // the point.\n          //\n          // For example, when the lookup point is the center of a text\n          // character, we want to treat the whole the bbox of the character as\n          // being part of the \"point'.\n          //\n          // This is only needed when the popup transitions from hover -> ghost\n          // display mode and hold-to-show keys are configured (but no longer\n          // pressed, hence the transition). Without this, we can easily get\n          // mousemove events that are outside the lookup point and not on the\n          // path to the popup but where we really don't want to close the\n          // popup since they're still in roughly the same place.\n          //\n          // When we _don't_ have hold-to-show keys configured this is not\n          // a problem because, provided the mouse is still inside the character\n          // that triggered the lookup, we'll keep showing the popup.\n          //\n          // This is expressed as a margin simply so that we don't have to\n          // convert it when transferring between frames.\n          marginX: s.number(),\n          marginY: s.number(),\n        })\n      ),\n    })\n  ),\n\n  // The type of content the popup is positioned relative to.\n  contentType: s.enums(['text', 'image']),\n\n  // The particular appearance and behavior of the popup\n  display: discriminator('mode', {\n    // static: no interactivity, small tabs, no close button etc.\n    static: s.type({}),\n    // ghost: not interactive yet, shows tabs etc. but has a dotted outline,\n    // has no pointer events, and no arrow. Used while scanning using the mouse\n    // before settling on a word to lookup.\n    ghost: discriminator('trigger', {\n      // Transition to hover when the timeout expires\n      timeout: s.type({ timeout: s.number() }),\n      // Transition to hover when the following keys are no longer held\n      keys: s.type({ keyType: s.number() }),\n    }),\n    // hover: interactive using the mouse by hovering over it. Shows an arrow\n    // to the lookup point.\n    hover: s.type({}),\n    // pinned: similar to hover but remains visible even if the mouse moves\n    // outside the popup.\n    pinned: s.type({}),\n    // touch: interactive using touch events. Has no arrow to the lookup point\n    // and does not allowing hovering over using the mouse.\n    touch: s.type({}),\n  }),\n});\n\nexport type PopupState = s.Infer<typeof PopupStateSchema>;\n\nexport type DisplayMode = PopupState['display']['mode'];\n\nexport function clearPopupTimeout(popupState?: PopupState) {\n  if (\n    popupState?.display.mode === 'ghost' &&\n    popupState.display.trigger === 'timeout'\n  ) {\n    window.clearTimeout(popupState.display.timeout);\n  }\n}\n","import { discriminator } from '@birchill/discriminator';\nimport * as s from 'superstruct';\n\nimport { PopupStateSchema } from '../content/popup-state';\n\nconst SearchRequestSchema = s.type({\n  input: s.string(),\n  includeRomaji: s.optional(s.boolean()),\n});\n\nexport type SearchRequest = s.Infer<typeof SearchRequestSchema>;\n\nconst SearchOtherRequestSchema = s.assign(\n  SearchRequestSchema,\n  s.type({\n    wordsMatchLen: s.number(),\n  })\n);\n\nexport type SearchOtherRequest = s.Infer<typeof SearchOtherRequestSchema>;\n\nexport const BackgroundRequestSchema = discriminator('type', {\n  //\n  // Requests for the background page\n  //\n  canHoverChanged: s.type({ value: s.boolean() }),\n  disabled: s.type({}),\n  disableMouseInteraction: s.type({}),\n  'enable?': s.type({}),\n  enabled: s.type({\n    src: s.string(),\n  }),\n  isDbUpdating: s.type({}),\n  options: s.type({}),\n  puckStateChanged: s.type({\n    value: s.object({\n      x: s.number(),\n      y: s.number(),\n      orientation: s.enums(['above', 'below']),\n      active: s.boolean(),\n    }),\n  }),\n  searchWords: SearchRequestSchema,\n  searchOther: SearchOtherRequestSchema,\n  toggleDefinition: s.type({}),\n  translate: s.type({\n    input: s.string(),\n    includeRomaji: s.optional(s.boolean()),\n  }),\n\n  //\n  // Requests to be forwarded to different frames\n  //\n\n  // We send these messages via the background page simply because using\n  // postMessage causes some Web pages to break when they encounter unrecognized\n  // messages.\n\n  // Popup showing status\n  'frame:popupShown': s.type({\n    frameId: s.number(),\n    state: s.optional(PopupStateSchema),\n  }),\n  'children:popupShown': s.type({\n    state: s.optional(PopupStateSchema),\n  }),\n  'children:popupHidden': s.type({}),\n  'top:isPopupShowing': s.type({}),\n\n  // Text highlighting\n  'frame:highlightText': s.type({ length: s.number(), frameId: s.number() }),\n  'frame:clearTextHighlight': s.type({ frameId: s.number() }),\n\n  // Lookup-related requests\n  'top:lookup': s.type({\n    // We don't validate the bulk of the contents here but leave that to the\n    // receiving end.\n\n    // Parameters for designating the iframe source properties\n    source: s.type({\n      src: s.string(),\n      dimensions: s.type({\n        width: s.number(),\n        height: s.number(),\n      }),\n    }),\n  }),\n  'top:pinPopup': s.type({}),\n  'top:unpinPopup': s.type({}),\n  'top:commitPopup': s.type({}),\n  'top:clearResult': s.type({}),\n  'top:nextDictionary': s.type({}),\n  'top:toggleDefinition': s.type({}),\n  'top:expandPopup': s.type({}),\n  'top:movePopup': s.type({ direction: s.enums(['up', 'down']) }),\n\n  // Copy mode requests\n  'top:enterCopyMode': s.type({}),\n  'top:exitCopyMode': s.type({}),\n  'top:nextCopyEntry': s.type({}),\n  'top:copyCurrentEntry': s.type({\n    copyType: s.enums(['entry', 'tab', 'word']),\n  }),\n});\n\nexport type BackgroundRequest = s.Infer<typeof BackgroundRequestSchema>;\n","/// <reference path=\"./mail-extensions.d.ts\" />\nimport Bugsnag from '@birchill/bugsnag-zero';\nimport * as s from 'superstruct';\nimport browser, { Runtime, Tabs, Windows } from 'webextension-polyfill';\n\nimport { ContentConfigParams } from '../common/content-config-params';\nimport { requestIdleCallback } from '../utils/request-idle-callback';\n\nimport {\n  BackgroundMessage,\n  IndividualFrameMessage,\n  TopFrameMessage,\n} from './background-message';\nimport { BackgroundRequestSchema } from './background-request';\nimport {\n  EnabledChangedCallback,\n  EnabledState,\n  TabManager,\n} from './tab-manager';\n\ntype Tab = {\n  frames: Array<{ initialSrc: string }>;\n  src: string;\n  rootWindowCheckTimeout?: number;\n};\n\nexport default class AllTabManager implements TabManager {\n  private config: ContentConfigParams | undefined;\n  private initPromise: Promise<void> | undefined;\n  private initComplete = false;\n  private enabled = false;\n  private listeners: Array<EnabledChangedCallback> = [];\n  private tabs: Array<Tab> = [];\n  private tabsCleanupTask: number | undefined;\n\n  async init(config: ContentConfigParams): Promise<void> {\n    if (this.initPromise) {\n      if (JSON.stringify(this.config) !== JSON.stringify(config)) {\n        const error = new Error(\n          'AllTabManager::init called multiple times with different configurations'\n        );\n        console.error(error);\n        void Bugsnag.notify(error);\n      }\n      return this.initPromise;\n    }\n\n    this.initPromise = this.doInit(config);\n\n    return this.initPromise;\n  }\n\n  private async doInit(config: ContentConfigParams): Promise<void> {\n    this.config = config;\n\n    // Try to fetch our previous enabled state from local storage\n    this.enabled = await this.getStoredEnabledState();\n\n    // Notify listeners\n    if (this.enabled) {\n      this.notifyListeners(true);\n    }\n\n    // Try to enable the active tab in each window\n    if (this.enabled) {\n      this.enableActiveTabs().catch((e) => Bugsnag.notify(e));\n    }\n\n    // Since we only enable the content script in the active tabs, if any other\n    // tab becomes active we should make sure it gets enabled too.\n    browser.tabs.onActivated.addListener(({ tabId }) => {\n      return this.enableTab(tabId);\n    });\n\n    // Response to enabling-related messages\n    browser.runtime.onMessage.addListener(\n      (\n        request: unknown,\n        sender: Runtime.MessageSender\n      ): undefined | Promise<any> => {\n        if (!s.is(request, BackgroundRequestSchema)) {\n          return undefined;\n        }\n\n        switch (request.type) {\n          case 'enable?':\n            if (!sender.tab || typeof sender.tab.id !== 'number') {\n              return undefined;\n            }\n\n            void this.enableTab(sender.tab.id, sender.frameId);\n            break;\n\n          case 'enabled':\n            if (\n              !sender.tab ||\n              typeof sender.tab.id !== 'number' ||\n              typeof sender.frameId !== 'number'\n            ) {\n              return undefined;\n            }\n\n            this.updateFrames({\n              tabId: sender.tab.id,\n              frameId: sender.frameId,\n              src: request.src,\n            });\n\n            return Promise.resolve({ frameId: sender.frameId });\n\n          case 'disabled':\n            if (!sender.tab || typeof sender.tab.id !== 'number') {\n              return;\n            }\n\n            this.dropFrame({\n              tabId: sender.tab.id,\n              frameId: sender.frameId,\n            });\n            break;\n        }\n\n        return undefined;\n      }\n    );\n\n    this.initComplete = true;\n  }\n\n  private async getStoredEnabledState(): Promise<boolean> {\n    let getEnabledResult;\n    try {\n      getEnabledResult = await browser.storage.local.get('enabled');\n    } catch {\n      // This error occurs too frequently to be useful to report to Bugsnag.\n      return false;\n    }\n\n    return (\n      getEnabledResult.hasOwnProperty('enabled') && !!getEnabledResult.enabled\n    );\n  }\n\n  private async enableActiveTabs(): Promise<void> {\n    // browser.tabs.query sometimes fails with a generic Error with message \"An\n    // unexpected error occurred\". I don't know why. Maybe it should fail? Maybe\n    // it's a timing thing? Who knows \n    //\n    // For now, we just do a single retry, two seconds later. If that fails,\n    // I suppose the user will have to try again.\n    const tryToEnable = async () => {\n      const tabs = await browser.tabs.query({ active: true });\n      if (!tabs) {\n        return;\n      }\n\n      for (const tab of tabs) {\n        if (typeof tab.id === 'number') {\n          await this.enableTab(tab.id);\n        }\n      }\n    };\n\n    // Try to enable but only wait on the first attempt.\n    try {\n      await tryToEnable();\n    } catch {\n      console.log('Failed to re-enable. Will retry in two seconds.');\n      setTimeout(() => {\n        tryToEnable().catch(() => {\n          console.log('Second attempt to re-enable failed. Giving up.');\n        });\n      }, 2000);\n    }\n  }\n\n  //\n  // State queries\n  //\n\n  getEnabledState(): Promise<Array<EnabledState>> {\n    return Promise.resolve([{ enabled: this.enabled, tabId: undefined }]);\n  }\n\n  //\n  // Toggling related interface\n  //\n\n  async toggleTab(_tab: Tabs.Tab | undefined, config: ContentConfigParams) {\n    if (!this.initPromise) {\n      throw new Error('Should have called init before toggleTab');\n    }\n\n    await this.initPromise;\n\n    // Update our local copy of the config\n    this.config = config;\n\n    if (!this.enabled) {\n      Bugsnag.leaveBreadcrumb('Enabling active tabs from toggle');\n    }\n\n    // Update local state\n    this.enabled = !this.enabled;\n\n    // Update tabs\n    if (this.enabled) {\n      // Enable the active tabs\n      await this.enableActiveTabs();\n    } else {\n      // Disable all tabs\n      await sendMessageToAllTabs({ type: 'disable', frame: '*' });\n    }\n\n    // Store our local value\n    if (this.enabled) {\n      browser.storage.local.set({ enabled: true }).catch(() => {\n        // Ignore, it's just not that important.\n      });\n    } else {\n      browser.storage.local.remove('enabled').catch(() => {\n        // Ignore\n      });\n    }\n\n    this.notifyListeners(this.enabled);\n  }\n\n  private async enableTab(tabId: number, frameId?: number): Promise<void> {\n    if (!this.config) {\n      throw new Error('Should have called init before enableTab');\n    }\n\n    if (!this.enabled) {\n      return;\n    }\n\n    try {\n      await browser.tabs.sendMessage(\n        tabId,\n        {\n          type: 'enable',\n          config: this.config,\n          // At the point when the listener gets this message it won't know what\n          // its frameId is so it's pointless to specify it here.\n          frame: '*',\n        },\n        { frameId }\n      );\n    } catch {\n      // Some tabs don't have the content script so just ignore\n      // connection failures here.\n    }\n  }\n\n  //\n  // Config updates\n  //\n\n  async updateConfig(config: ContentConfigParams) {\n    // Ignore redundant changes\n    if (JSON.stringify(this.config) === JSON.stringify(config)) {\n      return;\n    }\n\n    this.config = config;\n\n    if (!this.enabled) {\n      return;\n    }\n\n    await sendMessageToAllTabs({ type: 'enable', config, frame: '*' });\n  }\n\n  async notifyDbUpdated() {\n    await sendMessageToAllTabs({ type: 'dbUpdated', frame: '*' });\n  }\n\n  //\n  // Frame management\n  //\n\n  sendMessageToFrame<T extends Omit<IndividualFrameMessage, 'frame'>>({\n    tabId,\n    message,\n    frameId,\n  }: {\n    tabId: number;\n    message: T;\n    frameId: number;\n  }) {\n    browser.tabs\n      .sendMessage(tabId, { ...message, frame: frameId }, { frameId })\n      .catch(() => {\n        // Probably just a stale frameId\n      });\n  }\n\n  sendMessageToTopFrame<T extends Omit<TopFrameMessage, 'frame'>>({\n    tabId,\n    message,\n  }: {\n    tabId: number;\n    message: T;\n  }) {\n    const frameId = this.getTopFrameId(tabId);\n    if (frameId === null) {\n      return;\n    }\n\n    browser.tabs\n      .sendMessage(tabId, { ...message, frame: 'top' }, { frameId })\n      .catch(() => {\n        // Probably just a stale frameId\n      });\n  }\n\n  private getTopFrameId(tabId: number): number | null {\n    if (!(tabId in this.tabs)) {\n      return null;\n    }\n\n    return Number(Object.keys(this.tabs[tabId].frames)[0]);\n  }\n\n  getInitialFrameSrc({\n    tabId,\n    frameId,\n  }: {\n    tabId: number;\n    frameId: number;\n  }): string | undefined {\n    return this.tabs[tabId]?.frames[frameId]?.initialSrc;\n  }\n\n  private updateFrames({\n    tabId,\n    frameId,\n    src,\n  }: {\n    tabId: number;\n    frameId: number;\n    src: string;\n  }) {\n    if (tabId in this.tabs) {\n      const tab = this.tabs[tabId];\n      if (frameId === 0) {\n        tab.src = src;\n      }\n      // If we have navigated the root frame, blow away all the child frames\n      if (frameId === 0 && tab.src !== src && tab.src !== '') {\n        tab.frames = [];\n      }\n    } else {\n      this.tabs[tabId] = {\n        src: frameId === 0 ? src : '',\n        frames: [],\n      };\n    }\n\n    const tab = this.tabs[tabId];\n    const addedFrame = !(frameId in tab.frames);\n    tab.frames[frameId] = { initialSrc: src };\n\n    // Try to detect the \"no content script in the root window\" case\n    if (addedFrame && !tab.frames[0] && !tab.rootWindowCheckTimeout) {\n      tab.rootWindowCheckTimeout = self.setTimeout(() => {\n        if (!this.tabs[tabId] || !Object.keys(this.tabs[tabId].frames).length) {\n          return;\n        }\n\n        this.tabs[tabId].rootWindowCheckTimeout = undefined;\n\n        const topMostFrameId = Number(Object.keys(this.tabs[tabId].frames)[0]);\n        if (topMostFrameId !== 0) {\n          this.sendMessageToFrame({\n            tabId,\n            message: { type: 'isTopMost' },\n            frameId: topMostFrameId,\n          });\n        }\n      }, 3000);\n    }\n\n    // Schedule a task to clean up any tabs that have been closed\n    if (!this.tabsCleanupTask) {\n      this.tabsCleanupTask = requestIdleCallback(async () => {\n        this.tabsCleanupTask = undefined;\n        try {\n          const allTabs = await browser.tabs.query({});\n          const ourTabs = Object.keys(this.tabs).map(Number);\n          for (const tabId of ourTabs) {\n            if (!allTabs.some((t) => t.id === tabId)) {\n              delete this.tabs[tabId];\n            }\n          }\n        } catch (e) {\n          // Sometimes tabs.query will fail (e.g. if the user is dragging tabs).\n          //\n          // That's fine since presumably this task will get scheduled again\n          // eventually.\n          Bugsnag.leaveBreadcrumb('Error cleaning up tabs', e);\n        }\n      });\n    }\n  }\n\n  private dropFrame({\n    tabId,\n    frameId,\n  }: {\n    tabId: number;\n    frameId: number | undefined;\n  }) {\n    if (!this.tabs[tabId]) {\n      return;\n    }\n\n    if (typeof frameId === 'number') {\n      const tab = this.tabs[tabId];\n      delete tab.frames[frameId];\n      if (!tab.frames.length) {\n        delete this.tabs[tabId];\n      }\n    } else {\n      delete this.tabs[tabId];\n    }\n  }\n\n  //\n  // Listeners\n  //\n\n  addListener(listener: EnabledChangedCallback) {\n    if (!this.listeners.includes(listener)) {\n      this.listeners.push(listener);\n    }\n\n    if (this.initComplete) {\n      listener({ enabled: this.enabled, anyEnabled: this.enabled });\n    }\n\n    // If we are still initializing, all the listeners will get notified at the\n    // end of initialization if we are enabled.\n  }\n\n  removeListener(listener: EnabledChangedCallback) {\n    this.listeners = this.listeners.filter((l) => l !== listener);\n  }\n\n  private notifyListeners(enabled: boolean) {\n    for (const listener of this.listeners.slice()) {\n      listener({ enabled, anyEnabled: enabled });\n    }\n  }\n}\n\nasync function sendMessageToAllTabs(message: BackgroundMessage): Promise<void> {\n  const allTabs: Array<Tabs.Tab> = [];\n\n  // We could probably always just use `browser.tabs.query` but for some reason\n  // I decided to use browser.window.getAll. We use `browser.tabs.query` as a\n  // fallback when that is not available (e.g. Firefox for Android).\n  //\n  // 2021-09-20: I think we prefer windows.getAll over tabs.query because\n  // tabs.query is not particularly reliable (e.g. when the user is dragging\n  // tabs it will fail).\n  if (browser.windows) {\n    let windows: Array<Windows.Window> = [];\n    const windowTypes: Array<Windows.MailWindowType> = ['normal'];\n    // Firefox will just return an empty array if we pass a window type it\n    // doesn't recognize so we need to \"feature-detect\" if we are in a mail\n    // extension context or not. For now the presence/absence of the\n    // composeAction member will do.\n    if (browser.composeAction) {\n      windowTypes.push('messageCompose', 'messageDisplay');\n    }\n\n    try {\n      windows = await browser.windows.getAll({ populate: true, windowTypes });\n    } catch (e) {\n      Bugsnag.leaveBreadcrumb('Error getting windows', { error: e });\n    }\n\n    for (const win of windows) {\n      if (!win.tabs) {\n        continue;\n      }\n\n      allTabs.push(...win.tabs);\n    }\n  } else {\n    const tabs = await browser.tabs.query({});\n    allTabs.push(...tabs);\n  }\n\n  for (const tab of allTabs) {\n    if (!tab.id) {\n      continue;\n    }\n\n    browser.tabs.sendMessage(tab.id, message).catch(() => {\n      // Some tabs don't have the content script so just ignore\n      // connection failures here.\n    });\n  }\n}\n","import { DataSeries } from '@birchill/jpdict-idb';\n\nexport const localizedDataSeriesKey: { [series in DataSeries]: string } = {\n  kanji: 'options_kanji_data_name',\n  radicals: 'options_bushu_data_name',\n  names: 'options_name_data_name',\n  words: 'options_words_data_name',\n};\n","export function throttle<T extends (...args: Array<any>) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let lastInvocationTimeout: number | undefined;\n  let lastRan: number | undefined;\n  return function (...args) {\n    /* eslint @typescript-eslint/no-this-alias: 0 */\n    const context = this;\n    const run = () => {\n      func.apply(context, args);\n      lastRan = Date.now();\n    };\n\n    if (!lastRan) {\n      run();\n    } else {\n      self.clearTimeout(lastInvocationTimeout);\n      lastInvocationTimeout = self.setTimeout(\n        function () {\n          if (Date.now() - lastRan! >= limit) {\n            run();\n          }\n        },\n        limit - (Date.now() - lastRan)\n      );\n    }\n  };\n}\n","/// <reference path=\"../common/constants.d.ts\" />\n/// <reference path=\"./mail-extensions.d.ts\" />\nimport { allMajorDataSeries } from '@birchill/jpdict-idb';\nimport browser, { Action } from 'webextension-polyfill';\n\nimport { localizedDataSeriesKey } from '../common/data-series-labels';\nimport { throttle } from '../utils/throttle';\nimport { isSafari } from '../utils/ua-utils';\n\nimport { JpdictStateWithFallback } from './jpdict';\n\ninterface BrowserActionState {\n  enabled: boolean;\n  jpdictState: JpdictStateWithFallback;\n  tabId: number | undefined;\n  toolbarIcon: 'default' | 'sky';\n}\n\nconst action = __MV3__ ? browser.action : browser.browserAction;\n\n// Chrome makes the tooltip disappear for a second or so if we try updating it\n// while it is showing so if we update it too quickly it becomes impossible to\n// read. Instead we need to throttle our updates. 2.5s or so seems like a good\n// balance between being up-to-date and being readable.\nconst throttledSetTitle = throttle(\n  (...args: Parameters<Action.Static['setTitle']>) => {\n    try {\n      action.setTitle(...args).catch((e) => {\n        // Safari seems to frequently throw an exception when calling this\n        // method:\n        //\n        // \"Invalid call to action.setTitle(). Tab not found.\"\n        //\n        // I'm not sure why.\n        console.warn(e);\n      });\n    } catch (e) {\n      // I think Safari might actually throw an exception synchronously here\n      // as opposed to rejecting the Promise.\n      console.warn(e);\n    }\n  },\n  2500\n);\n\nlet currentUpdate: { next?: BrowserActionState } | undefined;\n\nexport function updateBrowserAction(params: BrowserActionState) {\n  // If we are already trying to update the browser action, queue our changes,\n  // clobbering any other queued changes.\n  //\n  // We need to ensure only one update runs at a time because in Chromium-based\n  // browsers setIcon is not FIFO and we can have earlier changes clobbering\n  // later ones.\n  if (currentUpdate) {\n    currentUpdate.next = params;\n    return;\n  }\n\n  void (async () => {\n    let nextParams: BrowserActionState | undefined = params;\n    while (nextParams) {\n      try {\n        // Indicate an update is running\n        currentUpdate = {};\n        await doUpdateBrowserAction(nextParams);\n      } catch {\n        // Ignore\n      }\n      // Look for the next update\n      nextParams = currentUpdate?.next;\n    }\n    // No updates left\n    currentUpdate = undefined;\n  })();\n}\n\nasync function doUpdateBrowserAction({\n  enabled,\n  jpdictState,\n  tabId,\n  toolbarIcon,\n}: BrowserActionState) {\n  const iconFilenameParts = ['10ten'];\n  let tooltip: string;\n\n  // Apply the variant, if needed\n  if (toolbarIcon === 'sky') {\n    iconFilenameParts.push('sky');\n  }\n\n  // First choose the base icon type / text\n  if (enabled) {\n    const jpdictWords = jpdictState.words.state;\n    const fallbackWords = jpdictState.words.fallbackState;\n\n    if (jpdictWords === 'ok' || fallbackWords === 'ok') {\n      tooltip = browser.i18n.getMessage('command_toggle_enabled');\n    } else if (jpdictWords === 'init' || fallbackWords === 'loading') {\n      tooltip = browser.i18n.getMessage('command_toggle_loading');\n    } else if (fallbackWords === 'unloaded') {\n      // If we get this far, we've either failed to load the jpdict database or\n      // we simply haven't got around to populating it yet (e.g. we're still\n      // downloading the other databases).\n      //\n      // However, we won't load the fallback database until the user actually\n      // tries to look something up so we don't know if it's available yet or\n      // not. For now, assume everything is ok.\n      tooltip = browser.i18n.getMessage('command_toggle_enabled');\n    } else {\n      iconFilenameParts.push('error');\n      tooltip = browser.i18n.getMessage('error_loading_dictionary');\n    }\n  } else {\n    iconFilenameParts.push('disabled');\n    tooltip = browser.i18n.getMessage('command_toggle_disabled');\n  }\n\n  const seriesColors = {\n    words: 'green',\n    names: 'blue',\n    kanji: 'purple',\n    radicals: 'purple',\n  };\n\n  // Next determine if we need to overlay any additional information.\n  switch (jpdictState.updateState.type) {\n    case 'checking':\n      // Technically the 'indeterminate' icon would be more correct here but\n      // using '0' instead leads to less flicker.\n      iconFilenameParts.push(\n        '0p',\n        seriesColors[jpdictState.updateState.series]\n      );\n      tooltip = browser.i18n.getMessage('command_toggle_checking');\n      break;\n\n    case 'updating':\n      {\n        const { totalProgress, series } = jpdictState.updateState;\n        // We only have progress variants for the regular and disabled styles.\n        if (!iconFilenameParts.includes('error')) {\n          iconFilenameParts.push(\n            Math.round(totalProgress * 5) * 20 + 'p',\n            seriesColors[series]\n          );\n        }\n        const dbLabel = browser.i18n.getMessage(localizedDataSeriesKey[series]);\n        const progressAsPercent = Math.round(totalProgress * 100);\n        tooltip = browser.i18n.getMessage('command_toggle_downloading', [\n          dbLabel,\n          String(progressAsPercent),\n        ]);\n      }\n      break;\n  }\n\n  // Set the icon\n  //\n  // We'd like to feature-detect if SVG icons are supported but Safari will\n  // just fail silently if we try.\n  const iconFilename = iconFilenameParts.join('-');\n  await setIcon(iconFilename, tabId);\n\n  // Add a warning overlay and update the string if there was a fatal\n  // update error.\n  const hasNotOkDatabase = allMajorDataSeries.some(\n    (series) => jpdictState[series].state !== 'ok'\n  );\n  if (\n    hasNotOkDatabase &&\n    !!jpdictState.updateError &&\n    jpdictState.updateError.name !== 'AbortError' &&\n    // Don't show quota exceeded errors. If the quota is exceeded, there's not\n    // a lot the user can do about it, and we don't want to bother them with\n    // a constant error signal.\n    jpdictState.updateError.name !== 'QuotaExceededError'\n  ) {\n    await action.setBadgeText({ text: '!', tabId });\n    await browser.composeAction?.setBadgeText({ text: '!' });\n    await action.setBadgeBackgroundColor({\n      color: 'yellow',\n      tabId,\n    });\n    await browser.composeAction?.setBadgeBackgroundColor({ color: 'yellow' });\n    tooltip = browser.i18n.getMessage('command_toggle_update_error');\n  } else {\n    await action.setBadgeText({ text: '', tabId });\n    await browser.composeAction?.setBadgeText({ text: '' });\n  }\n\n  // Set the caption\n  throttledSetTitle({ title: tooltip, tabId });\n  await browser.composeAction?.setTitle({ title: tooltip });\n}\n\nasync function setIcon(iconFilename: string, tabId?: number): Promise<void> {\n  // We'd like to feature-detect if SVG icons are supported but Safari will\n  // just fail silently if we try.\n  if (__SUPPORTS_SVG_ICONS__) {\n    const details = { path: `images/${iconFilename}.svg` };\n    await action.setIcon({ ...details, tabId });\n    await browser.composeAction?.setIcon(details);\n  } else {\n    const details = {\n      path: {\n        16: `images/${iconFilename}-16.png`,\n        32: `images/${iconFilename}-32.png`,\n        48: `images/${iconFilename}-48.png`,\n      },\n    };\n    // In Safari (both 15.x and 16.1 and Technology Preview, at the time of\n    // writing) the Promise returned by setIcon might simply never resolve.\n    // No exception is thrown, it just doesn't resolve.\n    //\n    // As a result, if we await setIcon we'll by waiting for a long time and all\n    // the while, subsequent calls to updateBrowserAction while see there's an\n    // ongoing call and just queue up their parameters meaning that the end\n    // result is that the icon never updates.\n    //\n    // As a result we simply don't wait on setIcon when we're on Safari. We\n    // really only need to wait on it for Chrome/Edge anyway since setIcon is\n    // not FIFO there.\n    if (isSafari()) {\n      void action.setIcon({ ...details, tabId });\n    } else {\n      await action.setIcon({ ...details, tabId });\n    }\n    await browser.composeAction?.setIcon(details);\n  }\n}\n\n// This will clobber any existing icon settings so it is only intended\n// to be used on startup (when no existing icon is already set) or when the icon\n// setting is changed (in which case we will update the browser action for\n// enabled tabs immediately afterwards anyway).\nexport function setDefaultToolbarIcon(toolbarIcon: 'default' | 'sky') {\n  const iconFilename =\n    toolbarIcon === 'sky' ? '10ten-disabled' : '10ten-sky-disabled';\n  void setIcon(iconFilename);\n}\n","/// <reference path=\"../common/constants.d.ts\" />\nimport browser, { Menus, Tabs } from 'webextension-polyfill';\n\nimport { isFenix } from '../utils/ua-utils';\n\nconst TOGGLE_MENU_ID = 'context-toggle';\nconst ENABLE_PUCK_MENU_ID = 'context-enable-puck';\n\n// Thunderbird does not support contextMenus, only menus.\n//\n// iOS does not support either.\nconst contextMenus: browser.ContextMenus.Static | undefined =\n  browser.contextMenus || browser.menus;\n\nexport function registerMenuListeners(options: {\n  onToggleMenu: (tab: Tabs.Tab | undefined) => void;\n  onTogglePuck: (enabled: boolean) => void;\n}) {\n  contextMenus?.onClicked.addListener((info, tab) => {\n    if (info.menuItemId === TOGGLE_MENU_ID) {\n      options.onToggleMenu(tab);\n    } else if (info.menuItemId === ENABLE_PUCK_MENU_ID) {\n      options.onTogglePuck(!!info.checked);\n    }\n  });\n}\n\n/**\n * Create / update the context menu items based on the current state.\n *\n * This is a little bit of a funny function because:\n *\n * 1. We can't programmatically tell if a menu item exists or not.\n *\n * 2. Firefox will destroy the context menu if an add-on is disabled.\n *    See bug 1771328 / bug 1817287.\n *\n *    The proposed workaround is to simply unconditionally create the menus at\n *    the top-level and ignore any errors that occur if the menu already\n *    exists.\n *\n *    See: https://bugzilla.mozilla.org/show_bug.cgi?id=1771328#c1\n *\n * As a result of that, we simply try to create each menu item each time and, if\n * it fails, we try to update it instead.\n */\nexport async function updateContextMenus(options: {\n  tabEnabled: boolean;\n  toggleMenuEnabled: boolean;\n  showPuck: boolean;\n}) {\n  // Fenix does not support context menus (but I'm not sure if it actually sets\n  // contextMenus to undefined).\n  if (!contextMenus || isFenix()) {\n    return;\n  }\n\n  const { tabEnabled, toggleMenuEnabled, showPuck } = options;\n\n  if (toggleMenuEnabled) {\n    try {\n      await addToggleMenu(tabEnabled);\n    } catch {\n      try {\n        await contextMenus.update(TOGGLE_MENU_ID, { checked: tabEnabled });\n      } catch {\n        // Ignore\n      }\n    }\n  } else {\n    await removeMenuItem(TOGGLE_MENU_ID);\n  }\n\n  // We only show the enable puck menu if the tab is enabled\n  if (tabEnabled) {\n    try {\n      await addEnablePuckMenu(showPuck);\n    } catch {\n      try {\n        await contextMenus.update(ENABLE_PUCK_MENU_ID, { checked: showPuck });\n      } catch {\n        // Ignore\n      }\n    }\n  } else {\n    await removeMenuItem(ENABLE_PUCK_MENU_ID);\n  }\n}\n\nasync function addToggleMenu(enabled: boolean) {\n  const contexts: Array<Menus.ContextType> = [\n    __MV3__ ? 'action' : 'browser_action',\n    'editable',\n    'frame',\n    'image',\n    'link',\n    'page',\n    'selection',\n    'video',\n  ];\n\n  // Safari throws if we try to include 'tab' in the set of contexts.\n  // (Chrome just ignores it, despite not supporting it.)\n  if (__SUPPORTS_TAB_CONTEXT_TYPE__) {\n    contexts.push('tab');\n  }\n\n  return createMenuItem({\n    id: TOGGLE_MENU_ID,\n    type: 'checkbox',\n    title: browser.i18n.getMessage('menu_enable_extension'),\n    contexts,\n    checked: enabled,\n  });\n}\n\nasync function addEnablePuckMenu(enabled: boolean) {\n  return createMenuItem({\n    id: ENABLE_PUCK_MENU_ID,\n    type: 'checkbox',\n    title: browser.i18n.getMessage('menu_enable_puck'),\n    contexts: [__MV3__ ? 'action' : 'browser_action'],\n    checked: enabled,\n  });\n}\n\nasync function createMenuItem(\n  createProperties: Menus.CreateCreatePropertiesType\n) {\n  // It's important we don't handle errors here so that the caller can detect a\n  // failure to create the menu item and try to update the existing one instead.\n  return new Promise<void>((resolve, reject) => {\n    if (!contextMenus) {\n      reject(new Error('contextMenus is undefined'));\n      return;\n    }\n\n    contextMenus.create(createProperties, () => {\n      if (browser.runtime.lastError) {\n        reject(browser.runtime.lastError);\n      }\n      resolve();\n    });\n  });\n}\n\nasync function removeMenuItem(menuItemId: string) {\n  try {\n    await contextMenus?.remove(menuItemId);\n  } catch {\n    // Ignore\n  }\n}\n","/** @public */\nexport class TimeoutError extends Error {\n  constructor(...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, TimeoutError);\n    }\n\n    this.name = 'TimeoutError';\n  }\n}\n\nexport function fetchWithTimeout(\n  resource: RequestInfo,\n  options?: {\n    timeout?: number | null;\n  } & RequestInit\n): Promise<Response> {\n  const controller = new AbortController();\n  if (options?.signal) {\n    options.signal.addEventListener('abort', () => {\n      controller.abort();\n    });\n  }\n\n  // Set up timeout callback\n  const { timeout = 5000 } = options || {};\n  let didTimeout = false;\n  let timeoutId: number | undefined;\n  if (timeout && timeout !== Infinity) {\n    // This should be safe to use even in service workers because if the worker\n    // is terminated before the timeout happens, presumably the fetch will be\n    // cancelled anyway.\n    timeoutId = self.setTimeout(() => {\n      didTimeout = true;\n      controller.abort();\n    }, timeout);\n  }\n\n  const responsePromise = new Promise<Response>((resolve, reject) => {\n    fetch(resource, {\n      ...options,\n      signal: controller.signal,\n    })\n      .then((response) => {\n        if (timeoutId) {\n          self.clearTimeout(timeoutId);\n        }\n        resolve(response);\n      })\n      .catch((e) => {\n        if (e?.name === 'AbortError' && didTimeout) {\n          reject(new TimeoutError());\n        } else {\n          reject(e);\n        }\n      });\n  });\n\n  return responsePromise;\n}\n","// Based heavily on: https://github.com/mk-pmb/is-error-js\n//\n// which has the following license:\n//\n// Copyright (c) 2015 is-error.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nconst objectToString = Object.prototype.toString;\nconst getPrototypeOf = Object.getPrototypeOf;\nconst ERROR_TYPE = '[object Error]';\n\nexport function isError(a: unknown): a is Error {\n  if (a instanceof Error) {\n    return true;\n  }\n\n  let err = a;\n  while (err) {\n    if (objectToString.call(err) === ERROR_TYPE) {\n      return true;\n    }\n    err = getPrototypeOf(err);\n  }\n\n  return false;\n}\n","import Bugsnag from '@birchill/bugsnag-zero';\nimport * as s from 'superstruct';\nimport browser from 'webextension-polyfill';\n\nimport { fetchWithTimeout } from '../utils/fetch';\nimport { isError } from '../utils/is-error';\nimport { getReleaseStage } from '../utils/release-stage';\n\nimport { getLocalFxData } from './fx-data';\n\ndeclare let self: (Window | ServiceWorkerGlobalScope) & typeof globalThis;\n\nconst FxDataSchema = s.type({\n  timestamp: s.min(s.integer(), 0),\n  rates: s.record(s.string(), s.number()),\n});\n\n// Hopefully this is sufficiently similar enough to the DownloadError class used\n// by jpdict-idb that our Bugsnag grouping code should treat them as the same.\nclass DownloadError extends Error {\n  code: number;\n  url: string;\n\n  constructor(url: string, code: number, ...params: any[]) {\n    super(...params);\n    Object.setPrototypeOf(this, DownloadError.prototype);\n\n    if (typeof (Error as any).captureStackTrace === 'function') {\n      (Error as any).captureStackTrace(this, DownloadError);\n    }\n\n    this.name = 'DownloadError';\n    this.code = code;\n    this.url = url;\n  }\n}\n\ntype FetchState =\n  | {\n      type: 'idle';\n      didFail?: boolean;\n    }\n  | {\n      type: 'fetching';\n      retryCount?: number;\n    }\n  | {\n      type: 'waiting to retry';\n      timeout: number;\n      retryCount: number;\n    };\n\nconst ONE_MINUTE = 60 * 1000;\nconst ONE_HOUR = 60 * ONE_MINUTE;\nconst ONE_DAY = 24 * ONE_HOUR;\n\nexport class FxFetcher {\n  private fetchState: FetchState = { type: 'idle' };\n  private updated: number | undefined;\n\n  constructor() {\n    browser.alarms.onAlarm.addListener((alarm) => {\n      if (alarm.name === 'fx-update') {\n        Bugsnag.leaveBreadcrumb('Running FX data update from alarm');\n        this.fetchData().catch((e) => Bugsnag.notify(e));\n      }\n    });\n\n    // Fetch the latest update date and if we've never downloaded the data,\n    // do it now.\n    //\n    // No need to catch errors here, getLocalFxData does its own error\n    // handling.\n    void getLocalFxData().then((fxData) => {\n      if (!fxData) {\n        Bugsnag.leaveBreadcrumb('No stored FX data. Doing initial fetch.');\n        this.fetchData().catch((e) => Bugsnag.notify(e));\n      } else {\n        Bugsnag.leaveBreadcrumb(\n          `Got stored FX data from ${new Date(\n            fxData.timestamp\n          )}. Last updated ${new Date(fxData.updated)}.`\n        );\n        this.updated = fxData.updated;\n      }\n    });\n  }\n\n  private async fetchData() {\n    // Don't try fetching if we are offline\n    if (!self.navigator.onLine) {\n      Bugsnag.leaveBreadcrumb('Deferring FX data update until we are online');\n      self.addEventListener('online', () => {\n        Bugsnag.leaveBreadcrumb(\n          'Fetching FX data update now that we are online'\n        );\n        void this.fetchData();\n      });\n      return;\n    }\n\n    // Don't try if we are already fetching\n    if (this.fetchState.type === 'fetching') {\n      Bugsnag.leaveBreadcrumb('Overlapping attempt to fetch FX data.');\n      return;\n    }\n\n    // Abort any timeout to retry\n    if (this.fetchState.type === 'waiting to retry') {\n      self.clearTimeout(this.fetchState.timeout);\n    }\n\n    // Update our state\n    this.fetchState = {\n      type: 'fetching',\n      retryCount:\n        this.fetchState.type === 'waiting to retry'\n          ? this.fetchState.retryCount + 1\n          : undefined,\n    };\n\n    // Set up base URL\n    let url = 'https://data.10ten.life/fx/jpy.json';\n\n    // Set up query string\n    const manifest = browser.runtime.getManifest();\n    const queryParams = new URLSearchParams({\n      sp: '10ten-ja-reader',\n      sv: (manifest as any).version_name || manifest.version,\n      sc: getReleaseStage() === 'production' ? 'prod' : 'dev',\n    });\n    url += `?${queryParams.toString()}`;\n\n    // Do the fetch\n    let fxData: s.Infer<typeof FxDataSchema> | undefined;\n    try {\n      const response = await fetchWithTimeout(url, {\n        mode: 'cors',\n        timeout: 20_000,\n      });\n\n      // Check the response\n      if (!response.ok) {\n        throw new DownloadError(url, response.status, response.statusText);\n      }\n\n      // Parse the response\n      const result = await response.json();\n      s.assert(result, FxDataSchema);\n\n      fxData = result;\n    } catch (e: unknown) {\n      // Convert network errors disguised as TypeErrors to DownloadErrors\n      let error = e;\n      if (\n        isError(e) &&\n        e instanceof TypeError &&\n        (e.message.startsWith('NetworkError') ||\n          e.message === 'Failed to fetch')\n      ) {\n        // Use 418 just so that we pass the check for a retry-able error below\n        // which looks for a status code in the 4xx~5xx range.\n        error = new DownloadError(url, 418, e.message);\n      }\n\n      // Possibly schedule a retry\n      const retryAbleError =\n        isError(error) &&\n        (error.name === 'TimeoutError' ||\n          error.name === 'NetworkError' ||\n          (error.name === 'DownloadError' &&\n            (error as DownloadError).code >= 400 &&\n            (error as DownloadError).code < 500));\n\n      const retryCount =\n        this.fetchState.type === 'fetching' &&\n        typeof this.fetchState.retryCount === 'number'\n          ? this.fetchState.retryCount\n          : 0;\n      if (retryAbleError && retryCount < 3) {\n        console.warn(error);\n        Bugsnag.leaveBreadcrumb(\n          `Failed attempt #${retryCount + 1} to fetch FX data. Will retry.`,\n          { error }\n        );\n\n        // We're using setTimeout here but in the case of event pages or service\n        // workers (as we use on some platforms) these are not guaranteed to\n        // run.\n        //\n        // That's fine though because if the background page gets killed then\n        // when it restarts it will trigger a new fetch anyway.\n        const timeout = self.setTimeout(() => this.fetchData(), 10_000);\n        this.fetchState = { type: 'waiting to retry', retryCount, timeout };\n      } else {\n        console.error(error);\n        void Bugsnag.notify(error);\n        this.fetchState = { type: 'idle', didFail: true };\n      }\n    }\n\n    if (fxData) {\n      // Store the response\n      //\n      // If this fails (e.g. due to a QuotaExceededError) there's not much we\n      // can do since we communicate the FX data with other components via\n      // local storage.\n      const updated = Date.now();\n      try {\n        await browser.storage.local.set({ fx: { ...fxData, updated } });\n\n        // Update our local state now that everything succeeded\n        this.updated = updated;\n        this.fetchState = { type: 'idle' };\n      } catch {\n        // Don't report to Bugsnag because this is really common in Firefox for\n        // some reason.\n        this.fetchState = { type: 'idle', didFail: true };\n      }\n    }\n\n    // Clear any alarm that might have triggered us so we can set a new alarm.\n    await this.cancelScheduledUpdate();\n\n    // If we succeeded, or failed outright, schedule our next update.\n    //\n    // For the failed outright case, we determined that retrying isn't going to\n    // help but who knows, maybe in an hour it will?\n    await this.scheduleNextUpdate();\n  }\n\n  async scheduleNextUpdate() {\n    // If we have an existing alarm, it's not likely to be later than we\n    const existingAlarm = await browser.alarms.get('fx-update');\n    if (existingAlarm) {\n      return;\n    }\n\n    // If we are already fetching (or waiting to re-fetch) let it run. It will\n    // schedule the next run when it completes.\n    if (this.fetchState.type !== 'idle') {\n      return;\n    }\n\n    // Schedule the next run to run in a day from the last update.\n    //\n    // If we failed the last update (or failed _every_ update) try again in an\n    // hour. We don't want to re-trigger too soon, however, or else we'll ping\n    // the server unnecessarily.\n    const now = Date.now();\n    let nextRun: number;\n    if (typeof this.updated === 'undefined' || this.fetchState.didFail) {\n      nextRun = now + ONE_HOUR;\n    } else {\n      nextRun = Math.max(this.updated + ONE_DAY, now);\n    }\n\n    // If the next UTC day is before we're scheduled to run next, bring the next\n    // run forwards so that we get the data when it is as fresh as possible.\n    const nextUtcDay = now + ONE_DAY - (now % ONE_DAY);\n    if (nextUtcDay < nextRun) {\n      // ... but add a few minutes to avoid all the clients hitting the server\n      // at the same time.\n      nextRun = nextUtcDay + Math.random() * ONE_HOUR;\n    }\n\n    // If the next run is within a minute or so, run it now. Otherwise, schedule\n    // it for later.\n    if (nextRun <= now + ONE_MINUTE) {\n      // Don't wait on fetchData -- it does its own error handling and caller's\n      // of this function shouldn't have to wait for us to run the fetch, only\n      // to schedule it.\n      void this.fetchData();\n    } else {\n      try {\n        Bugsnag.leaveBreadcrumb(\n          `Scheduling next FX data update for ${new Date(nextRun)}`\n        );\n        browser.alarms.create('fx-update', { when: nextRun });\n      } catch (e) {\n        console.error('Error creating alarm for FX data update', e);\n        void Bugsnag.notify(e);\n      }\n    }\n  }\n\n  async cancelScheduledUpdate() {\n    await browser.alarms.clear('fx-update');\n  }\n}\n","import Bugsnag from '@birchill/bugsnag-zero';\nimport browser from 'webextension-polyfill';\n\nimport { TabManager } from './tab-manager';\n\n// Determining if the tab is enabled or not is not straightforward since\n// different windows can have different enabled states.\n//\n// So if we get multiple windows, we should try to find out which one is the\n// current window and use that.\nexport async function isCurrentTabEnabled(\n  tabManager: TabManager\n): Promise<boolean> {\n  const enabledStates = await tabManager.getEnabledState();\n  if (enabledStates.length < 1) {\n    return false;\n  }\n\n  if (enabledStates.length === 1) {\n    return enabledStates[0].enabled;\n  }\n\n  try {\n    const currentWindowTabs = await browser.tabs.query({\n      active: true,\n      currentWindow: true,\n    });\n\n    // We've received at least one error report where `currentWindowTabs` was\n    // `undefined` on Safari. That shouldn't ever happen, but let's handle it just\n    // in case.\n    if (!currentWindowTabs) {\n      return false;\n    }\n\n    // Typically there's only one active tab per window so let's just query that\n    // (rather than introducing something potentially O(n^2)).\n    const activeTab = currentWindowTabs[0];\n\n    return (\n      activeTab &&\n      enabledStates.some(\n        (state) => state.tabId === activeTab.id && state.enabled\n      )\n    );\n  } catch (e) {\n    void Bugsnag.notify(e);\n    return false;\n  }\n}\n","import { halfToFullWidthNum, toNormalized } from '@birchill/normal-jp';\n\n// This method returns an array of input lengths which use 16-bit character\n// offsets as opposed to Unicode codepoints.\n//\n// That allows us to use .length, .substring etc. on the matched string.\n// If we make this return the positions of Unicode codepoints we will need to\n// update all users of this output to be non-BMP character aware.\nexport function normalizeInput(input: string): [string, number[]] {\n  // Convert to full-width, normalize decomposed characters, expand combined\n  // characters etc.\n  const fullWidthInput = halfToFullWidthNum(input);\n  let [normalized, inputLengths] = toNormalized(fullWidthInput);\n\n  // Strip out any zero-width non-joiners (as Google Docs sometimes likes to\n  // stick them between every single character).\n  [normalized, inputLengths] = stripZwnj(normalized, inputLengths);\n\n  // Truncate if we find characters outside the expected range.\n  for (let i = 0; i < fullWidthInput.length; ++i) {\n    const char = fullWidthInput.codePointAt(i)!;\n    // If we find a character out of range, we need to trim both normalized\n    // and inputLengths\n    if (\n      (char <= 0x2e80 && char != 0x200c) ||\n      (char >= 0x3000 && char <= 0x3002)\n    ) {\n      let outputIndex = 0;\n      while (inputLengths[outputIndex] < i) {\n        outputIndex++;\n      }\n      normalized = normalized.substring(0, outputIndex);\n      inputLengths = inputLengths.slice(0, outputIndex ? outputIndex + 1 : 0);\n      break;\n    }\n  }\n\n  return [normalized, inputLengths];\n}\n\nfunction stripZwnj(\n  input: string,\n  inputLengths: Array<number>\n): [string, Array<number>] {\n  let normalized = '';\n  const lengths: Array<number> = [];\n\n  let last = 0;\n  for (let i = 0; i < input.length; ++i) {\n    if (input.codePointAt(i) !== 0x200c) {\n      normalized += input[i];\n      lengths.push(inputLengths[i]);\n      last = inputLengths[i + 1];\n    }\n  }\n\n  if (last) {\n    lengths.push(last);\n  }\n\n  return [normalized, lengths];\n}\n","// Convert an error into a form that able to sent with postMessage and that\n// is also compatible with Bugsnag's NotifiableError type.\nexport function serializeError(error: Error): {\n  name: string;\n  message: string;\n} {\n  let name: string;\n\n  // Occasionally we get an undefined error object. We saw this at least once\n  // on Firefox 68. Note sure where it's coming from.\n  if (!error) {\n    // Generate a stack in the hope of getting some clue where this is coming\n    // from.\n    let stack: string | undefined;\n    try {\n      throw new Error('(Unknown error)');\n    } catch (e) {\n      stack = (e as Error).stack;\n    }\n    return { name: '(Unknown error)', message: stack || '' };\n  }\n\n  // We need to be careful not to read the 'code' field unless it's a string\n  // because DOMExceptions, for example, have a code field that is a number\n  // but what we really want from them is their 'name' field.\n  if (typeof (error as any).code === 'string') {\n    name = (error as any).code;\n  } else {\n    name = (error as any).name || (error as any).message;\n  }\n\n  // Also, if we get a generic \"Error\" with a more specific message field, we\n  // should use that.\n  if (\n    name === 'Error' &&\n    typeof (error as any).message === 'string' &&\n    (error as any).message.length\n  ) {\n    name = (error as any).message;\n  }\n\n  // Common conversions to more specific/useful error classes.\n  if (error instanceof TypeError && error.message.startsWith('NetworkError')) {\n    name = 'NetworkError';\n  }\n  if (name === 'NetworkError' && !self.navigator.onLine) {\n    name = 'OfflineError';\n  }\n\n  // Set the message to the message field, unless we're already using that as\n  // the name.\n  let message = (error as any).message || '';\n  if (message === name) {\n    message = '';\n  }\n\n  return { name, message };\n}\n","import { JpdictState } from '../background/jpdict';\nimport { serializeError } from '../utils/serialize-error';\n\nexport const queryState = () => ({ type: 'querystate' as const });\n\nexport const updateDb = ({\n  lang,\n  force,\n}: {\n  lang: string;\n  force: boolean;\n}) => ({\n  type: 'update' as const,\n  lang,\n  force,\n});\n\nexport const cancelUpdateDb = () => ({ type: 'cancelupdate' as const });\n\nexport const deleteDb = () => ({ type: 'delete' as const });\n\nexport const notifyDbStateUpdated = (state: JpdictState) => ({\n  type: 'dbstateupdated' as const,\n  state,\n});\n\nexport const notifyDbUpdateComplete = (lastCheck: Date | null) => ({\n  type: 'dbupdatecomplete' as const,\n  lastCheck,\n});\n\nexport const leaveBreadcrumb = ({ message }: { message: string }) => ({\n  type: 'breadcrumb' as const,\n  message,\n});\n\nexport const notifyError = ({\n  error,\n  severity = 'error',\n}: {\n  error: Error;\n  severity?: 'error' | 'warning';\n}) => ({\n  type: 'error' as const,\n  severity,\n  ...serializeError(error),\n  stack: error.stack,\n});\n\nexport type JpdictEvent =\n  | ReturnType<typeof queryState>\n  | ReturnType<typeof updateDb>\n  | ReturnType<typeof cancelUpdateDb>\n  | ReturnType<typeof deleteDb>\n  | ReturnType<typeof notifyDbStateUpdated>\n  | ReturnType<typeof notifyDbUpdateComplete>\n  | ReturnType<typeof leaveBreadcrumb>\n  | ReturnType<typeof notifyError>;\n","import Bugsnag from '@birchill/bugsnag-zero';\n\nimport { JpdictBackend, JpdictListener } from '../background/jpdict-backend';\nimport { JpdictEvent } from '../background/jpdict-events';\nimport * as events from '../background/jpdict-events';\n\nexport class JpdictWorkerBackend implements JpdictBackend {\n  private worker: Worker;\n  private listeners: Array<JpdictListener> = [];\n\n  constructor() {\n    this.worker = new Worker('./10ten-ja-jpdict.js');\n    this.worker.onmessageerror = (event: MessageEvent) => {\n      console.error(`Worker error: ${JSON.stringify(event)}`);\n      void Bugsnag.notify(`Worker error: ${JSON.stringify(event)}`);\n    };\n\n    this.worker.onmessage = async (event: MessageEvent) => {\n      const message = event.data as JpdictEvent;\n      this.notifyListeners(message);\n    };\n  }\n\n  updateDb(params: { lang: string; force: boolean }) {\n    this.worker.postMessage(events.updateDb(params));\n  }\n\n  cancelUpdateDb() {\n    this.worker.postMessage(events.cancelUpdateDb());\n  }\n\n  deleteDb() {\n    this.worker.postMessage(events.deleteDb());\n  }\n\n  queryState() {\n    this.worker.postMessage(events.queryState());\n  }\n\n  addEventListener(listener: JpdictListener) {\n    if (!this.listeners.includes(listener)) {\n      this.listeners.push(listener);\n    }\n  }\n\n  removeEventListener(listener: JpdictListener) {\n    this.listeners = this.listeners.filter((l) => l !== listener);\n  }\n\n  private notifyListeners(message: JpdictEvent) {\n    const listenersCopy = this.listeners.slice();\n    for (const listener of listenersCopy) {\n      listener(message);\n    }\n  }\n}\n","// This is duplicated from jpdict-idb's sorting of entries.\n//\n// We use it for sorting:\n//\n// 1) Between various deinflected results (e.g. so that  comes before \n//    when looking up ), and\n//\n// 2) In the case where we've fallen back to the flat file database.\n//\nimport { WordResult } from './search-result';\n\n// As with Array.prototype.sort, sorts `results` in-place, but returns the\n// result to support chaining.\nexport function sortWordResults(results: Array<WordResult>): Array<WordResult> {\n  const sortMeta: Map<\n    number,\n    { length?: number; priority: number; type: number }\n  > = new Map();\n\n  for (const result of results) {\n    const length = (\n      result.k.find((k) => k.matchRange) || result.r.find((r) => r.matchRange)\n    )?.ent.length;\n\n    // Determine the headword match type\n    //\n    // 1 = match on a kanji, or kana which is not just the reading for a kanji\n    // 2 = match on a kana reading for a kanji\n    const kanaReading = result.r.find((r) => !!r.matchRange);\n    const rt = kanaReading ? getKanaHeadwordType(kanaReading, result) : 1;\n\n    // Priority\n    const priority = getPriority(result);\n\n    sortMeta.set(result.id, { length, priority, type: rt });\n  }\n\n  results.sort((a, b) => {\n    const metaA = sortMeta.get(a.id)!;\n    const metaB = sortMeta.get(b.id)!;\n\n    if (\n      metaA.length !== undefined &&\n      metaB.length !== undefined &&\n      metaA.length !== metaB.length\n    ) {\n      return metaB.length - metaA.length;\n    }\n\n    if (metaA.type !== metaB.type) {\n      return metaA.type - metaB.type;\n    }\n\n    return metaB.priority - metaA.priority;\n  });\n\n  return results;\n}\n\nfunction getKanaHeadwordType(\n  r: WordResult['r'][number],\n  result: WordResult\n): 1 | 2 {\n  // We don't want to prioritize readings marked as `ok` etc. or else we'll end\n  // up prioritizing words like `` and `` being prioritized when searching\n  // for ``.\n  const isReadingObscure =\n    r.i?.includes('ok') ||\n    r.i?.includes('rk') ||\n    r.i?.includes('sk') ||\n    r.i?.includes('ik');\n\n  if (isReadingObscure) {\n    return 2;\n  }\n\n  // Kana headwords are type 1 (i.e. they are a primary headword, not just a\n  // reading for a kanji headword) if:\n  //\n  // (a) the entry has no kanji headwords or all the kanji headwords are marked\n  //     as `rK`, `sK`, or `iK`.\n  if (\n    !result.k.length ||\n    result.k.every(\n      (k) => k.i?.includes('rK') || k.i?.includes('sK') || k.i?.includes('iK')\n    )\n  ) {\n    return 1;\n  }\n\n  // (b) most of the English senses for the entry have a `uk` (usually kana)\n  //     `misc` field and the reading is not marked as `ok` (old kana usage).\n  //\n  // We wanted to make the condition here be just one sense being marked as `uk`\n  // but then you get words like `` being prioritized when searching for ``\n  // because of one sense out of many being usually kana.\n  //\n  // Furthermore, we don't want to require _all_ senses to be marked as `uk` or\n  // else that will mean that  fails to be prioritized when searching for\n  // `` because one sense out of 11 is not marked as `uk`.\n  if (mostMatchedEnSensesAreUk(result.s)) {\n    return 1;\n  }\n\n  // (c) the headword is marked as `nokanji`\n  return r.app === 0 ? 1 : 2;\n}\n\nfunction mostMatchedEnSensesAreUk(senses: WordResult['s']): boolean {\n  const matchedEnSenses = senses.filter(\n    (s) => s.match && (s.lang === undefined || s.lang === 'en')\n  );\n  if (matchedEnSenses.length === 0) {\n    return false;\n  }\n\n  const ukEnSenseCount = matchedEnSenses.filter((s) =>\n    s.misc?.includes('uk')\n  ).length;\n  return ukEnSenseCount >= matchedEnSenses.length / 2;\n}\n\nfunction getPriority(result: WordResult): number {\n  const scores: Array<number> = [0];\n\n  // Scores from kanji readings\n  for (const k of result.k || []) {\n    if (!k.matchRange || !k.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(k.p));\n  }\n\n  // Scores from kana readings\n  for (const r of result.r) {\n    if (!r.matchRange || !r.p) {\n      continue;\n    }\n\n    scores.push(getPrioritySum(r.p));\n  }\n\n  // Return top score\n  return Math.max(...scores);\n}\n\n// Produce an overall priority from a series of priority strings.\n//\n// This should produce a value somewhere in the range 0~67.\n//\n// In general we report the highest priority, but if we have several priority\n// scores we add a decreasing fraction (10%) of the lesser scores as an\n// indication that several sources have attested to the priority.\n//\n// That should typically produce a maximum attainable score of 66.8.\n// Having a bounded range like this makes it easier to combine this value with\n// other metrics when sorting.\nfunction getPrioritySum(priorities: Array<string>): number {\n  const scores = priorities.map(getPriorityScore).sort().reverse();\n  return scores.length\n    ? scores[0] +\n        scores\n          .slice(1)\n          .reduce(\n            (total, score, index) => total + score / Math.pow(10, index + 1),\n            0\n          )\n    : 0;\n}\n\n// This assignment is pretty arbitrary however it's mostly used for sorting\n// entries where all we need to do is distinguish between the really common ones\n// and the obscure academic ones.\n//\n// Entries with (P) are those ones that are marked with (P) in Edict.\nconst PRIORITY_ASSIGNMENTS: Map<string, number> = new Map([\n  ['i1', 50], // Top 10,000 words minus i2 (from 1998) (P)\n  ['i2', 20],\n  ['n1', 40], // Top 12,000 words in newspapers (from 2003?) (P)\n  ['n2', 20], // Next 12,000\n  ['s1', 32], // \"Speculative\" annotations? Seem pretty common to me. (P)\n  ['s2', 20], // (P)\n  ['g1', 30], // (P)\n  ['g2', 15],\n]);\n\nfunction getPriorityScore(p: string): number {\n  if (PRIORITY_ASSIGNMENTS.has(p)) {\n    return PRIORITY_ASSIGNMENTS.get(p)!;\n  }\n\n  if (p.startsWith('nf')) {\n    // The wordfreq scores are groups of 500 words.\n    // e.g. nf01 is the top 500 words, and nf48 is the 23,501 ~ 24,000\n    // most popular words.\n    const wordfreq = parseInt(p.substring(2), 10);\n    if (wordfreq > 0 && wordfreq < 48) {\n      return 48 - wordfreq / 2;\n    }\n  }\n\n  return 0;\n}\n","import { Client as BugsnagClient } from '@birchill/bugsnag-zero';\nimport {\n  BITS_PER_GLOSS_TYPE,\n  Gloss,\n  GlossType,\n  GlossTypes,\n  RawKanjiMeta,\n  RawReadingMeta,\n  RawWordSense,\n  WordResult,\n} from '@birchill/jpdict-idb';\nimport { kanaToHiragana } from '@birchill/normal-jp';\nimport { LRUMap } from 'lru_map';\nimport browser from 'webextension-polyfill';\n\nimport { stripFields } from '../utils/strip-fields';\nimport { Overwrite } from '../utils/type-helpers';\n\nimport { DictionaryWordResult, Sense } from './search-result';\nimport { sortWordResults } from './word-match-sorting';\n\ninterface FlatFileDatabaseOptions {\n  // Although the v7 API of bugsnag-js can operate on a singleton client we\n  // still need to pass this in so that we can avoid trying to call bugsnag\n  // when running unit tests (and trying to do so would trigger errors because\n  // we failed to call start anyway).\n  bugsnag?: BugsnagClient;\n}\n\ntype FlatFileDatabaseEvent =\n  | { type: 'loaded' }\n  | { type: 'error'; error: any; willRetry: boolean };\n\ntype FlatFileDatabaseListener = (event: FlatFileDatabaseEvent) => void;\n\nclass FlatFileDatabase {\n  bugsnag?: BugsnagClient;\n  listeners: Array<FlatFileDatabaseListener> = [];\n  loaded: Promise<any>;\n  lookupCache = new LRUMap<string, Array<number>>(500);\n  wordDict: string;\n  wordIndex: string;\n\n  constructor(options: FlatFileDatabaseOptions) {\n    this.bugsnag = options.bugsnag;\n    this.loaded = this.loadData();\n  }\n\n  //\n  // Loading\n  //\n\n  private async loadData(): Promise<void> {\n    try {\n      // Read in series to reduce contention\n      this.wordDict = await this.readFileWithAutoRetry(\n        browser.runtime.getURL('data/words.ljson')\n      );\n      this.wordIndex = await this.readFileWithAutoRetry(\n        browser.runtime.getURL('data/words.idx')\n      );\n\n      this.notifyListeners({ type: 'loaded' });\n    } catch (e) {\n      this.notifyListeners({ type: 'error', error: e, willRetry: false });\n    }\n  }\n\n  private async readFileWithAutoRetry(url: string): Promise<string> {\n    let attempts = 0;\n\n    // Bugsnag only gives us 30 characters for the breadcrumb but it's the\n    // end of the url we really want to record.\n    const makeBreadcrumb = (prefix: string, url: string): string => {\n      const urlStart = Math.max(0, url.length - (30 - prefix.length - 1));\n      return prefix + '' + url.substring(urlStart);\n    };\n\n    if (this.bugsnag) {\n      this.bugsnag.leaveBreadcrumb(makeBreadcrumb('Loading: ', url));\n    }\n\n    while (true) {\n      // We seem to occasionally hit loads that never finish (particularly on\n      // Linux and particularly on startup / upgrade). Set a timeout so that\n      // we can at least abort and try again.\n      const TIMEOUT_MS = 5 * 1000;\n      let timeoutId: number | undefined;\n\n      try {\n        let controller: AbortController | undefined;\n        let requestOptions: RequestInit | undefined;\n\n        // It turns out some people are still using Firefox < 57. :/\n        if (typeof AbortController === 'function') {\n          controller = new AbortController();\n          requestOptions = { signal: controller.signal };\n        }\n\n        timeoutId = self.setTimeout(\n          () => {\n            timeoutId = undefined;\n            if (controller) {\n              console.error(`Load of ${url} timed out. Aborting.`);\n              if (this.bugsnag) {\n                this.bugsnag.leaveBreadcrumb(makeBreadcrumb('Aborting: ', url));\n              }\n              controller.abort();\n            } else {\n              // TODO: This error doesn't actually propagate and do anything\n              // useful yet. But for now at least it means Firefox 56 doesn't\n              // break altogether.\n              if (this.bugsnag) {\n                void this.bugsnag.notify('[Pre FF57] Load timed out');\n              }\n              throw new Error(`Load of ${url} timed out.`);\n            }\n          },\n          TIMEOUT_MS * (attempts + 1)\n        );\n\n        const response = await fetch(url, requestOptions);\n        const responseText = await response.text();\n\n        clearTimeout(timeoutId);\n        if (this.bugsnag) {\n          this.bugsnag.leaveBreadcrumb(makeBreadcrumb('Loaded: ', url));\n        }\n\n        return responseText;\n      } catch (e) {\n        if (typeof timeoutId === 'number') {\n          clearTimeout(timeoutId);\n        }\n\n        if (this.bugsnag) {\n          this.bugsnag.leaveBreadcrumb(\n            makeBreadcrumb(`Failed(#${attempts + 1}): `, url)\n          );\n        }\n\n        if (++attempts >= 3) {\n          console.error(`Failed to load ${url} after ${attempts} attempts`);\n          throw e;\n        }\n\n        this.notifyListeners({ type: 'error', error: e, willRetry: true });\n\n        // Wait for a (probably) increasing interval before trying again\n        const intervalToWait = Math.round(Math.random() * attempts * 1000);\n        console.log(\n          `Failed to load ${url}. Trying again in ${intervalToWait}ms`\n        );\n        await new Promise((resolve) => setTimeout(resolve, intervalToWait));\n      }\n    }\n  }\n\n  //\n  // Searching\n  //\n\n  async getWords({\n    input,\n    maxResults,\n  }: {\n    input: string;\n    maxResults: number;\n  }): Promise<Array<DictionaryWordResult>> {\n    await this.loaded;\n\n    let offsets = this.lookupCache.get(input);\n    if (!offsets) {\n      const lookupResult = findLineStartingWith({\n        source: this.wordIndex,\n        text: input + ',',\n      });\n      if (!lookupResult) {\n        this.lookupCache.set(input, []);\n        return [];\n      }\n      offsets = lookupResult.split(',').slice(1).map(Number);\n      this.lookupCache.set(input, offsets);\n    }\n\n    const result: Array<DictionaryWordResult> = [];\n\n    for (const offset of offsets) {\n      const entry = JSON.parse(\n        this.wordDict.substring(offset, this.wordDict.indexOf('\\n', offset))\n      ) as RawWordRecord;\n\n      result.push(\n        toDictionaryWordResult({ entry, matchingText: input, offset })\n      );\n    }\n\n    // Sort before capping the number of results\n    sortWordResults(result);\n    result.splice(maxResults);\n\n    return result;\n  }\n\n  //\n  // Listeners\n  //\n\n  addListener(listener: FlatFileDatabaseListener) {\n    if (this.listeners.includes(listener)) {\n      return;\n    }\n\n    this.listeners.push(listener);\n  }\n\n  removeListener(listener: FlatFileDatabaseListener) {\n    this.listeners = this.listeners.filter((l) => l !== listener);\n  }\n\n  notifyListeners(event: FlatFileDatabaseEvent) {\n    const listenersCopy = this.listeners.slice();\n    for (const listener of listenersCopy) {\n      listener(event);\n    }\n  }\n}\n\n// Performs a binary search of a linefeed delimited string, |data|, for |text|.\nfunction findLineStartingWith({\n  source,\n  text,\n}: {\n  source: string;\n  text: string;\n}): string | null {\n  const tlen = text.length;\n  let start = 0;\n  let end: number = source.length - 1;\n\n  while (start < end) {\n    const midpoint: number = (start + end) >> 1;\n    const i: number = source.lastIndexOf('\\n', midpoint) + 1;\n\n    const candidate: string = source.substring(i, i + tlen);\n    if (text < candidate) {\n      end = i - 1;\n    } else if (text > candidate) {\n      start = source.indexOf('\\n', midpoint + 1) + 1;\n    } else {\n      return source.substring(i, source.indexOf('\\n', midpoint + 1));\n    }\n  }\n\n  return null;\n}\n\n// This type matches the structure of the records in the flat file database\n// (which, incidentally, differ slightly from the data format used by jpdict-idb\n// since, for example, they don't include the ID field).\n//\n// As a result it is only used as part of the fallback mechanism.\n\ninterface RawWordRecord {\n  k?: Array<string>;\n  km?: Array<0 | RawKanjiMeta>;\n  r: Array<string>;\n  rm?: Array<0 | RawReadingMeta>;\n  s: Array<RawWordSense>;\n}\n\nfunction toDictionaryWordResult({\n  entry,\n  matchingText,\n  offset,\n}: {\n  entry: RawWordRecord;\n  matchingText: string;\n  offset: number;\n}): DictionaryWordResult {\n  const kanjiMatch =\n    !!entry.k && entry.k.some((k) => kanaToHiragana(k) === matchingText);\n  const kanaMatch =\n    !kanjiMatch && entry.r.some((r) => kanaToHiragana(r) === matchingText);\n\n  return {\n    id: offset,\n    k: mergeMeta(entry.k, entry.km, (key, meta) => ({\n      ent: key,\n      ...meta,\n      match:\n        (kanjiMatch && kanaToHiragana(key) === matchingText) || !kanjiMatch,\n      matchRange:\n        kanaToHiragana(key) === matchingText ? [0, key.length] : undefined,\n    })),\n    r: mergeMeta(entry.r, entry.rm, (key, meta) => ({\n      ent: key,\n      ...meta,\n      match: (kanaMatch && kanaToHiragana(key) === matchingText) || !kanaMatch,\n      matchRange:\n        kanaToHiragana(key) === matchingText ? [0, key.length] : undefined,\n    })),\n    s: expandSenses(entry.s),\n  };\n}\n\ntype WithExtraMetadata<T> = Overwrite<\n  T,\n  {\n    wk: WordResult['k'][0]['wk'];\n    bv: WordResult['k'][0]['bv'];\n    bg: WordResult['k'][0]['bv'];\n  }\n>;\n\nfunction mergeMeta<MetaType extends RawKanjiMeta | RawReadingMeta, MergedType>(\n  keys: Array<string> | undefined,\n  metaArray: Array<0 | MetaType> | undefined,\n  merge: (key: string, meta?: WithExtraMetadata<MetaType>) => MergedType\n): Array<MergedType> {\n  const result: Array<MergedType> = [];\n\n  for (const [i, key] of (keys || []).entries()) {\n    const meta: MetaType | undefined =\n      metaArray && metaArray.length >= i + 1 && metaArray[i] !== 0\n        ? (metaArray[i] as MetaType)\n        : undefined;\n\n    // The following is taken from jpdict-idb's `makeWordResult` function.\n    //\n    // WaniKani levels are stored in the `p` (priority) field for simplicity\n    // in the form `wk{N}` where N is the level number.\n    // We need to extract any such levels and store them in the `wk` field\n    // instead.\n    //\n    // Likewise for Bunpro levels which need to be combined with an `bv` /\n    // `bg` fields since these contain the original source text for a fuzzy\n    // match.\n    let wk: number | undefined;\n    let bv: number | undefined;\n    let bg: number | undefined;\n\n    const p = meta?.p?.filter((p) => {\n      if (/^wk\\d+$/.test(p)) {\n        const wkLevel = parseInt(p.slice(2), 10);\n        if (typeof wk === 'undefined' || wkLevel < wk) {\n          wk = wkLevel;\n        }\n        return false;\n      }\n\n      if (/^bv\\d+$/.test(p)) {\n        const bvLevel = parseInt(p.slice(2), 10);\n        if (typeof bv === 'undefined' || bvLevel < bv) {\n          bv = bvLevel;\n        }\n        return false;\n      }\n\n      if (/^bg\\d+$/.test(p)) {\n        const bgLevel = parseInt(p.slice(2), 10);\n        if (typeof bg === 'undefined' || bgLevel < bg) {\n          bg = bgLevel;\n        }\n        return false;\n      }\n\n      return true;\n    });\n\n    if (p?.length) {\n      meta!.p = p;\n    } else {\n      delete meta?.p;\n    }\n\n    const extendedMeta = meta as WithExtraMetadata<MetaType> | undefined;\n\n    if (wk) {\n      extendedMeta!.wk = wk;\n    }\n\n    if (typeof bv === 'number') {\n      extendedMeta!.bv = Object.assign(\n        { l: bv },\n        meta?.bv ? { src: meta?.bv } : undefined\n      );\n    }\n\n    if (typeof bg === 'number') {\n      extendedMeta!.bg = Object.assign(\n        { l: bg },\n        meta?.bg ? { src: meta?.bg } : undefined\n      );\n    }\n\n    result.push(merge(key, extendedMeta));\n  }\n\n  return result;\n}\n\nfunction expandSenses(senses: Array<RawWordSense>): Array<Sense> {\n  return senses.map((sense) => ({\n    g: expandGlosses(sense),\n    ...stripFields(sense, ['g', 'gt']),\n    match: true,\n  }));\n}\n\nfunction expandGlosses(sense: RawWordSense): Array<Gloss> {\n  // Helpers to work out the gloss type\n  const gt = sense.gt || 0;\n  const typeMask = (1 << BITS_PER_GLOSS_TYPE) - 1;\n  const glossTypeAtIndex = (i: number): GlossType => {\n    return GlossTypes[(gt >> (i * BITS_PER_GLOSS_TYPE)) & typeMask];\n  };\n\n  return sense.g.map((gloss, i) => {\n    // This rather convoluted mess is because our test harness differentiates\n    // between properties that are not set and those that are set to\n    // undefined.\n    const result: Gloss = { str: gloss };\n\n    const type = glossTypeAtIndex(i);\n    if (type !== 'none') {\n      result.type = type;\n    }\n\n    return result;\n  });\n}\n\n// ---------------------------------------------------------------------------\n//\n// Loader utility\n//\n// ---------------------------------------------------------------------------\n\n// This is all a bit complicated. It comes about because we want the following\n// behavior:\n//\n// If we are looking up words and need to fallback to the flat file dictionary\n// we should wait for it to load. However, if it fails to load the first time\n// we should retry automatically but NOT make callers wait for those retries.\n//\n// However, if one of those automatic retries succeeds, subsequent calls to get\n// the database should use the resolved promise.\n\nexport type FlatFileDatabaseLoadState =\n  | 'unloaded'\n  | 'loading'\n  | 'retrying'\n  | 'error'\n  | 'ok';\n\nexport type FlatFileDatabaseLoadCallback = (\n  state: FlatFileDatabaseLoadState\n) => void;\n\nexport class FlatFileDatabaseLoader {\n  loadState: FlatFileDatabaseLoadState = 'unloaded';\n  onUpdate: FlatFileDatabaseLoadCallback | undefined;\n\n  private bugsnag?: BugsnagClient;\n  private flatFileDatabase: FlatFileDatabase | undefined;\n  private loadError: any;\n\n  private loadPromise: Promise<FlatFileDatabase> | undefined;\n  private resolveLoad: (db: FlatFileDatabase) => void;\n  private rejectLoad: (e: any) => void;\n\n  constructor(options: FlatFileDatabaseOptions) {\n    this.bugsnag = options.bugsnag;\n    this.onFlatFileDatabaseUpdated = this.onFlatFileDatabaseUpdated.bind(this);\n  }\n\n  resetIfNotLoaded(): void {\n    if (this.loadState === 'ok') {\n      return;\n    }\n\n    if (this.flatFileDatabase) {\n      this.flatFileDatabase.removeListener(this.onFlatFileDatabaseUpdated);\n      this.flatFileDatabase = undefined;\n    }\n\n    this.loadState = 'unloaded';\n  }\n\n  load(): Promise<FlatFileDatabase> {\n    if (this.flatFileDatabase && this.loadPromise) {\n      return this.loadPromise;\n    }\n\n    this.flatFileDatabase = new FlatFileDatabase({ bugsnag: this.bugsnag });\n    this.flatFileDatabase.addListener(this.onFlatFileDatabaseUpdated);\n\n    this.loadPromise = new Promise<FlatFileDatabase>((resolve, reject) => {\n      this.resolveLoad = resolve;\n      this.rejectLoad = reject;\n    });\n\n    this.loadState = 'loading';\n    if (this.onUpdate) {\n      this.onUpdate(this.loadState);\n    }\n\n    return this.loadPromise;\n  }\n\n  private onFlatFileDatabaseUpdated(event: FlatFileDatabaseEvent) {\n    switch (event.type) {\n      case 'loaded':\n        this.loadState = 'ok';\n        this.loadError = undefined;\n\n        // If this is the initial load, make sure to resolve the load promise.\n        //\n        // (If it is NOT the initial load, resolveLoad will be a no-op since\n        // rejectLoad will have already been called.)\n        if (this.resolveLoad && this.flatFileDatabase) {\n          this.resolveLoad(this.flatFileDatabase);\n        }\n\n        // If this is not the initial load, make sure to replace the loadPromise\n        // so that anyone who waits on it from now on will get the resolved\n        // database.\n        if (this.flatFileDatabase) {\n          this.loadPromise = Promise.resolve(this.flatFileDatabase);\n        }\n        break;\n\n      case 'error':\n        if (event.willRetry) {\n          this.loadState = 'retrying';\n        } else {\n          this.loadState = 'error';\n          // Reset the flat file database so that subsequence calls to load()\n          // will retry loading.\n          this.flatFileDatabase?.removeListener(this.onFlatFileDatabaseUpdated);\n          this.flatFileDatabase = undefined;\n        }\n        this.loadError = event.error;\n        if (this.rejectLoad) {\n          this.rejectLoad(event.error);\n        }\n        break;\n    }\n\n    if (this.onUpdate) {\n      this.onUpdate(this.loadState);\n    }\n  }\n\n  get database(): Promise<FlatFileDatabase> {\n    switch (this.loadState) {\n      case 'unloaded':\n        return this.load();\n\n      case 'loading':\n        return this.loadPromise!;\n\n      case 'retrying':\n      // This should fail since we don't want the caller to wait on retries so\n      // this falls through\n\n      case 'error':\n        return Promise.reject(this.loadError);\n\n      case 'ok':\n        return Promise.resolve(this.flatFileDatabase!);\n    }\n  }\n}\n","import {\n  DataSeries,\n  JpdictIdb,\n  MajorDataSeries,\n  UpdateErrorState,\n  allMajorDataSeries,\n  cancelUpdateWithRetry,\n  clearCachedVersionInfo,\n  toUpdateErrorState,\n  updateWithRetry,\n} from '@birchill/jpdict-idb';\n\nimport { requestIdleCallbackPromise } from '../utils/request-idle-callback';\n\nimport { JpdictState } from './jpdict';\nimport {\n  JpdictEvent,\n  leaveBreadcrumb,\n  notifyDbStateUpdated,\n  notifyDbUpdateComplete,\n  notifyError,\n} from './jpdict-events';\n\nexport type JpdictListener = (event: JpdictEvent) => void;\n\nexport interface JpdictBackend {\n  addEventListener(listener: JpdictListener): void;\n  removeEventListener(listener: JpdictListener): void;\n\n  updateDb(params: { lang: string; force: boolean }): void;\n  cancelUpdateDb(): void;\n  deleteDb(): void;\n  queryState(): void;\n}\n\nexport class JpdictLocalBackend implements JpdictBackend {\n  private db: JpdictIdb | undefined;\n  private dbIsInitialized: Promise<boolean>;\n  private currentUpdate:\n    | {\n        lang: string;\n        series: MajorDataSeries;\n        forceUpdate: boolean;\n      }\n    | undefined;\n\n  private lastUpdateError: UpdateErrorState | undefined;\n  private listeners: Array<JpdictListener> = [];\n\n  constructor() {\n    this.doDbStateNotification = this.doDbStateNotification.bind(this);\n    this.dbIsInitialized = this.initDb()\n      .then(() => true)\n      .catch(() => false);\n  }\n\n  addEventListener(listener: JpdictListener) {\n    if (!this.listeners.includes(listener)) {\n      this.listeners.push(listener);\n    }\n  }\n\n  removeEventListener(listener: JpdictListener) {\n    this.listeners = this.listeners.filter((l) => l !== listener);\n  }\n\n  async updateDb({ lang, force }: { lang: string; force: boolean }) {\n    try {\n      await this.updateAllSeries({ lang, forceUpdate: force });\n    } catch (error) {\n      this.notifyListeners(notifyError({ error }));\n    }\n  }\n\n  cancelUpdateDb() {\n    if (!this.currentUpdate) {\n      return;\n    }\n\n    cancelUpdateWithRetry({ db: this.db!, series: this.currentUpdate.series });\n    this.currentUpdate = undefined;\n  }\n\n  async deleteDb() {\n    if (this.db) {\n      try {\n        await this.db.destroy();\n      } catch (error) {\n        this.notifyListeners(notifyError({ error }));\n      }\n    }\n  }\n\n  async queryState() {\n    if (await this.dbIsInitialized) {\n      this.doDbStateNotification();\n    }\n  }\n\n  //\n  // Implementation helpers\n  //\n\n  private async initDb(): Promise<JpdictIdb> {\n    let retryCount = 0;\n    while (true) {\n      if (this.db) {\n        try {\n          await this.db.destroy();\n        } catch {\n          console.log('Failed to destroy previous database');\n        }\n      }\n\n      try {\n        this.db = new JpdictIdb({ verbose: true });\n        this.db.addChangeListener(this.doDbStateNotification);\n\n        await this.db.ready;\n        return this.db;\n      } catch (e) {\n        if (retryCount >= 3) {\n          console.log(\n            'Giving up opening database. Likely in permanent private browsing mode.'\n          );\n          throw e;\n        }\n        retryCount++;\n        console.log(\n          `Failed to open database. Retrying shortly (attempt: ${retryCount})...`\n        );\n        await requestIdleCallbackPromise({ timeout: 1000 });\n      }\n    }\n  }\n\n  private async updateAllSeries({\n    lang,\n    forceUpdate,\n  }: {\n    lang: string;\n    forceUpdate: boolean;\n  }) {\n    if (!(await this.dbIsInitialized)) {\n      return;\n    }\n\n    // Check for a current update\n    let wasForcedUpdate = false;\n    if (this.currentUpdate) {\n      // If the language matches and we're not (newly) forcing an update, then\n      // just let the current update run.\n      if (\n        this.currentUpdate.lang === lang &&\n        (this.currentUpdate.forceUpdate || !forceUpdate)\n      ) {\n        return;\n      }\n\n      // Otherwise, cancel the current update but make sure to propagate the\n      // forced flag if we were forced.\n      wasForcedUpdate = this.currentUpdate.forceUpdate;\n      this.cancelUpdateDb();\n      this.currentUpdate = undefined;\n    }\n\n    // Firefox 112+ (and presumably Thunderbird 112+) has an unfortunate bug\n    // where, when we try to clear an objectStore, it just hangs:\n    //\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1860486\n    //\n    // Until that bug is fixed (or we replace our database storage entirely), we\n    // need to detect when we are likely to want to clear an object store and\n    // simply blow away the whole database and replace it.\n    //\n    // That's quite unfortunate because it means we'll need to download all the\n    // names data again which is massive but it's better than having the user be\n    // stuck.\n    if (hasBuggyObjectStoreClear()) {\n      // Check if we need to replace the data, i.e. if running an update is\n      // likely to try and clear a data series' object store.\n      //\n      // There are basically two cases where this happens:\n      //\n      // 1. We are changing the language\n      //\n      // 2. The major/minor version of a data series has changed\n      //\n      // Working out if the language is changed is hard. Not all series have all\n      // languages so a mismatch between the passed-in `lang` and the series'\n      // language doesn't necessarily mean that the language has changed.\n      //\n      // Instead, if there are _no_ series that match the language we can assume\n      // it has changed.\n      const langChanged =\n        this.db &&\n        this.db.kanji.state === 'ok' &&\n        this.db.kanji.version?.lang !== lang &&\n        this.db.radicals.state === 'ok' &&\n        this.db.radicals.version?.lang !== lang &&\n        this.db.words.state === 'ok' &&\n        this.db.words.version?.lang !== lang;\n\n      // Working out if the major/minor version has changed is impossible\n      // without either:\n      //\n      // 1. Duplicating the logic to download the version info metadata here and\n      //    comparing it, or\n      //\n      // 2. Passing some sort of flag into `updateWithRetry` to indicate that\n      //    if the version has changed we should replace the database.\n      //\n      // Both are very invasive so we'll just have to commit to not updating the\n      // major/minor version until either the bug is fixed in Firefox or we\n      // replace our database storage.\n\n      if (langChanged) {\n        try {\n          this.notifyListeners(\n            leaveBreadcrumb({\n              message:\n                'Detected language change on buggy version of Firefox. Replacing database.',\n            })\n          );\n          await this.initDb();\n        } catch (error) {\n          this.notifyListeners(notifyError({ error }));\n        }\n      }\n    }\n\n    const onUpdateError =\n      (series: DataSeries) =>\n      (params: { error: Error; nextRetry?: Date; retryCount?: number }) => {\n        const { error, nextRetry, retryCount } = params;\n        if (nextRetry) {\n          const diffInMs = nextRetry.getTime() - Date.now();\n          this.notifyListeners(\n            leaveBreadcrumb({\n              message: `Encountered ${error.name} error updating ${series} database. Retrying in ${diffInMs}ms.`,\n            })\n          );\n\n          // We don't want to report all download errors since the auto-retry\n          // behavior will mean we get too many. Also, we don't care about\n          // intermittent failures for users on flaky network connections.\n          //\n          // However, if a lot of clients are failing multiple times to fetch\n          // a particular resource, we want to know.\n          if (retryCount === 5) {\n            this.notifyListeners(notifyError({ error, severity: 'warning' }));\n          }\n        } else if (\n          error.name !== 'AbortError' &&\n          error.name !== 'OfflineError'\n        ) {\n          this.notifyListeners(notifyError({ error }));\n        } else {\n          this.notifyListeners(\n            leaveBreadcrumb({\n              message: `Database update for ${series} database encountered ${error.name} error`,\n            })\n          );\n        }\n\n        this.lastUpdateError = toUpdateErrorState(params);\n        this.doDbStateNotification();\n      };\n\n    const runNextUpdate = () => {\n      // Check if we successfully updated a series\n      if (this.currentUpdate) {\n        this.lastUpdateError = undefined;\n        this.notifyListeners(\n          leaveBreadcrumb({\n            message: `Successfully updated ${this.currentUpdate.series} database`,\n          })\n        );\n        this.doDbStateNotification();\n      }\n\n      // Cycle through data series\n      //\n      // We use the following order:\n      //\n      // 1. Kanji\n      // 2. Names\n      // 3. Words\n      //\n      // Although the words dictionary is the most important one, we already have\n      // the flat-file version available for words so, if we're going to run out\n      // of disk space, it would be good to try and get as much of the other data\n      // in first.\n      if (!this.currentUpdate) {\n        this.currentUpdate = {\n          lang,\n          series: 'kanji',\n          forceUpdate: forceUpdate || wasForcedUpdate,\n        };\n      } else if (this.currentUpdate.series === 'kanji') {\n        this.currentUpdate.series = 'names';\n      } else if (this.currentUpdate.series === 'names') {\n        this.currentUpdate.series = 'words';\n      } else {\n        this.currentUpdate = undefined;\n        this.notifyListeners(\n          notifyDbUpdateComplete(getLatestCheckTime(this.db!))\n        );\n        return;\n      }\n\n      if (forceUpdate || wasForcedUpdate) {\n        clearCachedVersionInfo();\n      }\n      void updateWithRetry({\n        db: this.db!,\n        series: this.currentUpdate.series,\n        lang,\n        onUpdateComplete: runNextUpdate,\n        onUpdateError: onUpdateError(this.currentUpdate.series),\n      });\n    };\n\n    runNextUpdate();\n  }\n\n  private doDbStateNotification() {\n    // Wait until we have finished resolving the database versions before\n    // reporting anything.\n    if (\n      !this.db ||\n      this.db.words.state === 'init' ||\n      this.db.kanji.state === 'init' ||\n      this.db.radicals.state === 'init' ||\n      this.db.names.state === 'init'\n    ) {\n      return;\n    }\n\n    // Merge update states to show the current / latest update\n    const lastCheck = getLatestCheckTime(this.db);\n    const updateState = this.currentUpdate\n      ? this.db[this.currentUpdate.series].updateState\n      : { type: 'idle' as const, lastCheck };\n\n    const state: JpdictState = {\n      words: {\n        state: this.db.words.state,\n        version: this.db.words.version,\n      },\n      kanji: {\n        state: this.db.kanji.state,\n        version: this.db.kanji.version,\n      },\n      radicals: {\n        state: this.db.radicals.state,\n        version: this.db.radicals.version,\n      },\n      names: {\n        state: this.db.names.state,\n        version: this.db.names.version,\n      },\n      updateState,\n      updateError: this.lastUpdateError,\n    };\n\n    this.notifyListeners(notifyDbStateUpdated(state));\n  }\n\n  private notifyListeners(message: JpdictEvent) {\n    const listenersCopy = this.listeners.slice();\n    for (const listener of listenersCopy) {\n      listener(message);\n    }\n  }\n}\n\nfunction getLatestCheckTime(db: JpdictIdb): Date | null {\n  const latestCheckAsNumber = Math.max.apply(\n    null,\n    allMajorDataSeries.map((series) => db[series].updateState.lastCheck)\n  );\n\n  return latestCheckAsNumber !== 0 ? new Date(latestCheckAsNumber) : null;\n}\n\nfunction hasBuggyObjectStoreClear() {\n  const userAgent = navigator.userAgent;\n  const firefoxOrThunderbird = /(Firefox|Thunderbird)\\/(\\d+)/.exec(userAgent);\n  if (firefoxOrThunderbird && firefoxOrThunderbird[2]) {\n    const version = parseInt(firefoxOrThunderbird[2], 10);\n    // The bug has been fixed in Firefox 123.\n    return (\n      version >= 112 && (firefoxOrThunderbird[1] !== 'Firefox' || version < 123)\n    );\n  }\n  return false;\n}\n","/** @public */\nexport const halfWidthNumbers = /[0-9]/;\n\n// U+FF01~U+FF5E is for full-width alphanumerics (includes some punctuation\n// like  and  because they appear in the kanji headwords for some entries)\n//\n// Note that U+FF5E is full-width tilde  (not  which is a wave dash).\n//\n// U+FF61~U+FF65 is some halfwidth ideographic symbols, e.g.  but we skip them\n// (although previous rikai-tachi included them) since they're mostly going to\n// be delimiters\n/** @public */\nexport const fullWidthAlphanumerics = /[\\uff01-\\uff5e]/;\n\n// On some platforms, Google Docs puts zero-width joiner characters between\n// _all_ the characters so we need to match on them in order to match runs of\n// characters.\n/** @public */\nexport const zeroWidthNonJoiner = /[\\u200c]/;\n\n// * U+25CB is 'white circle' often used to represent a blank\n//   (U+3007 is an ideographic zero that is also sometimes used for this\n//   purpose, but this is included in the U+3001~U+30FF range.)\n/** @public */\nexport const whiteCircle = /[\\u25cb]/;\n\n// U+2E80~U+2EF3 is the CJK radicals supplement block\n// U+2F00~U+2FD5 is the Kangxi radicals block\n/** @public */\nexport const radicals = /[\\u2e80-\\u2ef3\\u2f00-\\u2fd5]/u;\n\n// * U+3000~U+3039 is ideographic punctuation but we skip:\n//\n//    U+3000 (ideographic space),\n//    U+3001 ( ideographic comma),\n//    U+3002 ( ideographic full stop),\n//    U+3003 ( ditto mark),\n//    U+3008,U+3009 (),\n//    U+300A,U+300B (),\n//    U+300C,U+300D ( corner brackets for quotations),\n//                  [ENAMDICT actually uses this in one entry,\n//                  \"\", but I think we\n//                  can live without being able to recognize that)\n//    U+300E,U+300F ( ), and\n//    U+3010,U+3011 ( ),\n//\n//   since these are typically only going to delimit words.\n/** @public */\nexport const nonDelimitingIdeographicPunctuation =\n  /[\\u3004-\\u3007\\u3012-\\u3039]/;\n\n// U+3041~U+309F is the hiragana range\n/** @public */\nexport const hiragana = /[\\u3041-\\u309f\\u{1b001}]/u;\n\n// U+30A0~U+30FF is the katakana range\n/** @public */\nexport const katakana = /[\\u30a0-\\u30ff\\u{1b000}]/u;\n\n// * U+3220~U+3247 is various enclosed characters like \n// * U+3280~U+32B0 is various enclosed characters like \n// * U+32D0~U+32FF is various enclosed characters like  and .\nconst enclosedChars = /[\\u3220-\\u3247\\u3280-\\u32b0\\u32d0-\\u32ff]/;\n\n// U+3300~U+3357 is various shorthand characters from the CJK compatibility\n// block like \nconst shorthandChars = /[\\u3300-\\u3357]/;\n\n// U+3358~U+3370 is numbers composed with  e.g. \nconst tenChars = /[\\u3358-\\u3370]/;\n\n// U+337B~U+337E is various era names e.g. \nconst eraChars = /[\\u337B-\\u337E]/;\n\n// U+337F is \nconst kabushikiGaisha = /[\\u337F]/;\n\n// U+4E00~U+9FFF is the CJK Unified Ideographs block (\"the kanji\")\n/** @public */\nexport const kanji = /[\\u4e00-\\u9fff]/;\n\n// * U+3400~U+4DBF is the CJK Unified Ideographs Extension A block (rare\n//   kanji)\n// * U+F900~U+FAFF is the CJK Compatibility Ideographs block (random odd\n//   kanji, because standards)\n// * U+20000~U+2A6DF is CJK Unified Ideographs Extension B (more rare kanji)\n/** @public */\nexport const rareKanji = /[\\u3400-\\u4dbf\\uf900-\\ufaff\\u{20000}-\\u{2a6df}]/u;\n\n// U+FF66~U+FF9F is halfwidth katakana\n/** @public */\nexport const halfwidthKatakanaChar = /[\\uff66-\\uff9f]/;\n\n// U+1B002-U+1B0FF is hentaigana\n/** @public */\nexport const hentaigana = /[\\u{1b002}-\\u{1b0ff}]/u;\n\nexport function getCombinedCharRange(ranges: Array<RegExp>): RegExp {\n  let source = '[';\n  let flags = '';\n\n  for (const range of ranges) {\n    // Check we have a character class\n    if (!isCharacterClassRange(range)) {\n      throw new Error(`Expected a character class range, got: ${range.source}`);\n    }\n\n    // Check it is not negated\n    if (range.source[1] === '^') {\n      throw new Error(\n        `Expected a non-negated character class range, got ${range.source}`\n      );\n    }\n\n    source += range.source.substring(1, range.source.length - 1);\n    if (range.flags.indexOf('u') !== -1) {\n      flags = 'u';\n    }\n  }\n\n  source += ']';\n\n  return new RegExp(source, flags);\n}\n\n// This is far from complete but all the RegExps we deal with are ones we've\n// written so hopefully it's a good-enough sanity check.\nfunction isCharacterClassRange(re: RegExp): boolean {\n  return (\n    re.source.length >= 2 &&\n    re.source.startsWith('[') &&\n    re.source.endsWith(']')\n  );\n}\n\n// \"Japanese\" here simply means any character we treat as worth attempting to\n// translate, including full-width alphanumerics etc. but NOT characters that\n// typically delimit words.\n/** @public */\nexport const japaneseChar = getCombinedCharRange([\n  // We include half-width numbers so we can recognize things like 1\n  halfWidthNumbers,\n  fullWidthAlphanumerics,\n  zeroWidthNonJoiner,\n  whiteCircle,\n  radicals,\n  nonDelimitingIdeographicPunctuation,\n  hiragana,\n  katakana,\n  enclosedChars,\n  shorthandChars,\n  tenChars,\n  eraChars,\n  kabushikiGaisha,\n  kanji,\n  rareKanji,\n  halfwidthKatakanaChar,\n  hentaigana,\n]);\n\nexport function getNegatedCharRange(range: RegExp): RegExp {\n  // Check if we got a character class range\n  if (!isCharacterClassRange(range)) {\n    throw new Error(`Expected a character class range, got: ${range.source}`);\n  }\n\n  const negated = range.source[1] === '^';\n\n  const source = `[${negated ? '' : '^'}${range.source.substring(\n    negated ? 2 : 1,\n    range.source.length - 1\n  )}]`;\n\n  return new RegExp(source, range.flags);\n}\n\nexport const nonJapaneseChar = getNegatedCharRange(japaneseChar);\n\nexport function hasKatakana(text: string): boolean {\n  return katakana.test(text);\n}\n\nexport function startsWithDigit(input: string): boolean {\n  const c = input.length ? input.charCodeAt(0) : 0;\n  return (c >= 48 && c <= 57) || (c >= 65296 && c <= 65305);\n}\n\nconst kanjiNumerals = [\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n  '',\n];\n\nexport function startsWithNumeral(input: string): boolean {\n  return (\n    startsWithDigit(input) ||\n    (!!input.length && kanjiNumerals.includes(input[0]))\n  );\n}\n\nconst onlyDigits = /^[0-9-,.]+$/;\n\nexport function isOnlyDigits(input: string): boolean {\n  return onlyDigits.test(input);\n}\n","// \nconst yoonStart = [\n  0x304d, 0x3057, 0x3061, 0x306b, 0x3072, 0x307f, 0x308a, 0x304e, 0x3058,\n  0x3073, 0x3074,\n];\n// \nconst smallY = [0x3083, 0x3085, 0x3087];\n\nexport function endsInYoon(input: string): boolean {\n  const length = [...input].length;\n  return (\n    length > 1 &&\n    smallY.includes(input.codePointAt(length - 1)!) &&\n    yoonStart.includes(input.codePointAt(length - 2)!)\n  );\n}\n","import Bugsnag from '@birchill/bugsnag-zero';\nimport { AbortError, NameResult, getNames } from '@birchill/jpdict-idb';\nimport { expandChoon, kyuujitaiToShinjitai } from '@birchill/normal-jp';\n\nimport { isOnlyDigits } from '../utils/char-range';\n\nimport { NameSearchResult } from './search-result';\nimport { endsInYoon } from './yoon';\n\nexport async function nameSearch({\n  abortSignal,\n  input,\n  inputLengths,\n  minInputLength,\n  maxResults,\n}: {\n  abortSignal?: AbortSignal;\n  input: string;\n  inputLengths: Array<number>;\n  minInputLength?: number;\n  maxResults: number;\n}): Promise<NameSearchResult | null> {\n  const result: NameSearchResult = {\n    type: 'names',\n    data: [],\n    more: false,\n    matchLen: 0,\n  };\n\n  // Record the position of existing entries for grouping purposes\n  const existingItems = new Map<string, number>();\n\n  // Record which entries we have already seen so we don't try to merge the same\n  // entries when matching on variants\n  const have = new Set<number>();\n\n  let currentString = input;\n\n  while (currentString.length > 0) {\n    // Check if we have been aborted\n    if (abortSignal?.aborted) {\n      throw new AbortError();\n    }\n\n    const currentInputLength = inputLengths[currentString.length];\n    if (minInputLength && minInputLength > currentInputLength) {\n      break;\n    }\n\n    // Don't lookup the input if we only have digits remaining.\n    if (isOnlyDigits(input)) {\n      break;\n    }\n\n    // Expand  to its various possibilities\n    const variations = [currentString, ...expandChoon(currentString)];\n\n    // See if there are any  we can convert to \n    const toNew = kyuujitaiToShinjitai(currentString);\n    if (toNew !== currentString) {\n      variations.push(toNew);\n    }\n\n    for (const variant of variations) {\n      let names: Array<NameResult>;\n      try {\n        names = await getNames(variant);\n      } catch (e) {\n        console.error('Error looking up names', e);\n        void Bugsnag.notify(e || '(Error looking up names)');\n        return null;\n      }\n\n      // Filter out entries we already have\n      names = names.filter((name) => !have.has(name.id));\n      if (!names.length) {\n        continue;\n      }\n\n      result.matchLen = Math.max(result.matchLen, currentInputLength);\n\n      for (const name of names) {\n        have.add(name.id);\n\n        // We group together entries where the kana readings and translation\n        // details are all equal.\n        const nameContents = getNameEntryHash(name);\n\n        // Check for an existing entry to combine with\n        const existingIndex = existingItems.get(nameContents);\n        if (typeof existingIndex !== 'undefined') {\n          const existingEntry = result.data[existingIndex];\n          if (name.k) {\n            if (!existingEntry.k) {\n              existingEntry.k = [];\n            }\n            existingEntry.k.push(...name.k);\n          }\n        } else {\n          result.data.push({ ...name, matchLen: currentInputLength });\n          existingItems.set(nameContents, result.data.length - 1);\n        }\n\n        if (result.data.length >= maxResults) {\n          return result;\n        }\n      }\n\n      // Unlike word searching, we don't restrict subsequent searches to this\n      // variant since if we get a search for  we want to return matches\n      // for _both_  and  and name entries.\n    }\n\n    // Shorten input, but don't split a  (e.g. ).\n    const lengthToShorten = endsInYoon(currentString) ? 2 : 1;\n    currentString = currentString.substr(\n      0,\n      currentString.length - lengthToShorten\n    );\n  }\n\n  if (!result.data.length) {\n    return null;\n  }\n\n  return result;\n}\n\nfunction getNameEntryHash(name: NameResult): string {\n  return (\n    name.r.join('-') +\n    '#' +\n    name.tr\n      .map(\n        (tr) =>\n          `${(tr.type || []).join(',')}-${tr.det.join(',')}${\n            tr.cf ? '-' + tr.cf.join(',') : ''\n          }`\n      )\n      .join(';')\n  );\n}\n","import { kanaToHiragana } from '@birchill/normal-jp';\n\n// Convert using a modified Hepburn-ish romajification\n\nconst replacements: Array<[string, string]> = [\n  ['', 'a'],\n  ['', 'i'],\n  ['', 'u'],\n  ['', 'e'],\n  ['', 'o'],\n  ['', 'ka'],\n  ['', 'ki'],\n  ['', 'ku'],\n  ['', 'ke'],\n  ['', 'ko'],\n  ['', 'kya'],\n  ['', 'kyu'],\n  ['', 'kyo'],\n  ['', 'sa'],\n  ['', 'shi'],\n  ['', 'su'],\n  ['', 'se'],\n  ['', 'so'],\n  ['', 'sha'],\n  ['', 'shu'],\n  ['', 'sho'],\n  ['', 'ta'],\n  ['', 'chi'],\n  ['', 'tsu'],\n  ['', 'te'],\n  ['', 'to'],\n  ['', 'cha'],\n  ['', 'chu'],\n  ['', 'cho'],\n  ['', 'na'],\n  ['', 'ni'],\n  ['', 'nu'],\n  ['', 'ne'],\n  ['', 'no'],\n  ['', 'nya'],\n  ['', 'nyu'],\n  ['', 'nyo'],\n  ['', 'ha'],\n  ['', 'hi'],\n  ['', 'fu'],\n  ['', 'he'],\n  ['', 'ho'],\n  ['', 'hya'],\n  ['', 'hyu'],\n  ['', 'hyo'],\n  ['', 'ma'],\n  ['', 'mi'],\n  ['', 'mu'],\n  ['', 'me'],\n  ['', 'mo'],\n  ['', 'mya'],\n  ['', 'myu'],\n  ['', 'myo'],\n  ['', 'ya'],\n  ['', 'yu'],\n  ['', 'yo'],\n  ['', 'ra'],\n  ['', 'ri'],\n  ['', 'ru'],\n  ['', 're'],\n  ['', 'ro'],\n  ['', 'rya'],\n  ['', 'ryu'],\n  ['', 'ryo'],\n  ['', 'wa'],\n  ['', 'i'],\n  ['', 'e'],\n  ['', 'o'],\n  ['', 'n'],\n  ['', 'ga'],\n  ['', 'gi'],\n  ['', 'gu'],\n  ['', 'ge'],\n  ['', 'go'],\n  ['', 'gya'],\n  ['', 'gyu'],\n  ['', 'gyo'],\n  ['', 'za'],\n  ['', 'ji'],\n  ['', 'zu'],\n  ['', 'ze'],\n  ['', 'zo'],\n  ['', 'ja'],\n  ['', 'ju'],\n  ['', 'jo'],\n  ['', 'da'],\n  ['', 'ji'],\n  ['', 'zu'],\n  ['', 'de'],\n  ['', 'do'],\n  ['', 'ja'],\n  ['', 'ju'],\n  ['', 'jo'],\n  ['', 'ba'],\n  ['', 'bi'],\n  ['', 'bu'],\n  ['', 'be'],\n  ['', 'bo'],\n  ['', 'bya'],\n  ['', 'byu'],\n  ['', 'byo'],\n  ['', 'pa'],\n  ['', 'pi'],\n  ['', 'pu'],\n  ['', 'pe'],\n  ['', 'po'],\n  ['', 'pya'],\n  ['', 'pyu'],\n  ['', 'pyo'],\n\n  // The following almost always appear in katakana, but well, people do crazy\n  // stuff so let's handle them in hiragana too (and it makes handling this\n  // easier too since we can just blindly convert everything to hiragana as\n  // a pre-processing step).\n  ['', 'yi'],\n  ['', 'ye'],\n  ['', 'wa'],\n  ['', 'wi'],\n  ['', 'wu'],\n  ['', 'we'],\n  ['', 'wo'],\n  ['', 'wyu'],\n  ['', 'va'],\n  ['', 'vi'],\n  ['', 'vu'],\n  ['', 've'],\n  ['', 'vo'],\n  ['', 'vya'],\n  ['', 'vyu'],\n  ['', 'vye'],\n  ['', 'vyo'],\n  ['', 'kye'],\n  ['', 'gye'],\n  ['', 'kwa'],\n  ['', 'kwi'],\n  ['', 'kwe'],\n  ['', 'kwo'],\n  ['', 'kwa'],\n  ['', 'gwa'],\n  ['', 'gwi'],\n  ['', 'gwe'],\n  ['', 'gwo'],\n  ['', 'gwa'],\n  ['', 'she'],\n  ['', 'je'],\n  ['', 'si'],\n  ['', 'zi'],\n  ['', 'che'],\n  ['', 'tsa'],\n  ['', 'tsi'],\n  ['', 'tse'],\n  ['', 'tso'],\n  ['', 'tsyu'],\n  ['', 'ti'],\n  ['', 'tu'],\n  ['', 'tyu'],\n  ['', 'di'],\n  ['', 'du'],\n  ['', 'dyu'],\n  ['', 'nye'],\n  ['', 'hye'],\n  ['', 'bye'],\n  ['', 'pye'],\n  ['', 'fa'],\n  ['', 'fi'],\n  ['', 'fe'],\n  ['', 'fo'],\n  ['', 'fya'],\n  ['', 'fyu'],\n  ['', 'fye'],\n  ['', 'fyo'],\n  ['', 'hu'],\n  ['', 'mye'],\n  ['', 'rye'],\n  ['', 'la'],\n  ['', 'li'],\n  ['', 'lu'],\n  ['', 'le'],\n  ['', 'lo'],\n  ['', 'lya'],\n  ['', 'lyu'],\n  ['', 'lye'],\n  ['', 'lyo'],\n\n  // These ones don't have hiragana equivalents, but these are basically for\n  //  anyway.\n  ['', 'va'],\n  ['', 'vi'],\n  ['', 've'],\n  ['', 'vo'],\n  ['', '-'],\n\n  // Seriously maniac territory here\n  ['', 'yori'],\n  ['', 'koto'],\n];\n\nconst maxReplacementLength = Math.max(...replacements.map(([a]) => a.length));\nconst replacementMap = new Map(replacements);\n\nexport function toRomaji(kana: string): string {\n  // We don't currently convert half-width katakana simply because we're not\n  // expecting to encounter it. If we do, we can use toNormalize for that.\n  const hiragana = kanaToHiragana(kana);\n\n  let result = '';\n\n  // Special handling for  so we can handle  high-tension\n  // expressions.\n  //\n  // (This will probably never appear in any dictionary entries, but in the\n  // interests of making this function a little more general-use we handle it\n  // anyway.)\n  let explosiveness = 0;\n\n  // Apply any built-up explosiveness when we don't have any following hiragana\n  // to apply it to.\n  const explode = () => {\n    if (explosiveness) {\n      result += \"'\".repeat(explosiveness);\n      explosiveness = 0;\n    }\n  };\n\n  let i = 0;\n  while (i < hiragana.length) {\n    const firstCharCode = hiragana.charCodeAt(i);\n\n    // Check for \n    if (firstCharCode === 0x3063) {\n      explosiveness++;\n      i++;\n      continue;\n    }\n\n    // Skip anything that is clearly out of range\n    if (firstCharCode < 0x3041) {\n      explode();\n      result += hiragana.substr(i, 1);\n      i++;\n      continue;\n    }\n\n    let substringLength = Math.max(maxReplacementLength, hiragana.length - i);\n\n    while (substringLength) {\n      const substring = hiragana.substr(i, substringLength);\n      const replacement = replacementMap.get(substring);\n      if (replacement) {\n        if (explosiveness) {\n          const initial = replacement[0] === 'c' ? 't' : replacement[0];\n          result += initial.repeat(explosiveness);\n          explosiveness = 0;\n        }\n\n        // Separate a vowel from a previous \n        if (\n          replacement.length === 1 &&\n          result &&\n          result[result.length - 1] === 'n' &&\n          ['a', 'e', 'i', 'o', 'u'].includes(replacement)\n        ) {\n          result += '-';\n        }\n\n        result += replacement;\n        break;\n      }\n\n      substringLength--;\n    }\n\n    // No match found, just append the character as-is.\n    if (!substringLength) {\n      explode();\n      result += hiragana.substr(i, 1);\n      substringLength = 1;\n    }\n\n    i += substringLength;\n  }\n\n  // Handle final  (e.g.   atsu')\n  explode();\n\n  return result;\n}\n","import { kanaToHiragana } from '@birchill/normal-jp';\n\nexport const enum Reason {\n  PolitePastNegative,\n  PoliteNegative,\n  PoliteVolitional,\n  Chau,\n  Sugiru,\n  PolitePast,\n  Tara,\n  Tari,\n  Causative,\n  PotentialOrPassive,\n  Toku,\n  Sou,\n  Tai,\n  Polite,\n  Respectful,\n  Humble,\n  HumbleOrKansaiDialect,\n  Past,\n  Negative,\n  Passive,\n  Ba,\n  Volitional,\n  Potential,\n  CausativePassive,\n  Te,\n  Zu,\n  Imperative,\n  MasuStem,\n  Adv,\n  Noun,\n  ImperativeNegative,\n  Continuous,\n  Ki,\n  SuruNoun,\n  ZaruWoEnai,\n  NegativeTe,\n  Irregular,\n}\n\nexport const deinflectL10NKeys: { [key: number]: string } = {\n  [Reason.Respectful]: 'deinflect_respectful',\n  [Reason.Humble]: 'deinflect_humble',\n  [Reason.HumbleOrKansaiDialect]: 'deinflect_humble_or_kansai_dialect',\n  [Reason.PolitePastNegative]: 'deinflect_polite_past_negative',\n  [Reason.PoliteNegative]: 'deinflect_polite_negative',\n  [Reason.PoliteVolitional]: 'deinflect_polite_volitional',\n  [Reason.Chau]: 'deinflect_chau',\n  [Reason.Sugiru]: 'deinflect_sugiru',\n  [Reason.PolitePast]: 'deinflect_polite_past',\n  [Reason.Tara]: 'deinflect_tara',\n  [Reason.Tari]: 'deinflect_tari',\n  [Reason.Causative]: 'deinflect_causative',\n  [Reason.PotentialOrPassive]: 'deinflect_potential_or_passive',\n  [Reason.Sou]: 'deinflect_sou',\n  [Reason.Toku]: 'deinflect_toku',\n  [Reason.Tai]: 'deinflect_tai',\n  [Reason.Polite]: 'deinflect_polite',\n  [Reason.Past]: 'deinflect_past',\n  [Reason.Negative]: 'deinflect_negative',\n  [Reason.Passive]: 'deinflect_passive',\n  [Reason.Ba]: 'deinflect_ba',\n  [Reason.Volitional]: 'deinflect_volitional',\n  [Reason.Potential]: 'deinflect_potential',\n  [Reason.CausativePassive]: 'deinflect_causative_passive',\n  [Reason.Te]: 'deinflect_te',\n  [Reason.Zu]: 'deinflect_zu',\n  [Reason.Imperative]: 'deinflect_imperative',\n  [Reason.MasuStem]: 'deinflect_masu_stem',\n  [Reason.Adv]: 'deinflect_adv',\n  [Reason.Noun]: 'deinflect_noun',\n  [Reason.ImperativeNegative]: 'deinflect_imperative_negative',\n  [Reason.Continuous]: 'deinflect_continuous',\n  [Reason.Ki]: 'deinflect_ki',\n  [Reason.SuruNoun]: 'deinflect_suru_noun',\n  [Reason.ZaruWoEnai]: 'deinflect_zaru_wo_enai',\n  [Reason.NegativeTe]: 'deinflect_negative_te',\n  [Reason.Irregular]: 'deinflect_irregular',\n};\n\nconst enum Type {\n  // Final word type\n  IchidanVerb = 1 << 0, // i.e. ru-verbs\n  GodanVerb = 1 << 1, // i.e. u-verbs\n  IAdj = 1 << 2,\n  KuruVerb = 1 << 3,\n  SuruVerb = 1 << 4,\n  SpecialSuruVerb = 1 << 5,\n  NounVS = 1 << 6,\n  All = IchidanVerb |\n    GodanVerb |\n    IAdj |\n    KuruVerb |\n    SuruVerb |\n    SpecialSuruVerb |\n    NounVS,\n  // Intermediate types\n  Initial = 1 << 7, // original word before any deinflection (from-type only)\n  TaTeStem = 1 << 8,\n  DaDeStem = 1 << 9,\n  MasuStem = 1 << 10,\n  IrrealisStem = 1 << 11,\n}\n\nexport { Type as WordType };\n\ntype DeinflectRule = {\n  from: string;\n  to: string;\n  // A bit mask representing the type of words to which this rule can be\n  // applied.\n  //\n  // For example,  would match the \"\"\"\" rule where the from-type\n  // is an ichidan/ru-verb while the to-type is the intermediate type masu-stem.\n  // The remaining  would then match the \"\"\"\" rule where the from-type\n  // is the intermediate type masu-stem while the to-type is a godan/u-verb.\n  //\n  // Intermediate types ensure that some rules are only applied in specific\n  // conditions.\n  //\n  // For example, consider the deinflection rule \"\"\"\". Without the to-type\n  // masu-stem everything following--not just the correct masu stem--would\n  // match it. \"\" would be parsed as \"< imperative < polite\", which\n  // is obviously not correct.\n  //\n  // Similarly, the type Intial ensures that a rule is only applied when it\n  // is at the very end of an inflecting word, as every to-type is different\n  // from it.\n  //\n  // These fields are bit masks since there can be multiple types\n  // accepted. For example, for the rule  the deinflected word\n  // could be an ichidan/ru-verb (e.g. ) but it could also be the special\n  // verb  (when it is written in hiragana a different rule will match). As\n  // a result, the to-type needs to represent both of these possibilities.\n  fromType: number;\n  toType: number;\n  reasons: Array<Reason>;\n};\n\n// prettier-ignore\nconst deinflectRuleData: Array<\n  [from: string, to: string, fromType: number, toType: number, reasons: Array<Reason>]\n> = [\n  // -------------- 7 --------------\n  ['', '', Type.Initial, Type.TaTeStem, [Reason.Respectful, Reason.Continuous, Reason.Imperative]],\n  ['', '', Type.GodanVerb, Type.TaTeStem, [Reason.Respectful, Reason.Continuous]],\n  ['', '', Type.Initial, Type.DaDeStem, [Reason.Respectful, Reason.Continuous, Reason.Imperative]],\n  ['', '', Type.GodanVerb, Type.DaDeStem, [Reason.Respectful, Reason.Continuous]],\n  // -------------- 6 --------------\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.PoliteNegative]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.PolitePastNegative]],\n  ['', '', Type.Initial, Type.TaTeStem, [Reason.Respectful, Reason.Continuous, Reason.Imperative]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.GodanVerb, Type.TaTeStem, [Reason.Respectful, Reason.Continuous]],\n  ['', '', Type.Initial, Type.DaDeStem, [Reason.Respectful, Reason.Continuous, Reason.Imperative]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.GodanVerb, Type.DaDeStem, [Reason.Respectful, Reason.Continuous]],\n  // -------------- 5 --------------\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  // -------------- 4 --------------\n  ['', '', Type.Initial, Type.IAdj, [Reason.Tara]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Tari]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.IchidanVerb, Type.KuruVerb, [Reason.Causative]],\n  ['', '', Type.IchidanVerb, Type.KuruVerb, [Reason.PotentialOrPassive]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.ZaruWoEnai]],\n  ['', '', Type.Initial, Type.SuruVerb, [Reason.NegativeTe]],\n  ['', '', Type.IchidanVerb, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Causative]],\n  ['', '', Type.IchidanVerb, Type.SpecialSuruVerb, [Reason.Irregular, Reason.PotentialOrPassive]],\n  ['', '', Type.IchidanVerb, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Causative]],\n  ['', '', Type.IchidanVerb, Type.SpecialSuruVerb, [Reason.Irregular, Reason.PotentialOrPassive]],\n  ['', '', Type.IchidanVerb, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Causative]],\n  ['', '', Type.IchidanVerb, Type.SpecialSuruVerb, [Reason.Irregular, Reason.PotentialOrPassive]],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Polite, Reason.Tara]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Polite, Reason.Tari]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.PoliteVolitional]],\n  // -------------- 3 --------------\n  ['', '', Type.GodanVerb, Type.MasuStem, [Reason.Humble]],\n  ['', '', Type.GodanVerb, Type.NounVS, [Reason.SuruNoun, Reason.Humble]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Past]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.IAdj, Type.IAdj, [Reason.Negative]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Ba]],\n  ['', '', Type.Initial, Type.KuruVerb, [Reason.Volitional]],\n  ['', '', Type.IchidanVerb, Type.KuruVerb, [Reason.Potential]],\n  ['', '', Type.IchidanVerb, Type.KuruVerb, [Reason.Potential]],\n  ['', '', Type.IchidanVerb, Type.KuruVerb, [Reason.Potential]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.IchidanVerb, Type.IchidanVerb | Type.KuruVerb, [Reason.Causative]],\n  ['', '', Type.IchidanVerb, Type.SuruVerb, [Reason.Causative]],\n  ['', '', Type.IAdj, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Negative]],\n  ['', '', Type.IchidanVerb, Type.IrrealisStem, [Reason.CausativePassive]],\n  ['', '', Type.IchidanVerb, Type.SuruVerb, [Reason.Passive]],\n  ['', '', Type.IAdj, Type.SuruVerb, [Reason.Negative]],\n  ['', '', Type.Initial, Type.SuruVerb, [Reason.Volitional]],\n  ['', '', Type.GodanVerb, Type.DaDeStem, [Reason.Chau]],\n  ['', '', Type.IchidanVerb, Type.IAdj, [Reason.Sugiru]],\n  ['', '', Type.IchidanVerb, Type.MasuStem, [Reason.Sugiru]],\n  ['', '', Type.IchidanVerb, Type.IAdj, [Reason.Sugiru]],\n  ['', '', Type.IchidanVerb, Type.MasuStem, [Reason.Sugiru]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Ba]],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.GodanVerb, Type.TaTeStem, [Reason.Chau]],\n  ['', '', Type.IchidanVerb, Type.TaTeStem, [Reason.Continuous]],\n  ['', '', Type.GodanVerb, Type.TaTeStem, [Reason.HumbleOrKansaiDialect, Reason.Continuous]],\n  ['', '', Type.IchidanVerb, Type.DaDeStem, [Reason.Continuous]],\n  ['', '', Type.GodanVerb, Type.DaDeStem, [Reason.HumbleOrKansaiDialect, Reason.Continuous]],\n  ['', '', Type.IchidanVerb, Type.SuruVerb, [Reason.Potential]],\n  ['', '', Type.Initial, Type.IrrealisStem, [Reason.NegativeTe]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Respectful, Reason.Imperative]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.GodanVerb, Type.MasuStem, [Reason.Respectful]],\n  ['', '', Type.GodanVerb, Type.NounVS, [Reason.SuruNoun, Reason.Respectful]],\n  ['', '', Type.GodanVerb, Type.MasuStem, [Reason.Respectful]],\n  ['', '', Type.GodanVerb, Type.NounVS, [Reason.SuruNoun, Reason.Respectful]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.PolitePast]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Polite, Reason.Te]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.PoliteNegative]],\n  ['', '', Type.IchidanVerb, Type.IchidanVerb | Type.KuruVerb, [Reason.PotentialOrPassive]],\n  // -------------- 2 --------------\n  ['', '', Type.GodanVerb, Type.MasuStem, [Reason.Humble]],\n  ['', '', Type.GodanVerb, Type.NounVS, [Reason.SuruNoun, Reason.Humble]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Te]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.Initial, Type.KuruVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.Initial, Type.SuruVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Zu]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Sugiru]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Sugiru]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Sugiru]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Sugiru]],\n  ['', '', Type.SuruVerb, Type.NounVS, [Reason.SuruNoun]],\n  ['', '', Type.Initial, Type.SuruVerb, [Reason.Zu]],\n  ['', '', Type.Initial, Type.SuruVerb, [Reason.Negative]],\n  ['', '', Type.Initial, Type.SuruVerb, [Reason.Negative]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Ba]],\n  ['', '', Type.Initial, Type.SuruVerb, [Reason.Imperative]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.IchidanVerb, Type.IrrealisStem, [Reason.Causative]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Zu]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Negative]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Imperative]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Sou]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Sou]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Volitional]],\n  ['', '', Type.IAdj, Type.MasuStem, [Reason.Tai]],\n  ['', '', Type.Initial, Type.TaTeStem, [Reason.Tara]],\n  ['', '', Type.Initial, Type.DaDeStem, [Reason.Tara]],\n  ['', '', Type.Initial, Type.TaTeStem, [Reason.Tari]],\n  ['', '', Type.Initial, Type.DaDeStem, [Reason.Tari]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.IchidanVerb, Type.TaTeStem, [Reason.Continuous]],\n  ['', '', Type.IchidanVerb, Type.DaDeStem, [Reason.Continuous]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.GodanVerb, Type.TaTeStem, [Reason.Toku]],\n  ['', '', Type.GodanVerb, Type.TaTeStem, [Reason.HumbleOrKansaiDialect, Reason.Continuous]],\n  ['', '', Type.GodanVerb, Type.DaDeStem, [Reason.Toku]],\n  ['', '', Type.GodanVerb, Type.DaDeStem, [Reason.HumbleOrKansaiDialect, Reason.Continuous]],\n  ['', '', Type.IAdj, Type.IrrealisStem, [Reason.Negative]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Polite]],\n  ['', '', Type.Initial, Type.MasuStem, [Reason.Polite, Reason.Imperative]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Ba]],\n  ['', '', Type.IchidanVerb, Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  ['', '', Type.Initial, Type.IchidanVerb | Type.KuruVerb, [Reason.Volitional]],\n  ['', '', Type.Initial, Type.IchidanVerb | Type.GodanVerb | Type.KuruVerb | Type.SuruVerb, [Reason.Ba]],\n  ['', '', Type.IchidanVerb, Type.IchidanVerb | Type.GodanVerb, [Reason.Potential]],\n  ['', '', Type.IchidanVerb, Type.IrrealisStem, [Reason.Passive]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Volitional]],\n  // Irregular -form stems\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  // -------------- 1 --------------\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.DaDeStem, Type.GodanVerb, []],\n  ['', '', Type.Initial, Type.KuruVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Ki]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.TaTeStem, Type.KuruVerb, []],\n  ['', '', Type.MasuStem, Type.KuruVerb, [Reason.MasuStem]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Adv]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.IrrealisStem, Type.KuruVerb, []],\n  ['', '', Type.Initial, Type.IAdj, [Reason.Noun]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.MasuStem, Type.SuruVerb, [Reason.MasuStem]],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.SuruVerb, []],\n  ['', '', Type.Initial, Type.IrrealisStem, [Reason.Zu]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.SpecialSuruVerb, [Reason.Irregular, Reason.Imperative]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.Initial, Type.TaTeStem, [Reason.Past]],\n  ['', '', Type.Initial, Type.DaDeStem, [Reason.Past]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.TaTeStem, Type.GodanVerb, []],\n  ['', '', Type.Initial, Type.TaTeStem, [Reason.Te]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.DaDeStem, [Reason.Te]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.Initial, Type.IchidanVerb | Type.GodanVerb | Type.KuruVerb | Type.SuruVerb, [Reason.ImperativeNegative]],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.IrrealisStem, [Reason.Negative]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.IchidanVerb, [Reason.Imperative]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.MasuStem, Type.GodanVerb, [Reason.MasuStem]],\n  ['', '', Type.Initial, Type.GodanVerb, [Reason.Imperative]],\n  ['', '', Type.Initial, Type.IchidanVerb, [Reason.Imperative]],\n  ['', '', Type.IrrealisStem, Type.GodanVerb, []],\n  ['', '', Type.DaDeStem, Type.GodanVerb, []],\n  ['', '', Type.DaDeStem, Type.GodanVerb, []],\n  ['', '', Type.DaDeStem, Type.GodanVerb, []],\n  ['', '', Type.Initial, Type.IrrealisStem, [Reason.Negative]],\n];\n\ninterface DeinflectRuleGroup {\n  rules: Array<DeinflectRule>;\n  fromLen: number;\n}\n\nconst deinflectRuleGroups: Array<DeinflectRuleGroup> = [];\n\nfunction getDeinflectRuleGroups() {\n  if (!deinflectRuleGroups.length) {\n    let prevLen = -1;\n    let ruleGroup: DeinflectRuleGroup;\n\n    for (const [from, to, fromType, toType, reasons] of deinflectRuleData) {\n      const rule: DeinflectRule = { from, to, fromType, toType, reasons };\n\n      if (prevLen !== rule.from.length) {\n        prevLen = rule.from.length;\n        ruleGroup = { rules: [], fromLen: prevLen };\n        deinflectRuleGroups.push(ruleGroup);\n      }\n      ruleGroup!.rules.push(rule);\n    }\n  }\n\n  return deinflectRuleGroups;\n}\n\nexport interface CandidateWord {\n  // The de-inflected candidate word\n  word: string;\n  // An optional sequence of reasons describing the how |word| was derived\n  // from the original input string.\n  //\n  // Each array is a sequence of rules applied in turn.\n  // There may be multiple arrays when multiple sequences of rules were applied\n  // to produce word.\n  reasonChains: Array<Array<Reason>>;\n  // For a de-inflected word, this is a bitfield comprised of flags from the\n  // WordType enum describing the possible types of word this could represent\n  // (e.g. godan verb, i-adj). If a word looked up in the dictionary does not\n  // match this type, it should be ignored since the deinflection is not valid\n  // in that case.\n  //\n  // See the extended notes for DeinflectRule.rule.\n  type: number;\n}\n\n// Returns an array of possible de-inflected versions of |word|.\nexport function deinflect(word: string): CandidateWord[] {\n  let result: Array<CandidateWord> = [];\n  const resultIndex: { [index: string]: number } = {};\n  const ruleGroups = getDeinflectRuleGroups();\n\n  const original: CandidateWord = {\n    word,\n    // Initially, the type of word is unknown, so we set the type mask to\n    // match all rules except stems, that don't make sense on their own.\n    type: 0xffff ^ (Type.TaTeStem | Type.DaDeStem | Type.IrrealisStem),\n    reasonChains: [],\n  };\n  result.push(original);\n  resultIndex[word] = 0;\n\n  let i = 0;\n  do {\n    const thisCandidate = result[i];\n\n    // Don't deinflect masu-stem results of Ichidan verbs any further since\n    // they should already be the plain form.\n    //\n    // Without this we would take something like , try deinflecting it as\n    // a masu stem into  and then try de-inflecting it as a continuous\n    // form. However, we should just stop immediately after de-inflecting to\n    // the plain form.\n    if (\n      thisCandidate.type & Type.IchidanVerb &&\n      thisCandidate.reasonChains.length === 1 &&\n      thisCandidate.reasonChains[0].length === 1 &&\n      thisCandidate.reasonChains[0][0] === Reason.MasuStem\n    ) {\n      continue;\n    }\n\n    const word = thisCandidate.word;\n    const type = thisCandidate.type;\n\n    // Ichidan verbs have only one stem, which is the plain form minus the\n    // final . Since the stem is shorter than the plain form, to avoid\n    // adding multiple entries for all possible stem variations to the rule\n    // data array, we forward the stem to the plain form programmatically.\n    if (type & (Type.MasuStem | Type.TaTeStem | Type.IrrealisStem)) {\n      const reason = [];\n\n      // Add the \"masu\" reason only if the word is solely the masu stem.\n      if (type & Type.MasuStem && !thisCandidate.reasonChains.length) {\n        reason.push([Reason.MasuStem]);\n      }\n\n      // Ichidan verbs attach the auxiliary verbs  and  instead of\n      //  and  for the passive and causative forms to their stem. Since\n      //  and  exist as separate rules that bypass the irrealis stem\n      // type, we ignore the the rules with a to-type of IrrealisStem for the\n      // passive and causative, i.e. the rules for  and .\n      // Similarly, we need to ignore the rule for the causative passive, as\n      // the contraction of  to  is incorrect for Ichidan verbs.\n      const inapplicableForm =\n        type & Type.IrrealisStem &&\n        (thisCandidate.reasonChains[0][0] == Reason.Passive ||\n          thisCandidate.reasonChains[0][0] == Reason.Causative ||\n          thisCandidate.reasonChains[0][0] == Reason.CausativePassive);\n\n      if (!inapplicableForm) {\n        result.push({\n          word: word + '',\n          type: Type.IchidanVerb | Type.KuruVerb,\n          reasonChains: [...thisCandidate.reasonChains, ...reason],\n        });\n      }\n    }\n\n    for (const ruleGroup of ruleGroups) {\n      if (ruleGroup.fromLen > word.length) {\n        continue;\n      }\n\n      const ending = word.slice(-ruleGroup.fromLen);\n      const hiraganaEnding = kanaToHiragana(ending);\n\n      for (const rule of ruleGroup.rules) {\n        if (!(type & rule.fromType)) {\n          continue;\n        }\n\n        if (ending !== rule.from && hiraganaEnding !== rule.from) {\n          continue;\n        }\n\n        const newWord =\n          word.substring(0, word.length - rule.from.length) + rule.to;\n        if (!newWord.length) {\n          continue;\n        }\n\n        // Continue if the rule introduces a duplicate in the reason chain,\n        // as it wouldn't make sense grammatically.\n        const ruleReasons = new Set(rule.reasons);\n        if (thisCandidate.reasonChains.flat().some((r) => ruleReasons.has(r))) {\n          continue;\n        }\n\n        // If we already have a candidate for this word with the same\n        // 'to' type(s), expand the possible reasons by starting a new\n        // reason chain.\n        //\n        // We do not want to start a new reason chain with a pure forwarding\n        // rule, represented by an empty reasons array, as it cannot stand on\n        // its own and needs a preceding rule to make sense.\n        //\n        // If the 'to' type(s) differ, then we'll add a separate candidate\n        // and just hope that when we go to match against dictionary words\n        // we'll filter out the mismatching one(s).\n        if (resultIndex[newWord]) {\n          const candidate = result[resultIndex[newWord]];\n          if (candidate.type === rule.toType) {\n            if (rule.reasons.length) {\n              // Start a new reason chain\n              candidate.reasonChains.unshift([...rule.reasons]);\n            }\n            continue;\n          }\n        }\n        resultIndex[newWord] = result.length;\n\n        //\n        // Start a new candidate\n        //\n\n        // Deep clone multidimensional array\n        const reasonChains = [];\n        for (const array of thisCandidate.reasonChains) {\n          reasonChains.push([...array]);\n        }\n\n        // We only need to add something to the reason chain if the rule is\n        // not a pure forwarding rule, i.e. the reasons array is not empty.\n        if (rule.reasons.length) {\n          // Add our new reason in\n          //\n          // If we already have reason chains, prepend to the first chain\n          if (reasonChains.length) {\n            const firstReasonChain = reasonChains[0];\n\n            // Rather having causative + passive, combine the two rules into\n            // \"causative passive\":\n            if (\n              rule.reasons[0] === Reason.Causative &&\n              firstReasonChain.length &&\n              firstReasonChain[0] === Reason.PotentialOrPassive\n            ) {\n              firstReasonChain.splice(0, 1, Reason.CausativePassive);\n            } else if (\n              // Add the \"masu\" reason only if the word is solely the masu stem.\n              rule.reasons[0] === Reason.MasuStem &&\n              firstReasonChain.length\n            ) {\n              // Do nothing\n            } else {\n              firstReasonChain.unshift(...rule.reasons);\n            }\n          } else {\n            // Add new reason to the start of the chain\n            reasonChains.push([...rule.reasons]);\n          }\n        }\n\n        const candidate: CandidateWord = {\n          reasonChains,\n          type: rule.toType,\n          word: newWord,\n        };\n\n        result.push(candidate);\n      }\n    }\n  } while (++i < result.length);\n\n  // Post-process to filter out any lingering intermediate forms\n  result = result.filter((r) => r.type & Type.All);\n\n  return result;\n}\n","import { AbortError, PartOfSpeech } from '@birchill/jpdict-idb';\nimport { expandChoon, kyuujitaiToShinjitai } from '@birchill/normal-jp';\nimport browser from 'webextension-polyfill';\n\nimport { isOnlyDigits } from '../utils/char-range';\nimport { toRomaji } from '../utils/romaji';\n\nimport {\n  CandidateWord,\n  WordType,\n  deinflect,\n  deinflectL10NKeys,\n} from './deinflect';\nimport {\n  DictionaryWordResult,\n  WordResult,\n  WordSearchResult,\n} from './search-result';\nimport { sortWordResults } from './word-match-sorting';\nimport { endsInYoon } from './yoon';\n\nexport type GetWordsFunction = (params: {\n  input: string;\n  maxResults: number;\n}) => Promise<Array<DictionaryWordResult>>;\n\nexport async function wordSearch({\n  abortSignal,\n  getWords,\n  input,\n  inputLengths,\n  maxResults,\n  includeRomaji,\n}: {\n  abortSignal?: AbortSignal;\n  getWords: GetWordsFunction;\n  input: string;\n  inputLengths: Array<number>;\n  maxResults: number;\n  includeRomaji: boolean;\n}): Promise<WordSearchResult | null> {\n  let longestMatch = 0;\n  let have = new Set<number>();\n  const result: WordSearchResult = {\n    type: 'words',\n    data: [],\n    more: false,\n    matchLen: 0,\n  };\n  let includeVariants = true;\n\n  while (input.length) {\n    // Check if we have been aborted\n    if (abortSignal?.aborted) {\n      throw new AbortError();\n    }\n\n    // If we only have digits left, don't bother looking them up since we don't\n    // want to bother the user by showing the popup every time they hover over a\n    // digit.\n    if (isOnlyDigits(input)) {\n      break;\n    }\n\n    // If we include a de-inflected substring we show it in the reasons string.\n    const showInflections = !!result.data.length;\n\n    const variations = [input];\n\n    // Generate variations on this substring\n    if (includeVariants) {\n      // Expand  to its various possibilities\n      variations.push(...expandChoon(input));\n\n      // See if there are any  we can convert to \n      const toNew = kyuujitaiToShinjitai(input);\n      if (toNew !== input) {\n        variations.push(toNew);\n      }\n    }\n\n    for (const variant of variations) {\n      const wordResults = await lookupCandidates({\n        abortSignal,\n        existingEntries: have,\n        getWords,\n        input: variant,\n        includeRomaji,\n        maxResults,\n        showInflections,\n      });\n\n      if (!wordResults.length) {\n        continue;\n      }\n\n      // Now that we have filtered our set of matches to those we plan to keep,\n      // update our duplicates set.\n      have = new Set([...have, ...wordResults.map((word) => word.id)]);\n\n      // And now that we know we will add at least one entry for this candidate\n      // we can update our longest match length.\n      longestMatch = Math.max(longestMatch, inputLengths[input.length]);\n\n      // Add the results to the list\n      //\n      // TODO: This is not right. If we end up with exactly maxResults, we\n      // shouldn't set `more` to true unless we know that there were actually\n      // more results. Fixing this will require changing the signature\n      // GetWordsFunction, however.\n      if (result.data.length + wordResults.length >= maxResults) {\n        result.more = true;\n      }\n\n      result.data.push(\n        ...wordResults.slice(0, maxResults - result.data.length)\n      );\n\n      // Continue refining this variant excluding all others\n      input = variant;\n      includeVariants = false;\n      break;\n    }\n\n    if (result.data.length >= maxResults) {\n      break;\n    }\n\n    // Shorten input, but don't split a  (e.g. ).\n    const lengthToShorten = endsInYoon(input) ? 2 : 1;\n    input = input.substring(0, input.length - lengthToShorten);\n  }\n\n  if (!result.data.length) {\n    return null;\n  }\n\n  result.matchLen = longestMatch;\n  return result;\n}\n\nasync function lookupCandidates({\n  abortSignal,\n  existingEntries,\n  getWords,\n  includeRomaji,\n  input,\n  maxResults,\n  showInflections,\n}: {\n  abortSignal?: AbortSignal;\n  existingEntries: Set<number>;\n  getWords: GetWordsFunction;\n  includeRomaji: boolean;\n  input: string;\n  maxResults: number;\n  showInflections: boolean;\n}): Promise<Array<WordResult>> {\n  const result: Array<WordResult> = [];\n\n  const candidates: Array<CandidateWord> = deinflect(input);\n  for (const [candidateIndex, candidate] of candidates.entries()) {\n    if (abortSignal?.aborted) {\n      throw new AbortError();\n    }\n\n    let wordResults = await lookupCandidate({\n      candidate,\n      getWords,\n      includeRomaji,\n      originalInput: input,\n      isDeinflection: candidateIndex !== 0,\n      maxResults,\n      showInflections,\n    });\n\n    // Drop redundant results\n    wordResults = wordResults.filter((word) => !existingEntries.has(word.id));\n\n    result.push(...wordResults);\n  }\n\n  // The results are currently sorted for each candidate lookup but we really\n  // want to sort _across_ all the candidate lookups.\n  sortWordResults(result);\n\n  return result;\n}\n\nasync function lookupCandidate({\n  candidate,\n  getWords,\n  includeRomaji,\n  originalInput: input,\n  isDeinflection,\n  maxResults,\n  showInflections,\n}: {\n  candidate: CandidateWord;\n  getWords: GetWordsFunction;\n  includeRomaji: boolean;\n  originalInput: string;\n  isDeinflection: boolean;\n  maxResults: number;\n  showInflections: boolean;\n}): Promise<Array<WordResult>> {\n  let matches = await getWords({ input: candidate.word, maxResults });\n\n  // The deinflection code doesn't know anything about the actual words. It just\n  // produces possible deinflections along with a type that says what kind of a\n  // word (e.g. godan verb, i-adjective etc.) it must be in order for that\n  // deinflection to be valid.\n  //\n  // So, if we have a possible deinflection, we need to check that it matches\n  // the kind of word we looked up.\n  matches = matches.filter(\n    (match) => !isDeinflection || entryMatchesType(match, candidate.type)\n  );\n\n  if (!matches.length) {\n    return [];\n  }\n\n  // Generate the reason string\n  let reason: string | undefined;\n  if (candidate.reasonChains.length) {\n    reason =\n      '< ' +\n      candidate.reasonChains\n        .map((reasonList) =>\n          reasonList\n            .map((reason) => browser.i18n.getMessage(deinflectL10NKeys[reason]))\n            .join(' < ')\n        )\n        .join(browser.i18n.getMessage('deinflect_alternate'));\n    if (showInflections) {\n      reason += ` < ${input}`;\n    }\n  }\n\n  // Process each match into a suitable result\n  const result: Array<WordResult> = [];\n\n  for (const match of matches) {\n    const wordResult: WordResult = { ...match, reason };\n\n    if (includeRomaji) {\n      wordResult.romaji = match.r.map((r) => toRomaji(r.ent));\n    }\n\n    result.push(wordResult);\n  }\n\n  return result;\n}\n\n// Tests if a given entry matches the type of a generated deflection\nfunction entryMatchesType(entry: DictionaryWordResult, type: number): boolean {\n  const hasMatchingSense = (test: (pos: PartOfSpeech) => boolean) =>\n    entry.s.some((sense) => sense.pos?.some(test));\n\n  if (\n    type & WordType.IchidanVerb &&\n    hasMatchingSense((pos) => pos.startsWith('v1'))\n  ) {\n    return true;\n  }\n\n  if (\n    type & WordType.GodanVerb &&\n    hasMatchingSense((pos) => pos.startsWith('v5') || pos.startsWith('v4'))\n  ) {\n    return true;\n  }\n\n  if (\n    type & WordType.IAdj &&\n    hasMatchingSense((pos) => pos.startsWith('adj-i'))\n  ) {\n    return true;\n  }\n\n  if (type & WordType.KuruVerb && hasMatchingSense((pos) => pos === 'vk')) {\n    return true;\n  }\n\n  if (\n    type & WordType.SuruVerb &&\n    hasMatchingSense((pos) => pos === 'vs-i' || pos === 'vs-s')\n  ) {\n    return true;\n  }\n\n  if (\n    type & WordType.SpecialSuruVerb &&\n    hasMatchingSense((pos) => pos === 'vs-s' || pos === 'vz')\n  ) {\n    return true;\n  }\n\n  if (type & WordType.NounVS && hasMatchingSense((pos) => pos === 'vs')) {\n    return true;\n  }\n\n  return false;\n}\n","import Bugsnag from '@birchill/bugsnag-zero';\nimport {\n  DataSeries,\n  DataSeriesState,\n  DataVersion,\n  UpdateErrorState,\n  UpdateState,\n  getKanji,\n  getWords as idbGetWords,\n} from '@birchill/jpdict-idb';\nimport { kanaToHiragana } from '@birchill/normal-jp';\nimport browser from 'webextension-polyfill';\n\nimport { normalizeInput } from '../utils/normalize-input';\nimport { JpdictWorkerBackend } from '../worker/jpdict-worker-backend';\n\nimport { FlatFileDatabaseLoadState, FlatFileDatabaseLoader } from './flat-file';\nimport { JpdictBackend, JpdictLocalBackend } from './jpdict-backend';\nimport { JpdictEvent } from './jpdict-events';\nimport { nameSearch } from './name-search';\nimport {\n  KanjiSearchResult,\n  NameSearchResult,\n  TranslateResult,\n  WordSearchResult,\n} from './search-result';\nimport { GetWordsFunction, wordSearch } from './word-search';\n\n//\n// Exported types\n//\n\nexport type JpdictState = {\n  words: {\n    state: DataSeriesState;\n    version: DataVersion | null;\n  };\n  kanji: {\n    state: DataSeriesState;\n    version: DataVersion | null;\n  };\n  radicals: {\n    state: DataSeriesState;\n    version: DataVersion | null;\n  };\n  names: {\n    state: DataSeriesState;\n    version: DataVersion | null;\n  };\n  updateState: UpdateState;\n  updateError?: UpdateErrorState;\n};\n\nexport type JpdictStateWithFallback = Omit<JpdictState, 'words'> & {\n  words: JpdictState['words'] & {\n    fallbackState: FlatFileDatabaseLoadState;\n  };\n};\n\n//\n// Minimum amount of time to wait before checking for database updates.\n//\n\nconst UPDATE_THRESHOLD_MS = 12 * 60 * 60 * 1000; // 12 hours\n\n//\n// Backend setup\n//\n\nconst backend: JpdictBackend =\n  'Worker' in self ? new JpdictWorkerBackend() : new JpdictLocalBackend();\n\n// Local state tracking\n//\n// We track some state locally because we want to avoid querying the database\n// when it is being updated since this can block for several seconds.\n\nlet dbState: JpdictStateWithFallback = {\n  words: {\n    state: 'init',\n    version: null,\n    fallbackState: 'unloaded',\n  },\n  kanji: {\n    state: 'init',\n    version: null,\n  },\n  radicals: {\n    state: 'init',\n    version: null,\n  },\n  names: {\n    state: 'init',\n    version: null,\n  },\n  updateState: { type: 'idle', lastCheck: null },\n};\n\n// Is the IDB database available for the given series?\n//\n// We structure the tables and access them in a way that means we _should_ be\n// able to use, e.g., the 'words' table in a performant manner while the 'names'\n// table is being updated, but this doesn't appear to work for Chrome which\n// suffers significant lag when any tables in the database are being accessed.\n//\n// As a result we simply don't touch IDB while it's being updated.\nfunction getDataSeriesStatus(\n  series: DataSeries\n): 'ok' | 'updating' | 'unavailable' {\n  // If we're unavailable or initializing, treat the database as unavailable\n  // regardless of whether or not we're updating.\n  if (\n    dbState[series].state === 'unavailable' ||\n    dbState[series].state === 'init'\n  ) {\n    return 'unavailable';\n  }\n\n  // Otherwise, whether we're empty or ok, check if we're updating.\n  if (dbState.updateState.type !== 'idle') {\n    return 'updating';\n  }\n\n  // Otherwise treat empty as unavailable.\n  return dbState[series].state === 'ok' ? 'ok' : 'unavailable';\n}\n\n// Fallback words database to use if we can't read the IndexedDB one (e.g.\n// because we hit a quota error, or because it is currently being updated).\n\nconst fallbackDatabaseLoader = new FlatFileDatabaseLoader({\n  // If 'process' is defined, we're running in a node environment, which\n  // which probably means we're running in a test environment and should not\n  // bother trying to call bugsnag.\n  bugsnag: typeof process === 'object' ? undefined : Bugsnag,\n});\n\n// We also need to track the lastUpdateTime locally. That's because if\n// we tried to read it from extension storage when we get worker messages,\n// because the API is async, on Chrome we can get situations where we actually\n// end up applying the database state messages in the wrong order.\n\nlet lastUpdateTime: number | null = null;\n\n//\n// Public API\n//\n\nlet initPromise: Promise<void> | undefined;\nlet initComplete = false;\n\nexport async function initDb({\n  lang,\n  onUpdate,\n}: {\n  lang: string;\n  onUpdate: (status: JpdictStateWithFallback) => void;\n}) {\n  if (initPromise) {\n    await initPromise;\n    return;\n  }\n\n  let resolveInitPromise: () => void;\n  initPromise = new Promise((resolve) => {\n    resolveInitPromise = resolve;\n  });\n\n  lastUpdateTime = await getLastUpdateTime();\n  Bugsnag.leaveBreadcrumb(`Got last update time of ${lastUpdateTime}`);\n\n  // Register the listener\n  backend.addEventListener(async (event: JpdictEvent) => {\n    switch (event.type) {\n      case 'dbstateupdated':\n        {\n          // Prepare the new state while preserving the existing fallback state.\n          const state = {\n            ...event.state,\n            words: {\n              ...event.state.words,\n              fallbackState: dbState.words.fallbackState,\n            },\n          };\n\n          // Fill out the lastCheck field in the updateState.\n          //\n          // This value will only be set if we already did a check this session.\n          // It is _not_ a stored value.  So, if it is not set, use the value we\n          // stored instead.\n          if (state.updateState.lastCheck === null && lastUpdateTime) {\n            state.updateState.lastCheck = new Date(lastUpdateTime);\n          }\n\n          dbState = state;\n\n          try {\n            onUpdate(state);\n          } catch (e) {\n            void Bugsnag.notify(e);\n          }\n\n          if (!initComplete) {\n            initComplete = true;\n            resolveInitPromise();\n          }\n        }\n        break;\n\n      case 'dbupdatecomplete':\n        if (event.lastCheck) {\n          void setLastUpdateTime(event.lastCheck.getTime());\n        }\n        break;\n\n      case 'breadcrumb':\n        Bugsnag.leaveBreadcrumb(event.message);\n        break;\n\n      case 'error':\n        {\n          const error = new Error(event.message);\n          error.name = event.name;\n          error.stack = event.stack;\n          void Bugsnag.notify(error, { severity: event.severity });\n        }\n        break;\n    }\n  });\n\n  // Make sure updates to the fallback database loading state are also reported.\n  //\n  // But first, reset any loads that might have errored or hung so that the\n  // user can retry the load by disabling/enabling the add-on.\n  fallbackDatabaseLoader.resetIfNotLoaded();\n  fallbackDatabaseLoader.onUpdate = (\n    fallbackDatabaseState: FlatFileDatabaseLoadState\n  ) => {\n    dbState.words.fallbackState = fallbackDatabaseState;\n    onUpdate(dbState);\n  };\n\n  // Fetch the initial state\n  backend.queryState();\n\n  // If we updated within the minimum window then we don't need to update\n  if (lastUpdateTime && Date.now() - lastUpdateTime < UPDATE_THRESHOLD_MS) {\n    Bugsnag.leaveBreadcrumb('Downloaded data is up-to-date');\n  } else {\n    updateDb({ lang, force: false });\n  }\n\n  await initPromise;\n}\n\nasync function getLastUpdateTime(): Promise<number | null> {\n  try {\n    const getResult = await browser.storage.local.get('lastDbUpdateTime');\n    if (typeof getResult.lastDbUpdateTime === 'number') {\n      return getResult.lastDbUpdateTime as number;\n    }\n  } catch {\n    // Extension storage can sometimes randomly fail with 'An unexpected error\n    // occurred'. Ignore, but log it.\n    console.warn('Failed to get last update time from storage');\n  }\n\n  return null;\n}\n\nasync function setLastUpdateTime(time: number | null) {\n  // Make sure to update the local version too.\n  lastUpdateTime = time;\n\n  // Extension storage can randomly fail with \"An unexpected error occurred\".\n  try {\n    if (time) {\n      await browser.storage.local.set({\n        lastDbUpdateTime: time,\n      });\n    } else {\n      await browser.storage.local.remove('lastDbUpdateTime');\n    }\n\n    // Try to remove any old value we stored so we don't end up using it\n    // accidentally.\n    browser.storage.local.remove('lastUpdateKanjiDb').catch(() => {\n      /* Ignore */\n    });\n  } catch {\n    // Don't notify Bugsnag because this is a common error in Firefox.\n  }\n}\n\nexport function updateDb(params: { lang: string; force: boolean }) {\n  backend.updateDb(params);\n}\n\nexport function cancelUpdateDb() {\n  backend.cancelUpdateDb();\n}\n\nexport function deleteDb() {\n  backend.deleteDb();\n  void setLastUpdateTime(null);\n}\n\n// ---------------------------------------------------------------------------\n//\n// Words\n//\n// ---------------------------------------------------------------------------\n\nconst WORDS_MAX_ENTRIES = 7;\n\nexport async function searchWords({\n  input,\n  abortSignal,\n  includeRomaji = false,\n  max = 0,\n}: {\n  input: string;\n  abortSignal?: AbortSignal;\n  includeRomaji?: boolean;\n  max?: number;\n}): Promise<\n  [\n    result: WordSearchResult | null,\n    dbStatus: 'updating' | 'unavailable' | undefined,\n  ]\n> {\n  let [word, inputLengths] = normalizeInput(input);\n\n  const maxResults =\n    max > 0 ? Math.min(WORDS_MAX_ENTRIES, max) : WORDS_MAX_ENTRIES;\n\n  // Determine which dictionary to use: The IndexedDB one or the flat-file\n  // fallback dictionary.\n  let getWords: GetWordsFunction;\n  const dbStatus = getDataSeriesStatus('words');\n  if (dbStatus === 'ok') {\n    getWords = ({ input, maxResults }: { input: string; maxResults: number }) =>\n      idbGetWords(input, { matchType: 'exact', limit: maxResults });\n  } else {\n    try {\n      const flatFileDatabase = await fallbackDatabaseLoader.database;\n      getWords = flatFileDatabase.getWords.bind(flatFileDatabase);\n      // The IDB database handles kana variations but for the flat file database\n      // we need to do it ourselves.\n      word = kanaToHiragana(word);\n    } catch {\n      return [null, dbStatus];\n    }\n  }\n\n  return [\n    await wordSearch({\n      abortSignal,\n      getWords,\n      input: word,\n      inputLengths,\n      maxResults,\n      includeRomaji,\n    }),\n    dbStatus !== 'ok' ? dbStatus : undefined,\n  ];\n}\n\n// ---------------------------------------------------------------------------\n//\n// Translate\n//\n// ---------------------------------------------------------------------------\n\nexport async function translate({\n  text,\n  includeRomaji = false,\n}: {\n  text: string;\n  includeRomaji?: boolean;\n}): Promise<TranslateResult | null> {\n  const result: TranslateResult = {\n    type: 'translate',\n    data: [],\n    textLen: text.length,\n    more: false,\n  };\n\n  let skip: number;\n  while (text.length > 0) {\n    const [searchResult, dbStatus] = await searchWords({\n      input: text,\n      max: 1,\n      includeRomaji,\n    });\n\n    if (searchResult && searchResult.data) {\n      if (result.data.length >= WORDS_MAX_ENTRIES) {\n        result.more = true;\n        break;\n      }\n\n      // Just take first match\n      result.data.push(searchResult.data[0]);\n      skip = searchResult.matchLen;\n    } else {\n      skip = 1;\n    }\n\n    if (searchResult && dbStatus) {\n      result.dbStatus = dbStatus;\n    }\n\n    text = text.substring(skip);\n  }\n\n  if (result.data.length === 0) {\n    return null;\n  }\n\n  result.textLen -= text.length;\n  return result;\n}\n\n// ---------------------------------------------------------------------------\n//\n// Kanji\n//\n// ---------------------------------------------------------------------------\n\nexport async function searchKanji(\n  input: string\n): Promise<KanjiSearchResult | null | 'unavailable' | 'updating'> {\n  const kanjiStatus = getDataSeriesStatus('kanji');\n  const radicalStatus = getDataSeriesStatus('radicals');\n  if (kanjiStatus === 'unavailable' || radicalStatus === 'unavailable') {\n    return 'unavailable';\n  }\n\n  if (kanjiStatus === 'updating' || radicalStatus === 'updating') {\n    return 'updating';\n  }\n\n  // Normalize the input in order to be able to parse radicals as kanji.\n  const [normalized] = normalizeInput(input);\n\n  // Do some very elementary filtering on kanji\n  //\n  // We know that the input should be mostly Japanese so we just do some very\n  // basic filtering to drop any hiragana / katakana.\n  //\n  // We _could_ do a more thoroughgoing check based on all the different Unicode\n  // ranges but they're constantly being expanded and if some obscure character\n  // ends up in the kanji database we want to show it even if it doesn't match\n  // our expectations of what characters are kanji.\n  const kanjiLastIndex = new Map<string, number>();\n  const kanji = [\n    ...new Set(\n      [...normalized].filter((c, i) => {\n        const cp = c.codePointAt(0)!;\n        const isKanji =\n          // Don't bother looking up Latin text\n          cp >= 0x3000 &&\n          // Or hiragana (yeah, 0x1b0001 is also hiragana but this is good enough)\n          !(cp >= 0x3040 && cp <= 0x309f) &&\n          // Or katakana\n          !(cp >= 0x30a0 && cp <= 0x30ff) &&\n          !(cp >= 0x31f0 && cp <= 0x31ff) &&\n          // Or half-width katakana\n          !(cp >= 0xff65 && cp <= 0xff9f);\n        if (isKanji) {\n          kanjiLastIndex.set(c, i);\n        }\n\n        return isKanji;\n      })\n    ),\n  ];\n\n  const logWarningMessage = (message: string) => {\n    // Ignore certain warnings that are not currently meaningful\n    if (message.startsWith(\"Couldn't find a radical or kanji entry for\")) {\n      return;\n    }\n\n    void Bugsnag.notify(message, { severity: 'warning' });\n  };\n\n  let result;\n  try {\n    result = await getKanji({\n      kanji,\n      lang: dbState.kanji.version?.lang ?? 'en',\n      logWarningMessage,\n    });\n  } catch (e) {\n    console.error('Error looking up kanji', e);\n    void Bugsnag.notify(e || '(Error looking up kanji)');\n    return null;\n  }\n\n  if (!result.length) {\n    return null;\n  }\n\n  // Work out what the last matched character was\n  const matchLen =\n    Math.max(...result.map((r) => kanjiLastIndex.get(r.c) || 0)) + 1;\n\n  return { type: 'kanji', data: result, matchLen };\n}\n\n// ---------------------------------------------------------------------------\n//\n// Names\n//\n// ---------------------------------------------------------------------------\n\nconst NAMES_MAX_ENTRIES = 20;\n\nexport async function searchNames({\n  abortSignal,\n  input,\n  minLength,\n}: {\n  abortSignal?: AbortSignal;\n  input: string;\n  minLength?: number;\n}): Promise<NameSearchResult | null | 'unavailable' | 'updating'> {\n  const dbStatus = getDataSeriesStatus('names');\n  if (dbStatus !== 'ok') {\n    return dbStatus;\n  }\n\n  const [normalized, inputLengths] = normalizeInput(input);\n\n  return nameSearch({\n    abortSignal,\n    input: normalized,\n    inputLengths,\n    minInputLength: minLength,\n    maxResults: NAMES_MAX_ENTRIES,\n  });\n}\n","export async function shouldRequestPersistentStorage(): Promise<boolean> {\n  // Prior to Firefox 77, Firefox would prompt the user if we request persistent\n  // storage. That could be annyoing (especially if the user denies the request)\n  // so we don't request persistent storage unless it looks like the user needs\n  // it.\n  const firefoxMajorVersion = getFirefoxMajorVersion();\n  return (\n    firefoxMajorVersion === null ||\n    firefoxMajorVersion >= 77 ||\n    (await wouldBenefitFromPersistentStorage())\n  );\n}\n\nfunction getFirefoxMajorVersion(): number | null {\n  const matches = navigator.userAgent.match(/\\sFirefox\\/([0-9.]+)/);\n  if (!matches) {\n    return null;\n  }\n\n  return Math.floor(parseFloat(matches[1]));\n}\n\nasync function wouldBenefitFromPersistentStorage(): Promise<boolean> {\n  let estimate: StorageEstimate;\n  try {\n    estimate = await navigator.storage.estimate();\n  } catch {\n    return false;\n  }\n\n  // If we couldn't get an estimate, assume attempting to persist storage will\n  // fail so just return false.\n  if (\n    typeof estimate.quota === 'undefined' ||\n    typeof estimate.usage === 'undefined'\n  ) {\n    return false;\n  }\n\n  // We could use persistent storage if we have less than 200Mb for our quota or\n  // are over 80% of our quota.\n  const quotaInMb = estimate.quota / (1024 * 1024);\n  const usageAsPercent = estimate.usage / estimate.quota;\n\n  return quotaInMb < 200 || usageAsPercent > 0.8;\n}\n","/// <reference path=\"../common/constants.d.ts\" />\n/// <reference path=\"./mail-extensions.d.ts\" />\n\n/*\n\n  10ten Japanese Reader\n  by Brian Birtles\n  https://github.com/birchill/10ten-ja-reader\n\n  ---\n\n  Originally based on Rikaikun\n  by Erek Speed\n  http://code.google.com/p/rikaikun/\n\n  ---\n\n  Originally based on Rikaichan 1.07\n  by Jonathan Zarate\n  http://www.polarcloud.com/\n\n  ---\n\n  Originally based on RikaiXUL 0.4 by Todd Rudick\n  http://www.rikai.com/\n  http://rikaixul.mozdev.org/\n\n  ---\n\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program. If not, see <https://www.gnu.org/licenses/>.\n\n  ---\n\n  Please do not change or remove any of the copyrights or links to web pages\n  when modifying any of the files. - Jon\n\n*/\nimport Bugsnag from '@birchill/bugsnag-zero';\nimport { AbortError, allDataSeries } from '@birchill/jpdict-idb';\nimport * as s from 'superstruct';\nimport browser, { Runtime, Tabs } from 'webextension-polyfill';\n\nimport '../../manifest.json.src';\n\nimport { Config } from '../common/config';\nimport {\n  DbListenerMessage,\n  notifyDbStateUpdated,\n} from '../common/db-listener-messages';\nimport { startBugsnag } from '../utils/bugsnag';\nimport { stripFields } from '../utils/strip-fields';\nimport { Split } from '../utils/type-helpers';\n\nimport TabManager from './all-tab-manager';\nimport {\n  BackgroundRequestSchema,\n  SearchOtherRequest,\n  SearchRequest,\n} from './background-request';\nimport { setDefaultToolbarIcon, updateBrowserAction } from './browser-action';\nimport { registerMenuListeners, updateContextMenus } from './context-menus';\nimport { FxFetcher } from './fx-fetcher';\nimport { isCurrentTabEnabled } from './is-current-tab-enabled';\nimport {\n  JpdictStateWithFallback,\n  cancelUpdateDb,\n  deleteDb,\n  initDb,\n  searchWords as jpdictSearchWords,\n  searchKanji,\n  searchNames,\n  translate,\n  updateDb,\n} from './jpdict';\nimport { shouldRequestPersistentStorage } from './quota-management';\nimport { SearchOtherResult, SearchWordsResult } from './search-result';\n\n//\n// Setup bugsnag\n//\n\nstartBugsnag();\n\n//\n// Setup tab manager\n//\n\nconst tabManager = new TabManager();\nconst fxFetcher = new FxFetcher();\n\ntabManager.addListener(\n  async ({\n    enabled,\n    tabId,\n    anyEnabled,\n  }: {\n    enabled: boolean;\n    tabId?: number | undefined;\n    anyEnabled: boolean;\n  }) => {\n    try {\n      await config.ready;\n    } catch (e) {\n      void Bugsnag.notify(e || '(No error)');\n      return;\n    }\n\n    // Update browser action with enabled state\n    updateBrowserAction({\n      enabled,\n      jpdictState,\n      tabId,\n      toolbarIcon: config.toolbarIcon,\n    });\n\n    // Update context menus\n    await updateContextMenus({\n      tabEnabled: enabled,\n      toggleMenuEnabled: config.contextMenuEnable,\n      showPuck: config.computedShowPuck === 'show',\n    });\n\n    // If we have enabled a tab, make sure we update our FX data.\n    //\n    // We don't do this unless a tab is enabled because some users may have the\n    // add-on installed but never enabled and we shouldn't download FX data each\n    // day in that case.\n    if (anyEnabled) {\n      await fxFetcher.scheduleNextUpdate();\n    } else {\n      await fxFetcher.cancelScheduledUpdate();\n    }\n  }\n);\n\n//\n// Setup config\n//\n\nconst config = new Config();\n\nconfig.addChangeListener(async (changes) => {\n  // Update toolbar icon as needed\n  if (changes.hasOwnProperty('toolbarIcon')) {\n    const toolbarIcon = changes.toolbarIcon.newValue as 'default' | 'sky';\n\n    // Update all the different windows separately since they may have differing\n    // enabled states.\n    const enabledStates = await tabManager.getEnabledState();\n\n    // If we are targetting individual tabs, however, first update the default\n    // icon for all tabs.\n    if (\n      !enabledStates.length ||\n      typeof enabledStates[0].tabId !== 'undefined'\n    ) {\n      setDefaultToolbarIcon(config.toolbarIcon);\n    }\n\n    for (const tabState of enabledStates) {\n      updateBrowserAction({\n        enabled: tabState.enabled,\n        jpdictState,\n        tabId: tabState.tabId,\n        toolbarIcon,\n      });\n    }\n  }\n\n  // Update context menus as needed\n  const toggleMenuEnabled: boolean | undefined =\n    changes.contextMenuEnable?.newValue;\n  let showPuck: 'show' | 'hide' | undefined;\n  if (\n    changes.hasOwnProperty('showPuck') ||\n    changes.hasOwnProperty('canHover')\n  ) {\n    showPuck = config.computedShowPuck;\n  }\n\n  if (\n    typeof toggleMenuEnabled !== 'undefined' ||\n    typeof showPuck !== 'undefined'\n  ) {\n    try {\n      const tabEnabled = await isCurrentTabEnabled(tabManager);\n      await updateContextMenus({\n        tabEnabled,\n        toggleMenuEnabled:\n          typeof toggleMenuEnabled === 'undefined'\n            ? config.contextMenuEnable\n            : toggleMenuEnabled,\n        showPuck:\n          (typeof showPuck === 'undefined'\n            ? config.computedShowPuck\n            : showPuck) === 'show',\n      });\n    } catch (e) {\n      void Bugsnag.notify(e);\n    }\n  }\n\n  // Update dictionary language\n  if (changes.hasOwnProperty('dictLang')) {\n    const newLang = (changes as any).dictLang.newValue;\n    Bugsnag.leaveBreadcrumb(`Changing language of database to ${newLang}.`);\n    updateDb({ lang: newLang, force: true });\n  }\n\n  // Tell the content scripts about any changes\n  await tabManager.updateConfig(config.contentConfig);\n});\n\nvoid config.ready.then(async () => {\n  // If we have a non-default toolbar icon, set it for all tabs now so that\n  // when we open a new tab, etc. it will be set correctly.\n  if (config.toolbarIcon !== 'default') {\n    setDefaultToolbarIcon(config.toolbarIcon);\n  }\n\n  // Initialize the tab manager first since we'll need its enabled state for\n  // a number of other things.\n  await tabManager.init(config.contentConfig);\n\n  const tabEnabled = await isCurrentTabEnabled(tabManager);\n\n  await updateContextMenus({\n    tabEnabled,\n    toggleMenuEnabled: config.contextMenuEnable,\n    showPuck: config.computedShowPuck === 'show',\n  });\n});\n\n//\n// Jpdict database\n//\n\nlet jpdictState: JpdictStateWithFallback = {\n  words: {\n    state: 'init',\n    version: null,\n    fallbackState: 'unloaded',\n  },\n  kanji: {\n    state: 'init',\n    version: null,\n  },\n  radicals: {\n    state: 'init',\n    version: null,\n  },\n  names: {\n    state: 'init',\n    version: null,\n  },\n  updateState: { type: 'idle', lastCheck: null },\n};\n\nlet dbInitialized = false;\n\nconst dbReady = (async () => {\n  if (dbInitialized) {\n    return true;\n  }\n\n  Bugsnag.leaveBreadcrumb('Initializing dictionary...');\n\n  await config.ready;\n  await initDb({ lang: config.dictLang, onUpdate: onDbStatusUpdated });\n\n  dbInitialized = true;\n\n  return true;\n})().catch((e) => {\n  console.error('Error initializing dictionary', e);\n  void Bugsnag.notify(e);\n\n  return false;\n});\n\nasync function onDbStatusUpdated(state: JpdictStateWithFallback) {\n  const dbWasUnavailable =\n    jpdictState.words.state === 'empty' ||\n    jpdictState.words.state === 'unavailable';\n  const dbWasUpdating = jpdictState.updateState.type === 'updating';\n\n  jpdictState = state;\n\n  // Update all the different windows separately since they may have differing\n  // enabled states.\n  const enabledStates = await tabManager.getEnabledState();\n  for (const tabState of enabledStates) {\n    updateBrowserAction({\n      enabled: tabState.enabled,\n      jpdictState: state,\n      tabId: tabState.tabId,\n      toolbarIcon: config.toolbarIcon,\n    });\n  }\n\n  notifyDbListeners();\n\n  const dbIsAvailable = jpdictState.words.state === 'ok';\n  const dbIsUpdating = jpdictState.updateState.type === 'updating';\n  if ((dbWasUnavailable || dbWasUpdating) && dbIsAvailable && !dbIsUpdating) {\n    await tabManager.notifyDbUpdated();\n  }\n}\n\nfunction isDbUpdating() {\n  if (!dbInitialized) {\n    return true;\n  }\n\n  for (const series of allDataSeries) {\n    if (jpdictState[series].state === 'init') {\n      return true;\n    }\n  }\n\n  return jpdictState.updateState.type !== 'idle';\n}\n\n//\n// Database listeners\n//\n\nconst dbListeners: Array<Runtime.Port> = [];\n\nfunction isDbListenerMessage(event: unknown): event is DbListenerMessage {\n  return typeof event === 'object' && typeof (event as any).type === 'string';\n}\n\nbrowser.runtime.onConnect.addListener((port: Runtime.Port) => {\n  if (port.name !== 'options') {\n    return;\n  }\n\n  dbListeners.push(port);\n\n  // Push initial state to new listener\n  notifyDbListeners(port);\n\n  port.onMessage.addListener(async (event: unknown) => {\n    if (!isDbListenerMessage(event)) {\n      return;\n    }\n\n    switch (event.type) {\n      case 'updatedb':\n        await config.ready;\n\n        Bugsnag.leaveBreadcrumb('Manually triggering database update');\n        updateDb({ lang: config.dictLang, force: true });\n        break;\n\n      case 'cancelupdatedb':\n        Bugsnag.leaveBreadcrumb('Manually canceling database update');\n        cancelUpdateDb();\n        break;\n\n      case 'deletedb':\n        Bugsnag.leaveBreadcrumb('Manually deleting database');\n        deleteDb();\n        break;\n    }\n  });\n\n  port.onDisconnect.addListener(() => {\n    const index = dbListeners.indexOf(port);\n    if (index !== -1) {\n      dbListeners.splice(index, 1);\n    }\n  });\n});\n\nfunction notifyDbListeners(specifiedListener?: Runtime.Port) {\n  if (!dbListeners.length) {\n    return;\n  }\n\n  const message = notifyDbStateUpdated(jpdictState);\n\n  for (const listener of dbListeners) {\n    if (specifiedListener && listener !== specifiedListener) {\n      continue;\n    }\n\n    try {\n      listener.postMessage(message);\n    } catch (e) {\n      console.error('Error posting message', e);\n      void Bugsnag.notify(e || '(Error posting message update message)');\n    }\n  }\n}\n\n//\n// Search\n//\n\nasync function searchWords({\n  input,\n  includeRomaji,\n  abortSignal,\n}: SearchRequest & {\n  abortSignal: AbortSignal;\n}): Promise<SearchWordsResult | null> {\n  await dbReady;\n\n  const [words, dbStatus] = await jpdictSearchWords({\n    abortSignal,\n    input,\n    includeRomaji,\n  });\n\n  return {\n    words,\n    dbStatus,\n  };\n}\n\nasync function searchOther({\n  input,\n  wordsMatchLen,\n  abortSignal,\n}: SearchOtherRequest & {\n  abortSignal: AbortSignal;\n}): Promise<SearchOtherResult | null> {\n  await dbReady;\n\n  // Names\n  const nameResult = await searchNames({ abortSignal, input });\n  const names = typeof nameResult === 'string' ? null : nameResult;\n\n  if (abortSignal.aborted) {\n    throw new AbortError();\n  }\n\n  // Kanji\n  const longestMatch = Math.max(wordsMatchLen, names?.matchLen ?? 0);\n  const kanjiResult = await searchKanji(input.slice(0, longestMatch || 1));\n  const kanji = typeof kanjiResult === 'string' ? null : kanjiResult;\n\n  if (abortSignal.aborted) {\n    throw new AbortError();\n  }\n\n  if (!kanji && !names) {\n    return null;\n  }\n\n  return { kanji, names };\n}\n\n//\n// Browser event handlers\n//\n\nasync function toggle(tab?: Tabs.Tab) {\n  await config.ready;\n  await tabManager.toggleTab(tab, config.contentConfig);\n}\n\nif (__MV3__) {\n  browser.action.onClicked.addListener(toggle);\n} else {\n  browser.browserAction.onClicked.addListener(toggle);\n}\nbrowser.composeAction?.onClicked.addListener(toggle);\n\n// We can sometimes find ourselves in a situation where we have a backlog of\n// search requests. To avoid that, we simply cancel any previous request.\nlet pendingSearchWordsRequest:\n  | { input: string; controller: AbortController }\n  | undefined;\nlet pendingSearchOtherRequest:\n  | { input: string; controller: AbortController }\n  | undefined;\n\nbrowser.runtime.onMessage.addListener(\n  (\n    request: unknown,\n    sender: Runtime.MessageSender\n  ): undefined | Promise<any> => {\n    if (!s.is(request, BackgroundRequestSchema)) {\n      // We can sometimes get requests here from other extensions?\n      //\n      // We've observed requests such as the following:\n      //\n      //   {\"type\":\"cs-frame-forget\"}\n      //   {\"action\":\"requestBackendReadySignal\"}\n      //   {\"type\":\"cs-frame-connect\",\"data\":{\"isDark\":true}}\n      //\n      // Curiously in all cases the user agent was not identified so I'm not\n      // sure if this can happen in all browsers or not.\n      console.warn(`Unrecognized request: ${JSON.stringify(request)}`);\n      return undefined;\n    }\n\n    switch (request.type) {\n      case 'options':\n        return browser.runtime.openOptionsPage();\n\n      case 'searchWords':\n        Bugsnag.leaveBreadcrumb('Searching for words', {\n          ...request,\n          input: 'x'.repeat(request.input.length),\n        });\n        if (pendingSearchWordsRequest) {\n          Bugsnag.leaveBreadcrumb('Canceling previous search');\n          pendingSearchWordsRequest.controller.abort();\n          pendingSearchWordsRequest = undefined;\n        }\n\n        // Go ahead and stop any searches of other dictionaries too since they\n        // are no longer relevant and will only make this search take longer.\n        if (pendingSearchOtherRequest) {\n          pendingSearchOtherRequest.controller.abort();\n          pendingSearchOtherRequest = undefined;\n        }\n\n        pendingSearchWordsRequest = {\n          input: request.input,\n          controller: new AbortController(),\n        };\n\n        return (async () => {\n          try {\n            return await searchWords({\n              ...request,\n              abortSignal: pendingSearchWordsRequest.controller.signal,\n            });\n          } catch (e) {\n            if (e.name === 'AbortError') {\n              return 'aborted';\n            }\n            void Bugsnag.notify(e);\n            return null;\n          } finally {\n            if (pendingSearchWordsRequest?.input === request.input) {\n              pendingSearchWordsRequest = undefined;\n            }\n          }\n        })();\n\n      case 'searchOther':\n        Bugsnag.leaveBreadcrumb('Searching for non-words', {\n          ...request,\n          input: 'x'.repeat(request.input.length),\n        });\n        if (pendingSearchOtherRequest) {\n          Bugsnag.leaveBreadcrumb('Canceling previous search');\n          pendingSearchOtherRequest.controller.abort();\n          pendingSearchOtherRequest = undefined;\n        }\n\n        pendingSearchOtherRequest = {\n          input: request.input,\n          controller: new AbortController(),\n        };\n\n        return (async () => {\n          try {\n            return await searchOther({\n              ...request,\n              abortSignal: pendingSearchOtherRequest.controller.signal,\n            });\n          } catch (e) {\n            if (e.name === 'AbortError') {\n              return 'aborted';\n            }\n            void Bugsnag.notify(e);\n            return null;\n          } finally {\n            if (pendingSearchOtherRequest?.input === request.input) {\n              pendingSearchOtherRequest = undefined;\n            }\n          }\n        })();\n\n      case 'translate':\n        Bugsnag.leaveBreadcrumb('Translating string', {\n          ...request,\n          input: 'x'.repeat(request.input.length),\n        });\n        return dbReady\n          .then(() =>\n            translate({\n              text: request.input,\n              includeRomaji: request.includeRomaji,\n            })\n          )\n          .catch((e) => {\n            if (e.name === 'AbortError') {\n              return 'aborted';\n            }\n            void Bugsnag.notify(e);\n            return null;\n          });\n\n      case 'toggleDefinition':\n        Bugsnag.leaveBreadcrumb('Toggling definitions on/off');\n        void config.ready.then(() => {\n          config.toggleReadingOnly();\n        });\n        break;\n\n      case 'disableMouseInteraction':\n        Bugsnag.leaveBreadcrumb('Disabling mouse interaction');\n        void config.ready.then(() => {\n          config.popupInteractive = false;\n        });\n        break;\n\n      case 'canHoverChanged':\n        Bugsnag.leaveBreadcrumb('Changing hover ability setting', request);\n        void config.ready.then(() => {\n          config.canHover = request.value;\n        });\n        break;\n\n      case 'puckStateChanged':\n        void config.ready.then(() => {\n          config.puckState = request.value;\n        });\n        break;\n\n      case 'isDbUpdating':\n        return Promise.resolve(isDbUpdating());\n\n      //\n      // Forwarded messages\n      //\n\n      case 'frame:popupShown':\n      case 'frame:highlightText':\n      case 'frame:clearTextHighlight':\n        {\n          const [, type] = request.type.split(':') as Split<\n            typeof request.type,\n            ':'\n          >;\n          if (sender.tab?.id) {\n            tabManager.sendMessageToFrame({\n              tabId: sender.tab.id,\n              message: { ...stripFields(request, ['frameId']), type },\n              frameId: request.frameId,\n            });\n          }\n        }\n        break;\n\n      case 'children:popupHidden':\n      case 'children:popupShown':\n        {\n          if (!sender.tab?.id) {\n            break;\n          }\n\n          const [, type] = request.type.split(':') as Split<\n            typeof request.type,\n            ':'\n          >;\n          const message = { ...request, type, frame: 'children' };\n          browser.tabs.sendMessage(sender.tab.id, message).catch(() => {\n            // Ignore, possibly a tab that has gone away.\n          });\n        }\n        break;\n\n      case 'top:lookup':\n        {\n          if (!sender.tab?.id || typeof sender.frameId !== 'number') {\n            break;\n          }\n\n          const initialSrc = tabManager.getInitialFrameSrc({\n            tabId: sender.tab.id,\n            frameId: sender.frameId,\n          });\n\n          tabManager.sendMessageToTopFrame({\n            tabId: sender.tab.id,\n            message: {\n              ...request,\n              type: 'lookup',\n              source: {\n                frameId: sender.frameId,\n                initialSrc,\n                currentSrc: request.source.src,\n                dimensions: request.source.dimensions,\n              },\n            },\n          });\n        }\n        break;\n\n      case 'top:isPopupShowing':\n      case 'top:pinPopup':\n      case 'top:unpinPopup':\n      case 'top:commitPopup':\n      case 'top:clearResult':\n      case 'top:nextDictionary':\n      case 'top:toggleDefinition':\n      case 'top:expandPopup':\n      case 'top:movePopup':\n      case 'top:enterCopyMode':\n      case 'top:exitCopyMode':\n      case 'top:nextCopyEntry':\n      case 'top:copyCurrentEntry':\n        {\n          if (!sender.tab?.id) {\n            break;\n          }\n\n          const [, type] = request.type.split(':') as Split<\n            typeof request.type,\n            ':'\n          >;\n          tabManager.sendMessageToTopFrame({\n            tabId: sender.tab.id,\n            message: { ...request, type },\n          });\n        }\n        break;\n    }\n\n    return undefined;\n  }\n);\n\nbrowser.runtime.onInstalled.addListener(async (details) => {\n  // Request persistent storage permission\n  if (navigator.storage) {\n    let persisted = await navigator.storage.persisted();\n    if (\n      !persisted &&\n      // navigator.storage.persist is not available in ServiceWorker contexts\n      'persist' in navigator.storage &&\n      (await shouldRequestPersistentStorage())\n    ) {\n      persisted = await navigator.storage.persist();\n      if (persisted) {\n        Bugsnag.leaveBreadcrumb('Got persistent storage permission');\n      } else {\n        Bugsnag.leaveBreadcrumb('Failed to get persistent storage permission');\n      }\n    }\n  }\n\n  if (\n    details.reason === 'update' &&\n    details.previousVersion &&\n    !details.temporary\n  ) {\n    Bugsnag.leaveBreadcrumb(\n      `Updated from version ${details.previousVersion} to ${\n        browser.runtime.getManifest().version\n      }`\n    );\n  }\n});\n\nbrowser.runtime.onPerformanceWarning?.addListener(async (details) => {\n  // We'd really like to know which site this is happening on so we can debug\n  // and try to fix it.\n  //\n  // It's hard to be sure what is an acceptable amount of information to send,\n  // however.\n  //\n  // We'd like to report the full URL but even after stripping query strings,\n  // there's still the possibility of leaking private information such as with\n  // capability URLs.\n  //\n  // The hostname is probably safe but ideally we'd add an opt-out before\n  // sending that.\n  //\n  // Example code for fetching the hostname:\n  //\n  // let host: string | undefined;\n  // if (typeof details.tabId === 'number' && details.tabId) {\n  //   try {\n  //     const rawUrl = (await browser.tabs.get(details.tabId)).url;\n  //     if (rawUrl) {\n  //       const urlObj = new URL(rawUrl);\n  //       host = urlObj.hostname;\n  //     }\n  //   } catch {\n  //     /* Ignore */\n  //   }\n  // }\n  //\n  // For now we'll just see if we get these reports at all and decide if we need\n  // more information to fix them.\n  void Bugsnag.notify(\n    { name: 'PerformanceWarning', message: details.description },\n    {\n      metadata: { 'Performance warning': details },\n    }\n  );\n});\n\nregisterMenuListeners({\n  onToggleMenu: toggle,\n  onTogglePuck: (enabled: boolean) => {\n    config.showPuck = enabled ? 'show' : 'hide';\n  },\n});\n\n// Mail extension steps\n\nvoid (async () => {\n  if (browser.messageDisplayScripts || browser.composeScripts) {\n    try {\n      await browser.messageDisplayScripts?.register({\n        js: [{ file: '/10ten-ja-content.js' }],\n      });\n      await browser.composeScripts?.register({\n        js: [{ file: '/10ten-ja-content.js' }],\n      });\n    } catch (e) {\n      console.error('Failed to register message display or compose scripts', e);\n      void Bugsnag.notify(e);\n    }\n  }\n})();\n"],"names":["jsonEqualish","actual","expected","Object","is","objEquiv","a","b","Date","getTime","Array","isArray","constructor","Error","aKeys","definedKeys","bKeys","length","sort","i","key","keys","filter","globalThis","chrome","runtime","id","browser","CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE","wrapAPIs","extensionAPIs","apiMetadata","DefaultWeakMap","WeakMap","createItem","items","undefined","super","this","get","has","set","isThenable","value","then","makeCallback","promise","metadata","callbackArgs","lastError","reject","message","singleCallbackArg","resolve","pluralizeArguments","numArgs","wrapAsyncFunction","name","target","args","minArgs","maxArgs","Promise","fallbackToNoCallback","cbError","console","warn","noCallback","wrapMethod","method","wrapper","Proxy","apply","targetMethod","thisObj","call","hasOwnProperty","Function","bind","prototype","wrapObject","wrappers","cache","create","handlers","proxyTarget","prop","receiver","defineProperty","configurable","enumerable","desc","Reflect","deleteProperty","wrapEvent","wrapperMap","addListener","listener","hasListener","removeListener","onRequestFinishedWrappers","req","wrappedReq","getContent","onMessageWrappers","sender","sendResponse","didCallSendResponse","wrappedSendResponse","sendResponsePromise","response","result","err","isResultThenable","sendPromisedResult","msg","error","__mozWebExtensionPolyfillReject__","catch","wrappedSendMessageCallback","reply","wrappedSendMessage","apiNamespaceObj","wrappedCb","push","sendMessage","staticWrappers","devtools","network","onRequestFinished","onMessage","onMessageExternal","tabs","settingMetadata","clear","privacy","services","websites","module","exports","FetchDelivery","client","sendEvent","sentAt","toISOString","body","JSON","stringify","apiKey","payloadVersion","notifier","events","fetch","endpoints","notify","mode","credentials","headers","referrerPolicy","CircularReference","Symbol","AccessError","safeFilter","input","replacer","options","seen","depth","depthLimit","edgeIndex","edgesLimit","Infinity","replacement","includes","hasToJson","safeAccess","toJSON","String","copy","limit","Math","min","item","currentKey","pop","accessor","objectToString","toString","getPrototypeOf","ERROR_TYPE","isError","isObject","CHROME_IE_STACK_REGEXP","SAFARI_NATIVE_CODE_REGEXP","parseStack","stackString","partialResult","match","parseV8OrIE","parseFFOrSafari","reduce","stack","file","lineNumber","replace","test","concat","columnNumber","filtered","split","line","map","indexOf","sanitizedLine","location","tokens","slice","locationParts","extractLocation","join","functionNameRegex","matches","urlLike","regExp","parts","exec","parseInt","col","toExceptions","maybeError","component","normalizeError","exceptions","makeException","getCauses","cause","backtrace","fromSimpleError","getStringMember","field","newError","stackOptions","errorClass","stacktrace","getStacktrace","type","self","navigator","getStackString","generateBacktrace","MAX_STACK_SIZE","curr","arguments","callee","_e","RegExp","$1","caller","e","browserNotifyUnhandledExceptions","load","addEventListener","evt","ErrorEvent","filename","Number","isSafeInteger","lineno","log","colno","firstStackFrame","notifyEvent","unhandled","severity","severityReason","browserNotifyUnhandledRejections","reason","consoleBreadcrumbs","methodsToHook","original","leaveBreadcrumb","arg","stringified","errorBreadcrumbs","addOnPostError","event","errorMessage","fetchBreadcrumbs","oldFetch","init","url","isRequest","handleFetchSuccess","handleFetchError","Request","startsWith","status","request","interactionBreadcrumbs","targetText","targetSelector","isHtmlElement","getNodeText","isElement","getNodeSelector","nodeType","Node","ELEMENT_NODE","namespaceURI","elem","text","textContent","innerText","truncate","trim","tagName","className","document","querySelectorAll","parentNode","childNodes","index","from","children","parentElement","ommision","navigationBreadcrumbs","drop","oldURL","relativeLocation","to","newURL","state","getCurrentState","href","history","Window","replaceState","wrapHistoryFn","fn","win","pushState","urlObj","URL","pathname","search","hash","orig","title","stateChangeToMetadata","currentPath","prevState","appStart","now","appDuration","addOnError","app","duration","reset","parseUserAgent","userAgent","matchedRule","matchUserAgent","os","detectOS","device","osName","detectAppleDevice","browserName","browserVersion","osVersion","manufacturer","model","userAgentRules","matched","regex","uaMatch","operatingSystemRules","maxTouchPoints","browserContextWithUaParser","uaParser","context","locale","language","languages","metaData","browserContext","deviceOrientation","orientation","screen","documentElement","clientWidth","clientHeight","limitEvents","n","window","_key","Map","entries","Set","values","truncateString","getOwnPropertyNames","ArrayBuffer","byteLength","maxLength","substring","breadcrumbs","breadcrumb","browserHandledRejectionBreadcrumbs","BugsnagStatic","config","delivery","errorCallbacks","postErrorCallbacks","plugins","start","onError","plugin","timestamp","maxBreadcrumbs","splice","originalError","releaseStage","enabledReleaseStages","user","version","appVersion","appType","time","sortLast","callback","callbackResult","eventForDelivery","payload","getUser","setUser","email","add","removeOnError","delete","removeOnPostError","getPlugin","find","setDelivery","Bugsnag","StructError","TypeError","failure","failures","cached","rest","path","explanation","assign","isIterable","x","iterator","isNonArrayObject","print","shiftIterator","next","done","toFailure","struct","refinement","branch","toFailures","r","ctx","mask","coerce","coercer","validator","k","v","s","ts","t","refiner","Struct","props","schema","assert","validate","tuples","tuple","Structs","isType","schemas","Element","enums","description","integer","isNaN","isInteger","literal","constant","never","knowns","Never","unknowns","coerced","optional","record","Key","Value","string","union","S","first","getSize","size","threshold","refine","exclusive","nonempty","instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","getIdbProxyableTypes","IDBDatabase","IDBObjectStore","IDBIndex","IDBCursor","IDBTransaction","getCursorAdvanceMethods","advance","continue","continuePrimaryKey","transactionDoneMap","transformCache","reverseTransformCache","promisifyRequest","unlisten","removeEventListener","success","wrap","cacheDonePromiseForTransaction","tx","complete","DOMException","idbProxyTraps","objectStoreNames","objectStore","replaceTraps","wrapFunction","func","unwrap","transformCachableValue","IDBRequest","newValue","openDB","indexedDB","open","openPromise","upgrade","oldVersion","newVersion","transaction","blocked","db","terminated","blocking","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","async","storeName","store","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","isIteratorProp","asyncIterator","expandChoon","vowel","repeat","initialResult","matchO","matchKatakanaO","expandO","base","expandedWithU","expandedWithO","kanaToHiragana","char","codePointAt","fromCodePoint","kyuujitaiToShinjitai","inputCodePoints","outputCodePoints","KYUU_TO_SHIN","halfToFullWidthNum","HANKAKU_KATAKANA_TO_ZENKAKU","VOICED_TO_COMPOSED","SEMIVOICED_TO_COMPOSED","COMBINED_CHARS_A","COMBINED_CHARS_B","ENCLOSED_CHARS_A","ENCLOSED_CHARS_B","ENCLOSED_CHARS_C","ENCLOSED_CHARS_D","RADICAL_TO_KANJI_CHARS","RADICAL_TO_KANJI","toNormalized","inputLengths","charCodeAt","prevChar","composed","expanded","radical","fill","fromCharCode","AbortError","params","setPrototypeOf","captureStackTrace","allDataSeries","allMajorDataSeries","DownloadError","code","isAbortError","isDownloadError","getErrorMessage","fetchWithTimeout","resource","controller","AbortController","onAbort","abort","signal","didTimeout","timeoutId","timeout","setTimeout","clearTimeout","safeInteger","getVersionInfo","versionInfoFile","getVersionInfoFile","baseUrl","lang","dbVersionInfo","getCurrentVersionInfo","series","majorVersion","clearCachedVersionInfo","cachedVersionInfo","CACHE_TIMEOUT","accessTime","rawVersionInfoFile","ok","json","aborted","parseVersionInfoFile","VersionInfoStruct","major","minor","patch","databaseVersion","dateOfCreation","VersionInfoFileStruct","ljsonStreamIterator","reader","stream","getReader","lineEnd","decoder","TextDecoder","buffer","parseLine","parse","releaseLock","readResult","waitWithTimeout","read","decode","lines","timeoutPromise","_","race","val","stripFields","o","fields","compareVersions","BASE_URL","DOWNLOAD_TIMEOUT","hasLanguage","download","versionInfo","getDownloadList","currentVersion","latestVersion","files","getEvents","format","partInfo","versionToString","downloadType","nextPart","part","nextPatch","HeaderLineStruct","records","PatchLineStruct","dottedVersion","commonUrlStart","headerRead","fileStartEvent","totalRecords","QuotaExceededError","hasHiragana","str","toWordStoreRecord","rm","km","h","keysToHiragana","kc","gt_en","gt_l","getStoreIdForWordRecord","toNameStoreRecord","entry","getStoreIdForNameRecord","toKanjiStoreRecord","getStoreIdForKanjiRecord","toRadicalStoreRecord","getStoreIdForRadicalRecord","getVersionKey","JpdictStore","toStoreRecord","words","names","kanji","radicals","getStoreId","deletePromise","_newVersion","kanjiTable","createObjectStore","keyPath","createIndex","multiEntry","radicalsTable","namesTable","wordsTable","close","destroy","clearSeries","targetTable","versionTable","getDataVersion","versionDoc","updateDataVersion","put","updateSeries","durability","table","update","updates","isVeryGenericError","atOrNearQuota","info","_getKanji","estimate","storage","usage","quota","reducer","action","lastCheck","checkDate","fileProgress","totalProgress","KanjiMetaSchema","p","bv","bg","AccentSchema","pos","ReadingMetaSchema","CrossReferenceSchema","sense","LangSourceSchema","src","wasei","WordSenseSchema","g","gt","kapp","rapp","misc","dial","inf","xref","ant","lsrc","WordIdSchema","WordDownloadRecordSchema","validateWordDownloadRecord","WordDownloadDeleteRecordSchema","validateWordDownloadDeleteRecord","NameTranslationSchema","det","cf","NameIdSchema","NameDownloadRecordSchema","tr","validateNameDownloadRecord","NameDownloadDeleteRecordSchema","validateNameDownloadDeleteRecord","ReadingsStruct","on","kun","na","py","RadicalStruct","nelson","var","MiscSchema","gr","sc","freq","jlpt","jlptn","kk","wk","meta","KanjiIdSchema","KanjiDownloadRecordSchema","m","m_lang","rad","refs","st","comp","validateKanjiDownloadRecord","KanjiDownloadDeleteRecordSchema","validateKanjiDownloadDeleteRecord","RadicalIdSchema","RadicalDownloadRecordSchema","pua","posn","validateRadicalDownloadRecord","RadicalDownloadDeleteRecordSchema","validateRadicalDownloadDeleteRecord","validateDownloadRecordMapping","validateDownloadRecord","validateDownloadDeleteRecordMapping","validateDownloadDeleteRecord","BATCH_SIZE","MAX_PROGRESS_RESOLUTION","doUpdate","currentFile","currentFileVersion","totalFiles","currentRecord","lastReportedTotalProgress","versionToWrite","parseRecordEvent","unvalidatedRecord","MAJOR_VERSION","JpdictIdb","updateState","verbose","changeListeners","inProgressUpdates","readyPromise","dataVersion","notifyChanged","ready","hasData","hasInProgressUpdate","deleteSeries","cancelUpdate","addChangeListener","removeChangeListener","topic","existingUpdate","updatePromise","finally","requestedLang","wroteSomething","currentLang","inProgressUpdate","isVerbose","OfflineError","GlossTypes","GLOSS_TYPE_MAX","BITS_PER_GLOSS_TYPE","floor","log2","toWordResult","matchMode","kanjiMatches","kanjiMatchRanges","kanaMatches","kanaMatchRanges","senseMatches","getMatchMetadataForCrossRefLookup","getMatchMetadata","makeWordResult","matchedGlossRanges","mergeMeta","matchRange","ent","wkLevel","bvLevel","bgLevel","l","expandSenses","matcher","arrayToBitfield","searchOnlyHeadwordMatch","kanaMatchesForKanji","kanjiMatchesForKana","xRefK","xRefR","kanaIsMatch","extendWithNulls","arr","len","extra","max","wildCardMatch","matchingKanjiAtIndex","metaArray","matchRanges","merge","senses","getRangesForSense","senseIndex","gloss","end","expandGlosses","matchedRanges","typeMask","glossTypeAtIndex","range","sortWordResults","results","sortMeta","matchingHeadword","excessChars","searchLength","kanaReading","rt","getKanaHeadwordType","priority","getPriority","metaA","metaB","isReadingObscure","every","_a","_b","_c","mostMatchedEnSensesAreUk","matchedEnSenses","ukEnSenseCount","scores","isHeadwordSearch","getPrioritySum","priorities","getPriorityScore","reverse","total","score","pow","PRIORITY_ASSIGNMENTS","wordfreq","_state","_db","_openPromise","_oldVersion","matchType","lookup","normalize","addedRecords","maybeAddRecord","term","kanaMatching","kanjiIndex","IDBKeyRange","only","bound","readingIndex","hiraganaIndex","hiragana","hiraganaKey","sortedResult","getKanji","ids","kanjiRecords","getKanjiById","radicalResults","getRadicalForKanji","logWarningMessage","componentResults","getComponentsForKanji","relatedResults","getRelatedKanji","getRadicals","variantId","getRadicalVariantId","baseId","formatRadicalId","radicalVariant","baseRadical","padStart","parseVariants","variants","popVariantForRadical","variantIndex","findIndex","variant","katakanaToRoman","components","radicalMap","getCharToRadicalMapping","kanjiToLookup","kanjiMap","radicalRecord","variantRadical","kanjiRecord","reading","asRoman","relatedKanji","cfChar","getAll","mapping","getNames","toUpdateErrorState","nextRetry","retryCount","requestIdleCallback","cancelIdleCallback","timeRemaining","handle","uuid","crypto","getRandomValues","Uint8Array","dbToUuid","getUpdateKey","obj","updateWithRetry","startUpdate","onUpdateComplete","onUpdateError","updateNow","runUpdate","onLine","onlineCallback","once","goOffline","beginUpdating","resetUpdate","suppressError","isNetworkError","scheduleResult","maybeScheduleRetry","maybeScheduleIdleRetry","onDatabaseChange","seriesHasProgress","downloadedSomething","clearRetryInterval","cancelUpdateWithRetry","updateKey","retryState","setTimeoutHandle","requestIdleCallbackHandle","changeCallback","getOrRegisterChangeCallback","getRetryCount","retryIntervalMs","getRetryIntervalMs","random","FxLocalDataSchema","rates","updated","getLocalFxData","onUpdate","getStorageChangeCallback","fxData","fx","validated","onChange","changes","areaName","isFirefox","isFenix","isChromium","isSafari","dbLanguages","ExtensionStorageError","PopupKeys","enabledKeys","l10nKey","SUPPORTED_REFERENCES","getReferencesForLang","ref","REFERENCE_ABBREV_MAPPING","CO","H","L","E","KK","DK","N","NR","V","P","IN","I","U","Y","WK","convertLegacyReference","OFF_BY_DEFAULT_REFERENCES","Config","readSettings","settings","localSettings","notifyDbStateUpdated","installType","getReleaseStage","getExtensionInstallId","internalUuid","host","storedInstallId","installid","installId","getRandomId","number","getRandomNumber","MAX_SAFE_INTEGER","round","extend","discriminatorSchema","discriminator","getStructForValue","branchStruct","PopupStateSchema","frameId","y","width","height","direction","side","allowOverlap","lookupPoint","marginX","marginY","contentType","display","static","ghost","keyType","hover","pinned","touch","SearchRequestSchema","includeRomaji","SearchOtherRequestSchema","wordsMatchLen","BackgroundRequestSchema","canHoverChanged","disabled","disableMouseInteraction","enabled","isDbUpdating","puckStateChanged","active","searchWords","searchOther","toggleDefinition","translate","source","dimensions","copyType","AllTabManager","initPromise","doInit","getStoredEnabledState","notifyListeners","enableActiveTabs","tabId","enableTab","tab","updateFrames","dropFrame","initComplete","getEnabledResult","tryToEnable","getEnabledState","toggleTab","_tab","sendMessageToAllTabs","frame","updateConfig","notifyDbUpdated","sendMessageToFrame","sendMessageToTopFrame","getTopFrameId","localizedDataSeriesKey","throttle","lastInvocationTimeout","lastRan","run","__MV3__","throttledSetTitle","setTitle","currentUpdate","updateBrowserAction","TOGGLE_MENU_ID","ENABLE_PUCK_MENU_ID","contextMenus","registerMenuListeners","onClicked","menuItemId","onToggleMenu","onTogglePuck","checked","updateContextMenus","toggleMenuEnabled","addToggleMenu","tabEnabled","removeMenuItem","addEnablePuckMenu","showPuck","contexts","__SUPPORTS_TAB_CONTEXT_TYPE__","createMenuItem","createProperties","remove","TimeoutError","FxDataSchema","isCurrentTabEnabled","tabManager","enabledStates","currentWindowTabs","currentWindow","activeTab","normalizeInput","fullWidthInput","normalized","stripZwnj","serializeError","queryState","updateDb","force","cancelUpdateDb","deleteDb","notifyDbUpdateComplete","notifyError","JpdictWorkerBackend","worker","postMessage","listeners","listenersCopy","Worker","onmessageerror","onmessage","data","FlatFileDatabase","loadData","wordDict","readFileWithAutoRetry","wordIndex","willRetry","attempts","makeBreadcrumb","prefix","urlStart","bugsnag","TIMEOUT_MS","requestOptions","responseText","intervalToWait","getWords","loaded","offsets","lookupCache","lookupResult","findLineStartingWith","offset","toDictionaryWordResult","matchingText","maxResults","LRUMap","tlen","midpoint","JpdictLocalBackend","updateAllSeries","forceUpdate","dbIsInitialized","doDbStateNotification","initDb","requestIdleCallbackPromise","wasForcedUpdate","hasBuggyObjectStoreClear","langChanged","diffInMs","lastUpdateError","runNextUpdate","getLatestCheckTime","updateError","latestCheckAsNumber","firefoxOrThunderbird","halfWidthNumbers","fullWidthAlphanumerics","zeroWidthNonJoiner","whiteCircle","nonDelimitingIdeographicPunctuation","katakana","enclosedChars","shorthandChars","tenChars","eraChars","kabushikiGaisha","rareKanji","halfwidthKatakanaChar","hentaigana","getCombinedCharRange","ranges","flags","isCharacterClassRange","re","endsWith","japaneseChar","getNegatedCharRange","negated","yoonStart","smallY","endsInYoon","nameSearch","more","matchLen","existingItems","have","currentString","abortSignal","currentInputLength","minInputLength","isOnlyDigits","variations","toNew","nameContents","getNameEntryHash","existingIndex","existingEntry","lengthToShorten","substr","replacements","maxReplacementLength","replacementMap","toRomaji","kana","explosiveness","explode","firstCharCode","substringLength","initial","wordSearch","longestMatch","includeVariants","showInflections","wordResults","lookupCandidates","existingEntries","word","candidates","deinflect","candidateIndex","candidate","lookupCandidate","originalInput","isDeinflection","entryMatchesType","reasonChains","reasonList","deinflectL10NKeys","wordResult","romaji","hasMatchingSense","WordType","UPDATE_THRESHOLD_MS","backend","dbState","fallbackState","getDataSeriesStatus","fallbackDatabaseLoader","FlatFileDatabaseLoader","process","lastUpdateTime","resolveInitPromise","getLastUpdateTime","setLastUpdateTime","resetIfNotLoaded","fallbackDatabaseState","getResult","lastDbUpdateTime","WORDS_MAX_ENTRIES","dbStatus","idbGetWords","flatFileDatabase","database","textLen","skip","searchResult","searchKanji","kanjiStatus","radicalStatus","kanjiLastIndex","cp","isKanji","NAMES_MAX_ENTRIES","searchNames","minLength","shouldRequestPersistentStorage","firefoxMajorVersion","getFirefoxMajorVersion","wouldBenefitFromPersistentStorage","parseFloat","quotaInMb","usageAsPercent","startBugsnag","TabManager","fxFetcher","FxFetcher","anyEnabled","jpdictState","toolbarIcon","contextMenuEnable","computedShowPuck","scheduleNextUpdate","cancelScheduledUpdate","setDefaultToolbarIcon","tabState"],"mappings":"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EsF,YAAY;MAEhB,MAAMI,mBAAkC;MAExC,WAAW1F,KAAKyF,iBACdC,iBAAiBve,KAAKwe,aAAa3F,MAAMA;MAG3C,OAAOxV,OAAO+a,iBAAiBG;AACjC;IAEA,IAAMC,eAAwC;MAC5C,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP,OAAO;MACP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;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,MAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;;IAET,EAAC,OAAQ;IAGX,IAAIC;IAgBG,SAASC,aAAa9c;MAK3B,KAAK6c,kBACHA,mBAAmB,IAAInO,IAAIkO;MAG7B,IAAIG,eAAe,EAAC;MACpB,IAAIngB,SAAS;MAEb,SAAS5F,IAAI,GAAGA,IAAIgJ,MAAMlJ,UAAUE,GAAG;QACrC,IAAIsf,IAAItW,MAAMgd,WAAWhmB;QAGzB,IAAKsf,KAAK,SAAUA,KAAK,SAAYA,KAAK,UAAWA,KAAK,QAAU;UAClEyG,aAAangB,OAAO9F,UAAUE,IAAI;UAClC;AACF;QAGA,IAAIsf,KAAK,SAAUA,KAAK,OACtBA,IAAI6F,4BAA4B7F,IAAI;QAKtC,MAAM2G,WAAWrgB,OAAO9F,SAAS8F,OAAOogB,WAAWpgB,OAAO9F,SAAS,KAAK;QACxE,IAAIwf,MAAM,OAAQ;UAChB,MAAM4G,WAAWd,mBAAmBhkB,IAAI6kB;UACxC,IAAIC,UAAU;YACZtgB,SAASA,OAAOyG,MAAM,IAAI;YAC1BiT,IAAI4G;AACN;AACF,eAAO,IAAI5G,MAAM,OAAQ;UAEvB,MAAM4G,WAAWb,uBAAuBjkB,IAAI6kB;UAC5C,IAAIC,UAAU;YACZtgB,SAASA,OAAOyG,MAAM,IAAI;YAC1BiT,IAAI4G;AACN;AACF;QAGA,IAAIC;QACJ,IAAI7G,KAAK,SAAUA,KAAK,OACtB6G,WAAWb,iBAAiBhG,IAAI,aAC3B,IAAIA,KAAK,SAAUA,KAAK,OAC7B6G,WAAWZ,iBAAiBjG,IAAI,aAC3B,IAAIA,KAAK,SAAUA,KAAK,OAC7B6G,WAAWX,iBAAiBlG,IAAI,aAC3B,IAAIA,KAAK,SAAUA,KAAK,OAC7B6G,WAAWV,iBAAiBnG,IAAI,aAC3B,IAAIA,KAAK,SAAUA,KAAK,OAC7B6G,WAAWT,iBAAiBpG,IAAI,aAC3B,IAAIA,KAAK,SAAUA,KAAK,OAC7B6G,WAAWR,iBAAiBrG,IAAI;QAIlC,MAAM8G,WAAWD,WAAWN,iBAAiBzkB,IAAIke,UAAK;QACtD,IAAI8G,SACFD,WAAWrc,OAAO+a,cAAcuB;QAGlC,IAAID,UAAU;UACZvgB,UAAUugB;UACVJ,aAAatf,QAAQlH,MAAM4mB,SAASrmB,SAAS,GAAGumB,KAAKrmB;AACvD,eACE4F,UAAUkE,OAAOwc,aAAahH;QAEhCyG,aAAangB,OAAO9F,UAAUE,IAAI;AACpC;MAEA,OAAO,EAAC4F,QAAQmgB;AAClB;;;;ICzxBO,IAAMQ,aAAN,MAAM,oBAAmB7mB;MAC9B,WAAAD,IAAe+mB;QACbtlB,SAASslB;QACTxnB,OAAOynB,eAAetlB,MAAM,YAAWyC;QAEvC,WAAYlE,MAAcgnB,sBAAsB,YAC7ChnB,MAAcgnB,kBAAkBvlB,MAAM;QAGzCA,KAAKmB,OAAO;AACd;;;QCRK,IAAMqkB,gBAA2C,EACtD,SACA,SACA,YACA;IAcK,IAAMC,qBAAqD,EAChE,SACA,SACA;;;;ICHK,IAAMC,gBAAN,MAAM,uBAAsBnnB;MAIjC,WAAAD,EAAY,MAAM,SAAkC+mB;QAClDtlB,SAASslB;QACTxnB,OAAOynB,eAAetlB,MAAM,eAAcyC;QAE1C,WAAYlE,MAAcgnB,sBAAsB,YAC7ChnB,MAAcgnB,kBAAkBvlB,MAAM;QAGzCA,KAAKmB,OAAO;QACZnB,KAAK2lB,OAAOA;QACZ3lB,KAAK4P,MAAMA;AACb;;;;QCnCK,SAAS,yBAAS5R;MACvB,cAAcA,MAAM,YAAYA,MAAM,SAASI,MAAMC,QAAQL;AAC/D;;QCEO,SAAS4nB,aAAahY;MAC3B,OAAO,yBAASA,MAAM,UAAUA,KAAKA,EAAEzM,SAAS;AAClD;IAEO,SAAS0kB,gBAAgBjY;MAC9B,OAAO,yBAASA,MAAM,UAAUA,KAAKA,EAAEzM,SAAS;AAClD;IAEO,SAAS2kB,gBAAgBlY;MAC9B,OAAO,yBAASA,aAAaA,EAAE/M,YAAY,WAAW+M,EAAE/M,UAAU8H,OAAOiF;AAC3E;;QCLA,eAAsBmY,iBACpBC,UACAje;MAXF;MAgBE,MAAMke,aAAa,IAAIC;MACvB,MAAMC,UAAU,MAAMF,WAAWG;OACjC,KAAAre,WAAA,gBAAAA,QAASse,WAAT,mBAAiBtY,iBAAiB,SAASoY;MAG3C,OAAM,WAAcpe;MACpB,IAAIue,aAAa;MACjB,IAAIC;MACJ,IAAIC,WAAWA,YAAYne,OACzBke,YAAYE,YAAW;QACrBH,aAAa;QACbL,WAAWG;AAAO,UACjBI;MAGL;QACE,MAAMhiB,iBAAiB0C,MAAM8e,UAAU;aAClCje;UACHse,QAAQJ,WAAWI;;QAGrB,IAAIE,WACFG,aAAaH;QAGf,OAAO/hB;AACT,QAAE,OAAOoJ;QAEP,IAAI0Y,cAAcV,aAAahY,IAC7B,MAAM,IAAI8X,cACR;UACEC,MAAM;UACN/V,YAAYoW,aAAa,WAAWA,WAAWA,SAASpW;WAE1D,4BAA4B4W,UAAW;QAI3C,MAAM5Y;AACR,QAAE;SACA,KAAA7F,WAAA,gBAAAA,QAASse,WAAT,mBAAiBhH,oBAAoB,SAAS8G;AAChD;AACF;;QCxDO,IAAMQ,cAAc,MACvB/I,OAASrB,WAAW,gBAAgBlc,SAAU8N,OAAOC,cAAc/N;;;ICWvE,eAAsBumB,gBAAe,SAC5B,QACD,MACF,cACQ,SACL;MAUP,MAAMC,wBAAwBC,mBAAmB;QAC/CC;QACAC;QACAR;QACAH;;MAIF,MAAMY,gBAAgBC,sBACpBL,iBACAM,QACAC;MAEF,KAAKH,eACH,MAAM,IAAIvB,cACR;QAAEC,MAAM;SACR,iDAAiDwB,+CAA+CH;MAIpG,OAAOC;AACT;IAEO,SAASI;MACdC,yBAAoB;AACtB;IAEA,IAAMC,gBAAgB,MAAQ;IAE9B,IAAID;IAIJ3F,eAAemF,oBAAmB,SACzB,MACH,SACG;MAQP,KACEQ,qBAAA,gBAAAA,kBAAmBN,UAASA,QAC5BM,kBAAkBE,aAAatpB,KAAKyV,QAAQ4T,eAE5C,OAAOD,kBAAkBT;MAE3BS,yBAAoB;MACpB,MAAME,aAAatpB,KAAKyV;MAExB,IAAI8T;MAEJ,MAAM7X,MAAM,GAAGmX,gCAAgCC;MAE/C,IAAIxiB;MACJ;QACEA,iBAAiBuhB,iBAAiBnW,KAAK;UAAEyW;UAAQG;;AACnD,QAAE,OAAO5Y;QACP,IAAIgY,aAAahY,MAAMiY,gBAAgBjY,IACrC,MAAMA;QAGR,MAAM,IAAI8X,cACR;UAAEC,MAAM;UAA4B/V;WACpC,gBAAgBA,uBAAuBkW,gBAAgBlY;AAE3D;MAGA,KAAKpJ,SAASkjB,IAAI;QAChB,MAAM/B,OACJnhB,SAAS0L,WAAW,MAChB,wBACA;QACN,MAAM,IAAIwV,cACR;UAAEC;UAAM/V;WACR,gBAAgBA,+BAA+BpL,SAAS0L;AAE5D;MAGA;QACEuX,2BAA2BjjB,SAASmjB;AACtC,QAAE,OAAO/Z;QACP,MAAM,IAAI8X,cACR;UAAEC,MAAM;UAAsB/V;WAC9B,2BACEkW,gBAAgBlY,MAAM;AAG5B;MAEA,IAAIyY,UAAA,gBAAAA,OAAQuB,SACV,MAAM,IAAIxC;MAGZ,MAAMyB,kBAAkBgB,qBAAqBJ;MAE7CH,oBAAoB;QAAEN;QAAMH;QAAiBW;;MAE7C,OAAOX;AACT;IAEA,IAAMiB,oBAAsB,UAAK;MAC/BC,OAAS,SAAIpB,eAAe;MAC5BqB,OAAS,SAAIrB,eAAe;MAC5BsB,OAAS,SAAItB,eAAe;MAC5Bjb,OAASuR,SAAW,SAAI0J,eAAe;MACvCuB,iBAAmBjL,SAAWI;MAC9B8K,gBAAkBrK,SAAWT;;IAG/B,IAAM+K,wBAA0BlL,OAC5BG,UACAH,OAASG,UAAUyK;IAKvB,SAASD,qBAAqBJ;MAC5B,KAAKA,oBACH,MAAM,IAAI/B,cACR;QAAEC,MAAM;SACR;MAIJ,OAAO7gB,OAAO+hB,mBAAqB/K,SACjC2L,oBACAW;MAGF,IAAItjB,OACF,MAAM,IAAI4gB,cACR;QAAEC,MAAM;SACR,6BAA6B7gB;MAIjC,OAAO+hB;AACT;IAEA,SAASK,sBACPL,iBACAM,QACAC;MAEA,MAAMD,UAAUN,kBACd,OAAO;MAGT,MAAMO,gBAAgBP,gBAAgBM,UACpC,MAAM,IAAIzB,cACR;QAAEC,MAAM;SACR,MAAMyB,0CAA0CD;MAIpD,OAAON,gBAAgBM,QAAQC;AACjC;;QCvLA,gBAAuBiB,qBAAoB,QACnC,QACA,SACC;MAQP,MAAMC,SAASC,OAAOC;MACtB,MAAMC,UAAU;MAChB,MAAMC,UAAU,IAAIC,YAAY;MAChC,IAAIC,SAAS;MAEb,MAAMC,YAAaje;QACjB;UACE,OAAOhE,KAAKkiB,MAAMle;AACpB,UAAE;UACA;YACE0d,OAAOS;AACT,YAAE,OAEF;UACA,MAAM,IAAIrD,cACR;YAAEC,MAAM;YAA2B/V;aACnC,0CAA0ChF;AAE9C;AAAA;MAGF,OAAO,MAAM;QACX,IAAIoe;QACJ;UACEA,mBAAmBC,gBAAgB;YACjCzoB,SAAS8nB,OAAOY;YAChB1C;YACA5W;;AAEJ,UAAE,OAAOhC;UACP;YACE0a,OAAOS;AACT,YAAE,OAEF;UAEA,IAAInD,aAAahY,MAAMiY,gBAAgBjY,IACrC,MAAMA;UAGR,MAAM,IAAI8X,cACR;YAAEC,MAAM;YAA6B/V;aACrC,iCAAiCkW,gBAAgBlY;AAErD;QAEA,OAAM,MAAM,SAAYob;QAExB,IAAIxO,MAAM;UACRoO,UAAUF,QAAQS;UAClB,IAAIP,QAAQ;kBACJC,UAAUD;YAChBA,SAAS;AACX;UAEA;AACF;QAEAA,UAAUF,QAAQS,OAAO9oB,OAAO;UAAEkoB,QAAQ;;QAC1C,MAAMa,QAAQR,OAAOje,MAAM8d;QAK3BG,SAASQ,MAAMzqB,SAASyqB,MAAMrR,OAAOqR,MAAMzqB,SAAS,GAAG,GAAG,KAAK;QAE/D,WAAWiM,QAAQwe,OAAO;UACxB,IAAI/C,OAAOuB,SACT,MAAM,IAAIxC;UAGZ,KAAKxa,MACH;gBAGIie,UAAUje;AAClB;AACF;AACF;IAEA,SAASqe,iBAAmB,SACnB,SACA;MAOP,IAAI1C;MAEJ,MAAM8C,iBAAiB,IAAI7nB,SAAe,CAAC8nB,GAAG1oB;QAC5C2lB,YAAYvZ,KAAKyZ,YAAW;UAC1BC,aAAaH;UACb3lB,OACE,IAAI8kB,cACF;YAAEC,MAAM;YAAW/V;aACnB,4BAA4B4W,UAAU;AAEzC,YACAA;AAAQ;MAGb,OAAOhlB,QAAQ+nB,KAAK,EAAC/oB,SAAS6oB,kBAAiB/oB,MAAMkpB;QACnD9C,aAAaH;QACb,OAAOiD;AAAG;AAEd;;QC3HO,SAASC,YACdC,GACAC;MAEA,MAAMllB,SAAqB;WAAcilB;;MACzC,WAAWjd,SAASkd,eACXllB,OAAOgI;MAEhB,OAAmBhI;AACrB;;QCNO,SAASmlB,gBACd5rB,GACAC;MAEA,IAAID,EAAE+pB,QAAQ9pB,EAAE8pB,OACd,QAAQ;MAEV,IAAI/pB,EAAE+pB,QAAQ9pB,EAAE8pB,OACd,OAAO;MAET,IAAI/pB,EAAEgqB,QAAQ/pB,EAAE+pB,OACd,QAAQ;MAEV,IAAIhqB,EAAEgqB,QAAQ/pB,EAAE+pB,OACd,OAAO;MAET,IAAIhqB,EAAEiqB,QAAQhqB,EAAEgqB,OACd,QAAQ;MAEV,IAAIjqB,EAAEiqB,QAAQhqB,EAAEgqB,OACd,OAAO;MAET,OAAO;AACT;;QC+BA,IAAM4B,WAAW;IAEjB,IAAMC,mBAAmB;IAUzB,eAAsBC,aAAY,QAC1B,cACM,MACR;MASJ;QACE,MAAMtlB,eAAemiB,eAAe;UAClCG,SAAS8C;UACT1C;UACAH;UACAI;UACAZ,SAASsD;UACTzD;;QAEF,SAAS5hB;AACX,QAAE;QACA,OAAO;AACT;AACF;IAEA,gBAAuBulB,UAAS,QACxB,cACM,gBACE,MACV;MAGJ,MAAMC,oBAAoBrD,eAAe;QACvCG,SAAS8C;QACT1C;QACAH;QACAI;QACAZ,SAASsD;QACTzD;;MAGF,OAAM,OAAStZ,MAAAA,SAASmd,gBAAgB;QACtCC;QACAC,eAAeH;;MAGjB,IAAIld,UAAS,WAAWod,sBAChB;QAAEpd,MAAM;;YAGV;QAAEA,MAAM;QAAiBsd,OAAOA,MAAM1rB;;MAE5C,WAAWyL,QAAQigB,cACVC,UAAU;QACfvD,SAAS8C;QACT1C;QACAH;QACA5O,SAAShO,KAAKgO;QACdiO;QACAkE,QAAQngB,KAAKmgB;QACbC,UAAUpgB,KAAKogB;;YAIb;QAAEzd,MAAM;;AAChB;IAcA,SAASmd,iBAAgB,gBACT;MAoBd,IAAIC,kBAAkBP,gBAAgBO,gBAAgBC,iBAAiB,GAAG;QACxE,MAAMK,kBAAkB,EAAG1C,OAAOC,OAAOC,WACvC,GAAGF,SAASC,SAASC;QACvB,MAAM,IAAIvC,cACR;UAAEC,MAAM;WACR,qBAAqB8E,gBACnBL,sDACuCK,gBACvCN;AAGN;MAIA,IAAIO,gBACDP,kBACDP,gBAAgBO,gBAAgB;WAAKC;QAAenC,OAAO;WAAO,IAC7D,UACA;MAUP,IACEyC,iBAAiB,aACjBP,kBAAA,gBAAAA,eAAgBK,aAChBJ,cAAcnC,QAAQkC,eAAelC,QAAQ,IAE7CyC,eAAe;MAqBjB,IAAIA,iBAAiB,WAAWN,cAAc1e,OAAO;QACnD,MAAM2e,SAAiC;QACvC,IAAIM,WAAW;QAEf,OAAOA,YAAYP,cAAc1e,OAAO;UACtC2e,OAAM/kB,KAAK;YACTilB,QAAQ;YACRnS,SAAS;cACP2P,OAAOqC,cAAcrC;cACrBC,OAAOoC,cAAcpC;cACrBC,OAAOmC,cAAcnC;;YAEvBuC,UAAU;cACRI,MAAMD;cACNjf,OAAO0e,cAAc1e;;;UAGzBif;AACF;QAEA,OAAO;UAAE5d,MAAM2d;UAAcL,OAAAA;;AAC/B;MAGA,IAAIK,iBAAiB,SACnB,OAAO;QACL3d,MAAM2d;QACNL,OAAO,EACL;UACEE,QAAQ;UACRnS,SAAS;YACP2P,OAAOqC,cAAcrC;YACrBC,OAAOoC,cAAcpC;YACrBC,OAAOmC,cAAcnC;;;;MAS/B,KAAKkC,gBACH,MAAM,IAAI5rB,MACR;MAKJ,MAAM8rB,QAAiC;MACvC,IAAIF,eAAeK,UAAU;QAC3B,IAAIG,WAAWR,eAAeK,SAASI,OAAO;QAE9C,OAAOD,YAAYR,eAAeK,SAAS9e,OAAO;UAChD2e,MAAM/kB,KAAK;YACTilB,QAAQ;YACRnS,SAAS;cACP2P,OAAOoC,eAAepC;cACtBC,OAAOmC,eAAenC;cACtBC,OAAOkC,eAAelC;;YAExBuC,UAAU;cACRI,MAAMD;cACNjf,OAAOye,eAAeK,SAAS9e;;;UAGnCif;AACF;AACF;MAGA,IAAIE,YAAYV,eAAelC,QAAQ;MACvC,OAAO4C,aAAaT,cAAcnC,OAAO;QACvCoC,MAAM/kB,KAAK;UACTilB,QAAQ;UACRnS,SAAS;YACP2P,OAAOqC,cAAcrC;YACrBC,OAAOoC,cAAcpC;YACrBC,OAAO4C;;;QAGXA;AACF;MAEA,OAAO;QAAE9d,MAAM2d;QAAcL;;AAC/B;IAYA,IAAMS,mBAAqB,UAAK;MAC9B/d,MAAQ2P,QAAQ;MAChBtE,SAAW,UAAK;QACd2P,OAAS,SAAIpB,eAAe;QAC5BqB,OAAS,SAAIrB,eAAe;QAC5BsB,OAAS,SAAItB,eAAe;QAC5BuB,iBAAmBjL,SAAWI;QAC9B8K,gBAAkBrK,SAAWT;;MAE/B0N,SAAW,SAAIpE,eAAe;MAC9BiE,MAAQ3N,SAAW,SAAI0J,eAAe;MACtC4D,QAAUlO,MAAM,EAAC,SAAS;;IAG5B,IAAM2O,kBAAoB,UAAK;MAC7B1B,GAAKjN,MAAM,EAAC,KAAK,KAAK;;IAGxBsF,gBAAgB2I,WAAU,SACjB,QACD,MACF,SACG,QACD,QACA;MAGN,MAAMW,gBAAgB,GAAG7S,QAAQ2P,SAAS3P,QAAQ4P,SAAS5P,QAAQ6P;MACnE,MAAMiD,iBAAiB,GAAGnE,wBAAwBI,UAAUH,QAAQiE;MACpE,MAAMrb,MACJ2a,WAAW,UACP,GAAGW,+BACHV,WACE,GAAGU,kBAAkBV,SAASI,eAC9B,GAAGM;MAEX,IAAI1mB;MACJ;QACEA,iBAAiBuhB,iBAAiBnW,KAAK;UACrCyW;UACAG,SAASsD;;AAEb,QAAE,OAAOlc;QACP,IAAIgY,aAAahY,MAAMiY,gBAAgBjY,IACrC,MAAMA;QAGR,MAAM,IAAI8X,cACR;UAAEC,MAAM;UAAwB/V;WAChC,iBAAiBA,uBAAuBkW,gBAAgBlY;AAE5D;MAEA,KAAKpJ,SAASkjB,IAAI;QAChB,MAAM/B,OACJnhB,SAAS0L,WAAW,MAChB,yBACA;QACN,MAAM,IAAIwV,cACR;UAAEC;UAAM/V;WACR,iBAAiBA,+BAA+BpL,SAAS0L;AAE7D;MAEA,IAAI1L,SAASmC,SAAS,MACpB,MAAM,IAAI+e,cACR;QAAEC,MAAM;QAA6B/V;SACrC;MAIJ,IAAIub,aAAa;MAEjB,iBAAiBvgB,QAAQyd,oBAAoB;QAC3CE,QAAQ/jB,SAASmC;QACjB0f;QACAG,SAASsD;QACTla;UAEA,IAAM9R,GAAG8M,MAAMkgB,mBAAmB;QAChC,IAAIK,YACF,MAAM,IAAIzF,cACR;UAAEC,MAAM;UAA+B/V;WACvC,kCAAkChJ,KAAKC,UAAU+D;QAIrD,IAAIgf,gBAAgBhf,KAAKwN,SAASA,aAAa,GAC7C,MAAM,IAAIsN,cACR;UAAEC,MAAM;UAA+B/V;WACvC,+CAA+ChJ,KAAKC,UAClDuR,iBACQxR,KAAKC,UAAU+D,KAAKwN;QAIlC,IAAIxN,KAAKggB,UAASJ,YAAA,gBAAAA,SAAUI,OAC1B,MAAM,IAAIlF,cACR;UAAEC,MAAM;UAA+B/V;WACvC,kDAAkD4a,YAAA,gBAAAA,SAAUI,cAAchgB,KAAKggB;QAInF,IAAIhgB,KAAK2f,WAAWA,QAClB,MAAM,IAAI7E,cACR;UAAEC,MAAM;UAA+B/V;WACvC,kCAAkC2a,0BAA0B3f,KAAK2f;QAIrE,IAAIa;QACJ,IAAIxgB,KAAKggB,cAAS,GAChBQ,iBAAiB;UACfre,MAAM;UACNse,cAAczgB,KAAKmgB;UACnB3S,SAAS;eACJxN,KAAKwN;YACRoS,UAAU;cACRI,MAAMhgB,KAAKggB;cACXlf,OAAO8e,SAAU9e;;YAEnBsb;;gBAIJoE,iBAAiB;UACfre,MAAM;UACNse,cAAczgB,KAAKmgB;UACnB3S,SAAS;eACJxN,KAAKwN;YACR4O;;;cAKAoE;QAEND,aAAa;AACf,aAAO,IAAIZ,WAAW,WAAazsB,GAAG8M,MAAMogB,kBAAkB;QAC5D,KAAKG,YACH,MAAM,IAAIzF,cACR;UAAEC,MAAM;UAA6B/V;WACrC,qCAAqChJ,KAAKC,UAAU+D;QAIxD,MAAMvD,OACJuD,KAAK0e,MAAM,MAAM,QAAQ1e,KAAK0e,MAAM,MAAM,WAAW;cACjD;UAAEvc,MAAM;UAAU1F;UAAM6V,QAAQuM,YAAY7e,MAAM,EAAC;;AAC3D,aAAO,IAAI2f,WAAW,UAAU,yBAAS3f,OAAO;QAC9C,KAAKugB,YACH,MAAM,IAAIzF,cACR;UAAEC,MAAM;UAA6B/V;WACrC,qCAAqChJ,KAAKC,UAAU+D;QAIxD,IAAI,OAAOA,MACT,MAAM,IAAI8a,cACR;UAAEC,MAAM;UAA6B/V;WACrC,iDAAiDhJ,KAAKC,UACpD+D;cAKA;UAAEmC,MAAM;UAAU1F,MAAM;UAAO6V,QAAQtS;;AAC/C,aAUE,MAAM,IAAI8a,cACR;QAAEC,MAAM;QAA6B/V;SACrC,0BAA0BhJ,KAAKC,UAAU+D;YAKzC;QAAEmC,MAAM;;AAChB;;;QC/fO,IAAMue,qBAAN,MAAM,4BAA2B/sB;MACtC,WAAAD,IAAe+mB;QACbtlB,SAASslB;QACTxnB,OAAOynB,eAAetlB,MAAM,oBAAmByC;QAE/C,WAAYlE,MAAcgnB,sBAAsB,YAC7ChnB,MAAcgnB,kBAAkBvlB,MAAM;QAGzCA,KAAKmB,OAAO;QACZnB,KAAKa,UAAU;AACjB;;;;QCAK,SAAS0qB,YAAYC;MAC1B,OAAO,KAAIA,MACR3gB,KAAKsT,KAAMA,EAAEsF,YAAY,KACzBvF,MAAMC,KAAMA,KAAK,SAAUA,KAAK;AACrC;;QCyBO,SAASsN,kBAAkBvO;MAChC,MAAMzY,SAAS;WACVyY;QACHwO,IAAIxO,QAAOwO,KACPxO,QAAOwO,GAAG7gB,KAAKkG,QAAUA,SAAS,IAAI,OAAOA,cAC7C;QACJ4a,IAAIzO,QAAOyO,KACPzO,QAAOyO,GAAG9gB,KAAKkG,QAAUA,SAAS,IAAI,OAAOA,cAC7C;QACJ6a,GAAGC,eAAe,KAAK3O,QAAO9B,KAAK,OAAQ8B,QAAOpC;QAClDgR,IAAI;QACJC,OAAO;QACPC,MAAM;;MAOR,KAAKvnB,OAAOinB,WACHjnB,OAAOinB;MAEhB,KAAKjnB,OAAOknB,WACHlnB,OAAOknB;MAGhB,OAAOlnB;AACT;IAEO,SAASwnB,wBACd/O;MAEA,OAAOA,QAAO9d;AAChB;IAaO,SAAS8sB,kBAAkBC;MAChC,OAAO;WACFA;QACHP,GAAGC,eAAe,KAAKM,MAAM/Q,KAAK,OAAQ+Q,MAAMrR;;AAEpD;IAEO,SAASsR,wBACdlP;MAEA,OAAOA,QAAO9d;AAChB;IAgBO,SAASitB,mBACdnP;MAEA,OAAO;WACFA;QACHiB,GAAGjB,QAAOiB,EAAEsF,YAAY;;AAE5B;IAEO,SAAS6I,yBACdpP;MAEA,OAAOA,QAAOiB,EAAEsF,YAAY;AAC9B;IAUO,SAAS8I,qBACdrP;MAEA,OAAOA;AACT;IAEO,SAASsP,2BACdtP;MAEA,OAAOA,QAAO9d;AAChB;IAQA,SAASysB,eAAenV;MAItB,OAAOtY,MAAMwT,KACX,IAAI6E,IAAIC,OAAO7L,KAAKxK,SAAUkjB,eAAeljB,SAAQrB,OAAOusB;AAEhE;;QChIA,SAASkB,cAActF;MACrB,QAAQA;OACN,KAAK;QACH,OAAO;;OAET,KAAK;QACH,OAAO;;OAET,KAAK;QACH,OAAO;;OAET,KAAK;QACH,OAAO;;AAEb;IA8DO,IAAMuF,cAAN;MAAA;QACL,KAAQpa,QAA4D;QAKpE,KAAUqa,gBAIN;UACFC,OAAOnB;UACPoB,OAAOX;UACPY,OAAOT;UACPU,UAAUR;;QAGZ,KAAUS,aAIN;UACFJ,OAAOX;UACPY,OAAOT;UACPU,OAAOR;UACPS,UAAUP;;AACZ;MAEA,UAAMhM;QACJ,IAAIxgB,KAAKsS,UAAU,QACjB,OAAOtS,KAAK+gB;QAGd,IAAI/gB,KAAKsS,UAAU,WACjB,OAAOtS,KAAKygB;QAGd,IAAIzgB,KAAKsS,UAAU,kBACXtS,KAAKitB;QAGbjtB,KAAKsS,QAAQ;QAGb,MAAMtF,QAAOhN;QAEbA,KAAKygB,cAAcH,OAAqB,UAAU,GAAG;UACnD,OAAAI,CACEK,IACAJ,YACAuM,aACArM;YAMA,IAAIF,aAAa,GAAG;cAClB,MAAMwM,aAAapM,GAAGqM,kBAA2B,SAAS;gBACxDC,SAAS;;cAEXF,WAAWG,YAAY,QAAQ,QAAQ;gBAAEC,YAAY;;cACrDJ,WAAWG,YAAY,SAAS,SAAS;gBAAEC,YAAY;;cACvDJ,WAAWG,YAAY,QAAQ,QAAQ;gBAAEC,YAAY;;cAErD,MAAMC,gBAAgBzM,GAAGqM,kBAA8B,YAAY;gBACjEC,SAAS;;cAEXG,cAAcF,YAAY,KAAK;cAC/BE,cAAcF,YAAY,KAAK;cAC/BE,cAAcF,YAAY,KAAK;cAE/BvM,GAAGqM,kBAA6B,WAAW;gBACzCC,SAAS;;AAEb;YACA,IAAI1M,aAAa,GAAG;cAClB,MAAM8M,aAAa1M,GAAGqM,kBAA2B,SAAS;gBACxDC,SAAS;;cAEXI,WAAWH,YAAY,KAAK,KAAK;gBAAEC,YAAY;;cAC/CE,WAAWH,YAAY,KAAK,KAAK;gBAAEC,YAAY;;AACjD;YACA,IAAI5M,aAAa,GAAG;cAClB,MAAM8M,aAAa5M,YAAYf,YAAY;cAC3C2N,WAAWH,YAAY,KAAK,KAAK;gBAAEC,YAAY;;AACjD;YACA,IAAI5M,aAAa,GAAG;cAClB,MAAM+M,aAAa3M,GAAGqM,kBAA2B,SAAS;gBACxDC,SAAS;;cAEXK,WAAWJ,YAAY,KAAK,KAAK;gBAAEC,YAAY;;cAC/CG,WAAWJ,YAAY,KAAK,KAAK;gBAAEC,YAAY;;cAE/CG,WAAWJ,YAAY,KAAK,KAAK;gBAAEC,YAAY;;cAE/CG,WAAWJ,YAAY,MAAM,MAAM;gBAAEC,YAAY;;cACjDG,WAAWJ,YAAY,SAAS,SAAS;gBAAEC,YAAY;;cACvDG,WAAWJ,YAAY,QAAQ,QAAQ;gBAAEC,YAAY;;AACvD;AACF;UACA,OAAAzM;YACEnf,QAAQ2M,IAAI;AACd;UACA,QAAA2S;YACE,IAAIjU,MAAK+T,IAAI;cACX;gBACE/T,MAAK+T,GAAG4M;AACV,gBAAE,OAEF;cACA3gB,MAAK+T,UAAK;cACV/T,MAAKsF,QAAQ;AACf;AACF;WACChS,MAAMygB;UACP/T,MAAK+T,KAAKA;UACV/T,MAAKsF,QAAQ;UACb,OAAOyO;AAAE;QAGX;gBACQ/gB,KAAKygB;AACb,UAAE,OAAO7S;UACP5N,KAAKsS,QAAQ;UACb,MAAM1E;AACR,UAAE;UAEA5N,KAAKygB,mBAAc;AACrB;QAOAS,SAAS,cAAclc,OAAM;QAE7B,OAAOhF,KAAK+gB;AACd;MAEA,WAAM4M;QA1PR;QA2PI,IAAI3tB,KAAKsS,UAAU,QACjB;QAGF,IAAItS,KAAKsS,UAAU,YACjB,OAAOtS,KAAKitB;QAGd,IAAIjtB,KAAKsS,UAAU,iBACXtS,KAAKygB;SAGb,KAAAzgB,KAAK+gB,OAAL,mBAAS4M;QACT3tB,KAAK+gB,UAAK;QACV/gB,KAAKsS,QAAQ;AACf;MAEA,aAAMsb;QACJ,IAAI5tB,KAAKsS,UAAU,cACXtS,KAAK2tB;QAGb3tB,KAAKsS,QAAQ;QAEbtS,KAAKitB,gBAAgB/L,SAAS,UAAU;UACtC,OAAAJ;YACEnf,QAAQ2M,IAAI;AACd;;cAGItO,KAAKitB;QAEXjtB,KAAKitB,qBAAgB;QACrBjtB,KAAKsS,QAAQ;AACf;MAEA,iBAAMub,CAAY1G;QAChB,MAAMpG,WAAW/gB,KAAKwgB;QAEtB,MAAMf,KAAKsB,GAAGF,YAAY,EAACsG,QAAQ,aAAY;QAE/C;UAEE,MAAM2G,cAAcrO,GAAGK,YAAYqH;gBAC7B2G,YAAY9nB;UAGlB,MAAM+nB,eAAetO,GAAGK,YAAY;UACpC,MAAM1gB,KAAKqtB,cAActF;eACpB4G,aAAa7U,OAAO9Z;AAC3B,UAAE,OAAOwO;UACPjM,QAAQmD,MAAM,+BAA+BqiB,WAAWvZ;UAGxD6R,GAAGjF,KAAKxV,OAAM;UACd;YACEya,GAAG2G;AACL,YAAE,OAIF;UAEA,MAAMxY;AACR;cAEM6R,GAAGjF;AACX;MAEA,oBAAMwT,CAAe7G;cACbnnB,KAAKwgB;QAEX,MAAM1hB,MAAM2tB,cAActF;QAC1B,MAAM8G,mBAAmBjuB,KAAK+gB,GAAI9gB,IAAI,WAAWnB;QACjD,KAAKmvB,YACH,OAAO;QAGT,OAAOxE,YAAYwE,YAAY,EAAC;AAClC;MAEA,uBAAMC,EAAkB,QAChB;cAMAluB,KAAKwgB;QAEX;UACE,MAAMphB,KAAKqtB,cAActF;gBACnBnnB,KAAK+gB,GAAIoN,IAAI,WAAW;eAAK/V;YAAShZ;;AAC9C,UAAE,OAAOwO;UACPjM,QAAQmD,MACN,8BAA8BqiB,cAAcvgB,KAAKC,UAAUuR,YAC3DxK;UAGF,MAAMA;AACR;AACF;MAEA,kBAAMwgB,EAAmC,QACjC;cAMApuB,KAAKwgB;QAEX,MAAMf,KAAKzf,KAAK+gB,GAAIF,YAAYsG,QAAQ,aAAa;UACnDkH,YAAY;;QAEd,MAAMC,QAAQ7O,GAAGoC;QAEjB;UAME,WAAW0M,WAAUC,SACnB,IAAID,QAAOlnB,SAAS,eACbinB,MAAMpV,OAAOlZ,KAAKgtB,WAAW7F,QAAQoH,QAAOrR,oBAE5CoR,MAAMH,IAAInuB,KAAK2sB,cAAcxF,QAAQoH,QAAOrR;gBAI/CuC,GAAGjF;AACX,UAAE,OAAO5M;UACPjM,QAAQmD,MAAM,yBAAyBqiB,UAAUvZ;UAGjD6R,GAAGjF,KAAKxV,OAAM;UACd;YACEya,GAAG2G;AACL,YAAE,OAEF;UAWA,IAAIqI,mBAAmB7gB,YAAa8gB,iBAAkB;YACpD/sB,QAAQgtB,KACN;YAEF,MAAM,IAAIrD;AACZ;UAEA,MAAM1d;AACR;AACF;;MAGA,eAAMghB,CAAU9B;cACR9sB,KAAKwgB;QAEX,MAAM/b,SAAkC;QACxC;UACE,MAAMgb,KAAKzf,KAAK+gB,GAAIF,YAAY;UAChC,WAAW1C,KAAK2O,OAAO;YACrB,MAAM5P,gBAAeuC,GAAGoC,MAAM5hB,IAAIke;YAClC,IAAIjB,SACFzY,OAAOa,KAAK4X;AAEhB;AACF;QAEA,OAAOzY;AACT;;IASF,SAASgqB,mBAAmB7gB;MAC1B,WAAWA,MAAM,aACf,OAAO;MAKT,OACGA,aAAarP,WAAUqP,KAAA,gBAAAA,EAAGzM,UAAUyM,KAAA,gBAAAA,EAAGzM,UAAS,aAAYyM,KAAA,gBAAAA,EAAG/M;AAEpE;IAEA8gB,eAAe+M;MACb;QACE,MAAMG,iBAAiB7hB,KAAKC,UAAU6hB,QAAQD;QAC9C,cACSA,SAASE,UAAU,sBACnBF,SAASG,UAAU,eAC1BH,SAASE,QAAQF,SAASG,QAAQ;AAEtC,QAAE;QACA,OAAO;AACT;AACF;;QCpcO,SAASC,QAAQ3c,OAAoB4c;MAC1C,QAAQA,OAAOniB;OACb,KAAK;QACH,OAAO;UACLA,MAAM;UACNoa,QAAQ+H,OAAO/H;UACfgI,WAAW7c,MAAM6c;;;OAGrB,KAAK;QACH,OAAO;UACLpiB,MAAM;UACNoiB,WAAWD,OAAOE;;;OAGtB,KAAK;QACH,OAAO;UAAEriB,MAAM;UAAQoiB,WAAWD,OAAOE,aAAa9c,MAAM6c;;;OAE9D,KAAK;OACL,KAAK;QAQH,OAAO7c;;OAET,KAAK;QACH,IAAIA,MAAMvF,SAAS,QAAQ;UACzBpL,QAAQmD,MAAM;UACd,OAAOwN;AACT;QAEA,OAAO;UACLvF,MAAM;UACNoa,QAAQ7U,MAAM6U;UACd/O,SAAS8W,OAAO9W;UAChBiX,cAAc;UACdC,eAAehd,MAAMvF,SAAS,aAAauF,MAAMgd,gBAAgB;UACjEH,WAAW7c,MAAM6c;;;OAGrB,KAAK;QAIH,OAAO7c;;OAET,KAAK;QACH,IAAIA,MAAMvF,SAAS,YAAY;UAC7BpL,QAAQmD,MAAM,qCAAqCwN,MAAMvF;UACzD,OAAOuF;AACT;QAEA,OAAO;aACFA;UACH+c,cAAcH,OAAOG;UACrBC,eAAeJ,OAAOI;;;OAG1B,KAAK;QAEH,OAAOhd;;AAEb;;QCpDA,IAAMid,kBAA2C,UAAK;MACpD1wB,GAAKoe,SAAW,WAAQI;MACxBmS,GAAKvS,SAAW,WAAQI;MACxBoS,IAAMxS,SAAWI;MACjBqS,IAAMzS,SAAWI;;IAGnB,IAAMsS,eAAqC,UAAK;MAC9C9wB,GAAK,SAAI8nB,eAAe;MACxBiJ,KAAO3S,SAAW,WAAQI;;IAG5B,IAAMwS,oBAA+C,UAAK;MACxDhxB,GAAKoe,SAAW,WAAQI;MACxBmS,GAAKvS,SAAW,WAAQI;MACxBvJ,KAAOmJ,SAAW,SAAI0J,eAAe;MACrC3oB,GAAKif,SAAWK,MAAM,EAAG,SAAIqJ,eAAe,IAAM,WAAMgJ;MACxDF,IAAMxS,SAAWI;MACjBqS,IAAMzS,SAAWI;;IAInB,IAAMyS,uBACFxS,MAAM,EACJ,UAAK;MACLlC,GAAK0C,SAAWT;MAChB0S,OAAS9S,SAAW,SAAI0J,eAAe;QAEvC,UAAK;MACL7L,GAAKgD,SAAWT;MAChB0S,OAAS9S,SAAW,SAAI0J,eAAe;QAEvC,UAAK;MACLvL,GAAK0C,SAAWT;MAChBvC,GAAKuC;MACL0S,OAAS9S,SAAW,SAAI0J,eAAe;;IAI7C,IAAMqJ,mBAA6C,UAAK;MACtDhJ,MAAQ/J,SAAWa,SAAWT;MAC9B4S,KAAOhT,SAAWI;;;;;;MAQlBuN,MAAQtN,MAAM,EAAGZ,QAAQ,OAASA,aAAQ;MAC1CwT,OAAS5S,MAAM,EAAGZ,QAAQ,OAASA,aAAQ;;IAG7C,IAAMyT,kBAA2C,UAAK;MACpDC,GAAKtS,SAAW,WAAQA,SAAWT;MACnCgT,IAAMpT,SAAW,SAAI0J,eAAe;MACpCK,MAAQ/J,SAAWa,SAAWT;MAC9BiT,MAAQrT,SAAW,SAAI0J,eAAe;MACtC4J,MAAQtT,SAAW,SAAI0J,eAAe;MACtCiJ,KAAO3S,SAAW,WAAQI;MAC1B5Q,OAASwQ,SAAW,WAAQI;MAC5BmT,MAAQvT,SAAW,WAAQI;MAC3BoT,MAAQxT,SAAW,WAAQI;MAC3BqT,KAAOzT,SAAWa,SAAWT;MAC7BsT,MAAQ1T,SAAWa,SAAW,WAAMgS;MACpCc,KAAO3T,SAAWa,SAAW,WAAMgS;MACnCe,MAAQ5T,SAAWa,SAAW,WAAMkS;;IAGtC,IAAMc,eAAiB,SAAInK,eAAe;IAW1C,IAAMoK,2BAA6D,UAAK;MACtE3xB,IAAI0xB;MACJ1V,GAAK6B,SAAWa,SAAW,WAAQT;MACnCsO,IAAM1O,SAAWa,SAAW,WAAQR,MAAM,EAAGZ,QAAQ,IAAI6S;MACzDzU,GAAK,WAAQgD,SAAWA,SAAWT;MACnCqO,IAAMzO,SACFa,SAAW,WAAQR,MAAM,EAAGZ,QAAQ,IAAImT;MAE5CvU,GAAK,WAAM6U;;IAGN,SAASa,2BACd9T;MAEA,OAASpB,SAASoB,SAAQ6T;AAC5B;IAMA,IAAME,iCACF,UAAK;MACL7xB,IAAI0xB;;IAGD,SAASI,iCACdhU;MAEA,OAASpB,SAASoB,SAAQ+T;AAC5B;IAQA,IAAME,wBAAuD,UAAK;MAChEpkB,MAAQkQ,SAAW,WAAQI;MAC3B+T,KAAO,WAAQtT,SAAWT;MAC1BgU,IAAMpU,SAAW,WAAQa,SAAWT;;IAGtC,IAAMiU,eAAiB,SAAI3K,eAAe;IAI1C,IAAM4K,2BAA6D,UAAK;MACtEnyB,IAAIkyB;MACJlW,GAAK6B,SAAW,WAAQa,SAAWT;MACnCvC,GAAKgD,SAAW,WAAQA,SAAWT;MACnCmU,IAAM,WAAML;;IAGP,SAASM,2BACdvU;MAEA,OAASpB,SAASoB,SAAQqU;AAC5B;IAMA,IAAMG,iCACF,UAAK;MACLtyB,IAAIkyB;;IAGD,SAASK,iCACdzU;MAEA,OAASpB,SAASoB,SAAQwU;AAC5B;IAQA,IAAME,iBAA6C,UAAK;MACtDC,IAAM5U,SAAW,WAAQI;MACzByU,KAAO7U,SAAW,WAAQI;MAC1B0U,IAAM9U,SAAW,WAAQI;MACzB2U,IAAM/U,SAAW,WAAQI;;IAG3B,IAAM4U,gBAAuC,UAAK;MAChD/X,GAAK,SAAIyM,eAAe;MACxBuL,QAAUjV,SAAW,SAAI0J,eAAe;MACxCxlB,MAAQ8b,SAAW,WAAQI;MAC3B8U,KAAOlV,SAAWI;;IAGpB,IAAM+U,aAA0C,UAAK;MACnDC,IAAMpV,SAAS0J;MACf2L,IAAM,SAAI3L,eAAe;MACzB4L,MAAQtV,SAAW,SAAI0J,eAAe;;;MAGtC6L,MAAQvV,SAAW,SAAI0J,eAAe;MACtC8L,OAASxV,SAAW,SAAI0J,eAAe;MACvC+L,IAAMzV,SAAW,SAAI0J,eAAe;;;MAGpCgM,IAAM1V,SAAW,SAAI0J,eAAe;MACpCiM,MAAQ3V,SAAW,WAAQI;;IAG7B,IAAMwV,gBAAkB/U,SAAWT;IAInC,IAAMyV,4BAA+D,UAAK;MACxE3U,GAAG0U;MACH/X,GAAG8W;MACHmB,GAAK,WAAQ1V;MACb2V,QAAU/V,SAAWI;MACrB4V,KAAKhB;MACLiB,MAAQhW,OAASG,UAAYC,MAAM,EAAGD,UAAY;MAClDmT,MAAM4B;MACNe,IAAMlW,SAAWI;MACjB+V,MAAQnW,SAAWI;MACnB8U,KAAOlV,SAAW,WAAQI;MAC1BgU,IAAMpU,SAAWK,MAAM,EAAGD,UAAY,WAAQA;;IAGzC,SAASgW,4BACdnW;MAEA,OAASpB,SAASoB,SAAQ4V;AAC5B;IAMA,IAAMQ,kCACF,UAAK;MACLnV,GAAG0U;;IAGA,SAASU,kCACdrW;MAEA,OAASpB,SAASoB,SAAQoW;AAC5B;IAQA,IAAME,kBAAoB1V,SAAWT;IAWrC,IAAMoW,8BAAmE,UAAK;MAC5Er0B,IAAIo0B;MACJ1Y,GAAK,SAAI6L,eAAe;MACxB1oB,GAAKgf,SAAWa,SAAWT;MAC3BjC,GAAK6B,SAAWa,SAAWT;MAC3BqW,KAAOzW,SAAS0J;MAChBrL,GAAGqL;MACHoL,IAAM,WAAQjU,SAAWT;MACzBsW,MAAQ1W,SAAWa,SAAWT;MAC9B0V,GAAK,WAAQjV,SAAWT;MACxB2V,QAAU/V,SAAWa,SAAWT;;IAG3B,SAASuW,8BACd1W;MAEA,OAASpB,SAASoB,SAAQuW;AAC5B;IAMA,IAAMI,oCACF,UAAK;MACLz0B,IAAIo0B;;IAGD,SAASM,oCACd5W;MAEA,OAASpB,SAASoB,SAAQ2W;AAC5B;IAiBA,IAAME,gCAIF;MACFnH,OAAOoE;MACPnE,OAAO4E;MACP3E,OAAOuG;MACPtG,UAAU6G;;IAGL,SAASI,wBAAkD,QAEhE9W,QAAAA;MAKA,OAAO6W,8BAA8B5M,QAAQjK;AAC/C;IAcA,IAAM+W,sCAIF;MACFrH,OAAOsE;MACPrE,OAAO8E;MACP7E,OAAOyG;MACPxG,UAAU+G;;IAGL,SAASI,8BAAwD,QAEtEhX,QAAAA;MAKA,OAAO+W,oCAAoC9M,QAAQjK;AACrD;;QCnVA,IAAMiX,aAAa;IAGnB,IAAMC,0BAA0B;IAEhC,eAAsB7F,QAAO,UACnB,gBACM,MACV,cACQ,QACN,QACA;MAWN,OAAO8F,SAAS;QACd5b;QACA0R;QACAnD;QACAI;QACAD;QACAd;QACAxE;;AAEJ;IAEAF,eAAe0S,UAAoC,UACzC,gBACM,MACV,cACQ,QACN,QACA;MAaN,KAAKlK,sBACGtI,MAAMgM,YAAY1G;MAG1B,IAAImN,cAAc;MAClB,IAAIC;MACJ,IAAIC,aAAa;MAEjB,IAAIC,gBAAgB;MACpB,IAAIpJ,eAAe;MACnB,IAAImD,UAAuC;MAE3C,IAAIkG;MAEJ,iBAAiBnlB,SAASya,SAAS;QACjC7C;QACAC;QACA+C;QACAnD;QACAX;UACE;QACF,IAAIA,OAAOuB,SACT,MAAM,IAAIxC;QAGZ,QAAQ7V,MAAMxC;SACZ,KAAK;gBACG8U,MAAMgM,YAAY1G;UACxB;;SAEF,KAAK;UACHqN,aAAajlB,MAAM8a;UACnB5R,SAAS;YAAE1L,MAAM;;UACjB;;SAEF,KAAK;UACH0L,SAAS;YAAE1L,MAAM;;UACjB;;SAEF,KAAK;UACHunB;UACAG,gBAAgB;UAChBpJ,eAAe9b,MAAM8b;UACrBkJ,qBAAqBhlB,MAAM6I;UAC3BK,SAAS;YAAE1L,MAAM;YAAaqL,SAAS7I,MAAM6I;;UAC7C,IAAIkc,gBAAgB,GAAG;YACrB7b,SAAS;cAAE1L,MAAM;cAAYsiB,cAAc;cAAGC,eAAe;;YAC7DoF,4BAA4B;AAC9B;UACA;;SAEF,KAAK;UACH;YAEE,IAAIlG,QAAQ7vB,QAAQ;oBACZkjB,MAAMuM,aAAa;gBAAEjH;gBAAQqH;;cACnCA,UAAU;AACZ;YAMA,MAAMmG,iBAAiBJ;YACvB,IACEI,eAAenK,YACfmK,eAAenK,SAASI,SAAS+J,eAAenK,SAAS9e,cAElDipB,eAAenK;kBAElB3I,MAAMqM,kBAAkB;cAC5B/G;cACA/O,SAASuc;;YAIX,MAAMrF,gBAAgBgF,cAAcE;YACpC/b,SAAS;cACP1L,MAAM;cACNsiB,cAAc;cACdC;;YAEFoF,4BAA4BpF;YAE5B7W,SAAS;cAAE1L,MAAM;cAAWqL,SAASuc;;AACvC;UACA;;SAEF,KAAK;UACH;YACE,OAAO7vB,OAAOypB,WAAUqG,iBAAiB;cAAEzN;cAAQ5X;;YACnD,IAAIzK,OACF2T,SAAS;cACP1L,MAAM;cACNlM,SAASiE,MAAMjE;cACfqc,QAAQ3N,MAAM2N;qBAEX;cACLsR,QAAQlpB,KAAKipB;cACb,IAAIC,QAAQ7vB,UAAUw1B,YAAY;sBAC1BtS,MAAMuM,aAAa;kBAAEjH;kBAAQqH;;gBACnCA,UAAU;AACZ;AACF;YAKAiG;YAIA,MAAMpF,eAAeoF,gBAAgBpJ;YACrC,MAAMiE,iBAAiBgF,cAAc,IAAIjF,gBAAgBmF;YACzD;;;;YAIEnF,eAAe,MACdqF,mCAA8B,KAC7BpF,gBAAgBoF,4BACdN,0BACJ;cACA3b,SAAS;gBAAE1L,MAAM;gBAAYsiB;gBAAcC;;cAC3CoF,4BAA4BpF;AAC9B;AACF;UACA;;AAEN;AACF;IAEA,SAASsF,kBAA4C,QAC7C;MAMN,OAAM,MAAQ1X,QAAQ2X,qBAAsBtlB;MAC5C,IAAIlI,SAAS,UAAU;QACrB,OAAO3C,MAAKwY,WAAUgX,6BAA6B;UACjD/M;UACAjK,QAAQ2X;;QAEV,OAAOnwB,OAAM,EAACA,WAAK,MAAa,OAAC,GAAW;UAAE2C;UAAM6V,QAAAA;;AACtD;MAEA,OAAOxY,KAAKwY,WAAU8W,uBAAuB;QAC3C7M;QACAjK,QAAQ2X;;MAEV,OAAOnwB,MAAM,EAACA,UAAK,MAAa,OAAC,GAAW;QAAE2C;QAAM6V,QAAAA;;AACtD;;QC7NA,IAAM4X,gBAAoD;MACxDhI,OAAO;MACPC,UAAU;MACVF,OAAO;MACPD,OAAO;;IAkBF,IAAMmI,YAAN;;;;MAsCL,WAAAz2B,EAAY,UAAY,SAAiC,CAAC;QArC1D,KAAAwuB,QAAwB;UACtBxa,OAAO;UACP8F,SAAS;UACT4c,aAAa;YAAEjoB,MAAM;YAAQoiB,WAAW;;;QAE1C,KAAApC,WAA2B;UACzBza,OAAO;UACP8F,SAAS;UACT4c,aAAa;YAAEjoB,MAAM;YAAQoiB,WAAW;;;QAE1C,KAAAtC,QAAwB;UACtBva,OAAO;UACP8F,SAAS;UACT4c,aAAa;YAAEjoB,MAAM;YAAQoiB,WAAW;;;QAE1C,KAAAvC,QAAwB;UACtBta,OAAO;UACP8F,SAAS;UACT4c,aAAa;YAAEjoB,MAAM;YAAQoiB,WAAW;;;QAM1C,KAAQ8F,UAAU;QAElB,KAAQC,kBAAoC;QAC5C,KAAQC,oBAEJ;UAAEvI,YAAO;UAAWE,YAAO;UAAWD,YAAO;;QAS/C7sB,KAAK6hB,QAAQ,IAAI6K;QACjB1sB,KAAKi1B,UAAUA;QAGfj1B,KAAKo1B,eAAe;UAClB;YACE,WAAWjO,UAAU3B,eAAe;cAKlC,MAAM6P,oBAAqBr1B,KAAc6hB,MAAMmM,eAAe7G;cAC9DnnB,KAAKkuB,kBAAkB/G,QAAQkO;AACjC;AACF,YAAE,OAAOznB;YACPjM,QAAQmD,MAAM;YACdnD,QAAQmD,MAAM8I;YAGd,WAAWuZ,UAAU3B,eACnBxlB,KAAKmnB,UAAU;iBACVnnB,KAAKmnB;cACR7U,OAAO;cACP8F,SAAS;;YAIb,MAAMxK;AACR,YAAE;YACA5N,KAAKs1B,cAAc;AACrB;AACD,UA3BmB;AA4BtB;MAEA,SAAIC;QACF,OAAOv1B,KAAKo1B;AACd;;;;MAQA,aAAMxH;QACJ;gBACQ5tB,KAAKu1B;AACb,UAAE,OAEF;QAEA,MAAMC,UAAUhQ,cAActH,MAC3Bpf,OAAoBkB,KAAKlB,KAAKwT,UAAU;QAE3C,IAAIkjB,eACIx1B,KAAK6hB,MAAM+L;QAGnB,MAAM6H,sBAAsBhQ,mBAAmBvH,MAC5C5C,aAAatb,KAAKm1B,kBAAkB7Z,QAAO;QAE9C,IAAItb,KAAKi1B,WAAWQ,qBAClB9zB,QAAQgtB,KAAK;QAGf3uB,KAAK6hB,QAAQ,IAAI6K;QACjB,WAAWvF,UAAU3B,eACnBxlB,KAAKmnB,UAAU;UACb7U,OAAO;UACP8F,SAAS;UACT4c,aAAa;YAAEjoB,MAAM;YAAQoiB,WAAW;;;QAG5CnvB,KAAKs1B,cAAc;AACrB;MAEA,kBAAMI,CAAavO;QACjB,IAAInnB,KAAKm1B,kBAAkBhO,SACzBnnB,KAAK21B,aAAaxO;cAGdnnB,KAAK6hB,MAAMgM,YAAY1G;QAC7BnnB,KAAKkuB,kBAAkB/G,QAAQ;QAE/B,IAAIA,WAAW,SAAS;gBAChBnnB,KAAK6hB,MAAMgM,YAAY;UAC7B7tB,KAAKkuB,kBAAkB,YAAY;AACrC;AACF;;;;MAQA,iBAAA0H,CAAkBnd;QAChB,IAAIzY,KAAKk1B,gBAAgBpqB,QAAQ2N,eAAe,GAC9C;QAEFzY,KAAKk1B,gBAAgB5vB,KAAKmT;AAC5B;MAEA,oBAAAod,CAAqBpd;QACnB,MAAM9G,QAAQ3R,KAAKk1B,gBAAgBpqB,QAAQ2N;QAC3C,IAAI9G,WAAW,GACb;QAEF3R,KAAKk1B,gBAAgBnd,OAAOpG,OAAO;AACrC;MAEQ,aAAA2jB,CAAcQ;QACpB,MAAMZ,kBAAkBl1B,KAAKk1B,gBAAgBhqB;QAC7C,WAAWuN,YAAYyc,iBACrBzc,SAASqd;AAEb;;;;MAQA,YAAMvH,EAAO,QAAQ;QAEnB,MAAMwH,iBAAiB/1B,KAAKm1B,kBAAkBhO;QAC9C,IAAI4O,kBAAkBA,eAAe/O,SAASA,MAAM;UAClD,IAAIhnB,KAAKi1B,SACPtzB,QAAQgtB,KACN,oCAAoCxH;UAIxC,OAAO4O,eAAev1B;AACxB;QAGA,IAAIu1B,gBAAgB;UAClB,IAAI/1B,KAAKi1B,SACPtzB,QAAQgtB,KACN,mCAAmCxH,gDAAgDH,mDAAmD+O,eAAe/O;UAIzJhnB,KAAK21B,aAAaxO;AACpB;QAEA,MAAMlB,aAAa,IAAIC;QACvB,MAAMG,SAASJ,WAAWI;QAC1B,MAAM2P,gBAAgB;gBACdh2B,KAAKu1B;UAEX,IAAIlP,OAAOuB,SACT,MAAM,IAAIxC;UAGZ,QAAQ+B;WACN,KAAK;kBACGnnB,KAAKq0B,SAAS;cAAElN,QAAQ;cAASd;cAAQW;;YAC/C;;WAEF,KAAK;kBACGhnB,KAAKq0B,SAAS;cAAElN,QAAQ;cAASd;cAAQW;;YAC/C,IAAIX,OAAOuB,SACT,MAAM,IAAIxC;kBAENplB,KAAKq0B,SAAS;cAAElN,QAAQ;cAAYd;cAAQW;;YAClD;;WAEF,KAAK;kBACGhnB,KAAKq0B,SAAS;cAAElN,QAAQ;cAASd;cAAQW;;YAC/C;;UAGJ,IAAIX,OAAOuB,SACT,MAAM,IAAIxC;AAEb,UA5BqB;QA8BtBplB,KAAKm1B,kBAAkBhO,UAAU;UAC/BH;UACAf;UACAzlB,SAASw1B,cACNhxB,OAAM,WACNixB,SAAQ;YAGP,IACEj2B,KAAKm1B,kBAAkBhO,WACvBnnB,KAAKm1B,kBAAkBhO,QAASH,SAASA,MAEzChnB,KAAKm1B,kBAAkBhO,eAAU;YAEnCnnB,KAAKs1B,cAAc;AAAe;;QAIxC,OAAOU;AACT;MAEA,cAAc3B,EAAS,QACf,QAENrN,MAAMkP;QA1RV;QAgSI,IAAIC,iBAAiB;QAErB,MAAMlH,WAAWC;UACflvB,KAAKmnB,QAAQ6N,cAAc,QACzBh1B,KAAKmnB,QAAQ6N,aACb9F;UAGF,IAAIA,OAAOniB,SAAS,WAAW;YAC7BopB,iBAAiB;YACjBn2B,KAAKkuB,kBAAkB/G,QAAQ+H,OAAO9W;AACxC;UAEA,IAAI8W,OAAOniB,SAAS,gBAAgB/M,KAAKi1B,SACvCtzB,QAAQC,KAAK,2BAA2BstB,OAAOruB,SAASquB,OAAOhS;UAGjEld,KAAKs1B,cAAc;AAAe;QAIpC,IAAIjP,OAAOuB,SAAS;UAClBqH,SAAQ;YAAEliB,MAAM;YAASqiB,WAAW;;UACpC,MAAM,IAAIhK;AACZ;QAEA,MAAMgK,aAAY,IAAIlxB;QAEtB;UACE+wB,SAAQ;YAAEliB,MAAM;YAASoa;;UAIzB,MAAMH,OACJkP,kBAAkB,cACXnM,YAAY;YACjB5C;YACAH,MAAMkP;YACN9O,cAAc0N,cAAc3N;YAC5Bd;eAEE6P,gBACA;UAIN,MAAME,cACJp2B,KAAKmnB,QAAQ7U,UAAU,QAAO,KAAAtS,KAAKmnB,QAAQ/O,YAAb,mBAAsB4O,YAAO;UAC7D,IAAIoP,eAAeA,gBAAgBpP,MAAM;YACvC,IAAIhnB,KAAKi1B,SACPtzB,QAAQgtB,KACN,eAAexH,mCAAmCH;kBAGhDhnB,KAAK6hB,MAAMgM,YAAY1G;YAC7BnnB,KAAKkuB,kBAAkB/G,QAAQ;AACjC;UAEA,IAAId,OAAOuB,SACT,MAAM,IAAIxC;UAGZ,IAAIplB,KAAKi1B,SACPtzB,QAAQgtB,KACN,4BAA4BxH,uCAAuCvgB,KAAKC,UACtE7G,KAAKmnB,QAAQ/O,gBAAW;gBAKxBmW,OAAO;YACX9V,UAAUwW;YACV9E,gBAAgBnqB,KAAKmnB,QAAQ/O,gBAAW;YACxC4O;YACAI,cAAc0N,cAAc3N;YAC5Bd;YACAc;YACAtF,OAAO7hB,KAAK6hB;;UAGd,IAAIwE,OAAOuB,SACT,MAAM,IAAIxC;UAGZ6J,SAAQ;YAAEliB,MAAM;YAAOqiB;;AACzB,UAAE,OAAOxhB;UAGPqhB,SAAQ;YACNliB,MAAM;YACNqiB,WAAW+G,iBAAiB/G,YAAY;;UAE1C,MAAMxhB;AACR;AACF;MAEQ,iBAAAsgB,CAAkB/G,QAAoB/O;QAC5C,IACEpY,KAAKmnB,QAAQ7U,UAAU,UACvBtS,KAAKmnB,QAAQ7U,UAAU,kBACvB;QAAA,KAAA5U,cAAasC,KAAKmnB,QAAQ/O,SAASA,UAEnC;QAGFpY,KAAKmnB,QAAQ/O,UAAUA;QACvBpY,KAAKmnB,QAAQ7U,QAAQ8F,UAAU,OAAO;QAEtCpY,KAAKs1B,cAAc;AACrB;MAEA,YAAAK,CAAaxO;QACX,MAAMkP,mBAAmBr2B,KAAKm1B,kBAAkBhO;QAChD,KAAKkP,kBACH,OAAO;QAGTA,iBAAiBpQ,WAAWG;QAE5B,OAAO;AACT;;;;MAQA,aAAIkQ;QACF,OAAOt2B,KAAKi1B;AACd;;;;IClaK,IAAMsB,eAAN,MAAM,sBAAqBh4B;MAChC,WAAAD,IAAe+mB;QACbtlB,SAASslB;QACTxnB,OAAOynB,eAAetlB,MAAM,cAAayC;QAEzC,WAAYlE,MAAcgnB,sBAAsB,YAC7ChnB,MAAcgnB,kBAAkBvlB,MAAM;QAGzCA,KAAKmB,OAAO;AACd;;;;;QC6FK,IAAMq1B,aAAa,EAAC,QAAQ,QAAQ,OAAO,OAAO;IAElD,IAAMC,iBAAiBD,WAAW73B;IAClC,IAAM+3B,sBAAsB5tB,KAAK6tB,MAAM7tB,KAAK8tB,KAAKH,mBAAmB;;IC7EpE,SAASI,aACd3Z,SACA/J,QACA2jB;MAEA,IAAIC,cACFC,kBACAC,aACAC,iBACAC;MACF,WAAWhkB,WAAW,WAElB4jB,cACAC,kBACAC,aACAC,iBACAC,gBACEC,kCAAkCla,SAAQ/J,QAAQ2jB,kBAGpDC,cACAC,kBACAC,aACAC,iBACAC,gBACEE,iBAAiBna,SAAQ/J,QAAQ2jB;MAGvC,OAAOQ,eACLpa,SACA6Z,cACAC,kBACAC,aACAC,iBACAC,cACA;AAEJ;IAmCA,SAASG,eACPpa,SACA6Z,cACAC,kBACAC,aACAC,iBACAC,cACAI;MAEA,OAAO;QACLn4B,IAAI8d,QAAO9d;QACXgc,GAAGoc,UACDta,QAAO9B,GACP8B,QAAOyO,IACPoL,cACAC,mBACA,CAACl4B,KAAKiL,OAAO0tB,YAAY7E;UArH/B;UAsHQ,MAAMnuB,SAA6B;YACjCizB,KAAK54B;eACD8zB,OAAOnJ,YAAYmJ,MAAM,EAAC,MAAM,eAAS;YAC7C7oB;;UAWF,IAAI4oB;UACJ,IAAIlD;UACJ,IAAIC;UAEJ,MAAMF,KAAI,KAAAoD,QAAA,gBAAAA,KAAMpD,MAAN,mBAASxwB,QAAQwwB;YACzB,IAAI,UAAUjlB,KAAKilB,KAAI;cACrB,MAAMmI,UAAU/rB,SAAS4jB,GAAEtkB,MAAM,IAAI;cACrC,WAAWynB,OAAO,eAAegF,UAAUhF,IACzCA,KAAKgF;cAEP,OAAO;AACT;YAEA,IAAI,UAAUptB,KAAKilB,KAAI;cACrB,MAAMoI,UAAUhsB,SAAS4jB,GAAEtkB,MAAM,IAAI;cACrC,WAAWukB,OAAO,eAAemI,UAAUnI,IACzCA,KAAKmI;cAEP,OAAO;AACT;YAEA,IAAI,UAAUrtB,KAAKilB,KAAI;cACrB,MAAMqI,UAAUjsB,SAAS4jB,GAAEtkB,MAAM,IAAI;cACrC,WAAWwkB,OAAO,eAAemI,UAAUnI,IACzCA,KAAKmI;cAEP,OAAO;AACT;YAEA,OAAO;AAAI;UAGb,IAAIrI,KAAA,gBAAAA,EAAG7wB,QACL8F,OAAO+qB,IAAIA,eAEJ/qB,OAAO+qB;UAGhB,IAAImD,IACFluB,OAAOkuB,KAAKA;UAGd,WAAWlD,OAAO,UAChBhrB,OAAOgrB,KAAK5xB,OAAOmc,OACjB;YAAE8d,GAAGrI;cACLmD,QAAA,gBAAAA,KAAMnD,MAAK;YAAEQ,KAAK2C,QAAA,gBAAAA,KAAMnD;mBAAO;UAInC,WAAWC,OAAO,UAChBjrB,OAAOirB,KAAK7xB,OAAOmc,OACjB;YAAE8d,GAAGpI;cACLkD,QAAA,gBAAAA,KAAMlD,MAAK;YAAEO,KAAK2C,QAAA,gBAAAA,KAAMlD;mBAAO;UAInC,IAAI+H,YACFhzB,OAAOgzB,aAAaA;UAEtB,OAAOhzB;AAAM;QAGjBqW,GAAG0c,UACDta,QAAOpC,GACPoC,QAAOwO,IACPuL,aACAC,kBACA,CAACp4B,KAAKiL,OAAO0tB,YAAY7E;UAvM/B;UAwMQ,MAAMnuB,SAA4B;YAChCizB,KAAK54B;eACD8zB,OAAOnJ,YAAYmJ,MAAM,EAAC,MAAM,eAAS;YAC7C7oB;;UAGF,IAAI0lB;UACJ,IAAIC;UAEJ,MAAMF,KAAI,KAAAoD,QAAA,gBAAAA,KAAMpD,MAAN,mBAASxwB,QAAQwwB;YACzB,IAAI,UAAUjlB,KAAKilB,KAAI;cACrB,MAAMoI,UAAUhsB,SAAS4jB,GAAEtkB,MAAM,IAAI;cACrC,WAAWukB,OAAO,eAAemI,UAAUnI,IACzCA,KAAKmI;cAEP,OAAO;AACT;YAEA,IAAI,UAAUrtB,KAAKilB,KAAI;cACrB,MAAMqI,UAAUjsB,SAAS4jB,GAAEtkB,MAAM,IAAI;cACrC,WAAWwkB,OAAO,eAAemI,UAAUnI,IACzCA,KAAKmI;cAEP,OAAO;AACT;YAEA,OAAO;AAAI;UAGb,IAAIrI,KAAA,gBAAAA,EAAG7wB,QACL8F,OAAO+qB,IAAIA,eAEJ/qB,OAAO+qB;UAGhB,WAAWC,OAAO,UAChBhrB,OAAOgrB,KAAK5xB,OAAOmc,OACjB;YAAE8d,GAAGrI;cACLmD,QAAA,gBAAAA,KAAMnD,MAAK;YAAEQ,KAAK2C,QAAA,gBAAAA,KAAMnD;mBAAO;UAInC,WAAWC,OAAO,UAChBjrB,OAAOirB,KAAK7xB,OAAOmc,OACjB;YAAE8d,GAAGpI;cACLkD,QAAA,gBAAAA,KAAMlD,MAAK;YAAEO,KAAK2C,QAAA,gBAAAA,KAAMlD;mBAAO;UAInC,IAAI+H,YACFhzB,OAAOgzB,aAAaA;UAEtB,OAAOhzB;AAAM;QAGjB6W,GAAGyc,aAAa7a,QAAO5B,GAAG6b,cAAcI;;AAE5C;IAEA,SAASF,iBACPna,SACA/J,QACA2jB;MAtQF;MAkTE,MAAMkB,UAAqCxM;QACzC,QAAQsL;SACN,KAAK;UACH,OAAOtL,QAAQrY;;SACjB,KAAK;UACH,OAAOoQ,eAAeiI,SAASrY;;SACjC,KAAK;UACH,OAAOqY,IAAIvb,WAAWkD;;SACxB,KAAK;UACH,OAAOoQ,eAAeiI,KAAKvb,WAAWkD;;SACxC,KAAK;UACH,OAAO,KAAIqY,MAAKjjB,SAAS4K;;AAC7B;MAEF,IAAI4jB,eAAekB,gBAAgB/a,QAAO9B,KAAK,IAAI4c;MAGnD,MAAMhB,mBAAgD;MACtD,IAAIkB,0BAA0B;MAC9B,SAASr5B,IAAI,GAAGA,OAAK,KAAAqe,QAAO9B,MAAP,mBAAUzc,WAAU,IAAIE,KAC3C,IAAIk4B,eAAgB,KAAKl4B,GAAI;QAC3B,QAAQi4B;SACN,KAAK;SACL,KAAK;SACL,KAAK;SACL,KAAK;UACHE,iBAAiB1xB,KAAK,EAACzG,GAAG,GAAGsU,OAAOxU;UACpC;;SAEF,KAAK;UACH;YACE,MAAMgT,QAAQ,KAAIuL,QAAO9B,EAAGvc,KAAIiM,QAAQqI;YACxC6jB,iBAAiB1xB,KAAK,EAACzG,GAAG8S,OAAOA,QAAQ;AAC3C;UACA;;QAEJumB,4BAAAA,8BAA8B,iBAAAhb,QAAOyO,OAAP,mBAAY9sB,OAAZ,mBAAgBA,MAAhB,mBAAmB0J,SAAS;AAC5D;MAGF,IAAI0uB,cAAc;MAClB,IAAIE,eAAe;MACnB,MAAMD,kBAA+C;MACrD,IAAIH,cAAc;QAEhBE,cAAckB,oBAAoBjb,SAAQ6Z;QAC1CI,eAAec,gBAAgB/a,QAAO5B,IAAIyU;UACxC,IAAImI,yBACF,OAAO;UAGT,WAAWnI,MAAMO,SAAS,aACxB,UAAUP,MAAMO,OAAOyG,oBAClB,WAAWhH,MAAMQ,SAAS,aAC/B,UAAUR,MAAMQ,OAAO0G,mBAEvB,OAAO;AACT;AAEJ,aAAO,IACLH,cAAc,YACdA,cAAc,qBACdA,cAAc,iBACdA,cAAc,+BACd;QAEAG,cAAcgB,gBAAgB/a,QAAOpC,GAAGkd;QACxCjB,eAAeqB,oBAAoBlb,SAAQ+Z;QAG3C,SAASp4B,IAAI,GAAGA,IAAIqe,QAAOpC,EAAEnc,QAAQE,KACnC,IAAIo4B,cAAe,KAAKp4B,GAAI;UAC1Bq4B,gBAAgB5xB,KAAK,EAACzG,GAAG,GAAGsU,OAAOxU;UACnCu5B,4BAAAA,8BAA8B,iBAAAhb,QAAOwO,OAAP,mBAAY7sB,OAAZ,mBAAgBA,MAAhB,mBAAmB0J,SAAS;AAC5D;QAGF4uB,eAAec,gBAAgB/a,QAAO5B,IAAIyU;UACxC,IAAImI,yBACF,OAAO;UAGT,WAAWnI,MAAMQ,SAAS,aACxB,UAAUR,MAAMQ,OAAO0G,mBAClB,WAAWlH,MAAMO,SAAS,aAC/B,UAAUP,MAAMO,OAAOyG,oBAEvB,OAAO;AACT;AAEJ;MAEA,OAAO,EACLA,cACAC,kBACAC,aACAC,iBACAC;AAEJ;IAEA,SAASC,kCACPla,SACAyT,MACAmG;MA1ZF;MAkaE,IAAIC,eAAe;MACnB,IAAIC,mBAAgD;MACpD,IAAIC,cAAc;MAClB,IAAIC,kBAA+C;MACnD,IAAIC,eAAe;MAEnB,MAAMkB,QAAS1H,KAAavV;MAC5B,MAAMkd,QAAS3H,KAAa7V;MAE5B,IAAIud,SAASC,OAAO;QAElBvB,eAAekB,gBAAgB/a,QAAO9B,KAAK,KAAKA,KAAMA,MAAMid;QAC5D,SAASx5B,IAAI,GAAGA,OAAK,KAAAqe,QAAO9B,MAAP,mBAAUzc,WAAU,IAAIE,KAC3C,IAAIk4B,eAAgB,KAAKl4B,GACvBm4B,iBAAiB1xB,KAAK,EAACzG,GAAG,GAAGw5B,MAAM15B;QAKvCs4B,cAAcgB,gBAAgB/a,QAAOpC,IAAIA,KAAMA,MAAMwd;QACrD,SAASz5B,IAAI,GAAGA,IAAIqe,QAAOpC,EAAEnc,QAAQE,KACnC,IAAIo4B,cAAe,KAAKp4B,GACtBq4B,gBAAgB5xB,KAAK,EAACzG,GAAG,GAAGy5B,MAAM35B;QAMtCw4B,eAAec,gBAAgB/a,QAAO5B,IAAIyU;UACxC,WAAWA,MAAMO,SAAS,aACxB,UAAUP,MAAMO,OAAOyG,oBAClB,WAAWhH,MAAMQ,SAAS,aAC/B,UAAUR,MAAMQ,OAAO0G,mBAEvB,OAAO;AACT;AAEJ,cAEIF,cACAC,kBACAC,aACAC,iBACAC,gBACEE,iBAAiBna,SAASmb,SAASC,OAASxB;MAGlD,IAAInG,KAAKZ,OACPoH,eAAe,KAAMxG,KAAKZ,QAAQ;MAGpC,OAAO,EACLgH,cACAC,kBACAC,aACAC,iBACAC;AAEJ;IA4CA,SAASgB,oBACPjb,SACA6Z;MAEA,MAAMwB,cAAe7M,OAClBA,aAAaA,GAAG5X,QAAQ,kBAAkB4X,GAAG5X,MAAMijB;MAEtD,OAAOkB;;;MAGLO,gBAAgBtb,QAAOwO,MAAM,IAAIxO,QAAOpC,EAAEnc,SAC1C45B;AAEJ;IAEA,SAASC,gBACPC,KACAC;MAEA,MAAMC,QAAQ7vB,KAAK8vB,IAAIF,MAAMD,IAAI95B,QAAQ;MACzC,OAAO85B,IAAIjuB,OAAOpM,MAAMu6B,OAAOzT,KAAK;AACtC;IAEA,SAASkT,oBACPlb,SACA+Z;MAEA,MAAM4B,iBAAiB,MAAM3b,QAAO9B,KAAK,IAAIzc,UAAU;MACvD,MAAMm6B,uBAAwBj6B;QApiBhC;QAqiBI,KAAKqe,QAAOwO,MAAMxO,QAAOwO,GAAG/sB,SAASE,IAAI,KAAKqe,QAAOwO,GAAG7sB,OAAO,MAC7D,OAAOg6B;QAGT,QAAO,KAAA3b,QAAOwO,GAAG7sB,GAAIiV,QAAd,YAAqB+kB;AAAa;MAG3C,IAAIttB,UAAU;MACd,SAAS1M,IAAI,GAAGA,IAAIqe,QAAOpC,EAAEnc,QAAQE,KACnC0M,WAAW0rB,cAAe,KAAKp4B,IAAKi6B,qBAAqBj6B,KAAK;MAEhE,OAAO0M;AACT;IAEA,SAAS0sB,gBAAmBQ,KAAeluB;MACzC,OAAOkuB,IAAIvuB,QACT,CAAC7J,OAAO0Q,MAAMlS,MAAO0L,KAAKwG,QAAQ1Q,QAAS,KAAKxB,IAAKwB,QACrD;AAEJ;IAEA,SAASm3B,UACPz4B,MACAg6B,WACAxtB,SACAytB,aACAC;MA/jBF;MAskBE,MAAMx0B,SAA4B;MAElC,YAAY5F,GAAGC,SAASC,QAAQ,IAAIyX,WAAW;QAC7C,MAAMzM,WAAWwB,UAAW,KAAK1M;QACjC,MAAM+zB,OACJmG,aAAaA,UAAUp6B,UAAUE,IAAI,KAAKk6B,UAAUl6B,OAAO,OACvDk6B,UAAUl6B,UACV;QACN,MAAM44B,cAAa,KAAAuB,YAAY3f,MAAMrQ,QAASA,KAAK,OAAOnK,QAAvC,mBAA2CqM,MAAM;QAGpEzG,OAAOa,KAAK2zB,MAAMn6B,KAAKiL,OAAO0tB,YAAY7E;AAC5C;MAEA,OAAOnuB;AACT;IAEA,SAASszB,aACPmB,QACA/B,cACAI;MAEA,MAAM4B,oBAAqBt6B,KACzB04B,mBACGv4B,QAAO,EAAEo6B,gBAAgBA,eAAev6B,IACxCgM,KAAI,EAAE,EAAEwuB,OAAO3hB,OAAO4hB,SAAS,EAACD,OAAO3hB,OAAO4hB;MAEnD,OAAOJ,OAAOruB,KAAI,CAACklB,OAAOlxB,OAAM;QAC9BuxB,GAAGmJ,cAAcxJ,OAAOoJ,kBAAkBt6B;WACvC4qB,YAAYsG,OAAO,EAAC,KAAK;QAC5BhmB,UAAUotB,eAAgB,KAAKt4B;;AAEnC;IAIA,SAAS06B,cACPxJ,OACAyJ;MAGA,MAAMnJ,KAAKN,MAAMM,MAAM;MACvB,MAAMoJ,YAAY,KAAK/C,uBAAuB;MAC9C,MAAMgD,mBAAoB76B,KACjB23B,WAAYnG,MAAOxxB,IAAI63B,sBAAwB+C;MAGxD,OAAO1J,MAAMK,EAAEvlB,KAAI,CAACwuB,OAAOx6B;QAIzB,MAAM4F,SAAgB;UAAE+mB,KAAK6N;;QAE7B,MAAMtsB,QAAO2sB,iBAAiB76B;QAC9B,IAAIkO,UAAS,QACXtI,OAAOsI,OAAOA;QAGhB,IAAI4sB;QACJ,OAAOH,cAAc76B,UAAU66B,cAAc,GAAG,MAAM36B,GACpD86B,QAAQH,cAAc1X;QAExB,IAAI6X,OACFl1B,OAAOgzB,aAAakC,MAAMzuB,MAAM;QAGlC,OAAOzG;AAAM;AAEjB;;QCtoBO,SAASm1B,gBACdC,UACA,gBAA8C,CAAC;MAE/C,MAAMC,YAGF,IAAIvjB;MAER,WAAW9R,UAAUo1B,SAAS;QAE5B,MAAME,mBACJt1B,OAAO2W,EAAE/B,MAAM+B,KAAMA,EAAEqc,gBAAehzB,OAAOqW,EAAEzB,MAAMyB,KAAMA,EAAE2c;QAC/D,MAAMuC,cACJC,gBAAgBF,mBACZA,iBAAiBrC,IAAI/4B,SAASs7B,oBAC9B;QAQN,MAAMC,cAAcz1B,OAAOqW,EAAEzB,MAAMyB,OAAQA,EAAE2c;QAC7C,MAAM0C,KAAKD,cAAcE,oBAAoBF,aAAaz1B,UAAU;QAGpE,MAAM41B,WAAWC,YAAY71B;QAE7Bq1B,SAAS35B,IAAIsE,OAAOrF,IAAI;UAAE46B;UAAaK;UAAUttB,MAAMotB;;AACzD;MAEAN,QAAQj7B,MAAK,CAACZ,GAAGC;QACf,MAAMs8B,QAAQT,SAAS75B,IAAIjC,EAAEoB;QAC7B,MAAMo7B,QAAQV,SAAS75B,IAAIhC,EAAEmB;QAE7B,IACEm7B,MAAMP,qBAAgB,KACtBQ,MAAMR,qBAAgB,KACtBO,MAAMP,gBAAgBQ,MAAMR,aAE5B,OAAOO,MAAMP,cAAcQ,MAAMR;QAGnC,IAAIO,MAAMxtB,SAASytB,MAAMztB,MACvB,OAAOwtB,MAAMxtB,OAAOytB,MAAMztB;QAG5B,OAAOytB,MAAMH,WAAWE,MAAMF;AAAQ;MAGxC,OAAOR;AACT;IAEA,SAASO,oBAAoBtf,GAAsBrW;MA3DnD;MA+DE,MAAMg2B,qBACJ,KAAA3f,EAAEjc,MAAF,mBAAK0J,SAAS,YACd,KAAAuS,EAAEjc,MAAF,mBAAK0J,SAAS,YACd,KAAAuS,EAAEjc,MAAF,mBAAK0J,SAAS,YACd,KAAAuS,EAAEjc,MAAF,mBAAK0J,SAAS;MAEhB,IAAIkyB,kBACF,OAAO;MAQT,KACGh2B,OAAO2W,EAAEzc,UACV8F,OAAO2W,EAAEsf,OACNtf;QAjFP,IAAAuf,KAAAC,KAAAC;QAiFa,SAAAF,MAAAvf,EAAEvc,MAAF,gBAAA87B,IAAKpyB,SAAS,YAASqyB,MAAAxf,EAAEvc,MAAF,gBAAA+7B,IAAKryB,SAAS,YAASsyB,MAAAzf,EAAEvc,MAAF,gBAAAg8B,IAAKtyB,SAAS;AAAA,WAGrE,OAAO;MAaT,IAAIuyB,yBAAyBr2B,OAAO6W,IAClC,OAAO;MAIT,OAAOR,EAAEhH,QAAQ,IAAI,IAAI;AAC3B;IAEA,SAASgnB,yBAAyB5B;MAChC,MAAM6B,kBAAkB7B,OAAOl6B,QAC5Bsc,MAAMA,GAAEvR,UAAUuR,GAAE0L,cAAS,KAAa1L,GAAE0L,SAAS;MAExD,IAAI+T,gBAAgBp8B,WAAW,GAC7B,OAAO;MAGT,MAAMq8B,iBAAiBD,gBAAgB/7B,QAAQsc;QAjHjD;QAkHI,aAAAA,GAAEkV,SAAF,mBAAQjoB,SAAS;AAAA,UACjB5J;MACF,OAAOq8B,kBAAkBD,gBAAgBp8B,SAAS;AACpD;IAEO,SAAS27B,YAAY71B;MAG1B,MAAMw2B,SAAwB,EAAC;MAC/B,MAAMC,mBACJz2B,OAAO2W,EAAE8C,MAAM9C,OAAQA,EAAEqc,gBACzBhzB,OAAOqW,EAAEoD,MAAMpD,OAAQA,EAAE2c;MAG3B,WAAWrc,KAAK3W,OAAO2W,GAAG;QACxB,KAAK8f,oBAAoB9f,EAAEqc,cAAcrc,EAAErR,WAAWqR,EAAEoU,GACtD;QAGFyL,OAAO31B,KAAK61B,eAAe/f,EAAEoU;AAC/B;MAGA,WAAW1U,KAAKrW,OAAOqW,GAAG;QACxB,KAAKogB,oBAAoBpgB,EAAE2c,cAAc3c,EAAE/Q,WAAW+Q,EAAE0U,GACtD;QAGFyL,OAAO31B,KAAK61B,eAAergB,EAAE0U;AAC/B;MAGA,OAAO1mB,KAAK8vB,OAAOqC;AACrB;IAaA,SAASE,eAAeC;MACtB,MAAMH,SAASG,WAAWvwB,IAAIwwB,kBAAkBz8B,OAAO08B;MACvD,OAAOL,OAAOt8B,SACVs8B,OAAO,KACLA,OACG/vB,MAAM,GACNhB,QACC,CAACqxB,OAAOC,OAAO7pB,UAAU4pB,QAAQC,QAAQ1yB,KAAK2yB,IAAI,IAAI9pB,QAAQ,KAC9D,KAEN;AACN;IAOA,IAAM+pB,wBAA4C,IAAInlB,IAAI,EACxD,EAAC,MAAM;;IACP,EAAC,MAAM,MACP,EAAC,MAAM;;IACP,EAAC,MAAM;;IACP,EAAC,MAAM;;IACP,EAAC,MAAM;;IACP,EAAC,MAAM;;IACP,EAAC,MAAM;IAGF,SAAS8kB,iBAAiB7L;MAC/B,IAAIkM,qBAAqBx7B,IAAIsvB,IAC3B,OAAOkM,qBAAqBz7B,IAAIuvB;MAGlC,IAAIA,EAAEvf,WAAW,OAAO;QAItB,MAAM0rB,WAAW/vB,SAAS4jB,EAAExY,UAAU,IAAI;QAC1C,IAAI2kB,WAAW,KAAKA,WAAW,IAC7B,OAAO,KAAKA,WAAW;AAE3B;MAEA,OAAO;AACT;;QClKA,IAAIC,SAAsC;IAC1C,IAAIC;IACJ,IAAIC;IAEJ,SAAS;MACP,IAAIF,WAAW,QACb,OAAOp6B,QAAQT,QAAQ86B;MAGzB,IAAID,WAAW,WACb,OAAOE;MAGTF,SAAS;MAETE,eAAexb,OAAqB,UAAU,GAAG;QAC/C,OAAAI,CACEmb,MACAE,aACA7O,aACArM;UAQAA,YAAYuF;AACd;QACA,OAAAtF;UACEnf,QAAQ2M,IAAI;AACd;QACA,QAAA2S;UACE,IAAI4a,KAAK;YACPA,IAAIlO;YACJkO,WAAM;YACND,SAAS;AACX;AACF;QACA,UAAA5a;UACE6a,WAAM;UACND,SAAS;AACX;SAECt7B,MAAMygB;QACL8a,MAAM9a;QACN6a,SAAS;QACT,OAAO7a;AAAE,UAEV/b,OAAM;QACL42B,SAAS;QACTC,WAAM;QACN,OAAO;AAAI,UAEZ5F,SAAQ;QACP6F,oBAAe;AAAA;MAGnB,OAAOA;AACT;IAUA,eAAsB,cACpB3oB,QACApL;MAnHF;MAqHE,MAAMgZ,WAAW;MACjB,KAAKA,IACH,OAAO;MAIT,MAAMib,aAAY,KAAAj0B,WAAA,gBAAAA,QAASi0B,cAAT,YAAsB;MACxC,MAAMnzB,SAAQ,KAAAd,WAAA,gBAAAA,QAASc,UAAT,YAAkBR;MAGhC,MAAM4zB,SAAS9oB,OAAO+oB;MAGtB,MAAMC,gBAA4B,IAAI1lB;MACtC,MAAMojB,UAA6B;MAEnC,MAAMuC,iBAAiB,CACrBlf,SACAmf,MACAC,eAA4C;QAE5C,IAAIH,aAAaj8B,IAAIgd,QAAO9d,KAC1B;QAGF,IAAI03B;QACJ,IAAIkF,cAAc,SAChBlF,YAAYwF,iBAAiB,UAAU,WAAW,wBAElDxF,YACEwF,iBAAiB,UACb,gBACA;QAERzC,QAAQv0B,KAAKuxB,aAAa3Z,SAAQmf,MAAMvF;QACxCqF,aAAanjB,IAAIkE,QAAO9d;AAAG;MAI7B,MAAMm9B,aAAaxb,GAAIF,YAAY,SAASgB,MAAMlQ,MAAM;MAIxD,MAAM7S,MACJk9B,cAAc,UACVQ,YAAYC,KAAKR,UACjBO,YAAYE,MAAMT,QAAQA,SAAS;MACzC,iBAAiBzZ,UAAU+Z,WAAWha,QAAQzjB,MAC5Cs9B,eAAe5Z,OAAOniB,OAAO47B;MAI/B,MAAMU,eAAe5b,GAAIF,YAAY,SAASgB,MAAMlQ,MAAM;MAC1D,iBAAiB6Q,UAAUma,aAAapa,QAAQzjB,MAC9Cs9B,eAAe5Z,OAAOniB,OAAO47B;MAI/B;QACE,MAAMW,gBAAgB7b,GAAIF,YAAY,SAASgB,MAAMlQ,MAAM;QAC3D,MAAMkrB,WAAWtZ,eAAe0Y;QAChC,MAAMa,cACJd,cAAc,UACVQ,YAAYC,KAAKI,YACjBL,YAAYE,MAAMG,UAAUA,WAAW;QAC7C,iBAAiBra,UAAUoa,cAAcra,QAAQua,cAC/CV,eAAe5Z,OAAOniB,OAAOw8B,UAAU;AAE3C;MAUA,IAAIE;MACJ,IAAIf,cAAc,SAChBe,eAAenD,gBAAgBC,eAE/BkD,eAAenD,gBAAgBC,SAAS;QAAEI,cAAcgC,OAAOt9B;;MAGjE,IAAIkK,OACFk0B,aAAahlB,OAAOlP;MAGtB,OAAOk0B;AACT;IAmSA,eAAsBC,UAAS,OACxB,MACD,oBACgBr7B,QAAQ2M;MAM5B,MAAM2uB,MAAMnQ,MAAMjiB,KAAKiiB,UAAUA,OAAMrJ,YAAY;MACnD,MAAMyZ,qBAA8CC,aAAaF;MAEjE,MAAMG,uBAAuBC,mBAAmB;QAC9CH;QACAlW;QACAsW;;MAEF,IAAIJ,aAAav+B,WAAWy+B,eAAez+B,QACzC,MAAM,IAAIJ,MACR,0CAA0C2+B,aAAav+B,8BAA8By+B,eAAez+B;MAIxG,MAAM4+B,yBAAyBC,sBAAsB;QACnDN;QACAlW;QACAsW;;MAEF,IAAIJ,aAAav+B,WAAW4+B,iBAAiB5+B,QAC3C,MAAM,IAAIJ,MACR,0CAA0C2+B,aAAav+B,gCAAgC4+B,iBAAiB5+B;MAI5G,MAAM8+B,uBAAuBC,gBAAgBR,cAAclW;MAC3D,IAAIkW,aAAav+B,WAAW8+B,eAAe9+B,QACzC,MAAM,IAAIJ,MACR,0CAA0C2+B,aAAav+B,oCAAoC8+B,eAAe9+B;MAK9G,OAAOu+B,aAAaryB,KAAiB,CAACqS,SAAQre,MAC5C4qB,YACE;WACKvM;QACHiB,GAAGxV,OAAO+a,cAAcxG,QAAOiB;QAC/B6U,QAAQ9V,QAAO8V,UAAUhM;QACzBiM,KAAKmK,eAAev+B;QACpBu0B,MAAMmK,iBAAiB1+B;QACvBwyB,IAAIoM,eAAe5+B;SAErB,EAAC;AAGP;IAEA8iB,eAAewb,aACbF;MAEA,MAAMlc,WAAW;MACjB,KAAKA,IACH,OAAO;MAGT,MAAMmc,eAAwC;MAC9C;QACE,MAAMzd,KAAKsB,GAAIF,YAAY;QAC3B,WAAW1C,KAAK8e,KAAK;UACnB,MAAM/f,gBAAeuC,GAAGoC,MAAM5hB,IAAIke;UAClC,IAAIjB,SACFggB,aAAa53B,KAAK4X;AAEtB;AACF;MAEA,OAAOggB;AACT;IAEAvb,eAAe0b,oBAAmB,cACpB,MACR;MAOJ,MAAMtQ,iBAAiB4Q;MAEvB,OAAOT,aAAaryB,KAAKqS;QACvB,MAAM0gB,YAAYC,oBAAoB3gB;QACtC,MAAM4gB,SAASC,gBAAgB7gB,QAAO+V,IAAI/Y;QAE1C,MAAM8jB,iBAAiBjR,SAAS9sB,IAAI29B,aAAaE;QACjD,IAAI7K;QACJ,IAAI+K,gBAAgB;UAClB/K,MAAM;YACJ/Y,GAAGgD,QAAO+V,IAAI/Y;YACdjc,GAAG+/B,eAAe//B;YAClBmd,GAAG4iB,eAAe5iB;YAClB2W,IAAIiM,eAAejM;YACnBgB,GAAGiL,eAAejL;YAClBC,QAAQgL,eAAehL,UAAUhM;;UAEnC,IAAI9J,QAAO+V,IAAIf,QACbe,IAAIf,SAAShV,QAAO+V,IAAIf;AAE5B,eAAO;UAILoL,kBAAkB,2BAA2BM,aAAaE;UAC1D7K,MAAM;eACD/V,QAAO+V;;;;YAIVh1B,GAAG;YACH8zB,IAAI,EAAC;YACLgB,GAAG,EAAC;YACJC,QAAQhM;;AAEZ;QAGA,IAAI4W,WAAW;UACb,MAAMK,cAAclR,SAAS9sB,IAAI69B;UACjC,IAAIG,aAAa;YACf,OAAM,GAAG,GAAG,IAAI,GAAG,UAAaA;YAChChL,IAAI7P,OAAO;cAAEnlB;cAAGmd;cAAG2W;cAAIgB;cAAGC,QAAQA,UAAUhM;;AAC9C;AACF;QAEA,OAAOiM;AAAG;AAEd;IAEA,SAAS8K,gBAAgB3+B;MACvB,OAAOA,GAAGiK,WAAW60B,SAAS,GAAG;AACnC;IAIA,SAASC,cAAcjhB;MACrB,MAAMkhB,WAAmD;MAEzD,IAAIlhB,QAAOiV,KACT,WAAWyL,aAAa1gB,QAAOiV,KAAK;QAClC,MAAM5mB,UAAUqyB,UAAU7zB,MAAM;QAChC,IAAIwB,SAAS;UACX,OAAO,EAAE0Z,WAAW1Z;UACpB6yB,SAAS94B,KAAK;YACZ2f,SAASrZ,SAASqZ,SAAS;YAC3B7lB,IAAIw+B;;AAER;AACF;MAGF,OAAOQ;AACT;IAEA,SAASC,qBACPpZ,SACAmZ;MAIA,MAAME,eAAeF,SAASG,WAC3BvgC,KAAMA,EAAEinB,YAAYA,WAAYA,YAAY,MAAMjnB,EAAEoB,OAAO;MAG9D,IAAIk/B,kBAAkB,GACpB;MAGF,MAAMl/B,KAAKg/B,SAASE,cAAcl/B;MAClCg/B,SAASrmB,OAAOumB,cAAc;MAE9B,OAAOl/B;AACT;IAEA,SAASy+B,oBAAoB3gB;MAC3B,MAAMkhB,WAAWD,cAAcjhB;MAC/B,MAAMshB,UAAUJ,SAAS/kB,MAAMrb,KAAMA,EAAEinB,YAAY/H,QAAO+V,IAAI/Y;MAC9D,OAAOskB,WAAA,gBAAAA,QAASp/B;AAClB;IAaA,IAAMq/B,kBAA2C,EAC/C,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,SACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,SACN,EAAC,UAAK,QACN,EAAC,UAAK,SACN,EAAC,UAAK,SACN,EAAC,UAAK,SACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,OACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK;IAGR9c,eAAe6b,uBAAsB,cACvB,MACR;MAQJ,MAAMkB,aAAaxB,aAAahzB,QAC9B,CAACw0B,aAAYxhB,YACXwhB,YAAWl0B,OAAO0S,QAAOkW,OAAO,KAAIlW,QAAOkW,SAAQ,MACrD;MAIF,MAAMuL,mBAAmBC;MACzB,MAAMC,iBAAgB,IAAIpoB;MAC1B,WAAW0H,KAAKugB,YACd,IAAIvgB,MAAMwgB,WAAWz+B,IAAIie,IACvB0gB,cAAc7lB,IAAImF,EAAEsF,YAAY;MAKpC,IAAIqb,YAA0C,IAAIvoB;MAClD,IAAIsoB,cAAcnhB,MAAM;QACtB,MAAMwf,sBAAqBC,aAAa,KAAI0B;QAC5CC,WAAW,IAAIvoB,IACb2mB,cAAaryB,KAAKqS,WAAW,EAACvU,OAAO+a,cAAcxG,QAAOiB,IAAIjB;AAElE;MAGA,MAAM6P,iBAAiB4Q;MACvB,MAAMl5B,SAAqC;MAC3C,WAAWyY,WAAUggB,cAAc;QACjC,MAAM9J,OAA4B;QAClC,MAAMgL,WAAWD,cAAcjhB;QAE/B,WAAWiB,KAAKjB,QAAOkW,OAAO,KAAIlW,QAAOkW,SAAQ,IAC/C,IAAIuL,WAAWz+B,IAAIie,IAAI;UACrB,IAAI4gB,gBAAgBhS,SAAS9sB,IAAI0+B,WAAW1+B,IAAIke;UAChD,IAAI4gB,eAAe;YAEjB,MAAMnB,YAAYS,qBAAqBU,cAAejkB,GAAGsjB;YACzD,WAAWR,cAAc,aAAa;cACpC,MAAMoB,iBAAiBjS,SAAS9sB,IAAI29B;cACpC,IAAIoB,gBACFD,gBAAgBC,qBAEhB1B,kBACE,4CAA4CM;AAGlD;YAEA,MAAM5xB,YAAoC;cACxCmS;cACA4T,IAAIgN,cAAchN;cAClBgB,GAAGgM,cAAchM;cACjBC,QAAQ+L,cAAc/L,UAAUhM;;YAElC,MAAMiX,cAAclR,SAAS9sB,IAAI89B,gBAAgBgB,cAAcjkB;YAC/D,IAAImjB,eAAeA,YAAY7iB,GAC7BpP,UAAUoP,IAAI6iB,YAAY7iB;YAG5BgY,KAAK9tB,KAAK0G;AACZ,iBACEsxB,kBAAkB,oCAAoCnf;AAE1D,eAAO,IAAI2gB,SAAS5+B,IAAIie,IAAI;UAC1B,MAAM8gB,cAAcH,SAAS7+B,IAAIke;UACjC,IAAI8gB,aAAa;YACf,IAAIlN,KAAoB;YACxB,IAAIkN,YAAYnkB,EAAEgX,OAAOmN,YAAYnkB,EAAEgX,IAAInzB,QACzCozB,KAAKkN,YAAYnkB,EAAEgX,IAAIjnB,KAAKq0B,WAAYA,QAAQ50B,QAAQ,KAAK,YACxD,IAAI20B,YAAYnkB,EAAE+W,MAAMoN,YAAYnkB,EAAE+W,GAAGlzB,QAC9CozB,KAAKkN,YAAYnkB,EAAE+W;YAGrBuB,KAAK9tB,KAAK;cACR6Y;cACA4T;cACAgB,GAAGkM,YAAYlM;cACfC,QAAQiM,YAAYjM,UAAUhM;;AAElC;AACF,eAAO,IAAI7I,EAAEsF,YAAY,MAAO,SAAUtF,EAAEsF,YAAY,MAAO,OAM7D,IAAIuD,SAAS,MACXoM,KAAK9tB,KAAK;UACR6Y;UACA4T,IAAI,EAAC5T;UACL4U,GAAG,EAAC,2BAAO5U;UACX6U,QAAQhM;iBAEL;UACL,MAAMmY,UAAUV,gBAAgBtgB,EAAEsF,YAAY,KAAM,OAAQ;UAoB5D,KAAK,EAAC,MAAM,MAAM,MAAM,OAAMlb,SAASye,OACrCsW,kBACE,oDAAoDtW;UAGxDoM,KAAK9tB,KAAK;YACR6Y;YACA4T,IAAI,EAAC5T;YACL4U,GAAG,EAAC,YAAYoM;YAChBnM,QAAQhM;;AAEZ,eAEAsW,kBAAkB,8CAA8Cnf;QAIpE1Z,OAAOa,KAAK8tB;AACd;MAEA,OAAO3uB;AACT;IAEAkd,eAAe+b,gBACbR,cACAlW;MAGA,MAAMqK,KAAK6L,aAAahzB,QACtB,CAACmnB,KAAInU,YACHmU,IAAG7mB,OACD0S,QAAOmU,KAAK,KAAInU,QAAOmU,KAAIxmB,KAAKsT,KAAMA,EAAEsF,YAAY,MAAM,MAAK,MAEnE;MAEF,MAAMob,gBAAgB,IAAIpoB,IAAY4a;MAGtC,IAAIyN,YAA0C,IAAIvoB;MAClD,IAAIsoB,cAAcnhB,MAAM;QACtB,MAAMwf,sBAAqBC,aAAa,KAAI0B;QAC5CC,WAAW,IAAIvoB,IACb2mB,cAAaryB,KAAKqS,WAAW,EAACvU,OAAO+a,cAAcxG,QAAOiB,IAAIjB;AAElE;MAGA,MAAMzY,SAAqC;MAC3C,WAAWyY,WAAUggB,cAAc;QACjC,MAAMkC,eAAoC;QAC1C,WAAWC,UAAUniB,QAAOmU,KAAK,KAAInU,QAAOmU,OAAM,IAAI;UACpD,MAAMvE,QAAQgS,SAAS7+B,IAAIo/B;UAC3B,KAAKvS,OACH;UAGF,OAAM,GAAG,GAAG,QAAQ,QAAWA;UAC/BsS,aAAa95B,KAAK;YAAE6Y,GAAGkhB;YAAQvkB;YAAGiY;YAAGC,QAAQA,UAAUhM;YAAMwJ;;AAC/D;QACA/rB,OAAOa,KAAK85B;AACd;MAEA,OAAO36B;AACT;IAEAkd,eAAegc;MACb,MAAM5c,WAAW;MACjB,KAAKA;MACH,OAAO,IAAIxK;MAGb,OAAOwK,GACJue,OAAO,YACPh/B,MAAMyqB,WAAY,IAAIxU,IAAIwU,QAAQlgB,KAAKqS,WAAW,EAACA,QAAO9d,IAAI8d;AACnE;IAEAyE,eAAeid;MACb,MAAM7R,iBAAiB4Q;MAEvB,IAAIM;MACJ,MAAMsB,WAA+B,IAAIhpB;MAEzC,WAAW0O,WAAW8H,SAASrW,UAC7B,IAAIuO,QAAQ7lB,GAAG0L,QAAQ,UAAU,GAAG;QAClCmzB,cAAchZ;QACd,IAAIA,QAAQhnB,GACVshC,QAAQp/B,IAAI8kB,QAAQhnB,GAAGgnB,QAAQ7lB;QAEjC,IAAI6lB,QAAQ7J,GACVmkB,QAAQp/B,IAAI8kB,QAAQ7J,GAAG6J,QAAQ7lB;AAEnC,aAAO;QACL,KAAK6+B,aACH,MAAM,IAAI1/B,MAAM;QAElB,IAAI0mB,QAAQnK,MAAMmjB,YAAYnjB,GAC5B,MAAM,IAAIvc,MAAM;QAQlB,IAAI0mB,QAAQ7lB,OAAO,SACjB;QAEF,IAAI6lB,QAAQhnB,KAAKgnB,QAAQhnB,MAAMggC,YAAYhgC,GACzCshC,QAAQp/B,IAAI8kB,QAAQhnB,GAAGgnB,QAAQ7lB;QAEjC,IAAI6lB,QAAQ7J,KAAK6J,QAAQ7J,MAAM6iB,YAAY7iB,GACzCmkB,QAAQp/B,IAAI8kB,QAAQ7J,GAAG6J,QAAQ7lB;AAEnC;MAGF,OAAOmgC;AACT;IAQA,eAAsBC,SAASrsB;MAC7B,MAAM4N,WAAW;MACjB,KAAKA,IACH,OAAO;MAIT,MAAMkb,SAAS9oB,OAAO+oB;MAGtB,MAAMC,gBAA4B,IAAI1lB;MACtC,MAAMhS,SAA4B;MAElC,MAAM23B,iBAAkBlf;QACtB,KAAKif,aAAaj8B,IAAIgd,QAAO9d,KAAK;UAChCqF,OAAOa,KAAKmkB,YAAYvM,SAAQ,EAAC;UACjCif,aAAanjB,IAAIkE,QAAO9d;AAC1B;AAAA;MAIF,MAAMm9B,aAAaxb,GAAIF,YAAY,SAASgB,MAAMlQ,MAAM;MAIxD,iBAAiB6Q,UAAU+Z,WAAWha,QAAQia,YAAYC,KAAKR,UAC7DG,eAAe5Z,OAAOniB;MAIxB,MAAMs8B,eAAe5b,GAAIF,YAAY,SAASgB,MAAMlQ,MAAM;MAC1D,iBAAiB6Q,UAAUma,aAAapa,QAAQia,YAAYC,KAAKR,UAC/DG,eAAe5Z,OAAOniB;MAIxB,MAAMu8B,gBAAgB7b,GAAIF,YAAY,SAASgB,MAAMlQ,MAAM;MAC3D,MAAMkrB,WAAWtZ,eAAe0Y;MAChC,iBAAiBzZ,UAAUoa,cAAcra,QACvCia,YAAYC,KAAKI,YAEjBT,eAAe5Z,OAAOniB;MAGxB,OAAOoE;AACT;;QC7iCO,SAASg7B,oBAAmB,OAC5B,WACI;MAOT,OAAO;QACLt+B,MAAM2D,MAAM3D;QACZN,SAASiE,MAAMjE;QACf8kB,MAAM7gB,iBAAiB4gB,gBAAgB5gB,MAAM6gB,YAAO;QACpD/V,KAAK9K,iBAAiB4gB,gBAAgB5gB,MAAM8K,WAAM;QAClD8vB;QACAC;;AAEJ;;QCdO,IAAIC;IAIJ,IAAIC;IAEX,WACS7yB,SAAS,mBACTA,KAAK4yB,wBAAwB,qBAC7B5yB,KAAK6yB,uBAAuB,YACnC;MACAD,sBAAuB5yB,KAAa4yB;MACpCC,qBAAsB7yB,KAAa6yB;AACrC,WAAO;MACLD,sBAAsB,CACpBnnB,UACA1Q;QAIA,MAAMye,UAAUze,UAAUA,QAAQye,UAAU,IAAI;QAChD,OAAOxZ,KAAKyZ,YAAW;UACrBhO,SAAS;YAAEqnB,eAAe,MAAM;YAAGxZ,YAAY;;AAAO,YACrDE;AAAQ;MAGbqZ,qBAAsBE;QACpBrZ,aAAaqZ;AAAO;AAExB;;QChDO,SAASC;MACd,QAAS,IAAK32B,cAAc,OAAO,OAAO,OAAO,MAAMiB,QACrD,WACC6T,MAEGhQ,OAAOgQ,KACN8hB,OAAOC,gBAAgB,IAAIC,WAAW,IAAI,KAAM,MAAOhyB,OAAOgQ,KAAK,GACpE9U,SAAS;AAEjB;;QCLA,IAAM+2B,YAAmC,IAAI7pB;IAEtC,SAAS8pB,aAAaC,KAAgBnZ;MAC3C,KAAKiZ,SAASlgC,IAAIogC,MAChBF,SAASjgC,IAAImgC,KAAKN;MAEpB,MAAMlC,SAASsC,SAASngC,IAAIqgC;MAE5B,OAAO,GAAGxC,UAAU3W;AACtB;;QCmCO,SAASoZ,iBAAgB,IAC5B,MACE,QACE,kBACU,eAEhB9Z,YAAAA,cAAazZ,KAAKyZ,YAAU,YAChB;MAUZ+Z,YAAY;QACVzf;QACAiG;QACAG;QACAV,YAAAA;QACAga;QACAC;QACAC;;AAEJ;IAEA,SAASC,WAAU,IACf,MACE,QAEJna,YAAAA,aAAAA,kBACgB;MAWhB,KAAKxZ,UAAU4zB,QAAQ;QACrB,MAAMC,iBAAiBnf;UACrBif,UAAU;YACR7f;YACAiG;YACAG;YACAV,YAAAA;YACAga;YACAC;;AACA;QAGJ3yB,iBAAiB,UAAU+yB,gBAAgB;UAAEC,MAAM;;QACnDC,UAAU;UAAEjgB;UAAIoG;UAAQH;UAAM8Z;;QAC9BJ,iBAAA,gBAAAA,cAAgB;UAAE57B,OAAO,IAAIyxB;;QAC7B;AACF;MAGA0K,cAAc;QAAElgB;QAAIoG;QAAQH;;WAG5B;QACE;gBACQjG,GAAGwN,OAAO;YAAEpH;YAAQH;;UAE1Bka,YAAY;YAAEngB;YAAIoG;;UAElB,IAAIpG,GAAGuV,WACL30B,QAAQ2M,IAAI;UAGdmyB,oBAAA,gBAAAA;AACF,UAAE,OAAO7yB;UACP,IAAImT,GAAGuV,WACL30B,QAAQmD,MAAM,4BAA4B8I;UAG5C,IAAI+xB;UACJ,IAAID;UACJ,IAAIyB,gBAAgB;UAGpB,MAAMC,iBAAiBxzB,aAAa8X;UACpC,IAAI0b,gBAAgB;YAClB,MAAMC,iBAAiBC,mBAAmB;cACxCvgB;cACAiG;cACAG;cACAV,YAAAA;cACAga;cACAC;;YAEF,IAAIW,kBACC3B,WAAWC,cAAe0B;AAEjC,iBAAO,IAAIzzB,KAAKA,aAAarP,SAASqP,EAAEzM,SAAS,mBAAmB;YAClE,MAAMkgC,iBAAiBE,uBAAuB;cAC5CxgB;cACAiG;cACAG;cACAV,YAAAA;cACAga;cACAC;;YAEF,IAAIW,kBACC1B,cAAe0B;YAGpBF,kBAAkBE;AACpB,iBACEH,YAAY;YAAEngB;YAAIoG;;UAGpB,KAAKga,iBAAiBT,eAAe;YACnC,MAAM57B,QAAQ8I,aAAarP,QAAQqP,IAAI,IAAIrP,MAAMoK,OAAOiF;YACxD8yB,cAAc;cAAE57B;cAAO46B;cAAWC;;AACpC;AACF;AACD,QAzDD;AA0DF;IAEA,SAAS6B,kBAAiB,IACtB,QACI;MAQN,IAAI1L,UAAU,WAAW;QACvBoL,YAAY;UAAEngB;UAAIoG;;QAClB;AACF;MAQA,MAAMsa,oBAAqBta,WACzBpG,GAAGoG,SAAQ6N,YAAYjoB,SAAS,cAC/BgU,GAAGoG,SAAQ6N,YAAoC3F,eAAe;MACjE,MAAMqS,sBACJva,WAAW,UACPsa,kBAAkB,YAAYA,kBAAkB,cAChDA,kBAAkBta;MAExB,IAAIua,qBACFC,mBAAmB;QAAE5gB;QAAIoG;;AAE7B;IAEO,SAASya,uBAAsB,IAClC;MAMFV,YAAY;QAAEngB;QAAIoG;;AACpB;IAsCA,IAAMgO,qBAA6C,IAAI5e;IAQvD,SAASiqB,aAAY,IACjB,MACE,QAEJ/Z,YAAAA,aAAAA,kBACgB,eACH;MAYb,MAAMob,YAAYxB,aAAatf,IAAIoG;MACnC,IAAI2a,aAAa3M,kBAAkBl1B,IAAI4hC;MAGvC,IAAIC,cAAcA,WAAW9a,SAASA,MAAM;QAC1C,IAAIjG,GAAGuV,WACL30B,QAAQgtB,KACN;QAGJuS,YAAY;UAAEngB;UAAIoG;;AACpB;MAGA2a,aAAa3M,kBAAkBl1B,IAAI4hC;MACnC,IAAIC,YAAY;QAGd,KAAKnB,WAAW;UACd,IAAI5f,GAAGuV,WACL30B,QAAQgtB,KACN;UAGJ;AACF;QAIA,IAAImT,WAAW/0B,SAAS,WAAW;UACjC,IAAIgU,GAAGuV,WACL30B,QAAQgtB,KAAK;UAEf;AACF;QAIA,IAAImT,WAAW/0B,SAAS,YAAY;UAClC,IAAIgU,GAAGuV,WACL30B,QAAQgtB,KAAK;UAEf;AACF;QAGA,IAAI5N,GAAGuV,WACL30B,QAAQ2M,IAAI;QAEd4yB,YAAY;UAAEngB;UAAIoG;;AACpB;MAKA2a,aAAa3M,kBAAkBl1B,IAAI4hC;MACnC,IAAIC,YAAY;QACd,IAAI/gB,GAAGuV,WACL30B,QAAQ2M,IAAI;QAEd;AACF;MAEAsyB,UAAU;QAAE7f;QAAIiG;QAAMG;QAAQV,YAAAA;QAAYga;QAAkBC;;AAC9D;IAEA,SAASQ,aAAY,IACjB;MAMF,MAAMW,YAAYxB,aAAatf,IAAIoG;MACnC,MAAM2a,aAAa3M,kBAAkBl1B,IAAI4hC;MACzC,KAAKC,YACH;MAGF,QAAQA,WAAW/0B;OACjB,KAAK;QACHsS,oBAAoB,UAAUyiB,WAAWhB;QACzC;;OAEF,KAAK;QACHpa,aAAaob,WAAWC;QACxB;;OAEF,KAAK;QACHlC,mBAAmBiC,WAAWE;QAC9B;;MAGJjhB,GAAG8U,qBAAqBiM,WAAWG;MACnC9M,kBAAkBjc,OAAO2oB;MAEzB9gB,GAAG4U,aAAaxO;AAClB;IAEA,SAAS6Z,WAAU,IACf,MACE,gBACU;MAQd,MAAMa,YAAYxB,aAAatf,IAAIoG;MACnC,MAAM2a,aAAa3M,kBAAkBl1B,IAAI4hC;MACzC,IAAIC,YACFZ,YAAY;QAAEngB;QAAIoG;;MAGpBgO,kBAAkBh1B,IAAI0hC,WAAW;QAC/B90B,MAAM;QACNia;QACA8Z;QACAmB,gBAAgBC,4BAA4B;UAAEnhB;UAAIoG;;;AAEtD;IAEA,SAAS8Z,eAAc,IACnB,MACE;MAOJ,MAAMY,YAAYxB,aAAatf,IAAIoG;MACnC,MAAM2a,aAAa3M,kBAAkBl1B,IAAI4hC;MAEzC1M,kBAAkBh1B,IAAI0hC,WAAW;QAC/B90B,MAAM;QACNia;QACAib,gBAAgBC,4BAA4B;UAAEnhB;UAAIoG;;QAClDwY,YAAYwC,cAAcL;QAC1BM,iBAAiBC,mBAAmBP;;AAExC;IAEA,SAASR,oBAAmB,IACxB,MACE,QAEJ7a,YAAAA,aAAAA,kBACgB;MAUhB,MAAMob,YAAYxB,aAAatf,IAAIoG;MACnC,MAAM2a,aAAa3M,kBAAkBl1B,IAAI4hC;MAIzC,KAAIC,cAAA,gBAAAA,WAAY/0B,UAAS,YACvB;MAGF,IAAIq1B,kBAAkBN,WAAWM;MACjC,IAAIA,iBAEFA,kBAAkBt5B,KAAKC,IAAIq5B,kBAAkB,GAAG,KAAK,KAAK,KAAK,WAG/DA,kBAAkB,MAAOt5B,KAAKw5B,WAAW;MAG3C,IAAI3C,aAAamC,WAAWnC;MAC5BA,oBAAoBA,eAAe,WAAWA,aAAa,IAAI;MAE/D,IAAI5e,GAAGuV,WACL30B,QAAQ2M,IAAI,iCAAiC8zB;MAG/C,MAAML,mBAAmBtb,aAAW;QAClC,IAAI1F,GAAGuV,WACL30B,QAAQ2M,IAAI;QAGdsyB,UAAU;UACR7f;UACAiG;UACAG;UACAV,YAAAA;UACAga;UACAC;;AACA,UACD0B;MAEH,MAAM1C,YAAY,IAAIxhC,KAAKA,KAAKyV,QAAQyuB;MAExCjN,kBAAkBh1B,IAAI0hC,WAAW;QAC/B90B,MAAM;QACNia;QACAib,gBAAgBC,4BAA4B;UAAEnhB;UAAIoG;;QAClDwY;QACAyC;QACAL;;MAGF,OAAO;QAAErC;QAAWC;;AACtB;IAEA,SAASgC,oBAAmB,IACxB;MAMF,MAAME,YAAYxB,aAAatf,IAAIoG;MACnC,MAAM2a,aAAa3M,kBAAkBl1B,IAAI4hC;MAIzC,KAAIC,cAAA,gBAAAA,WAAY/0B,UAAS,eAAe+0B,WAAWM,iBACjD;MAGFjN,kBAAkBh1B,IAAI0hC,WAAW;WAC5BC;QACHM,sBAAiB;QACjBzC,iBAAY;;AAEhB;IAEA,SAAS4B,wBAAuB,IAC5B,MACE,QAEJ9a,YAAAA,aAAAA,kBACgB;MAUhB,MAAMob,YAAYxB,aAAatf,IAAIoG;MACnC,MAAM2a,aAAa3M,kBAAkBl1B,IAAI4hC;MAIzC,KAAIC,cAAA,gBAAAA,WAAY/0B,UAAS,YACvB;MAKF,IAAI4yB,aAAamC,WAAWnC;MAC5B,IAAIA,cAAcA,cAAc,GAC9B;MAGFA,oBAAoBA,eAAe,WAAWA,aAAa,IAAI;MAE/D,IAAI5e,GAAGuV,WACL30B,QAAQ2M,IAAI;MAGd,MAAM0zB,4BAA4BpC,qBAChC;QACE,IAAI7e,GAAGuV,WACL30B,QAAQ2M,IAAI;QAGdsyB,UAAU;UACR7f;UACAiG;UACAG;UACAV,YAAAA;UACAga;UACAC;;AACA,UAEJ;QAAEla,SAAS;;MAGb2O,kBAAkBh1B,IAAI0hC,WAAW;QAC/B90B,MAAM;QACNia;QACAib,gBAAgBC,4BAA4B;UAAEnhB;UAAIoG;;QAClD6a;QACArC;;MAGF,OAAO;QAAEA;;AACX;IAQA,SAASuC,6BAA4B,IACjC;MAMF,MAAML,YAAYxB,aAAatf,IAAIoG;MACnC,MAAM2a,aAAa3M,kBAAkBl1B,IAAI4hC;MACzC,IAAIC,YACF,OAAOA,WAAWG;MAGpB,MAAMA,iBAAkBnM,SACtB0L,iBAAiB;QAAEzgB;QAAIoG;QAAQ2O;;MACjC/U,GAAG6U,kBAAkBqM;MAErB,OAAOA;AACT;IAEA,SAASE,cAAcL;MACrB,QAAOA,cAAA,gBAAAA,WAAY/0B,UAAS,YAAY+0B,cAAA,gBAAAA,WAAYnC,kBAAa;AACnE;IAEA,SAAS0C,mBACPP;MAEA,QAAOA,cAAA,gBAAAA,WAAY/0B,UAAS,0BAC1B+0B,cAAA,gBAAAA,WAAY/0B,UAAS,aACnB+0B,cAAA,gBAAAA,WAAYM,uBACZ;AACN;;;;;ICxmBA,MAAMG,oBAAoBjnB,UAAO;MAC/BzD,WAAWyD,SAAMA,WAAa;MAC9BknB,OAAOlnB,OAASA,UAAYA;MAC5BmnB,SAASnnB,SAAMA,WAAa;;IAKvBqG,eAAe+gB,eACpBC;MAEA,IAAIA,UACFtjC,2BAAAA,QAAAA,UAAAA,YAAsCujC,yBAAyBD;MAGjE;QACE,MAAME,gBAAgBxjC,2BAAAA,QAAAA,MAAAA,IAA0B,QAAQyjC;QACxD,KAAKD,QACH;QAEF,OAAO/9B,OAAOi+B,aAAaznB,SAAWunB,QAAQN;QAE9C,IAAIQ,WACF,OAAOA,qBAEFxpB,QAAQnS,OAAOtC,OAAO;UAAE6J,UAAU;;AAE3C,QAAE;QACAhN,QAAQC,KAAK;AACf;MAEA;AACF;IAEA,SAASghC,yBAAyBI;MAChC,OAAO,CACLC,SACAC;QAEA,IAAIA,aAAa,SACf;QAGF,IAAI,QAAQD,SAAS;UACnB,OAAOn+B,OAAOi+B,aAAaznB,SACzB2nB,QAAQH,GAAGziB,UACXkiB;UAGF,IAAIQ,WACFC,SAASD,sBAEJxpB,QAAQnS,OAAOtC,OAAO;YAAE6J,UAAU;;AAE3C;AAAA;AAEJ;;IC5DO,SAASlF,mBAASzL;MACvB,cAAcA,MAAM,YAAYA,MAAM,SAASI,MAAMC,QAAQL;AAC/D;;;;;ICCO,SAASyrB,yBACdC,GACAC;MAEA,MAAMllB,SAAqB;WAAKilB;;MAChC,KAAK,MAAMjd,SAASkd,eACXllB,OAAOgI;MAEhB,OAAOhI;AACT;;ICZO,SAAS0+B;MACd,OAAOl2B,UAAUiH,UAAUpJ,QAAQ,iBAAiB;AACtD;IAEO,SAASs4B;MACd,OAAOD,eAAel2B,UAAUiH,UAAUpJ,QAAQ,gBAAgB;AACpE;IAEO,SAASu4B;MACd,OACEp2B,UAAUiH,UAAUpJ,QAAQ,gBAAgB,KAC5CmC,UAAUiH,UAAUpJ,QAAQ,kBAAkB;AAElD;IAMO,SAASw4B;MACd,OAAOr2B,UAAUiH,UAAUpJ,QAAQ,gBAAgB,MAAMu4B;AAC3D;;ICrBO,MAAME,cAAc,EACzB,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA;;;;;;;;;;;ICVK,MAAMC,8BAA8BjlC;MAIzC,WAAAD,EACE,KAAK,YACF+mB;QAEHtlB,SAASslB,SAPX,uCACA;QAOExnB,OAAOynB,eAAetlB,MAAMwjC,sBAAsB/gC;QAElD,WAAWlE,MAAMgnB,sBAAsB,YACrChnB,MAAMgnB,kBAAkBvlB,MAAMwjC;QAGhCxjC,KAAKmB,OAAO;QACZnB,KAAKa,UAAU,aAAaquB,WAAWpwB;QACvCkB,KAAKlB,MAAMA;QACXkB,KAAKkvB,SAASA;AAChB;;;ICEK,MAAMuU,YAA0B,EACrC;MACEtiC,MAAM;MACNpC,MAAM,EAAC,SAAS,SAAS;MACzB2kC,aAAa,EAAC,SAAS;MACvBC,SAAS;OAEX;MACExiC,MAAM;MACNpC,MAAM,EAAC;MACP2kC,aAAa;MACbC,SAAS;OAEX;MACExiC,MAAM;MACNpC,MAAM,EAAC;MACP2kC,aAAa;MACbC,SAAS;OAEX;MACExiC,MAAM;MACNpC,MAAM,EAAC;MACP2kC,aAAa,EAAC;MACdC,SAAS;OAEX;MACExiC,MAAM;MACNpC,MAAM,EAAC,OAAO;MACd2kC,aAAa,EAAC;MACdC,SAAS;OAEX;MACExiC,MAAM;MACNpC,MAAM,EAAC,OAAO,QAAQ;MACtB2kC,aAAa,EAAC;MACdC,SAAS;OAEX;MACExiC,MAAM;MACNpC,MAAM,EAAC;MACP2kC,aAAa;MACbC,SAAS;OAEX;MACExiC,MAAM;MACNpC,MAAM,EAAC;MACP2kC,aAAa,EAAC;MACdC,SAAS;;;ICjEb,MAAMC,uBAAuB;;IAE3B;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;IAEA;;;IAGA;;IAEA;;IAEA;;IAEA;;IAEA;IAKK,SAASC,qBAAqB7c;MACnC,IAAIA,SAAS,MACX,OAAO4c,qBAAqB5kC,QAAQ8kC,OAAQA,QAAQ;MAEtD,OAAOF;AACT;IAEA,MAAMG,2BAEF;MACFC,IAAI;MACJC,GAAG;MACHC,GAAG;MACHC,GAAG;MACHC,IAAI;MACJC,IAAI;MACJC,GAAG;MACHC,IAAI;MACJC,GAAG;MACHC,GAAG;MACHC,IAAI;MACJC,GAAG;MACHC,GAAG;MACHC,GAAG;MACHC,IAAI;;IAGC,SAASC,uBACdjB;MAEA,OAAOC,yBAAyBzhC,eAAewhC,OAC3CC,yBAAyBD,YACzBhkC;AACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QCmBA,MAAMklC,4BAAwD,IAAIvuB,IAAI,EACpE,eACA,oBACA,oBACA,YACA;IAGK,MAAMwuB;MAoBX,kBAAcC;QACZ,IAAIC;QACJ;UACEA,iBAAiB9lC,2BAAAA,QAAAA,KAAAA,IAAyB;AAC5C,UAAE;UACA8lC,WAAW,CAAC;AACd;QACA;UACEA,SAASC,uBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICzIxB,MAAMC,uBAAwB/yB,UAAwB;MAC3DvF,MAAM;MACNuF;;;ICFF,IAAI2F,6BAA6C;IAEjD,IAAI5Y,2BAAAA,YACFA,2BAAAA,WAAAA,UAEGiB,MAAMquB;MACL,IAAIA,KAAK2W,gBAAgB,eACvBrtB,6BAAe;AACjB,QAEDjT,OAAO4I;MACNjM,QAAQC,KAAKgM;AAAE;IAId,SAAS23B;MACd,OAAOttB;AACT;;ICIA,MAAMutB,wBAAwB7jB;MAC5B,IAAI8jB;MACJ;;;;;;;;;;;;;QAkBEA,eAAe,IAAIxyB,IAAI5T,2BAAAA,QAAAA,OAAuB,QAAQqmC;AACxD,QAAE;iBAEF;;MAEA,IAAID,gBAAgBA,iBAAiBpmC,2BAAAA,QAAAA,IACnC,OAAOomC;;YAIT;QACE,IAAIE,yBAAyBtmC,2BAAAA,QAAAA,MAAAA,IAA0B,eACnDumC;QACJ,WAAWD,oBAAoB,UAAU;UACvC,MAAME,YAAYC;gBACZzmC,2BAAAA,QAAAA,MAAAA,IAA0B;YAAEumC,WAAWC;;UAC7CF,kBAAkBE;AACpB;QAEA,OAAOF;AACT,QAAE;qFAEF;;MAEA,OAAO;AAAS;IAGlB,SAASG;MACP,MAAMC,SAASC,gBAAgB;MAC/B,OAAO,GAAG,IAAIjjB,OAAO,MAAMgjB,OAAO18B,SAAS,MAAM6B,OAAO;AAC1D;;QAGA,SAAS86B,gBAAgBrnC;MACvB,IAAImK,KAAK2yB,IAAI,IAAI98B,UAAUwP,OAAO83B,kBAChCtkC,QAAQmD,MACN,yBAAyBnG;MAG7B,MAAM+X,SAAS,IAAIypB,WAAWxhC;MAC9BshC,OAAOC,gBAAgBxpB;MACvB,MAAMkiB,MAAM9vB,KAAK2yB,IAAI,GAAG;MAExB,IAAIh3B,SAAS;MACb,KAAK,IAAI5F,IAAI,GAAGA,IAAI6X,OAAO/X,QAAQE,KAAK;QACtC4F,UAAU;QACVA,UAAUqE,KAAKo9B,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBCrElB,IAAItG;sBAMJ,IAAIC;IAEX,IAAI;;;;;;;;;;;;;;;;;;;;;;;;;;ICdJ,SAASsG,OAKPnoC,GAAqBC;MACrB,IAAID,EAAE+O,SAAS,iBAAiB;QAC9B,MAAMq5B,sBAAsBpoC,EAAE4d;QAI9B,MAAM2jB,UAA8C,CAAC;QACrD,YAAYzgC,KAAKuB,UAAUxC,OAAO2Y,QAAQ4vB,oBAAoB7G,UAC5DA,QAAQzgC,OAAS,YAAOuB,OAAOpC;QAEjC,OAAOooC,cAAcroC,EAAE4d,OAAOnP,OAAO8yB;AACvC;MAEA,OAAS,YAAOvhC,GAAkCC;AACpD;IA4BA,SAAS,WAAMoC;MAKb,WACSA,UAAU,mBACTA,UAAU,YAAYA,MAAMgJ,aAAaxL,OAAO4E,UAAU4G,UAElE,OAAOzC,KAAKC,UAAUxG;MAExB,OAAO,GAAGA;AACZ;IAEA,SAAS,4BAASrC;MAChB,cAAcA,MAAM,YAAYA,MAAM,SAASI,MAAMC,QAAQL;AAC/D;IAEO,IAAMqoC,gBAAgB,CAI3B55B,OACA8yB;MAEA,MAAMxgC,OAAOlB,OAAOkB,KAAKwgC;MAEzB,MAAM+G,oBACJjmC;QAEA,KACG,4BAASA,iBACHA,MAAMoM,WAAW,aACvB1N,KAAKwJ,SAASlI,MAAMoM,SAErB;QAGF,MAAMmO,SAASva,MAAMoM;QACrB,MAAM85B,eAAehH,QAAQ3kB;QAC7B,KAAK2rB,cACH;QAGF,OAAOJ,OAAOI,cAAgB,YAAO;UAAE,CAAC95B,QAAUiQ,QAAQ9B;;AAAW;MAGvE,OAAO,IAAMc,OAGX;QACA3O,MAAM;QACN6O,QAAQ;UAAEnP;UAAO8yB;;QACjB,SAAC/oB,CAAQnW,OAAgBkV;UACvB,MAAMmF,SAAS4rB,kBAAkBjmC;UACjC,IAAIqa,eACKA,OAAOlE,QAAQnW,OAAOkV;AAEjC;QACA,SAAA4F,CAAU9a,OAAgBkV;UACxB,KAAK,4BAASlV,QACZ,OAAO,qCAAqC,WAAMA;UAGpD,MAAMoM,SAASpM,iBAAiBA,MAAMoM,WAAW,UAC/C,OAAO,4BAA4BA,kCAAkC,WACnEpM;UAIJ,KAAKtB,KAAKwJ,SAASlI,MAAMoM,SACvB,OAAO,aAAaA,uBAAuB1N,KACxC8L,KAAK/L,OAAQ,IAAIA,SACjBuM,KAAK,yBAAyBhL,MAAMoM;UAGzC,MAAMiO,SAAS4rB,kBAAkBjmC;UACjC,KAAKqa,QACH,OAAO;UAGT,OAAOA,OAAOS,UAAU9a,OAAOkV;AACjC;;AACA;;IC7IG,MAAMixB,mBAAmBlrB,UAAO;;MAErCsU,KAAKtU,SACHA,UAAO;;QAELmrB,SAASnrB;;QAETpB,GAAGoB;QACHorB,GAAGprB;QACHqrB,OAAOrrB;QACPsrB,QAAQtrB;QACRurB,WAAWvrB,MAAQ,EAAC,YAAY,cAAc;QAC9CwrB,MAAMxrB,MAAQ,EAAC,UAAU,SAAS;;QAElCyrB,cAAczrB;;;QAGd0rB,aAAa1rB,SACXA,UAAO;;UAELpB,GAAGoB;UACHorB,GAAGprB;;;;;;;;;;;;;;;;;UAqBH2rB,SAAS3rB;UACT4rB,SAAS5rB;;;;MAOjB6rB,aAAa7rB,MAAQ,EAAC,QAAQ;;MAG9B8rB,SAASf,cAAc,QAAQ;;QAE7BgB,QAAQ/rB,UAAO,CAAC;;;;QAIhBgsB,OAAOjB,cAAc,WAAW;;UAE9B7f,SAASlL,UAAO;YAAEkL,SAASlL;;;UAE3Bvc,MAAMuc,UAAO;YAAEisB,SAASjsB;;;;;QAI1BksB,OAAOlsB,UAAO,CAAC;;;QAGfmsB,QAAQnsB,UAAO,CAAC;;;QAGhBosB,OAAOpsB,UAAO,CAAC;;;;ICvEnB,MAAMqsB,sBAAsBrsB,UAAO;MACjCzT,OAAOyT;MACPssB,eAAetsB,SAAWA;;IAK5B,MAAMusB,2BAA2BvsB,YAC/BqsB,qBACArsB,UAAO;MACLwsB,eAAexsB;;IAMZ,MAAMysB,0BAA0B1B,cAAc,QAAQ;;MAI3D2B,iBAAiB1sB,UAAO;QAAEjb,OAAOib;;MACjC2sB,UAAU3sB,UAAO,CAAC;MAClB4sB,yBAAyB5sB,UAAO,CAAC;MACjC,WAAWA,UAAO,CAAC;MACnB6sB,SAAS7sB,UAAO;QACd2U,KAAK3U;;MAEP8sB,cAAc9sB,UAAO,CAAC;MACtBvT,SAASuT,UAAO,CAAC;MACjB+sB,kBAAkB/sB,UAAO;QACvBjb,OAAOib,YAAS;UACdpB,GAAGoB;UACHorB,GAAGprB;UACHxF,aAAawF,MAAQ,EAAC,SAAS;UAC/BgtB,QAAQhtB;;;MAGZitB,aAAaZ;MACba,aAAaX;MACbY,kBAAkBntB,UAAO,CAAC;MAC1BotB,WAAWptB,UAAO;QAChBzT,OAAOyT;QACPssB,eAAetsB,SAAWA;;;;;;;MAY5B,oBAAoBA,UAAO;QACzBmrB,SAASnrB;QACThJ,OAAOgJ,SAAWkrB;;MAEpB,uBAAuBlrB,UAAO;QAC5BhJ,OAAOgJ,SAAWkrB;;MAEpB,wBAAwBlrB,UAAO,CAAC;MAChC,sBAAsBA,UAAO,CAAC;;MAG9B,uBAAuBA,UAAO;QAAE3c,QAAQ2c;QAAYmrB,SAASnrB;;MAC7D,4BAA4BA,UAAO;QAAEmrB,SAASnrB;;;MAG9C,cAAcA,UAAO;;;;QAKnBqtB,QAAQrtB,UAAO;UACb2U,KAAK3U;UACLstB,YAAYttB,UAAO;YACjBqrB,OAAOrrB;YACPsrB,QAAQtrB;;;;MAId,gBAAgBA,UAAO,CAAC;MACxB,kBAAkBA,UAAO,CAAC;MAC1B,mBAAmBA,UAAO,CAAC;MAC3B,mBAAmBA,UAAO,CAAC;MAC3B,sBAAsBA,UAAO,CAAC;MAC9B,wBAAwBA,UAAO,CAAC;MAChC,mBAAmBA,UAAO,CAAC;MAC3B,iBAAiBA,UAAO;QAAEurB,WAAWvrB,MAAQ,EAAC,MAAM;;;MAGpD,qBAAqBA,UAAO,CAAC;MAC7B,oBAAoBA,UAAO,CAAC;MAC5B,qBAAqBA,UAAO,CAAC;MAC7B,wBAAwBA,UAAO;QAC7ButB,UAAUvtB,MAAQ,EAAC,SAAS,OAAO;;;;;;;;;;;;;;IC3ExB,MAAMwtB;MASnB,UAAMn5B,CAAK0H;QACT,IAAIrX,KAAK+oC,aAAa;UACpB,IAAIniC,KAAKC,UAAU7G,KAAKqX,YAAYzQ,KAAKC,UAAUwQ,SAAS;YAC1D,MAAMvS,QAAQ,IAAIvG,MAChB;YAEFoD,QAAQmD,MAAMA;iBACTyU,QAAQnS,OAAOtC;AACtB;UACA,OAAO9E,KAAK+oC;AACd;QAEA/oC,KAAK+oC,cAAc/oC,KAAKgpC,OAAO3xB;QAE/B,OAAOrX,KAAK+oC;AACd;MAEA,YAAcC,CAAO3xB;QACnBrX,KAAKqX,SAASA;;gBAGdrX,KAAKmoC,gBAAgBnoC,KAAKipC;;gBAG1B,IAAIjpC,KAAKmoC,SACPnoC,KAAKkpC,gBAAgB;;gBAIvB,IAAIlpC,KAAKmoC,SACPnoC,KAAKmpC,mBAAmBnkC,OAAO4I,KAAM2L,QAAQnS,OAAOwG;;;gBAKtDvO,2BAAAA,KAAAA,YAAAA,aAAqC,EAAG+pC,WAC/BppC,KAAKqpC,UAAUD;;gBAIxB/pC,2BAAAA,QAAAA,UAAAA,aACE,CACE8Q,SACAhM;UAEA,KAAKmX,GAAKnL,SAAS43B,0BACjB;UAGF,QAAQ53B,QAAQpD;WACd,KAAK;YACH,KAAK5I,OAAOmlC,cAAcnlC,OAAOmlC,IAAIlqC,OAAO,UAC1C;iBAGGY,KAAKqpC,UAAUllC,OAAOmlC,IAAIlqC,IAAI+E,OAAOsiC;YAC1C;;WAEF,KAAK;YACH,KACGtiC,OAAOmlC,cACDnlC,OAAOmlC,IAAIlqC,OAAO,mBAClB+E,OAAOsiC,YAAY,UAE1B;YAGFzmC,KAAKupC,aAAa;cAChBH,OAAOjlC,OAAOmlC,IAAIlqC;cAClBqnC,SAAStiC,OAAOsiC;cAChBxW,KAAK9f,QAAQ8f;;YAGf,OAAOzuB,QAAQT,QAAQ;cAAE0lC,SAAStiC,OAAOsiC;;;WAE3C,KAAK;YACH,KAAKtiC,OAAOmlC,cAAcnlC,OAAOmlC,IAAIlqC,OAAO,UAC1C;YAGFY,KAAKwpC,UAAU;cACbJ,OAAOjlC,OAAOmlC,IAAIlqC;cAClBqnC,SAAStiC,OAAOsiC;;YAElB;;UAGJ;AAAgB;QAIpBzmC,KAAKypC,eAAe;AACtB;MAEA,2BAAcR;QACZ,IAAIS;QACJ;UACEA,yBAAyBrqC,2BAAAA,QAAAA,MAAAA,IAA0B;AACrD,UAAE;;UAEA,OAAO;AACT;QAEA,OACEqqC,iBAAiBpnC,eAAe,gBAAgBonC,iBAAiBvB;AAErE;MAEA,sBAAcgB;;;;;;QAOZ,MAAMQ,cAAchoB;UAClB,MAAM7b,aAAazG,2BAAAA,KAAAA,MAAmB;YAAEipC,QAAQ;;UAChD,KAAKxiC,MACH;UAGF,KAAK,MAAMwjC,OAAOxjC,MAChB,WAAWwjC,IAAIlqC,OAAO,gBACdY,KAAKqpC,UAAUC,IAAIlqC;AAE7B;;gBAIF;gBACQuqC;AACR,UAAE;UACAhoC,QAAQ2M,IAAI;UACZmY,YAAW;YACTkjB,cAAc3kC,OAAM;cAClBrD,QAAQ2M,IAAI;AAAiD;AAC7D,cACD;AACL;AACF;;MAMA,eAAAs7B;QACE,OAAOpoC,QAAQT,QAAQ,EAAC;UAAEonC,SAASnoC,KAAKmoC;UAASiB,YAAOtpC;;AAC1D;;MAMA,eAAM+pC,CAAUC,MAA4BzyB;QAC1C,KAAKrX,KAAK+oC,aACR,MAAM,IAAIxqC,MAAM;cAGZyB,KAAK+oC;;gBAGX/oC,KAAKqX,SAASA;QAEd,KAAKrX,KAAKmoC,SACR5uB,QAAQrK,gBAAgB;;gBAI1BlP,KAAKmoC,WAAWnoC,KAAKmoC;;gBAGrB,IAAInoC,KAAKmoC;;cAEDnoC,KAAKmpC;;cAGLY,qBAAqB;UAAEh9B,MAAM;UAAWi9B,OAAO;;;gBAIvD,IAAIhqC,KAAKmoC,SACP9oC,2BAAAA,QAAAA,MAAAA,IAA0B;UAAE8oC,SAAS;WAAQnjC,OAAM,iBAInD3F,2BAAAA,QAAAA,MAAAA,OAA6B,WAAW2F,OAAM;QAKhDhF,KAAKkpC,gBAAgBlpC,KAAKmoC;AAC5B;MAEA,eAAckB,CAAUD,OAAe3C;QACrC,KAAKzmC,KAAKqX,QACR,MAAM,IAAI9Y,MAAM;QAGlB,KAAKyB,KAAKmoC,SACR;QAGF;gBACQ9oC,2BAAAA,KAAAA,YACJ+pC,OACA;YACEr8B,MAAM;YACNsK,QAAQrX,KAAKqX;;;YAGb2yB,OAAO;aAET;YAAEvD;;AAEN,UAAE;;sCAGF;;AACF;;MAMA,kBAAMwD,CAAa5yB;;QAEjB,IAAIzQ,KAAKC,UAAU7G,KAAKqX,YAAYzQ,KAAKC,UAAUwQ,SACjD;QAGFrX,KAAKqX,SAASA;QAEd,KAAKrX,KAAKmoC,SACR;cAGI4B,qBAAqB;UAAEh9B,MAAM;UAAUsK;UAAQ2yB,OAAO;;AAC9D;MAEA,qBAAME;cACEH,qBAAqB;UAAEh9B,MAAM;UAAai9B,OAAO;;AACzD;;MAMA,kBAAAG,EAAoE,OAC7D,SACE;QAOP9qC,2BAAAA,KAAAA,YACe+pC,OAAO;aAAKvoC;UAASmpC,OAAOvD;WAAW;UAAEA;WACrDzhC,OAAM;AAGX;MAEA,qBAAAolC,EAAgE,OACzD;QAML,MAAM3D,UAAUzmC,KAAKqqC,cAAcjB;QACnC,IAAI3C,YAAY,MACd;QAGFpnC,2BAAAA,KAAAA,YACe+pC,OAAO;aAAKvoC;UAASmpC,OAAO;WAAS;UAAEvD;WACnDzhC,OAAM;AAGX;MAEQ,aAAAqlC,CAAcjB;QACpB,MAAMA,SAASppC,KAAK8F,O;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC5TjB,MAAMwkC,yBAA6D;MACxExd,OAAO;MACPC,UAAU;MACVF,OAAO;MACPD,OAAO;;;ICNF,SAAS2d,kBACdtqB,MACApX;MAEA,IAAI2hC;MACJ,IAAIC;MACJ,OAAO,YAAappC;yDAElB,MAAMkU,UAAUvV;QAChB,MAAM0qC,MAAM;UACVzqB,KAAK/d,MAAMqT,SAASlU;UACpBopC,UAAUvsC,KAAKyV;AAAK;QAGtB,KAAK82B,SACHC,YACK;UACL19B,KAAK0Z,aAAa8jB;UAClBA,wBAAwBx9B,KAAKyZ,YAC3B;YACE,IAAIvoB,KAAKyV,QAAQ82B,WAAY5hC,OAC3B6hC;AAEJ,cACA7hC,SAAS3K,KAAKyV,QAAQ82B;AAE1B;AACF;AACF;;;;ICVA,MAAMvb,wBAASyb,QAAUtrC,IAAiBA,2BAAAA;;;;;QAM1C,MAAMurC,oBAAoBL,mBACxB,IAAIlpC;MACF;QACE6tB,sBAAO2b,YAAYxpC,MAAM2D,OAAO4I;;;;;UAO9BjM,QAAQC,KAAKgM;AAAE;AAEnB,QAAE,OAAOA;;;QAGPjM,QAAQC,KAAKgM;AACf;AAAA,QAEF;IAGF,IAAIk9B;IAEG,SAASC,oBAAoB1lB;;;;;;MAOlC,IAAIylB,eAAe;QACjBA,cAAcvwB,OAAO8K;QACrB;AACF;WAEK;;;;;;;;;;;;;;;QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICtDP,MAAM2lB,iBAAiB;IACvB,MAAMC,sBAAsB;;;;QAK5B,MAAMC,eACJ7rC,2BAAAA,gBAAwBA,2BAAAA;IAEnB,SAAS8rC,sBAAsBpjC;MAIpCmjC,cAAcE,UAAU1nC,aAAY,CAACirB,MAAM2a;QACzC,IAAI3a,KAAK0c,eAAeL,gBACtBjjC,QAAQujC,aAAahC,WAChB,IAAI3a,KAAK0c,eAAeJ,qBAC7BljC,QAAQwjC,eAAe5c,KAAK6c;AAC9B;AAEJ;;;;;;;;;;;;;;;;;;;OAqBO7pB,eAAe8pB,mBAAmB1jC;;;MAOvC,KAAKmjC,gBAAgB9H,WACnB;MAGF,OAAM,YAAY,mBAAmB,YAAer7B;MAEpD,IAAI2jC,mBACF;cACQC,cAAcC;AACtB,QAAE;QACA;gBACQV,aAAa3c,OAAOyc,gBAAgB;YAAEQ,SAASI;;AACvD,UAAE;mBAEF;;AACF,mBAEMC,eAAeb;;YAIvB,IAAIY,YACF;cACQE,kBAAkBC;AAC1B,QAAE;QACA;gBACQb,aAAa3c,OAAO0c,qBAAqB;YAAEO,SAASO;;AAC5D,UAAE;mBAEF;;AACF,mBAEMF,eAAeZ;AAEzB;IAEAtpB,eAAegqB,cAAcxD;MAC3B,MAAM6D,WAAqC,EACzCrB,QAAU,IAAW,kBACrB,YACA,SACA,SACA,QACA,QACA,aACA;;;YAKF,IAAIsB,MACFD,SAAS1mC,KAAK;MAGhB,OAAO4mC,eAAe;QACpB9sC,IAAI4rC;QACJj+B,MAAM;QACNuG,OAAOjU,2BAAAA,KAAAA,WAAwB;QAC/B2sC;QACAR,SAASrD;;AAEb;IAEAxmB,eAAemqB,kBAAkB3D;MAC/B,OAAO+D,eAAe;QACpB9sC,IAAI6rC;QACJl+B,MAAM;QACNuG,OAAOjU,2BAAAA,KAAAA,WAAwB;QAC/B2sC,UAAU,EAACrB,QAAU,IAAW;QAChCa,SAASrD;;AAEb;IAEAxmB,eAAeuqB,eACbC;;;MAIA,OAAO,IAAI3qC,SAAc,CAACT,SAASH;QACjC,KAAKsqC,cAAc;UACjBtqC,OAAO,IAAIrC,MAAM;UACjB;AACF;QAEA2sC,aAAaroC,OAAOspC,mBAAkB;UACpC,IAAI9sC,2BAAAA,QAAAA,WACFuB,OAAOvB,2BAAAA,QAAAA;UAET0B;AAAS;AACT;AAEN;IAEA4gB,eAAekqB,eAAeR;MAC5B;eACQH,cAAckB,OAAOf;AAC7B,QAAE;iBAEF;;AACF;;mBCvJO,MAAMgB,qBAAqB9tC;MAChC,WAAAD,IAAe+mB;QACbtlB,SAASslB;QACTxnB,OAAOynB,eAAetlB,MAAMqsC,aAAa5pC;QAEzC,WAAW,wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICkBf,MAAM2G,0BAAiBvL,OAAO4E,UAAU4G;IACxC,MAAMC,0BAAiBzL,OAAOyL;IAC9B,MAAMC,sBAAa;IAEZ,SAASC,iBAAQxL;MACtB,IAAIA,aAAaO,OACf,OAAO;MAGT,IAAImG,MAAM1G;MACV,OAAO0G,KAAK;QACV,IAAI0E,wBAAe/G,KAAKqC,SAAS6E,qBAC/B,OAAO;QAET7E,MAAM4E,wBAAe5E;AACvB;MAEA,OAAO;AACT;;;;;;;;;;;IC9BA,MAAM4nC,eAAehxB,UAAO;MAC1BzD,WAAWyD,SAAMA,WAAa;MAC9BknB,OAAOlnB,OAASA,UAAYA;;;;QAK9B,MAAMoK,iCAAsBnnB;MAI1B,WAAAD,CAAYsR,KAAa+V,SAAiBN;QACxCtlB,SAASslB,SAJX,kDACA;QAIExnB,OAAOynB,eAAetlB,MAAM0lB,yBAAcjjB;QAE1C,WAAW,wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ICjBRkf,eAAe4qB,oBACpBC;MAEA,MAAMC,sBAAsBD,WAAW5C;MACvC,IAAI6C,cAAc9tC,SAAS,GACzB,OAAO;MAGT,IAAI8tC,cAAc9tC,WAAW,GAC3B,OAAO8tC,cAAc,GAAGtE;MAG1B;QACE,MAAMuE,0BAA0BrtC,2BAAAA,KAAAA,MAAmB;UACjDipC,QAAQ;UACRqE,eAAe;;;;;gBAMjB,KAAKD,mBACH,OAAO;;;gBAKT,MAAME,YAAYF,kBAAkB;QAEpC,OACEE,aACAH,cAAcvuB,MACX5L,SAAUA,MAAM82B,UAAUwD,UAAUxtC,MAAMkT,MAAM61B;AAGvD,QAAE,OAAOv6B;aACF2L,QAAQnS,OAAOwG;QACpB,OAAO;AACT;AACF;;;;;;;ICzCO,SAASi/B,eAAehlC;;;MAG7B,MAAMilC,iBAAiB/oB,mBAAmBlc;MAC1C,KAAKklC,YAAYnoB,gBAAgBD,aAAamoB;;;aAI7CC,YAAYnoB,gBAAgBooB,UAAUD,YAAYnoB;;YAGnD,KAAK,IAAI/lB,IAAI,GAAGA,IAAIiuC,eAAenuC,UAAUE,GAAG;QAC9C,MAAM2kB,OAAOspB,eAAerpB,YAAY5kB;;;gBAGxC,IACE;;;;;;;;;;;;;;;;;;;;;;;;;ICtBC,SAASouC,eAAenoC;MAI7B,IAAI3D;;;YAIJ,KAAK2D,OAAO;;;QAGV,IAAIqF;QACJ;UACE,MAAM,IAAI5L,MAAM;AAClB,UAAE,OAAOqP;UACPzD,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;ICdP,MAAM+iC,aAAa,OAAO;MAAEngC,MAAM;;IAElC,MAAMogC,yBAAW,EACtBnmB,MACAomB,YAIK;MACLrgC,MAAM;MACNia;MACAomB;;IAGK,MAAMC,iBAAiB,OAAO;MAAEtgC,MAAM;;IAEtC,MAAMugC,yBAAW,OAAO;MAAEvgC,MAAM;;IAEhC,MAAMs4B,qCAAwB/yB,UAAwB;MAC3DvF,MAAM;MACNuF;;IAGK,MAAMi7B,yBAA0Bpe,cAA4B;MACjEpiB,MAAM;MACNoiB;;IAGK,MAAMjgB,gCAAkB,EAAGrO,cAAoC;MACpEkM,MAAM;MACNlM;;IAGK,MAAM2sC,cAAc,EACzB1oC,OACA6J,WAAW,cAIN;MACL5B,MAAM;MACN4B;SACGs+B,eAAenoC;MAClBqF,OAAOrF,MAAMqF;;;;;;;;;;;;ICxCR,MAAMsjC;MAiBX,QAAAN,CAAS9nB;QACPrlB,KAAK0tC,OAAOC,YAAY1mC,uBAAgBoe;AAC1C;MAEA,cAAAgoB;QACErtC,KAAK0tC,OAAOC,YAAY1mC;AAC1B;MAEA,QAAAqmC;QACEttC,KAAK0tC,OAAOC,YAAY1mC;AAC1B;MAEA,UAAAimC;QACEltC,KAAK0tC,OAAOC,YAAY1mC;AAC1B;MAEA,gBAAA8G,CAAiBpK;QACf,KAAK3D,KAAK4tC,UAAUrlC,SAAS5E,WAC3B3D,KAAK4tC,UAAUtoC,KAAK3B;AAExB;MAEA,mBAAA0b,CAAoB1b;QAClB3D,KAAK4tC,YAAY5tC,KAAK4tC,UAAU5uC,QAAQ84B,KAAMA,MAAMn0B;AACtD;MAEQ,eAAAulC,CAAgBroC;QACtB,MAAMgtC,gBAAgB7tC,KAAK4tC,UAAU1iC;QACrC,KAAK,MAAMvH,YAAYkqC,eACrBlqC,SAAS9C;AAEb;MA5CA,WAAAvC;QAHA,4CAAQ,eAAR;QACA,4CAAQ,aAAmC;QAGzC0B,KAAK0tC,SAAS,IAAII,OAAO;QACzB9tC,KAAK0tC,OAAOK,iBAAkBx+B;UAC5B5N,QAAQmD,MAAM,iBAAiB8B,KAAKC,UAAU0I;eACzCgK,QAAQnS,OAAO,iBAAiBR,KAAKC,UAAU0I;AAAS;QAG/DvP,KAAK0tC,OAAOM,YAAYrsB,MAAOpS;UAC7B,MAAM1O,UAAU0O,MAAM0+B;UACtBjuC,KAAKkpC,gBAAgBroC;AAAQ;AAEjC;;;;;;;;;;;;ICRK,SAAS+4B,mCAAgBC;MAC9B,MAAMC,WAGF,IAAIvjB;MAER,KAAK,MAAM9R,UAAUo1B,SAAS;QAC5B,MAAMl7B,UACJ8F,OAAO2W,EAAE/B,MAAM+B,KAAMA,EAAEqc,gBAAehzB,OAAOqW,EAAEzB,MAAMyB,KAAMA,EAAE2c,eAC5DC,IAAI/4B;;;;;gBAMP,MAAMu7B,cAAcz1B,OAAOqW,EAAEzB,MAAMyB,OAAQA,EAAE2c;QAC7C,MAAM0C,KAAKD,cAAcE,uCAAoBF,aAAaz1B,UAAU;;gBAGpE,MAAM41B,WAAWC,+BAAY71B;QAE7Bq1B,SAAS35B,IAAIsE,OAAOrF,IAAI;UAAET;UAAQ07B;UAAUttB,MAAMotB;;AACpD;MAEAN,QAAQj7B,MAAK,CAACZ,GAAGC;QACf,MAAMs8B,QAAQT,SAAS75B,IAAIjC,EAAEoB;QAC7B,MAAMo7B,QAAQV,SAAS75B,IAAIhC,EAAEmB;QAE7B,IACEm7B,MAAM57B,gBAAWmB,KACjB06B,MAAM77B,gBAAWmB,KACjBy6B,MAAM57B,WAAW67B,MAAM77B,QAEvB,OAAO67B,MAAM77B,SAAS47B,MAAM57B;QAG9B,IAAI47B,MAAMxtB,SAASytB,MAAMztB,MACvB,OAAOwtB,MAAMxtB,OAAOytB,MAAMztB;QAG5B,OAAOytB,MAAMH,WAAWE,MAAMF;AAAQ;MAGxC,OAAOR;AACT;IAEA,SAASO,uCACPtf,GACArW;;;;MAKA,MAAMg2B,mBACJ3f,EAAEjc,GAAG0J,SAAS,SACduS,EAAEjc,GAAG0J,SAAS,SACduS,EAAEjc,GAAG0J,SAAS,SACduS,EAAEjc,GAAG0J,SAAS;MAEhB,IAAIkyB,kBACF,OAAO;;;;;;YAQT,KACGh2B,OAAO2W,EAAEzc,UACV8F,OAAO2W,EAAEsf,OACNtf,KAAMA,EAAEvc,GAAG0J,SAAS,SAAS6S,EAAEvc,GAAG0J,SAAS,SAAS6S,EAAEvc,GAAG0J,SAAS,SAGrE,OAAO;;;;;;;;;;;YAaT,IAAIuyB,4CAAyBr2B,OAAO6W,IAClC,OAAO;;YAIT,OAAOR,EAAEhH,QAAQ,IAAI,IAAI;AAC3B;IAEA,SAASgnB,4CAAyB5B;MAChC,MAAM6B,kBAAkB7B,OAAOl6B,QAC5Bsc,KAAMA,EAAEvR,UAAUuR,EAAE0L,cAASlnB,KAAawb,EAAE0L,SAAS;MAExD,IAAI+T,gBAAgBp8B,WAAW,GAC7B,OAAO;MAGT,MAAMq8B,iBAAiBD,gBAAgB/7B,QAAQsc,KAC7CA,EAAEkV,MAAMjoB,SAAS,QACjB5J;MACF,OAAOq8B,kBAAkBD,gBAAgBp8B,SAAS;AACpD;IAEA,SAAS27B,+BAAY71B;MACnB,MAAMw2B,SAAwB,EAAC;;YAG/B,KAAK,MAAM7f,KAAK3W,OAAO2W,KAAK,IAAI;QAC9B,KAAKA,EAAEqc,eAAerc,EAAEoU,GACtB;QAGFyL,OAAO31B,KAAK61B,kCAAe/f,EAAEoU;AAC/B;;YAGA,KAAK,MAAM1U,KAAKrW,OAAOqW,GAAG;QACxB,KAAKA,EAAE2c,eAAe3c,EAAE0U,GACtB;QAGFyL,OAAO31B,KAAK61B,kCAAergB,EAAE0U;AAC/B;;YAGA,OAAO1mB,KAAK8vB,OAAOqC;AACrB;;;;;;;;;;;;QAaA,SAASE,kCAAeC;MACtB,MAAMH,SAASG,WAAWvwB,IAAIwwB,qCAAkBz8B,OAAO08B;MACvD,OAAOL,OAAOt8B,SACVs8B,OAAO,KACLA,OACG/vB,MAAM,GACNhB,QACC,CAACqxB,OAAOC,OAAO7pB,UAAU4pB,QAAQC,QAAQ1yB,KAAK2yB,IAAI,IAAI9pB,QAAQ,KAC9D,KAEN;AACN;;;;;;QAOA,MAAM+pB,0CAA4C,IAAInlB,IAAI,EACxD,EAAC,MAAM,MACP,EAAC,MAAM,MACP,EAAC,MAAM,MACP,EAAC,MAAM,MACP,EAAC,MAAM,MACP,EAAC,MAAM,MACP,EAAC,MAAM,MACP,EAAC,MAAM;IAGT,SAAS8kB,oCAAiB7L;MACxB,IAAIkM,wCAAqBx7B,IAAIsvB,IAC3B,OAAOkM,wCAAqBz7B,IAAIuvB;MAGlC,IAAIA,EAAEvf,WAAW,OAAO;;;;QAItB,MAAM0rB,WAAW/vB,SAAS4jB,EAAExY,UAAU,IAAI;QAC1C,IAAI2kB,WAAW,KAAKA,WAAW,IAC7B,OAAO,KAAKA,WAAW;AAE3B;MAEA,OAAO;AACT;;;;;;;;;;;ICxKA,MAAMuS;;MAiBJ,cAAcC;QACZ;;UAEEnuC,KAAKouC,iBAAiBpuC,KAAKquC,sBACzBhvC,2BAAAA,QAAAA,OAAuB;UAEzBW,KAAKsuC,kBAAkBtuC,KAAKquC,sBAC1BhvC,2BAAAA,QAAAA,OAAuB;UAGzBW,KAAKkpC,gBAAgB;YAAEn8B,MAAM;;AAC/B,UAAE,OAAOa;UACP5N,KAAKkpC,gBAAgB;YAAEn8B,MAAM;YAASjI,OAAO8I;YAAG2gC,WAAW;;AAC7D;AACF;MAEA,2BAAcF,CAAsBz+B;QAClC,IAAI4+B,WAAW;;;gBAIf,MAAMC,iBAAiB,CAACC,QAAgB9+B;UACtC,MAAM++B,WAAW7lC,KAAK8vB,IAAI,GAAGhpB,IAAIjR,UAAU,KAAK+vC,OAAO/vC,SAAS;UAChE,OAAO+vC,SAAS,WAAM9+B,IAAIoH,UAAU23B;AAAS;QAG/C,IAAI3uC,KAAK4uC,SACP5uC,KAAK4uC,QAAQ1/B,gBAAgBu/B,eAAe,aAAa7+B;QAG3D,OAAO,MAAM;;;;UAIX,MAAMi/B,aAAa,IAAI;UACvB,IAAItoB;UAEJ;YACE,IAAIN;YACJ,IAAI6oB;;wBAGJ,WAAW5oB,oBAAoB,YAAY;cACzCD,aAAa,IAAIC;cACjB4oB,iBAAiB;gBAAEzoB,QAAQJ,WAAWI;;AACxC;YAEAE,YAAYvZ,KAAKyZ,YACf;cACEF,iBAAYzmB;cACZ,IAAImmB,YAAY;gBACdtkB,QAAQmD,MAAM,WAAW8K;gBACzB,IAAI5P,KAAK4uC,SACP5uC,KAAK4uC,QAAQ1/B,gBAAgBu/B,eAAe,cAAc7+B;gBAE5DqW,WAAWG;AACb,qBAAO;;;;gBAIL,IAAIpmB,KAAK4uC,cACF5uC,KAAK4uC,QAAQxnC,OAAO;gBAE3B,MAAM,IAAI7I,MAAM,WAAWqR;AAC7B;AAAA,gBAEFi/B,cAAcL,WAAW;YAG3B,MAAMhqC,iBAAiB0C,MAAM0I,KAAKk/B;YAClC,MAAMC,qBAAqBvqC,SAASwM;YAEpC0V,aAAaH;YACb,IAAIvmB,KAAK4uC,SACP5uC,KAAK4uC,QAAQ1/B,gBAAgBu/B,eAAe,YAAY7+B;YAG1D,OAAOm/B;AACT,YAAE,OAAOnhC;YACP,WAAW2Y,cAAc,UACvBG,aAAaH;YAGf,IAAIvmB,KAAK4uC,SACP5uC,KAAK4uC,QAAQ1/B,gBACXu/B,eAAe,WAAWD,WAAW,QAAQ5+B;YAIjD,MAAM4+B,YAAY,GAAG;cACnB7sC,QAAQmD,MAAM,kBAAkB8K,aAAa4+B;cAC7C,MAAM5gC;AACR;YAEA5N,KAAKkpC,gBAAgB;cAAEn8B,MAAM;cAASjI,OAAO8I;cAAG2gC,WAAW;;;wBAG3D,MAAMS,iBAAiBlmC,KAAKo9B,MAAMp9B,KAAKw5B,WAAWkM,WAAW;YAC7D7sC,QAAQ2M,IACN,kBAAkBsB,wBAAwBo/B;kBAEtC,IAAIxtC,SAAST,WAAY0lB,WAAW1lB,SAASiuC;AACrD;AACF;AACF;;MAMA,cAAMC,EAAS,OACR;cAMCjvC,KAAKkvC;QAEX,IAAIC,UAAUnvC,KAAKovC,YAAYnvC,IAAI4H;QACnC,KAAKsnC,SAAS;UACZ,MAAME,eAAeC,qBAAqB;YACxC3G,QAAQ3oC,KAAKsuC;YACbt9B,MAAMnJ,QAAQ;;UAEhB,KAAKwnC,cAAc;YACjBrvC,KAAKovC,YAAYjvC,IAAI0H,OAAO;YAC5B,OAAO;AACT;UACAsnC,UAAUE,aAAa1kC,MAAM,KAAKO,MAAM,GAAGL,IAAIsD;UAC/CnO,KAAKovC,YAAYjvC,IAAI0H,OAAOsnC;AAC9B;QAEA,MAAM1qC,SAAsC;QAE5C,KAAK,MAAM8qC,UAAUJ,SAAS;UAC5B,MAAMhjB,QAAQvlB,KAAKkiB,MACjB9oB,KAAKouC,SAASp3B,UAAUu4B,QAAQvvC,KAAKouC,SAAStjC,QAAQ,MAAMykC;UAG9D9qC,OAAOa,KACLkqC,uBAAuB;YAAErjB;YAAOsjB,cAAc5nC;YAAO0nC;;AAEzD;;gBAGA3V,mCAAgBn1B;QAChBA,OAAOsT,OAAO23B;QAEd,OAAOjrC;AACT;;MAMA,WAAAf,CAAYC;QACV,IAAI3D,KAAK4tC,UAAUrlC,SAAS5E,WAC1B;QAGF3D,KAAK4tC,UAAUtoC,KAAK3B;AACtB;MAEA,cAAAE,CAAeF;QACb3D,KAAK4tC,YAAY5tC,KAAK4tC,UAAU5uC,QAAQ84B,KAAMA,MAAMn0B;AACtD;MAEA,eAAAulC,CAAgB35B;QACd,MAAMs+B,gBAAgB7tC,KAAK4tC,UAAU1iC;QACrC,KAAK,MAAMvH,YAAYkqC,eACrBlqC,SAAS4L;AAEb;MAtLA,WAAAjR,CAAYyJ;QAPZ;QACA,6CAA6C;QAC7C;QACA,+CAAc,IAAI4nC,IAAAA,OAA8B;QAChD;QACA;QAGE3vC,KAAK4uC,UAAU7mC,QAAQ6mC;QACvB5uC,KAAKkvC,SAASlvC,KAAKmuC;AACrB;;;QAuLF,SAASmB,sBAAqB,QACtB;MAMN,MAAMM,OAAO5+B,KAAKrS;MAClB,IAAI+Y,QAAQ;MACZ,IAAI4hB,MAAcqP,OAAOhqC,SAAS;MAElC,OAAO+Y,QAAQ4hB,KAAK;QAClB,MAAMuW,WAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC9MtB,MAAMC;MAqBX,gBAAA/hC,CAAiBpK;QACf,KAAK3D,KAAK4tC,UAAUrlC,SAAS5E,WAC3B3D,KAAK4tC,UAAUtoC,KAAK3B;AAExB;MAEA,mBAAA0b,CAAoB1b;QAClB3D,KAAK4tC,YAAY5tC,KAAK4tC,UAAU5uC,QAAQ84B,KAAMA,MAAMn0B;AACtD;MAEA,cAAMwpC,EAAS,MAAM;QACnB;gBACQntC,KAAK+vC,gBAAgB;YAAE/oB;YAAMgpB,aAAa5C;;AAClD,UAAE,OAAOtoC;UACP9E,KAAKkpC,gBAAgBsE,YAAY;YAAE1oC;;AACrC;AACF;MAEA,cAAAuoC;QACE,KAAKrtC,KAAK8qC,eACR;QAGFlJ,sBAAsB;UAAE7gB,IAAI/gB,KAAK+gB;UAAKoG,QAAQnnB,KAAK8qC,cAAc3jB;;QACjEnnB,KAAK8qC,qBAAgBhrC;AACvB;MAEA,cAAMwtC;QACJ,IAAIttC,KAAK+gB,IACP;gBACQ/gB,KAAK+gB,GAAG6M;AAChB,UAAE,OAAO9oB;UACP9E,KAAKkpC,gBAAgBsE,YAAY;YAAE1oC;;AACrC;AAEJ;MAEA,gBAAMooC;QACJ,UAAUltC,KAAKiwC,iBACbjwC,KAAKkwC;AAET;;MAMA,YAAcC;QACZ,IAAIxQ,aAAa;QACjB,OAAO,MAAM;UACX,IAAI3/B,KAAK+gB,IACP;kBACQ/gB,KAAK+gB,GAAG6M;AAChB,YAAE;YACAjsB,QAAQ2M,IAAI;AACd;UAGF;YACEtO,KAAK+gB,KAAK,IAAIgU,UAAU;cAAEE,SAAS;;YACnCj1B,KAAK+gB,GAAG6U,kBAAkB51B,KAAKkwC;kBAEzBlwC,KAAK+gB,GAAGwU;YACd,OAAOv1B,KAAK+gB;AACd,YAAE,OAAOnT;YACP,IAAI+xB,cAAc,GAAG;cACnBh+B,QAAQ2M,IACN;cAEF,MAAMV;AACR;YACA+xB;YACAh+B,QAAQ2M,IACN,uDAAuDqxB;kBAEnDyQ,2BAA2B;cAAE5pB,SAAS;;AAC9C;AACF;AACF;MAEA,qBAAcupB,EAAgB,MACxB;QAMJ,WAAY/vC,KAAKiwC,iBACf;;gBAIF,IAAII,kBAAkB;QACtB,IAAIrwC,KAAK8qC,eAAe;;;UAGtB,IACE9qC,KAAK8qC,cAAc9jB,SAASA,SAC3BhnB,KAAK8qC,cAAckF,gBAAgBA,cAEpC;;;oBAKFK,kBAAkBrwC,KAAK8qC,cAAckF;UACrChwC,KAAKqtC;UACLrtC,KAAK8qC,qBAAgBhrC;AACvB;;;;;;;;;;;;;gBAcA,IAAIwwC,4BAA4B;;;;;;;;;;;UAgB9B,MAAMC,cACJvwC,KAAK+gB,MACL/gB,KAAK+gB,GAAG+L,MAAMxa,UAAU,QACxBtS,KAAK+gB,GAAG+L,MAAM1U,SAAS4O,SAASA,QAChChnB,KAAK+gB,GAAGgM,SAASza,UAAU,QAC3BtS,KAAK+gB,GAAGgM,SAAS3U,SAAS4O,SAASA,QACnChnB,KAAK+gB,GAAG6L,MAAMta,UAAU,QACxBtS,KAAK+gB,GAAG6L,MAAMxU,SAAS4O,SAASA;;;;;;;;;;;;;oBAelC,IAAIupB,aACF;YACEvwC,KAAKkpC,gBACHh6B,8BAAgB;cACdrO,SACE;;kBAGAb,KAAKmwC;AACb,YAAE,OAAOrrC;YACP9E,KAAKkpC,gBAAgBsE,YAAY;cAAE1oC;;AACrC;AAEJ;QAEA,MAAM47B,gBACHvZ,UACA9B;UACC,OAAM,OAAO,WAAW,cAAiBA;UACzC,IAAIqa,WAAW;YACb,MAAM8Q,WAAW9Q,UAAUvhC,YAAYD,KAAKyV;YAC5C3T,KAAKkpC,gBACHh6B,8BAAgB;cACdrO,SAAS,eAAeiE,MAAM3D,uBAAuBgmB,gCAAgCqpB;;;;;;;;wBAUzF,IAAI7Q,eAAe,GACjB3/B,KAAKkpC,gBAAgBsE,YAAY;cAAE1oC;cAAO6J,UAAU;;AAExD,iBAAO,IACL7J,MAAM3D,SAAS,gBACf2D,MAAM3D,SAAS,gBAEfnB,KAAKkpC,gBAAgBsE,YAAY;YAAE1oC;oBAEnC9E,KAAKkpC,gBACHh6B,8BAAgB;YACdrO,SAAS,uBAAuBsmB,+BAA+BriB,MAAM3D;;UAK3EnB,KAAKywC,kBAAkBhR,mBAAmBpa;UAC1CrlB,KAAKkwC;AAAuB;QAGhC,MAAMQ,gBAAgB;;UAEpB,IAAI1wC,KAAK8qC,eAAe;YACtB9qC,KAAKywC,uBAAkB3wC;YACvBE,KAAKkpC,gBACHh6B,8BAAgB;cACdrO,SAAS,wBAAwBb,KAAK8qC,cAAc3jB;;YAGxDnnB,KAAKkwC;AACP;;;;;;;;;;;;;oBAcA,KAAKlwC,KAAK8qC,eACR9qC,KAAK8qC,gBAAgB;YACnB9jB;YACAG,QAAQ;YACR6oB,aAAaA,eAAeK;kBAEzB,IAAIrwC,KAAK8qC,cAAc3jB,WAAW,SACvCnnB,KAAK8qC,cAAc3jB,SAAS,cACvB,IAAInnB,KAAK8qC,cAAc3jB,WAAW,SACvCnnB,KAAK8qC,cAAc3jB,SAAS,cACvB;YACLnnB,KAAK8qC,qBAAgBhrC;YACrBE,KAAKkpC,gBACHqE,uBAAuBoD,mBAAmB3wC,KAAK+gB;YAEjD;AACF;UAEA,IAAIivB,eAAeK,iBACjBhpB;eAEGkZ,gBAAgB;YACnBxf,IAAI/gB,KAAK+gB;YACToG,QAAQnnB,KAAK8qC,cAAc3jB;YAC3BH;YACAyZ,kBAAkBiQ;YAClBhQ,eAAeA,cAAc1gC,KAAK8qC,cAAc3jB;;AAChD;QAGJupB;AACF;MAEQ,qBAAAR;;;QAGN,KACGlwC,KAAK+gB,MACN/gB,KAAK+gB,GAAG6L,MAAMta,UAAU,UACxBtS,KAAK+gB,GAAG+L,MAAMxa,UAAU,UACxBtS,KAAK+gB,GAAGgM,SAASza,UAAU,UAC3BtS,KAAK+gB,GAAG8L,MAAMva,UAAU,QAExB;;gBAIF,MAAM6c,YAAYwhB,mBAAmB3wC,KAAK+gB;QAC1C,MAAMiU,cAAch1B,KAAK8qC,gBACrB9qC,KAAK+gB,GAAG/gB,KAAK8qC,cAAc3jB,QAAQ6N,cACnC;UAAEjoB,MAAM;UAAiBoiB;;QAE7B,MAAM7c,QAAqB;UACzBsa,OAAO;YACLta,OAAOtS,KAAK+gB,GAAG6L,MAAMta;YACrB8F,SAASpY,KAAK+gB,GAAG6L,MAAMxU;;UAEzB0U,OAAO;YACLxa,OAAOtS,KAAK+gB,GAAG+L,MAAMxa;YACrB8F,SAASpY,KAAK+gB,GAAG+L,MAAM1U;;UAEzB2U,UAAU;YACRza,OAAOtS,KAAK+gB,GAAGgM,SAASza;YACxB8F,SAASpY,KAAK+gB,GAAGgM,SAAS3U;;UAE5ByU,OAAO;YACLva,OAAOtS,KAAK+gB,GAAG8L,MAAMva;YACrB8F,SAASpY,KAAK+gB,GAAG8L,MAAMzU;;UAEzB4c;UACA4b,aAAa5wC,KAAKywC;;QAGpBzwC,KAAKkpC,gBAAgB7D,mCAAqB/yB;AAC5C;MAEQ,eAAA42B,CAAgBroC;QACtB,MAAMgtC,gBAAgB7tC,KAAK4tC,UAAU1iC;QACrC,KAAK,MAAMvH,YAAYkqC,eACrBlqC,SAAS9C;AAEb;MArUA,WAAAvC;QAbA,qCAAQ,WAAR;QACA,qCAAQ,wBAAR;QACA,qCAAQ,sBAAR;QAQA,qCAAQ,wBAAR;QACA,qCAAQ,aAAmC;QAGzC0B,KAAKkwC,wBAAwBlwC,KAAKkwC,sBAAsB1tC,KAAKxC;QAC7DA,KAAKiwC,kBAAkBjwC,KAAKmwC,SACzB7vC,MAAK,MAAM,OACX0E,OAAM,MAAM;AACjB;;IAmUF,SAAS2rC,mBAAmB5vB;MAC1B,MAAM8vB,sBAAsB/nC,KAAK8vB,IAAI12B,MACnC,MACAujB,mBAAmB5a,KAAKsc,UAAWpG,GAAGoG,QAAQ6N,YAAY7F;MAG5D,OAAO0hB,wBAAwB,IAAI,IAAI3yC,KAAK2yC,uBAAuB;AACrE;IAEA,SAASP;MACP,MAAMp8B,YAAYjH,UAAUiH;MAC5B,MAAM48B,uBAAuB,+BAA+BnlC,KAAKuI;MACjE,IAAI48B,wBAAwBA,qBAAqB,IAAI;QACnD,MAAM14B,UAAUxM,SAASklC,qBAAqB,IAAI;;gBAElD,OACE14B,WAAW,QAAQ04B,qBAAqB,OAAO,aAAa14B,UAAU;AAE1E;MACA,OAAO;AACT;;mBC5YO,MAAM24B,mBAAmB;;;;;;;;;sBAWzB,MAAMC,yBAAyB;;;;sBAM/B,MAAMC,qBAAqB;;;;sBAM3B,MAAMC,cAAc;;;sBAKpB,MAAMnkB,sBAAW;;;;;;;;;;;;;;;;;sBAmBjB,MAAMokB,sCACX;;sBAIK,MAAMtU,sBAAW;;sBAIjB,MAAMuU,WAAW;;;;QAKxB,MAAMC,gBAAgB;;;QAItB,MAAMC,iBAAiB;;QAGvB,MAAMC,WAAW;;QAGjB,MAAMC,WAAW;;QAGjB,MAAMC,kBAAkB;;sBAIjB,MAAM3kB,mBAAQ;;;;;;sBAQd,MAAM4kB,YAAY;;sBAIlB,MAAMC,wBAAwB;;sBAI9B,MAAMC,aAAa;IAEnB,SAASC,qBAAqBC;MACnC,IAAInJ,SAAS;MACb,IAAIoJ,QAAQ;MAEZ,KAAK,MAAMpY,SAASmY,QAAQ;;QAE1B,KAAKE,sBAAsBrY,QACzB,MAAM,IAAIp7B,MAAM,0CAA0Co7B,MAAMgP;;gBAIlE,IAAIhP,MAAMgP,OAAO,OAAO,KACtB,MAAM,IAAIpqC,MACR,qDAAqDo7B,MAAMgP;QAI/DA,UAAUhP,MAAMgP,OAAO3xB,UAAU,GAAG2iB,MAAMgP,OAAOhqC,SAAS;QAC1D,IAAIg7B,MAAMoY,MAAMjnC,QAAQ,UAAU,GAChCinC,QAAQ;AAEZ;MAEApJ,UAAU;MAEV,OAAO,IAAIl7B,OAAOk7B,QAAQoJ;AAC5B;;;QAIA,SAASC,sBAAsBC;MAC7B,OACEA,GAAGtJ,OAAOhqC,UAAU,KACpBszC,GAAGtJ,OAAO14B,WAAW,QACrBgiC,GAAGtJ,OAAOuJ,SAAS;AAEvB;;;;sBAMO,MAAMC,eAAeN,qBAAqB;;IAE/Cd,kBACAC,wBACAC,oBACAC,aACAnkB,qBACAokB,qCACAtU,qBACAuU,UACAC,eACAC,gBACAC,UACAC,UACAC,iBACA3kB,kBACA4kB,WACAC,uBACAC;IAGK,SAASQ,oBAAoBzY;;MAElC,KAAKqY,sBAAsBrY,QACzB,MAAM,IAAIp7B,MAAM,0CAA0Co7B,MAAMgP;MAGlE,MAAM0J,UAAU1Y,MAAMgP,OAAO,OAAO;MAEpC,MAAMA,SAAS,IAAI0J,UAAU,KAAK,MAAM1Y,MAAMgP,OAAO3xB,UACnDq7B,UAAU,IAAI,GACd1Y,MAAMgP,OAAOhqC,SAAS;MAGxB,OAAO,IAAI8O,OAAOk7B,QAAQhP,MAAMoY;AAClC;IAE+BK,oBAAoBD;;;;;;;IC/KnD,MAAMG,YAAY,EAChB,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ,QAChE,QAAQ;;QAGV,MAAMC,SAAS,EAAC,QAAQ,QAAQ;IAEzB,SAASC,WAAW3qC;MACzB,MAAMlJ,SAAS,KAAIkJ,QAAOlJ;MAC1B,OACEA,SAAS,KACT4zC,OAAOhqC,SAASV,MAAM4b,YAAY9kB,SAAS,OAC3C2zC,UAAU/pC,SAASV,MAAM4b,YAAY9kB,SAAS;AAElD;;ICNOgjB,eAAe8wB,YAAW,aACpB,OACN,cACO,gBACE;MASd,MAAMhuC,SAA2B;QAC/BsI,MAAM;QACNkhC,MAAM;QACNyE,MAAM;QACNC,UAAU;;;YAIZ,MAAMC,gBAAgB,IAAIr8B;;;YAI1B,MAAMs8B,OAAO,IAAIp8B;MAEjB,IAAIq8B,gBAAgBjrC;MAEpB,OAAOirC,cAAcn0C,SAAS,GAAG;;QAE/B,IAAIo0C,aAAanrB,SACf,MAAM,IAAIxC;QAGZ,MAAM4tB,qBAAqBpuB,aAAakuB,cAAcn0C;QACtD,IAAIs0C,kBAAkBA,iBAAiBD,oBACrC;;gBAIF,IAAIE,aAAarrC,QACf;;gBAIF,MAAMsrC,aAAa,EAACL,kBAAkBjwB,YAAYiwB;;gBAGlD,MAAMM,QAAQzvB,qBAAqBmvB;QACnC,IAAIM,UAAUN,eACZK,WAAW7tC,KAAK8tC;QAGlB,KAAK,MAAM5U,WAAW2U,YAAY;UAChC,IAAItmB;UACJ;YACEA,cAAc2S,SAAShB;AACzB,YAAE,OAAO5wB;YACPjM,QAAQmD,MAAM,0BAA0B8I;iBACnC2L,QAAQnS,OAAOwG,KAAK;YACzB,OAAO;AACT;;oBAGAif,QAAQA,MAAM7tB,QAAQmC,SAAU0xC,KAAK3yC,IAAIiB,KAAK/B;UAC9C,KAAKytB,MAAMluB,QACT;UAGF8F,OAAOkuC,WAAW7pC,KAAK8vB,IAAIn0B,OAAOkuC,UAAUK;UAE5C,KAAK,MAAM7xC,QAAQ0rB,OAAO;YACxBgmB,KAAK75B,IAAI7X,KAAK/B;;;wBAId,MAAMi0C,eAAeC,iBAAiBnyC;;wBAGtC,MAAMoyC,gBAAgBX,cAAc3yC,IAAIozC;YACxC,WAAWE,kBAAkB,aAAa;cACxC,MAAMC,gBAAgB/uC,OAAOwpC,KAAKsF;cAClC,IAAIpyC,KAAKia,GAAG;gBACV,KAAKo4B,cAAcp4B,GACjBo4B,cAAcp4B,IAAI;gBAEpBo4B,cAAcp4B,EAAE9V,QAAQnE,KAAKia;AAC/B;AACF,mBAAO;cACL3W,OAAOwpC,KAAK3oC,KAAK;mBAAKnE;gBAAMwxC,UAAUK;;cACtCJ,cAAczyC,IAAIkzC,cAAc5uC,OAAOwpC,KAAKtvC,SAAS;AACvD;YAEA,IAAI8F,OAAOwpC,KAAKtvC,UAAU+wC,YACxB,OAAOjrC;AAEX;;;uDAKF;;;gBAGA,MAAMgvC,kBAAkBjB,WAAWM,iBAAiB,IAAI;QACxDA,gBAAgBA,cAAcY,OAC5B,GACAZ,cAAcn0C,SAAS80C;AAE3B;MAEA,KAAKhvC,OAAOwpC,KAAKtvC,QACf,OAAO;MAGT,OAAO8F;AACT;IAEA,SAAS6uC,iBAAiBnyC;MACxB,OACEA,KAAK2Z,EAAEzP,KAAK,OACZ,MACAlK,KAAKqwB,GACF3mB,KACE2mB,MACC,IAAIA,GAAGzkB,QAAQ,IAAI1B,KAAK,QAAQmmB,GAAGJ,IAAI/lB,KAAK,OAAO,GAAhD;;;;ICnIb,MAAMsoC,eAAwC,EAC5C,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,SACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,SACN,EAAC,UAAK,SACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,OACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,QACP,EAAC,gBAAM,QACP,EAAC,gBAAM,QACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,QACP,EAAC,gBAAM,QACP,EAAC,gBAAM,QACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,UAAK,QACN,EAAC,gBAAM,SACP,EAAC,gBAAM,SACP,EAAC,gBAAM;;;;;IAMP,E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"}