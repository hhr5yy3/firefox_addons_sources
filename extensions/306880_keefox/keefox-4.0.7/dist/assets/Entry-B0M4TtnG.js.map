{"version":3,"file":"Entry-B0M4TtnG.js","sources":["../../../src/common/model/SessionType.ts","../../../src/common/model/EntrySummary.ts","../../../src/common/model/Group.ts","../../../src/common/model/Database.ts","../../../src/common/model/Locator.ts","../../../src/common/model/KPRPCDTOs.ts","../../../src/common/model/Field.ts","../../../src/common/model/GroupSummary.ts","../../../src/common/model/Entry.ts"],"sourcesContent":["export enum SessionType {\n    Event = \"event\",\n    Websocket = \"websocket\"\n}\n","import { Entry } from \"./Entry\";\nimport { Icon } from \"./Icon\";\nimport { utils } from \"../utils\";\nimport { EntrySummaryDto } from \"./KPRPCDTOs\";\n\nexport class EntrySummary {\n    icon: Icon;\n    usernameValue: string;\n    usernameName: string;\n    path: string;\n    title: string;\n    uRLs: string[];\n    url: string;\n    uuid: string;\n    dbFileName: string;\n    relevanceScore: number;\n    fullDetails?: Entry; //TODO:5: remove circular reference by maintaining independent Entry lookup by uuid?\n    isPreferredMatch?: boolean;\n\n    constructor(e: Partial<EntrySummary>) {\n        this.icon = e.icon || { version: 1, iconImageData: \"\" };\n        this.usernameValue = e.usernameValue || \"<no username>\";\n        this.usernameName = e.usernameName || \"<no username>\";\n        this.path = e.path || \"UNKNOWN PATH\";\n        this.title = e.title || \"\";\n        this.uRLs = e.uRLs || [];\n        this.url = e?.url || \"\";\n        this.uuid = e.uuid || utils.newGUID();\n        this.dbFileName = e.dbFileName || \"\";\n        this.relevanceScore = e.relevanceScore;\n        this.fullDetails = e.fullDetails;\n        this.isPreferredMatch = e.isPreferredMatch;\n    }\n\n    public static fromEntry(entry: Entry) {\n        return new EntrySummary({\n            icon: entry.icon,\n            usernameValue: Entry.getUsernameField(entry)?.value,\n            usernameName: Entry.getUsernameField(entry)?.name,\n            title: entry.title,\n            uRLs: entry.URLs,\n            url: entry?.URLs[0],\n            uuid: entry.uuid,\n            dbFileName: entry.database.fileName,\n            fullDetails: entry,\n            isPreferredMatch: entry.isPreferredMatch\n        });\n    }\n\n    public static fromKPRPCEntrySummaryDTO(\n        entrySummaryDto: EntrySummaryDto,\n        path: string,\n        dbFileName: string\n    ) {\n        return new EntrySummary({\n            icon: { version: 1, iconImageData: entrySummaryDto.iconImageData },\n            usernameValue: entrySummaryDto.usernameValue,\n            usernameName: entrySummaryDto.usernameName,\n            path,\n            title: entrySummaryDto.title,\n            uRLs: entrySummaryDto.uRLs,\n            url: entrySummaryDto?.uRLs[0],\n            uuid: entrySummaryDto.uniqueID,\n            dbFileName\n        });\n    }\n}\n","import { EntrySummary } from \"./EntrySummary\";\nimport { Icon } from \"./Icon\";\nimport { utils } from \"../utils\";\nimport { GroupDto } from \"./KPRPCDTOs\";\n\nexport class Group {\n    readonly title: string;\n    readonly uuid: string;\n    readonly icon: Icon;\n    readonly path: string;\n    readonly entrySummaries: EntrySummary[];\n    readonly groups: Group[];\n    //childEntries: Entry[] - this is only needed if we ever request GetAllDatabases(true) but Kee currently has no need for this KPRPC feature\n\n    constructor(g: Partial<Group>) {\n        this.title = g.title || \"\";\n        this.uuid = g.uuid || utils.newGUID();\n        this.icon = g.icon || { version: 1, iconImageData: \"\" };\n        this.path = g.path || \"UNKNOWN PATH\";\n        this.entrySummaries = g.entrySummaries || [];\n        this.groups = g.groups || [];\n    }\n\n    public static fromKPRPCGroupDTO(groupDto: GroupDto, dbFileName: string) {\n        return new Group({\n            title: groupDto.title,\n            uuid: groupDto.uniqueID,\n            icon: { version: 1, iconImageData: groupDto.iconImageData },\n            path: groupDto.path,\n            entrySummaries: groupDto.childLightEntries.map(childLightEntry =>\n                EntrySummary.fromKPRPCEntrySummaryDTO(childLightEntry, groupDto.path, dbFileName)\n            ),\n            groups: groupDto.childGroups.map(childGroup =>\n                this.fromKPRPCGroupDTO(childGroup, dbFileName)\n            )\n        });\n    }\n\n    public static containsId(group: Group, id: string) {\n        if (group.uuid === id) return true;\n        if (group.groups && group.groups.some(g => Group.containsId(g, id))) return true;\n        return false;\n    }\n    public static matchingId(group: Group, id: string): Group | null {\n        if (group.uuid === id) {\n            return group;\n        }\n\n        for (const childGroup of group.groups) {\n            const matchingChildGroup = Group.matchingId(childGroup, id);\n            if (matchingChildGroup) {\n                return matchingChildGroup;\n            }\n        }\n\n        return null;\n    }\n\n}\n","import { SessionType } from \"./SessionType\";\nimport { DatabaseDto } from \"./KPRPCDTOs\";\nimport { Icon } from \"./Icon\";\nimport { Group } from \"./Group\";\n\nexport class Database {\n    name: string;\n    fileName: string;\n    icon: Icon;\n    root: Group;\n    active: boolean;\n    sessionType: SessionType;\n    sessionFeatures: string[];\n\n    constructor(db: Partial<Database>) {\n        this.name = db.name || \"\";\n        this.fileName = db.fileName || \"\";\n        this.icon = db.icon || { version: 1, iconImageData: \"\" };\n        this.root = db.root || new Group({});\n        this.active = db.active || false;\n        this.sessionType = db.sessionType || SessionType.Event;\n        this.sessionFeatures = db.sessionFeatures || [\"\"];\n    }\n\n    public static fromKPRPCDatabaseDTO(\n        dto: DatabaseDto,\n        sessionType: SessionType,\n        sessionFeatures: string[]\n    ) {\n        return new Database({\n            name: dto.name,\n            fileName: dto.fileName,\n            icon: { version: 1, iconImageData: dto.iconImageData },\n            root: Group.fromKPRPCGroupDTO(dto.root, dto.fileName),\n            active: dto.active,\n            sessionType,\n            sessionFeatures\n        });\n    }\n}\n","export class Locator {\n    // HTML id attribute\n    id: string;\n\n    // HTML name attribute\n    name: string;\n\n    // HTML input type\n    type: string;\n\n    // HTML DOM select query\n    query?: string;\n\n    // Visible and accessibility labels\n    labels?: string[];\n\n    // Any autocomplete values we found, or require, in the DOM\n    autocompleteValues?: string[];\n\n    constructor(locator: Partial<Locator>) {\n        this.id = locator.id || \"\";\n        this.name = locator.name || \"\";\n        this.type = locator.type || \"\";\n        this.query = locator.query;\n        this.labels = locator.labels;\n        this.autocompleteValues = locator.autocompleteValues;\n    }\n\n    //TODO:5: Things like MaxLength that can be used to both help identify the field and generate new values/passwords\n}\n","import { SessionType } from \"./SessionType\";\n\nexport class PasswordProfileDto {\n    name: string;\n    sessionType: SessionType;\n}\n\nexport class DatabaseDto {\n    name: string;\n    fileName?: string;\n    iconImageData: string;\n    root: GroupDto;\n    active?: boolean;\n}\n\nexport class DatabaseSummaryDto {\n    name: string;\n    fileName?: string;\n    iconImageData: string;\n    root: GroupSummaryDto;\n    active?: boolean;\n}\n\nexport class GroupSummaryDto {\n    title: string;\n    uniqueID: string;\n    iconImageData: string;\n    path: string;\n}\n\nexport class GroupDto {\n    title: string;\n    uniqueID: string;\n    iconImageData: string;\n    path: string;\n    childLightEntries: EntrySummaryDto[];\n    childGroups: GroupDto[];\n    //childEntries: EntryDto[] - this is only needed if we ever request GetAllDatabases(true) but Kee currently has no need for this KPRPC feature\n}\n\nexport enum PlaceholderHandling {\n    Default = \"Default\",\n    Enabled = \"Enabled\",\n    Disabled = \"Disabled\"\n}\n\nexport enum MatchAccuracyEnum {\n    // Best = Non-URL match (i.e. we matched by UUID instead)\n    // Best = Regex match (it is impossible for us to infer how\n    // accurate a regex match is in comparison with other classes\n    // of match so we always treat it as the best possible match\n    // even if the regex itself is very loose)\n    // Best = Same URL including query string\n\n    // Close = Same URL excluding query string\n\n    // HostnameAndPort = Same hostname and port\n\n    // Hostname = Same hostname (domain + subdomains)\n\n    // Domain = Same domain\n\n    // None = No match (e.g. when we are being asked to return all entries)\n\n    Best = 50,\n    Close = 40,\n    HostnameAndPort = 30,\n    Hostname = 20,\n    Domain = 10,\n    None = 0\n}\n\nexport class EntryDto {\n    db: DatabaseDto;\n    parent: GroupSummaryDto;\n    iconImageData: string;\n    alwaysAutoFill: boolean;\n    alwaysAutoSubmit: boolean;\n    neverAutoFill: boolean;\n    neverAutoSubmit: boolean;\n    priority: number;\n    uRLs: string[];\n    matchAccuracy: number;\n    hTTPRealm: string;\n    uniqueID: string;\n    title: string;\n    formFieldList: FieldDto[];\n}\n\nexport class EntrySummaryDto {\n    iconImageData: string;\n    uRLs: string[];\n    uniqueID: string;\n    title: string;\n    usernameValue: string;\n    usernameName: string;\n}\n\n// tslint:disable-next-line:class-name\nexport class FieldDto {\n    displayName: string;\n\n    // \"name\" attribute on the HTML form element\n    name: string;\n\n    // \"value\" attribute on the HTML form element\n    value: string;\n\n    // \"id\" attribute on the HTML form element\n    id: string;\n\n    // \"type\" attribute on the HTML form element\n    type: FormFieldTypeDTO;\n\n    page: number;\n}\n\nexport enum FormFieldTypeDTO {\n    radio = \"FFTradio\",\n    username = \"FFTusername\",\n    text = \"FFTtext\",\n    password = \"FFTpassword\",\n    select = \"FFTselect\",\n    checkbox = \"FFTcheckbox\"\n}\n","import { utils } from \"../utils\";\nimport { Locator } from \"./Locator\";\nimport { FieldDto, FormFieldTypeDTO } from \"./KPRPCDTOs\";\n\nexport type FieldType = \"password\" | \"text\" | \"existing\" | \"boolean\" | \"otp\" | \"some-chars\";\n\nexport class Field {\n    // Unique ID that we can use to help UI operations and identification when there is no known name for this field.\n    // Also may be useful in future for multiple-page reconfiguration or per-browser field configuration overrides?\n    readonly uuid: string;\n\n    // visual identifier for the field. May be specified by the user or inferred from\n    // either default Entry data (username/password/OTP) or form field label or name attribute\n    readonly name: string;\n\n    // The value we'll fill into the form.\n    // For existing determines which option to activate.\n    // For boolean determines whether to activate or deactivate (to ignore, delete the field record)\n    // For OTP, need to work out whether we will have to transfer the secrets and recalculate in the browser or just treat as standard value\n    readonly value: string;\n\n    // type of data this field represents. There's no 100% way to match this to the type of HTML form element but it's often logical.\n    // E.g. password goes into password fields unless user explicitly re-configures that; existing would typically match something\n    // like a radio button or select option already present on the HTML form; boolean would match a checkbox.\n    readonly type: FieldType;\n\n    // How we can find the correct target in the HTML.\n    readonly locators: Locator[];\n\n    // tracks the most recent value we want to reset to in cases where the user has that possibility\n    readonly resetValue: string;\n\n    constructor(field: Partial<Field>) {\n        this.name = field.name || \"\";\n        this.value = field.value || \"\";\n        this.resetValue = field.resetValue || \"\";\n        this.uuid = field.uuid || utils.newGUID();\n        this.type = field.type || \"text\";\n        this.locators = field.locators || [];\n    }\n\n    private static getDisplayValueInternal(\n        field: Field,\n        revealPasswords: boolean,\n        replacementIfProtected: string\n    ) {\n        if (field.type === \"boolean\") {\n            return field.value === \"KEEFOX_CHECKED_FLAG_TRUE\" ? $STR(\"enabled\") : $STR(\"disabled\");\n        } else {\n            return field.type === \"password\" && !revealPasswords\n                ? replacementIfProtected\n                : field.value;\n        }\n    }\n\n    static getDisplayValue(field: Field, revealPasswords: boolean) {\n        return Field.getDisplayValueInternal(\n            field,\n            revealPasswords,\n            \"*\".repeat(field.value.length)\n        );\n    }\n\n    static getDisplayName(field: Field) {\n        if (field.name === \"KeePass username\") {\n            return $STR(\"username\");\n        } else if (field.name === \"KeePass password\") {\n            return $STR(\"password\");\n        } else {\n            return field.name ? field.name : \"[ \" + $STR(\"no_name\") + \" ]\";\n        }\n    }\n\n    static getDisplayTooltip(field: Field, revealPasswords: boolean) {\n        return (\n            Field.getDisplayName(field) +\n            \": \" +\n            Field.getDisplayValueInternal(field, revealPasswords, $STR(\"click_to_reveal_hide\"))\n        );\n    }\n\n    static typeFromDOMtype(domType: string): FieldType {\n        // We can't know every type that may exist in future so assume:\n        // 1. unknown types must be text\n        // 2. we won't be asked to handle types for irrelevant elements such as buttons\n        switch (domType) {\n            case \"password\":\n                return \"password\";\n            case \"radio\":\n                return \"existing\";\n            case \"checkbox\":\n                return \"boolean\";\n            case \"select-one\":\n                return \"existing\";\n            default:\n                return \"text\";\n        }\n    }\n\n    // By convention the first non-password item will be the username and the password will be either 1st or 2nd in the list\n    static combineDomFieldLists(usernameIndex: number, otherFields: Field[], passwords: Field[]) {\n        const fields: Field[] = [];\n        if (usernameIndex >= 0 && otherFields[usernameIndex]) {\n            fields.push(otherFields[usernameIndex]);\n        }\n        passwords.forEach(f => {\n            fields.push(f);\n        });\n        otherFields.forEach((f, index) => {\n            if (index !== usernameIndex) {\n                fields.push(f);\n            }\n        });\n        return fields;\n    }\n\n    static fromDOM(element: any, domType: string, value: string) {\n        const labels = collectLabels(element);\n        return new Field({\n            uuid: utils.newGUID(),\n            name: labels && labels.length ? labels[0] : element.name,\n            locators: [\n                new Locator({\n                    name: element.name,\n                    id: element.id,\n                    type: domType,\n                    labels,\n                    autocompleteValues: collectAutocompleteValues(element)\n                })\n            ],\n            value,\n            type: Field.typeFromDOMtype(domType)\n        });\n    }\n\n    static fromKPRPCFieldDTO(f: FieldDto) {\n        let type: FieldType = \"text\";\n        let locatorType = \"text\";\n\n        switch (f.type) {\n            case FormFieldTypeDTO.password:\n                type = \"password\";\n                locatorType = \"password\";\n                break;\n            case FormFieldTypeDTO.radio:\n                type = \"existing\";\n                locatorType = \"radio\";\n                break;\n            case FormFieldTypeDTO.checkbox:\n                type = \"boolean\";\n                locatorType = \"checkbox\";\n                break;\n            case FormFieldTypeDTO.select:\n                type = \"existing\";\n                locatorType = \"select\";\n                break;\n            case FormFieldTypeDTO.username:\n                type = \"text\";\n                locatorType = \"text\";\n                break;\n            case FormFieldTypeDTO.text:\n                type = \"text\";\n                locatorType = \"text\";\n                break;\n        }\n\n        return new Field({\n            name: f.displayName || f.name,\n            uuid: utils.newGUID(),\n            value: f.value,\n            resetValue: f.value,\n            type: type,\n            locators: [\n                new Locator({\n                    id: f.id,\n                    name: f.name,\n                    type: locatorType\n                })\n            ]\n        });\n    }\n\n    static toKPRPCFieldDTO(f: Field, isUsername: boolean) {\n        let fft: FormFieldTypeDTO;\n\n        switch (f.locators[0].type) {\n            case \"password\":\n                fft = FormFieldTypeDTO.password;\n                break;\n            case \"radio\":\n                fft = FormFieldTypeDTO.radio;\n                break;\n            case \"checkbox\":\n                fft = FormFieldTypeDTO.checkbox;\n                break;\n            case \"select-one\":\n                fft = FormFieldTypeDTO.select;\n                break;\n            default:\n                fft = isUsername ? FormFieldTypeDTO.username : FormFieldTypeDTO.text;\n                break;\n        }\n\n        return {\n            displayName: f.name,\n            id: f.locators[0].id,\n            name: f.locators[0].name,\n            type: fft,\n            value: f.value,\n            page: -1\n        } as FieldDto;\n    }\n}\n\n// Might be other element types but main thing is they have the labels property\nfunction collectLabels(element: HTMLInputElement | HTMLSelectElement) {\n    const labels: string[] = [];\n    const labelsCount = element.labels?.length || 0;\n    for (let i = 0; i < labelsCount; i++) {\n        const label = element.labels[i];\n        if (label?.innerText) labels.push(label.innerText);\n    }\n    const ariaLabel = element.getAttribute(\"aria-label\")?.toLowerCase();\n    if (ariaLabel) labels.push(ariaLabel);\n    const ariaLabelIds: string[] = [];\n    element\n        .getAttribute(\"aria-labelledby\")\n        ?.trim()\n        .split(\" \")\n        .forEach(id => {\n            if (id) ariaLabelIds.push(id);\n        });\n    element\n        .getAttribute(\"aria-describedby\")\n        ?.trim()\n        .split(\" \")\n        .forEach(id => {\n            if (id) ariaLabelIds.push(id);\n        });\n    ariaLabelIds.forEach(id => {\n        const labelElement = document.getElementById(id);\n        if (labelElement?.innerText) labels.push(labelElement.innerText);\n    });\n    return labels.length ? labels : undefined;\n}\n\nfunction collectAutocompleteValues(element: HTMLInputElement | HTMLSelectElement) {\n    const values: string[] = [];\n    element.attributes[\"autocomplete\"]?.value\n        ?.trim()\n        .split(\" \")\n        .forEach(v => {\n            if (v) values.push(v.toLowerCase());\n        });\n    return values.length ? values : undefined;\n}\n","import { Icon } from \"./Icon\";\nimport { utils } from \"../utils\";\nimport { GroupSummaryDto } from \"./KPRPCDTOs\";\nimport { Group } from \"./Group\";\n\nexport class GroupSummary {\n    readonly title: string;\n    readonly uuid: string;\n    readonly icon: Icon;\n    readonly path: string;\n\n    constructor(g: Partial<GroupSummary>) {\n        this.title = g.title || \"\";\n        this.uuid = g.uuid || utils.newGUID();\n        this.icon = g.icon || { version: 1, iconImageData: \"\" };\n        this.path = g.path || \"UNKNOWN PATH\";\n    }\n\n    public static fromKPRPCGroupSummaryDTO(groupSummaryDto: GroupSummaryDto) {\n        return new GroupSummary({\n            title: groupSummaryDto.title,\n            uuid: groupSummaryDto.uniqueID,\n            icon: { version: 1, iconImageData: groupSummaryDto.iconImageData },\n            path: groupSummaryDto.path\n        });\n    }\n\n    public static fromGroup(group: Group) {\n        return new GroupSummary({\n            title: group.title,\n            uuid: group.uuid,\n            icon: group.icon,\n            path: group.path\n        });\n    }\n}\n\nexport const TemporaryIDString =\n    \"TEMPORARY ID TO IDENTIFY THIS AS A DIRTY ENTRY THAT DOESN'T EXIST IN SOURCE DATABASE YET\";\n","import { Icon } from \"./Icon\";\nimport { Database } from \"./Database\";\nimport { utils } from \"../utils\";\nimport { Field } from \"./Field\";\nimport { EntryDto, FormFieldTypeDTO } from \"./KPRPCDTOs\";\nimport { DatabaseSummary } from \"./DatabaseSummary\";\nimport { GroupSummary } from \"./GroupSummary\";\n\n// Although we use uuids for Fields and possibly Locators, we don't allow them to exist outside of their parent entry.\n\nexport class Entry {\n    // array of URL strings (normally just one is needed\n    // but a given entry can be associated with more than one site\n    // or with multiple pages on that site)\n    readonly URLs: string[];\n\n    // How accurate is the best URL match for this entry (only set if entry\n    // was supplied in response to certain search requests). Higher = closer match\n    readonly matchAccuracy: number;\n\n    // The realm of a HTTP authentication request\n    readonly httpRealm: string;\n\n    // The index of the otherField which we will treat as the username in KeePass\n    // readonly usernameIndex: number;\n\n    readonly fields: Field[];\n\n    // The KeePass entry's uniqueID (if known)\n    readonly uuid: string;\n\n    // The title of the KeePass entry (auto-generated from the page title by default,\n    // or the page URL's hostname if no title is set)\n    readonly title: string;\n\n    readonly icon: Icon;\n\n    readonly parentGroup: GroupSummary;\n\n    readonly alwaysAutoFill: boolean;\n    readonly alwaysAutoSubmit: boolean;\n    readonly neverAutoFill: boolean;\n    readonly neverAutoSubmit: boolean;\n\n    readonly database: DatabaseSummary;\n\n    // How relevant this entry is to the current form in\n    // the browser - transient (not stored in KeePass)\n    //TODO:5 put all match data into a new object?\n    relevanceScore: number;\n    lowFieldMatchRatio: any;\n    formIndex: number;\n    entryIndex: number;\n    isPreferredMatch?: boolean;\n\n    constructor(e: Partial<Entry>) {\n        this.alwaysAutoFill = e.alwaysAutoFill || false;\n        this.alwaysAutoSubmit = e.alwaysAutoSubmit || false;\n        this.neverAutoFill = e.neverAutoFill || false;\n        this.neverAutoSubmit = e.neverAutoSubmit || false;\n        this.URLs = e.URLs || [];\n        this.fields = e.fields || [];\n        this.httpRealm = e.httpRealm || \"\";\n        this.parentGroup = e.parentGroup || null;\n        this.uuid = e.uuid || utils.newGUID();\n        this.title = e.title || \"\";\n        this.matchAccuracy = e.matchAccuracy || 0;\n        this.icon = e.icon || { version: 1, iconImageData: \"\" };\n        this.database = e.database || new Database({});\n        this.relevanceScore = e.relevanceScore;\n        this.lowFieldMatchRatio = e.lowFieldMatchRatio;\n        this.formIndex = e.formIndex;\n        this.entryIndex = e.entryIndex;\n        this.isPreferredMatch = e.isPreferredMatch;\n    }\n\n    public static getUsernameField(entry: Entry) {\n        return entry.fields.find(f => f.type === \"text\");\n    }\n    public static getPasswordField(entry: Entry) {\n        return entry.fields.find(f => f.type === \"password\");\n    }\n\n    public static fromKPRPCEntryDTO(entryDto: EntryDto, db: DatabaseSummary) {\n        const sortedFields: Field[] = [];\n        let maximumPage = 1;\n        const usernameIndex = entryDto.formFieldList.findIndex(\n            f => f.type === FormFieldTypeDTO.username\n        );\n\n        const unsortedFields = entryDto.formFieldList.map(f => {\n            if (f.page > maximumPage) maximumPage = f.page;\n\n            return Field.fromKPRPCFieldDTO(f);\n        });\n        const firstPasswordIndex = unsortedFields.findIndex(f => f.type === \"password\");\n\n        if (usernameIndex > -1) {\n            sortedFields.push(unsortedFields[usernameIndex]);\n        }\n        if (firstPasswordIndex > -1) {\n            sortedFields.push(unsortedFields[firstPasswordIndex]);\n        }\n        unsortedFields.forEach((f, i) => {\n            if (i !== usernameIndex && i !== firstPasswordIndex) {\n                sortedFields.push(f);\n            }\n        });\n\n        const entry = new Entry({\n            URLs: entryDto.uRLs,\n            neverAutoFill: entryDto.neverAutoFill,\n            alwaysAutoFill: entryDto.alwaysAutoFill,\n            neverAutoSubmit: entryDto.neverAutoSubmit,\n            alwaysAutoSubmit: entryDto.alwaysAutoSubmit,\n            icon: { version: 1, iconImageData: entryDto.iconImageData },\n            parentGroup: GroupSummary.fromKPRPCGroupSummaryDTO(entryDto.parent),\n            database: db,\n            matchAccuracy: entryDto.matchAccuracy,\n            httpRealm: entryDto.hTTPRealm,\n            uuid: entryDto.uniqueID,\n            title: entryDto.title,\n            fields: sortedFields\n        });\n\n        return entry;\n    }\n\n    public static toKPRPCEntryDTO(entry: Entry) {\n        const entryDto = new EntryDto();\n        entryDto.alwaysAutoFill = entry.alwaysAutoFill;\n        entryDto.alwaysAutoSubmit = entry.alwaysAutoSubmit;\n        entryDto.formFieldList = entry.fields.map((f, i) => Field.toKPRPCFieldDTO(f, i === 0));\n        entryDto.hTTPRealm = entry.httpRealm;\n        entryDto.iconImageData = entry.icon.iconImageData;\n        entryDto.neverAutoFill = entry.neverAutoFill;\n        entryDto.neverAutoSubmit = entry.neverAutoSubmit;\n        entryDto.title = entry.title;\n        entryDto.uRLs = entry.URLs;\n        return entryDto;\n    }\n}\n"],"names":["SessionType","FormFieldTypeDTO"],"mappings":"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"}