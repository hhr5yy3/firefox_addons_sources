(()=>{"use strict";var __webpack_modules__={7584:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{b:()=>loadTranslator});const loadTranslator=code=>{const translatorClass=eval(code);if("function"!=typeof translatorClass)throw new TypeError("Type of object must be callable");let instance;try{instance=new translatorClass}catch(e){throw console.error(e),new Error("Error while create instance of translator")}const requiredMethods=["translate","translateBatch","getLengthLimit"];requiredMethods.forEach((e=>{if(!(e in instance))throw new TypeError(`Translator method "${e}" is not defined`);if("function"!=typeof instance[e])throw new TypeError(`Translator instance member "${e}" is not a function`)}));const requiredStaticMethods=["isSupportedAutoFrom","getSupportedLanguages"];return requiredStaticMethods.forEach((e=>{if(!(e in translatorClass))throw new TypeError(`Translator static method "${e}" is not defined`);if("function"!=typeof translatorClass[e])throw new TypeError(`Translator static member "${e}" is not a function`)})),translatorClass}}},__webpack_module_cache__={};function __webpack_require__(e){var r=__webpack_module_cache__[e];if(void 0!==r)return r.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(e,r)=>{for(var t in r)__webpack_require__.o(r,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},__webpack_require__.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r);var __webpack_exports__={};(()=>{var e,r,t,n,o,a,s;(s=e||(e={})).Call="call",s.Reply="reply",s.Syn="syn",s.SynAck="synAck",s.Ack="ack",function(e){e.Fulfilled="fulfilled",e.Rejected="rejected"}(r||(r={})),(a=t||(t={})).ConnectionDestroyed="ConnectionDestroyed",a.ConnectionTimeout="ConnectionTimeout",a.NoIframeSrc="NoIframeSrc",function(e){e.DataCloneError="DataCloneError"}(n||(n={})),(o||(o={})).Message="message";const i=({name:e,message:r,stack:t})=>({name:e,message:r,stack:t});let c=0;const l=()=>++c,d=e=>e?e.split("."):[],u=(e,r,t)=>{const n=d(r);return n.reduce(((e,r,o)=>(void 0===e[r]&&(e[r]={}),o===n.length-1&&(e[r]=t),e[r])),e),e},p=(e,r)=>{const t={};return Object.keys(e).forEach((n=>{const o=e[n],a=((e,r)=>{const t=d(r||"");return t.push(e),(e=>e.join("."))(t)})(n,r);"object"==typeof o&&Object.assign(t,p(o,a)),"function"==typeof o&&(t[a]=o)})),t},_=(n,a,s,i,c)=>{const{localName:d,local:p,remote:_,originForSending:g,originForReceiving:m}=a;let w=!1;c(`${d}: Connecting call sender`);const h=s.reduce(((n,a)=>{return n[a]=(s=a,(...n)=>{let a;c(`${d}: Sending ${s}() call`);try{_.closed&&(a=!0)}catch(e){a=!0}if(a&&i(),w){const e=new Error(`Unable to send ${s}() call due to destroyed connection`);throw e.code=t.ConnectionDestroyed,e}return new Promise(((t,a)=>{const i=l(),u=n=>{if(n.source!==_||n.data.penpal!==e.Reply||n.data.id!==i)return;if("*"!==m&&n.origin!==m)return void c(`${d} received message from origin ${n.origin} which did not match expected origin ${m}`);const l=n.data;c(`${d}: Received ${s}() reply`),p.removeEventListener(o.Message,u);let g=l.returnValue;l.returnValueIsError&&(g=(e=>{const r=new Error;return Object.keys(e).forEach((t=>r[t]=e[t])),r})(g)),(l.resolution===r.Fulfilled?t:a)(g)};p.addEventListener(o.Message,u);const w={penpal:e.Call,id:i,methodName:s,args:n};_.postMessage(w,g)}))}),n;var s}),{});return Object.assign(n,(e=>{const r={};for(const t in e)u(r,t,e[t]);return r})(h)),()=>{w=!0}};var g=__webpack_require__(7584);let m=null;const w=((a={})=>{const{parentOrigin:s="*",methods:c={},timeout:l,debug:d=!1}=a,u=(e=>(...r)=>{e&&console.log("[Penpal]",...r)})(d),g=((e,r)=>{const t=[];let n=!1;return{destroy(e){n||(n=!0,r("Child: Destroying connection"),t.forEach((r=>{r(e)})))},onDestroy(e){n?e():t.push(e)}}})(0,u),{destroy:m,onDestroy:w}=g,h=p(c),f=((t,a,s,c)=>{const{destroy:l,onDestroy:d}=s;return s=>{if(!(t instanceof RegExp?t.test(s.origin):"*"===t||t===s.origin))return void c(`Child: Handshake - Received SYN-ACK from origin ${s.origin} which did not match expected origin ${t}`);c("Child: Handshake - Received SYN-ACK, responding with ACK");const u="null"===s.origin?"*":s.origin,p={penpal:e.Ack,methodNames:Object.keys(a)};window.parent.postMessage(p,u);const g={localName:"Child",local:window,remote:window.parent,originForSending:u,originForReceiving:s.origin},m=((t,a,s)=>{const{localName:c,local:l,remote:d,originForSending:u,originForReceiving:p}=t;let _=!1;const g=t=>{if(t.source!==d||t.data.penpal!==e.Call)return;if("*"!==p&&t.origin!==p)return void s(`${c} received message from origin ${t.origin} which did not match expected origin ${p}`);const o=t.data,{methodName:l,args:g,id:m}=o;s(`${c}: Received ${l}() call`);const w=t=>o=>{if(s(`${c}: Sending ${l}() reply`),_)return void s(`${c}: Unable to send ${l}() reply due to destroyed connection`);const a={penpal:e.Reply,id:m,resolution:t,returnValue:o};t===r.Rejected&&o instanceof Error&&(a.returnValue=i(o),a.returnValueIsError=!0);try{d.postMessage(a,u)}catch(t){if(t.name===n.DataCloneError){const n={penpal:e.Reply,id:m,resolution:r.Rejected,returnValue:i(t),returnValueIsError:!0};d.postMessage(n,u)}throw t}};new Promise((e=>e(a[l].apply(a,g)))).then(w(r.Fulfilled),w(r.Rejected))};return l.addEventListener(o.Message,g),()=>{_=!0,l.removeEventListener(o.Message,g)}})(g,a,c);d(m);const w={},h=_(w,g,s.data.methodNames,l,c);return d(h),w}})(s,h,g,u),y=new Promise(((r,n)=>{const a=((e,r)=>{let n;return void 0!==e&&(n=window.setTimeout((()=>{const n=new Error(`Connection timed out after ${e}ms`);n.code=t.ConnectionTimeout,r(n)}),e)),()=>{clearTimeout(n)}})(l,m),i=t=>{if((()=>{try{clearTimeout()}catch(e){return!1}return!0})()&&t.source===parent&&t.data&&t.data.penpal===e.SynAck){const e=f(t);e&&(window.removeEventListener(o.Message,i),a(),r(e))}};window.addEventListener(o.Message,i),(()=>{u("Child: Handshake - Sending SYN");const r={penpal:e.Syn},t=s instanceof RegExp?"*":s;window.parent.postMessage(r,t)})(),w((e=>{window.removeEventListener(o.Message,i),e&&n(e)}))}));return{promise:y,destroy(){m()}}})({methods:{async init(e){const r=(0,g.b)(e);return m=new r,{autoFrom:r?.isSupportedAutoFrom()??!1,supportedLanguages:r?.getSupportedLanguages()??[],maxTextLength:m?.getLengthLimit()??5e3,timeout:m?.getRequestsTimeout()??50}},async translate(e,r,t){if(!m)throw new Error("Translator is not defined");return m.translate(e,r,t)},async translateBatch(e,r,t){if(!m)throw new Error("Translator is not defined");return m.translateBatch(e,r,t)}}});window.fetch=async(e,r={})=>w.promise.then((t=>t.fetch(e,r).then((({body:e,...r})=>new Response(e,r)))))})()})();