{"version":3,"file":"832.js","mappings":"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","sources":["webpack://floccus/./_locales/ lazy ^.*","webpack://floccus/./src/lib/DefunctCrypto.js","webpack://floccus/./src/lib/browser-api.js","webpack://floccus/./src/lib/native/NativeAccountStorage.js","webpack://floccus/./src/lib/native/NativeController.js","webpack://floccus/./src/errors/Error.ts","webpack://floccus/./src/lib/Account.ts","webpack://floccus/./src/lib/AdapterFactory.ts","webpack://floccus/./src/lib/Controller.ts","webpack://floccus/./src/lib/Crypto.ts","webpack://floccus/./src/lib/Diff.ts","webpack://floccus/./src/lib/LocalTabs.ts","webpack://floccus/./src/lib/Mappings.ts","webpack://floccus/./src/lib/Scanner.ts","webpack://floccus/./src/lib/Tree.ts","webpack://floccus/./src/lib/adapters/Caching.ts","webpack://floccus/./src/lib/adapters/Git.ts","webpack://floccus/./src/lib/adapters/GoogleDrive.ts","webpack://floccus/./src/lib/adapters/Linkwarden.ts","webpack://floccus/./src/lib/adapters/NextcloudBookmarks.ts","webpack://floccus/./src/lib/adapters/WebDav.ts","webpack://floccus/./src/lib/browser/BrowserAccount.ts","webpack://floccus/./src/lib/browser/BrowserDetection.ts","webpack://floccus/./src/lib/browser/BrowserTree.ts","webpack://floccus/./src/lib/interfaces/Controller.ts","webpack://floccus/./src/lib/isTest.ts","webpack://floccus/./src/lib/native/I18n.ts","webpack://floccus/./src/lib/native/NativeAccount.ts","webpack://floccus/./src/lib/native/NativeTree.ts","webpack://floccus/./src/lib/serializers/Html.ts","webpack://floccus/./src/lib/serializers/Xbel.ts","webpack://floccus/./src/lib/strategies/Default.ts","webpack://floccus/./src/lib/strategies/Merge.ts","webpack://floccus/./src/lib/strategies/Unidirectional.ts"],"sourcesContent":["var map = {\n\t\"./cs/messages.json\": [\n\t\t25974,\n\t\t974\n\t],\n\t\"./de/messages.json\": [\n\t\t72805,\n\t\t805\n\t],\n\t\"./en/messages.json\": [\n\t\t18033\n\t],\n\t\"./es/messages.json\": [\n\t\t77772,\n\t\t772\n\t],\n\t\"./fi/messages.json\": [\n\t\t83283,\n\t\t283\n\t],\n\t\"./fr/messages.json\": [\n\t\t28488,\n\t\t488\n\t],\n\t\"./gl/messages.json\": [\n\t\t17925,\n\t\t925\n\t],\n\t\"./ja/messages.json\": [\n\t\t75591,\n\t\t591\n\t],\n\t\"./ko_KR/messages.json\": [\n\t\t89080,\n\t\t80\n\t],\n\t\"./nl_NL/messages.json\": [\n\t\t50165,\n\t\t165\n\t],\n\t\"./pl/messages.json\": [\n\t\t81024,\n\t\t24\n\t],\n\t\"./pt/messages.json\": [\n\t\t12120,\n\t\t120\n\t],\n\t\"./pt_BR/messages.json\": [\n\t\t88193,\n\t\t193\n\t],\n\t\"./ru/messages.json\": [\n\t\t18995,\n\t\t995\n\t],\n\t\"./sv/messages.json\": [\n\t\t50787,\n\t\t787\n\t],\n\t\"./tr/messages.json\": [\n\t\t1562,\n\t\t562\n\t],\n\t\"./tr_TR/messages.json\": [\n\t\t25457,\n\t\t457\n\t],\n\t\"./zh/messages.json\": [\n\t\t48214,\n\t\t214\n\t],\n\t\"./zh_CN/messages.json\": [\n\t\t52088,\n\t\t88\n\t],\n\t\"./zh_TW/messages.json\": [\n\t\t64624,\n\t\t624\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {\n\t\treturn __webpack_require__(id);\n\t});\n}\nwebpackAsyncContext.keys = () => (Object.keys(map));\nwebpackAsyncContext.id = 21509;\nmodule.exports = webpackAsyncContext;","export default class Crypto {\n  static async sha256(message) {\n    const msgBuffer = new TextEncoder('utf-8').encode(message) // encode as UTF-8\n    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer) // hash the message\n    const hashHex = this.bufferToHexstr(hashBuffer) // convert bytes to hex string\n    return hashHex\n  }\n\n  static bufferToHexstr(buffer) {\n    return Array.from(new Uint8Array(buffer))\n      .map(b => ('00' + b.toString(16)).slice(-2))\n      .join('') // convert bytes to hex string\n  }\n\n  static hexstrToBuffer(hex) {\n    for (\n      var bytes = new Uint8Array(hex.length / 2), c = 0;\n      c < hex.length;\n      c += 2\n    ) {\n      bytes[c / 2] = parseInt(hex.substr(c, 2), 16)\n    }\n    return bytes\n  }\n\n  static async prepareKey(key) {\n    const keyBuffer = await crypto.subtle.digest(\n      'SHA-256',\n      new TextEncoder('utf-8').encode(key)\n    ) // hash the key\n    let cryptoKey = await crypto.subtle.importKey(\n      'raw',\n      keyBuffer,\n      { name: 'AES-CBC' },\n      false,\n      ['decrypt', 'encrypt']\n    )\n    return cryptoKey\n  }\n\n  static async decryptAES(key, iv, ciphertext) {\n    return new TextDecoder().decode(\n      await crypto.subtle.decrypt(\n        { name: 'AES-CBC', iv: Uint8Array.from(Crypto.iv) },\n        await this.prepareKey(key),\n        this.hexstrToBuffer(ciphertext)\n      )\n    )\n  }\n\n  static async encryptAES(key, iv, message) {\n    return this.bufferToHexstr(\n      await crypto.subtle.encrypt(\n        { name: 'AES-CBC', iv: Uint8Array.from(Crypto.iv) },\n        await this.prepareKey(key),\n        new TextEncoder().encode(message)\n      )\n    )\n  }\n\n  static getRandomBytes(bytelength) {\n    let rand = new Int8Array(bytelength)\n    crypto.getRandomValues(rand)\n    return rand\n  }\n}\n\n// A default initialization vector for the key hash\nCrypto.iv = [\n  58,\n  14,\n  9,\n  204,\n  174,\n  93,\n  77,\n  98,\n  12,\n  248,\n  11,\n  160,\n  143,\n  24,\n  119,\n  20\n]\n","/* global chrome browser */\n\nconst ChromePromise = (function(root) {\n  'use strict'\n  var push = Array.prototype.push,\n    hasOwnProperty = Object.prototype.hasOwnProperty\n\n  function ChromePromise(chrome, Promise) {\n    chrome = chrome || root.chrome\n    Promise = Promise || root.Promise\n\n    var runtime = chrome.runtime\n\n    fillProperties(chrome, this)\n\n    /// /////////////\n\n    function setPromiseFunction(fn, thisArg) {\n      return function() {\n        var args = arguments\n\n        return new Promise(function(resolve, reject) {\n          function callback() {\n            var err = runtime.lastError\n            if (err) {\n              reject(err)\n            } else {\n              resolve.apply(null, arguments)\n            }\n          }\n\n          push.call(args, callback)\n\n          fn.apply(thisArg, args)\n        })\n      }\n    }\n\n    function fillProperties(source, target) {\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          var val = source[key]\n          var type = typeof val\n\n          if (type === 'object' && !(val instanceof ChromePromise) && key.indexOf('on') !== 0) {\n            target[key] = {}\n            fillProperties(val, target[key])\n          } else if (type === 'function') {\n            target[key] = setPromiseFunction(val, source)\n          } else {\n            target[key] = val\n          }\n        }\n      }\n    }\n  }\n\n  return ChromePromise\n})(typeof window !== 'undefined' ? window : self)\n\nlet b\nif (typeof browser === 'undefined' && typeof chrome !== 'undefined') {\n  b = new ChromePromise(chrome, Promise)\n  b.alarms = chrome.alarms // Don't promisify alarms -- don't make sense, yo!\n  b.browserAction = chrome.browserAction // apparently, they provide no callbacks for these\n  b.action = chrome.action // apparently, they provide no callbacks for these\n  b.i18n = chrome.i18n\n} else {\n  b = browser\n}\n\nexport default b\n","import { Preferences as Storage } from '@capacitor/preferences'\nimport Cryptography from '../Crypto'\nimport DefunctCryptography from '../DefunctCrypto'\nimport Mappings from '../Mappings'\nimport { Folder, ItemLocation } from '../Tree'\nimport AsyncLock from 'async-lock'\n\nconst storageLock = new AsyncLock()\n\nexport default class NativeAccountStorage {\n  constructor(id) {\n    this.accountId = id\n  }\n\n  static async changeEntry(entryName, fn, defaultVal) {\n    await storageLock.acquire(entryName, async() => {\n      let entry = await NativeAccountStorage.getEntry(entryName, defaultVal)\n      entry = fn(entry)\n\n      await Storage.set({ key: entryName, value: JSON.stringify(entry) })\n    })\n  }\n\n  static async getEntry(entryName, defaultVal) {\n    let entry = await Storage.get({key: entryName })\n    if (entry.value) {\n      while (typeof entry.value === 'string') {\n        entry.value = JSON.parse(entry.value)\n      }\n      return entry.value\n    } else {\n      return defaultVal\n    }\n  }\n\n  static deleteEntry(entryName) {\n    return Storage.remove({key: entryName})\n  }\n\n  static async getAllAccounts() {\n    let accounts = await NativeAccountStorage.getEntry(`accounts`, {})\n    return Object.keys(accounts)\n  }\n\n  async getAccountData(key) {\n    let accounts = await NativeAccountStorage.getEntry(`accounts`, {})\n    let data = accounts[this.accountId]\n    if (key) {\n      if (data.iv) {\n        data.password = await DefunctCryptography.decryptAES(key, data.iv, data.password)\n        delete data.iv\n      } else {\n        data.password = await Cryptography.decryptAES(key, data.password, data.username)\n        if (data.passphrase) {\n          data.passphrase = await Cryptography.decryptAES(key, data.passphrase, data.username)\n        }\n      }\n    }\n    return data\n  }\n\n  async setAccountData(data, key) {\n    let encData = data\n    if (key) {\n      if (data.iv) {\n        delete data.iv\n      }\n      encData = {\n        ...data,\n        password: await Cryptography.encryptAES(key, data.password, data.username),\n        ...(data.passphrase && {passphrase: await Cryptography.encryptAES(key, data.passphrase, data.username)})\n      }\n    }\n    return NativeAccountStorage.changeEntry(\n      `accounts`,\n      accounts => {\n        accounts[this.accountId] = encData\n        return accounts\n      },\n      {}\n    )\n  }\n\n  async deleteAccountData() {\n    await NativeAccountStorage.changeEntry(`accounts`, accounts => {\n      delete accounts[this.accountId]\n      return accounts\n    })\n    await this.deleteCache()\n    await this.deleteMappings()\n  }\n\n  async initCache() {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => ({})\n    )\n  }\n\n  async getCache() {\n    const data = await NativeAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].cache`\n    )\n    return Folder.hydrate(data && Object.keys(data).length ? data : {location: ItemLocation.LOCAL})\n  }\n\n  async setCache(data) {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => data\n    )\n  }\n\n  async deleteCache() {\n    await NativeAccountStorage.deleteEntry(`bookmarks[${this.accountId}].cache`)\n  }\n\n  async initMappings() {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => ({})\n    )\n  }\n\n  async getMappings() {\n    const data = await NativeAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].mappings`\n    )\n    return new Mappings(\n      this,\n      data && Object.keys(data).length\n        ? data\n        : {\n          bookmarks: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          },\n          folders: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          }\n        }\n    )\n  }\n\n  async setMappings(data) {\n    await NativeAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => data\n    )\n  }\n\n  async deleteMappings() {\n    await NativeAccountStorage.deleteEntry(`bookmarks[${this.accountId}].mappings`)\n  }\n\n  async getCurrentContinuation() {\n    return NativeAccountStorage.getEntry(`bookmarks[${this.accountId}].continuation`)\n  }\n\n  async setCurrentContinuation(continuation) {\n    await NativeAccountStorage.changeEntry(`bookmarks[${this.accountId}].continuation`, (_) => continuation, null)\n  }\n}\n","import { Preferences as Storage } from '@capacitor/preferences'\nimport { Network } from '@capacitor/network'\nimport Cryptography from '../Crypto'\nimport NativeAccountStorage from './NativeAccountStorage'\nimport Account from '../Account'\nimport { STATUS_ALLGOOD, STATUS_DISABLED, STATUS_ERROR, STATUS_SYNCING } from '../interfaces/Controller'\n\nconst INACTIVITY_TIMEOUT = 1000 * 7\nconst DEFAULT_SYNC_INTERVAL = 15\n\nclass AlarmManager {\n  constructor(ctl) {\n    this.ctl = ctl\n    this.backgroundSyncEnabled = true\n    setInterval(() => this.checkSync(), 25 * 1000)\n\n    Network.addListener('networkStatusChange', status => {\n      if (status.connected) {\n        this.backgroundSyncEnabled = true\n      } else {\n        this.backgroundSyncEnabled = false\n      }\n    })\n  }\n\n  async checkSync() {\n    if (!this.backgroundSyncEnabled) {\n      return\n    }\n    const accounts = await NativeAccountStorage.getAllAccounts()\n    for (let accountId of accounts) {\n      const account = await Account.get(accountId)\n      const data = account.getData()\n      if (data.scheduled) {\n        this.ctl.scheduleSync(accountId)\n      }\n      if (\n        !data.lastSync ||\n        Date.now() >\n        (data.syncInterval || DEFAULT_SYNC_INTERVAL) * 1000 * 60 + data.lastSync\n      ) {\n        this.ctl.scheduleSync(accountId)\n      }\n    }\n  }\n}\n\nexport default class NativeController {\n  constructor() {\n    this.schedule = {}\n    this.listeners = []\n\n    this.alarms = new AlarmManager(this)\n\n    // lock accounts when locking is enabled\n\n    Storage.get({key: 'accountsLocked' }).then(async({value: accountsLocked}) => {\n      this.setEnabled(!accountsLocked)\n      this.unlocked = !accountsLocked\n      if (accountsLocked) {\n        this.key = null\n      }\n    })\n  }\n\n  setEnabled(enabled) {\n    this.enabled = enabled\n  }\n\n  async unlock(key) {\n    let accountsLocked = await Storage.get({ key: 'accountsLocked' })\n    if (accountsLocked) {\n      let hashedKey = await Cryptography.sha256(key)\n      let decryptedHash = await Cryptography.decryptAES(\n        key,\n        accountsLocked,\n        'FLOCCUS'\n      )\n\n      if (decryptedHash !== hashedKey) {\n        throw new Error('The provided key was wrong')\n      }\n      this.key = key\n    }\n    this.unlocked = true\n    this.setEnabled(true)\n  }\n\n  getUnlocked() {\n    return Promise.resolve(this.unlocked)\n  }\n\n  async scheduleAll() {\n    const accounts = await Account.getAllAccounts()\n    for (const account of accounts) {\n      this.scheduleSync(account.id)\n    }\n  }\n\n  async scheduleSync(accountId, wait) {\n    if (wait) {\n      if (this.schedule[accountId]) {\n        clearTimeout(this.schedule[accountId])\n      }\n      this.schedule[accountId] = setTimeout(\n        () => this.scheduleSync(accountId),\n        INACTIVITY_TIMEOUT\n      )\n      return\n    }\n\n    let account = await Account.get(accountId)\n    if (account.getData().syncing) {\n      return\n    }\n    // if the account is already scheduled, don't prevent it, to avoid getting stuck\n    if (!account.getData().enabled && !account.getData().scheduled) {\n      return\n    }\n\n    const status = await this.getStatus()\n    if (status === STATUS_SYNCING) {\n      await account.setData({ ...account.getData(), scheduled: account.getData().scheduled || true })\n      return\n    }\n\n    if (account.getData().scheduled === true) {\n      await this.syncAccount(accountId)\n    } else {\n      await this.syncAccount(accountId, account.getData().scheduled)\n    }\n  }\n\n  async cancelSync(accountId, keepEnabled) {\n    let account = await Account.get(accountId)\n    // Avoid starting it again automatically\n    if (!keepEnabled) {\n      await account.setData({ ...account.getData(), enabled: false })\n    }\n    await account.cancelSync()\n  }\n\n  async syncAccount(accountId, strategy, forceSync = false) {\n    if (!this.enabled) {\n      return\n    }\n    let account = await Account.get(accountId)\n    if (account.getData().syncing) {\n      return\n    }\n    setTimeout(() => this.updateStatus(), 500)\n    try {\n      await account.sync(strategy, forceSync)\n    } catch (error) {\n      console.error(error)\n    }\n    this.updateStatus()\n  }\n\n  async updateStatus() {\n    this.listeners.forEach(fn => fn())\n  }\n\n  async getStatus() {\n    if (!this.unlocked) {\n      return STATUS_ERROR\n    }\n    const accounts = await Account.getAllAccounts()\n    let overallStatus = accounts.reduce((status, account) => {\n      const accData = account.getData()\n      if (status === STATUS_SYNCING || accData.syncing) {\n        return STATUS_SYNCING\n      } else if (status === STATUS_ERROR || (accData.error && !accData.syncing)) {\n        return STATUS_ERROR\n      } else {\n        return STATUS_ALLGOOD\n      }\n    }, STATUS_ALLGOOD)\n\n    if (overallStatus === STATUS_ALLGOOD) {\n      if (accounts.every(account => !account.getData().enabled)) {\n        overallStatus = STATUS_DISABLED\n      }\n    }\n\n    return overallStatus\n  }\n\n  onStatusChange(listener) {\n    this.listeners.push(listener)\n    let unregistered = false\n    return () => {\n      if (unregistered) return\n      this.listeners.splice(this.listeners.indexOf(listener), 1)\n      unregistered = true\n    }\n  }\n\n  async onLoad() {\n    const accounts = await Account.getAllAccounts()\n    await Promise.all(\n      accounts.map(async acc => {\n        if (acc.getData().syncing) {\n          await acc.setData({\n            ...acc.getData(),\n            syncing: false,\n            scheduled: false,\n          })\n        }\n      })\n    )\n  }\n}\n\nlet singleton\nNativeController.getSingleton = function() {\n  if (!singleton) {\n    singleton = new NativeController()\n  }\n  return singleton\n}\n","import { Bookmark, TItemLocation } from '../lib/Tree'\n\nexport class FloccusError extends Error {\n  public code: number\n\n  constructor(message) {\n    super(message)\n    // See https://stackoverflow.com/questions/12915412/how-do-i-extend-a-host-object-e-g-error-in-typescript#22666069\n    Object.setPrototypeOf(this, FloccusError.prototype)\n  }\n}\n\nexport class UnknownCreateTargetError extends FloccusError {\n  constructor() {\n    super(\"E001: Folder to create in doesn't exist\")\n    this.code = 1\n    Object.setPrototypeOf(this, UnknownCreateTargetError.prototype)\n  }\n}\n\nexport class UnknownBookmarkUpdateError extends FloccusError {\n  constructor() {\n    super(\"E002: Bookmark to update doesn't exist anymore\")\n    this.code = 2\n    Object.setPrototypeOf(this, UnknownBookmarkUpdateError.prototype)\n  }\n}\n\nexport class UnknownMoveOriginError extends FloccusError {\n  constructor() {\n    super(\"E003: Folder to move out of doesn't exist\")\n    this.code = 3\n    Object.setPrototypeOf(this, UnknownMoveOriginError.prototype)\n  }\n}\n\nexport class UnknownMoveTargetError extends FloccusError {\n  constructor() {\n    super(\"E004: Folder to move into doesn't exist\")\n    this.code = 4\n    Object.setPrototypeOf(this, UnknownMoveTargetError.prototype)\n  }\n}\n\nexport class UnknownFolderParentUpdateError extends FloccusError {\n  constructor() {\n    super(\"E006: Parent of folder to update doesn't exist\")\n    this.code = 5\n    Object.setPrototypeOf(this, UnknownFolderParentUpdateError.prototype)\n  }\n}\n\nexport class UnknownFolderUpdateError extends FloccusError {\n  constructor() {\n    super(\"E006: Folder to update doesn't exist\")\n    this.code = 6\n    Object.setPrototypeOf(this, UnknownFolderUpdateError.prototype)\n  }\n}\n\nexport class UnknownFolderMoveError extends FloccusError {\n  constructor() {\n    super(\"E007: Folder to move doesn't exist\")\n    this.code = 7\n    Object.setPrototypeOf(this, UnknownFolderMoveError.prototype)\n  }\n}\n\n// code 8 is unused\n// code 9 is unused\n\nexport class UnknownFolderOrderError extends FloccusError {\n  constructor() {\n    super('E010: Could not find folder to order')\n    this.code = 10\n    Object.setPrototypeOf(this, UnknownFolderOrderError.prototype)\n  }\n}\n\nexport class UnknownFolderItemOrderError extends FloccusError {\n  public item: string\n  constructor(item: string) {\n    super('E011: Item in folder ordering is not an actual child')\n    this.code = 11\n    this.item = item\n    Object.setPrototypeOf(this, UnknownFolderItemOrderError.prototype)\n  }\n}\n\nexport class MissingItemOrderError extends FloccusError {\n  public item: string\n  constructor(item: string) {\n    super(\"E012: Folder ordering is missing some of the folder's children\")\n    this.code = 12\n    this.item = item\n    Object.setPrototypeOf(this, MissingItemOrderError.prototype)\n  }\n}\n\nexport class UnknownFolderRemoveError extends FloccusError {\n  constructor() {\n    super(\"E013: Folder to remove doesn't exist\")\n    this.code = 13\n    Object.setPrototypeOf(this, UnknownFolderRemoveError.prototype)\n  }\n}\n\nexport class UnknownFolderParentRemoveError extends FloccusError {\n  constructor() {\n    super(\"E014: Parent folder to remove folder from of doesn't exist\")\n    this.code = 14\n    Object.setPrototypeOf(this, UnknownFolderParentRemoveError.prototype)\n  }\n}\n\nexport class UnexpectedServerResponseError extends FloccusError {\n  constructor() {\n    super('E015: Unexpected response data from server')\n    this.code = 15\n    Object.setPrototypeOf(this, UnexpectedServerResponseError.prototype)\n  }\n}\n\nexport class RequestTimeoutError extends FloccusError {\n  constructor() {\n    super('E016: Request timed out.')\n    this.code = 16\n    Object.setPrototypeOf(this, RequestTimeoutError.prototype)\n  }\n}\n\nexport class NetworkError extends FloccusError {\n  constructor() {\n    super('E017: Network error: Check your network connection and your profile details')\n    this.code = 17\n    Object.setPrototypeOf(this, NetworkError.prototype)\n  }\n}\n\nexport class AuthenticationError extends FloccusError {\n  constructor() {\n    super(\"E018: Couldn't authenticate with the server.\")\n    this.code = 18\n    Object.setPrototypeOf(this, AuthenticationError.prototype)\n  }\n}\n\nexport class HttpError extends FloccusError {\n  public status: number\n  public method: string\n  constructor(status: number, method: string) {\n    super(`E019: HTTP status ${status}. Failed ${method} request. Check your server configuration and log.`)\n    this.code = 19\n    this.status = status\n    this.method = method\n    Object.setPrototypeOf(this, HttpError.prototype)\n  }\n}\n\nexport class ParseResponseError extends FloccusError {\n  public response: string\n  constructor(response: string) {\n    super('E020: Could not parse server response. Is the bookmarks app installed on your server?')\n    this.code = 20\n    this.response = response\n    Object.setPrototypeOf(this, ParseResponseError.prototype)\n  }\n}\n\nexport class InconsistentServerStateError extends FloccusError {\n  constructor() {\n    super('E021: Inconsistent server state. Folder is present in childorder list but not in folder tree')\n    this.code = 21\n    Object.setPrototypeOf(this, InconsistentServerStateError.prototype)\n  }\n}\n\nexport class InconsistentBookmarksExistenceError extends FloccusError {\n  public folder: string\n  public bookmark: string\n  constructor(folder:string, bookmark:string) {\n    super(`E022: Folder ${folder} supposedly contains non-existent bookmark ${bookmark}`)\n    this.code = 22\n    this.folder = folder\n    this.bookmark = bookmark\n    Object.setPrototypeOf(this, InconsistentBookmarksExistenceError.prototype)\n  }\n}\n\nexport class UnclearedLockFileError extends FloccusError {\n  public lockFile: string\n\n  constructor(lockFile:string) {\n    super(`E023: Unable to clear lock file, consider deleting ${lockFile} manually.`)\n    this.code = 23\n    this.lockFile = lockFile\n    Object.setPrototypeOf(this, UnclearedLockFileError.prototype)\n  }\n}\n\nexport class LockFileError extends FloccusError {\n  public status: number\n  public lockFile: string\n\n  constructor(status:number, lockFile:string) {\n    super(`E024: HTTP status ${status} while trying to determine status of lock file ${lockFile}`)\n    this.code = 24\n    this.status = status\n    this.lockFile = lockFile\n    Object.setPrototypeOf(this, LockFileError.prototype)\n  }\n}\n\nexport class SlashError extends FloccusError {\n  public status: number\n  public lockFile: string\n\n  constructor() {\n    super(\"E025: Bookmarks file setting mustn't begin with a slash: '/'\")\n    this.code = 25\n    Object.setPrototypeOf(this, SlashError.prototype)\n  }\n}\n\nexport class CancelledSyncError extends FloccusError {\n  constructor() {\n    super('E026: Sync process was cancelled')\n    this.code = 26\n    Object.setPrototypeOf(this, InterruptedSyncError.prototype)\n  }\n}\n\nexport class InterruptedSyncError extends FloccusError {\n  constructor() {\n    super('E027: Sync process was interrupted')\n    this.code = 27\n    Object.setPrototypeOf(this, InterruptedSyncError.prototype)\n  }\n}\n\n// code 28 is unused\n\nexport class FailsafeError extends FloccusError {\n  public percent: number\n\n  constructor(percent:number) {\n    super(`E029: Failsafe: The current sync run would delete ${percent}% of your bookmarks. Refusing to execute. Disable this failsafe in the profile settings if you want to proceed anyway.`)\n    this.code = 29\n    this.percent = percent\n    Object.setPrototypeOf(this, FailsafeError.prototype)\n  }\n}\n\nexport class DecryptionError extends FloccusError {\n  constructor() {\n    super('E030: Failed to decrypt bookmarks file. The passphrase may be wrong or the file may be corrupted.')\n    this.code = 30\n    Object.setPrototypeOf(this, DecryptionError.prototype)\n  }\n}\n\nexport class GoogleDriveAuthenticationError extends FloccusError {\n  constructor() {\n    super('E031: Could not authenticate with Google Drive. Please connect floccus with your google account again.')\n    this.code = 31\n    Object.setPrototypeOf(this, GoogleDriveAuthenticationError.prototype)\n  }\n}\n\nexport class OAuthTokenError extends FloccusError {\n  constructor() {\n    super('E032: OAuth error. Token validation error. Please reconnect your Google Account.')\n    this.code = 32\n    Object.setPrototypeOf(this, OAuthTokenError.prototype)\n  }\n}\n\nexport class RedirectError extends FloccusError {\n  constructor() {\n    super(\"E033: Redirect detected. Please make sure the server supports the selected sync method and URL you entered is correct doesn't redirect to a different location.\")\n    this.code = 33\n    Object.setPrototypeOf(this, RedirectError.prototype)\n  }\n}\n\nexport class FileUnreadableError extends FloccusError {\n  constructor() {\n    super('E034: Remote bookmarks file is unreadable. Perhaps you forgot to set an encryption passphrase, or you set the wrong file format.')\n    this.code = 34\n    Object.setPrototypeOf(this, FileUnreadableError.prototype)\n  }\n}\n\nexport class CreateBookmarkError extends FloccusError {\n  public bookmark: Bookmark<TItemLocation>\n  constructor(bookmark: Bookmark<TItemLocation>) {\n    super(`E035: Failed to create the following bookmark on the server: ${bookmark.inspect()}`)\n    this.code = 35\n    this.bookmark = bookmark\n    Object.setPrototypeOf(this, CreateBookmarkError.prototype)\n  }\n}\n\nexport class MissingPermissionsError extends FloccusError {\n  constructor() {\n    super(`E036: Missing permissions to access the sync server`)\n    this.code = 36\n    Object.setPrototypeOf(this, MissingPermissionsError.prototype)\n  }\n}\n\nexport class ResourceLockedError extends FloccusError {\n  constructor() {\n    super(`E037: Resource is locked`)\n    this.code = 37\n    Object.setPrototypeOf(this, ResourceLockedError.prototype)\n  }\n}\n\nexport class LocalFolderNotFoundError extends FloccusError {\n  constructor() {\n    super(`E038: Could not find local folder`)\n    this.code = 38\n    Object.setPrototypeOf(this, LocalFolderNotFoundError.prototype)\n  }\n}\n\nexport class UpdateBookmarkError extends FloccusError {\n  public bookmark: Bookmark<TItemLocation>\n  constructor(bookmark: Bookmark<TItemLocation>) {\n    super(`E039: Failed to update the following bookmark on the server: ${bookmark.inspect()}`)\n    this.code = 39\n    this.bookmark = bookmark\n    Object.setPrototypeOf(this, UpdateBookmarkError.prototype)\n  }\n}","import AdapterFactory from './AdapterFactory'\nimport Logger from './Logger'\nimport { ItemLocation, TItemLocation } from './Tree'\nimport UnidirectionalSyncProcess from './strategies/Unidirectional'\nimport MergeSyncProcess from './strategies/Merge'\nimport DefaultSyncProcess from './strategies/Default'\nimport IAccountStorage, { IAccountData, TAccountStrategy } from './interfaces/AccountStorage'\nimport { TAdapter } from './interfaces/Adapter'\nimport { OrderFolderResource, TLocalTree } from './interfaces/Resource'\nimport { Capacitor } from '@capacitor/core'\nimport IAccount from './interfaces/Account'\nimport Mappings from './Mappings'\nimport { isTest } from './isTest'\nimport CachingAdapter from './adapters/Caching'\nimport * as Sentry from '@sentry/vue'\n\ndeclare const DEBUG: boolean\n\n// register Adapters\nAdapterFactory.register('linkwarden', async() => (await import('./adapters/Linkwarden')).default)\nAdapterFactory.register('nextcloud-folders', async() => (await import('./adapters/NextcloudBookmarks')).default)\nAdapterFactory.register('nextcloud-bookmarks', async() => (await import('./adapters/NextcloudBookmarks')).default)\nAdapterFactory.register('webdav', async() => (await import('./adapters/WebDav')).default)\nAdapterFactory.register('git', async() => (await import('./adapters/Git')).default)\nAdapterFactory.register('google-drive', async() => (await import('./adapters/GoogleDrive')).default)\nAdapterFactory.register('fake', async() => (await import('./adapters/Fake')).default)\n\n// 2h\nconst LOCK_TIMEOUT = 1000 * 60 * 60 * 2\n\nexport default class Account {\n  static cache = {}\n  static singleton : IAccount\n\n  static async getAccountClass(): Promise<IAccount> {\n    if (this.singleton) {\n      return this.singleton\n    }\n    if (Capacitor.getPlatform() === 'web') {\n      this.singleton = (await import('./browser/BrowserAccount')).default\n    } else {\n      this.singleton = (await import('./native/NativeAccount')).default\n    }\n    return this.singleton\n  }\n\n  static async get(id:string):Promise<Account> {\n    if (this.cache[id]) {\n      await this.cache[id].updateFromStorage()\n      return this.cache[id]\n    }\n    const account = await (await this.getAccountClass()).get(id)\n    this.cache[id] = account\n    return account\n  }\n\n  static async create(data: IAccountData):Promise<Account> {\n    return (await this.getAccountClass()).create(data)\n  }\n\n  static async import(accounts:IAccountData[]):Promise<void> {\n    for (const accountData of accounts) {\n      await this.create({...accountData, enabled: false})\n    }\n  }\n\n  static async export(accountIds:string[]):Promise<IAccountData[]> {\n    return (await Promise.all(\n      accountIds.map(id => Account.get(id))\n    )).map(a => a.getData())\n  }\n\n  public id: string\n  public syncing: boolean\n  protected syncProcess: DefaultSyncProcess\n  protected storage: IAccountStorage\n  protected server: TAdapter\n  protected localTree: TLocalTree\n  protected localTabs: TLocalTree\n  protected lockTimeout: number\n\n  constructor(id:string, storageAdapter:IAccountStorage, serverAdapter: TAdapter, treeAdapter:TLocalTree) {\n    this.server = serverAdapter\n    this.id = id\n    this.storage = storageAdapter\n    this.localTree = treeAdapter\n    this.lockTimeout = LOCK_TIMEOUT\n  }\n\n  async delete():Promise<void> {\n    await this.storage.deleteAccountData()\n  }\n\n  getLabel():string {\n    return this.server.getLabel()\n  }\n\n  getData():IAccountData {\n    const defaults = {\n      localRoot: null,\n      strategy: 'default' as TAccountStrategy,\n      syncInterval: 15,\n      nestedSync: false,\n      failsafe: true,\n      allowNetwork: false,\n      label: '',\n      errorCount: 0,\n      clickCountEnabled: false,\n    }\n    const data = Object.assign(defaults, this.server.getData())\n    if (data.type === 'nextcloud-folders') {\n      data.type = 'nextcloud-bookmarks'\n    }\n    return data\n  }\n\n  async getResource():Promise<OrderFolderResource<typeof ItemLocation.LOCAL>> {\n    return this.localTree\n  }\n\n  async getServer():Promise<TAdapter> {\n    return this.server\n  }\n\n  async setData(data:IAccountData):Promise<void> {\n    await this.storage.setAccountData(data, null)\n    this.server.setData(data)\n  }\n\n  async updateFromStorage():Promise<void> {\n    throw new Error('Not implemented')\n  }\n\n  async tracksBookmark(localId:string):Promise<boolean> {\n    if (!(await this.isInitialized())) return false\n    const mappings = await this.storage.getMappings()\n    const snapshot = mappings.getSnapshot()\n    const foundBookmark = Object.keys(snapshot.LocalToServer.bookmark).some(\n      (id) => String(localId) === String(id)\n    )\n    const foundFolder = Object.keys(snapshot.LocalToServer.folder).some(\n      (id) => String(localId) === String(id)\n    )\n    return foundBookmark || foundFolder\n  }\n\n  async init():Promise<void> {\n    throw new Error('Not implemented')\n  }\n\n  async isInitialized():Promise<boolean> {\n    throw new Error('Not implemented')\n  }\n\n  async sync(strategy?:TAccountStrategy, forceSync = false):Promise<void> {\n    let mappings: Mappings\n    try {\n      if (this.getData().syncing || this.syncing) return\n\n      const localResource = await this.getResource()\n      if (!(await this.server.isAvailable()) || !(await localResource.isAvailable())) return\n\n      Logger.log('Starting sync process for account ' + this.getLabel())\n      Sentry.setUser({ id: this.id })\n      this.syncing = true\n      await this.setData({ ...this.getData(), syncing: 0.05, scheduled: false, error: null })\n\n      if (!(await this.isInitialized())) {\n        await this.init()\n      }\n\n      if (this.server.onSyncStart) {\n        const needLock = (strategy || this.getData().strategy) !== 'slave'\n        let status\n        try {\n          status = await this.server.onSyncStart(needLock, forceSync)\n        } catch (e) {\n          // Resource locked\n          if (e.code === 37) {\n            // We got a resource locked error\n            if (this.getData().lastSync < Date.now() - this.lockTimeout || forceSync) {\n              // but if we've been waiting for the lock for more than 2h\n              // start again without locking the resource\n              status = await this.server.onSyncStart(false, true)\n            } else {\n              await this.setData({\n                ...this.getData(),\n                error: null,\n                syncing: false,\n                scheduled: strategy || this.getData().strategy\n              })\n              this.syncing = false\n              Logger.log(\n                'Resource is locked, trying again soon'\n              )\n              await Logger.persist()\n              return\n            }\n          } else {\n            await this.server.onSyncFail()\n            throw e\n          }\n        }\n        if (status === false) {\n          await this.init()\n        }\n      }\n\n      // main sync steps:\n      mappings = await this.storage.getMappings()\n      const cacheTree = await this.storage.getCache()\n\n      let continuation = await this.storage.getCurrentContinuation()\n\n      if (typeof continuation !== 'undefined' && continuation !== null) {\n        try {\n          this.syncProcess = await DefaultSyncProcess.fromJSON(\n            mappings,\n            localResource,\n            this.server,\n            async(progress, actionDone) => {\n              await this.progressCallback(progress, actionDone)\n            },\n            continuation\n          )\n        } catch (e) {\n          continuation = null\n          Logger.log('Failed to load pending continuation. Continuing with normal sync')\n        }\n      }\n\n      if (typeof continuation === 'undefined' || continuation === null || (typeof strategy !== 'undefined' && continuation.strategy !== strategy) || Date.now() - continuation.createdAt > 1000 * 60 * 30) {\n        // If there is no pending continuation, we just sync normally\n        // Same if the pending continuation was overridden by a different strategy\n        // same if the continuation is older than half an hour. We don't want old zombie continuations\n\n        let strategyClass: typeof DefaultSyncProcess|typeof MergeSyncProcess|typeof UnidirectionalSyncProcess, direction: TItemLocation\n        switch (strategy || this.getData().strategy) {\n          case 'slave':\n            Logger.log('Using \"merge slave\" strategy (no cache available)')\n            strategyClass = UnidirectionalSyncProcess\n            direction = ItemLocation.LOCAL\n            break\n          case 'overwrite':\n            Logger.log('Using \"merge overwrite\" strategy (no cache available)')\n            strategyClass = UnidirectionalSyncProcess\n            direction = ItemLocation.SERVER\n            break\n          default:\n            if (!cacheTree.children.length) {\n              Logger.log('Using \"merge default\" strategy (no cache available)')\n              strategyClass = MergeSyncProcess\n            } else {\n              Logger.log('Using \"default\" strategy')\n              strategyClass = DefaultSyncProcess\n            }\n            break\n        }\n\n        this.syncProcess = new strategyClass(\n          mappings,\n          localResource,\n          this.server,\n          async(progress, actionsDone?) => {\n            await this.progressCallback(progress, actionsDone)\n          }\n        )\n        this.syncProcess.setCacheTree(cacheTree)\n        if (direction) {\n          this.syncProcess.setDirection(direction)\n        }\n        await this.syncProcess.sync()\n      } else {\n        // if there is a pending continuation, we resume it\n\n        Logger.log('Found existing persisted pending continuation. Resuming last sync')\n        await this.syncProcess.sync()\n      }\n\n      await this.setData({ ...this.getData(), scheduled: false, syncing: 1 })\n\n      // update cache\n      const cache = (await localResource.getBookmarksTree()).clone(false)\n      this.syncProcess.filterOutUnacceptedBookmarks(cache)\n      this.syncProcess.filterOutUnmappedItems(cache, await mappings.getSnapshot())\n      await this.storage.setCache(cache)\n\n      if (this.server.onSyncComplete) {\n        await this.server.onSyncComplete()\n      }\n\n      if (mappings) {\n        await mappings.persist()\n      }\n\n      this.syncing = false\n\n      await this.storage.setCurrentContinuation(null)\n      await this.setData({\n        ...this.getData(),\n        error: null,\n        errorCount: 0,\n        syncing: false,\n        scheduled: false,\n        lastSync: Date.now(),\n      })\n\n      Logger.log(\n        'Successfully ended sync process for account ' + this.getLabel()\n      )\n    } catch (e) {\n      console.log(e)\n      const message = await Account.stringifyError(e)\n      console.error('Syncing failed with', message)\n      Logger.log('Syncing failed with', message)\n      Sentry.setContext('accountData', {\n        ...this.getData(),\n        username: 'SENSITIVEVALUEHIDDEN',\n        password: 'SENSITIVEVALUVALUEHIDDEN',\n        passphrase: 'SENSITIVEVALUVALUEHIDDEN'\n      })\n      if (e.list) {\n        Sentry.captureException(message)\n      } else {\n        Sentry.captureException(e)\n      }\n\n      await this.setData({\n        ...this.getData(),\n        error: message,\n        errorCount: this.getData().errorCount + 1,\n        syncing: false,\n        scheduled: false,\n      })\n      if (matchAllErrors(e, e => e.code !== 27 && (!isTest || e.code !== 26))) {\n        await this.storage.setCurrentContinuation(null)\n      }\n      this.syncing = false\n      if (this.server.onSyncFail) {\n        await this.server.onSyncFail()\n      }\n\n      // reset cache and mappings after error\n      // (but not after interruption or NetworkError)\n      if (matchAllErrors(e, e => e.code !== 27 && e.code !== 17 && (!isTest || e.code !== 26))) {\n        await this.init()\n      }\n    }\n    await Logger.persist()\n  }\n\n  static async stringifyError(er:any):Promise<string> {\n    return (await this.getAccountClass()).stringifyError(er)\n  }\n\n  async cancelSync():Promise<void> {\n    if (!this.syncing) return\n    this.server.cancel()\n    if (this.syncProcess) {\n      await this.syncProcess.cancel()\n    }\n  }\n\n  private async progressCallback(progress: number, actionsDone: number) {\n    if (!this.syncing) {\n      return\n    }\n    await this.setData({ ...this.getData(), syncing: progress })\n    if (!this.syncProcess) {\n      return\n    }\n    if (actionsDone && (!(this.server instanceof CachingAdapter) || !('onSyncComplete' in this.server))) {\n      await this.storage.setCurrentContinuation(this.syncProcess.toJSON())\n      await this.syncProcess.getMappingsInstance().persist()\n    }\n  }\n\n  static async getAllAccounts():Promise<Account[]> {\n    return (await this.getAccountClass()).getAllAccounts()\n  }\n\n  static async getAccountsContainingLocalId(localId:string, ancestors:string[], allAccounts:Account[]):Promise<Account[]> {\n    return (await this.getAccountClass()).getAccountsContainingLocalId(localId, ancestors, allAccounts)\n  }\n}\n\nfunction matchAllErrors(e, fn:(e)=>boolean) {\n  return fn(e) && e.list && e.list.every(e => matchAllErrors(e, fn))\n}\n","import { TAdapter } from './interfaces/Adapter'\nimport { IAccountData } from './interfaces/AccountStorage'\n\nexport default {\n  registry: {},\n  register(type:string, adapter: any):void {\n    this.registry[type] = adapter\n  },\n  async factory(data: any): Promise<TAdapter> {\n    if ('type' in data) {\n      const adapter = await this.registry[data.type]()\n      return new adapter(data)\n    }\n  },\n  async getDefaultValues(type:string):Promise<IAccountData> {\n    const adapter = await this.registry[type]()\n    return {\n      ...adapter.getDefaultValues(),\n      enabled: true,\n    }\n  }\n}\n","import IController from './interfaces/Controller'\nimport { Capacitor } from '@capacitor/core'\n\ninterface FloccusWorker {\n  postMessage(data: any): void\n  addEventListener(fn: (data: any) => void): () => void\n}\n\nexport default class Controller implements IController {\n  public static singleton: IController\n  private worker: FloccusWorker|null\n  private key: string|null|undefined\n\n  static async getSingleton():Promise<IController> {\n    if (!this.singleton) {\n      if (Capacitor.getPlatform() === 'web') {\n        // otherwise load the proxy\n        this.singleton = new Controller\n      } else {\n        // If we're not on the web, laod the implementation directly\n        this.singleton = new (await import('./native/NativeController')).default\n      }\n    }\n    return this.singleton\n  }\n\n  constructor(worker?: FloccusWorker) {\n    this.worker = worker\n  }\n\n  async getWorker(): Promise<FloccusWorker> {\n    if (this.worker) {\n      return Promise.resolve(this.worker)\n    }\n    if (!navigator.userAgent.includes('Firefox') && navigator.serviceWorker?.controller) {\n      return navigator.serviceWorker.ready.then((registration) => ({\n        postMessage: (...args) => registration.active.postMessage(...args),\n        addEventListener: (fn) => {\n          const listener = (event) => fn(event.data)\n          navigator.serviceWorker.addEventListener('message', listener)\n          return () => navigator.serviceWorker.removeEventListener('message', listener)\n        },\n      }))\n    }\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../lib/browser-api')).default\n      return {\n        postMessage: (data) => {\n          try {\n            browser.runtime.sendMessage(data)\n          } catch (e) {\n            console.warn(e)\n          }\n        },\n        addEventListener: (fn) => {\n          try {\n            browser.runtime.onMessage.addListener(fn)\n          } catch (e) {\n            console.warn(e)\n          }\n          return () => {\n            try {\n              browser.runtime.onMessage.removeListener(fn)\n            } catch (e) {\n              console.warn(e)\n            }\n          }\n        },\n      }\n    }\n  }\n\n  async cancelSync(accountId, keepEnabled): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'cancelSync', params: [accountId, keepEnabled]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  onStatusChange(listener): () => void {\n    const eventListener = (data) => {\n      const {type} = data\n      if (type === 'status:update') {\n        listener()\n      }\n    }\n    let worker, removeListener\n    this.getWorker().then(w => {\n      worker = w\n      removeListener = worker.addEventListener(eventListener)\n    })\n    return () => {\n      removeListener && removeListener()\n    }\n  }\n\n  async scheduleSync(accountId, wait): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'scheduleSync', params: [accountId, wait]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async scheduleAll(): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'scheduleAll', params: []}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async setEnabled(enabled: boolean): Promise<void> {\n    const worker = await this.getWorker()\n    const message = {type: 'setEnabled', params: [enabled]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async syncAccount(accountId, strategy, forceSync = false): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'syncAccount', params: [accountId, strategy, forceSync]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async unlock(key): Promise<void> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n    const message = {type: 'unlock', params: [key]}\n    worker.postMessage(message)\n    console.log('Sending message to service worker: ', message)\n  }\n\n  async getUnlocked(): Promise<boolean> {\n    console.log('Waiting for service worker readiness')\n    const worker = await this.getWorker()\n\n    return new Promise((resolve) => {\n      const eventListener = (data) => {\n        if (data.type === 'getUnlockedResponse') {\n          resolve(data.params[0])\n          console.log('Message response received', data)\n          removeEventListener()\n        }\n      }\n      const removeEventListener = worker.addEventListener(eventListener)\n      const message = { type: 'getUnlocked', params: [] }\n      worker.postMessage(message)\n      console.log('Sending message to service worker: ', message)\n    })\n  }\n\n  async onLoad() {\n    // noop\n  }\n}\n","import { fromUint8Array, toUint8Array } from 'js-base64'\n\nexport default class Crypto {\n  static iterations = 250000\n  static ivLength = 16\n\n  static async sha256(message: string): Promise<string> {\n    const msgBuffer = new TextEncoder().encode(message) // encode as UTF-8\n    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer) // hash the message\n    const hashHex = this.bufferToHexstr(new Uint8Array(hashBuffer)) // convert bytes to hex string\n    return hashHex\n  }\n\n  static bufferToHexstr(buffer: Uint8Array): string {\n    return Array.from(new Uint8Array(buffer))\n      .map(b => ('00' + b.toString(16)).slice(-2))\n      .join('') // convert bytes to hex string\n  }\n\n  static hexstrToBuffer(hex: string): Uint8Array {\n    for (\n      var bytes = new Uint8Array(hex.length / 2), c = 0;\n      c < hex.length;\n      c += 2\n    ) {\n      bytes[c / 2] = parseInt(hex.substr(c, 2), 16)\n    }\n    return bytes\n  }\n\n  static async prepareKey(passphrase: string, salt: string): Promise<CryptoKey> {\n    const enc = new TextEncoder()\n    const passphraseBytes = enc.encode(passphrase)\n    const saltBytes = enc.encode(salt)\n    const key = await crypto.subtle.importKey('raw', passphraseBytes, 'PBKDF2', false, ['deriveKey'])\n    return crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        hash: 'SHA-256',\n        salt: saltBytes,\n        iterations: Crypto.iterations\n      },\n      key,\n      {\n        name: 'AES-GCM',\n        length: 256\n      },\n      false,\n      ['encrypt', 'decrypt']\n    )\n  }\n\n  static async decryptAES(key: string, payload: string, salt: string) : Promise<string> {\n    const cryptoKey = await this.prepareKey(key, salt)\n    const buffer = toUint8Array(payload)\n    const iv = buffer.slice(0, this.ivLength)\n    const ciphertext = buffer.slice(this.ivLength)\n\n    const plaintextBytes = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, cryptoKey, ciphertext)\n    return new TextDecoder().decode(plaintextBytes)\n  }\n\n  static async encryptAES(key: string, message: string, salt: string): Promise<string> {\n    // Generate a random 16 byte initialization vector\n    const iv = this.getRandomBytes(this.ivLength)\n    const messageBytes = new TextEncoder().encode(message)\n    const cryptoKey = await this.prepareKey(key, salt)\n    const ciphertext = await crypto.subtle.encrypt(\n      { name: 'AES-GCM', iv },\n      cryptoKey,\n      messageBytes\n    )\n\n    const resultBytes = this.concatBytes(iv, new Uint8Array(ciphertext))\n\n    return fromUint8Array(resultBytes)\n  }\n\n  static concatBytes(array1: Uint8Array, array2: Uint8Array): Uint8Array {\n    const result = new Uint8Array(array1.length + array2.length)\n    result.set(array1, 0)\n    result.set(array2, array1.length)\n    return result\n  }\n\n  static getRandomBytes(bytelength: number) : Uint8Array {\n    const rand = new Uint8Array(bytelength)\n    crypto.getRandomValues(rand)\n    return rand\n  }\n}\n","import { Folder, TItem, ItemType, TItemLocation, ItemLocation, hydrate } from './Tree'\nimport Mappings, { MappingSnapshot } from './Mappings'\nimport Ordering from './interfaces/Ordering'\nimport batchingToposort from 'batching-toposort'\nimport Logger from './Logger'\n\nexport const ActionType = {\n  CREATE: 'CREATE',\n  UPDATE: 'UPDATE',\n  MOVE: 'MOVE',\n  REMOVE: 'REMOVE',\n  REORDER: 'REORDER',\n} as const\n\nexport type TActionType = (typeof ActionType)[keyof typeof ActionType];\n\nexport interface CreateAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'CREATE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  index?: number,\n  oldIndex?: number,\n}\n\nexport interface UpdateAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'UPDATE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n}\n\nexport interface RemoveAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'REMOVE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  index?: number,\n  oldIndex?: number,\n}\n\nexport interface ReorderAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'REORDER',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  order: Ordering<L1>,\n  oldOrder?: Ordering<L2>,\n}\n\nexport interface MoveAction<L1 extends TItemLocation, L2 extends TItemLocation> {\n  type: 'MOVE',\n  payload: TItem<L1>,\n  oldItem?: TItem<L2>,\n  index?: number,\n  oldIndex?: number,\n}\n\nexport type Action<L1 extends TItemLocation, L2 extends TItemLocation> = CreateAction<L1, L2>|UpdateAction<L1, L2>|RemoveAction<L1, L2>|ReorderAction<L1,L2>|MoveAction<L1,L2>\n\nexport type LocationOfAction<A> = A extends Action<infer L, TItemLocation> ? L : never\nexport type OldLocationOfAction<A> = A extends Action<TItemLocation, infer L> ? L : never\n\nexport type MapLocation<A extends Action<TItemLocation, TItemLocation>, NewLocation extends TItemLocation> =\n// eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n  A extends CreateAction<infer O, infer P> ?\n    CreateAction<NewLocation, O>\n    // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n    : A extends UpdateAction<infer O, infer P> ?\n      UpdateAction<NewLocation, O>\n      // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n      : A extends MoveAction<infer O, infer P> ?\n        MoveAction<NewLocation, O>\n        // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n        : A extends RemoveAction<infer O, infer P> ?\n          RemoveAction<NewLocation, O>\n          // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars\n          : A extends ReorderAction<infer O, infer P> ?\n            ReorderAction<NewLocation, O>\n            : never\n\nexport default class Diff<L1 extends TItemLocation, L2 extends TItemLocation, A extends Action<L1, L2>> {\n  private readonly actions: A[]\n\n  constructor() {\n    this.actions = []\n  }\n\n  clone(filter: (action:A)=>boolean = () => true): Diff<L1, L2, A> {\n    const newDiff : Diff<L1, L2, A> = new Diff\n    this.getActions().forEach((action: A) => {\n      if (filter(action)) {\n        newDiff.commit(action)\n      }\n    })\n\n    return newDiff\n  }\n\n  commit(action: A):void {\n    this.actions.push({ ...action })\n  }\n\n  retract(action: A):void {\n    this.actions.splice(this.actions.indexOf(action), 1)\n  }\n\n  getActions():A[] {\n    return [].concat(\n      this.actions\n    )\n  }\n\n  static findChain(\n    mappingsSnapshot: MappingSnapshot,\n    actions: Action<TItemLocation, TItemLocation>[], itemTree: Folder<TItemLocation>,\n    currentItem: TItem<TItemLocation>,\n    targetAction: Action<TItemLocation, TItemLocation>,\n    chain: Action<TItemLocation, TItemLocation>[] = []\n  ): boolean {\n    const targetItemInTree = itemTree.findFolder(Mappings.mapId(mappingsSnapshot, targetAction.payload, itemTree.location))\n    if (\n      targetAction.payload.findItem(ItemType.FOLDER,\n        Mappings.mapParentId(mappingsSnapshot, currentItem, targetAction.payload.location)) ||\n      (targetItemInTree && targetItemInTree.findFolder(Mappings.mapParentId(mappingsSnapshot, currentItem, itemTree.location)))\n    ) {\n      return true\n    }\n    const newCurrentActions = actions.filter(targetAction =>\n      !chain.includes(targetAction) && (\n        targetAction.payload.findItem(ItemType.FOLDER, Mappings.mapParentId(mappingsSnapshot, currentItem, targetAction.payload.location)) ||\n        (\n          itemTree.findFolder(Mappings.mapId(mappingsSnapshot, targetAction.payload, itemTree.location)) &&\n          itemTree.findFolder(Mappings.mapId(mappingsSnapshot, targetAction.payload, itemTree.location)).findFolder(Mappings.mapParentId(mappingsSnapshot, currentItem, itemTree.location)))\n      )\n    )\n    if (newCurrentActions.length) {\n      for (const newCurrentAction of newCurrentActions) {\n        if (Diff.findChain(mappingsSnapshot, actions, itemTree, newCurrentAction.payload, targetAction, [...chain, newCurrentAction])) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  static sortMoves<L1 extends TItemLocation, L2 extends TItemLocation>(actions: MoveAction<L1, L2>[], tree: Folder<L1>) :MoveAction<L1, L2>[][] {\n    const bookmarks = actions.filter(a => a.payload.type === ItemType.BOOKMARK)\n    const folderMoves = actions.filter(a => a.payload.type === ItemType.FOLDER)\n    const DAG = folderMoves\n      .reduce((DAG, action1) => {\n        DAG[action1.payload.id] = folderMoves.filter(action2 => {\n          if (action1 === action2 || String(action1.payload.id) === String(action2.payload.id)) {\n            return false\n          }\n          return (\n            (tree.findItem(action1.payload.type, action1.payload.id) && tree.findItem(action1.payload.type, action1.payload.id).findItem(action2.payload.type, action2.payload.id))\n          )\n        })\n          .map(a => a.payload.id)\n        return DAG\n      }, {})\n    let batches\n    try {\n      batches = batchingToposort(DAG).map(batch => batch.map(id => folderMoves.find(a => String(a.payload.id) === String(id))))\n    } catch (e) {\n      console.log({DAG, tree, actions})\n      throw e\n    }\n    batches.push(bookmarks)\n    batches.reverse()\n    return batches\n  }\n\n  /**\n   * on ServerToLocal: don't map removals\n   * on LocalToServer:\n   * @param mappingsSnapshot\n   * @param targetLocation\n   * @param filter\n   * @param skipErroneousActions\n   */\n  map<L3 extends TItemLocation>(mappingsSnapshot:MappingSnapshot, targetLocation: L3, filter: (action: A)=>boolean = () => true, skipErroneousActions = false): Diff<L3, L1, MapLocation<A, L3>> {\n    const newDiff : Diff<L3, L1, MapLocation<A, L3>> = new Diff\n\n    // Map payloads\n    this.getActions()\n      .map(a => a as A)\n      .forEach(action => {\n        let newAction\n\n        if (!filter(action)) {\n          return\n        }\n\n        // needed because we set oldItem in the first section, so we wouldn't know anymore if it was set before\n        const oldItem = action.oldItem\n\n        // We have two sections here, because we want to be able to take IDs from oldItem even for moves\n        // but not parentIds (which do change during moves, obviously)\n\n        if (oldItem && targetLocation !== ItemLocation.SERVER) {\n          const oldId = action.oldItem.id\n          const newId = action.payload.id\n          newAction = {\n            ...action,\n            payload: action.payload.cloneWithLocation(false, targetLocation),\n            oldItem: action.oldItem.cloneWithLocation(false, action.payload.location)\n          }\n          newAction.payload.id = oldId\n          newAction.oldItem.id = newId\n        } else {\n          newAction = {\n            ...action,\n            payload: action.payload.cloneWithLocation(false, targetLocation),\n            oldItem: action.payload.clone(false)\n          }\n          newAction.payload.id = Mappings.mapId(mappingsSnapshot, action.payload, targetLocation)\n        }\n\n        if (oldItem && targetLocation !== ItemLocation.SERVER && action.type !== ActionType.MOVE) {\n          newAction.oldItem.parentId = action.payload.parentId\n          newAction.payload.parentId = Mappings.mapParentId(mappingsSnapshot, action.oldItem, targetLocation)\n        } else {\n          newAction.oldItem.parentId = action.payload.parentId\n          newAction.payload.parentId = Mappings.mapParentId(mappingsSnapshot, action.payload, targetLocation)\n          if (typeof newAction.payload.parentId === 'undefined' && typeof action.payload.parentId !== 'undefined') {\n            if (skipErroneousActions) {\n              // simply ignore this action as it appears to be no longer valid\n              Logger.log('Failed to map parentId: ' + action.payload.parentId)\n              Logger.log('Removing MOVE action from plan:', action)\n              return\n            } else {\n              Logger.log('payload.location = ' + action.payload.location + ' | targetLocation = ' + targetLocation)\n              const diff = new Diff()\n              diff.commit(action)\n              Logger.log('Failed to map parentId of action ' + diff.inspect())\n              Logger.log(JSON.stringify(mappingsSnapshot, null,'\\t'))\n              throw new Error('Failed to map parentId to ' + targetLocation + ': ' + action.payload.parentId)\n            }\n          }\n        }\n\n        if (action.type === ActionType.REORDER) {\n          newAction.oldOrder = action.order\n          newAction.order = action.order.map(item => {\n            return {...item, id: mappingsSnapshot[(targetLocation === ItemLocation.LOCAL ? ItemLocation.SERVER : ItemLocation.LOCAL) + 'To' + targetLocation][item.type][item.id]}\n          })\n        }\n\n        newDiff.commit(newAction)\n      })\n    return newDiff\n  }\n\n  toJSON() {\n    return this.getActions().map((action: A) => {\n      return {\n        ...action,\n        payload: action.payload.clone(false),\n        oldItem: action.oldItem && action.oldItem.clone(false),\n      }\n    })\n  }\n\n  inspect(depth = 0):string {\n    return 'Diff\\n' + this.getActions().map((action: A) => {\n      return `\\nAction: ${action.type}\\nPayload: #${action.payload.id}[${action.payload.title}]${'url' in action.payload ? `(${action.payload.url})` : ''} parentId: ${action.payload.parentId} ${'index' in action ? `Index: ${action.index}\\n` : ''}${'order' in action ? `Order: ${JSON.stringify(action.order, null, '\\t')}` : ''}`\n    }).join('\\n')\n  }\n\n  static fromJSON<L1 extends TItemLocation, L2 extends TItemLocation, A2 extends Action<L1, L2>>(json) {\n    const diff: Diff<L1, L2, A2> = new Diff\n    json.forEach((action: A2): void => {\n      action.payload = hydrate<L1>(action.payload)\n      action.oldItem = action.oldItem && hydrate<L2>(action.oldItem)\n      diff.commit(action)\n    })\n    return diff\n  }\n}\n\nexport interface PlanStage1<L1 extends TItemLocation, L2 extends TItemLocation> {\n  CREATE: Diff<L1, L2, CreateAction<L1, L2>>\n  UPDATE: Diff<L1, L2, UpdateAction<L1, L2>>\n  MOVE: Diff<L1, L2, MoveAction<L1, L2>>\n  REMOVE: Diff<L2, L1, RemoveAction<L2, L1>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport interface PlanStage2<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation> {\n  CREATE: Diff<L3, L1, CreateAction<L3, L1>>\n  UPDATE: Diff<L3, L1, UpdateAction<L3, L1>>\n  MOVE: Diff<L1, L2, MoveAction<L1, L2>>\n  REMOVE: Diff<L3, L2, RemoveAction<L3, L2>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport interface PlanStage3<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation> {\n  CREATE: Diff<L3, L1, CreateAction<L3, L1>>\n  UPDATE: Diff<L3, L1, UpdateAction<L3, L1>>\n  MOVE: Diff<L3, L1, MoveAction<L3, L1>>\n  REMOVE: Diff<L3, L2, RemoveAction<L3, L2>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport interface PlanRevert<L1 extends TItemLocation, L2 extends TItemLocation> {\n  CREATE: Diff<L1, L2, CreateAction<L1, L2>>\n  UPDATE: Diff<L1, L2, UpdateAction<L1, L2>>\n  MOVE: Diff<L2, L1, MoveAction<L2, L1>>\n  REMOVE: Diff<L1, L2, RemoveAction<L1, L2>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n","import browser from './browser-api'\nimport Logger from './Logger'\nimport { OrderFolderResource } from './interfaces/Resource'\nimport PQueue from 'p-queue'\nimport { Bookmark, Folder, ItemLocation } from './Tree'\nimport Ordering from './interfaces/Ordering'\nimport uniq from 'lodash/uniq'\n\nexport default class LocalTabs implements OrderFolderResource<typeof ItemLocation.LOCAL> {\n  private queue: PQueue<{ concurrency: 10 }>\n  private storage: unknown\n\n  constructor(storage:unknown) {\n    this.storage = storage\n    this.queue = new PQueue({ concurrency: 10 })\n  }\n\n  async getBookmarksTree():Promise<Folder<typeof ItemLocation.LOCAL>> {\n    let tabs = await browser.tabs.query({\n      windowType: 'normal' // no devtools or panels or popups\n    })\n    tabs = tabs.filter(tab => !tab.incognito)\n\n    return new Folder({\n      title: '',\n      id: 'tabs',\n      location: ItemLocation.LOCAL,\n      children: uniq(tabs.map(t => t.windowId)).map((windowId, i) => {\n        return new Folder({\n          title: 'Window ' + i,\n          id: windowId,\n          parentId: 'tabs',\n          location: ItemLocation.LOCAL,\n          children: tabs\n            .filter(t => t.windowId === windowId)\n            .sort((t1,t2) => t1.index - t2.index)\n            .map(t => new Bookmark({\n              id: t.id,\n              title: t.title,\n              url: t.url,\n              parentId: windowId,\n              location: ItemLocation.LOCAL,\n            }))\n        })\n      })\n    })\n  }\n\n  async createBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    Logger.log('(tabs)CREATE', bookmark)\n    if (bookmark.parentId === 'tabs') {\n      Logger.log('Parent is \"tabs\", ignoring this one.')\n      return\n    }\n    if (self.location.protocol === 'moz-extension:' && new URL(bookmark.url).protocol === 'file:') {\n      Logger.log('URL is a file URL and we are on firefox, ignoring this one.')\n      return\n    }\n    const node = await this.queue.add(() =>\n      browser.tabs.create({\n        windowId: typeof bookmark.parentId === 'string' ? parseInt(bookmark.parentId) : bookmark.parentId,\n        url: bookmark.url,\n        // Only firefox allows discarded prop\n        ...(typeof browser.BookmarkTreeNodeType !== 'undefined' && { discarded: true }),\n        active: false,\n      })\n    )\n    await awaitTabsUpdated()\n    return node.id\n  }\n\n  async updateBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(tabs)UPDATE', bookmark)\n    if (bookmark.parentId === 'tabs') {\n      Logger.log('Parent is \"tabs\", ignoring this one.')\n      return\n    }\n    await this.queue.add(() =>\n      browser.tabs.update(bookmark.id, {\n        url: bookmark.url\n      })\n    )\n    await this.queue.add(() =>\n      browser.tabs.move(bookmark.id, {\n        windowId: bookmark.parentId,\n        index: -1 // last\n      })\n    )\n    await awaitTabsUpdated()\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<void> {\n    const bookmarkId = bookmark.id\n    Logger.log('(tabs)REMOVE', bookmark)\n    if (bookmark.parentId === 'tabs') {\n      Logger.log('Parent is \"tabs\", ignoring this one.')\n      return\n    }\n    await this.queue.add(() => browser.tabs.remove(bookmarkId))\n    await awaitTabsUpdated()\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.LOCAL>): Promise<number> {\n    Logger.log('(tabs)CREATEFOLDER', folder)\n    const node = await this.queue.add(() =>\n      browser.windows.create()\n    )\n    return node.id\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(tabs)ORDERFOLDER', { id, order })\n    const originalTabs = await browser.tabs.query({\n      windowId: id\n    })\n    try {\n      for (let index = 0; index < order.length; index++) {\n        await browser.tabs.move(order[index].id, { index })\n      }\n    } catch (e) {\n      throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n    }\n    // Move items not touched by sync back to where they were\n    // Not perfect but good enough (Problem: [a,X,c] => insert(b,0) => [b, X, a, c])\n    if (originalTabs.length !== order.length) {\n      const untouchedChildren = originalTabs.map((tab, i) => [i, tab]).filter(([, tab]) =>\n        !order.some(item => String(tab.id) === String(item.id))\n      )\n      try {\n        for (const [index, child] of untouchedChildren) {\n          await browser.tabs.move(child.id, {index})\n        }\n      } catch (e) {\n        throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n      }\n    }\n    await awaitTabsUpdated()\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(tabs)UPDATEFOLDER (noop)', folder)\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    const id = folder.id\n    Logger.log('(tabs)REMOVEFOLDER', id)\n    await this.queue.add(() => browser.window.remove(id))\n  }\n\n  async isAvailable(): Promise<boolean> {\n    const tabs = await browser.tabs.query({\n      windowType: 'normal' // no devtools or panels or popups\n    })\n    return Boolean(tabs.length)\n  }\n}\n\nfunction awaitTabsUpdated() {\n  return Promise.race([\n    new Promise<void>(resolve => {\n      browser.tabs.onUpdated.addListener(() => {\n        browser.tabs.onUpdated.removeListener(resolve)\n        setTimeout(() => resolve(), 1000)\n      })\n    }),\n    new Promise(resolve => setTimeout(resolve, 1100))\n  ])\n}\n","import { TItem, TItemLocation, TItemType } from './Tree'\n\ntype InternalItemTypeMapping = { LocalToServer: Record<string, string>, ServerToLocal: Record<string, string> }\n\nexport type Mapping = Record<TItemType,Record<string,number|string>>\n\nexport type MappingSnapshot = {\n  ServerToLocal: Mapping,\n  LocalToServer: Mapping\n}\n\nexport default class Mappings {\n  private folders: InternalItemTypeMapping\n  private bookmarks: InternalItemTypeMapping\n  private storage: any\n\n  constructor(storageAdapter:any, mappingsData:any) {\n    this.storage = storageAdapter\n    this.folders = mappingsData.folders\n    this.bookmarks = mappingsData.bookmarks\n  }\n\n  getSnapshot():MappingSnapshot {\n    return {\n      ServerToLocal: {\n        bookmark: {...this.bookmarks.ServerToLocal},\n        folder: {...this.folders.ServerToLocal}\n      },\n      LocalToServer: {\n        bookmark: {...this.bookmarks.LocalToServer},\n        folder: {...this.folders.LocalToServer}\n      }\n    }\n  }\n\n  async addFolder({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.add(this.folders, { localId, remoteId })\n  }\n\n  async removeFolder({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.remove(this.folders, { localId, remoteId })\n  }\n\n  async addBookmark({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.add(this.bookmarks, { localId, remoteId })\n  }\n\n  async removeBookmark({ localId, remoteId }: { localId?:string|number, remoteId?:string|number }):Promise<void> {\n    Mappings.remove(this.bookmarks, { localId, remoteId })\n  }\n\n  async persist():Promise<void> {\n    await this.storage.setMappings({\n      folders: this.folders,\n      bookmarks: this.bookmarks\n    })\n  }\n\n  private static add(mappings, { localId, remoteId }: { localId?:string|number, remoteId?:string|number }) {\n    if (typeof localId === 'undefined' || typeof remoteId === 'undefined') {\n      throw new Error('Cannot add empty mapping')\n    }\n    mappings.LocalToServer[localId] = remoteId\n    mappings.ServerToLocal[remoteId] = localId\n  }\n\n  private static remove(mappings, { localId, remoteId }: { localId?:string|number, remoteId?:string|number }):InternalItemTypeMapping {\n    if (localId && remoteId && mappings.LocalToServer[localId] !== remoteId) {\n      mappings = this.remove(mappings, { localId })\n      return this.remove(mappings, { remoteId })\n    }\n\n    if (typeof localId !== 'undefined') {\n      delete mappings.ServerToLocal[mappings.LocalToServer[localId]]\n      delete mappings.LocalToServer[localId]\n    } else {\n      delete mappings.LocalToServer[mappings.ServerToLocal[remoteId]]\n      delete mappings.ServerToLocal[remoteId]\n    }\n  }\n\n  static mapId(mappingsSnapshot:MappingSnapshot, item: TItem<TItemLocation>, target: TItemLocation) : string|number {\n    if (item.location === target) {\n      return item.id\n    }\n    return mappingsSnapshot[item.location + 'To' + target][item.type][item.id]\n  }\n\n  static mapParentId(mappingsSnapshot:MappingSnapshot, item: TItem<TItemLocation>, target: TItemLocation) : string|number {\n    if (item.location === target) {\n      return item.parentId\n    }\n    return mappingsSnapshot[item.location + 'To' + target].folder[item.parentId]\n  }\n\n  static mappable(mappingsSnapshot: MappingSnapshot, item1: TItem<TItemLocation>, item2: TItem<TItemLocation>) : boolean {\n    if (Mappings.mapId(mappingsSnapshot, item1, item2.location) === item2.id) {\n      return true\n    }\n    if (Mappings.mapId(mappingsSnapshot, item2, item1.location) === item1.id) {\n      return true\n    }\n    return false\n  }\n}\n","import * as Parallel from 'async-parallel'\nimport Diff, { ActionType, CreateAction, MoveAction, RemoveAction, ReorderAction, UpdateAction } from './Diff'\nimport { Bookmark, Folder, ItemLocation, ItemType, TItem, TItemLocation } from './Tree'\nimport Logger from './Logger'\n\nexport interface ScanResult<L1 extends TItemLocation, L2 extends TItemLocation> {\n  CREATE: Diff<L1, L2, CreateAction<L1, L2>>\n  UPDATE: Diff<L1, L2, UpdateAction<L1, L2>>\n  MOVE: Diff<L1, L2, MoveAction<L1, L2>>\n  REMOVE: Diff<L2, L1, RemoveAction<L2, L1>>\n  REORDER: Diff<L1, L2, ReorderAction<L1, L2>>\n}\n\nexport default class Scanner<L1 extends TItemLocation, L2 extends TItemLocation> {\n  private oldTree: TItem<L1>\n  private newTree: TItem<L2>\n  private mergeable: (i1: TItem<TItemLocation>, i2: TItem<TItemLocation>) => boolean\n  private preserveOrder: boolean\n  private checkHashes: boolean\n  private hasCache: boolean\n\n  private result: ScanResult<L2, L1>\n\n  constructor(oldTree:TItem<L1>, newTree:TItem<L2>, mergeable:(i1:TItem<TItemLocation>, i2:TItem<TItemLocation>)=>boolean, preserveOrder:boolean, checkHashes = true, hasCache = true) {\n    this.oldTree = oldTree\n    this.newTree = newTree\n    this.mergeable = mergeable\n    this.preserveOrder = preserveOrder\n    this.checkHashes = typeof checkHashes === 'undefined' ? true : checkHashes\n    this.hasCache = hasCache\n    this.result = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n  }\n\n  getDiffs(): ScanResult<L2, L1> {\n    return this.result\n  }\n\n  async run():Promise<ScanResult<L2, L1>> {\n    await this.diffItem(this.oldTree, this.newTree)\n    await this.findMoves()\n    await this.addReorders()\n    return this.result\n  }\n\n  async diffItem(oldItem:TItem<L1>, newItem:TItem<L2>):Promise<void> {\n    // give the browser time to breathe\n    await Promise.resolve()\n    Logger.log('Calculating diff for ', oldItem, newItem)\n    if (oldItem.type === 'folder' && newItem.type === 'folder') {\n      return this.diffFolder(oldItem, newItem)\n    } else if (oldItem.type === 'bookmark' && newItem.type === 'bookmark') {\n      return this.diffBookmark(oldItem, newItem)\n    } else {\n      throw new Error('Mismatched diff items: ' + oldItem.type + ', ' + newItem.type)\n    }\n  }\n\n  async diffFolder(oldFolder:Folder<L1>, newFolder:Folder<L2>):Promise<void> {\n    if (this.checkHashes) {\n      const hasChanged = await this.folderHasChanged(oldFolder, newFolder)\n      if (!hasChanged) {\n        return\n      }\n    }\n\n    if (oldFolder.title !== newFolder.title && typeof oldFolder.parentId !== 'undefined' && typeof newFolder.parentId !== 'undefined') {\n      // folder title changed and it's not the root folder\n      this.result.UPDATE.commit({type: ActionType.UPDATE, payload: newFolder, oldItem: oldFolder})\n    }\n\n    // Preserved Items and removed Items\n    // (using map here, because 'each' doesn't provide indices)\n    const unmatchedChildren = newFolder.children.slice(0)\n    await Parallel.map(oldFolder.children, async(old, index) => {\n      const newItem = unmatchedChildren.find((child) => old.type === child.type && this.mergeable(old, child))\n      // we found an item in the new folder that matches the one in the old folder\n      if (newItem) {\n        await this.diffItem(old, newItem)\n        unmatchedChildren.splice(unmatchedChildren.indexOf(newItem), 1)\n        return\n      }\n\n      if (newFolder.isRoot && newFolder.location === ItemLocation.LOCAL) {\n        // We can't remove root folders locally\n        return\n      }\n\n      this.result.REMOVE.commit({type: ActionType.REMOVE, payload: old, index})\n    }, 1)\n\n    // created Items\n    // (using map here, because 'each' doesn't provide indices)\n    await Parallel.map(unmatchedChildren, async(newChild, index) => {\n      if (oldFolder.isRoot && oldFolder.location === ItemLocation.LOCAL) {\n        // We can't create root folders locally\n        return\n      }\n      this.result.CREATE.commit({type: ActionType.CREATE, payload: newChild, index})\n    }, 1)\n\n    if (newFolder.children.length > 1) {\n      this.result.REORDER.commit({\n        type: ActionType.REORDER,\n        payload: newFolder,\n        order: newFolder.children.map(i => ({ type: i.type, id: i.id })),\n      })\n    }\n  }\n\n  async diffBookmark(oldBookmark:Bookmark<L1>, newBookmark:Bookmark<L2>):Promise<void> {\n    let hasChanged\n    if (this.checkHashes) {\n      hasChanged = await this.bookmarkHasChanged(oldBookmark, newBookmark)\n    } else {\n      hasChanged = oldBookmark.title !== newBookmark.title || oldBookmark.url !== newBookmark.url\n    }\n    if (hasChanged) {\n      this.result.UPDATE.commit({ type: ActionType.UPDATE, payload: newBookmark, oldItem: oldBookmark })\n    }\n  }\n\n  async bookmarkHasChanged(oldBookmark:Bookmark<L1>, newBookmark:Bookmark<L2>):Promise<boolean> {\n    const oldHash = await oldBookmark.hash()\n    const newHash = await newBookmark.hash()\n    return oldHash !== newHash\n  }\n\n  async folderHasChanged(oldFolder:Folder<L1>, newFolder:Folder<L2>):Promise<boolean> {\n    const oldHash = await oldFolder.hash(this.preserveOrder)\n    const newHash = await newFolder.hash(this.preserveOrder)\n    return oldHash !== newHash\n  }\n\n  async findMoves():Promise<void> {\n    Logger.log('Scanner: Finding moves')\n    let createActions\n    let removeActions\n    let reconciled = true\n\n    // As soon as one match is found, action list is updated and search is started with the new list\n    // repeat until no rewrites happen anymore\n    while (reconciled) {\n      reconciled = false\n      let createAction: CreateAction<L2, L1>, removeAction: RemoveAction<L1,L2>\n\n      // First find direct matches (avoids glitches when folders and their contents have been moved)\n      createActions = this.result.CREATE.getActions()\n      while (!reconciled && (createAction = createActions.shift())) {\n        // give the browser time to breathe\n        await Promise.resolve()\n        const createdItem = createAction.payload\n        removeActions = this.result.REMOVE.getActions()\n        while (!reconciled && (removeAction = removeActions.shift())) {\n          // give the browser time to breathe\n          await Promise.resolve()\n          const removedItem = removeAction.payload\n\n          if (this.mergeable(removedItem, createdItem) &&\n            (removedItem.type !== 'folder' ||\n              (!this.hasCache && removedItem.childrenSimilarity(createdItem) > 0.8))) {\n            this.result.CREATE.retract(createAction)\n            this.result.REMOVE.retract(removeAction)\n            this.result.MOVE.commit({\n              type: ActionType.MOVE,\n              payload: createdItem,\n              oldItem: removedItem,\n              index: createAction.index,\n              oldIndex: removeAction.index\n            })\n            reconciled = true\n            // Don't use the items from the action, but the ones in the actual tree to avoid using tree parts mutated by this algorithm (see below)\n            await this.diffItem(removedItem, createdItem)\n          }\n        }\n      }\n\n      // Then find descendant matches\n      createActions = this.result.CREATE.getActions()\n      while (!reconciled && (createAction = createActions.shift())) {\n        // give the browser time to breathe\n        await Promise.resolve()\n        const createdItem = createAction.payload\n        removeActions = this.result.REMOVE.getActions()\n        while (!reconciled && (removeAction = removeActions.shift())) {\n          // give the browser time to breathe\n          await Promise.resolve()\n          const removedItem = removeAction.payload\n          const oldItem = removedItem.findItemFilter(\n            createdItem.type,\n            item => this.mergeable(item, createdItem),\n            item => item.childrenSimilarity(createdItem)\n          )\n          if (oldItem) {\n            let oldIndex\n            this.result.CREATE.retract(createAction)\n            if (oldItem === removedItem) {\n              this.result.REMOVE.retract(removeAction)\n            } else {\n              // We clone the item here, because we don't want to mutate all copies of this tree (item)\n              const removedItemClone = removedItem.clone(true)\n              const oldParentClone = removedItemClone.findItem(ItemType.FOLDER, oldItem.parentId) as Folder<L1>\n              const oldItemClone = removedItemClone.findItem(oldItem.type, oldItem.id)\n              oldIndex = oldParentClone.children.indexOf(oldItemClone)\n              oldParentClone.children.splice(oldIndex, 1)\n              removeAction.payload = removedItemClone\n              removeAction.payload.createIndex()\n            }\n            this.result.MOVE.commit({\n              type: ActionType.MOVE,\n              payload: createdItem,\n              oldItem,\n              index: createAction.index,\n              oldIndex: oldIndex || removeAction.index\n            })\n            reconciled = true\n            if (oldItem.type === ItemType.FOLDER) { // TODO: Is this necessary?\n              await this.diffItem(oldItem, createdItem)\n            }\n          } else {\n            const newItem = createdItem.findItemFilter(\n              removedItem.type,\n              item => this.mergeable(removedItem, item),\n              item => item.childrenSimilarity(removedItem)\n            )\n            let index\n            if (newItem) {\n              this.result.REMOVE.retract(removeAction)\n              if (newItem === createdItem) {\n                this.result.CREATE.retract(createAction)\n              } else {\n                // We clone the item here, because we don't want to mutate all copies of this tree (item)\n                const createdItemClone = createdItem.clone(true)\n                const newParentClone = createdItemClone.findItem(ItemType.FOLDER, newItem.parentId) as Folder<L2>\n                const newClonedItem = createdItemClone.findItem(newItem.type, newItem.id)\n                index = newParentClone.children.indexOf(newClonedItem)\n                newParentClone.children.splice(index, 1)\n                createAction.payload = createdItemClone\n                createAction.payload.createIndex()\n              }\n              this.result.MOVE.commit({\n                type: ActionType.MOVE,\n                payload: newItem,\n                oldItem: removedItem,\n                index: index || createAction.index,\n                oldIndex: removeAction.index\n              })\n              reconciled = true\n              if (removedItem.type === ItemType.FOLDER) {\n                await this.diffItem(removedItem, newItem)\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Remove all UPDATEs that have already been handled by a MOVE\n    const moves = this.result.MOVE.getActions()\n    const updates = this.result.UPDATE.getActions()\n    updates.forEach(update => {\n      if (moves.find(move => String(move.payload.id) === String(update.payload.id))) {\n        this.result.UPDATE.retract(update)\n      }\n    })\n  }\n\n  async addReorders(): Promise<void> {\n    Logger.log('Scanner: Generate reorders')\n    const targets = {}\n    const sources = {}\n\n    // Collect folders to reorder\n    this.result.CREATE.getActions()\n      .forEach(action => {\n        targets[action.payload.parentId] = true\n      })\n    this.result.REMOVE.getActions()\n      .forEach(action => {\n        sources[action.payload.parentId] = true\n      })\n    this.result.MOVE.getActions()\n      .forEach(action => {\n        targets[action.payload.parentId] = true\n        sources[action.oldItem.parentId] = true\n      })\n\n    for (const folderId in sources) {\n      const oldFolder = this.oldTree.findItem(ItemType.FOLDER, folderId) as Folder<L1>\n      if (!oldFolder) {\n        // In case a MOVE's old parent was removed\n        continue\n      }\n      const newFolder = this.newTree.findItemFilter(ItemType.FOLDER, (item) => this.mergeable(oldFolder, item)) as Folder<L2>\n      if (newFolder) {\n        targets[newFolder.id] = true\n      }\n    }\n\n    for (const folderId in targets) {\n      const newFolder = this.newTree.findItem(ItemType.FOLDER, folderId) as Folder<L2>\n      const duplicate = this.result.REORDER.getActions().find(a => String(a.payload.id) === String(newFolder.id))\n      if (duplicate) {\n        this.result.REORDER.retract(duplicate)\n      }\n      this.result.REORDER.commit({\n        type: ActionType.REORDER,\n        payload: newFolder,\n        order: newFolder.children.map(i => ({ type: i.type, id: i.id })),\n      })\n    }\n  }\n}\n","import Crypto from './Crypto'\nimport Logger from './Logger'\nimport TResource from './interfaces/Resource'\nimport * as Parallel from 'async-parallel'\n\nconst STRANGE_PROTOCOLS = ['data:', 'javascript:', 'about:', 'chrome:', 'file:']\n\nexport const ItemLocation = {\n  LOCAL: 'Local',\n  SERVER: 'Server'\n} as const\n\nexport type TItemLocation = (typeof ItemLocation)[keyof typeof ItemLocation];\n\nexport type TOppositeLocation<L extends TItemLocation> = L extends typeof ItemLocation.LOCAL ? typeof ItemLocation.SERVER : L extends typeof ItemLocation.SERVER ? typeof ItemLocation.LOCAL : never\n\nexport const ItemType = {\n  FOLDER: 'folder',\n  BOOKMARK: 'bookmark'\n} as const\n\nexport type TItemType = (typeof ItemType)[keyof typeof ItemType];\n\ninterface IItemIndex<L extends TItemLocation> {\n  // eslint-disable-next-line no-use-before-define\n  [ItemType.BOOKMARK]: Record<string|number,Bookmark<L>>,\n  // eslint-disable-next-line no-use-before-define\n  [ItemType.FOLDER]: Record<string|number,Folder<L>>,\n}\n\nexport class Bookmark<L extends TItemLocation> {\n  public type = ItemType.BOOKMARK\n  public id: string | number\n  public parentId: string | number |null\n  public title: string\n  public url: string\n  public tags: string[]\n  public location: L\n  public isRoot = false\n  private hashValue: string\n\n  constructor({ id, parentId, url, title, tags, location }: { id:string|number, parentId:string|number, url:string, title:string, tags?: string[], location: L }) {\n    this.id = id\n    this.parentId = parentId\n    this.title = title\n    this.tags = tags\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.location = location || ItemLocation.LOCAL\n\n    if (this.location !== ItemLocation.LOCAL && this.location !== ItemLocation.SERVER) {\n      throw new Error('Location failed validation')\n    }\n\n    try {\n      // not a regular bookmark\n      if (STRANGE_PROTOCOLS.some(proto => url.indexOf(proto) === 0)) {\n        this.url = url\n        return\n      }\n\n      const urlObj = new URL(url)\n      this.url = urlObj.href\n    } catch (e) {\n      Logger.log('Failed to normalize', url)\n      this.url = url\n    }\n  }\n\n  canMergeWith<L2 extends TItemLocation>(otherItem: TItem<L2>): boolean {\n    if (otherItem instanceof Bookmark) {\n      return this.url === otherItem.url\n    }\n    return false\n  }\n\n  childrenSimilarity<L2 extends TItemLocation>(otherItem: TItem<L2>): number {\n    return 0\n  }\n\n  async hash():Promise<string> {\n    if (!this.hashValue) {\n      this.hashValue = await Crypto.sha256(\n        JSON.stringify({ title: this.title, url: this.url })\n      )\n    }\n    return this.hashValue\n  }\n\n  clone(withHash?: boolean):Bookmark<L> {\n    return new Bookmark(this)\n  }\n\n  cloneWithLocation<L2 extends TItemLocation>(withHash:boolean, location: L2): Bookmark<L2> {\n    return new Bookmark({\n      ...this,\n      location,\n    })\n  }\n\n  createIndex():any {\n    return { [this.id]: this }\n  }\n\n  // TODO: Make this return the correct type based on the type param\n  findItem(type:TItemType, id:string|number):TItem<L>|null {\n    if (type === 'bookmark' && String(id) === String(this.id)) {\n      return this\n    }\n    return null\n  }\n\n  // TODO: Make this return the correct type based on the type param\n  findItemFilter(type:TItemType, fn:(item:TItem<L>)=>boolean, prefer:(item: TItem<L>)=>number = () => 1):TItem<L>|null {\n    if (type === ItemType.BOOKMARK && fn(this)) {\n      return this\n    }\n    return null\n  }\n\n  count():number {\n    return 1\n  }\n\n  inspect(depth = 0):string {\n    return (\n      Array(depth < 0 ? 0 : depth)\n        .fill('  ')\n        .join('') +\n      `- #${this.id}[${this.title}](${this.url}) parentId: ${this.parentId}`\n    )\n  }\n\n  visitCreate(resource: TResource<L>):Promise<number | string> {\n    return resource.createBookmark(this)\n  }\n\n  visitUpdate(resource: TResource<L>): Promise<void> {\n    return resource.updateBookmark(this)\n  }\n\n  visitRemove(resource: TResource<L>): Promise<void> {\n    return resource.removeBookmark(this)\n  }\n\n  static hydrate<L2 extends TItemLocation>(obj: any):Bookmark<L2> {\n    return new Bookmark(obj)\n  }\n}\n\nexport class Folder<L extends TItemLocation> {\n  public type = ItemType.FOLDER\n  public id: number | string\n  public title?: string\n  public parentId: number | string\n  public children: TItem<L>[]\n  public hashValue: Record<string,string>\n  public isRoot = false\n  public loaded = true\n  public location: L\n  private index: IItemIndex<L>\n\n  constructor({ id, parentId, title, children, hashValue, loaded, location, isRoot }\n  :{\n    id:number|string,\n    parentId?:number|string,\n    title?:string,\n    // eslint-disable-next-line no-use-before-define\n    children?: TItem<L>[],\n    hashValue?:Record<'true'|'false',string>,\n    loaded?: boolean,\n    location: L,\n    isRoot?: boolean,\n  }) {\n    this.id = id\n    this.parentId = parentId\n    this.title = title\n    this.children = children || []\n    this.hashValue = {...hashValue} || {}\n    this.loaded = loaded !== false\n    this.isRoot = isRoot\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.location = location || ItemLocation.LOCAL\n\n    if (this.location !== ItemLocation.LOCAL && this.location !== ItemLocation.SERVER) {\n      throw new Error('Location failed validation')\n    }\n  }\n\n  // eslint-disable-next-line no-use-before-define\n  findItemFilter(type:TItemType, fn:(Item)=>boolean, prefer:(Item)=>number = () => 1):TItem<L>|null {\n    if (!this.index) {\n      this.createIndex()\n    }\n    const candidates = Object.values(this.index[type]).filter(fn)\n    // return the preferred match based on a preference measure\n    return candidates.sort((a,b) => prefer(a) - prefer(b)).pop()\n  }\n\n  findFolder(id:string|number): Folder<L> {\n    if (String(this.id) === String(id)) {\n      return this\n    }\n\n    if (this.index) {\n      return this.index.folder[id]\n    }\n\n    // traverse sub folders\n    return this.children\n      .filter(child => child instanceof Folder)\n      .map(folder => folder as Folder<L>)\n      .map(folder => folder.findFolder(id))\n      .filter(folder => !!folder)[0]\n  }\n\n  findBookmark(id:string|number):Bookmark<L> {\n    if (this.index) {\n      return this.index.bookmark[id]\n    }\n    const bookmarkFound = this.children\n      .filter(child => child instanceof Bookmark)\n      .map(child => child as Bookmark<L>)\n      .find(bm => String(bm.id) === String(id))\n    if (bookmarkFound) {\n      return bookmarkFound\n    }\n    // traverse sub folders\n    return this.children\n      .filter(child => child instanceof Folder)\n      .map(folder => folder as Folder<L>)\n      .map(folder => folder.findBookmark(id))\n      .filter(bookmark => !!bookmark)[0]\n  }\n\n  // eslint-disable-next-line no-use-before-define\n  findItem(type:TItemType, id:string|number):TItem<L>|null {\n    if (type === ItemType.FOLDER) {\n      return this.findFolder(id)\n    } else {\n      return this.findBookmark(id)\n    }\n  }\n\n  async traverse(fn: (item:TItem<L>, folder: Folder<L>)=>void): Promise<void> {\n    await Parallel.each(this.children, async item => {\n      await fn(item, this)\n      if (item.type === 'folder') {\n        // give the browser time to breathe\n        await Promise.resolve()\n        await item.traverse(fn)\n      }\n    }, 10)\n  }\n\n  // eslint-disable-next-line no-use-before-define\n  canMergeWith<L2 extends TItemLocation>(otherItem: TItem<L2>): boolean {\n    if (otherItem instanceof Folder) {\n      return this.title === otherItem.title\n    }\n    return false\n  }\n\n  childrenSimilarity<L2 extends TItemLocation>(otherItem: TItem<L2>): number {\n    if (otherItem instanceof Folder) {\n      return this.children.reduce(\n        (count, item) =>\n          otherItem.children.find(i => i.title === item.title) ? count + 1 : count,\n        0\n      ) / Math.max(this.children.length, otherItem.children.length)\n    }\n    return 0\n  }\n\n  async hash(preserveOrder = false): Promise<string> {\n    if (this.hashValue && this.hashValue[String(preserveOrder)]) {\n      return this.hashValue[String(preserveOrder)]\n    }\n\n    if (!this.loaded) {\n      throw new Error('Trying to calculate hash of a folder that isn\\'t loaded')\n    }\n\n    const children = this.children.slice()\n    if (!preserveOrder) {\n      // only re-sort unless we sync the order of the children as well\n      children.sort((c1, c2) => {\n        if (c1.title < c2.title) {\n          return -1\n        }\n        if (c2.title < c1.title) {\n          return 1\n        }\n        return 0\n      })\n    }\n    if (!this.hashValue) this.hashValue = {}\n    this.hashValue[String(preserveOrder)] = await Crypto.sha256(\n      JSON.stringify({\n        title: this.title,\n        children: await Parallel.map(\n          this.children,\n          child => child.hash(preserveOrder),\n          1\n        )\n      })\n    )\n    return this.hashValue[String(preserveOrder)]\n  }\n\n  clone(withHash?:boolean):Folder<L> {\n    return new Folder({\n      ...this,\n      ...(!withHash && { hashValue: {} }),\n      children: this.children.map(child => child.clone(withHash))\n    })\n  }\n\n  cloneWithLocation<L2 extends TItemLocation>(withHash:boolean, location: L2):Folder<L2> {\n    return new Folder({\n      ...this,\n      location,\n      ...(!withHash && { hashValue: {} }),\n      children: this.children.map(child => child.cloneWithLocation(withHash, location))\n    })\n  }\n\n  count():number {\n    if (!this.index) {\n      this.createIndex()\n    }\n    return Object.keys(this.index.bookmark).length\n  }\n\n  countFolders():number {\n    if (!this.index) {\n      this.createIndex()\n    }\n    return Object.keys(this.index.folder).length\n  }\n\n  createIndex():IItemIndex<L> {\n    this.index = {\n      folder: { [this.id]: this },\n      bookmark: this.children\n        .filter(child => child instanceof Bookmark)\n        .reduce((obj, child) => {\n          obj[child.id] = child\n          return obj\n        }, {})\n    }\n\n    this.children\n      .filter(child => child instanceof Folder)\n      .map(child => child.createIndex())\n      .forEach(subIndex => {\n        Object.assign(this.index.folder, subIndex.folder)\n        Object.assign(this.index.bookmark, subIndex.bookmark)\n      })\n    return this.index\n  }\n\n  inspect(depth = 0):string {\n    return (\n      Array(depth < 0 ? 0 : depth)\n        .fill('  ')\n        .join('') +\n      `+ #${this.id}[${this.title}] parentId: ${this.parentId}, hash: ${this\n        .hashValue[String(true)] || this.hashValue[String(false)]}\\n` +\n      this.children\n        .map(child =>\n          child && child.inspect ? child.inspect(depth + 1) : String(child)\n        )\n        .join('\\n')\n    )\n  }\n\n  visitCreate(resource: TResource<L>):Promise<number | string> {\n    return resource.createFolder(this)\n  }\n\n  visitUpdate(resource: TResource<L>): Promise<void> {\n    return resource.updateFolder(this)\n  }\n\n  visitRemove(resource: TResource<L>): Promise<void> {\n    return resource.removeFolder(this)\n  }\n\n  static hydrate<L2 extends TItemLocation>(obj: {id: string|number, parentId?: string|number, title?: string, location: L2, children: any[], isRoot: boolean}): Folder<L2> {\n    return new Folder({\n      ...obj,\n      children: obj.children\n        ? obj.children.map(child => {\n          // Firefox seems to set 'url' even for folders\n          if ('url' in child && typeof child.url === 'string') {\n            return Bookmark.hydrate(child)\n          } else {\n            return Folder.hydrate(child)\n          }\n        })\n        : null\n    })\n  }\n\n  static getAncestorsOf<L2 extends TItemLocation>(item: TItem<L2>, tree: Folder<L2>): TItem<L2>[] {\n    const ancestors = [item]\n    let parent = item\n    while (String(parent.id) !== String(tree.id)) {\n      ancestors.push(parent)\n      parent = tree.findItem(ItemType.FOLDER, parent.parentId)\n      if (!parent) {\n        throw new Error('Item is not a descendant of the tree passed')\n      }\n    }\n    ancestors.reverse()\n    return ancestors\n  }\n}\n\nexport type TItem<L extends TItemLocation> = Bookmark<L> | Folder<L>\n\nexport function hydrate<L extends TItemLocation>(obj: any) {\n  if (obj.type === ItemType.FOLDER) {\n    return Folder.hydrate<L>(obj)\n  }\n  if (obj.type === ItemType.BOOKMARK) {\n    return Bookmark.hydrate<L>(obj)\n  }\n  throw new Error(`Cannot hydrate object ${JSON.stringify(obj)}`)\n}\n","import * as Tree from '../Tree'\nimport { Bookmark, Folder, ItemLocation, TItemLocation } from '../Tree'\nimport Logger from '../Logger'\nimport Adapter from '../interfaces/Adapter'\nimport difference from 'lodash/difference'\n\nimport Ordering from '../interfaces/Ordering'\nimport {\n  MissingItemOrderError,\n  UnknownBookmarkUpdateError,\n  UnknownCreateTargetError, UnknownFolderItemOrderError, UnknownFolderOrderError, UnknownFolderUpdateError,\n  UnknownMoveOriginError,\n  UnknownMoveTargetError\n} from '../../errors/Error'\nimport { BulkImportResource } from '../interfaces/Resource'\n\nexport default class CachingAdapter implements Adapter, BulkImportResource<TItemLocation> {\n  protected highestId: number\n  protected bookmarksCache: Folder<TItemLocation>\n  protected server: any\n  protected location: TItemLocation = ItemLocation.SERVER\n\n  constructor(server: any) {\n    this.resetCache()\n  }\n\n  resetCache() {\n    this.highestId = 0\n    this.bookmarksCache = new Folder({ id: 0, title: 'root', location: this.location })\n  }\n\n  getLabel():string {\n    const data = this.getData()\n    return data.label || data.username + '@' + new URL(data.url).hostname\n  }\n\n  async getBookmarksTree(): Promise<Folder<TItemLocation>> {\n    return this.bookmarksCache.clone()\n  }\n\n  acceptsBookmark(bm:Bookmark<TItemLocation>):boolean {\n    if (bm.url === 'data:') {\n      return false\n    }\n    try {\n      return Boolean(['https:', 'http:', 'ftp:', 'data:', 'javascript:', 'file:', 'chrome:', 'edge:'].includes(\n        new URL(bm.url).protocol\n      ))\n    } catch (e) {\n      return false\n    }\n  }\n\n  async createBookmark(bm:Bookmark<TItemLocation>):Promise<string|number> {\n    Logger.log('CREATE', bm)\n    bm.id = ++this.highestId\n    const foundFolder = this.bookmarksCache.findFolder(bm.parentId)\n    if (!foundFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    foundFolder.children.push(bm)\n    this.bookmarksCache.createIndex()\n    return bm.id\n  }\n\n  async updateBookmark(newBm: Bookmark<TItemLocation>): Promise<void> {\n    Logger.log('UPDATE', newBm)\n    const foundBookmark = this.bookmarksCache.findBookmark(newBm.id)\n    if (!foundBookmark) {\n      throw new UnknownBookmarkUpdateError()\n    }\n    foundBookmark.url = newBm.url\n    foundBookmark.title = newBm.title\n    if (String(foundBookmark.parentId) === String(newBm.parentId)) {\n      return\n    }\n    const foundOldFolder = this.bookmarksCache.findFolder(\n      foundBookmark.parentId\n    )\n    if (!foundOldFolder) {\n      throw new UnknownMoveOriginError()\n    }\n    const foundNewFolder = this.bookmarksCache.findFolder(newBm.parentId)\n    if (!foundNewFolder) {\n      throw new UnknownMoveTargetError()\n    }\n    foundOldFolder.children.splice(\n      foundOldFolder.children.indexOf(foundBookmark),\n      1\n    )\n    foundNewFolder.children.push(foundBookmark)\n    foundBookmark.parentId = newBm.parentId\n    this.bookmarksCache.createIndex()\n  }\n\n  async removeBookmark(bookmark:Bookmark<TItemLocation>): Promise<void> {\n    Logger.log('REMOVE', { bookmark })\n    const id = bookmark.id\n    const foundBookmark = this.bookmarksCache.findBookmark(id)\n    if (!foundBookmark) {\n      return\n    }\n    const foundOldFolder = this.bookmarksCache.findFolder(\n      foundBookmark.parentId\n    )\n    if (!foundOldFolder) {\n      return\n    }\n    foundOldFolder.children.splice(\n      foundOldFolder.children.indexOf(foundBookmark),\n      1\n    )\n    this.bookmarksCache.createIndex()\n  }\n\n  async createFolder(folder:Folder<TItemLocation>): Promise<string|number> {\n    Logger.log('CREATEFOLDER', { folder })\n    const newFolder = new Tree.Folder({ id: ++this.highestId, parentId: folder.parentId, title: folder.title, location: this.location })\n    const foundParentFolder = this.bookmarksCache.findFolder(newFolder.parentId)\n    if (!foundParentFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    foundParentFolder.children.push(newFolder)\n    this.bookmarksCache.createIndex()\n    return newFolder.id\n  }\n\n  async updateFolder(folder:Folder<TItemLocation>): Promise<void> {\n    Logger.log('UPDATEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.bookmarksCache.findFolder(id)\n    if (!oldFolder) {\n      throw new UnknownFolderUpdateError()\n    }\n\n    const foundOldParentFolder = this.bookmarksCache.findFolder(oldFolder.parentId)\n    if (!foundOldParentFolder) {\n      throw new UnknownMoveOriginError()\n    }\n    const foundNewParentFolder = this.bookmarksCache.findFolder(folder.parentId)\n    if (!foundNewParentFolder) {\n      throw new UnknownMoveTargetError()\n    }\n    if (oldFolder.findFolder(foundNewParentFolder.id)) {\n      throw new Error('Detected creation of folder loop: Moving ' + id + ' to ' + folder.parentId + ', but it already contains the new parent node')\n    }\n    foundOldParentFolder.children.splice(foundOldParentFolder.children.indexOf(oldFolder), 1)\n    foundNewParentFolder.children.push(oldFolder)\n    oldFolder.title = folder.title\n    oldFolder.parentId = folder.parentId\n    this.bookmarksCache.createIndex()\n  }\n\n  async orderFolder(id:string|number, order:Ordering<TItemLocation>):Promise<void> {\n    Logger.log('ORDERFOLDER', { id, order })\n\n    const folder = this.bookmarksCache.findFolder(id)\n    if (!folder) {\n      throw new UnknownFolderOrderError()\n    }\n    order.forEach(item => {\n      const child = folder.findItem(item.type, item.id)\n      if (!child || String(child.parentId) !== String(folder.id)) {\n        throw new UnknownFolderItemOrderError(id + ':' + JSON.stringify(item))\n      }\n    })\n    folder.children.forEach(child => {\n      const item = order.find((item) => item.type === child.type && String(item.id) === String(child.id))\n      if (!item) {\n        throw new MissingItemOrderError(\n          id + ':' + child.inspect()\n        )\n      }\n    })\n    if (order.length !== folder.children.length) {\n      const diff = difference(folder.children.map(i => i.id), order.map(i => i.id))\n      throw new MissingItemOrderError(id + ':' + JSON.stringify(diff))\n    }\n    const newChildren = []\n    order.forEach(item => {\n      const child = folder.findItem(item.type, item.id)\n      newChildren.push(child)\n    })\n    folder.children = newChildren\n  }\n\n  async removeFolder(folder:Folder<TItemLocation>):Promise<void> {\n    Logger.log('REMOVEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.bookmarksCache.findFolder(id)\n    if (!oldFolder) {\n      return\n    }\n    // root folder doesn't have a parent, yo!\n    const foundOldFolder = this.bookmarksCache.findFolder(oldFolder.parentId)\n    if (!foundOldFolder) {\n      return\n    }\n    foundOldFolder.children.splice(foundOldFolder.children.indexOf(oldFolder), 1)\n    this.bookmarksCache.createIndex()\n  }\n\n  async bulkImportFolder(id:string|number, folder:Folder<TItemLocation>):Promise<Folder<TItemLocation>> {\n    Logger.log('BULKIMPORT', { id, folder })\n    const foundFolder = this.bookmarksCache.findFolder(id)\n    if (!foundFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    // clone and adjust ids\n    const imported = folder.clone()\n    imported.id = id\n    await imported.traverse(async(item, parentFolder) => {\n      item.id = ++this.highestId\n      item.parentId = parentFolder.id\n    })\n    // insert into tree\n    foundFolder.children = imported.children\n    // good as new\n    this.bookmarksCache.createIndex()\n    return imported\n  }\n\n  setData(data:any):void {\n    this.server = { ...data }\n  }\n\n  getData():any {\n    return { ...this.server }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function,@typescript-eslint/no-unused-vars\n  async onSyncStart(needLock = true):Promise<void|boolean> { }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async onSyncFail():Promise<void> { }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  async onSyncComplete():Promise<void> { }\n\n  cancel() {\n    // noop\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n}\n","import CachingAdapter from './Caching'\nimport XbelSerializer from '../serializers/Xbel'\nimport Logger from '../Logger'\nimport { Capacitor } from '@capacitor/core'\nimport * as git from 'isomorphic-git'\nimport http from 'isomorphic-git/http/web'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport FS from '@isomorphic-git/lightning-fs'\nimport Html from '../serializers/Html'\nimport {\n  FileUnreadableError,\n  MissingPermissionsError,\n  ResourceLockedError,\n  SlashError\n} from '../../errors/Error'\nimport Crypto from '../Crypto'\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Lock every 2mins while syncing\nconst LOCK_TIMEOUT = 15 * 60 * 1000 // Override lock 0.25h after last time lock has been set\nexport default class GitAdapter extends CachingAdapter {\n  private lockingInterval: any\n  private lockingPromise: Promise<void>\n  private locked: string[]\n  private cancelCallback: () => void\n  private initialTreeHash: string\n  private dir: string\n  private hash: string\n  private fs: FS|null\n\n  constructor(server) {\n    super(server)\n    this.server = server\n    this.locked = []\n    this.lockingInterval = null\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'git',\n      url: 'https://example.org/repo.git',\n      username: 'bob',\n      password: 's3cret',\n      branch: 'main',\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      includeCredentials: false,\n      allowRedirects: false,\n      allowNetwork: false,\n    }\n  }\n\n  getLabel():string {\n    const data = this.getData()\n    const url = new URL(data.url)\n    url.protocol = ''\n    return data.label || data.username + '@' + url.hostname + ':' + data.bookmark_file\n  }\n\n  getData() {\n    return { ...GitAdapter.getDefaultValues(), ...this.server }\n  }\n\n  cancel() {\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  async onSyncStart(needLock = true, forceLock = false) {\n    Logger.log('onSyncStart: begin')\n\n    this.hash = await Crypto.sha256(JSON.stringify(this.server)) + Date.now()\n    this.dir = '/' + this.hash + '/'\n\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins: [this.server.url + '/'] })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.fs = new FS(this.hash, {wipe: true})\n\n    Logger.log('(git) init')\n    await git.init({ fs: this.fs, dir: this.dir })\n    await git.addRemote({\n      fs: this.fs,\n      dir: this.dir,\n      url: this.server.url,\n      remote: 'origin',\n      force: true\n    })\n\n    try {\n      Logger.log('(git) fetch from remote')\n      await git.fetch({\n        http,\n        fs: this.fs,\n        dir: this.dir,\n        tags: true,\n        pruneTags: true,\n        remote: 'origin',\n        depth: 10,\n        onAuth: () => this.onAuth()\n      })\n      Logger.log('(git) checkout branch ' + (this.server.branch))\n      await git.checkout({ fs: this.fs, dir: this.dir, ref: this.server.branch })\n    } catch (e) {\n      if (e && e.code === git.Errors.NotFoundError.code && (e.data.what === 'HEAD' || e.data.what === this.server.branch || e.data.what === 'origin/' + this.server.branch)) {\n        Logger.log('(git) writeFile ' + this.dir + '/README.md')\n        await this.fs.promises.writeFile(this.dir + '/README.md', 'This repository is used to synchronize bookmarks via [floccus](https://floccus.org).', {mode: 0o777, encoding: 'utf8'})\n        Logger.log('(git) add .')\n        await git.add({fs: this.fs, dir: this.dir, filepath: '.'})\n        Logger.log('(git) commit')\n        await git.commit({\n          fs: this.fs,\n          dir: this.dir,\n          message: 'Floccus bookmarks update',\n          author: {\n            name: 'Floccus bookmarks sync',\n          }\n        })\n        const currentBranch = await git.currentBranch({fs: this.fs, dir: this.dir})\n        if (currentBranch && currentBranch !== this.server.branch) {\n          await git.renameBranch({ fs: this.fs, dir: this.dir, ref: this.server.branch, oldref: currentBranch })\n        }\n        Logger.log('(git) push')\n        await git.push({\n          fs: this.fs,\n          http,\n          dir: this.dir,\n          ref: this.server.branch,\n          remoteRef: this.server.branch,\n          remote: 'origin',\n          onAuth: () => this.onAuth()\n        })\n      } else {\n        throw e\n      }\n    }\n\n    if (this.server.bookmark_file[0] === '/') {\n      throw new SlashError()\n    }\n\n    if (this.lockingInterval) {\n      clearInterval(this.lockingInterval)\n    }\n    if (forceLock) {\n      await this.setLock()\n    } else if (needLock) {\n      await this.obtainLock()\n    }\n    if (needLock || forceLock) {\n      this.lockingInterval = setInterval(() => this.setLock(), LOCK_INTERVAL) // Set lock every minute\n    }\n\n    const status = await this.pullFromServer()\n\n    this.initialTreeHash = await this.bookmarksCache.hash(true)\n\n    Logger.log('onSyncStart: completed')\n\n    return status\n  }\n\n  async onSyncFail() {\n    Logger.log('onSyncFail')\n    clearInterval(this.lockingInterval)\n    await this.freeLock()\n    indexedDB.deleteDatabase(this.hash)\n  }\n\n  async onSyncComplete() {\n    Logger.log('onSyncComplete')\n    clearInterval(this.lockingInterval)\n\n    this.bookmarksCache = this.bookmarksCache.clone()\n    const newTreeHash = await this.bookmarksCache.hash(true)\n    if (newTreeHash !== this.initialTreeHash) {\n      const fileContents = this.server.bookmark_file_type === 'xbel' ? createXBEL(this.bookmarksCache, this.highestId) : createHTML(this.bookmarksCache, this.highestId)\n      Logger.log('(git) writeFile ' + this.dir + '/' + this.server.bookmark_file)\n      await this.fs.promises.writeFile(this.dir + '/' + this.server.bookmark_file, fileContents, {mode: 0o777, encoding: 'utf8'})\n      Logger.log('(git) add .')\n      await git.add({fs: this.fs, dir: this.dir, filepath: '.'})\n      Logger.log('(git) commit')\n      await git.commit({\n        fs: this.fs,\n        dir: this.dir,\n        message: `Floccus update: ${this.getLabel()}`,\n        author: {\n          name: 'Floccus bookmarks sync',\n        }\n      })\n      try {\n        Logger.log('(git) push')\n        await git.push({\n          fs: this.fs,\n          http,\n          dir: this.dir,\n          remote: 'origin',\n          force: true,\n          onAuth: () => this.onAuth()\n        })\n      } catch (e) {\n        if (e.code && e.code === git.Errors.PushRejectedError.code) {\n          this.freeLock()\n          throw new ResourceLockedError\n        }\n      }\n    } else {\n      Logger.log('No changes to the server version necessary')\n    }\n\n    await this.freeLock()\n    indexedDB.deleteDatabase(this.hash)\n  }\n\n  async obtainLock() {\n    const tags = await git.listTags({ fs: this.fs, dir: this.dir })\n    const lockTag = tags.sort().reverse().find((tag) => tag.startsWith('floccus-lock-'))\n    if (lockTag) {\n      const dateLocked = Number(lockTag.slice('floccus-lock-'.length))\n      if (Date.now() - dateLocked < LOCK_TIMEOUT) {\n        throw new ResourceLockedError()\n      }\n    }\n\n    await this.setLock()\n  }\n\n  async setLock() {\n    this.lockingPromise = (async() => {\n      const tag = 'floccus-lock-' + Date.now()\n      Logger.log('(git) tag ' + tag)\n      await git.tag({ fs: this.fs, dir: this.dir, ref: tag })\n      Logger.log('(git) push tag ' + tag)\n      await git.push({ fs: this.fs, http, dir: this.dir, ref: tag, onAuth: () => this.onAuth() })\n      this.locked.push(tag)\n    })()\n    await this.lockingPromise\n  }\n\n  async onAuth() {\n    return { username: this.server.username, password: this.server.password }\n  }\n\n  async freeLock() {\n    if (this.lockingPromise) {\n      await this.lockingPromise\n    }\n    if (!this.locked.length) {\n      return\n    }\n\n    try {\n      for (const tag of this.locked) {\n        Logger.log('(git) push: delete tag ' + tag)\n        await git.push({ fs: this.fs, http, dir: this.dir, ref: tag, delete: true, onAuth: () => this.onAuth() })\n      }\n      this.locked = []\n      return true\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      return false\n    }\n  }\n\n  async pullFromServer() {\n    let fileContents\n    try {\n      Logger.log('(git) readFile')\n      fileContents = await this.fs.promises.readFile(this.dir + '/' + this.server.bookmark_file, { encoding: 'utf8' })\n    } catch (e) {\n      this.resetCache()\n      // Could not find file\n      return false\n    }\n\n    if (!fileContents || (!fileContents.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>') && !fileContents.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>'))) {\n      throw new FileUnreadableError()\n    }\n\n    /* let's get the highestId */\n    for (const line of fileContents.split('\\n')) {\n      if (line.indexOf('<!--- highestId :') >= 0) {\n        const idxStart = line.indexOf(':') + 1\n        const idxEnd = line.lastIndexOf(':')\n\n        this.highestId = parseInt(line.substring(idxStart, idxEnd))\n        break\n      }\n    }\n\n    switch (this.server.bookmark_file_type) {\n      case 'xbel':\n        Logger.log('(git) parse XBEL')\n        this.bookmarksCache = XbelSerializer.deserialize(fileContents)\n        break\n      case 'html':\n        Logger.log('(git) parse HTML')\n        this.bookmarksCache = Html.deserialize(fileContents)\n        break\n      default:\n        throw new Error('Invalid bookmark file type')\n    }\n\n    // Found file, we can keep the cache from the previous run\n    return true\n  }\n\n  async clearServer() {\n    const hash = await Crypto.sha256(JSON.stringify(this.server)) + Date.now()\n    this.dir = '/' + hash + '/'\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const fs = new FS(hash, {wipe: true})\n\n    Logger.log('(git) init')\n    await git.init({ fs, dir: this.dir, defaultBranch: this.server.branch })\n    await git.addRemote({\n      fs,\n      dir: this.dir,\n      url: this.server.url,\n      remote: 'origin',\n      force: true\n    })\n    await fs.promises.writeFile(this.dir + '/README.md', 'This repository is used to synchronize bookmarks via [floccus](https://floccus.org).', {mode: 0o777, encoding: 'utf8'})\n    await git.add({fs, dir: this.dir, filepath: '.'})\n    await git.commit({\n      fs,\n      dir: this.dir,\n      message: 'Floccus bookmarks update',\n      author: {\n        name: 'Floccus bookmarks sync',\n      }\n    })\n    const currentBranch = await git.currentBranch({fs, dir: this.dir})\n    if (currentBranch && currentBranch !== this.server.branch) {\n      await git.renameBranch({ fs, dir: this.dir, ref: this.server.branch, oldref: currentBranch })\n    }\n    await git.push({\n      fs,\n      http,\n      dir: this.dir,\n      ref: this.server.branch,\n      remoteRef: this.server.branch,\n      remote: 'origin',\n      force: true,\n      onAuth: () => this.onAuth()\n    })\n    await git.fetch({\n      http,\n      fs,\n      dir: this.dir,\n      tags: true,\n      pruneTags: true,\n      remote: 'origin',\n      depth: 10,\n      onAuth: () => this.onAuth()\n    })\n    const tags = await git.listTags({ fs, dir: this.dir })\n    const lockTags = tags.filter(tag => tag.startsWith('floccus-lock-'))\n    for (const tag of lockTags) {\n      await git.push({ fs, http, dir: this.dir, ref: tag, delete: true, onAuth: () => this.onAuth() })\n    }\n  }\n}\n\nfunction createXBEL(rootFolder, highestId) {\n  let output = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\" \"http://pyxml.sourceforge.net/topics/dtds/xbel.dtd\">\n<xbel version=\"1.0\">\n`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += XbelSerializer.serialize(rootFolder)\n\n  output += `\n</xbel>`\n\n  return output\n}\n\nfunction createHTML(rootFolder, highestId) {\n  let output = `<!DOCTYPE NETSCAPE-Bookmark-file-1>\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\">\n<TITLE>Bookmarks</TITLE>`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += Html.serialize(rootFolder)\n\n  output += '</html>'\n\n  return output\n}\n","import CachingAdapter from './Caching'\nimport Logger from '../Logger'\nimport XbelSerializer from '../serializers/Xbel'\nimport Crypto from '../Crypto'\nimport Credentials from '../../../google-api.credentials.json'\nimport {\n  AuthenticationError,\n  DecryptionError, FileUnreadableError,\n  GoogleDriveAuthenticationError, HttpError, CancelledSyncError, MissingPermissionsError,\n  NetworkError,\n  OAuthTokenError, ResourceLockedError\n} from '../../errors/Error'\nimport { OAuth2Client } from '@byteowls/capacitor-oauth2'\nimport { Capacitor, CapacitorHttp as Http } from '@capacitor/core'\n\nconst OAuthConfig = {\n  authorizationBaseUrl: 'https://accounts.google.com/o/oauth2/auth',\n  accessTokenEndpoint: 'https://oauth2.googleapis.com/token',\n  scope: 'https://www.googleapis.com/auth/drive.file',\n  resourceUrl: 'https://www.googleapis.com/drive/v3/about?fields=user/displayName',\n  logsEnabled: true,\n  android: {\n    appId: Credentials.android.client_id,\n    responseType: 'code', // if you configured a android app in google dev console the value must be \"code\"\n    redirectUrl: 'org.handmadeideas.floccus:/' // package name from google dev console\n  },\n  ios: {\n    appId: Credentials.ios.client_id,\n    responseType: 'code',\n    redirectUrl: 'org.handmadeideas.floccus:/'\n  }\n}\n\ninterface CustomResponse {\n  status: number,\n  json(): Promise<any>,\n  text(): Promise<string>,\n}\n\ndeclare const chrome: any\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Lock every two minutes while syncing\nconst LOCK_TIMEOUT = 15 * 60 * 1000 // Override lock 15min after last time it was set\nexport default class GoogleDriveAdapter extends CachingAdapter {\n  static SCOPES = ['https://www.googleapis.com/auth/drive.metadata.readonly']\n\n  private initialTreeHash: string\n  private fileId: string\n  private accessToken: string\n  private cancelCallback: () => void = null\n  private alwaysUpload = false\n  private lockingInterval: any\n  private locked = false\n  private lockingPromise: Promise<CustomResponse>\n\n  constructor(server) {\n    super(server)\n    this.server = server\n  }\n\n  static async authorize(interactive = true) {\n    const platform = Capacitor.getPlatform()\n\n    if (platform !== 'web') {\n      const result = await OAuth2Client.authenticate(OAuthConfig)\n      const refresh_token = result.access_token_response.refresh_token\n      const username = result.user.displayName\n      return { refresh_token, username }\n    }\n\n    if (platform === 'web') {\n      const browser = (await import('../browser-api')).default\n      const origins = ['https://oauth2.googleapis.com/', 'https://www.googleapis.com/']\n      if (!(await browser.permissions.contains({ origins }))) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    // see https://developers.google.com/identity/protocols/oauth2/native-app\n    const challenge = Crypto.bufferToHexstr(await Crypto.getRandomBytes(128)).substr(0, 128)\n    const state = Crypto.bufferToHexstr(await Crypto.getRandomBytes(128)).substr(0, 64)\n    const redirectURL = chrome.identity.getRedirectURL()\n    const scopes = ['https://www.googleapis.com/auth/drive.file']\n    let authURL = 'https://accounts.google.com/o/oauth2/auth'\n    authURL += `?client_id=${Credentials.web.client_id}`\n    authURL += `&response_type=code`\n    authURL += `&redirect_uri=${encodeURIComponent(redirectURL)}`\n    authURL += `&scope=${encodeURIComponent(scopes.join(' '))}`\n    authURL += `&approval_prompt=force&access_type=offline`\n    authURL += `&code_challenge=${challenge}`\n    authURL += `&state=${state}`\n\n    const browser = (await import('../browser-api')).default\n\n    const redirectResult = await browser.identity.launchWebAuthFlow({\n      interactive,\n      url: authURL\n    })\n\n    const m = redirectResult.match(/[#?](.*)/)\n    if (!m || m.length < 1)\n      return null\n    const params = new URLSearchParams(m[1].split('#')[0])\n    const code = params.get('code')\n    const resState = params.get('state')\n\n    if (!code) {\n      throw new Error('Authorization failure')\n    }\n    if (resState !== state) {\n      throw new Error('Authorization failure: State param does not match')\n    }\n    const response = await fetch('https://oauth2.googleapis.com/token', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      body: `code=${code}` +\n        `&client_id=${Credentials.web.client_id}` +\n        `&client_secret=${Credentials.web.client_secret}` +\n        `&redirect_uri=${encodeURIComponent(chrome.identity.getRedirectURL())}` +\n        `&code_verifier=${challenge}` +\n        '&grant_type=authorization_code'\n    })\n\n    if (response.status !== 200) {\n      Logger.log('Failed to retrieve refresh token from Google API: ' + await response.text())\n      throw new OAuthTokenError()\n    }\n    const json = await response.json()\n    if (!json.access_token || !json.refresh_token) {\n      Logger.log('Failed to retrieve refresh token from Google API: ' + JSON.stringify(json))\n      throw new OAuthTokenError()\n    }\n\n    const res = await fetch('https://www.googleapis.com/drive/v3/about?fields=user/displayName', {\n      headers: {\n        Authorization: 'Bearer ' + json.access_token\n      }\n    })\n    const about = await res.json()\n\n    return { refresh_token: json.refresh_token, username: about.user.displayName }\n  }\n\n  async getAccessToken(refreshToken:string) {\n    const platform = Capacitor.getPlatform()\n\n    const response = await this.request('POST', 'https://oauth2.googleapis.com/token',\n      {\n        refresh_token: refreshToken,\n        client_id: Credentials[platform].client_id,\n        ...(platform === 'web' && {client_secret: Credentials.web.client_secret}),\n        grant_type: 'refresh_token',\n      },\n      'application/x-www-form-urlencoded'\n    )\n\n    if (response.status !== 200) {\n      Logger.log('Failed to retrieve access token from Google API: ' + await response.text())\n      throw new GoogleDriveAuthenticationError()\n    }\n\n    const json = await response.json()\n    if (json.access_token) {\n      return json.access_token\n    } else {\n      throw new OAuthTokenError()\n    }\n  }\n\n  getLabel():string {\n    return this.server.label || 'Google Drive: ' + this.server.bookmark_file\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'google-drive',\n      username: '',\n      password: '',\n      refreshToken: null,\n      bookmark_file: 'bookmarks.xbel',\n      allowNetwork: false,\n    }\n  }\n\n  getUrl() :string {\n    return 'https://www.googleapis.com/drive/v3'\n  }\n\n  timeout(ms) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, ms)\n      this.cancelCallback = () => reject(new CancelledSyncError())\n    })\n  }\n\n  async onSyncStart(needLock = true, forceLock = false) {\n    Logger.log('onSyncStart: begin')\n\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      const origins = ['https://oauth2.googleapis.com/', 'https://www.googleapis.com/']\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    this.accessToken = await this.getAccessToken(this.server.refreshToken)\n\n    const fileList = await this.listFiles(`name = '${this.server.bookmark_file}'`, 100)\n    const file = fileList.files.filter(file => !file.trashed)[0]\n\n    const filesToDelete = fileList.files.filter(file => !file.trashed).slice(1)\n    for (const fileToDelete of filesToDelete) {\n      try {\n        await this.deleteFile(fileToDelete.id)\n      } catch (e) {\n        Logger.log('Failed to delete superfluous file: ' + e.message)\n      }\n    }\n\n    if (file) {\n      this.fileId = file.id\n      if (forceLock) {\n        this.locked = await this.setLock(this.fileId)\n      } else if (needLock) {\n        const data = await this.getFileMetadata(file.id, 'appProperties')\n        if (data.appProperties && data.appProperties.locked && (data.appProperties.locked === true || JSON.parse(data.appProperties.locked))) {\n          const lockedDate = JSON.parse(data.appProperties.locked)\n          if (!Number.isInteger(lockedDate)) {\n            throw new ResourceLockedError()\n          }\n          if (Date.now() - lockedDate < LOCK_TIMEOUT) {\n            throw new ResourceLockedError()\n          }\n        }\n        this.locked = await this.setLock(this.fileId)\n      }\n\n      let xmlDocText = await this.downloadFile(this.fileId)\n\n      if (this.server.password) {\n        try {\n          try {\n            // TODO: Use this when encrypting\n            const json = JSON.parse(xmlDocText)\n            xmlDocText = await Crypto.decryptAES(this.server.password, json.ciphertext, json.salt)\n          } catch (e) {\n            xmlDocText = await Crypto.decryptAES(this.server.password, xmlDocText, this.server.bookmark_file)\n          }\n        } catch (e) {\n          if (xmlDocText && xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')) {\n            // not encrypted, yet => noop\n            this.alwaysUpload = true\n          } else {\n            throw new DecryptionError()\n          }\n        }\n      } else if (!xmlDocText || !xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')) {\n        throw new FileUnreadableError()\n      }\n\n      /* let's get the highestId */\n      const byNL = xmlDocText.split('\\n')\n      for (const line of byNL) {\n        if (line.indexOf('<!--- highestId :') >= 0) {\n          const idxStart = line.indexOf(':') + 1\n          const idxEnd = line.lastIndexOf(':')\n\n          this.highestId = parseInt(line.substring(idxStart, idxEnd))\n          break\n        }\n      }\n\n      this.bookmarksCache = XbelSerializer.deserialize(xmlDocText)\n      if (this.lockingInterval) {\n        clearInterval(this.lockingInterval)\n      }\n      if (needLock || forceLock) {\n        this.lockingInterval = setInterval(() => this.setLock(this.fileId), LOCK_INTERVAL) // Set lock every minute\n      }\n    } else {\n      this.resetCache()\n      this.alwaysUpload = true\n    }\n\n    this.initialTreeHash = await this.bookmarksCache.hash(true)\n\n    Logger.log('onSyncStart: completed')\n\n    if (!this.fileId) {\n      // notify sync process that we should reset cache\n      return false\n    }\n  }\n\n  async onSyncFail() {\n    Logger.log('onSyncFail')\n    if (this.fileId) {\n      clearInterval(this.lockingInterval)\n      if (this.locked) {\n        await this.freeLock(this.fileId)\n      }\n    }\n    this.fileId = null\n  }\n\n  async onSyncComplete() {\n    Logger.log('onSyncComplete')\n    clearInterval(this.lockingInterval)\n\n    this.bookmarksCache = this.bookmarksCache.clone()\n    const newTreeHash = await this.bookmarksCache.hash(true)\n    let xbel = createXBEL(this.bookmarksCache, this.highestId)\n\n    if (this.server.password) {\n      const salt = Crypto.bufferToHexstr(Crypto.getRandomBytes(64))\n      const ciphertext = await Crypto.encryptAES(this.server.password, xbel, salt)\n      xbel = JSON.stringify({ciphertext, salt})\n    }\n\n    if (!this.fileId) {\n      await this.createFile(xbel)\n      this.fileId = null\n      return\n    }\n\n    if (newTreeHash !== this.initialTreeHash || this.alwaysUpload) {\n      await this.uploadFile(this.fileId, xbel)\n      this.alwaysUpload = false // reset flag\n    } else {\n      Logger.log('No changes to the server version necessary')\n    }\n    await this.freeLock(this.fileId)\n    this.fileId = null\n  }\n\n  cancel() {\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  async request(method: string, url: string, body: any = null, contentType: string = null) : Promise<CustomResponse> {\n    return this.requestNative(method, url, body, contentType)\n  }\n\n  async requestWeb(method: string, url: string, body: any = null, contentType: string = null) : Promise<CustomResponse> {\n    let resp\n    try {\n      resp = await fetch(url, {\n        method,\n        credentials: 'omit',\n        headers: {\n          ...(this.accessToken && {Authorization: 'Bearer ' + this.accessToken}),\n          ...(contentType && {'Content-type': contentType})\n        },\n        ...(body && {body}),\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n    if (resp.status === 401 || resp.status === 403) {\n      Logger.log('Failed to authenticate to Google API: ' + await resp.text())\n      throw new AuthenticationError()\n    }\n    return resp\n  }\n\n  async requestNative(method: string, url: string, body: any = null, contentType: string = null) : Promise<CustomResponse> {\n    let res\n\n    if (contentType === 'application/x-www-form-urlencoded') {\n      const params = new URLSearchParams()\n      for (const [key, value] of Object.entries(body || {})) {\n        params.set(key, value as string)\n      }\n      body = params.toString()\n    }\n\n    try {\n      res = await Http.request({\n        url,\n        method,\n        headers: {\n          ...(this.accessToken && {Authorization: 'Bearer ' + this.accessToken}),\n          ...(contentType && {'Content-type': contentType}),\n        },\n        responseType: 'text',\n        ...(body && {data: body})\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      Logger.log('Failed to authenticate to Google API: ' + res.data)\n      throw new AuthenticationError()\n    }\n\n    if (res.status >= 500) {\n      throw new HttpError(res.status, method)\n    }\n\n    return {\n      status: res.status,\n      json: () => Promise.resolve(res.data),\n      text: () => Promise.resolve(res.data),\n    }\n  }\n\n  async listFiles(query: string, limit = 1) : Promise<any> {\n    const res = await this.request('GET', this.getUrl() + `/files?corpora=user&q=${encodeURIComponent(query)}&orderBy=modifiedTime%20desc&fields=files(id%2Cname%2Ctrashed)&pageSize=${limit}`)\n    return res.json()\n  }\n\n  async getFileMetadata(id: string, fields?:string): Promise<any> {\n    const res = await this.request('GET', this.getUrl() + '/files/' + id + (fields ? `?fields=${encodeURIComponent(fields)}` : ''))\n    return res.json()\n  }\n\n  async downloadFile(id: string): Promise<string> {\n    const res = await this.request('GET', this.getUrl() + '/files/' + id + '?alt=media')\n    return res.text()\n  }\n\n  async deleteFile(id: string): Promise<void> {\n    await this.request('DELETE', this.getUrl() + '/files/' + id)\n  }\n\n  async freeLock(id:string) {\n    if (this.lockingPromise) {\n      await this.lockingPromise\n    }\n    let lockFreed, i = 0\n    do {\n      const res = await this.request('PATCH', this.getUrl() + '/files/' + id,\n        JSON.stringify({\n          appProperties: {\n            locked: JSON.stringify(false)\n          }\n        }),\n        'application/json'\n      )\n      lockFreed = res.status === 200 || res.status === 204\n      if (!lockFreed) {\n        await this.timeout(1000)\n      }\n      i++\n    } while (!lockFreed && i < 10)\n    return lockFreed\n  }\n\n  async setLock(id:string) {\n    this.lockingPromise = this.request('PATCH', this.getUrl() + '/files/' + id,\n      JSON.stringify({\n        appProperties: {\n          locked: JSON.stringify(Date.now())\n        }\n      }),\n      'application/json'\n    )\n    const res = await this.lockingPromise\n    return res.status === 200\n  }\n\n  async createFile(xbel: string) {\n    let res = await this.request('POST', 'https://www.googleapis.com/upload/drive/v3/files?uploadType=media', xbel, 'application/xml')\n    if (res.status !== 200 && res.status !== 201) {\n      return false\n    }\n    const file = await res.json()\n    this.fileId = file.id\n\n    res = await this.request('PATCH', this.getUrl() + '/files/' + this.fileId,\n      JSON.stringify({name: this.server.bookmark_file}),\n      'application/json'\n    )\n    return res.status === 200\n  }\n\n  async uploadFile(id:string, xbel: string) {\n    const resp = await this.request('PATCH', 'https://www.googleapis.com/upload/drive/v3/files/' + id, xbel, 'application/xml')\n    return resp.status === 200\n  }\n}\n\nfunction createXBEL(rootFolder, highestId) {\n  let output = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\" \"http://pyxml.sourceforge.net/topics/dtds/xbel.dtd\">\n<xbel version=\"1.0\">\n`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += XbelSerializer.serialize(rootFolder)\n\n  output += `\n</xbel>`\n\n  return output\n}\n","import Adapter from '../interfaces/Adapter'\nimport { Bookmark, Folder, ItemLocation } from '../Tree'\nimport PQueue from 'p-queue'\nimport { IResource } from '../interfaces/Resource'\nimport Logger from '../Logger'\nimport {\n  AuthenticationError,\n  CancelledSyncError, HttpError,\n  NetworkError, ParseResponseError,\n  RedirectError,\n  RequestTimeoutError\n} from '../../errors/Error'\nimport { Capacitor, CapacitorHttp as Http } from '@capacitor/core'\n\nexport interface LinkwardenConfig {\n  type: 'linkwarden'\n  url: string\n  username: string\n  password: string\n  serverFolder: string,\n  includeCredentials?: boolean\n  allowRedirects?: boolean\n  allowNetwork?: boolean\n  label?: string\n}\n\nconst TIMEOUT = 300000\n\nexport default class LinkwardenAdapter implements Adapter, IResource<typeof ItemLocation.SERVER> {\n  private server: LinkwardenConfig\n  private fetchQueue: PQueue\n  private abortController: AbortController\n  private abortSignal: AbortSignal\n  private canceled: boolean\n\n  constructor(server: LinkwardenConfig) {\n    this.server = server\n    this.fetchQueue = new PQueue({ concurrency: 12 })\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n  }\n\n  static getDefaultValues(): LinkwardenConfig {\n    return {\n      type: 'linkwarden',\n      url: 'https://example.org',\n      username: 'bob',\n      password: 's3cret',\n      serverFolder: 'Floccus',\n      includeCredentials: false,\n      allowRedirects: false,\n      allowNetwork: false,\n    }\n  }\n\n  acceptsBookmark(bm: Bookmark<typeof ItemLocation.SERVER>):boolean {\n    try {\n      return ['https:', 'http:', 'ftp:', 'javascript:'].includes(new URL(bm.url).protocol)\n    } catch (e) {\n      return false\n    }\n  }\n\n  cancel(): void {\n    this.canceled = true\n    this.abortController.abort()\n  }\n\n  setData(data:LinkwardenConfig):void {\n    this.server = { ...data }\n  }\n\n  getData(): LinkwardenConfig {\n    return { ...LinkwardenAdapter.getDefaultValues(), ...this.server }\n  }\n\n  getLabel(): string {\n    const data = this.getData()\n    return data.label || (data.username.includes('@') ? data.username + ' on ' + new URL(data.url).hostname : data.username + '@' + new URL(data.url).hostname)\n  }\n\n  onSyncComplete(): Promise<void> {\n    return Promise.resolve(undefined)\n  }\n\n  onSyncFail(): Promise<void> {\n    return Promise.resolve(undefined)\n  }\n\n  onSyncStart(needLock?: boolean, forceLock?: boolean): Promise<void | boolean> {\n    this.canceled = false\n    return Promise.resolve(undefined)\n  }\n\n  async createBookmark(bookmark: Bookmark<typeof ItemLocation.SERVER>): Promise<string | number> {\n    Logger.log('(linkwarden)CREATE', {bookmark})\n    const {response} = await this.sendRequest(\n      'POST', '/api/v1/links',\n      'application/json',\n      {\n        url: bookmark.url,\n        name: bookmark.title,\n        collection: {\n          id: bookmark.parentId,\n        },\n      })\n    return response.id\n  }\n\n  async updateBookmark(bookmark: Bookmark<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)UPDATE', {bookmark})\n    const {response: collection} = await this.sendRequest('GET', `/api/v1/collections/${bookmark.parentId}`)\n    await this.sendRequest(\n      'PUT', `/api/v1/links/${bookmark.id}`,\n      'application/json',\n      {\n        id: bookmark.id,\n        url: bookmark.url,\n        name: bookmark.title,\n        tags: [],\n        collection: {\n          id: bookmark.parentId,\n          name: collection.name,\n          ownerId: collection.ownerId,\n        },\n      })\n  }\n\n  async removeBookmark(bookmark: Bookmark<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)DELETE', {bookmark})\n    await this.sendRequest('DELETE', `/api/v1/links/${bookmark.id}`)\n  }\n\n  async createFolder(folder: Folder<typeof ItemLocation.SERVER>): Promise<string | number> {\n    Logger.log('(linkwarden)CREATEFOLDER', {folder})\n    const {response} = await this.sendRequest(\n      'POST', '/api/v1/collections',\n      'application/json',\n      {\n        name: folder.title,\n        parentId: folder.parentId,\n      })\n    return response.id\n  }\n\n  async updateFolder(folder: Folder<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)UPDATEFOLDER', {folder})\n    const {response: collection} = await this.sendRequest('GET', `/api/v1/collections/${folder.id}`)\n    await this.sendRequest(\n      'PUT', `/api/v1/collections/${folder.id}`,\n      'application/json',\n      {\n        ...collection,\n        name: folder.title,\n        parentId: folder.parentId,\n      })\n  }\n\n  async removeFolder(folder: Folder<typeof ItemLocation.SERVER>): Promise<void> {\n    Logger.log('(linkwarden)DELETEFOLDER', {folder})\n    let success = false\n    let count = 0\n    do {\n      try {\n        count++\n        await this.sendRequest('DELETE', `/api/v1/collections/${folder.id}`)\n        success = true\n      } catch (e) {\n        if (e instanceof HttpError && e.status === 401) {\n          success = true\n        } else if (count > 3) {\n          throw e\n        }\n        // noop\n      }\n    } while (!success)\n  }\n\n  async getBookmarksTree(loadAll?: boolean): Promise<Folder<typeof ItemLocation.SERVER>> {\n    const links = []\n    let response\n    do {\n      ({ response } = await this.sendRequest('GET', `/api/v1/links?cursor=${links.length ? links[links.length - 1].id : ''}`))\n      links.push(...response)\n    } while (response.length !== 0)\n\n    const { response: collections } = await this.sendRequest('GET', `/api/v1/collections`)\n\n    let rootCollection = collections.find(collection => collection.name === this.server.serverFolder && collection.parentId === null)\n    if (!rootCollection) {\n      ({response: rootCollection} = await this.sendRequest(\n        'POST', '/api/v1/collections',\n        'application/json',\n        {\n          name: this.server.serverFolder,\n        }))\n    }\n\n    const buildTree = (collection, isRoot = false) => {\n      return new Folder({\n        id: collection.id,\n        title: collection.name,\n        parentId: collection.parentId,\n        location: ItemLocation.SERVER,\n        isRoot,\n        children: collections\n          .filter(col => col.parentId === collection.id)\n          .map(buildTree).concat(\n            links\n              .filter(link => link.collectionId === collection.id)\n              .map(link => new Bookmark({\n                id: link.id,\n                title: link.name,\n                parentId: link.collectionId,\n                url: link.url,\n                location: ItemLocation.SERVER,\n              }))\n          ),\n      })\n    }\n\n    return buildTree(rootCollection, true)\n  }\n\n  async isAvailable(): Promise<boolean> {\n    return true\n  }\n\n  async sendRequest(verb:string, relUrl:string, type:string = null, body:any = null, returnRawResponse = false):Promise<any> {\n    const url = this.server.url + relUrl\n    let res\n    let timedOut = false\n\n    if (type && type.includes('application/json')) {\n      body = JSON.stringify(body)\n    } else if (type && type.includes('application/x-www-form-urlencoded')) {\n      const params = new URLSearchParams()\n      for (const [key, value] of Object.entries(body || {})) {\n        params.set(key, value as any)\n      }\n      body = params.toString()\n    }\n\n    Logger.log(`QUEUING ${verb} ${url}`)\n\n    if (Capacitor.getPlatform() !== 'web') {\n      return this.sendRequestNative(verb, url, type, body, returnRawResponse)\n    }\n\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          fetch(url, {\n            method: verb,\n            credentials: this.server.includeCredentials ? 'include' : 'omit',\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Bearer ' + this.server.password,\n            },\n            signal: this.abortSignal,\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      if (this.canceled) throw new CancelledSyncError()\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.redirected && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      throw new HttpError(res.status, verb)\n    }\n    let json\n    try {\n      json = await res.json()\n    } catch (e) {\n      throw new ParseResponseError(e.message)\n    }\n\n    return json\n  }\n\n  private async sendRequestNative(verb: string, url: string, type: string, body: any, returnRawResponse: boolean) {\n    let res\n    let timedOut = false\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          Http.request({\n            url,\n            method: verb,\n            disableRedirects: !this.server.allowRedirects,\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Bearer ' + this.server.password,\n            },\n            responseType: 'json',\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { data: body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.status < 400 && res.status >= 300) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      throw new HttpError(res.status, verb)\n    }\n    const json = res.data\n\n    return json\n  }\n}\n","// Nextcloud ADAPTER\n// All owncloud specifc stuff goes in here\nimport { Capacitor, CapacitorHttp as Http } from '@capacitor/core'\nimport Adapter from '../interfaces/Adapter'\nimport HtmlSerializer from '../serializers/Html'\nimport Logger from '../Logger'\nimport { Bookmark, Folder, ItemLocation, TItem } from '../Tree'\nimport { Base64 } from 'js-base64'\nimport AsyncLock from 'async-lock'\nimport * as Parallel from 'async-parallel'\nimport PQueue from 'p-queue'\nimport flatten from 'lodash/flatten'\nimport {\n  BulkImportResource,\n  ClickCountResource,\n  LoadFolderChildrenResource,\n  OrderFolderResource\n} from '../interfaces/Resource'\nimport Ordering from '../interfaces/Ordering'\nimport {\n  AuthenticationError, CreateBookmarkError,\n  HttpError, CancelledSyncError,\n  MissingPermissionsError,\n  NetworkError,\n  ParseResponseError,\n  RedirectError,\n  RequestTimeoutError, ResourceLockedError,\n  UnexpectedServerResponseError,\n  UnknownCreateTargetError,\n  UnknownFolderParentUpdateError,\n  UnknownFolderUpdateError,\n  UnknownMoveTargetError, UpdateBookmarkError\n} from '../../errors/Error'\n\nconst PAGE_SIZE = 300\nconst TIMEOUT = 300000\n\nexport interface NextcloudBookmarksConfig {\n  type: 'nextcloud-folders'|'nextcloud-bookmarks'\n  url: string\n  username: string\n  password: string\n  serverRoot?: string\n  includeCredentials?: boolean\n  allowRedirects?: boolean\n  allowNetwork?: boolean\n  label?: string\n}\n\ninterface IChildFolder {\n  id: string|number\n  title: string\n  parentId?: string|number\n  children?: IChildFolder[]\n}\n\ninterface IChildOrderItem {\n  type: 'bookmark' | 'folder'\n  id: string|number\n  children?: IChildOrderItem[]\n}\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Set lock every two minutes while syncing\n\nexport default class NextcloudBookmarksAdapter implements Adapter, BulkImportResource<typeof ItemLocation.SERVER>, LoadFolderChildrenResource<typeof ItemLocation.SERVER>, OrderFolderResource<typeof ItemLocation.SERVER>, ClickCountResource<typeof ItemLocation.SERVER> {\n  private server: NextcloudBookmarksConfig\n  private fetchQueue: PQueue<{ concurrency: 12 }>\n  private bookmarkLock: AsyncLock\n  public hasFeatureBulkImport:boolean = null\n  private list: Bookmark<typeof ItemLocation.SERVER>[]\n  private tree: Folder<typeof ItemLocation.SERVER>\n  private abortController: AbortController\n  private abortSignal: AbortSignal\n  private canceled = false\n  private cancelCallback: () => void = null\n  private lockingInterval: any\n  private lockingPromise: Promise<boolean>\n  private ended = false\n  private locked = false\n  private hasFeatureJavascriptLinks: boolean = null\n\n  constructor(server: NextcloudBookmarksConfig) {\n    this.server = server\n    this.fetchQueue = new PQueue({ concurrency: 12 })\n    this.bookmarkLock = new AsyncLock()\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n  }\n\n  static getDefaultValues(): NextcloudBookmarksConfig {\n    return {\n      type: 'nextcloud-bookmarks',\n      url: 'https://example.org',\n      username: 'bob',\n      password: 's3cret',\n      serverRoot: '',\n      includeCredentials: false,\n      allowRedirects: false,\n      allowNetwork: false,\n    }\n  }\n\n  setData(data:NextcloudBookmarksConfig):void {\n    this.server = { ...data }\n  }\n\n  getData():NextcloudBookmarksConfig {\n    return { ...NextcloudBookmarksAdapter.getDefaultValues(), ...this.server }\n  }\n\n  getLabel():string {\n    const data = this.getData()\n    return data.label || (data.username.includes('@') ? data.username + ' on ' + new URL(data.url).hostname : data.username + '@' + new URL(data.url).hostname)\n  }\n\n  acceptsBookmark(bm: Bookmark<typeof ItemLocation.SERVER>):boolean {\n    try {\n      return Boolean(~['https:', 'http:', 'ftp:'].concat(this.hasFeatureJavascriptLinks ? ['javascript:'] : []).indexOf(new URL(bm.url).protocol))\n    } catch (e) {\n      return false\n    }\n  }\n\n  normalizeServerURL(input:string):string {\n    const serverURL = new URL(input)\n    const indexLoc = serverURL.pathname.indexOf('index.php')\n    if (!serverURL.pathname) serverURL.pathname = ''\n    serverURL.search = ''\n    serverURL.hash = ''\n    serverURL.pathname = serverURL.pathname.substring(0, ~indexLoc ? indexLoc : undefined)\n    const output = serverURL.toString()\n    return output + (output[output.length - 1] !== '/' ? '/' : '')\n  }\n\n  async onSyncStart(needLock = true, forceLock = false): Promise<void> {\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins: [this.server.url + '/'] })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    await this.checkFeatureJavascriptLinks()\n\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n\n    if (this.lockingInterval) {\n      clearInterval(this.lockingInterval)\n    }\n\n    // if needLock -- we always need it\n    this.locked = await this.acquireLock()\n    if (!forceLock && !this.locked) {\n      throw new ResourceLockedError()\n    }\n    this.lockingInterval = setInterval(() => !this.ended && this.acquireLock(), LOCK_INTERVAL)\n\n    this.canceled = false\n    this.ended = false\n  }\n\n  async onSyncComplete(): Promise<void> {\n    this.ended = true\n    clearInterval(this.lockingInterval)\n    await this.releaseLock()\n  }\n\n  async onSyncFail(): Promise<void> {\n    this.ended = true\n    clearInterval(this.lockingInterval)\n    await this.releaseLock()\n  }\n\n  cancel() {\n    this.canceled = true\n    this.fetchQueue.clear()\n    this.abortController.abort()\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  async getBookmarksList():Promise<Bookmark<typeof ItemLocation.SERVER>[]> {\n    return this.bookmarkLock.acquire('list', async() => {\n      if (this.list) {\n        return this.list\n      }\n\n      Logger.log('Fetching bookmarks')\n      let i = 0\n      let data = []\n      let json\n      do {\n        json = await this.sendRequest(\n          'GET',\n          `index.php/apps/bookmarks/public/rest/v2/bookmark?page=${i}&limit=${PAGE_SIZE}`\n        )\n        if (!Array.isArray(json.data)) {\n          throw new UnexpectedServerResponseError()\n        }\n        data = data.concat(json.data)\n        i++\n      } while (json.data.length === PAGE_SIZE)\n\n      const bookmarks = flatten(\n        data.map((bm) => {\n          const bookmark = {\n            id: bm.id as number | string,\n            url: (bm.target || bm.url) as string,\n            title: bm.title as string,\n            parentId: null,\n            location: ItemLocation.SERVER,\n          }\n\n          return bm.folders.map((parentId) => {\n            const b = { ...bookmark }\n            b.parentId = parentId\n            return new Bookmark(b)\n          })\n        })\n      )\n\n      Logger.log('Received bookmarks from server', bookmarks)\n      this.list = bookmarks\n      return bookmarks\n    })\n  }\n\n  async getBookmarksTree(loadAll = false):Promise<Folder<typeof ItemLocation.SERVER>> {\n    this.list = null // clear cache before starting a new sync\n\n    if (!loadAll) {\n      return this.getSparseBookmarksTree()\n    } else {\n      return this.getCompleteBookmarksTree()\n    }\n  }\n\n  async _getChildFolders(folderId:string|number, layers = 0):Promise<IChildFolder[]> {\n    const folderJson = await this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/folder?root=${folderId}&layers=${layers}`\n    )\n    if (!Array.isArray(folderJson.data)) {\n      throw new UnexpectedServerResponseError()\n    }\n    return folderJson.data\n  }\n\n  async _findServerRoot():Promise<Folder<typeof ItemLocation.SERVER>> {\n    let tree = new Folder({ id: -1, location: ItemLocation.SERVER })\n    let childFolders\n    await Parallel.each(\n      this.server.serverRoot.split('/').slice(1),\n      async(segment) => {\n        childFolders = (tree.children && tree.children.length) ? tree.children : (await this._getChildFolders(tree.id))\n        let currentChild = childFolders.find(\n          (folder) => folder.title === segment\n        )\n        if (!currentChild) {\n          // create folder\n          const body = {\n            parent_folder: tree.id,\n            title: segment,\n          }\n          const json = await this.sendRequest(\n            'POST',\n            'index.php/apps/bookmarks/public/rest/v2/folder',\n            'application/json',\n            body\n          )\n          if (typeof json.item !== 'object') {\n            throw new UnexpectedServerResponseError()\n          }\n          currentChild = { id: json.item.id, children: [], title: json.item.title }\n        }\n        tree = new Folder({ id: currentChild.id, title: currentChild.title, location: ItemLocation.SERVER })\n      },\n      1\n    )\n    return tree\n  }\n\n  async getCompleteBookmarksTree():Promise<Folder<typeof ItemLocation.SERVER>> {\n    let tree = new Folder({ id: -1, location: ItemLocation.SERVER })\n    if (this.server.serverRoot) {\n      tree = await this._findServerRoot()\n    }\n\n    tree.children = await this._getChildren(tree.id, -1)\n    this.tree = tree\n    return tree.clone()\n  }\n\n  async getSparseBookmarksTree() :Promise<Folder<typeof ItemLocation.SERVER>> {\n    let tree = new Folder({ id: -1, location: ItemLocation.SERVER })\n\n    if (this.server.serverRoot) {\n      tree = await this._findServerRoot()\n    }\n\n    this.list = null\n    tree.loaded = false\n    tree.hashValue = { true: await this._getFolderHash(tree.id) }\n    this.tree = tree.clone(true) // we clone (withHash), so we can mess with our own version\n    return tree\n  }\n\n  async _getFolderHash(folderId:string|number):Promise<string> {\n    return this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${folderId}/hash`\n    )\n      .catch(() => {\n        return { data: '0' } // fallback\n      })\n      .then((json) => {\n        return json.data\n      })\n  }\n\n  async _getChildren(folderId:string|number, layers:number):Promise<TItem<typeof ItemLocation.SERVER>[]> {\n    const childrenJson = await this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${folderId}/children?layers=${layers}`\n    )\n    const children = childrenJson.data\n    const recurseChildren = (folderId, children) => {\n      return children.map((item) => {\n        if (item.type === 'bookmark') {\n          if ('target' in item && this.hasFeatureJavascriptLinks === null) {\n            this.hasFeatureJavascriptLinks = true\n          }\n          return new Bookmark({\n            id: item.id + ';' + folderId,\n            title: item.title,\n            parentId: folderId,\n            url: item.target || item.url,\n            location: ItemLocation.SERVER,\n          })\n        } else if (item.type === 'folder') {\n          const childFolder = new Folder({\n            id: item.id,\n            parentId: folderId,\n            title: item.title,\n            location: ItemLocation.SERVER,\n          })\n          childFolder.loaded = Boolean(item.children) // not children.length but whether the whole children field exists\n          childFolder.children = recurseChildren(item.id, item.children || [])\n          return childFolder\n        }\n      })\n    }\n    return recurseChildren(folderId, children)\n  }\n\n  async loadFolderChildren(folderId:string|number, all?: boolean): Promise<TItem<typeof ItemLocation.SERVER>[]> {\n    const folder = this.tree.findFolder(folderId)\n    if (!folder) {\n      throw new Error('Could not find folder for loadFolderChildren')\n    }\n    if (folder.loaded) {\n      return folder.clone(true).children\n    }\n    let children\n    if (all) {\n      children = await this._getChildren(folderId, -1)\n    } else {\n      children = await this._getChildren(folderId, 1)\n      const recurse = async(children) => {\n        return Parallel.each(children, async(child) => {\n          if (!(child instanceof Folder)) {\n            return\n          }\n          if (!child.loaded) {\n            const folderHash = await this._getFolderHash(child.id)\n            child.hashValue = { true: folderHash }\n          }\n          await recurse(child.children)\n        }, 5)\n      }\n      await recurse(children)\n    }\n    folder.children = children\n    folder.loaded = true\n    this.tree.createIndex()\n    return folder.clone(true).children\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.SERVER>):Promise<string|number> {\n    Logger.log('(nextcloud-folders)CREATEFOLDER', {folder})\n    const parentId = folder.parentId\n    const title = folder.title\n\n    const parentFolder = this.tree.findFolder(parentId)\n    if (!parentFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    const body = {\n      parent_folder: parentId,\n      title: title,\n    }\n    const json = await this.sendRequest(\n      'POST',\n      'index.php/apps/bookmarks/public/rest/v2/folder',\n      'application/json',\n      body\n    )\n    if (typeof json.item !== 'object') {\n      throw new UnexpectedServerResponseError()\n    }\n\n    parentFolder.children.push(\n      new Folder({ id: json.item.id, title, parentId, location: ItemLocation.SERVER })\n    )\n    this.tree.createIndex()\n    return json.item.id\n  }\n\n  async bulkImportFolder(parentId:string|number, folder:Folder<typeof ItemLocation.SERVER>):Promise<Folder<typeof ItemLocation.SERVER>> {\n    if (this.hasFeatureBulkImport === false) {\n      throw new Error('Current server does not support bulk import')\n    }\n    if (folder.count() > 75) {\n      throw new Error('Refusing to bulk import more than 75 bookmarks')\n    }\n    Logger.log('(nextcloud-folders)BULKIMPORT', { parentId, folder })\n    const parentFolder = this.tree.findFolder(parentId)\n    if (!parentFolder) {\n      throw new UnknownCreateTargetError()\n    }\n    const blob = new Blob(\n      [\n        '<!DOCTYPE NETSCAPE-Bookmark-file-1>\\n',\n        '<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\">\\n',\n        HtmlSerializer.serialize(folder),\n      ],\n      {\n        type: 'text/html',\n      }\n    )\n\n    const body = new FormData()\n    body.append('bm_import', blob, 'upload.html')\n\n    let json\n    try {\n      json = await this.sendRequest(\n        'POST',\n        `index.php/apps/bookmarks/public/rest/v2/folder/${parentId}/import`,\n        'multipart/form-data',\n        body\n      )\n    } catch (e) {\n      this.hasFeatureBulkImport = false\n      throw e\n    }\n\n    const recurseChildren = (children, id, title, parentId) => {\n      return new Folder({\n        id,\n        title,\n        parentId,\n        location: ItemLocation.SERVER,\n        children: children.map((item) => {\n          if (item.type === 'bookmark') {\n            return new Bookmark({\n              id: item.id + ';' + id,\n              title: item.title,\n              url: item.target || item.url,\n              parentId: id,\n              location: ItemLocation.SERVER,\n            })\n          } else if (item.type === 'folder') {\n            return recurseChildren(item.children, item.id, item.title, id)\n          } else {\n            console.log('PEBCAK', item)\n            throw new Error('PEBKAC')\n          }\n        }),\n      })\n    }\n    const imported = recurseChildren(json.data, parentId, folder.title, folder.parentId)\n    parentFolder.children = imported.clone(true).children\n    this.tree.createIndex()\n    return imported\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)UPDATEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.tree.findFolder(folder.id)\n    if (!oldFolder) {\n      throw new UnknownFolderUpdateError()\n    }\n    if (oldFolder.findFolder(folder.parentId)) {\n      throw new Error('Detected folder loop creation')\n    }\n    const body = {\n      parent_folder: folder.parentId,\n      title: folder.title,\n    }\n    await this.sendRequest(\n      'PUT',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${id}`,\n      'application/json',\n      body\n    )\n    const oldParentFolder = this.tree.findFolder(oldFolder.parentId)\n    if (!oldParentFolder) {\n      throw new UnknownFolderParentUpdateError()\n    }\n    oldParentFolder.children = oldParentFolder.children.filter(\n      (child) => String(child.id) !== String(id)\n    )\n    const newParentFolder = this.tree.findFolder(folder.parentId)\n    if (!newParentFolder) {\n      throw new UnknownMoveTargetError()\n    }\n    newParentFolder.children.push(oldFolder)\n    oldFolder.title = folder.title\n    oldFolder.parentId = folder.parentId\n    this.tree.createIndex()\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)ORDERFOLDER', { id, order })\n    const body = {\n      data: order.map((item) => ({\n        id: String(item.id).split(';')[0],\n        type: item.type,\n      })),\n    }\n    await this.sendRequest(\n      'PATCH',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${id}/childorder`,\n      'application/json',\n      body\n    )\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)REMOVEFOLDER', { folder })\n    const id = folder.id\n    const oldFolder = this.tree.findFolder(id)\n    if (!oldFolder) {\n      return\n    }\n    await this.sendRequest(\n      'DELETE',\n      `index.php/apps/bookmarks/public/rest/v2/folder/${id}`\n    )\n    const parent = this.tree.findFolder(oldFolder.parentId)\n    if (parent) {\n      parent.children = parent.children.filter(\n        (child) => String(child.id) !== String(id)\n      )\n      this.tree.createIndex()\n    }\n  }\n\n  async _getBookmark(id:string|number):Promise<Bookmark<typeof ItemLocation.SERVER>[]> {\n    Logger.log('Fetching single bookmark')\n\n    const json = await this.sendRequest(\n      'GET',\n      'index.php/apps/bookmarks/public/rest/v2/bookmark/' + id\n    )\n    if (typeof json.item !== 'object') {\n      throw new UnexpectedServerResponseError()\n    }\n\n    const bm = json.item\n    if (!bm.folders.length) {\n      bm.folders = [null]\n    }\n    return bm.folders.map((parentId) => {\n      return new Bookmark({\n        id: bm.id + ';' + parentId,\n        url: bm.target || bm.url,\n        title: bm.title,\n        parentId: parentId,\n        tags: bm.tags,\n        location: ItemLocation.SERVER,\n      })\n    })\n  }\n\n  async getExistingBookmark(url:string):Promise<false|Bookmark<typeof ItemLocation.SERVER>> {\n    if (url.toLowerCase().startsWith('javascript:')) {\n      if (!this.hasFeatureJavascriptLinks) {\n        return false\n      }\n      const json = await this.sendRequest(\n        'GET',\n        `index.php/apps/bookmarks/public/rest/v2/bookmark?page=-1&search[]=${encodeURIComponent(\n          'javascript:'\n        )}`\n      )\n      if (json.data.length) {\n        const bookmark = json.data.find(bookmark => bookmark.target === url)\n        if (bookmark) {\n          return {...bookmark, parentId: bookmark.folders[0], url}\n        } else {\n          return false\n        }\n      } else {\n        return false\n      }\n    }\n    const json = await this.sendRequest(\n      'GET',\n      `index.php/apps/bookmarks/public/rest/v2/bookmark?url=${encodeURIComponent(\n        url\n      )}`\n    )\n    if (json.data.length) {\n      return {...json.data[0], parentId: json.data[0].folders[0], url}\n    } else {\n      return false\n    }\n  }\n\n  async createBookmark(bm:Bookmark<typeof ItemLocation.SERVER>):Promise<string|number> {\n    Logger.log('(nextcloud-folders)CREATE', bm)\n\n    // We need this lock to avoid creating two boomarks with the same url\n    // in parallel\n    return this.bookmarkLock.acquire(bm.url, async() => {\n      let newParentFolder\n      if (this.tree) {\n        newParentFolder = this.tree.findFolder(bm.parentId)\n        if (!newParentFolder) {\n          throw new UnknownCreateTargetError()\n        }\n      }\n\n      const existingBookmark = await this.getExistingBookmark(bm.url)\n      if (existingBookmark) {\n        bm.id = existingBookmark.id + ';' + bm.parentId // We already use the new parentId here, to avoid moving it away from the old location\n        const updatedBookmark = bm.clone()\n        updatedBookmark.title = existingBookmark.title\n        await this.updateBookmark(updatedBookmark)\n      } else {\n        const body = {\n          url: bm.url,\n          title: bm.title,\n          folders: [bm.parentId],\n        }\n\n        let json\n        try {\n          json = await this.sendRequest(\n            'POST',\n            'index.php/apps/bookmarks/public/rest/v2/bookmark',\n            'application/json',\n            body\n          )\n        } catch (e) {\n          if (e instanceof HttpError) {\n            throw new CreateBookmarkError(bm)\n          }\n          throw e\n        }\n        if (typeof json.item !== 'object') {\n          throw new UnexpectedServerResponseError()\n        }\n        bm.id = json.item.id + ';' + bm.parentId\n      }\n      // add bookmark to cached list\n      const upstreamMark = bm.clone()\n      upstreamMark.id = bm.id.split(';')[0]\n      this.list && this.list.push(upstreamMark)\n      if (this.tree) {\n        newParentFolder.children.push(upstreamMark)\n        this.tree.createIndex()\n      }\n\n      return bm.id\n    })\n  }\n\n  async updateBookmark(newBm:Bookmark<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)UPDATE', newBm)\n\n    const [upstreamId, oldParentId] = String(newBm.id).split(';')\n\n    // We need this lock to avoid updating bookmarks which are in two places at Once\n    // in parallel\n    return this.bookmarkLock.acquire(upstreamId, async() => {\n      const bms = await this._getBookmark(upstreamId)\n\n      const newFolder = this.tree.findFolder(newBm.parentId)\n      if (!newFolder) {\n        throw new UnknownCreateTargetError()\n      }\n\n      const body = {\n        url: newBm.url,\n        title: newBm.title,\n        folders: bms\n          .map((bm) => bm.parentId)\n          .filter(\n            (parentId) =>\n              parentId && String(parentId) !== String(oldParentId) &&\n              // make sure this is not an outdated oldParentId (can happen due to canMergeWith in Scanner)\n              (!this.tree.findFolder(parentId) || this.tree.findFolder(parentId).findItemFilter('bookmark', i => i.canMergeWith(newBm)) || !this.tree.findFolder(parentId).loaded)\n          )\n          .concat([newBm.parentId]),\n        tags: bms[0].tags,\n      }\n\n      try {\n        await this.sendRequest(\n          'PUT',\n          `index.php/apps/bookmarks/public/rest/v2/bookmark/${upstreamId}`,\n          'application/json',\n          body\n        )\n      } catch (e) {\n        if (e instanceof HttpError) {\n          throw new UpdateBookmarkError(newBm)\n        }\n        throw e\n      }\n\n      if (!newFolder.children.find(item => String(item.id) === String(newBm.id) && item.type === 'bookmark')) {\n        newFolder.children.push(newBm)\n      }\n      newBm.id = upstreamId + ';' + newBm.parentId\n      this.tree.createIndex()\n\n      return newBm.id\n    })\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('(nextcloud-folders)REMOVE', { bookmark })\n    const id = bookmark.id\n    const [upstreamId, parentId] = String(id).split(';')\n\n    // Just to be safe\n    return this.bookmarkLock.acquire(upstreamId, async() => {\n      try {\n        await this.sendRequest(\n          'DELETE',\n          `index.php/apps/bookmarks/public/rest/v2/folder/${parentId}/bookmarks/${upstreamId}`\n        )\n        // remove bookmark from the cached list\n        const list = await this.getBookmarksList()\n        const listIndex = list.findIndex(\n          (bookmark) => String(bookmark.id) === String(upstreamId)\n        )\n        list.splice(listIndex, 1)\n      } catch (e) {\n        Logger.log('Error removing bookmark from folder: ' + e.message + '\\n Moving on.')\n      }\n    })\n  }\n\n  async checkFeatureJavascriptLinks(): Promise<void> {\n    if (this.hasFeatureJavascriptLinks !== null) {\n      return\n    }\n    try {\n      const json = await this.sendRequest(\n        'GET',\n        `index.php/apps/bookmarks/public/rest/v2/bookmark?page=1&limit=1`\n      )\n      if (!json.data.length) {\n        this.hasFeatureJavascriptLinks = true\n        try {\n          const id = await this.createBookmark(new Bookmark({id: null, parentId: '-1', title: 'floccus', url: 'javascript:void(0)', location: ItemLocation.SERVER}))\n          await this.removeBookmark(new Bookmark({id, parentId: '-1', title: 'floccus', url: 'javascript:void(0)', location: ItemLocation.SERVER}))\n        } catch (e) {\n          this.hasFeatureJavascriptLinks = false\n        }\n        return\n      }\n      this.hasFeatureJavascriptLinks = 'target' in json.data[0]\n    } catch (e) {\n      this.hasFeatureJavascriptLinks = false\n    }\n  }\n\n  async sendRequest(verb:string, relUrl:string, type:string = null, body:any = null, returnRawResponse = false):Promise<any> {\n    const url = this.normalizeServerURL(this.server.url) + relUrl\n    let res\n    let timedOut = false\n\n    if (type && type.includes('application/json')) {\n      body = JSON.stringify(body)\n    } else if (type && type.includes('application/x-www-form-urlencoded')) {\n      const params = new URLSearchParams()\n      for (const [key, value] of Object.entries(body || {})) {\n        params.set(key, value as any)\n      }\n      body = params.toString()\n    }\n\n    Logger.log(`QUEUING ${verb} ${url}`)\n\n    if (Capacitor.getPlatform() !== 'web') {\n      return this.sendRequestNative(verb, url, type, body, returnRawResponse)\n    }\n\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          fetch(url, {\n            method: verb,\n            credentials: this.server.includeCredentials ? 'include' : 'omit',\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Basic ' + authString,\n            },\n            signal: this.abortSignal,\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      if (this.canceled) throw new CancelledSyncError()\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.redirected && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      Logger.log(`${verb} ${url}: Server responded with ${res.status}: ` + (await res.text()).substring(0, 250))\n      throw new HttpError(res.status, verb)\n    }\n    let json\n    try {\n      json = await res.json()\n    } catch (e) {\n      throw new ParseResponseError(e.message)\n    }\n    if (json.status !== 'success') {\n      throw new Error('Nextcloud API error for request ' + verb + ' ' + relUrl + ' : \\n' + JSON.stringify(json))\n    }\n\n    return json\n  }\n\n  private async acquireLock():Promise<boolean> {\n    this.lockingPromise = (async() => {\n      const res = await this.sendRequest(\n        'POST',\n        'index.php/apps/bookmarks/public/rest/v2/lock',\n        null,\n        null,\n        true\n      )\n\n      if (res.status === 401 || res.status === 403) {\n        throw new AuthenticationError()\n      }\n      if (res.status !== 200 && res.status !== 405 && res.status !== 423) {\n        throw new HttpError(res.status, 'POST')\n      }\n\n      return res.status === 200 || res.status === 405\n    })()\n    return this.lockingPromise\n  }\n\n  private async releaseLock():Promise<boolean> {\n    if (this.lockingPromise) {\n      await this.lockingPromise\n    }\n    if (!this.locked) {\n      return\n    }\n    const res = await this.sendRequest(\n      'DELETE',\n      'index.php/apps/bookmarks/public/rest/v2/lock',\n      null,\n      null,\n      true\n    )\n\n    return res.status === 200\n  }\n\n  private async sendRequestNative(verb: string, url: string, type: string, body: any, returnRawResponse: boolean) {\n    let res\n    let timedOut = false\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    try {\n      res = await this.fetchQueue.add(() => {\n        Logger.log(`FETCHING ${verb} ${url}`)\n        return Promise.race([\n          Http.request({\n            url,\n            method: verb,\n            disableRedirects: !this.server.allowRedirects,\n            headers: {\n              ...(type && type !== 'multipart/form-data' && { 'Content-type': type }),\n              Authorization: 'Basic ' + authString,\n            },\n            responseType: 'json',\n            ...(body && !['get', 'head'].includes(verb.toLowerCase()) && { data: body }),\n          }),\n          new Promise((resolve, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(new RequestTimeoutError())\n            }, TIMEOUT)\n          ),\n        ])\n      })\n    } catch (e) {\n      if (timedOut) throw e\n      console.log(e)\n      throw new NetworkError()\n    }\n\n    Logger.log(`Receiving response for ${verb} ${url}`)\n\n    if (res.status < 400 && res.status >= 300) {\n      throw new RedirectError()\n    }\n\n    if (returnRawResponse) {\n      return res\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status === 503 || res.status >= 400) {\n      throw new HttpError(res.status, verb)\n    }\n    const json = res.data\n    if (json.status !== 'success') {\n      throw new Error('Nextcloud API error for request ' + verb + ' ' + url + ' : \\n' + JSON.stringify(json))\n    }\n\n    return json\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n\n  async countClick(url: string): Promise<void> {\n    try {\n      await this.sendRequest(\n        'POST',\n        'index.php/apps/bookmarks/public/rest/v2/bookmark/click',\n        'application/json',\n        {\n          url,\n        }\n      )\n    } catch (e) {\n      console.warn(e)\n    }\n  }\n}\n","import CachingAdapter from './Caching'\nimport XbelSerializer from '../serializers/Xbel'\nimport Logger from '../Logger'\nimport { Base64 } from 'js-base64'\n\nimport Crypto from '../Crypto'\nimport {\n  AuthenticationError,\n  DecryptionError, FileUnreadableError,\n  HttpError, CancelledSyncError,\n  LockFileError, MissingPermissionsError,\n  NetworkError, RedirectError, ResourceLockedError,\n  SlashError\n} from '../../errors/Error'\nimport { CapacitorHttp as Http } from '@capacitor/core'\nimport { Capacitor } from '@capacitor/core'\nimport Html from '../serializers/Html'\n\nconst LOCK_INTERVAL = 2 * 60 * 1000 // Lock every 2mins while syncing\nconst LOCK_TIMEOUT = 15 * 60 * 1000 // Override lock 0.25h after last time lock has been set\nexport default class WebDavAdapter extends CachingAdapter {\n  private lockingInterval: any\n  private lockingPromise: Promise<any>\n  private locked: boolean\n  private ended: boolean\n  private abortController: AbortController\n  private abortSignal: AbortSignal\n  private cancelCallback: () => void\n  private initialTreeHash: string\n  constructor(server) {\n    super(server)\n    this.server = server\n    this.locked = false\n    this.ended = true\n    this.lockingInterval = null\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'webdav',\n      url: 'https://example.org/',\n      username: 'bob',\n      password: 's3cret',\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      includeCredentials: false,\n      allowRedirects: false,\n      passphrase: '',\n      allowNetwork: false,\n    }\n  }\n\n  getData() {\n    return { ...WebDavAdapter.getDefaultValues(), ...this.server }\n  }\n\n  normalizeServerURL(input) {\n    const serverURL = new URL(input)\n    if (!serverURL.pathname) serverURL.pathname = ''\n    serverURL.search = ''\n    serverURL.hash = ''\n    const output = serverURL.toString()\n    return output + (output[output.length - 1] !== '/' ? '/' : '')\n  }\n\n  cancel() {\n    this.abortController.abort()\n    this.cancelCallback && this.cancelCallback()\n  }\n\n  getBookmarkURL() {\n    return this.normalizeServerURL(this.server.url) + this.server.bookmark_file\n  }\n\n  getBookmarkLockURL() {\n    return this.getBookmarkURL() + '.lock'\n  }\n\n  async checkLock() {\n    const fullURL = this.getBookmarkLockURL()\n    Logger.log(fullURL)\n\n    const response = await this.downloadFile(fullURL)\n    return response\n  }\n\n  timeout(ms) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, ms)\n      this.cancelCallback = () => reject(new CancelledSyncError())\n    })\n  }\n\n  async obtainLock() {\n    const res = await this.checkLock()\n    if (res.status === 200) {\n      if (res.headers['Last-Modified']) {\n        const date = new Date(res.headers['Last-Modified'])\n        const dateLocked = date.valueOf()\n        if (dateLocked + LOCK_TIMEOUT > Date.now()) {\n          throw new ResourceLockedError()\n        }\n      } else {\n        throw new ResourceLockedError()\n      }\n    }\n\n    if (res.status === 200) {\n      // continue anyway\n      this.locked = true\n    } else if (res.status === 404) {\n      await this.setLock()\n    } else {\n      throw new LockFileError(\n        res.status,\n        this.server.bookmark_file + '.lock'\n      )\n    }\n  }\n\n  async setLock() {\n    const fullURL = this.getBookmarkLockURL()\n    Logger.log('Setting lock: ' + fullURL)\n    this.lockingPromise = this.uploadFile(\n      fullURL,\n      'text/html',\n      '<html><body>I am a lock file</body></html>'\n    )\n    try {\n      await this.lockingPromise\n    } catch (e) {\n      if (e instanceof HttpError && (e.status === 423 || e.status === 409)) {\n        this.locked = false\n        throw new ResourceLockedError()\n      }\n      throw e\n    }\n    this.locked = true\n  }\n\n  async freeLock() {\n    if (this.lockingPromise) {\n      try {\n        await this.lockingPromise\n      } catch (e) {\n        console.warn(e)\n      }\n    }\n    if (!this.locked) {\n      return\n    }\n\n    const fullUrl = this.getBookmarkLockURL()\n\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n\n    let res, lockFreed, i = 0\n    try {\n      do {\n        Logger.log('Freeing lock: ' + fullUrl)\n        if (Capacitor.getPlatform() === 'web') {\n          res = await fetch(fullUrl, {\n            method: 'DELETE',\n            credentials: 'omit',\n            headers: {\n              Authorization: 'Basic ' + authString\n            },\n            signal: this.abortSignal,\n            ...(!this.server.allowRedirects && {redirect: 'manual'}),\n          })\n        } else {\n          res = await Http.request({\n            url: fullUrl,\n            method: 'DELETE',\n            headers: {\n              Authorization: 'Basic ' + authString\n            },\n            webFetchExtra: {\n              credentials: 'omit',\n            }\n          })\n        }\n        lockFreed = res.status === 200 || res.status === 204 || res.status === 404\n        if (!lockFreed) {\n          await this.timeout(1000)\n        }\n        i++\n      } while (!lockFreed && i < 10)\n      return lockFreed\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n    }\n  }\n\n  async pullFromServer() {\n    const fullUrl = this.getBookmarkURL()\n\n    const response = await this.downloadFile(fullUrl)\n\n    if (response.status === 401) {\n      throw new AuthenticationError()\n    }\n\n    if (response.status === 404) {\n      this.resetCache()\n      return response\n    }\n\n    if (response.status === 200) {\n      let xmlDocText = response.data\n\n      if (this.server.passphrase) {\n        try {\n          try {\n            const json = JSON.parse(xmlDocText)\n            xmlDocText = await Crypto.decryptAES(this.server.passphrase, json.ciphertext, json.salt)\n          } catch (e) {\n            xmlDocText = await Crypto.decryptAES(this.server.passphrase, xmlDocText, this.server.bookmark_file)\n          }\n        } catch (e) {\n          if (xmlDocText && (xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>') || xmlDocText.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>'))) {\n            // not encrypted, yet => noop\n          } else {\n            throw new DecryptionError()\n          }\n        }\n      } else if (!xmlDocText || (!xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>') && !xmlDocText.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>'))) {\n        throw new FileUnreadableError()\n      }\n\n      /* let's get the highestId */\n      const byNL = xmlDocText.split('\\n')\n      for (const line of byNL) {\n        if (line.indexOf('<!--- highestId :') >= 0) {\n          const idxStart = line.indexOf(':') + 1\n          const idxEnd = line.lastIndexOf(':')\n\n          this.highestId = parseInt(line.substring(idxStart, idxEnd))\n          break\n        }\n      }\n\n      switch (this.server.bookmark_file_type) {\n        case 'xbel':\n          if (!xmlDocText.includes('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')) {\n            throw new FileUnreadableError()\n          }\n          this.bookmarksCache = XbelSerializer.deserialize(xmlDocText)\n          break\n        case 'html':\n          if (!xmlDocText.includes('<!DOCTYPE NETSCAPE-Bookmark-file-1>')) {\n            throw new FileUnreadableError()\n          }\n          this.bookmarksCache = Html.deserialize(xmlDocText)\n          break\n        default:\n          throw new Error('Invalid bookmark file type')\n      }\n    }\n\n    return response\n  }\n\n  async onSyncStart(needLock = true, forceLock = false) {\n    Logger.log('onSyncStart: begin')\n    this.ended = false\n\n    if (Capacitor.getPlatform() === 'web') {\n      const browser = (await import('../browser-api')).default\n      let hasPermissions, error = false\n      try {\n        hasPermissions = await browser.permissions.contains({ origins: [this.server.url + '/'] })\n      } catch (e) {\n        error = true\n        console.warn(e)\n      }\n      if (!error && !hasPermissions) {\n        throw new MissingPermissionsError()\n      }\n    }\n\n    if (this.server.bookmark_file[0] === '/') {\n      throw new SlashError()\n    }\n\n    this.abortController = new AbortController()\n    this.abortSignal = this.abortController.signal\n\n    if (forceLock) {\n      await this.setLock()\n    } else if (needLock) {\n      await this.obtainLock()\n    }\n\n    const resp = await this.pullFromServer()\n\n    if (resp.status !== 200) {\n      if (resp.status !== 404) {\n        throw new HttpError(resp.status, 'GET')\n      }\n    }\n\n    this.initialTreeHash = await this.bookmarksCache.hash(true)\n\n    Logger.log('onSyncStart: completed')\n\n    if (this.lockingInterval) {\n      clearInterval(this.lockingInterval)\n    }\n    if (needLock || forceLock) {\n      this.lockingInterval = setInterval(() => !this.ended && this.setLock(), LOCK_INTERVAL) // Set lock every minute\n    }\n\n    if (resp.status === 404) {\n      // Notify sync process that we need to reset cache\n      return false\n    }\n  }\n\n  async onSyncFail() {\n    Logger.log('onSyncFail')\n    this.ended = true\n    clearInterval(this.lockingInterval)\n    await this.freeLock()\n  }\n\n  async onSyncComplete() {\n    Logger.log('onSyncComplete')\n    this.ended = true\n    clearInterval(this.lockingInterval)\n\n    this.bookmarksCache = this.bookmarksCache.clone()\n    const newTreeHash = await this.bookmarksCache.hash(true)\n    if (newTreeHash !== this.initialTreeHash) {\n      const fullUrl = this.getBookmarkURL()\n      let xbel = this.server.bookmark_file_type === 'xbel' ? createXBEL(this.bookmarksCache, this.highestId) : createHTML(this.bookmarksCache, this.highestId)\n      if (this.server.passphrase) {\n        const salt = Crypto.bufferToHexstr(Crypto.getRandomBytes(64))\n        const ciphertext = await Crypto.encryptAES(this.server.passphrase, xbel, salt)\n        xbel = JSON.stringify({ciphertext, salt})\n      }\n      await this.uploadFile(fullUrl, this.server.bookmark_file_type === 'xbel' ? 'application/xml' : 'text/html', xbel)\n    } else {\n      Logger.log('No changes to the server version necessary')\n    }\n\n    await this.freeLock()\n  }\n\n  async uploadFile(url, content_type, data) {\n    if (Capacitor.getPlatform() === 'web') {\n      return this.uploadFileWeb(url, content_type, data)\n    } else {\n      return this.uploadFileNative(url, content_type, data)\n    }\n  }\n\n  async uploadFileWeb(url, content_type, data) {\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    let res\n    try {\n      res = await fetch(url,{\n        method: 'PUT',\n        headers: {\n          'Content-Type': content_type,\n          Authorization: 'Basic ' + authString\n        },\n        credentials: 'omit',\n        signal: this.abortSignal,\n        ...(!this.server.allowRedirects && {redirect: 'manual'}),\n        body: data,\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      if (this.abortSignal.aborted) throw new CancelledSyncError()\n      throw new NetworkError()\n    }\n    if (res.status === 0 && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300) {\n      throw new HttpError(res.status, 'PUT')\n    }\n  }\n\n  async uploadFileNative(url, content_type, data) {\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    let res\n    try {\n      res = await Http.request({\n        url,\n        method: 'PUT',\n        headers: {\n          'Content-Type': content_type,\n          Authorization: 'Basic ' + authString\n        },\n        data\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300) {\n      throw new HttpError(res.status, 'PUT')\n    }\n  }\n\n  async downloadFile(url) {\n    if (Capacitor.getPlatform() === 'web') {\n      return this.downloadFileWeb(url)\n    } else {\n      return this.downloadFileNative(url)\n    }\n  }\n\n  async downloadFileWeb(url) {\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n    let res\n    try {\n      res = await fetch(url,{\n        method: 'GET',\n        headers: {\n          Authorization: 'Basic ' + authString\n        },\n        cache: 'no-store',\n        credentials: 'omit',\n        signal: this.abortSignal,\n        ...(!this.server.allowRedirects && {redirect: 'manual'})\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      if (this.abortSignal.aborted) throw new CancelledSyncError()\n      throw new NetworkError()\n    }\n    if (res.status === 0 && !this.server.allowRedirects) {\n      throw new RedirectError()\n    }\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300 && res.status !== 404) {\n      throw new HttpError(res.status, 'GET')\n    }\n\n    return { status: res.status, data: await res.text(), headers: res.headers }\n  }\n\n  async downloadFileNative(fullURL) {\n    let res\n    const authString = Base64.encode(\n      this.server.username + ':' + this.server.password\n    )\n\n    try {\n      res = await Http.request({\n        url: fullURL,\n        method: 'GET',\n        headers: {\n          Authorization: 'Basic ' + authString,\n          Pragma: 'no-cache',\n          'Cache-Control': 'no-cache'\n        },\n        responseType: 'text'\n      })\n    } catch (e) {\n      Logger.log('Error Caught')\n      Logger.log(e)\n      throw new NetworkError()\n    }\n\n    if (res.status === 401 || res.status === 403) {\n      throw new AuthenticationError()\n    }\n    if (res.status >= 300 && res.status !== 404) {\n      throw new HttpError(res.status, 'GET')\n    }\n\n    return res\n  }\n}\n\nfunction createXBEL(rootFolder, highestId) {\n  let output = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE xbel PUBLIC \"+//IDN python.org//DTD XML Bookmark Exchange Language 1.0//EN//XML\" \"http://pyxml.sourceforge.net/topics/dtds/xbel.dtd\">\n<xbel version=\"1.0\">\n`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += XbelSerializer.serialize(rootFolder)\n\n  output += `\n</xbel>`\n\n  return output\n}\n\nfunction createHTML(rootFolder, highestId) {\n  let output = `<!DOCTYPE NETSCAPE-Bookmark-file-1>\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=UTF-8\">\n<TITLE>Bookmarks</TITLE>`\n\n  output +=\n    '<!--- highestId :' +\n    highestId +\n    `: for Floccus bookmark sync browser extension -->\n`\n\n  output += Html.serialize(rootFolder)\n\n  output += '</html>'\n\n  return output\n}\n","import BrowserAccountStorage from './BrowserAccountStorage'\nimport BrowserTree from './BrowserTree'\nimport browser from '../browser-api'\nimport AdapterFactory from '../AdapterFactory'\nimport Account from '../Account'\nimport {\n  CreateBookmarkError,\n  FailsafeError, FloccusError,\n  HttpError,\n  InconsistentBookmarksExistenceError, LockFileError,\n  MissingItemOrderError,\n  ParseResponseError,\n  UnknownFolderItemOrderError, UpdateBookmarkError\n} from '../../errors/Error'\nimport {i18n} from '../native/I18n'\nimport { OrderFolderResource } from '../interfaces/Resource'\nimport { ItemLocation } from '../Tree'\n\nexport default class BrowserAccount extends Account {\n  static async get(id:string):Promise<Account> {\n    const storage = new BrowserAccountStorage(id)\n    const data = await storage.getAccountData(null)\n    const tree = new BrowserTree(storage, data.localRoot)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new BrowserAccount(id, storage, await AdapterFactory.factory(data), tree)\n  }\n\n  static async create(data):Promise<Account> {\n    const id = '' + Date.now() + Math.random()\n    const adapter = await AdapterFactory.factory(data)\n    const storage = new BrowserAccountStorage(id)\n\n    await storage.setAccountData(data, null)\n    const tree = new BrowserTree(storage, data.localRoot)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new BrowserAccount(id, storage, adapter, tree)\n  }\n\n  async init():Promise<void> {\n    console.log('initializing account ' + this.id)\n    const accData = this.getData()\n    if (!(await this.isInitialized()) && accData.localRoot !== 'tabs') {\n      const parentNode = await browser.bookmarks.getTree()\n      const bookmarksBar = parentNode[0].children[0]\n      const node = await browser.bookmarks.create({\n        title: 'Floccus (' + this.getLabel() + ')',\n        parentId: bookmarksBar.id,\n      })\n      accData.localRoot = node.id\n      accData.rootPath = await BrowserTree.getPathFromLocalId(node.id)\n      await this.setData(accData)\n    }\n    await this.storage.initMappings()\n    await this.storage.initCache()\n    this.localTree = new BrowserTree(this.storage, accData.localRoot)\n  }\n\n  async isInitialized():Promise<boolean> {\n    try {\n      const localRoot = this.getData().localRoot\n      if (localRoot === 'tabs') {\n        return true\n      }\n      await browser.bookmarks.getSubTree(localRoot)\n      return true\n    } catch (e) {\n      console.log('Apparently not initialized, because:', e)\n      return false\n    }\n  }\n\n  async getResource():Promise<OrderFolderResource<typeof ItemLocation.LOCAL>> {\n    if (this.getData().localRoot !== 'tabs') {\n      return this.localTree\n    } else {\n      const LocalTabs = (await import('../LocalTabs')).default\n      this.localTabs = new LocalTabs(this.storage)\n      return this.localTabs\n    }\n  }\n\n  async updateFromStorage():Promise<void> {\n    const data = await this.storage.getAccountData(null)\n    this.server.setData(data)\n    this.localTree = new BrowserTree(this.storage, data.localRoot)\n  }\n\n  static async stringifyError(er:any):Promise<string> {\n    if (er instanceof UnknownFolderItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof MissingItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof HttpError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.method])\n    }\n    if (er instanceof ParseResponseError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0')) + '\\n' + er.response\n    }\n    if (er instanceof InconsistentBookmarksExistenceError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.folder, er.bookmark])\n    }\n    if (er instanceof LockFileError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.lockFile])\n    }\n    if (er instanceof FailsafeError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.percent])\n    }\n    if (er instanceof CreateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof UpdateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof FloccusError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'))\n    }\n    if (er.list) {\n      if (er.list[0].code === 26) {\n        // Do not spam log with E026 (cancelled sync)\n        return this.stringifyError(er.list[0])\n      }\n      return (await Promise.all(er.list\n        .map((e) => {\n          return this.stringifyError(e)\n        })))\n        .join('\\n')\n    }\n    return er.message\n  }\n\n  static async getAllAccounts():Promise<Account[]> {\n    return Promise.all(\n      (await BrowserAccountStorage.getAllAccounts()).map((accountId) =>\n        Account.get(accountId)\n      )\n    )\n  }\n\n  static async getAccountsContainingLocalId(localId:string, ancestors:string[], allAccounts:Account[], withDisallowNested = false):Promise<Account[]> {\n    ancestors = ancestors || (await BrowserTree.getIdPathFromLocalId(localId))\n    allAccounts = allAccounts || (await this.getAllAccounts())\n\n    const accountsInvolved = allAccounts\n      .filter(acc => ancestors.includes(acc.getData().localRoot))\n      .sort((a, b) =>\n        ancestors.indexOf(a.getData().localRoot) - ancestors.indexOf(b.getData().localRoot)\n      )\n      .reverse()\n\n    if (!withDisallowNested) {\n      const lastNesterIdx = accountsInvolved.findIndex(acc => !acc.getData().nestedSync)\n      return accountsInvolved.slice(0, Math.max(1, lastNesterIdx))\n    } else {\n      return accountsInvolved\n    }\n  }\n}\n","export const isVivaldi = async() => {\n  const {default: browser} = await import('../browser-api.js')\n  const tabs = await browser.tabs.query({ active: true, currentWindow: true })\n  return Boolean(tabs?.[0]?.['vivExtData'])\n}\n","import browser from '../browser-api'\nimport Logger from '../Logger'\nimport * as Tree from '../Tree'\nimport { IResource } from '../interfaces/Resource'\nimport PQueue from 'p-queue'\nimport Account from '../Account'\nimport { Bookmark, Folder, ItemLocation, ItemType } from '../Tree'\nimport Ordering from '../interfaces/Ordering'\nimport random from 'random'\nimport seedrandom from 'seedrandom'\nimport { isVivaldi } from './BrowserDetection'\nimport { LocalFolderNotFoundError } from '../../errors/Error'\n\nlet absoluteRoot: {id: string}\n\nexport default class BrowserTree implements IResource<typeof ItemLocation.LOCAL> {\n  private readonly rootId: string\n  private queue: PQueue<{ concurrency: 10 }>\n  private storage: unknown\n  private absoluteRoot: { id: string }\n  private absoluteRootPromise: Promise<void>\n\n  constructor(storage:unknown, rootId:string) {\n    this.rootId = rootId\n    this.storage = storage\n    this.queue = new PQueue({ concurrency: 10 })\n    this.absoluteRootPromise = BrowserTree.getAbsoluteRootFolder().then(root => {\n      this.absoluteRoot = root\n    })\n  }\n\n  async getBookmarksTree():Promise<Folder<typeof ItemLocation.LOCAL>> {\n    const isVivaldiBrowser = await isVivaldi()\n    let tree\n    try {\n      [tree] = await browser.bookmarks.getSubTree(this.rootId)\n    } catch (e) {\n      throw new LocalFolderNotFoundError()\n    }\n    await this.absoluteRootPromise\n    const allAccounts = await (await Account.getAccountClass()).getAllAccounts()\n\n    const recurse = (node, parentId?, rng?) => {\n      if (\n        allAccounts.some(\n          acc => acc.getData().localRoot === node.id && String(node.id) !== String(this.rootId) && !acc.getData().nestedSync\n        )\n      ) {\n        // This is the root folder of a different account and the user doesn't want nested sync\n        return\n      }\n      let overrideTitle, isRoot\n      if (node.parentId === this.absoluteRoot.id && !isVivaldiBrowser) {\n        switch (node.id) {\n          case '1': // Chrome\n          case 'toolbar_____': // Firefox\n            overrideTitle = 'Bookmarks Bar'\n            break\n          case '2': // Chrome\n          case 'unfiled_____': // Firefox\n            overrideTitle = 'Other Bookmarks'\n            break\n          case 'menu________': // Firefox\n            overrideTitle = 'Bookmarks Menu'\n            break\n          case 'mobile______': // Firefox\n            overrideTitle = 'Mobile Bookmarks'\n        }\n        if (overrideTitle) {\n          Logger.log(\n            'Overriding title of built-in node',\n            node.id,\n            node.title,\n            '=>',\n            overrideTitle\n          )\n        }\n      }\n      if (node.id === this.absoluteRoot.id) {\n        isRoot = true\n      }\n      if (node.children) {\n        // seeded pseudo random number generator for separator IDs\n        // We use this because we want IDs that are (largely) collision-free even\n        // between folders and still consistent across browsers\n        const rng = random.clone(seedrandom(node.title))\n        const folder = new Tree.Folder({\n          location: ItemLocation.LOCAL,\n          id: node.id,\n          parentId,\n          title: parentId ? overrideTitle || node.title : undefined,\n          children: node.children\n            .map((child) => {\n              return recurse(child, node.id, rng)\n            })\n            .filter(child => !!child) // filter out `undefined` from nested accounts\n        })\n        folder.isRoot = isRoot\n        return folder\n      } else if (self.location.protocol === 'moz-extension:' && node.type === 'separator') {\n        // Translate mozilla separators to floccus separators\n        return new Tree.Bookmark({\n          location: ItemLocation.LOCAL,\n          id: node.id,\n          parentId,\n          title: '-----',\n          // If you have more than a quarter million separators in one folder, call me\n          // Floccus breaks down much earlier atm\n          url: `https://separator.floccus.org/?id=${rng.int(0,1000000)}`,\n        })\n      } else {\n        return new Tree.Bookmark({\n          location: ItemLocation.LOCAL,\n          id: node.id,\n          parentId,\n          title: node.title,\n          url: node.url\n        })\n      }\n    }\n    return recurse(tree) as Folder<typeof ItemLocation.LOCAL>\n  }\n\n  async createBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    Logger.log('(local)CREATE', bookmark)\n    if (bookmark.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    try {\n      if (self.location.protocol === 'moz-extension:' && new URL(bookmark.url).hostname === 'separator.floccus.org') {\n        const node = await this.queue.add(async() => {\n          Logger.log('(local)CREATE: executing create ', bookmark)\n          return browser.bookmarks.create({\n            parentId: bookmark.parentId.toString(),\n            type: 'separator'\n          })\n        })\n        return node.id\n      }\n      const node = await this.queue.add(async() => {\n        Logger.log('(local)CREATE: executing create ', bookmark)\n        return browser.bookmarks.create({\n          parentId: bookmark.parentId.toString(),\n          title: bookmark.title,\n          url: bookmark.url\n        })\n      })\n      return node.id\n    } catch (e) {\n      throw new Error('Could not create ' + bookmark.inspect() + ': ' + e.message)\n    }\n  }\n\n  async updateBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>):Promise<void> {\n    Logger.log('(local)UPDATE', bookmark)\n    if (bookmark.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    try {\n      if (self.location.protocol === 'moz-extension:' && new URL(bookmark.url).hostname === 'separator.floccus.org') {\n        // noop\n      } else {\n        await this.queue.add(async() => {\n          Logger.log('(local)UPDATE: executing update ', bookmark)\n          return browser.bookmarks.update(bookmark.id, {\n            title: bookmark.title,\n            url: bookmark.url\n          })\n        })\n      }\n      await this.queue.add(async() => {\n        Logger.log('(local)UPDATE: executing move ', bookmark)\n        return browser.bookmarks.move(bookmark.id, {\n          parentId: bookmark.parentId.toString()\n        })\n      })\n    } catch (e) {\n      throw new Error('Could not update ' + bookmark.inspect() + ': ' + e.message)\n    }\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<void> {\n    if (bookmark.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    const bookmarkId = bookmark.id\n    Logger.log('(local)REMOVE', bookmark)\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)REMOVE: executing remove ', bookmark)\n        return browser.bookmarks.remove(bookmarkId)\n      })\n    } catch (e) {\n      Logger.log('Could not remove ' + bookmark.inspect() + ': ' + e.message + '\\n Moving on')\n    }\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.LOCAL>): Promise<string> {\n    const {parentId, title} = folder\n    Logger.log('(local)CREATEFOLDER', folder)\n    if (folder.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    try {\n      const node = await this.queue.add(async() => {\n        Logger.log('(local)CREATEFOLDER: executing create ', folder)\n        return browser.bookmarks.create({\n          parentId: parentId.toString(),\n          title\n        })\n      })\n      return node.id\n    } catch (e) {\n      throw new Error('Could not create ' + folder.inspect() + ': ' + e.message)\n    }\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.LOCAL>) :Promise<void> {\n    Logger.log('(local)ORDERFOLDER', { id, order })\n    if (id === this.absoluteRoot.id) {\n      Logger.log('This action affects the absolute root. Skipping.')\n      return\n    }\n    const [realTree] = await browser.bookmarks.getSubTree(id)\n    try {\n      for (let index = 0; index < order.length; index++) {\n        await browser.bookmarks.move(order[index].id, { parentId: id.toString(), index })\n      }\n    } catch (e) {\n      throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n    }\n    // Move items not touched by sync back to where they were\n    // Not perfect but good enough (Problem: [a,X,c] => insert(b,0) => [b, X, a, c])\n    if (realTree.children.length !== order.length) {\n      const untouchedChildren = realTree.children.map((child,i) => [i, child]).filter(([, child]) =>\n        child.url\n          ? !order.some(item => item.type === ItemType.BOOKMARK && String(item.id) === String(child.id))\n          : !order.some(item => item.type === ItemType.FOLDER && String(item.id) === String(child.id))\n      )\n      try {\n        Logger.log('Move untouched children back into place', {untouchedChildren: untouchedChildren.map(([i, item]) => [i, item.id])})\n        for (const [index, child] of untouchedChildren) {\n          await browser.bookmarks.move(child.id, { parentId: id.toString(), index})\n        }\n      } catch (e) {\n        throw new Error('Failed to reorder folder ' + id + ': ' + e.message)\n      }\n    }\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    const {id, title, parentId} = folder\n    Logger.log('(local)UPDATEFOLDER', folder)\n    if (folder.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects a root folder. Skipping.')\n      return\n    }\n    if (folder.isRoot) {\n      Logger.log('This is the absolute root folder. Skip.')\n      return\n    }\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)UPDATEFOLDER: executing update ', folder)\n        return browser.bookmarks.update(id.toString(), {\n          title\n        })\n      })\n    } catch (e) {\n      throw new Error('Failed to rename folder ' + id + ': ' + e.message)\n    }\n    const oldFolder = (await browser.bookmarks.getSubTree(id))[0]\n    if (Folder.hydrate(oldFolder).findFolder(parentId)) {\n      throw new Error('Detected creation of folder loop. Moving ' + id + ' into its descendant ' + parentId)\n    }\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)CREATEFOLDER: executing move ', folder)\n        return browser.bookmarks.move(id.toString(), { parentId })\n      })\n    } catch (e) {\n      throw new Error('Failed to move folder ' + id + ': ' + e.message)\n    }\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    const id = folder.id\n    Logger.log('(local)REMOVEFOLDER', id)\n    if (folder.parentId === this.absoluteRoot.id) {\n      Logger.log('This action affects a root folder. Skipping.')\n      return\n    }\n    if (folder.isRoot) {\n      Logger.log('This is the root folder. Skip.')\n      return\n    }\n    try {\n      await this.queue.add(async() => {\n        Logger.log('(local)REMOVEFOLDER: executing remove ', folder)\n        return browser.bookmarks.removeTree(id.toString())\n      })\n    } catch (e) {\n      Logger.log('Could not remove ' + folder.inspect() + ': ' + e.message + '\\n Moving on.')\n    }\n  }\n\n  static async getPathFromLocalId(localId:string, ancestors?:string[], relativeToRoot?:string):Promise<string> {\n    if (localId === 'tabs') {\n      return browser.i18n.getMessage('LabelTabs')\n    }\n    try {\n      ancestors = ancestors || (await BrowserTree.getIdPathFromLocalId(localId))\n\n      if (relativeToRoot) {\n        ancestors = ancestors.slice(ancestors.indexOf(relativeToRoot) + 1)\n      }\n\n      return (\n        await Promise.all(\n          ancestors.map(async ancestor => {\n            try {\n              const bms = await browser.bookmarks.get(ancestor)\n              const bm = bms[0]\n              return bm.title.replace(/[/]/g, '\\\\/')\n            } catch (e) {\n              return 'Error!'\n            }\n          })\n        )\n      ).join('/')\n    } catch (e) {\n      return browser.i18n.getMessage('LabelFolderNotFound')\n    }\n  }\n\n  static async getIdPathFromLocalId(localId:string|null, path:string[] = []):Promise<string[]> {\n    if (typeof localId === 'undefined') {\n      return path\n    }\n    path.unshift(localId)\n    const bms = await browser.bookmarks.get(localId)\n    const bm = bms[0]\n    if (bm.parentId === localId) {\n      return path // might be that the root is circular\n    }\n    return this.getIdPathFromLocalId(bm.parentId, path)\n  }\n\n  static async getAbsoluteRootFolder() {\n    if (!absoluteRoot) {\n      try {\n        // chromium\n        absoluteRoot = (await browser.bookmarks.get('0'))[0]\n      } catch (e) {\n        try {\n          // firefox\n          absoluteRoot = (await browser.bookmarks.get('root________'))[0]\n        } catch (e) {\n          // any other browser\n          absoluteRoot = (await browser.bookmarks.getTree())[0]\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          delete absoluteRoot.children\n        }\n      }\n    }\n    return absoluteRoot\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n}\n","export default interface IController {\n  setEnabled(enabled:boolean): void;\n  unlock(key):Promise<void>;\n  scheduleSync(accountId, wait):Promise<void>;\n  scheduleAll():Promise<void>;\n  cancelSync(accountId, keepEnabled):Promise<void>;\n  syncAccount(accountId, strategy, forceSync):Promise<void>;\n  onStatusChange(listener):()=>void;\n  getUnlocked():Promise<boolean>;\n  onLoad():Promise<void>;\n}\n\nexport const STATUS_ERROR = Symbol('error')\nexport const STATUS_SYNCING = Symbol('syncing')\nexport const STATUS_ALLGOOD = Symbol('allgood')\nexport const STATUS_DISABLED = Symbol('disabled')\n","export const isTest = typeof window !== 'undefined' && (new URL(window.location.href)).pathname.includes('test')\n","import IntlMessageFormat from 'intl-messageformat'\nimport DEFAULT_MESSAGES from '../../../_locales/en/messages.json'\n\n// hehe, ignore all the things...\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst context = require.context(\n  '../../../_locales',\n  true,\n  /^.*?\\.json$/,\n  'lazy'\n)\n\ninterface TranslationEntry {\n  message: string;\n}\ninterface Messages {\n  [key: string]: TranslationEntry;\n}\n\nexport default class I18n {\n  private locales: string[];\n  private locale = 'en'\n  private messages: Messages | undefined;\n  private defaultMessages: Messages;\n  constructor(locale: string) {\n    this.locales = [locale]\n    this.defaultMessages = DEFAULT_MESSAGES\n    this.messages = DEFAULT_MESSAGES\n  }\n\n  setLocales(locales:string[]):void {\n    this.locales = locales\n  }\n\n  async load():Promise<void> {\n    for (const locale of this.locales) {\n      try {\n        const fileName = './' + locale.replace('-', '_') + '/messages.json'\n        const imported = await context(fileName)\n        console.log(imported)\n        this.messages = imported\n        this.locale = locale\n        break\n      } catch (error) {\n        console.warn(error)\n      }\n      try {\n        const fileName = './' + locale.split('-')[0] + '/messages.json'\n        const imported = await context(fileName)\n        console.log(imported)\n        this.messages = imported\n        this.locale = locale.split('-')[0]\n        break\n      } catch (error) {\n        console.warn(error)\n      }\n    }\n  }\n\n  /**\n   * Get a formatted message with the given name\n   */\n  public getMessage(messageName: string, content?: any, formats?: any): string {\n    const string = this.doGetMessage(messageName)\n    if (string) {\n      const message = new IntlMessageFormat(string.message, this.locale, formats).format(content)\n      if (!message) {\n        return messageName\n      }\n      if (Array.isArray(message)) {\n        return message.join('')\n      }\n      return message\n    }\n    return messageName\n  }\n\n  /**\n   * Get message with given name from the default locale\n   */\n  private getDefaultLocaleMessage(messageName: string): TranslationEntry | null {\n    if (!Object.hasOwnProperty.call(this.defaultMessages, messageName)) {\n      console.warn(`WARN: No message found with name ${messageName} in default locale en`)\n      return null\n    }\n    return this.defaultMessages[messageName]\n  }\n\n  /**\n   * Get message with given name\n   */\n  private doGetMessage(messageName: string): TranslationEntry | null {\n    if (!this.messages || !Object.hasOwnProperty.call(this.messages, messageName)) {\n      console.warn(`No message found with name ${messageName} in locale ${this.locale}. Using default locale 'en'`)\n      return this.getDefaultLocaleMessage(messageName)\n    }\n    return this.messages[messageName]\n  }\n}\n\nexport const i18n = new I18n('en')\n","import NativeAccountStorage from './NativeAccountStorage'\nimport NativeTree from './NativeTree'\nimport AdapterFactory from '../AdapterFactory'\nimport Account from '../Account'\nimport { IAccountData } from '../interfaces/AccountStorage'\nimport {\n  CreateBookmarkError,\n  FailsafeError, FloccusError,\n  HttpError,\n  InconsistentBookmarksExistenceError, LockFileError,\n  MissingItemOrderError,\n  ParseResponseError,\n  UnknownFolderItemOrderError, UpdateBookmarkError\n} from '../../errors/Error'\nimport Logger from '../Logger'\nimport { i18n } from './I18n'\n\nexport default class NativeAccount extends Account {\n  static async get(id:string):Promise<Account> {\n    const storage = new NativeAccountStorage(id)\n    const data = await storage.getAccountData(null)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tree = new NativeTree(storage)\n    await tree.load()\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new NativeAccount(id, storage, await AdapterFactory.factory(data), tree)\n  }\n\n  static async create(data: IAccountData):Promise<Account> {\n    const id = '' + Date.now() + Math.random()\n    const adapter = await AdapterFactory.factory(data)\n    const storage = new NativeAccountStorage(id)\n\n    await storage.setAccountData(data, null)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const tree = new NativeTree(storage)\n    await tree.load()\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new NativeAccount(id, storage, adapter, tree)\n  }\n\n  async init():Promise<void> {\n    console.log('initializing account ' + this.id)\n    await this.storage.initMappings()\n    await this.storage.initCache()\n    const nativeTree = new NativeTree(this.storage)\n    await nativeTree.load()\n    this.localTree = nativeTree\n  }\n\n  async isInitialized():Promise<boolean> {\n    try {\n      return Boolean(NativeAccountStorage.getEntry(`bookmarks[${this.storage.accountId}].mappings`))\n    } catch (e) {\n      console.log('Apparently not initialized, because:', e)\n      return false\n    }\n  }\n\n  async updateFromStorage():Promise<void> {\n    // empty\n  }\n\n  static async stringifyError(er:any):Promise<string> {\n    if (er instanceof UnknownFolderItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof MissingItemOrderError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.item])\n    }\n    if (er instanceof HttpError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.method])\n    }\n    if (er instanceof ParseResponseError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0')) + '\\n' + er.response\n    }\n    if (er instanceof InconsistentBookmarksExistenceError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.folder, er.bookmark])\n    }\n    if (er instanceof LockFileError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.status, er.lockFile])\n    }\n    if (er instanceof FailsafeError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.percent])\n    }\n    if (er instanceof CreateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof UpdateBookmarkError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'), [er.bookmark.inspect()])\n    }\n    if (er instanceof FloccusError) {\n      return i18n.getMessage('Error' + String(er.code).padStart(3, '0'))\n    }\n    if (er.list) {\n      return (await Promise.all(er.list\n        .map((e) => {\n          Logger.log(e)\n          return this.stringifyError(e)\n        })))\n        .join('\\n')\n    }\n    return er.message\n  }\n\n  static async getAllAccounts():Promise<Account[]> {\n    return Promise.all(\n      (await NativeAccountStorage.getAllAccounts()).map((accountId) =>\n        Account.get(accountId)\n      )\n    )\n  }\n}\n","import { Preferences as Storage } from '@capacitor/preferences'\nimport { Bookmark, Folder, ItemLocation, TItemLocation } from '../Tree'\nimport Ordering from '../interfaces/Ordering'\nimport CachingAdapter from '../adapters/Caching'\nimport IAccountStorage from '../interfaces/AccountStorage'\nimport { BulkImportResource } from '../interfaces/Resource'\n\nexport default class NativeTree extends CachingAdapter implements BulkImportResource<typeof ItemLocation.LOCAL> {\n  protected location: TItemLocation = ItemLocation.LOCAL\n\n  private storage: IAccountStorage\n  private readonly accountId: string\n  private saveTimeout: any\n\n  constructor(storage:IAccountStorage) {\n    super({})\n    this.storage = storage\n    this.accountId = this.storage.accountId\n  }\n\n  async load():Promise<boolean> {\n    const {value: tree} = await Storage.get({key: `bookmarks[${this.accountId}].tree`})\n    const {value: highestId} = await Storage.get({key: `bookmarks[${this.accountId}].highestId`})\n    if (tree) {\n      const oldHash = this.bookmarksCache && await this.bookmarksCache.cloneWithLocation(false, this.location).hash(true)\n      this.bookmarksCache = Folder.hydrate(JSON.parse(tree)).clone(false)\n      const newHash = await this.bookmarksCache.hash(true)\n      this.highestId = parseInt(highestId)\n      return oldHash && oldHash !== newHash\n    } else {\n      await this.save()\n      return false\n    }\n  }\n\n  async save():Promise<void> {\n    await Storage.set({key: `bookmarks[${this.accountId}].tree`, value: JSON.stringify(this.bookmarksCache.cloneWithLocation(true, ItemLocation.LOCAL))})\n    await Storage.set({key: `bookmarks[${this.accountId}].highestId`, value: this.highestId + ''})\n  }\n\n  triggerSave():void {\n    clearTimeout(this.saveTimeout)\n    this.saveTimeout = setTimeout(() => {\n      this.save()\n    }, 500)\n  }\n\n  async getBookmarksTree(): Promise<Folder<typeof ItemLocation.LOCAL>> {\n    const tree = await super.getBookmarksTree()\n    tree.createIndex()\n    return tree as Folder<typeof ItemLocation.LOCAL>\n  }\n\n  async createBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    this.triggerSave()\n    return super.createBookmark(bookmark)\n  }\n\n  async updateBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>):Promise<void> {\n    this.triggerSave()\n    return super.updateBookmark(bookmark)\n  }\n\n  async removeBookmark(bookmark:Bookmark<typeof ItemLocation.LOCAL>): Promise<void> {\n    this.triggerSave()\n    return super.removeBookmark(bookmark)\n  }\n\n  async createFolder(folder:Folder<typeof ItemLocation.LOCAL>): Promise<string|number> {\n    this.triggerSave()\n    return super.createFolder(folder)\n  }\n\n  async orderFolder(id:string|number, order:Ordering<typeof ItemLocation.LOCAL>) :Promise<void> {\n    this.triggerSave()\n    return super.orderFolder(id, order)\n  }\n\n  async updateFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    this.triggerSave()\n    return super.updateFolder(folder)\n  }\n\n  async removeFolder(folder:Folder<typeof ItemLocation.LOCAL>):Promise<void> {\n    this.triggerSave()\n    return super.removeFolder(folder)\n  }\n\n  async bulkImportFolder(id: number|string, folder:Folder<typeof ItemLocation.LOCAL>):Promise<Folder<typeof ItemLocation.LOCAL>> {\n    await Promise.all(folder.children.map(async child => {\n      child.parentId = id\n      if (child instanceof Bookmark) {\n        await super.createBookmark(child)\n      }\n      if (child instanceof Folder) {\n        const folderId = await super.createFolder(child)\n        await this.bulkImportFolder(folderId, child)\n      }\n    }))\n    return this.bookmarksCache.findFolder(id) as Folder<typeof ItemLocation.LOCAL>\n  }\n\n  isAvailable(): Promise<boolean> {\n    return Promise.resolve(true)\n  }\n}\n","import Serializer from '../interfaces/Serializer'\nimport { Bookmark, Folder, ItemLocation, TItem } from '../Tree'\nimport * as cheerio from 'cheerio'\n\nclass HtmlSerializer implements Serializer {\n  serialize(folder) {\n    return `<DL><p>\\n${this._serializeFolder(folder, '')}</DL><p>\\n`\n  }\n\n  _htmlentities_encode(string) {\n    return string.replace(/[<>&\"']/g, char => '&#' + char.charCodeAt(0) + ';')\n  }\n\n  _serializeFolder(folder, indent) {\n    return folder.children\n      .map(child => {\n        if (child instanceof Bookmark) {\n          return (\n            `${indent}<DT><A HREF=\"${this._htmlentities_encode(child.url)}\" TAGS=\"${''}\" ID=\"${child.id}\">${this._htmlentities_encode(child.title)}</A>\\n`\n          )\n        } else if (child instanceof Folder) {\n          const nextIndent = indent + '  '\n          return (\n            `${indent}<DT><H3 ID=\"${child.id}\">${this._htmlentities_encode(child.title)}</H3>\\n` +\n            `${indent}<DL><p>\\n${this._serializeFolder(\n              child,\n              nextIndent\n            )}${indent}</DL><p>\\n`\n          )\n        }\n      })\n      .join('')\n  }\n\n  deserialize(html): Folder<typeof ItemLocation.SERVER> {\n    const items: TItem<typeof ItemLocation.SERVER>[] = parseByString(html)\n    items.forEach(f => { f.parentId = '0' })\n    return new Folder({id: '0', title: 'root', children: items, location: ItemLocation.SERVER, isRoot: true})\n  }\n}\n\nexport default new HtmlSerializer()\n\n// The following code is based on https://github.com/hold-baby/bookmark-file-parser\n// Copyright (c) 2019 hold-baby\n// MIT License\n\nexport const getRootFolder = (body: cheerio.Cheerio<cheerio.Element>) => {\n  const h3 = body.find('h3').first()\n\n  const isChrome = typeof h3.attr('personal_toolbar_folder') === 'string'\n\n  if (isChrome) {\n    return body.children('dl').first()\n  }\n\n  const isSafari = typeof h3.attr('folded') === 'string'\n\n  if (isSafari) {\n    return body\n  }\n\n  const isIE = typeof h3.attr('item_id') === 'string'\n\n  if (isIE) {\n    return body.children('dl').first()\n  }\n\n  const isFireFox = h3.text() === 'Mozilla Firefox'\n\n  if (isFireFox) {\n    return body.children('dl').first()\n  }\n\n  return body.children('dl').first()\n}\n\nexport const parseByString = (content: string) => {\n  const $ = cheerio.load(content, {\n    decodeEntities: true\n  })\n\n  const body = $('body')\n  const root: TItem<typeof ItemLocation.SERVER>[] = []\n  const rdt = getRootFolder(body).children('dt')\n\n  const parseNode = (node: cheerio.Cheerio<cheerio.Element>, parentId?: string|number) => {\n    const eq0 = node.children().eq(0)\n    const title = typeof eq0.text() !== 'undefined' ? eq0.text() : ''\n    let url = ''\n    const id = typeof eq0.attr('id') !== 'undefined' ? eq0.attr('id') : ''\n    let children: TItem<typeof ItemLocation.SERVER>[] = []\n\n    switch (eq0[0].name) {\n      case 'h3':\n        // folder\n        const dl = node.children('dl').first()\n        const dts = dl.children()\n\n        const ls = dts.toArray().map((ele) => {\n          if (ele.name !== 'dt') return null\n          return parseNode($(ele), id)\n        })\n        children = ls.filter((item) => item !== null) as TItem<typeof ItemLocation.SERVER>[]\n        return new Folder({id, title, parentId, children, location: ItemLocation.SERVER})\n      case 'a':\n        // site\n        url = eq0.attr('href') || ''\n        return new Bookmark({id, title, url, parentId, location: ItemLocation.SERVER})\n    }\n    throw new Error('Failed to parse')\n  }\n\n  rdt.each((_, item) => {\n    const node = $(item)\n    const child = parseNode(node)\n    root.push(child)\n  })\n\n  return root\n}\n","import Serializer from '../interfaces/Serializer'\nimport { Bookmark, Folder, ItemLocation } from '../Tree'\nimport { XMLParser, XMLBuilder } from 'fast-xml-parser'\n\nclass XbelSerializer implements Serializer {\n  serialize(folder: Folder<typeof ItemLocation.SERVER>) {\n    const xbelObj = this._serializeFolder(folder)\n    const xmlBuilder = new XMLBuilder({format: true, preserveOrder: true, ignoreAttributes: false})\n    return xmlBuilder.build(xbelObj)\n  }\n\n  deserialize(xbel: string) {\n    const parser = new XMLParser({\n      preserveOrder: true,\n      ignorePiTags: true,\n      ignoreAttributes: false,\n      parseTagValue: true,\n    })\n    const xmlObj = parser.parse(xbel)\n\n    if (!Array.isArray(xmlObj[0].xbel)) {\n      throw new Error(\n        'Parse Error: ' + xbel\n      )\n    }\n\n    const rootFolder = new Folder({ id: 0, title: 'root', location: ItemLocation.SERVER })\n    try {\n      this._parseFolder(xmlObj[0].xbel, rootFolder)\n    } catch (e) {\n      throw new Error(\n        'Parse Error: ' + e.message\n      )\n    }\n    return rootFolder\n  }\n\n  _parseFolder(xbelObj, folder: Folder<typeof ItemLocation.SERVER>) {\n    /* parse depth first */\n\n    xbelObj\n      .forEach(node => {\n        let item\n        if (typeof node.bookmark !== 'undefined') {\n          item = new Bookmark({\n            id: parseInt(node[':@']['@_id']),\n            parentId: folder.id,\n            url: node[':@']['@_href'],\n            title: '' + (typeof node.bookmark?.[0]?.title?.[0]?.['#text'] !== 'undefined' ? node.bookmark?.[0]?.title?.[0]?.['#text'] : ''), // cast to string\n            location: ItemLocation.SERVER,\n          })\n        } else if (typeof node.folder !== 'undefined') {\n          item = new Folder({\n            id: parseInt(node[':@']?.['@_id']),\n            title: '' + (typeof node.folder?.[0]?.title?.[0]?.['#text'] !== 'undefined' ? node.folder?.[0]?.title?.[0]?.['#text'] : ''), // cast to string\n            parentId: folder.id,\n            location: ItemLocation.SERVER,\n          })\n          this._parseFolder(node.folder, item)\n        } else {\n          return\n        }\n\n        folder.children.push(item)\n      })\n  }\n\n  _serializeFolder(folder: Folder<typeof ItemLocation.SERVER>) {\n    return folder.children\n      .map(child => {\n        if (child instanceof Bookmark) {\n          return {\n            bookmark: [\n              {title: [{'#text': child.title}]}\n            ],\n            ':@': {\n              '@_href': child.url,\n              '@_id': String(child.id)\n            }\n          }\n        }\n\n        if (child instanceof Folder) {\n          return {\n            folder: [\n              {title: [{'#text': child.title}]},\n              ...this._serializeFolder(child)\n            ],\n            ':@': {\n              ...('id' in child && {'@_id': String(child.id)}),\n            }\n          }\n        }\n      })\n  }\n}\n\nexport default new XbelSerializer()\n","import {\n  Bookmark,\n  Folder,\n  TItem,\n  ItemType,\n  ItemLocation,\n  TItemLocation,\n  TOppositeLocation,\n} from '../Tree'\nimport Logger from '../Logger'\nimport Diff, {\n  ActionType,\n  CreateAction,\n  MoveAction,\n  PlanStage1, PlanStage2, PlanStage3,\n  RemoveAction,\n  ReorderAction,\n  UpdateAction\n} from '../Diff'\nimport Scanner, { ScanResult } from '../Scanner'\nimport * as Parallel from 'async-parallel'\nimport { throttle } from 'throttle-debounce'\nimport Mappings, { MappingSnapshot } from '../Mappings'\nimport TResource, { OrderFolderResource, TLocalTree } from '../interfaces/Resource'\nimport { TAdapter } from '../interfaces/Adapter'\nimport { CancelledSyncError, FailsafeError } from '../../errors/Error'\n\nimport NextcloudBookmarksAdapter from '../adapters/NextcloudBookmarks'\nimport CachingAdapter from '../adapters/Caching'\n\nconst ACTION_CONCURRENCY = 12\n\nexport default class SyncProcess {\n  protected mappings: Mappings\n  protected localTree: TLocalTree\n  protected server: TAdapter\n  protected cacheTreeRoot: Folder<typeof ItemLocation.LOCAL>|null\n  protected canceled: boolean\n  protected preserveOrder: boolean\n  protected progressCb: (progress:number, actionsDone?:number)=>void\n\n  // Stage -1\n  protected localTreeRoot: Folder<typeof ItemLocation.LOCAL> = null\n  protected serverTreeRoot: Folder<typeof ItemLocation.SERVER> = null\n\n  // Stage 0\n  protected localScanResult: ScanResult<typeof ItemLocation.LOCAL, TItemLocation> = null\n  protected serverScanResult: ScanResult<typeof ItemLocation.SERVER, TItemLocation> = null\n\n  // Stage 1\n  private localPlanStage1: PlanStage1<typeof ItemLocation.SERVER, TItemLocation>\n  private serverPlanStage1: PlanStage1<typeof ItemLocation.LOCAL, TItemLocation>\n\n  // Stage 2\n  private localPlanStage2: PlanStage2<typeof ItemLocation.SERVER, TItemLocation, typeof ItemLocation.LOCAL>\n  private serverPlanStage2: PlanStage2<typeof ItemLocation.LOCAL, TItemLocation, typeof ItemLocation.SERVER>\n\n  // Stage 3\n  private localDonePlan: PlanStage3<typeof ItemLocation.SERVER, TItemLocation, typeof ItemLocation.LOCAL>\n  private serverDonePlan: PlanStage3<typeof ItemLocation.LOCAL, TItemLocation, typeof ItemLocation.SERVER>\n  private localReorders: Diff<typeof ItemLocation.SERVER, TItemLocation, ReorderAction<typeof ItemLocation.SERVER, TItemLocation>>\n  private serverReorders: Diff<typeof ItemLocation.LOCAL, TItemLocation, ReorderAction<typeof ItemLocation.LOCAL, TItemLocation>>\n\n  // Stage 4\n  private localReordersFinal: Diff<typeof ItemLocation.LOCAL, TItemLocation, ReorderAction<typeof ItemLocation.LOCAL, TItemLocation>>\n  private serverReorderFinal: Diff<typeof ItemLocation.SERVER, TItemLocation, ReorderAction<typeof ItemLocation.SERVER, TItemLocation>>\n\n  protected actionsDone = 0\n  protected actionsPlanned = 0\n\n  protected isFirefox: boolean\n\n  protected staticContinuation: any = null\n\n  // The location that has precedence in case of conflicts\n  protected masterLocation: TItemLocation\n\n  constructor(\n    mappings:Mappings,\n    localTree:TLocalTree,\n    server:TAdapter,\n    progressCb:(progress:number, actionsDone?:number)=>void\n  ) {\n    this.mappings = mappings\n    this.localTree = localTree\n    this.server = server\n\n    this.preserveOrder = 'orderFolder' in this.server\n\n    this.progressCb = throttle(500, true, progressCb) as (progress:number, actionsDone?:number)=>void\n    this.canceled = false\n    this.isFirefox = self.location.protocol === 'moz-extension:'\n  }\n\n  getMembersToPersist() {\n    return [\n      // Stage 0\n      'localScanResult',\n      'serverScanResult',\n\n      // Stage 1\n      'localPlanStage1',\n      'serverPlanStage1',\n\n      // Stage 2\n      'localPlanStage2',\n      'serverPlanStage2',\n\n      // Stage 3\n      'localDonePlan',\n      'serverDonePlan',\n      'localReorders',\n      'serverReorders',\n\n      // Stage 4\n      'localReorderPlan',\n      'serverReorderPlan',\n    ]\n  }\n\n  getMappingsInstance(): Mappings {\n    return this.mappings\n  }\n\n  setCacheTree(cacheTree: Folder<typeof ItemLocation.LOCAL>) {\n    this.cacheTreeRoot = cacheTree\n  }\n\n  public getTargetTree<L1 extends TItemLocation>(targetLocation: L1): Folder<L1> {\n    return (targetLocation === ItemLocation.SERVER ? this.serverTreeRoot : this.localTreeRoot) as Folder<L1>\n  }\n\n  async cancel() :Promise<void> {\n    this.canceled = true\n    this.server.cancel()\n  }\n\n  updateProgress():void {\n    if (typeof this.actionsDone === 'undefined') {\n      this.actionsDone = 0\n    }\n    this.actionsDone++\n    this.progressCb(\n      Math.min(\n        1,\n        0.5 + (this.actionsDone / (this.actionsPlanned + 1)) * 0.5\n      ),\n      this.actionsDone\n    )\n    Logger.log(`Executed ${this.actionsDone} actions from ${this.actionsPlanned} actions`)\n  }\n\n  setProgress({actionsDone, actionsPlanned}: {actionsDone: number, actionsPlanned: number}) {\n    this.actionsDone = actionsDone\n    this.actionsPlanned = actionsPlanned\n    this.progressCb(\n      Math.min(\n        1,\n        0.5 + (this.actionsDone / (this.actionsPlanned + 1)) * 0.5\n      ),\n      this.actionsDone\n    )\n  }\n\n  setDirection(direction:TItemLocation):void {\n    throw new Error('Unsupported method')\n  }\n\n  async sync(): Promise<void> {\n    // onSyncStart is already executed at this point\n    this.progressCb(0.15)\n\n    this.masterLocation = ItemLocation.LOCAL\n    await this.prepareSync()\n\n    // trees are loaded at this point\n    this.progressCb(0.35)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log({localTreeRoot: this.localTreeRoot, serverTreeRoot: this.serverTreeRoot, cacheTreeRoot: this.cacheTreeRoot})\n\n    if (!this.localScanResult && !this.serverScanResult) {\n      const { localScanResult, serverScanResult } = await this.getDiffs()\n      Logger.log({ localScanResult, serverScanResult })\n      this.localScanResult = localScanResult\n      this.serverScanResult = serverScanResult\n      this.progressCb(0.45)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.serverPlanStage1) {\n      this.serverPlanStage1 = await this.reconcileDiffs(this.localScanResult, this.serverScanResult, ItemLocation.SERVER)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.localPlanStage1) {\n      this.localPlanStage1 = await this.reconcileDiffs(this.serverScanResult, this.localScanResult, ItemLocation.LOCAL)\n    }\n\n    let mappingsSnapshot: MappingSnapshot\n\n    if (!this.serverPlanStage2) {\n      // have to get snapshot after reconciliation, because of concurrent creation reconciliation\n      mappingsSnapshot = this.mappings.getSnapshot()\n      Logger.log('Mapping server plan')\n\n      this.serverPlanStage2 = {\n        CREATE: this.serverPlanStage1.CREATE.map(mappingsSnapshot, ItemLocation.SERVER),\n        UPDATE: this.serverPlanStage1.UPDATE.map(mappingsSnapshot, ItemLocation.SERVER),\n        MOVE: this.serverPlanStage1.MOVE,\n        REMOVE: this.serverPlanStage1.REMOVE.map(mappingsSnapshot, ItemLocation.SERVER),\n        REORDER: this.serverPlanStage1.REORDER,\n      }\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.localPlanStage2) {\n      // have to get snapshot after reconciliation, because of concurrent creation reconciliation\n      if (!mappingsSnapshot) mappingsSnapshot = this.mappings.getSnapshot()\n      Logger.log('Mapping local plan')\n\n      this.localPlanStage2 = {\n        CREATE: this.localPlanStage1.CREATE.map(mappingsSnapshot, ItemLocation.LOCAL),\n        UPDATE: this.localPlanStage1.UPDATE.map(mappingsSnapshot, ItemLocation.LOCAL),\n        MOVE: this.localPlanStage1.MOVE,\n        REMOVE: this.localPlanStage1.REMOVE.map(mappingsSnapshot, ItemLocation.LOCAL),\n        REORDER: this.localPlanStage1.REORDER,\n      }\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log({localPlan: this.localPlanStage2, serverPlan: this.serverPlanStage2})\n\n    this.applyFailsafe(this.localPlanStage2.REMOVE)\n\n    if (!this.localDonePlan) {\n      this.localDonePlan = {\n        CREATE: new Diff(),\n        UPDATE: new Diff(),\n        MOVE: new Diff(),\n        REMOVE: new Diff(),\n        REORDER: new Diff(),\n      }\n\n      this.serverDonePlan = {\n        CREATE: new Diff(),\n        UPDATE: new Diff(),\n        MOVE: new Diff(),\n        REMOVE: new Diff(),\n        REORDER: new Diff(),\n      }\n    }\n\n    if (!this.localReorders) {\n      this.localReorders = this.localPlanStage2.REORDER\n      this.serverReorders = this.serverPlanStage2.REORDER\n    }\n\n    if (!this.actionsPlanned) {\n      this.actionsPlanned = Object.values(this.serverPlanStage2).reduce((acc, diff) => diff.getActions().length + acc, 0) +\n        Object.values(this.localPlanStage2).reduce((acc, diff) => diff.getActions().length + acc, 0)\n    }\n\n    Logger.log('Executing server plan')\n    await this.execute(this.server, this.serverPlanStage2, ItemLocation.SERVER, this.serverDonePlan, this.serverReorders)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log('Executing local plan')\n    await this.execute(this.localTree, this.localPlanStage2, ItemLocation.LOCAL, this.localDonePlan, this.localReorders)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if ('orderFolder' in this.server && !this.localReordersFinal) {\n      // mappings have been updated, reload\n      mappingsSnapshot = this.mappings.getSnapshot()\n      this.localReordersFinal = this.reconcileReorderings(this.localReorders, this.serverDonePlan, ItemLocation.LOCAL, mappingsSnapshot)\n      this.serverReorderFinal = this.reconcileReorderings(this.serverReorders, this.localDonePlan, ItemLocation.SERVER, mappingsSnapshot)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if ('orderFolder' in this.server) {\n      Logger.log('Executing reorderings')\n      await Promise.all([\n        this.executeReorderings(this.server, this.serverReorderFinal),\n        this.executeReorderings(this.localTree, this.localReordersFinal),\n      ])\n    }\n  }\n\n  protected async prepareSync() {\n    if (!this.localTreeRoot) {\n      Logger.log('Retrieving local tree')\n      const localTreeRoot = await this.localTree.getBookmarksTree()\n      Logger.log('Filtering out unaccepted local bookmarks')\n      this.filterOutUnacceptedBookmarks(localTreeRoot)\n      if (this.server instanceof NextcloudBookmarksAdapter) {\n        Logger.log('Filtering out duplicate bookmarks')\n        await this.filterOutDuplicatesInTheSameFolder(localTreeRoot)\n      }\n      this.localTreeRoot = localTreeRoot\n    }\n\n    // Cache tree might not have been initialized and thus have no id\n    this.cacheTreeRoot.id = this.localTreeRoot.id\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    if (!this.serverTreeRoot) {\n      Logger.log('Retrieving server tree')\n      const serverTreeRoot = await this.server.getBookmarksTree()\n      Logger.log('Filtering out invalid server bookmarks')\n      this.filterOutInvalidBookmarks(serverTreeRoot)\n\n      if (this.canceled) {\n        throw new CancelledSyncError()\n      }\n\n      await this.mappings.addFolder({ localId: this.localTreeRoot.id, remoteId: serverTreeRoot.id })\n      const mappingsSnapshot = this.mappings.getSnapshot()\n\n      if ('loadFolderChildren' in this.server) {\n        Logger.log('Loading sparse tree as necessary')\n        // Load sparse tree\n        await this.loadChildren(serverTreeRoot, mappingsSnapshot, true)\n      }\n      this.serverTreeRoot = serverTreeRoot\n    }\n\n    // generate hash tables to find items faster\n    Logger.log('Generating indices for local tree')\n    this.localTreeRoot.createIndex()\n    Logger.log('Generating indices for cache tree')\n    this.cacheTreeRoot.createIndex()\n    Logger.log('Generating indices for server tree')\n    this.serverTreeRoot.createIndex()\n  }\n\n  protected applyFailsafe(removals: Diff<TItemLocation, TItemLocation, RemoveAction<TItemLocation, TItemLocation>>) {\n    const localCountTotal = this.localTreeRoot.count()\n    const localCountDeleted = removals.getActions().reduce((count, action) => count + action.payload.count(), 0)\n\n    Logger.log('Checking failsafe: ' + localCountDeleted + '/' + localCountTotal + '=' + (localCountDeleted / localCountTotal))\n    if (localCountTotal > 5 && localCountDeleted / localCountTotal > 0.5) {\n      const failsafe = this.server.getData().failsafe\n      if (failsafe !== false || typeof failsafe === 'undefined') {\n        throw new FailsafeError(Math.ceil((localCountDeleted / localCountTotal) * 100))\n      }\n    }\n  }\n\n  filterOutUnacceptedBookmarks(tree: Folder<TItemLocation>): void {\n    tree.children = tree.children.filter(child => {\n      if (child instanceof Bookmark) {\n        return this.server.acceptsBookmark(child)\n      } else {\n        this.filterOutUnacceptedBookmarks(child)\n        return true\n      }\n    })\n  }\n\n  filterOutInvalidBookmarks(tree: Folder<TItemLocation>): void {\n    tree.children = tree.children.filter(child => {\n      if (child instanceof Bookmark) {\n        // Chrome URLs cannot be added in firefox\n        if (this.isFirefox && child.url.startsWith('chrome')) {\n          return false\n        }\n        // Linkwarden supports bookmarks that have no URL eg. for directly uploaded files\n        if (child.url === null) {\n          return false\n        }\n      } else {\n        this.filterOutInvalidBookmarks(child)\n      }\n      return true\n    })\n  }\n\n  async filterOutDuplicatesInTheSameFolder(tree: Folder<TItemLocation>): Promise<void> {\n    const seenUrl = {}\n    const duplicates = []\n    tree.children = tree.children.filter(child => {\n      if (child.type === ItemType.BOOKMARK) {\n        if (seenUrl[child.url]) {\n          duplicates.push(child)\n          return false\n        }\n        seenUrl[child.url] = child\n      } else {\n        this.filterOutDuplicatesInTheSameFolder(child)\n      }\n      return true\n    })\n    duplicates.length &&\n      Logger.log(\n        'Filtered out the following duplicates before syncing',\n        duplicates\n      )\n  }\n\n  async getDiffs():Promise<{localScanResult:ScanResult<typeof ItemLocation.LOCAL, TItemLocation>, serverScanResult:ScanResult<typeof ItemLocation.SERVER, TItemLocation>}> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const newMappings = []\n\n    let localScanner, serverScanner\n    if (this.localTree.constructor.name === 'LocalTabs') {\n      // if we have the cache available, Diff cache and both trees\n      localScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.localTreeRoot,\n        // We also allow canMergeWith for folders here, because Window IDs are not stable\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            return true\n          }\n          if (oldItem.type === 'folder' && oldItem.canMergeWith(newItem)) {\n            return true\n          }\n          return false\n        },\n        this.preserveOrder,\n      )\n      serverScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.serverTreeRoot,\n        // We also allow canMergeWith here\n        // (for bookmarks, because e.g. for NextcloudFolders the id of moved bookmarks changes (because their id is \"<bookmarkID>;<folderId>\")\n        // (for folders because Window IDs are not stable)\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            newMappings.push([oldItem, newItem])\n            return true\n          }\n          if (oldItem.canMergeWith(newItem)) {\n            newMappings.push([oldItem, newItem])\n            return true\n          }\n          return false\n        },\n        this.preserveOrder,\n      )\n    } else {\n      // if we have the cache available, Diff cache and both trees\n      localScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.localTreeRoot,\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            return true\n          }\n          return false\n        },\n        this.preserveOrder\n      )\n      serverScanner = new Scanner(\n        this.cacheTreeRoot,\n        this.serverTreeRoot,\n        // We also allow canMergeWith here, because e.g. for NextcloudBookmarks the id of moved bookmarks changes (because their id is \"<bookmarkID>;<folderId>\")\n        (oldItem, newItem) => {\n          if (oldItem.type !== newItem.type) {\n            return false\n          }\n          // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark' && oldItem.url !== newItem.url) {\n            return false\n          }\n          if (Mappings.mappable(mappingsSnapshot, oldItem, newItem)) {\n            newMappings.push([oldItem, newItem])\n            return true\n          }\n          if (oldItem.type === 'bookmark' && newItem.type === 'bookmark') {\n            if (oldItem.canMergeWith(newItem)) {\n              newMappings.push([oldItem, newItem])\n              return true\n            }\n          }\n          return false\n        },\n        this.preserveOrder\n      )\n    }\n    Logger.log('Calculating diffs for local and server trees relative to cache tree')\n    const localScanResult = await localScanner.run()\n    const serverScanResult = await serverScanner.run()\n    await Parallel.map(newMappings, ([localItem, serverItem]) => this.addMapping(this.server, localItem, serverItem.id), 10)\n    return {localScanResult, serverScanResult}\n  }\n\n  async reconcileDiffs<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation>(\n    sourceScanResult:ScanResult<L1, L2>,\n    targetScanResult:ScanResult<TOppositeLocation<L1>, L3>,\n    targetLocation: TOppositeLocation<L1>\n  ): Promise<PlanStage1<L1, L2>> {\n    Logger.log('Reconciling diffs to prepare a plan for ' + targetLocation)\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const targetCreations = targetScanResult.CREATE.getActions()\n    const targetRemovals = targetScanResult.REMOVE.getActions()\n    const targetMoves = targetScanResult.MOVE.getActions()\n    const targetUpdates = targetScanResult.UPDATE.getActions()\n    const targetReorders = targetScanResult.REORDER.getActions()\n\n    const sourceCreations = sourceScanResult.CREATE.getActions()\n    const sourceRemovals = sourceScanResult.REMOVE.getActions()\n    const sourceMoves = sourceScanResult.MOVE.getActions()\n\n    const targetTree : Folder<TOppositeLocation<L1>> = (targetLocation === ItemLocation.LOCAL ? this.localTreeRoot : this.serverTreeRoot) as Folder<TOppositeLocation<L1>>\n    const sourceTree : Folder<L1> = (targetLocation === ItemLocation.LOCAL ? this.serverTreeRoot : this.localTreeRoot) as Folder<L1>\n\n    const allCreateAndMoveActions = (sourceScanResult.CREATE.getActions() as Array<CreateAction<L1, L2> | MoveAction<L1, L2> | CreateAction<TOppositeLocation<L1>, L3> | MoveAction<TOppositeLocation<L1>, L3>>)\n      .concat(sourceScanResult.MOVE.getActions())\n      .concat(targetScanResult.CREATE.getActions())\n      .concat(targetScanResult.MOVE.getActions())\n\n    const avoidTargetReorders = {}\n\n    // Prepare target plan\n    const targetPlan: PlanStage1<L1, L2> = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n\n    await Parallel.each(sourceScanResult.REMOVE.getActions(), async(action) => {\n      const concurrentRemoval = targetRemovals.find(targetRemoval =>\n        (action.payload.type === targetRemoval.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, targetRemoval.payload)) ||\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, action.payload, targetRemoval))\n      if (concurrentRemoval) {\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      const concurrentMove = targetMoves.find(targetMove =>\n        action.payload.type === targetMove.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, targetMove.payload)\n      )\n      if (concurrentMove && targetLocation === this.masterLocation) {\n        // moved on the target, moves from master take precedence, do nothing (i.e. leave target version intact)\n        return\n      }\n\n      targetPlan.REMOVE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.CREATE.getActions(), async(action) => {\n      const concurrentCreation = targetCreations.find(a => (\n        action.payload.parentId === Mappings.mapParentId(mappingsSnapshot, a.payload, action.payload.location) &&\n        action.payload.canMergeWith(a.payload)\n      ))\n      if (concurrentCreation) {\n        // created on both the target and sourcely, try to reconcile\n        const newMappings = []\n        const subScanner = new Scanner(\n          concurrentCreation.payload, // target tree\n          action.payload, // source tree\n          (oldItem, newItem) => {\n            if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n              // if two items can be merged, we'll add mappings here directly\n              newMappings.push([oldItem, newItem.id])\n              return true\n            }\n            return false\n          },\n          this.preserveOrder,\n          false\n        )\n        await subScanner.run()\n        newMappings.push([concurrentCreation.payload, action.payload.id])\n        await Parallel.each(newMappings, async([oldItem, newId]) => {\n          await this.addMapping(action.payload.location === ItemLocation.LOCAL ? this.localTree : this.server, oldItem, newId)\n        },1)\n        // TODO: subScanner may contain residual CREATE/REMOVE actions that need to be added to mappings\n        return\n      }\n      const concurrentRemoval = targetScanResult.REMOVE.getActions().find(targetRemoval =>\n        // target removal removed this creation's target (via some chain)\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetRemoval)\n      )\n      if (concurrentRemoval) {\n        avoidTargetReorders[action.payload.parentId] = true\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      targetPlan.CREATE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.MOVE.getActions(), async(action) => {\n      if (targetLocation === this.masterLocation) {\n        const concurrentMove = targetMoves.find(a =>\n          action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n        if (concurrentMove) {\n          // Moved both on target and sourcely, source has precedence: do nothing sourcely\n          return\n        }\n      }\n      // FInd out if there's a removal in the target diff which already deletes this item (via some chain of MOVE|CREATEs)\n      const complexTargetTargetRemoval = targetRemovals.find(targetRemoval => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetRemoval)\n      })\n      const concurrentTargetOriginRemoval = targetRemovals.find(targetRemoval =>\n        (action.payload.type === targetRemoval.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, targetRemoval.payload)) ||\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.oldItem, targetRemoval)\n      )\n      const concurrentSourceOriginRemoval = sourceRemovals.find(sourceRemoval => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, action.oldItem, sourceRemoval)\n      })\n      const concurrentSourceTargetRemoval = sourceRemovals.find(sourceRemoval =>\n        // We pass an empty folder here, because we don't want direct deletions of the moved folder's parent to count, as it's moved away anyway\n        Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, new Folder({id: 0, location: targetLocation}), action.payload, sourceRemoval)\n      )\n      if (complexTargetTargetRemoval) {\n        // target already deleted by a target|source REMOVE (connected via source MOVE|CREATEs)\n        if (!concurrentTargetOriginRemoval && !concurrentSourceOriginRemoval) {\n          // make sure this item is not already being removed, when it's no longer moved\n          // if (targetLocation === this.masterLocation) {\n          targetPlan.REMOVE.commit({ type: ActionType.REMOVE, payload: action.oldItem, oldItem: null })\n          SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.oldItem)\n          avoidTargetReorders[action.payload.id] = true\n          // }\n        }\n        return\n      }\n      if (concurrentSourceTargetRemoval) {\n        // target already deleted by a source REMOVE (connected via source MOVE|CREATEs)\n        if (targetLocation !== this.masterLocation) {\n          targetPlan.REMOVE.commit({ type: ActionType.REMOVE, payload: action.oldItem, oldItem: null })\n        }\n        SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.oldItem)\n        avoidTargetReorders[action.payload.id] = true\n        return\n      }\n      if (concurrentTargetOriginRemoval) {\n        // moved sourcely but removed on the target, recreate it on the target\n        if (targetLocation !== this.masterLocation) {\n          // only when coming from master do we recreate\n          const originalCreation = sourceCreations.find(creation => creation.payload.findItem(ItemType.FOLDER, action.payload.parentId))\n\n          // Remove subitems that have been (re)moved already by other actions\n          const newPayload = action.payload.clone()\n          if (newPayload.type === ItemType.FOLDER) {\n            newPayload.traverse((item, folder) => {\n              const removed = sourceRemovals.find(a => Mappings.mappable(mappingsSnapshot, item, a.payload))\n              const movedAway = sourceMoves.find(a => Mappings.mappable(mappingsSnapshot, item, a.payload))\n              if (removed || (movedAway && Mappings.mapParentId(mappingsSnapshot, movedAway.payload, item.location) !== item.parentId)) {\n                folder.children.splice(folder.children.indexOf(item), 1)\n              }\n            })\n          }\n\n          if (originalCreation && originalCreation.payload.type === ItemType.FOLDER) {\n            // in case the new parent is already a newly created item, merge it into that creation\n            const folder = originalCreation.payload.findFolder(action.payload.parentId)\n            folder.children.splice(action.index, 0, newPayload)\n          } else {\n            targetPlan.CREATE.commit({ type: ActionType.CREATE, oldItem: null, payload: newPayload })\n          }\n        }\n        return\n      }\n      // Find concurrent moves that form a hierarchy reversal together with this one\n      const concurrentHierarchyReversals = targetMoves.filter(targetMove => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetMove) &&\n          Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, targetMove.payload, action)\n      })\n      if (concurrentHierarchyReversals.length) {\n        if (targetLocation !== this.masterLocation) {\n          targetPlan.MOVE.commit(action)\n\n          concurrentHierarchyReversals.forEach(a => {\n            // moved sourcely but moved in reverse hierarchical order on target\n            const payload = a.oldItem.cloneWithLocation(false, action.payload.location)\n            const oldItem = a.payload.cloneWithLocation(false, action.oldItem.location)\n            oldItem.id = Mappings.mapId(mappingsSnapshot, a.payload, action.oldItem.location)\n            oldItem.parentId = Mappings.mapParentId(mappingsSnapshot, a.payload, action.oldItem.location)\n\n            if (\n              // Don't create duplicates!\n              targetPlan.MOVE.getActions().find(move => String(move.payload.id) === String(payload.id)) ||\n              sourceMoves.find(move => String(move.payload.id) === String(payload.id)) ||\n              // Don't move back into removed territory\n              targetRemovals.find(remove => Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, remove)) ||\n              sourceRemovals.find(remove => Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, action.payload, remove))\n            ) {\n              return\n            }\n\n            // revert target move\n            targetPlan.MOVE.commit({ ...a, payload, oldItem })\n            SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, payload)\n            SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, oldItem)\n          })\n        } else {\n          SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.oldItem)\n          SyncProcess.removeItemFromReorders(mappingsSnapshot, sourceScanResult.REORDER, action.payload)\n        }\n        return\n      }\n\n      targetPlan.MOVE.commit(action)\n    }, 1)\n\n    await Parallel.each(sourceScanResult.UPDATE.getActions(), async(action) => {\n      const concurrentUpdate = targetUpdates.find(a =>\n        action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n      if (concurrentUpdate && targetLocation === this.masterLocation) {\n        // Updated both on target and sourcely, source has precedence: do nothing sourcely\n        return\n      }\n      const concurrentRemoval = targetRemovals.find(a =>\n        a.payload.findItem(action.payload.type, Mappings.mapId(mappingsSnapshot, action.payload, a.payload.location)) ||\n        a.payload.findItem(ItemType.FOLDER, Mappings.mapParentId(mappingsSnapshot, action.payload, a.payload.location)))\n      if (concurrentRemoval) {\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      targetPlan.UPDATE.commit(action)\n    })\n\n    await Parallel.each(sourceScanResult.REORDER.getActions(), async(action) => {\n      if (avoidTargetReorders[action.payload.id]) {\n        return\n      }\n\n      if (targetLocation === this.masterLocation) {\n        const concurrentReorder = targetReorders.find(a =>\n          action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n        if (concurrentReorder) {\n          return\n        }\n      }\n\n      const concurrentRemoval = targetRemovals.find(a =>\n        a.payload.findItem('folder', action.payload.id))\n      if (concurrentRemoval) {\n        // Already deleted on target, do nothing.\n        return\n      }\n\n      targetPlan.REORDER.commit(action)\n    })\n\n    return targetPlan\n  }\n\n  async execute<L1 extends TItemLocation>(\n    resource:TResource<L1>,\n    planStage2:PlanStage2<TOppositeLocation<L1>, TItemLocation, L1>,\n    targetLocation:L1,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>,\n    reorders: Diff<TOppositeLocation<L1>, TItemLocation, ReorderAction<TOppositeLocation<L1>, TItemLocation>>): Promise<void> {\n    Logger.log('Executing ' + targetLocation + ' plan for ')\n\n    let createActions = planStage2.CREATE.getActions()\n    while (createActions.length > 0) {\n      Logger.log(targetLocation + ': executing CREATEs')\n      await Parallel.each(\n        createActions,\n        (action) => this.executeCreate(resource, action, targetLocation, planStage2.CREATE, reorders, donePlan),\n        ACTION_CONCURRENCY\n      )\n      createActions = planStage2.CREATE.getActions()\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing CREATEs')\n\n    await Parallel.each(\n      planStage2.UPDATE.getActions(),\n      (action) => this.executeUpdate(resource, action, targetLocation, planStage2.UPDATE, donePlan),\n      ACTION_CONCURRENCY\n    )\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const mappingsSnapshot = this.mappings.getSnapshot()\n    Logger.log(targetLocation + ': mapping MOVEs')\n\n    const planStage3: PlanStage3<TOppositeLocation<L1>, TItemLocation, typeof targetLocation> = {\n      CREATE: planStage2.CREATE,\n      UPDATE: planStage2.UPDATE,\n      MOVE: planStage2.MOVE.map(mappingsSnapshot, targetLocation),\n      REMOVE: planStage2.REMOVE,\n      REORDER: planStage2.REORDER,\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const batches = Diff.sortMoves(planStage3.MOVE.getActions(), this.getTargetTree(targetLocation))\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing MOVEs')\n    await Parallel.each(batches, batch => Parallel.each(batch, (action) => {\n      return this.executeUpdate(resource, action, targetLocation, planStage3.MOVE, donePlan)\n    }, ACTION_CONCURRENCY), 1)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing REMOVEs')\n    await Parallel.each(planStage3.REMOVE.getActions(), (action) => {\n      return this.executeRemove(resource, action, targetLocation, planStage3.REMOVE, donePlan)\n    }, ACTION_CONCURRENCY)\n  }\n\n  async executeCreate<L1 extends TItemLocation>(\n    resource: TResource<L1>,\n    action: CreateAction<L1, TOppositeLocation<L1>>,\n    targetLocation: L1,\n    diff: Diff<L1, TOppositeLocation<L1>, CreateAction<L1, TOppositeLocation<L1>>>,\n    reorders: Diff<TOppositeLocation<L1>, TItemLocation, ReorderAction<TOppositeLocation<L1>, TItemLocation>>,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>\n  ): Promise<void> {\n    // defer execution of actions to allow the this.canceled check below to work when cancelling in interrupt tests\n    await Promise.resolve()\n    Logger.log('Executing action ', action)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const done = () => {\n      diff.retract(action)\n      donePlan.CREATE.commit(action)\n      this.updateProgress()\n    }\n\n    const id = await action.payload.visitCreate(resource)\n    if (typeof id === 'undefined') {\n      // undefined means we couldn't create the item. we're ignoring it\n      done()\n      return\n    }\n\n    action.payload.id = id\n\n    if (action.oldItem) {\n      await this.addMapping(resource, action.oldItem, id)\n    }\n\n    if (action.payload instanceof Folder && !(action.oldItem instanceof Folder)) {\n      throw new Error('Assertion failed: action.oldItem should be set')\n    }\n\n    if (action.payload instanceof Folder && action.payload.children.length && action.oldItem instanceof Folder) {\n      // Fix for Unidirectional reverted REMOVEs, for all other strategies this should be a noop\n      action.payload.children.forEach((item) => {\n        item.parentId = id\n      })\n      // We *know* that oldItem exists here, because actions are mapped before being executed\n      if ('bulkImportFolder' in resource) {\n        if (action.payload.count() < 75 || this.server instanceof CachingAdapter) {\n          Logger.log('Attempting full bulk import')\n          try {\n            // Try bulk import with sub folders\n            const imported = await resource.bulkImportFolder(id, action.oldItem.cloneWithLocation(false, action.payload.location)) as Folder<typeof targetLocation>\n            const newMappings = []\n            const subScanner = new Scanner(\n              action.oldItem,\n              imported,\n              (oldItem, newItem) => {\n                if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n                  // if two items can be merged, we'll add mappings here directly\n                  newMappings.push([oldItem, newItem.id])\n                  return true\n                }\n                return false\n              },\n              this.preserveOrder,\n              false,\n            )\n            await subScanner.run()\n            await Parallel.each(newMappings, async([oldItem, newId]: [TItem<TItemLocation>, string|number]) => {\n              await this.addMapping(resource, oldItem, newId)\n            }, 10)\n\n            if ('orderFolder' in resource) {\n              const mappingsSnapshot = this.mappings.getSnapshot()\n              this.actionsPlanned++\n              reorders.commit({\n                type: ActionType.REORDER,\n                oldItem: imported,\n                payload: action.oldItem,\n                // payload children's IDs are not mapped\n                order: action.oldItem.children.map(i => ({ type: i.type, id: i.id }))\n              })\n              await action.oldItem.traverse((oldChildItem) => {\n                if (oldChildItem instanceof Folder && oldChildItem.children.length > 1) {\n                  // Correct the order after bulk import. Usually we expect bulk import to do the order correctly\n                  // on its own, but Nextcloud Bookmarks pre v14.2.0 does not\n                  const payload = imported.findFolder(Mappings.mapId(mappingsSnapshot, oldChildItem, targetLocation))\n                  // Order created items after the fact, as they've been created concurrently\n                  this.actionsPlanned++\n                  reorders.commit({\n                    type: ActionType.REORDER,\n                    oldItem: payload,\n                    payload: oldChildItem,\n                    order: oldChildItem.children.map(i => ({ type: i.type, id: i.id }))\n                  })\n                }\n              })\n            }\n\n            done()\n            return\n          } catch (e) {\n            Logger.log('Bulk import failed, continuing with normal creation', e)\n          }\n        } else {\n          try {\n            // Try bulk import without sub folders\n            const tempItem = action.oldItem.cloneWithLocation(false, action.payload.location)\n            const bookmarks = tempItem.children.filter(child => child instanceof Bookmark)\n            while (bookmarks.length > 0) {\n              Logger.log('Attempting chunked bulk import')\n              tempItem.children = bookmarks.splice(0, 70)\n              const imported = await resource.bulkImportFolder(action.payload.id, tempItem)\n              const newMappings = []\n              const subScanner = new Scanner(\n                tempItem,\n                imported,\n                (oldItem, newItem) => {\n                  if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n                    // if two items can be merged, we'll add mappings here directly\n                    newMappings.push([oldItem, newItem.id])\n                    return true\n                  }\n                  return false\n                },\n                this.preserveOrder,\n                false,\n              )\n              await subScanner.run()\n              await Parallel.each(newMappings, async([oldItem, newId]: [TItem<TItemLocation>, string|number]) => {\n                await this.addMapping(resource, oldItem, newId)\n              }, 10)\n            }\n\n            // create sub plan for the folders\n\n            const mappingsSnapshot = this.mappings.getSnapshot()\n\n            const folders = action.payload.children\n              .filter(item => item instanceof Folder)\n              .filter(item => item as Folder<L1>)\n\n            folders\n              .forEach((child) => {\n                // Necessary for Unidirectional reverted REMOVEs\n                const payload = child\n                payload.parentId = Mappings.mapParentId(mappingsSnapshot, child, targetLocation)\n                const oldItem = action.oldItem.findItem(child.type, child.id)\n                const newAction = { type: ActionType.CREATE, payload, oldItem }\n                this.actionsPlanned++\n                diff.commit(newAction)\n              })\n\n            if ('orderFolder' in resource) {\n              // Order created items after the fact, as they've been created concurrently\n              this.actionsPlanned++\n              reorders.commit({\n                type: ActionType.REORDER,\n                oldItem: action.payload,\n                payload: action.oldItem,\n                // payload children's IDs are not mapped\n                order: action.payload.children.map(i => ({ type: i.type, id: i.id }))\n              })\n            }\n\n            done()\n            return\n          } catch (e) {\n            Logger.log('Bulk import failed, continuing with normal creation', e)\n          }\n        }\n      }\n\n      // Create a sub plan and create each child individually (worst performance)\n      const mappingsSnapshot = this.mappings.getSnapshot()\n      action.payload.children\n        .forEach((child) => {\n          // Necessary for Unidirectional reverted REMOVEs\n          child.parentId = Mappings.mapParentId(mappingsSnapshot, child, targetLocation)\n          const oldItem = action.oldItem.findItem(child.type, child.id)\n          const newAction = { type: ActionType.CREATE, payload: child, oldItem }\n          this.actionsPlanned++\n          diff.commit(newAction)\n        })\n\n      if ('orderFolder' in resource) {\n        // Order created items after the fact, as they've been created concurrently\n        this.actionsPlanned++\n        reorders.commit({\n          type: ActionType.REORDER,\n          oldItem: action.payload,\n          payload: action.oldItem,\n          order: action.oldItem.children.map(i => ({ type: i.type, id: i.id }))\n        })\n      }\n    }\n\n    done()\n  }\n\n  async executeRemove<L1 extends TItemLocation>(\n    resource: TResource<L1>,\n    action: RemoveAction<L1, TItemLocation>,\n    targetLocation: L1,\n    diff: Diff<L1, TItemLocation, RemoveAction<L1, TItemLocation>>,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>\n  ): Promise<void> {\n    // defer execution of actions to allow the this.canceled check below to work when cancelling in interrupt tests\n    await Promise.resolve()\n    Logger.log('Executing action ', action)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    await action.payload.visitRemove(resource)\n    await this.removeMapping(resource, action.payload)\n    diff.retract(action)\n    donePlan.REMOVE.commit(action)\n    this.updateProgress()\n  }\n\n  async executeUpdate<L1 extends TItemLocation>(\n    resource: TResource<L1>,\n    action: UpdateAction<L1, TItemLocation> | MoveAction<L1, TItemLocation>,\n    targetLocation: L1,\n    diff: Diff<L1, TItemLocation, UpdateAction<L1, TItemLocation> | MoveAction<L1, TItemLocation>>,\n    donePlan: PlanStage3<TItemLocation, TItemLocation, L1>): Promise<void> {\n    // defer execution of actions to allow the this.canceled check below to work when cancelling in interrupt tests\n    await Promise.resolve()\n    Logger.log('Executing action ', action)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    await action.payload.visitUpdate(resource)\n    await this.addMapping(resource, action.oldItem, action.payload.id)\n    diff.retract(action)\n    if (action.type === ActionType.UPDATE) {\n      donePlan.UPDATE.commit(action)\n    } else {\n      donePlan.MOVE.commit(action)\n    }\n    this.updateProgress()\n  }\n\n  reconcileReorderings<L1 extends TItemLocation, L2 extends TItemLocation>(\n    targetReorders: Diff<L2, TItemLocation, ReorderAction<L2, TItemLocation>>,\n    sourceDonePlan: PlanStage3<L1, TItemLocation, L2>,\n    targetLocation: L1,\n    mappingSnapshot: MappingSnapshot\n  ) : Diff<L1, TItemLocation, ReorderAction<L1, TItemLocation>> {\n    Logger.log('Reconciling reorders to create a plan')\n\n    const sourceCreations = sourceDonePlan.CREATE.getActions()\n    const sourceRemovals = sourceDonePlan.REMOVE.getActions()\n    const sourceMoves = sourceDonePlan.MOVE.getActions()\n\n    const newReorders = new Diff<L2, TItemLocation, ReorderAction<L2, TItemLocation>>\n\n    targetReorders\n      .getActions()\n    // MOVEs have oldItem from cacheTree and payload now mapped to their corresponding target tree\n    // REORDERs have payload in source tree\n      .forEach(oldReorderAction => {\n        // clone action\n        const reorderAction = {...oldReorderAction, order: oldReorderAction.order.slice()}\n\n        const removed = sourceRemovals\n          .filter(removal => removal.payload.findItem(reorderAction.payload.type, removal.payload.id))\n        if (removed.length) {\n          return\n        }\n\n        // Find Away-moves\n        const childAwayMoves = sourceMoves\n          .filter(move =>\n            (String(reorderAction.payload.id) !== String(move.payload.parentId) && // reorder IDs are from localTree (source of this plan), move.oldItem IDs are from server tree (source of other plan)\n                reorderAction.order.find(item => String(item.id) === String(move.payload.id) && item.type === move.payload.type))// move.payload IDs are from localTree (target of the other plan\n          )\n\n        // Find removals\n        const concurrentRemovals = sourceRemovals\n          .filter(removal => reorderAction.order.find(item => String(item.id) === String(removal.payload.id) && item.type === removal.payload.type))\n\n        // Remove away-moves and removals\n        reorderAction.order = reorderAction.order.filter(item => {\n          let action\n          if (\n            // eslint-disable-next-line no-cond-assign\n            action = childAwayMoves.find(move =>\n              String(item.id) === String(move.payload.id) && move.payload.type === item.type)) {\n            Logger.log('ReconcileReorders: Removing moved item from order', {move: action, reorder: reorderAction})\n            return false\n          }\n\n          if (\n            // eslint-disable-next-line no-cond-assign\n            action = concurrentRemovals.find(removal =>\n              String(item.id) === String(removal.payload.id) && removal.payload.type === item.type)\n          ) {\n            Logger.log('ReconcileReorders: Removing removed item from order', {item, reorder: reorderAction, removal: action})\n            return false\n          }\n          return true\n        })\n\n        // Find and insert creations\n        const concurrentCreations = sourceCreations\n          .filter(creation => String(reorderAction.payload.id) === String(creation.payload.parentId))\n        concurrentCreations\n          .forEach(a => {\n            Logger.log('ReconcileReorders: Inserting created item into order', {creation: a, reorder: reorderAction})\n            reorderAction.order.splice(a.index, 0, { type: a.payload.type, id: a.payload.id })\n          })\n\n        // Find and insert moves at move target\n        const moves = sourceMoves\n          .filter(move =>\n            String(reorderAction.payload.id) === String(move.payload.parentId) &&\n                  !reorderAction.order.find(item => String(item.id) === String(move.payload.id) && item.type === move.payload.type)\n          )\n        moves.forEach(a => {\n          Logger.log('ReconcileReorders: Inserting moved item into order', {move: a, reorder: reorderAction})\n          reorderAction.order.splice(a.index, 0, { type: a.payload.type, id: a.payload.id })\n        })\n\n        newReorders.commit(reorderAction)\n      })\n\n    return newReorders.map(mappingSnapshot, targetLocation)\n  }\n\n  async executeReorderings(resource:OrderFolderResource<TItemLocation>, reorderings:Diff<TItemLocation, TItemLocation, ReorderAction<TItemLocation, TItemLocation>>):Promise<void> {\n    Logger.log('Executing reorderings')\n    Logger.log({ reorderings })\n\n    await Parallel.each(reorderings.getActions(), async(action) => {\n      Logger.log('Executing reorder action', `${action.type} Payload: #${action.payload.id}[${action.payload.title}]${'url' in action.payload ? `(${action.payload.url})` : ''} parentId: ${action.payload.parentId}`)\n      const item = action.payload\n\n      if (this.canceled) {\n        throw new CancelledSyncError()\n      }\n\n      if (action.order.length <= 1) {\n        return\n      }\n\n      const items = {}\n      try {\n        await resource.orderFolder(item.id, action.order\n          // in rare situations the diff generates a REMOVE for an item that is still in the tree,\n          // make sure to sort out those failed mapings (value: undefined)\n          // also make sure that items are unique\n          .filter(item => {\n            if (items[item.type + '' + item.id]) {\n              return false\n            }\n            items[item.type + '' + item.id] = true\n            return item.id\n          })\n        )\n      } catch (e) {\n        Logger.log('Failed to execute REORDER: ' + e.message + '\\nMoving on.')\n        Logger.log(e)\n      }\n      reorderings.retract(action)\n      this.updateProgress()\n    }, ACTION_CONCURRENCY)\n  }\n\n  async addMapping(resource:TResource<TItemLocation>, item:TItem<TItemLocation>, newId:string|number):Promise<void> {\n    await Promise.resolve()\n    let localId, remoteId\n    if (resource === this.server) {\n      localId = item.id\n      remoteId = newId\n    } else {\n      localId = newId\n      remoteId = item.id\n    }\n    if (item.type === 'folder') {\n      await this.mappings.addFolder({ localId, remoteId })\n    } else {\n      await this.mappings.addBookmark({ localId, remoteId })\n    }\n  }\n\n  async removeMapping(resource:TResource<TItemLocation>, item:TItem<TItemLocation>):Promise<void> {\n    let localId, remoteId\n    if (resource === this.server) {\n      remoteId = item.id\n    } else {\n      localId = item.id\n    }\n    if (item.type === 'folder') {\n      await this.mappings.removeFolder({ localId, remoteId })\n    } else {\n      await this.mappings.removeBookmark({ localId, remoteId })\n    }\n  }\n\n  async loadChildren(\n    serverItem:TItem<typeof ItemLocation.SERVER>,\n    mappingsSnapshot:MappingSnapshot,\n    isRoot = false\n  ):Promise<void> {\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n    if (!(serverItem instanceof Folder)) return\n    if (!('loadFolderChildren' in this.server)) return\n    let localItem, cacheItem\n    if (isRoot) {\n      localItem = this.localTreeRoot\n      cacheItem = this.cacheTreeRoot\n    } else {\n      const localId = mappingsSnapshot.ServerToLocal.folder[serverItem.id]\n      localItem = this.localTreeRoot.findFolder(localId)\n      cacheItem = this.cacheTreeRoot.findFolder(localId)\n    }\n    if (\n      localItem &&\n      !(await this.folderHasChanged(localItem, cacheItem, serverItem))\n    ) {\n      return\n    }\n    Logger.log('LOADCHILDREN', serverItem)\n    // If we don't know this folder, yet, load the whole subtree (!localItem)\n    const children = await this.server.loadFolderChildren(serverItem.id, !localItem)\n    if (!children) {\n      return\n    }\n    serverItem.children = children\n    serverItem.loaded = true\n\n    // recurse\n    await Parallel.each(\n      serverItem.children,\n      child => this.loadChildren(child, mappingsSnapshot),\n      10\n    )\n  }\n\n  async folderHasChanged(localItem: TItem<typeof ItemLocation.LOCAL>, cacheItem: TItem<typeof ItemLocation.LOCAL>, serverItem: TItem<typeof ItemLocation.SERVER>):Promise<boolean> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n    const localHash = localItem\n      ? await localItem.hash(this.preserveOrder)\n      : null\n    const cacheHash = cacheItem\n      ? await cacheItem.hash(this.preserveOrder)\n      : null\n    const serverHash = serverItem\n      ? await serverItem.hash(this.preserveOrder)\n      : null\n    const reconciled = !cacheItem\n    const changedLocally =\n      (localHash !== cacheHash) ||\n      (cacheItem && String(localItem.parentId) !== String(cacheItem.parentId))\n    const changedUpstream =\n      (cacheHash !== serverHash) ||\n      (cacheItem &&\n        String(cacheItem.parentId) !==\n        String(mappingsSnapshot.ServerToLocal.folder[serverItem.parentId]))\n    return changedLocally || changedUpstream || reconciled\n  }\n\n  filterOutUnmappedItems(tree: Folder<TItemLocation>, mapping: MappingSnapshot) {\n    tree.children = tree.children.filter(child => {\n      if (child instanceof Bookmark) {\n        return child.id in mapping.LocalToServer.bookmark\n      } else {\n        if (child.id in mapping.LocalToServer.folder) {\n          this.filterOutUnmappedItems(child, mapping)\n          return true\n        } else {\n          return false\n        }\n      }\n    })\n  }\n\n  static removeItemFromReorders(\n    mappingsSnapshot: MappingSnapshot,\n    sourceReorders:Diff<TItemLocation, TItemLocation, ReorderAction<TItemLocation, TItemLocation>>,\n    oldItem: TItem<TItemLocation>) {\n    const parentReorder = sourceReorders.getActions().find(action => Mappings.mapId(mappingsSnapshot, action.payload, oldItem.location) === oldItem.parentId)\n    if (!parentReorder) {\n      return\n    }\n    parentReorder.order = parentReorder.order.filter(item => !(item.type === oldItem.type && Mappings.mapId(mappingsSnapshot, oldItem, parentReorder.payload.location) === item.id))\n  }\n\n  toJSON(): ISerializedSyncProcess {\n    if (!this.staticContinuation) {\n      this.staticContinuation = {\n        localTreeRoot: this.localTreeRoot && this.localTreeRoot.clone(false),\n        cacheTreeRoot: this.cacheTreeRoot && this.cacheTreeRoot.clone(false),\n        serverTreeRoot: this.serverTreeRoot && this.serverTreeRoot.clone(false),\n      }\n    }\n    const membersToPersist = this.getMembersToPersist()\n    return {\n      strategy: 'default',\n      ...this.staticContinuation,\n      ...(Object.fromEntries(Object.entries(this)\n        .filter(([key]) => membersToPersist.includes(key)))\n      ),\n    }\n  }\n\n  static async fromJSON(mappings:Mappings,\n    localTree:TLocalTree,\n    server:TAdapter,\n    progressCb:(progress:number, actionsDone:number)=>void,\n    json: any) {\n    let strategy: SyncProcess\n    switch (json.strategy) {\n      case 'default':\n        strategy = new SyncProcess(mappings, localTree, server, progressCb)\n        break\n      case 'merge':\n        // eslint-disable-next-line no-case-declarations\n        const MergeSyncProcess = (await import('./Merge')).default\n        strategy = new MergeSyncProcess(mappings, localTree, server, progressCb)\n        break\n      case 'unidirectional':\n        // eslint-disable-next-line no-case-declarations\n        const UnidirectionalSyncProcess = (await import('./Unidirectional')).default\n        strategy = new UnidirectionalSyncProcess(mappings, localTree, server, progressCb)\n        break\n      default:\n        throw new Error('Unknown strategy: ' + json.strategy)\n    }\n    strategy.setProgress(json)\n    if (json.serverTreeRoot) {\n      strategy.serverTreeRoot = Folder.hydrate(json.serverTreeRoot)\n    }\n    if (json.localTreeRoot) {\n      strategy.localTreeRoot = Folder.hydrate(json.localTreeRoot)\n    }\n    if (json.cacheTreeRoot) {\n      strategy.cacheTreeRoot = Folder.hydrate(json.cacheTreeRoot)\n    }\n    strategy.getMembersToPersist().forEach((member) => {\n      if (member in json) {\n        if (member.toLowerCase().includes('scanresult') || member.toLowerCase().includes('plan')) {\n          this[member] = {\n            CREATE: Diff.fromJSON(json[member].CREATE),\n            UPDATE: Diff.fromJSON(json[member].UPDATE),\n            MOVE: Diff.fromJSON(json[member].MOVE),\n            REMOVE: Diff.fromJSON(json[member].REMOVE),\n            REORDER: Diff.fromJSON(json[member].REORDER),\n          }\n        } else if (member.toLowerCase().includes('reorders')) {\n          this[member] = Diff.fromJSON(json[member])\n        } else {\n          this[member] = json[member]\n        }\n      }\n    })\n\n    return strategy\n  }\n}\n\nexport interface ISerializedSyncProcess {\n  strategy: 'default' | 'merge' | 'unidirectional'\n  [k: string]: any\n}\n","import { Folder, ItemLocation, TItem, TItemLocation, TOppositeLocation } from '../Tree'\nimport Diff, { CreateAction, MoveAction, PlanStage1, PlanStage3, ReorderAction } from '../Diff'\nimport Scanner, { ScanResult } from '../Scanner'\nimport * as Parallel from 'async-parallel'\nimport DefaultSyncProcess, { ISerializedSyncProcess } from './Default'\nimport Mappings, { MappingSnapshot } from '../Mappings'\nimport Logger from '../Logger'\n\nconst ACTION_CONCURRENCY = 12\n\nexport default class MergeSyncProcess extends DefaultSyncProcess {\n  async getDiffs():Promise<{localScanResult:ScanResult<typeof ItemLocation.LOCAL, TItemLocation>, serverScanResult:ScanResult<typeof ItemLocation.SERVER, TItemLocation>}> {\n    // If there's no cache, diff the two trees directly\n    const newMappings: TItem<TItemLocation>[][] = []\n    const localScanner = new Scanner(\n      this.serverTreeRoot,\n      this.localTreeRoot,\n      (serverItem, localItem) => {\n        if (localItem.type === serverItem.type && serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const serverScanner = new Scanner(\n      this.localTreeRoot,\n      this.serverTreeRoot,\n      (localItem, serverItem) => {\n        if (serverItem.type === localItem.type && serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const localScanResult = await localScanner.run()\n    const serverScanResult = await serverScanner.run()\n    await Parallel.map(newMappings, ([localItem, serverItem]) => {\n      return this.addMapping(this.server, localItem, serverItem.id)\n    }, 10)\n\n    return {localScanResult, serverScanResult}\n  }\n\n  async reconcileDiffs<L1 extends TItemLocation, L2 extends TItemLocation, L3 extends TItemLocation>(\n    sourceScanResult:ScanResult<L1, L2>,\n    targetScanResult:ScanResult<TOppositeLocation<L1>, L3>,\n    targetLocation: TOppositeLocation<L1>\n  ): Promise<PlanStage1<L1, L2>> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const targetCreations = targetScanResult.CREATE.getActions()\n    const targetMoves = targetScanResult.MOVE.getActions()\n\n    const sourceMoves = sourceScanResult.MOVE.getActions()\n    const sourceUpdates = sourceScanResult.UPDATE.getActions()\n\n    const targetTree = this.getTargetTree(targetLocation)\n    const sourceTree = this.getTargetTree(targetLocation === ItemLocation.LOCAL ? ItemLocation.SERVER : ItemLocation.LOCAL) as Folder<L1>\n\n    const allCreateAndMoveActions = (sourceScanResult.CREATE.getActions() as Array<CreateAction<L1, L2> | MoveAction<L1, L2> | CreateAction<TOppositeLocation<L1>, L3> | MoveAction<TOppositeLocation<L1>, L3>>)\n      .concat(sourceScanResult.MOVE.getActions())\n      .concat(targetScanResult.CREATE.getActions())\n      .concat(targetScanResult.MOVE.getActions())\n\n    // Prepare target plan\n    const targetPlan: PlanStage1<L1, L2> = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n\n    await Parallel.each(sourceScanResult.CREATE.getActions(), async(action) => {\n      const concurrentCreation = targetCreations.find(a =>\n        a.payload.parentId === Mappings.mapParentId(mappingsSnapshot, action.payload, a.payload.location) &&\n        action.payload.canMergeWith(a.payload))\n      if (concurrentCreation) {\n        // created on both the server and locally, try to reconcile\n        const newMappings = []\n        const subScanner = new Scanner(\n          concurrentCreation.payload, // server tree\n          action.payload, // local tree\n          (oldItem, newItem) => {\n            if (oldItem.type === newItem.type && oldItem.canMergeWith(newItem)) {\n              // if two items can be merged, we'll add mappings here directly\n              newMappings.push([oldItem, newItem.id])\n              return true\n            }\n            return false\n          },\n          this.preserveOrder,\n          false,\n          false\n        )\n        await subScanner.run()\n        newMappings.push([concurrentCreation.payload, action.payload.id])\n        await Parallel.each(newMappings, async([oldItem, newId]) => {\n          await this.addMapping(action.payload.location === ItemLocation.LOCAL ? this.localTree : this.server, oldItem, newId)\n        },1)\n        // TODO: subScanner may contain residual CREATE/REMOVE actions that need to be added to mappings\n        return\n      }\n\n      targetPlan.CREATE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.MOVE.getActions(), async(action) => {\n      if (targetLocation === ItemLocation.LOCAL) {\n        const concurrentMove = sourceMoves.find(a =>\n          (action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload)) ||\n          (action.payload.type === 'bookmark' && action.payload.canMergeWith(a.payload))\n        )\n        if (concurrentMove) {\n          // Moved both on server and locally, local has precedence: do nothing locally\n          return\n        }\n      }\n      // Find concurrent moves that form a hierarchy reversal together with this one\n      const concurrentHierarchyReversals = targetMoves.filter(targetMove => {\n        return Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, sourceTree, action.payload, targetMove) &&\n          Diff.findChain(mappingsSnapshot, allCreateAndMoveActions, targetTree, targetMove.payload, action)\n      })\n      if (concurrentHierarchyReversals.length) {\n        if (targetLocation === ItemLocation.SERVER) {\n          concurrentHierarchyReversals.forEach(a => {\n            // moved locally but moved in reverse hierarchical order on server\n            const payload = a.oldItem.cloneWithLocation(false, action.payload.location) // we don't map here as we want this to look like a local action\n            const oldItem = a.payload.cloneWithLocation(false, action.oldItem.location)\n            oldItem.id = Mappings.mapId(mappingsSnapshot, oldItem, action.payload.location)\n            oldItem.parentId = Mappings.mapParentId(mappingsSnapshot, oldItem, action.payload.location)\n\n            if (\n              targetPlan.MOVE.getActions().find(move => String(move.payload.id) === String(payload.id)) ||\n              sourceMoves.find(move => String(move.payload.id) === String(payload.id))\n            ) {\n              // Don't create duplicates!\n              return\n            }\n\n            // revert server move\n            targetPlan.MOVE.commit({ ...a, payload, oldItem })\n          })\n          targetPlan.MOVE.commit(action)\n        }\n\n        // if target === LOCAL: Moved locally and in reverse hierarchical order on server. local has precedence: do nothing locally\n        return\n      }\n\n      targetPlan.MOVE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(sourceScanResult.UPDATE.getActions(), async(action) => {\n      const concurrentUpdate = sourceUpdates.find(a =>\n        action.payload.type === a.payload.type && Mappings.mappable(mappingsSnapshot, action.payload, a.payload))\n      if (concurrentUpdate && targetLocation === ItemLocation.LOCAL) {\n        // Updated both on server and locally, local has precedence: do nothing locally\n        return\n      }\n\n      targetPlan.UPDATE.commit(action)\n    }, ACTION_CONCURRENCY)\n\n    return targetPlan\n  }\n\n  reconcileReorderings<L1 extends TItemLocation, L2 extends TItemLocation>(\n    targetReorders: Diff<L2, TItemLocation, ReorderAction<L2, TItemLocation>>,\n    sourceDonePlan: PlanStage3<L1, TItemLocation, L2>,\n    targetLocation: L1,\n    mappingSnapshot: MappingSnapshot\n  ) : Diff<L1, TItemLocation, ReorderAction<L1, TItemLocation>> {\n    return super.reconcileReorderings(targetReorders, sourceDonePlan, targetLocation, mappingSnapshot)\n  }\n\n  async loadChildren(serverTreeRoot: Folder<typeof ItemLocation.SERVER>):Promise<void> {\n    Logger.log('Merge strategy: Load complete tree from server')\n    serverTreeRoot.children = (await this.server.getBookmarksTree(true)).children\n  }\n\n  toJSON(): ISerializedSyncProcess {\n    return {\n      ...DefaultSyncProcess.prototype.toJSON.apply(this),\n      strategy: 'merge'\n    }\n  }\n}\n","import DefaultStrategy, { ISerializedSyncProcess } from './Default'\nimport Diff, { ActionType, PlanRevert, PlanStage1, PlanStage3, ReorderAction } from '../Diff'\nimport * as Parallel from 'async-parallel'\nimport Mappings, { MappingSnapshot } from '../Mappings'\nimport { Folder, ItemLocation, TItem, TItemLocation, TOppositeLocation } from '../Tree'\nimport Logger from '../Logger'\nimport { CancelledSyncError } from '../../errors/Error'\nimport TResource from '../interfaces/Resource'\nimport Scanner, { ScanResult } from '../Scanner'\nimport DefaultSyncProcess from './Default'\n\nconst ACTION_CONCURRENCY = 12\n\nexport default class UnidirectionalSyncProcess extends DefaultStrategy {\n  protected direction: TItemLocation\n  protected revertPlan: PlanStage1<TItemLocation, TOppositeLocation<TItemLocation>>\n  protected revertDonePlan: PlanRevert<TItemLocation, TOppositeLocation<TItemLocation>>\n  protected revertReorders: Diff<TItemLocation, TOppositeLocation<TItemLocation>, ReorderAction<TItemLocation, TOppositeLocation<TItemLocation>>>\n\n  setDirection(direction: TItemLocation): void {\n    this.direction = direction\n  }\n\n  getMembersToPersist() {\n    return [\n      // Stage 0\n      'localScanResult',\n      'serverScanResult',\n\n      // Stage 1\n      'revertPlan',\n      'revertDonePlan',\n\n      // Stage 2\n      'revertReorders',\n    ]\n  }\n\n  async getDiffs():Promise<{localScanResult:ScanResult<typeof ItemLocation.LOCAL, TItemLocation>, serverScanResult:ScanResult<typeof ItemLocation.SERVER, TItemLocation>}> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const newMappings = []\n    const localScanner = new Scanner(\n      this.serverTreeRoot,\n      this.localTreeRoot,\n      // We can't rely on a cacheTree, thus we have to accept canMergeWith results as well\n      (serverItem, localItem) => {\n        if (localItem.type !== serverItem.type) {\n          return false\n        }\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        if (serverItem.type === 'bookmark' && localItem.type === 'bookmark' && serverItem.url !== localItem.url) {\n          return false\n        }\n        if (serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        if (Mappings.mappable(mappingsSnapshot, serverItem, localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const serverScanner = new Scanner(\n      this.localTreeRoot,\n      this.serverTreeRoot,\n      (localItem, serverItem) => {\n        if (serverItem.type !== localItem.type) {\n          return false\n        }\n        // If a bookmark's URL has changed we want to recreate it instead of updating it, because of Nextcloud Bookmarks' uniqueness constraints\n        if (serverItem.type === 'bookmark' && localItem.type === 'bookmark' && serverItem.url !== localItem.url) {\n          return false\n        }\n        if (serverItem.canMergeWith(localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        if (Mappings.mappable(mappingsSnapshot, serverItem, localItem)) {\n          newMappings.push([localItem, serverItem])\n          return true\n        }\n        return false\n      },\n      this.preserveOrder,\n      false,\n      false\n    )\n    const localScanResult = await localScanner.run()\n    const serverScanResult = await serverScanner.run()\n    await Parallel.map(newMappings, ([localItem, serverItem]) => {\n      return this.addMapping(this.server, localItem, serverItem.id)\n    })\n\n    return {localScanResult, serverScanResult}\n  }\n\n  async loadChildren(serverTreeRoot:Folder<typeof ItemLocation.SERVER>) :Promise<void> {\n    Logger.log('Unidirectional: Loading whole tree')\n    serverTreeRoot.children = (await this.server.getBookmarksTree(true)).children\n  }\n\n  async sync(): Promise<void> {\n    this.progressCb(0.15)\n\n    this.masterLocation = this.direction === ItemLocation.SERVER ? ItemLocation.LOCAL : ItemLocation.SERVER\n    await this.prepareSync()\n\n    this.progressCb(0.35)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log({localTreeRoot: this.localTreeRoot, serverTreeRoot: this.serverTreeRoot, cacheTreeRoot: this.cacheTreeRoot})\n\n    if (!this.localScanResult && !this.serverScanResult) {\n      const { localScanResult, serverScanResult } = await this.getDiffs()\n      Logger.log({ localScanResult, serverScanResult })\n      this.localScanResult = localScanResult\n      this.serverScanResult = serverScanResult\n      this.progressCb(0.45)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    let sourceScanResult: ScanResult<TItemLocation, TItemLocation>,\n      targetScanResult: ScanResult<TItemLocation, TItemLocation>,\n      target: TResource<TItemLocation>\n    if (this.direction === ItemLocation.SERVER) {\n      sourceScanResult = this.localScanResult\n      targetScanResult = this.serverScanResult\n      target = this.server\n    } else {\n      sourceScanResult = this.serverScanResult\n      targetScanResult = this.localScanResult\n      target = this.localTree\n    }\n\n    // First revert slave modifications\n\n    if (!this.revertPlan) {\n      this.revertPlan = await this.revertDiff(targetScanResult, sourceScanResult, this.direction)\n      Logger.log({revertPlan: this.revertPlan})\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    this.actionsPlanned = Object.values(this.revertPlan).reduce((acc, diff) => diff.getActions().length + acc, 0)\n\n    if (this.direction === ItemLocation.LOCAL) {\n      this.applyFailsafe(this.revertPlan.REMOVE)\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log('Executing ' + this.direction + ' revert plan')\n\n    this.revertDonePlan = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: new Diff(),\n    }\n\n    await this.executeRevert(target, this.revertPlan, this.direction, this.revertDonePlan, sourceScanResult.REORDER)\n\n    if ('orderFolder' in this.server && !this.revertReorders) {\n      const mappingsSnapshot = this.mappings.getSnapshot()\n      Logger.log('Mapping reorderings')\n      this.revertReorders = sourceScanResult.REORDER.map(mappingsSnapshot, this.direction)\n    }\n\n    if ('orderFolder' in this.server && 'orderFolder' in target) {\n      await this.executeReorderings(target, this.revertReorders)\n    }\n  }\n\n  async revertDiff<L1 extends TItemLocation, L2 extends TItemLocation>(\n    targetScanResult: ScanResult<L1, L2>,\n    sourceScanResult: ScanResult<L2, L1>,\n    targetLocation: L1\n  ): Promise<PlanRevert<L1, L2>> {\n    const mappingsSnapshot = this.mappings.getSnapshot()\n\n    const slavePlan: PlanRevert<L1, L2> = {\n      CREATE: new Diff(),\n      UPDATE: new Diff(),\n      MOVE: new Diff(),\n      REMOVE: new Diff(),\n      REORDER: targetScanResult.REORDER.clone(),\n    }\n\n    // Prepare slave plan for reversing slave changes\n\n    await Parallel.each(sourceScanResult.CREATE.getActions(), async(action) => {\n      // recreate it on slave resource otherwise\n      const payload = await this.translateCompleteItem(action.payload, mappingsSnapshot, targetLocation)\n      const oldItem = action.payload\n      payload.createIndex()\n      oldItem.createIndex()\n\n      slavePlan.CREATE.commit({...action, type: ActionType.CREATE, payload, oldItem })\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(targetScanResult.CREATE.getActions(), async(action) => {\n      slavePlan.REMOVE.commit({ ...action, type: ActionType.REMOVE })\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(targetScanResult.UPDATE.getActions(), async(action) => {\n      const payload = action.oldItem.cloneWithLocation(false, action.payload.location)\n      payload.id = action.payload.id\n      payload.parentId = action.payload.parentId\n\n      const oldItem = action.payload.cloneWithLocation(false, action.oldItem.location)\n      oldItem.id = action.oldItem.id\n      oldItem.parentId = action.oldItem.parentId\n      slavePlan.UPDATE.commit({ type: ActionType.UPDATE, payload, oldItem })\n    }, ACTION_CONCURRENCY)\n\n    await Parallel.each(targetScanResult.MOVE.getActions(), async(action) => {\n      const payload = action.payload.cloneWithLocation(false, action.oldItem.location)\n      payload.id = action.oldItem.id\n      payload.parentId = action.oldItem.parentId\n\n      slavePlan.MOVE.commit({ type: ActionType.MOVE, payload }) // no oldItem, because we want to map the id after having executed the CREATEs\n    }, ACTION_CONCURRENCY)\n\n    return slavePlan\n  }\n\n  private async translateCompleteItem<L1 extends TItemLocation, L2 extends TItemLocation>(item: TItem<L1>, mappingsSnapshot: MappingSnapshot, fakeLocation: L2) {\n    const newItem = item.cloneWithLocation(false, fakeLocation)\n    newItem.id = Mappings.mapId(mappingsSnapshot, item, fakeLocation)\n    newItem.parentId = Mappings.mapParentId(mappingsSnapshot, item, fakeLocation)\n    if (newItem instanceof Folder) {\n      const nonexistingItems = []\n      await newItem.traverse(async(child, parentFolder) => {\n        child.id = Mappings.mapId(mappingsSnapshot, child, fakeLocation)\n        if (typeof child.id === 'undefined') {\n          nonexistingItems.push(child)\n        }\n        child.parentId = parentFolder.id\n      })\n      newItem.createIndex()\n      // filter out all items that couldn't be mapped: These are creations from the slave side\n      nonexistingItems.forEach(item => {\n        const folder = newItem.findFolder(item.parentId)\n        folder.children = folder.children.filter(i => i.id)\n      })\n    } else {\n      newItem.createIndex()\n    }\n    return newItem\n  }\n\n  async executeRevert<L1 extends TItemLocation>(\n    resource:TResource<L1>,\n    planRevert:PlanRevert<L1, TOppositeLocation<L1>>,\n    targetLocation:L1,\n    donePlan: PlanStage3<TOppositeLocation<L1>, TItemLocation, L1>,\n    reorders: Diff<TOppositeLocation<L1>, TItemLocation, ReorderAction<TOppositeLocation<L1>, TItemLocation>>): Promise<void> {\n    Logger.log('Executing revert plan for ' + targetLocation)\n\n    let createActions = planRevert.CREATE.getActions()\n    while (createActions.length > 0) {\n      Logger.log(targetLocation + ': executing CREATEs')\n      await Parallel.each(\n        createActions,\n        (action) => this.executeCreate(resource, action, targetLocation, planRevert.CREATE, reorders, donePlan),\n        ACTION_CONCURRENCY\n      )\n      createActions = planRevert.CREATE.getActions()\n    }\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing CREATEs')\n\n    await Parallel.each(\n      planRevert.UPDATE.getActions(),\n      (action) => this.executeUpdate(resource, action, targetLocation, planRevert.UPDATE, donePlan),\n      ACTION_CONCURRENCY\n    )\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const mappingsSnapshot = this.mappings.getSnapshot()\n    // TODO: Store this in continuation\n    const mappedMoves = planRevert.MOVE.map(mappingsSnapshot, targetLocation)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    const batches = Diff.sortMoves(mappedMoves.getActions(), this.getTargetTree(targetLocation))\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing MOVEs')\n    await Parallel.each(batches, batch => Parallel.each(batch, (action) => {\n      return this.executeUpdate(resource, action, targetLocation, mappedMoves, donePlan)\n    }, ACTION_CONCURRENCY), 1)\n\n    if (this.canceled) {\n      throw new CancelledSyncError()\n    }\n\n    Logger.log(targetLocation + ': executing REMOVEs')\n    await Parallel.each(planRevert.REMOVE.getActions(), (action) => {\n      return this.executeRemove(resource, action, targetLocation, planRevert.REMOVE, donePlan)\n    }, ACTION_CONCURRENCY)\n  }\n\n  toJSON(): ISerializedSyncProcess {\n    return {\n      ...DefaultSyncProcess.prototype.toJSON.apply(this),\n      strategy: 'unidirectional'\n    }\n  }\n}\n"],"names":["map","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","e","Error","code","ids","id","all","slice","keys","Object","module","exports","Crypto","sha256","message","msgBuffer","TextEncoder","encode","hashBuffer","crypto","subtle","digest","this","bufferToHexstr","buffer","Array","from","Uint8Array","b","toString","join","hexstrToBuffer","hex","bytes","length","c","parseInt","substr","prepareKey","key","keyBuffer","importKey","name","decryptAES","iv","ciphertext","TextDecoder","decode","decrypt","encryptAES","encrypt","getRandomBytes","bytelength","rand","Int8Array","getRandomValues","ChromePromise","root","window","self","push","prototype","hasOwnProperty","chrome","runtime","setPromiseFunction","fn","thisArg","args","arguments","reject","call","err","lastError","apply","fillProperties","source","target","val","type","indexOf","browser","alarms","browserAction","action","i18n","storageLock","AsyncLock","NativeAccountStorage","constructor","accountId","changeEntry","entryName","defaultVal","acquire","async","entry","getEntry","Storage","set","value","JSON","stringify","get","parse","deleteEntry","remove","getAllAccounts","accounts","getAccountData","data","password","DefunctCryptography","Cryptography","username","passphrase","setAccountData","encData","deleteAccountData","deleteCache","deleteMappings","initCache","getCache","Folder","hydrate","location","ItemLocation","LOCAL","setCache","initMappings","getMappings","Mappings","bookmarks","ServerToLocal","LocalToServer","folders","setMappings","getCurrentContinuation","setCurrentContinuation","continuation","_","AlarmManager","ctl","backgroundSyncEnabled","setInterval","checkSync","Network","addListener","status","connected","Account","getData","scheduled","scheduleSync","lastSync","Date","now","syncInterval","NativeController","schedule","listeners","accountsLocked","_ref","setEnabled","unlocked","enabled","unlock","hashedKey","getUnlocked","scheduleAll","account","wait","clearTimeout","setTimeout","syncing","getStatus","STATUS_SYNCING","syncAccount","setData","cancelSync","keepEnabled","strategy","forceSync","undefined","updateStatus","sync","error","console","forEach","STATUS_ERROR","overallStatus","reduce","accData","STATUS_ALLGOOD","every","STATUS_DISABLED","onStatusChange","listener","unregistered","splice","onLoad","acc","singleton","getSingleton","setPrototypeOf","FloccusError","UnknownCreateTargetError","UnknownBookmarkUpdateError","UnknownMoveOriginError","UnknownMoveTargetError","UnknownFolderParentUpdateError","UnknownFolderUpdateError","UnknownFolderMoveError","UnknownFolderOrderError","item","UnknownFolderItemOrderError","MissingItemOrderError","UnknownFolderRemoveError","UnknownFolderParentRemoveError","UnexpectedServerResponseError","RequestTimeoutError","NetworkError","AuthenticationError","method","HttpError","response","ParseResponseError","InconsistentServerStateError","folder","bookmark","InconsistentBookmarksExistenceError","lockFile","UnclearedLockFileError","LockFileError","SlashError","InterruptedSyncError","CancelledSyncError","percent","FailsafeError","DecryptionError","GoogleDriveAuthenticationError","OAuthTokenError","RedirectError","FileUnreadableError","inspect","CreateBookmarkError","MissingPermissionsError","ResourceLockedError","LocalFolderNotFoundError","UpdateBookmarkError","register","default","storageAdapter","serverAdapter","treeAdapter","server","storage","localTree","lockTimeout","getAccountClass","Capacitor","getPlatform","cache","updateFromStorage","create","import","accountData","export","accountIds","a","delete","getLabel","assign","localRoot","nestedSync","failsafe","allowNetwork","label","errorCount","clickCountEnabled","getResource","getServer","tracksBookmark","localId","isInitialized","mappings","snapshot","getSnapshot","foundBookmark","some","String","foundFolder","init","localResource","isAvailable","log","Sentry","setUser","onSyncStart","needLock","persist","onSyncFail","cacheTree","fromJSON","progress","actionDone","progressCallback","syncProcess","createdAt","strategyClass","direction","SERVER","children","actionsDone","setCacheTree","setDirection","getBookmarksTree","clone","filterOutUnacceptedBookmarks","filterOutUnmappedItems","onSyncComplete","stringifyError","setContext","list","captureException","matchAllErrors","isTest","er","cancel","toJSON","getMappingsInstance","getAccountsContainingLocalId","ancestors","allAccounts","registry","adapter","factory","getDefaultValues","worker","Controller","getWorker","navigator","userAgent","includes","serviceWorker","controller","ready","registration","postMessage","active","addEventListener","event","removeEventListener","sendMessage","warn","onMessage","removeListener","params","eventListener","w","salt","enc","passphraseBytes","saltBytes","deriveKey","hash","iterations","payload","cryptoKey","toUint8Array","ivLength","plaintextBytes","messageBytes","resultBytes","concatBytes","fromUint8Array","array1","array2","result","ActionType","CREATE","UPDATE","MOVE","REMOVE","REORDER","actions","filter","newDiff","Diff","getActions","commit","retract","concat","findChain","mappingsSnapshot","itemTree","currentItem","targetAction","chain","targetItemInTree","findFolder","mapId","findItem","ItemType","FOLDER","mapParentId","newCurrentActions","newCurrentAction","sortMoves","tree","batches","BOOKMARK","folderMoves","DAG","action1","action2","batch","find","reverse","targetLocation","skipErroneousActions","newAction","oldItem","oldId","newId","cloneWithLocation","parentId","diff","oldOrder","order","depth","title","url","index","json","queue","concurrency","tabs","query","windowType","tab","incognito","t","windowId","i","sort","t1","t2","Bookmark","createBookmark","protocol","URL","add","BookmarkTreeNodeType","discarded","node","awaitTabsUpdated","updateBookmark","update","move","removeBookmark","bookmarkId","createFolder","windows","orderFolder","originalTabs","untouchedChildren","child","updateFolder","removeFolder","Boolean","race","onUpdated","mappingsData","addFolder","remoteId","addBookmark","mappable","item1","item2","oldTree","newTree","mergeable","preserveOrder","checkHashes","hasCache","getDiffs","run","diffItem","findMoves","addReorders","newItem","diffFolder","diffBookmark","oldFolder","newFolder","folderHasChanged","unmatchedChildren","Parallel","old","isRoot","newChild","oldBookmark","newBookmark","bookmarkHasChanged","hasChanged","oldHash","newHash","reconciled","createAction","removeAction","createActions","shift","createdItem","removeActions","removedItem","childrenSimilarity","oldIndex","findItemFilter","removedItemClone","oldParentClone","oldItemClone","createIndex","createdItemClone","newParentClone","newClonedItem","moves","folderId","targets","sources","duplicate","STRANGE_PROTOCOLS","tags","proto","urlObj","href","canMergeWith","otherItem","hashValue","withHash","prefer","count","fill","visitCreate","resource","visitUpdate","visitRemove","obj","loaded","values","pop","findBookmark","bm","traverse","each","Math","max","c1","c2","countFolders","subIndex","getAncestorsOf","parent","resetCache","highestId","bookmarksCache","hostname","acceptsBookmark","newBm","foundOldFolder","foundNewFolder","Tree","foundParentFolder","foundOldParentFolder","foundNewParentFolder","newChildren","bulkImportFolder","imported","parentFolder","locked","lockingInterval","branch","bookmark_file","bookmark_file_type","includeCredentials","allowRedirects","GitAdapter","cancelCallback","forceLock","dir","hasPermissions","permissions","contains","origins","fs","wipe","git","addRemote","remote","force","fetch","http","pruneTags","onAuth","checkout","ref","Errors","NotFoundError","what","promises","writeFile","mode","encoding","filepath","author","currentBranch","renameBranch","oldref","remoteRef","clearInterval","setLock","obtainLock","pullFromServer","initialTreeHash","freeLock","indexedDB","deleteDatabase","fileContents","rootFolder","output","serialize","createHTML","PushRejectedError","listTags","lockTag","tag","startsWith","dateLocked","Number","lockingPromise","readFile","split","line","idxStart","idxEnd","lastIndexOf","substring","deserialize","clearServer","defaultBranch","lockTags","OAuthConfig","authorizationBaseUrl","accessTokenEndpoint","scope","resourceUrl","logsEnabled","android","appId","client_id","responseType","redirectUrl","ios","alwaysUpload","authorize","interactive","platform","OAuth2Client","authenticate","refresh_token","access_token_response","user","displayName","challenge","state","redirectURL","identity","getRedirectURL","scopes","authURL","web","encodeURIComponent","launchWebAuthFlow","redirectResult","m","match","URLSearchParams","resState","headers","body","client_secret","text","access_token","Authorization","about","getAccessToken","refreshToken","request","grant_type","getUrl","timeout","ms","accessToken","listFiles","fileList","file","files","trashed","filesToDelete","fileToDelete","deleteFile","fileId","getFileMetadata","appProperties","lockedDate","isInteger","downloadFile","xmlDocText","byNL","newTreeHash","xbel","createFile","uploadFile","contentType","requestNative","requestWeb","credentials","resp","entries","res","limit","fields","lockFreed","SCOPES","GoogleDriveAdapter","TIMEOUT","fetchQueue","abortController","AbortController","abortSignal","signal","serverFolder","canceled","abort","LinkwardenAdapter","sendRequest","collection","ownerId","success","loadAll","links","collections","rootCollection","buildTree","col","link","collectionId","verb","relUrl","returnRawResponse","timedOut","sendRequestNative","toLowerCase","redirected","disableRedirects","hasFeatureBulkImport","ended","hasFeatureJavascriptLinks","bookmarkLock","serverRoot","NextcloudBookmarksAdapter","normalizeServerURL","input","serverURL","indexLoc","pathname","search","checkFeatureJavascriptLinks","acquireLock","releaseLock","clear","getBookmarksList","isArray","getCompleteBookmarksTree","getSparseBookmarksTree","_getChildFolders","layers","folderJson","_findServerRoot","segment","currentChild","parent_folder","_getChildren","_getFolderHash","true","catch","childrenJson","recurseChildren","childFolder","loadFolderChildren","folderHash","blob","Blob","FormData","append","oldParentFolder","newParentFolder","_getBookmark","getExistingBookmark","existingBookmark","updatedBookmark","upstreamMark","upstreamId","oldParentId","bms","listIndex","findIndex","authString","Base64","countClick","WebDavAdapter","getBookmarkURL","getBookmarkLockURL","checkLock","fullURL","valueOf","fullUrl","redirect","webFetchExtra","content_type","uploadFileWeb","uploadFileNative","aborted","downloadFileWeb","downloadFileNative","Pragma","BrowserAccount","random","getTree","parentNode","bookmarksBar","getPathFromLocalId","rootPath","getSubTree","LocalTabs","localTabs","getMessage","padStart","withDisallowNested","getIdPathFromLocalId","accountsInvolved","lastNesterIdx","isVivaldi","currentWindow","absoluteRoot","rootId","absoluteRootPromise","BrowserTree","getAbsoluteRootFolder","isVivaldiBrowser","recurse","rng","overrideTitle","int","realTree","removeTree","relativeToRoot","ancestor","replace","path","unshift","Symbol","context","locale","locales","defaultMessages","messages","setLocales","load","fileName","messageName","content","formats","string","doGetMessage","format","getDefaultLocaleMessage","I18n","NativeAccount","nativeTree","save","triggerSave","saveTimeout","_serializeFolder","_htmlentities_encode","char","charCodeAt","indent","nextIndent","html","items","parseByString","f","HtmlSerializer","getRootFolder","h3","first","attr","$","cheerio","decodeEntities","rdt","parseNode","eq0","eq","toArray","ele","xbelObj","XMLBuilder","ignoreAttributes","build","xmlObj","XMLParser","ignorePiTags","parseTagValue","_parseFolder","XbelSerializer","ACTION_CONCURRENCY","progressCb","localTreeRoot","serverTreeRoot","localScanResult","serverScanResult","actionsPlanned","staticContinuation","throttle","isFirefox","getMembersToPersist","cacheTreeRoot","getTargetTree","updateProgress","min","setProgress","masterLocation","prepareSync","serverPlanStage1","reconcileDiffs","localPlanStage1","serverPlanStage2","localPlanStage2","localPlan","serverPlan","applyFailsafe","localDonePlan","serverDonePlan","localReorders","serverReorders","execute","localReordersFinal","reconcileReorderings","serverReorderFinal","executeReorderings","filterOutDuplicatesInTheSameFolder","filterOutInvalidBookmarks","loadChildren","removals","localCountTotal","localCountDeleted","ceil","seenUrl","duplicates","newMappings","localScanner","serverScanner","localItem","serverItem","addMapping","sourceScanResult","targetScanResult","targetCreations","targetRemovals","targetMoves","targetUpdates","targetReorders","sourceCreations","sourceRemovals","sourceMoves","targetTree","sourceTree","allCreateAndMoveActions","avoidTargetReorders","targetPlan","targetRemoval","targetMove","concurrentCreation","complexTargetTargetRemoval","concurrentTargetOriginRemoval","concurrentSourceOriginRemoval","sourceRemoval","concurrentSourceTargetRemoval","SyncProcess","removeItemFromReorders","originalCreation","creation","newPayload","removed","movedAway","concurrentHierarchyReversals","planStage2","donePlan","reorders","executeCreate","executeUpdate","planStage3","executeRemove","done","oldChildItem","tempItem","removeMapping","sourceDonePlan","mappingSnapshot","newReorders","oldReorderAction","reorderAction","removal","childAwayMoves","concurrentRemovals","reorder","reorderings","cacheItem","localHash","cacheHash","serverHash","changedLocally","changedUpstream","mapping","sourceReorders","parentReorder","membersToPersist","fromEntries","MergeSyncProcess","UnidirectionalSyncProcess","member","sourceUpdates","revertPlan","revertDiff","revertDonePlan","executeRevert","revertReorders","slavePlan","translateCompleteItem","fakeLocation","planRevert","mappedMoves"],"sourceRoot":""}