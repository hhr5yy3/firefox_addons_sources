var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var background = function() {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
  "use strict";
  function defineBackground(arg) {
    if (arg == null || typeof arg === "function")
      return { main: arg };
    return arg;
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function getAugmentedNamespace(n) {
    if (n.__esModule)
      return n;
    var f2 = n.default;
    if (typeof f2 == "function") {
      var a2 = function a3() {
        if (this instanceof a3) {
          return Reflect.construct(f2, arguments, this.constructor);
        }
        return f2.apply(this, arguments);
      };
      a2.prototype = f2.prototype;
    } else
      a2 = {};
    Object.defineProperty(a2, "__esModule", {
      value: true
    });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a2, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a2;
  }
  var browserPolyfill = { exports: {} };
  (function(module2, exports) {
    (function(global2, factory) {
      {
        factory(module2);
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : commonjsGlobal, function(module3) {
      if (!(globalThis.chrome && globalThis.chrome.runtime && globalThis.chrome.runtime.id)) {
        throw new Error("This script should only be loaded in a browser extension.");
      }
      if (!(globalThis.browser && globalThis.browser.runtime && globalThis.browser.runtime.id)) {
        const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
        const wrapAPIs = (extensionAPIs) => {
          const apiMetadata = {
            "alarms": {
              "clear": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "clearAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "get": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "bookmarks": {
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getChildren": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getRecent": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getSubTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTree": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "browserAction": {
              "disable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "enable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "getBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getBadgeText": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "openPopup": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setBadgeText": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "browsingData": {
              "remove": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "removeCache": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCookies": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeDownloads": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFormData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeHistory": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeLocalStorage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePasswords": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePluginData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "settings": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "commands": {
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "contextMenus": {
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "cookies": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAllCookieStores": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "set": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "devtools": {
              "inspectedWindow": {
                "eval": {
                  "minArgs": 1,
                  "maxArgs": 2,
                  "singleCallbackArg": false
                }
              },
              "panels": {
                "create": {
                  "minArgs": 3,
                  "maxArgs": 3,
                  "singleCallbackArg": true
                },
                "elements": {
                  "createSidebarPane": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                }
              }
            },
            "downloads": {
              "cancel": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "download": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "erase": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFileIcon": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "open": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "pause": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFile": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "resume": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "extension": {
              "isAllowedFileSchemeAccess": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "isAllowedIncognitoAccess": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "history": {
              "addUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "deleteRange": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getVisits": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "i18n": {
              "detectLanguage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAcceptLanguages": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "identity": {
              "launchWebAuthFlow": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "idle": {
              "queryState": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "management": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getSelf": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setEnabled": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "uninstallSelf": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "notifications": {
              "clear": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPermissionLevel": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "pageAction": {
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "hide": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "permissions": {
              "contains": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "request": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "runtime": {
              "getBackgroundPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPlatformInfo": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "openOptionsPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "requestUpdateCheck": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "sendMessage": {
                "minArgs": 1,
                "maxArgs": 3
              },
              "sendNativeMessage": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "setUninstallURL": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "sessions": {
              "getDevices": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getRecentlyClosed": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "restore": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "storage": {
              "local": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "managed": {
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "sync": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              }
            },
            "tabs": {
              "captureVisibleTab": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "detectLanguage": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "discard": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "duplicate": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "executeScript": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getZoom": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getZoomSettings": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goBack": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goForward": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "highlight": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "insertCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "query": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "reload": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "sendMessage": {
                "minArgs": 2,
                "maxArgs": 3
              },
              "setZoom": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "setZoomSettings": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "update": {
                "minArgs": 1,
                "maxArgs": 2
              }
            },
            "topSites": {
              "get": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "webNavigation": {
              "getAllFrames": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFrame": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "webRequest": {
              "handlerBehaviorChanged": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "windows": {
              "create": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getLastFocused": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            }
          };
          if (Object.keys(apiMetadata).length === 0) {
            throw new Error("api-metadata.json has not been included in browser-polyfill");
          }
          class DefaultWeakMap extends WeakMap {
            constructor(createItem, items = void 0) {
              super(items);
              this.createItem = createItem;
            }
            get(key) {
              if (!this.has(key)) {
                this.set(key, this.createItem(key));
              }
              return super.get(key);
            }
          }
          const isThenable2 = (value) => {
            return value && typeof value === "object" && typeof value.then === "function";
          };
          const makeCallback = (promise, metadata) => {
            return (...callbackArgs) => {
              if (extensionAPIs.runtime.lastError) {
                promise.reject(new Error(extensionAPIs.runtime.lastError.message));
              } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                promise.resolve(callbackArgs[0]);
              } else {
                promise.resolve(callbackArgs);
              }
            };
          };
          const pluralizeArguments = (numArgs) => numArgs == 1 ? "argument" : "arguments";
          const wrapAsyncFunction = (name, metadata) => {
            return function asyncFunctionWrapper(target, ...args) {
              if (args.length < metadata.minArgs) {
                throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
              }
              if (args.length > metadata.maxArgs) {
                throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
              }
              return new Promise((resolve, reject) => {
                if (metadata.fallbackToNoCallback) {
                  try {
                    target[name](...args, makeCallback({
                      resolve,
                      reject
                    }, metadata));
                  } catch (cbError) {
                    console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError);
                    target[name](...args);
                    metadata.fallbackToNoCallback = false;
                    metadata.noCallback = true;
                    resolve();
                  }
                } else if (metadata.noCallback) {
                  target[name](...args);
                  resolve();
                } else {
                  target[name](...args, makeCallback({
                    resolve,
                    reject
                  }, metadata));
                }
              });
            };
          };
          const wrapMethod = (target, method, wrapper) => {
            return new Proxy(method, {
              apply(targetMethod, thisObj, args) {
                return wrapper.call(thisObj, target, ...args);
              }
            });
          };
          let hasOwnProperty2 = Function.call.bind(Object.prototype.hasOwnProperty);
          const wrapObject = (target, wrappers = {}, metadata = {}) => {
            let cache2 = /* @__PURE__ */ Object.create(null);
            let handlers2 = {
              has(proxyTarget2, prop) {
                return prop in target || prop in cache2;
              },
              get(proxyTarget2, prop, receiver) {
                if (prop in cache2) {
                  return cache2[prop];
                }
                if (!(prop in target)) {
                  return void 0;
                }
                let value = target[prop];
                if (typeof value === "function") {
                  if (typeof wrappers[prop] === "function") {
                    value = wrapMethod(target, target[prop], wrappers[prop]);
                  } else if (hasOwnProperty2(metadata, prop)) {
                    let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                    value = wrapMethod(target, target[prop], wrapper);
                  } else {
                    value = value.bind(target);
                  }
                } else if (typeof value === "object" && value !== null && (hasOwnProperty2(wrappers, prop) || hasOwnProperty2(metadata, prop))) {
                  value = wrapObject(value, wrappers[prop], metadata[prop]);
                } else if (hasOwnProperty2(metadata, "*")) {
                  value = wrapObject(value, wrappers[prop], metadata["*"]);
                } else {
                  Object.defineProperty(cache2, prop, {
                    configurable: true,
                    enumerable: true,
                    get() {
                      return target[prop];
                    },
                    set(value2) {
                      target[prop] = value2;
                    }
                  });
                  return value;
                }
                cache2[prop] = value;
                return value;
              },
              set(proxyTarget2, prop, value, receiver) {
                if (prop in cache2) {
                  cache2[prop] = value;
                } else {
                  target[prop] = value;
                }
                return true;
              },
              defineProperty(proxyTarget2, prop, desc) {
                return Reflect.defineProperty(cache2, prop, desc);
              },
              deleteProperty(proxyTarget2, prop) {
                return Reflect.deleteProperty(cache2, prop);
              }
            };
            let proxyTarget = Object.create(target);
            return new Proxy(proxyTarget, handlers2);
          };
          const wrapEvent = (wrapperMap) => ({
            addListener(target, listener, ...args) {
              target.addListener(wrapperMap.get(listener), ...args);
            },
            hasListener(target, listener) {
              return target.hasListener(wrapperMap.get(listener));
            },
            removeListener(target, listener) {
              target.removeListener(wrapperMap.get(listener));
            }
          });
          const onRequestFinishedWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onRequestFinished(req) {
              const wrappedReq = wrapObject(req, {}, {
                getContent: {
                  minArgs: 0,
                  maxArgs: 0
                }
              });
              listener(wrappedReq);
            };
          });
          const onMessageWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onMessage(message, sender, sendResponse) {
              let didCallSendResponse = false;
              let wrappedSendResponse;
              let sendResponsePromise = new Promise((resolve) => {
                wrappedSendResponse = function(response) {
                  didCallSendResponse = true;
                  resolve(response);
                };
              });
              let result2;
              try {
                result2 = listener(message, sender, wrappedSendResponse);
              } catch (err) {
                result2 = Promise.reject(err);
              }
              const isResultThenable = result2 !== true && isThenable2(result2);
              if (result2 !== true && !isResultThenable && !didCallSendResponse) {
                return false;
              }
              const sendPromisedResult = (promise) => {
                promise.then((msg) => {
                  sendResponse(msg);
                }, (error2) => {
                  let message2;
                  if (error2 && (error2 instanceof Error || typeof error2.message === "string")) {
                    message2 = error2.message;
                  } else {
                    message2 = "An unexpected error occurred";
                  }
                  sendResponse({
                    __mozWebExtensionPolyfillReject__: true,
                    message: message2
                  });
                }).catch((err) => {
                  console.error("Failed to send onMessage rejected reply", err);
                });
              };
              if (isResultThenable) {
                sendPromisedResult(result2);
              } else {
                sendPromisedResult(sendResponsePromise);
              }
              return true;
            };
          });
          const wrappedSendMessageCallback = ({
            reject,
            resolve
          }, reply) => {
            if (extensionAPIs.runtime.lastError) {
              if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                resolve();
              } else {
                reject(new Error(extensionAPIs.runtime.lastError.message));
              }
            } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
              reject(new Error(reply.message));
            } else {
              resolve(reply);
            }
          };
          const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
            if (args.length < metadata.minArgs) {
              throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
            }
            if (args.length > metadata.maxArgs) {
              throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
            }
            return new Promise((resolve, reject) => {
              const wrappedCb = wrappedSendMessageCallback.bind(null, {
                resolve,
                reject
              });
              args.push(wrappedCb);
              apiNamespaceObj.sendMessage(...args);
            });
          };
          const staticWrappers = {
            devtools: {
              network: {
                onRequestFinished: wrapEvent(onRequestFinishedWrappers)
              }
            },
            runtime: {
              onMessage: wrapEvent(onMessageWrappers),
              onMessageExternal: wrapEvent(onMessageWrappers),
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 1,
                maxArgs: 3
              })
            },
            tabs: {
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 2,
                maxArgs: 3
              })
            }
          };
          const settingMetadata = {
            clear: {
              minArgs: 1,
              maxArgs: 1
            },
            get: {
              minArgs: 1,
              maxArgs: 1
            },
            set: {
              minArgs: 1,
              maxArgs: 1
            }
          };
          apiMetadata.privacy = {
            network: {
              "*": settingMetadata
            },
            services: {
              "*": settingMetadata
            },
            websites: {
              "*": settingMetadata
            }
          };
          return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
        };
        module3.exports = wrapAPIs(chrome);
      } else {
        module3.exports = globalThis.browser;
      }
    });
  })(browserPolyfill);
  var browserPolyfillExports = browserPolyfill.exports;
  const browser$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserPolyfillExports);
  const proxiedEvents = {
    "commands.onCommand": ensureOptional((_a = browser$1 == null ? void 0 : browser$1.commands) == null ? void 0 : _a.onCommand),
    "omnibox.onInputChanged": ensureOptional((_b = browser$1 == null ? void 0 : browser$1.omnibox) == null ? void 0 : _b.onInputChanged),
    "omnibox.onInputEntered": ensureOptional((_c = browser$1 == null ? void 0 : browser$1.omnibox) == null ? void 0 : _c.onInputEntered),
    "runtime.onConnect": ensureOptional((_d = browser$1 == null ? void 0 : browser$1.runtime) == null ? void 0 : _d.onConnect),
    "runtime.onInstalled": ensureOptional((_e = browser$1 == null ? void 0 : browser$1.runtime) == null ? void 0 : _e.onInstalled),
    "runtime.onMessage": ensureOptional((_f = browser$1 == null ? void 0 : browser$1.runtime) == null ? void 0 : _f.onMessage),
    "runtime.onMessageExternal": ensureOptional((_g = browser$1 == null ? void 0 : browser$1.runtime) == null ? void 0 : _g.onMessageExternal),
    "tabs.onActivated": ensureOptional((_h = browser$1 == null ? void 0 : browser$1.tabs) == null ? void 0 : _h.onActivated),
    "tabs.onCreated": ensureOptional((_i = browser$1 == null ? void 0 : browser$1.tabs) == null ? void 0 : _i.onCreated),
    "tabs.onRemoved": ensureOptional((_j = browser$1 == null ? void 0 : browser$1.tabs) == null ? void 0 : _j.onRemoved),
    "tabs.onUpdated": ensureOptional((_k = browser$1 == null ? void 0 : browser$1.tabs) == null ? void 0 : _k.onUpdated),
    "windows.onFocusChanged": ensureOptional((_l = browser$1 == null ? void 0 : browser$1.windows) == null ? void 0 : _l.onFocusChanged),
    "contextMenus.onClicked": ensureOptional((_m = browser$1 == null ? void 0 : browser$1.contextMenus) == null ? void 0 : _m.onClicked)
  };
  class EventProxy {
    constructor() {
      __publicField(this, "listeners", /* @__PURE__ */ new Map());
    }
    init() {
      for (const [key, value] of Object.entries(proxiedEvents)) {
        if (!value) {
          continue;
        }
        value.addListener((...args) => {
          const listeners = this.listeners.get(key);
          if (!listeners) {
            return;
          }
          const results = [...listeners].map((l) => l(...args));
          const result2 = results.find((r2) => r2) ?? results[0];
          return result2;
        });
      }
    }
    addListener(key, listener) {
      const listeners = this.getListeners(key);
      listeners.add(listener);
    }
    removeListener(key, listener) {
      const listeners = this.getListeners(key);
      listeners.delete(listener);
    }
    getListeners(key) {
      let listeners = this.listeners.get(key);
      if (!listeners) {
        listeners = /* @__PURE__ */ new Set();
        this.listeners.set(key, listeners);
      }
      return listeners;
    }
  }
  function ensureOptional(val) {
    return val;
  }
  const eventProxy = new EventProxy();
  background;
  const definition = defineBackground(() => {
    if (self) {
      self.isInServiceWorker = true;
    }
    if (self && !self.window) {
      self.window = self;
    }
    window.global = window.global ?? window;
    eventProxy.init();
    Promise.resolve().then(() => wrappedIndex);
  });
  background;
  function initPlugins() {
  }
  const browser = browser$1;
  function print(method, ...args) {
    return;
  }
  const logger$2 = {
    debug: (...args) => print(console.debug, ...args),
    log: (...args) => print(console.log, ...args),
    warn: (...args) => print(console.warn, ...args),
    error: (...args) => print(console.error, ...args)
  };
  let result;
  try {
    initPlugins();
    result = definition.main();
    if (result instanceof Promise) {
      console.warn("The background's main() function return a promise, but it must be synchronous");
    }
  } catch (err) {
    logger$2.error("The background crashed on startup!");
    throw err;
  }
  const result$1 = result;
  const BROWSER_ALIASES_MAP = {
    "Amazon Silk": "amazon_silk",
    "Android Browser": "android",
    Bada: "bada",
    BlackBerry: "blackberry",
    Chrome: "chrome",
    Chromium: "chromium",
    Electron: "electron",
    Epiphany: "epiphany",
    Firefox: "firefox",
    Focus: "focus",
    Generic: "generic",
    "Google Search": "google_search",
    Googlebot: "googlebot",
    "Internet Explorer": "ie",
    "K-Meleon": "k_meleon",
    Maxthon: "maxthon",
    "Microsoft Edge": "edge",
    "MZ Browser": "mz",
    "NAVER Whale Browser": "naver",
    Opera: "opera",
    "Opera Coast": "opera_coast",
    PhantomJS: "phantomjs",
    Puffin: "puffin",
    QupZilla: "qupzilla",
    QQ: "qq",
    QQLite: "qqlite",
    Safari: "safari",
    Sailfish: "sailfish",
    "Samsung Internet for Android": "samsung_internet",
    SeaMonkey: "seamonkey",
    Sleipnir: "sleipnir",
    Swing: "swing",
    Tizen: "tizen",
    "UC Browser": "uc",
    Vivaldi: "vivaldi",
    "WebOS Browser": "webos",
    WeChat: "wechat",
    "Yandex Browser": "yandex",
    Roku: "roku"
  };
  const BROWSER_MAP = {
    amazon_silk: "Amazon Silk",
    android: "Android Browser",
    bada: "Bada",
    blackberry: "BlackBerry",
    chrome: "Chrome",
    chromium: "Chromium",
    electron: "Electron",
    epiphany: "Epiphany",
    firefox: "Firefox",
    focus: "Focus",
    generic: "Generic",
    googlebot: "Googlebot",
    google_search: "Google Search",
    ie: "Internet Explorer",
    k_meleon: "K-Meleon",
    maxthon: "Maxthon",
    edge: "Microsoft Edge",
    mz: "MZ Browser",
    naver: "NAVER Whale Browser",
    opera: "Opera",
    opera_coast: "Opera Coast",
    phantomjs: "PhantomJS",
    puffin: "Puffin",
    qupzilla: "QupZilla",
    qq: "QQ Browser",
    qqlite: "QQ Browser Lite",
    safari: "Safari",
    sailfish: "Sailfish",
    samsung_internet: "Samsung Internet for Android",
    seamonkey: "SeaMonkey",
    sleipnir: "Sleipnir",
    swing: "Swing",
    tizen: "Tizen",
    uc: "UC Browser",
    vivaldi: "Vivaldi",
    webos: "WebOS Browser",
    wechat: "WeChat",
    yandex: "Yandex Browser"
  };
  const PLATFORMS_MAP = {
    tablet: "tablet",
    mobile: "mobile",
    desktop: "desktop",
    tv: "tv"
  };
  const OS_MAP = {
    WindowsPhone: "Windows Phone",
    Windows: "Windows",
    MacOS: "macOS",
    iOS: "iOS",
    Android: "Android",
    WebOS: "WebOS",
    BlackBerry: "BlackBerry",
    Bada: "Bada",
    Tizen: "Tizen",
    Linux: "Linux",
    ChromeOS: "Chrome OS",
    PlayStation4: "PlayStation 4",
    Roku: "Roku"
  };
  const ENGINE_MAP = {
    EdgeHTML: "EdgeHTML",
    Blink: "Blink",
    Trident: "Trident",
    Presto: "Presto",
    Gecko: "Gecko",
    WebKit: "WebKit"
  };
  class Utils {
    /**
     * Get first matched item for a string
     * @param {RegExp} regexp
     * @param {String} ua
     * @return {Array|{index: number, input: string}|*|boolean|string}
     */
    static getFirstMatch(regexp, ua) {
      const match2 = ua.match(regexp);
      return match2 && match2.length > 0 && match2[1] || "";
    }
    /**
     * Get second matched item for a string
     * @param regexp
     * @param {String} ua
     * @return {Array|{index: number, input: string}|*|boolean|string}
     */
    static getSecondMatch(regexp, ua) {
      const match2 = ua.match(regexp);
      return match2 && match2.length > 1 && match2[2] || "";
    }
    /**
     * Match a regexp and return a constant or undefined
     * @param {RegExp} regexp
     * @param {String} ua
     * @param {*} _const Any const that will be returned if regexp matches the string
     * @return {*}
     */
    static matchAndReturnConst(regexp, ua, _const) {
      if (regexp.test(ua)) {
        return _const;
      }
      return void 0;
    }
    static getWindowsVersionName(version) {
      switch (version) {
        case "NT":
          return "NT";
        case "XP":
          return "XP";
        case "NT 5.0":
          return "2000";
        case "NT 5.1":
          return "XP";
        case "NT 5.2":
          return "2003";
        case "NT 6.0":
          return "Vista";
        case "NT 6.1":
          return "7";
        case "NT 6.2":
          return "8";
        case "NT 6.3":
          return "8.1";
        case "NT 10.0":
          return "10";
        default:
          return void 0;
      }
    }
    /**
     * Get macOS version name
     *    10.5 - Leopard
     *    10.6 - Snow Leopard
     *    10.7 - Lion
     *    10.8 - Mountain Lion
     *    10.9 - Mavericks
     *    10.10 - Yosemite
     *    10.11 - El Capitan
     *    10.12 - Sierra
     *    10.13 - High Sierra
     *    10.14 - Mojave
     *    10.15 - Catalina
     *
     * @example
     *   getMacOSVersionName("10.14") // 'Mojave'
     *
     * @param  {string} version
     * @return {string} versionName
     */
    static getMacOSVersionName(version) {
      const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
      v2.push(0);
      if (v2[0] !== 10)
        return void 0;
      switch (v2[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return void 0;
      }
    }
    /**
     * Get Android version name
     *    1.5 - Cupcake
     *    1.6 - Donut
     *    2.0 - Eclair
     *    2.1 - Eclair
     *    2.2 - Froyo
     *    2.x - Gingerbread
     *    3.x - Honeycomb
     *    4.0 - Ice Cream Sandwich
     *    4.1 - Jelly Bean
     *    4.4 - KitKat
     *    5.x - Lollipop
     *    6.x - Marshmallow
     *    7.x - Nougat
     *    8.x - Oreo
     *    9.x - Pie
     *
     * @example
     *   getAndroidVersionName("7.0") // 'Nougat'
     *
     * @param  {string} version
     * @return {string} versionName
     */
    static getAndroidVersionName(version) {
      const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
      v2.push(0);
      if (v2[0] === 1 && v2[1] < 5)
        return void 0;
      if (v2[0] === 1 && v2[1] < 6)
        return "Cupcake";
      if (v2[0] === 1 && v2[1] >= 6)
        return "Donut";
      if (v2[0] === 2 && v2[1] < 2)
        return "Eclair";
      if (v2[0] === 2 && v2[1] === 2)
        return "Froyo";
      if (v2[0] === 2 && v2[1] > 2)
        return "Gingerbread";
      if (v2[0] === 3)
        return "Honeycomb";
      if (v2[0] === 4 && v2[1] < 1)
        return "Ice Cream Sandwich";
      if (v2[0] === 4 && v2[1] < 4)
        return "Jelly Bean";
      if (v2[0] === 4 && v2[1] >= 4)
        return "KitKat";
      if (v2[0] === 5)
        return "Lollipop";
      if (v2[0] === 6)
        return "Marshmallow";
      if (v2[0] === 7)
        return "Nougat";
      if (v2[0] === 8)
        return "Oreo";
      if (v2[0] === 9)
        return "Pie";
      return void 0;
    }
    /**
     * Get version precisions count
     *
     * @example
     *   getVersionPrecision("1.10.3") // 3
     *
     * @param  {string} version
     * @return {number}
     */
    static getVersionPrecision(version) {
      return version.split(".").length;
    }
    /**
     * Calculate browser version weight
     *
     * @example
     *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
     *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
     *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
     *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
     *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
     *
     * @param {String} versionA versions versions to compare
     * @param {String} versionB versions versions to compare
     * @param {boolean} [isLoose] enable loose comparison
     * @return {Number} comparison result: -1 when versionA is lower,
     * 1 when versionA is bigger, 0 when both equal
     */
    /* eslint consistent-return: 1 */
    static compareVersions(versionA, versionB, isLoose = false) {
      const versionAPrecision = Utils.getVersionPrecision(versionA);
      const versionBPrecision = Utils.getVersionPrecision(versionB);
      let precision = Math.max(versionAPrecision, versionBPrecision);
      let lastPrecision = 0;
      const chunks = Utils.map([versionA, versionB], (version) => {
        const delta = precision - Utils.getVersionPrecision(version);
        const _version = version + new Array(delta + 1).join(".0");
        return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
      });
      if (isLoose) {
        lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
      }
      precision -= 1;
      while (precision >= lastPrecision) {
        if (chunks[0][precision] > chunks[1][precision]) {
          return 1;
        }
        if (chunks[0][precision] === chunks[1][precision]) {
          if (precision === lastPrecision) {
            return 0;
          }
          precision -= 1;
        } else if (chunks[0][precision] < chunks[1][precision]) {
          return -1;
        }
      }
      return void 0;
    }
    /**
     * Array::map polyfill
     *
     * @param  {Array} arr
     * @param  {Function} iterator
     * @return {Array}
     */
    static map(arr, iterator2) {
      const result2 = [];
      let i2;
      if (Array.prototype.map) {
        return Array.prototype.map.call(arr, iterator2);
      }
      for (i2 = 0; i2 < arr.length; i2 += 1) {
        result2.push(iterator2(arr[i2]));
      }
      return result2;
    }
    /**
     * Array::find polyfill
     *
     * @param  {Array} arr
     * @param  {Function} predicate
     * @return {Array}
     */
    static find(arr, predicate) {
      let i2;
      let l;
      if (Array.prototype.find) {
        return Array.prototype.find.call(arr, predicate);
      }
      for (i2 = 0, l = arr.length; i2 < l; i2 += 1) {
        const value = arr[i2];
        if (predicate(value, i2)) {
          return value;
        }
      }
      return void 0;
    }
    /**
     * Object::assign polyfill
     *
     * @param  {Object} obj
     * @param  {Object} ...objs
     * @return {Object}
     */
    static assign(obj, ...assigners) {
      const result2 = obj;
      let i2;
      let l;
      if (Object.assign) {
        return Object.assign(obj, ...assigners);
      }
      for (i2 = 0, l = assigners.length; i2 < l; i2 += 1) {
        const assigner = assigners[i2];
        if (typeof assigner === "object" && assigner !== null) {
          const keys2 = Object.keys(assigner);
          keys2.forEach((key) => {
            result2[key] = assigner[key];
          });
        }
      }
      return obj;
    }
    /**
     * Get short version/alias for a browser name
     *
     * @example
     *   getBrowserAlias('Microsoft Edge') // edge
     *
     * @param  {string} browserName
     * @return {string}
     */
    static getBrowserAlias(browserName) {
      return BROWSER_ALIASES_MAP[browserName];
    }
    /**
     * Get short version/alias for a browser name
     *
     * @example
     *   getBrowserAlias('edge') // Microsoft Edge
     *
     * @param  {string} browserAlias
     * @return {string}
     */
    static getBrowserTypeByAlias(browserAlias) {
      return BROWSER_MAP[browserAlias] || "";
    }
  }
  const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
  const browsersList = [
    /* Googlebot */
    {
      test: [/googlebot/i],
      describe(ua) {
        const browser2 = {
          name: "Googlebot"
        };
        const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Opera < 13.0 */
    {
      test: [/opera/i],
      describe(ua) {
        const browser2 = {
          name: "Opera"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Opera > 13.0 */
    {
      test: [/opr\/|opios/i],
      describe(ua) {
        const browser2 = {
          name: "Opera"
        };
        const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/SamsungBrowser/i],
      describe(ua) {
        const browser2 = {
          name: "Samsung Internet for Android"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/Whale/i],
      describe(ua) {
        const browser2 = {
          name: "NAVER Whale Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/MZBrowser/i],
      describe(ua) {
        const browser2 = {
          name: "MZ Browser"
        };
        const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/focus/i],
      describe(ua) {
        const browser2 = {
          name: "Focus"
        };
        const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/swing/i],
      describe(ua) {
        const browser2 = {
          name: "Swing"
        };
        const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/coast/i],
      describe(ua) {
        const browser2 = {
          name: "Opera Coast"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/opt\/\d+(?:.?_?\d+)+/i],
      describe(ua) {
        const browser2 = {
          name: "Opera Touch"
        };
        const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/yabrowser/i],
      describe(ua) {
        const browser2 = {
          name: "Yandex Browser"
        };
        const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/ucbrowser/i],
      describe(ua) {
        const browser2 = {
          name: "UC Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/Maxthon|mxios/i],
      describe(ua) {
        const browser2 = {
          name: "Maxthon"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/epiphany/i],
      describe(ua) {
        const browser2 = {
          name: "Epiphany"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/puffin/i],
      describe(ua) {
        const browser2 = {
          name: "Puffin"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/sleipnir/i],
      describe(ua) {
        const browser2 = {
          name: "Sleipnir"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/k-meleon/i],
      describe(ua) {
        const browser2 = {
          name: "K-Meleon"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/micromessenger/i],
      describe(ua) {
        const browser2 = {
          name: "WeChat"
        };
        const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/qqbrowser/i],
      describe(ua) {
        const browser2 = {
          name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
        };
        const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/msie|trident/i],
      describe(ua) {
        const browser2 = {
          name: "Internet Explorer"
        };
        const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/\sedg\//i],
      describe(ua) {
        const browser2 = {
          name: "Microsoft Edge"
        };
        const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/edg([ea]|ios)/i],
      describe(ua) {
        const browser2 = {
          name: "Microsoft Edge"
        };
        const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/vivaldi/i],
      describe(ua) {
        const browser2 = {
          name: "Vivaldi"
        };
        const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/seamonkey/i],
      describe(ua) {
        const browser2 = {
          name: "SeaMonkey"
        };
        const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/sailfish/i],
      describe(ua) {
        const browser2 = {
          name: "Sailfish"
        };
        const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/silk/i],
      describe(ua) {
        const browser2 = {
          name: "Amazon Silk"
        };
        const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/phantom/i],
      describe(ua) {
        const browser2 = {
          name: "PhantomJS"
        };
        const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/slimerjs/i],
      describe(ua) {
        const browser2 = {
          name: "SlimerJS"
        };
        const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(ua) {
        const browser2 = {
          name: "BlackBerry"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/(web|hpw)[o0]s/i],
      describe(ua) {
        const browser2 = {
          name: "WebOS Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/bada/i],
      describe(ua) {
        const browser2 = {
          name: "Bada"
        };
        const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/tizen/i],
      describe(ua) {
        const browser2 = {
          name: "Tizen"
        };
        const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/qupzilla/i],
      describe(ua) {
        const browser2 = {
          name: "QupZilla"
        };
        const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/firefox|iceweasel|fxios/i],
      describe(ua) {
        const browser2 = {
          name: "Firefox"
        };
        const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/electron/i],
      describe(ua) {
        const browser2 = {
          name: "Electron"
        };
        const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/MiuiBrowser/i],
      describe(ua) {
        const browser2 = {
          name: "Miui"
        };
        const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/chromium/i],
      describe(ua) {
        const browser2 = {
          name: "Chromium"
        };
        const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/chrome|crios|crmo/i],
      describe(ua) {
        const browser2 = {
          name: "Chrome"
        };
        const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    {
      test: [/GSA/i],
      describe(ua) {
        const browser2 = {
          name: "Google Search"
        };
        const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Android Browser */
    {
      test(parser) {
        const notLikeAndroid = !parser.test(/like android/i);
        const butAndroid = parser.test(/android/i);
        return notLikeAndroid && butAndroid;
      },
      describe(ua) {
        const browser2 = {
          name: "Android Browser"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* PlayStation 4 */
    {
      test: [/playstation 4/i],
      describe(ua) {
        const browser2 = {
          name: "PlayStation 4"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Safari */
    {
      test: [/safari|applewebkit/i],
      describe(ua) {
        const browser2 = {
          name: "Safari"
        };
        const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
        if (version) {
          browser2.version = version;
        }
        return browser2;
      }
    },
    /* Something else */
    {
      test: [/.*/i],
      describe(ua) {
        const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
        const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
        const hasDeviceSpec = ua.search("\\(") !== -1;
        const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
        return {
          name: Utils.getFirstMatch(regexp, ua),
          version: Utils.getSecondMatch(regexp, ua)
        };
      }
    }
  ];
  const osParsersList = [
    /* Roku */
    {
      test: [/Roku\/DVP/],
      describe(ua) {
        const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
        return {
          name: OS_MAP.Roku,
          version
        };
      }
    },
    /* Windows Phone */
    {
      test: [/windows phone/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
        return {
          name: OS_MAP.WindowsPhone,
          version
        };
      }
    },
    /* Windows */
    {
      test: [/windows /i],
      describe(ua) {
        const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
        const versionName = Utils.getWindowsVersionName(version);
        return {
          name: OS_MAP.Windows,
          version,
          versionName
        };
      }
    },
    /* Firefox on iPad */
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe(ua) {
        const result2 = {
          name: OS_MAP.iOS
        };
        const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
        if (version) {
          result2.version = version;
        }
        return result2;
      }
    },
    /* macOS */
    {
      test: [/macintosh/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
        const versionName = Utils.getMacOSVersionName(version);
        const os = {
          name: OS_MAP.MacOS,
          version
        };
        if (versionName) {
          os.versionName = versionName;
        }
        return os;
      }
    },
    /* iOS */
    {
      test: [/(ipod|iphone|ipad)/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
        return {
          name: OS_MAP.iOS,
          version
        };
      }
    },
    /* Android */
    {
      test(parser) {
        const notLikeAndroid = !parser.test(/like android/i);
        const butAndroid = parser.test(/android/i);
        return notLikeAndroid && butAndroid;
      },
      describe(ua) {
        const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
        const versionName = Utils.getAndroidVersionName(version);
        const os = {
          name: OS_MAP.Android,
          version
        };
        if (versionName) {
          os.versionName = versionName;
        }
        return os;
      }
    },
    /* WebOS */
    {
      test: [/(web|hpw)[o0]s/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
        const os = {
          name: OS_MAP.WebOS
        };
        if (version && version.length) {
          os.version = version;
        }
        return os;
      }
    },
    /* BlackBerry */
    {
      test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
        return {
          name: OS_MAP.BlackBerry,
          version
        };
      }
    },
    /* Bada */
    {
      test: [/bada/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
        return {
          name: OS_MAP.Bada,
          version
        };
      }
    },
    /* Tizen */
    {
      test: [/tizen/i],
      describe(ua) {
        const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
        return {
          name: OS_MAP.Tizen,
          version
        };
      }
    },
    /* Linux */
    {
      test: [/linux/i],
      describe() {
        return {
          name: OS_MAP.Linux
        };
      }
    },
    /* Chrome OS */
    {
      test: [/CrOS/],
      describe() {
        return {
          name: OS_MAP.ChromeOS
        };
      }
    },
    /* Playstation 4 */
    {
      test: [/PlayStation 4/],
      describe(ua) {
        const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
        return {
          name: OS_MAP.PlayStation4,
          version
        };
      }
    }
  ];
  const platformParsersList = [
    /* Googlebot */
    {
      test: [/googlebot/i],
      describe() {
        return {
          type: "bot",
          vendor: "Google"
        };
      }
    },
    /* Huawei */
    {
      test: [/huawei/i],
      describe(ua) {
        const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
        const platform = {
          type: PLATFORMS_MAP.mobile,
          vendor: "Huawei"
        };
        if (model) {
          platform.model = model;
        }
        return platform;
      }
    },
    /* Nexus Tablet */
    {
      test: [/nexus\s*(?:7|8|9|10).*/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Nexus"
        };
      }
    },
    /* iPad */
    {
      test: [/ipad/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Apple",
          model: "iPad"
        };
      }
    },
    /* Firefox on iPad */
    {
      test: [/Macintosh(.*?) FxiOS(.*?)\//],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Apple",
          model: "iPad"
        };
      }
    },
    /* Amazon Kindle Fire */
    {
      test: [/kftt build/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Amazon",
          model: "Kindle Fire HD 7"
        };
      }
    },
    /* Another Amazon Tablet with Silk */
    {
      test: [/silk/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet,
          vendor: "Amazon"
        };
      }
    },
    /* Tablet */
    {
      test: [/tablet(?! pc)/i],
      describe() {
        return {
          type: PLATFORMS_MAP.tablet
        };
      }
    },
    /* iPod/iPhone */
    {
      test(parser) {
        const iDevice = parser.test(/ipod|iphone/i);
        const likeIDevice = parser.test(/like (ipod|iphone)/i);
        return iDevice && !likeIDevice;
      },
      describe(ua) {
        const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "Apple",
          model
        };
      }
    },
    /* Nexus Mobile */
    {
      test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "Nexus"
        };
      }
    },
    /* Mobile */
    {
      test: [/[^-]mobi/i],
      describe() {
        return {
          type: PLATFORMS_MAP.mobile
        };
      }
    },
    /* BlackBerry */
    {
      test(parser) {
        return parser.getBrowserName(true) === "blackberry";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "BlackBerry"
        };
      }
    },
    /* Bada */
    {
      test(parser) {
        return parser.getBrowserName(true) === "bada";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile
        };
      }
    },
    /* Windows Phone */
    {
      test(parser) {
        return parser.getBrowserName() === "windows phone";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile,
          vendor: "Microsoft"
        };
      }
    },
    /* Android Tablet */
    {
      test(parser) {
        const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
        return parser.getOSName(true) === "android" && osMajorVersion >= 3;
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tablet
        };
      }
    },
    /* Android Mobile */
    {
      test(parser) {
        return parser.getOSName(true) === "android";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.mobile
        };
      }
    },
    /* desktop */
    {
      test(parser) {
        return parser.getOSName(true) === "macos";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop,
          vendor: "Apple"
        };
      }
    },
    /* Windows */
    {
      test(parser) {
        return parser.getOSName(true) === "windows";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop
        };
      }
    },
    /* Linux */
    {
      test(parser) {
        return parser.getOSName(true) === "linux";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.desktop
        };
      }
    },
    /* PlayStation 4 */
    {
      test(parser) {
        return parser.getOSName(true) === "playstation 4";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tv
        };
      }
    },
    /* Roku */
    {
      test(parser) {
        return parser.getOSName(true) === "roku";
      },
      describe() {
        return {
          type: PLATFORMS_MAP.tv
        };
      }
    }
  ];
  const enginesParsersList = [
    /* EdgeHTML */
    {
      test(parser) {
        return parser.getBrowserName(true) === "microsoft edge";
      },
      describe(ua) {
        const isBlinkBased = /\sedg\//i.test(ua);
        if (isBlinkBased) {
          return {
            name: ENGINE_MAP.Blink
          };
        }
        const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
        return {
          name: ENGINE_MAP.EdgeHTML,
          version
        };
      }
    },
    /* Trident */
    {
      test: [/trident/i],
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.Trident
        };
        const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    },
    /* Presto */
    {
      test(parser) {
        return parser.test(/presto/i);
      },
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.Presto
        };
        const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    },
    /* Gecko */
    {
      test(parser) {
        const isGecko = parser.test(/gecko/i);
        const likeGecko = parser.test(/like gecko/i);
        return isGecko && !likeGecko;
      },
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.Gecko
        };
        const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    },
    /* Blink */
    {
      test: [/(apple)?webkit\/537\.36/i],
      describe() {
        return {
          name: ENGINE_MAP.Blink
        };
      }
    },
    /* WebKit */
    {
      test: [/(apple)?webkit/i],
      describe(ua) {
        const engine = {
          name: ENGINE_MAP.WebKit
        };
        const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
        if (version) {
          engine.version = version;
        }
        return engine;
      }
    }
  ];
  class Parser {
    /**
     * Create instance of Parser
     *
     * @param {String} UA User-Agent string
     * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
     * improvements if you need to make a more particular parsing
     * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
     *
     * @throw {Error} in case of empty UA String
     *
     * @constructor
     */
    constructor(UA, skipParsing = false) {
      if (UA === void 0 || UA === null || UA === "") {
        throw new Error("UserAgent parameter can't be empty");
      }
      this._ua = UA;
      this.parsedResult = {};
      if (skipParsing !== true) {
        this.parse();
      }
    }
    /**
     * Get UserAgent string of current Parser instance
     * @return {String} User-Agent String of the current <Parser> object
     *
     * @public
     */
    getUA() {
      return this._ua;
    }
    /**
     * Test a UA string for a regexp
     * @param {RegExp} regex
     * @return {Boolean}
     */
    test(regex2) {
      return regex2.test(this._ua);
    }
    /**
     * Get parsed browser object
     * @return {Object}
     */
    parseBrowser() {
      this.parsedResult.browser = {};
      const browserDescriptor = Utils.find(browsersList, (_browser) => {
        if (typeof _browser.test === "function") {
          return _browser.test(this);
        }
        if (_browser.test instanceof Array) {
          return _browser.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (browserDescriptor) {
        this.parsedResult.browser = browserDescriptor.describe(this.getUA());
      }
      return this.parsedResult.browser;
    }
    /**
     * Get parsed browser object
     * @return {Object}
     *
     * @public
     */
    getBrowser() {
      if (this.parsedResult.browser) {
        return this.parsedResult.browser;
      }
      return this.parseBrowser();
    }
    /**
     * Get browser's name
     * @return {String} Browser's name or an empty string
     *
     * @public
     */
    getBrowserName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getBrowser().name).toLowerCase() || "";
      }
      return this.getBrowser().name || "";
    }
    /**
     * Get browser's version
     * @return {String} version of browser
     *
     * @public
     */
    getBrowserVersion() {
      return this.getBrowser().version;
    }
    /**
     * Get OS
     * @return {Object}
     *
     * @example
     * this.getOS();
     * {
     *   name: 'macOS',
     *   version: '10.11.12'
     * }
     */
    getOS() {
      if (this.parsedResult.os) {
        return this.parsedResult.os;
      }
      return this.parseOS();
    }
    /**
     * Parse OS and save it to this.parsedResult.os
     * @return {*|{}}
     */
    parseOS() {
      this.parsedResult.os = {};
      const os = Utils.find(osParsersList, (_os) => {
        if (typeof _os.test === "function") {
          return _os.test(this);
        }
        if (_os.test instanceof Array) {
          return _os.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (os) {
        this.parsedResult.os = os.describe(this.getUA());
      }
      return this.parsedResult.os;
    }
    /**
     * Get OS name
     * @param {Boolean} [toLowerCase] return lower-cased value
     * @return {String} name of the OS — macOS, Windows, Linux, etc.
     */
    getOSName(toLowerCase) {
      const { name } = this.getOS();
      if (toLowerCase) {
        return String(name).toLowerCase() || "";
      }
      return name || "";
    }
    /**
     * Get OS version
     * @return {String} full version with dots ('10.11.12', '5.6', etc)
     */
    getOSVersion() {
      return this.getOS().version;
    }
    /**
     * Get parsed platform
     * @return {{}}
     */
    getPlatform() {
      if (this.parsedResult.platform) {
        return this.parsedResult.platform;
      }
      return this.parsePlatform();
    }
    /**
     * Get platform name
     * @param {Boolean} [toLowerCase=false]
     * @return {*}
     */
    getPlatformType(toLowerCase = false) {
      const { type } = this.getPlatform();
      if (toLowerCase) {
        return String(type).toLowerCase() || "";
      }
      return type || "";
    }
    /**
     * Get parsed platform
     * @return {{}}
     */
    parsePlatform() {
      this.parsedResult.platform = {};
      const platform = Utils.find(platformParsersList, (_platform) => {
        if (typeof _platform.test === "function") {
          return _platform.test(this);
        }
        if (_platform.test instanceof Array) {
          return _platform.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (platform) {
        this.parsedResult.platform = platform.describe(this.getUA());
      }
      return this.parsedResult.platform;
    }
    /**
     * Get parsed engine
     * @return {{}}
     */
    getEngine() {
      if (this.parsedResult.engine) {
        return this.parsedResult.engine;
      }
      return this.parseEngine();
    }
    /**
     * Get engines's name
     * @return {String} Engines's name or an empty string
     *
     * @public
     */
    getEngineName(toLowerCase) {
      if (toLowerCase) {
        return String(this.getEngine().name).toLowerCase() || "";
      }
      return this.getEngine().name || "";
    }
    /**
     * Get parsed platform
     * @return {{}}
     */
    parseEngine() {
      this.parsedResult.engine = {};
      const engine = Utils.find(enginesParsersList, (_engine) => {
        if (typeof _engine.test === "function") {
          return _engine.test(this);
        }
        if (_engine.test instanceof Array) {
          return _engine.test.some((condition) => this.test(condition));
        }
        throw new Error("Browser's test function is not valid");
      });
      if (engine) {
        this.parsedResult.engine = engine.describe(this.getUA());
      }
      return this.parsedResult.engine;
    }
    /**
     * Parse full information about the browser
     * @returns {Parser}
     */
    parse() {
      this.parseBrowser();
      this.parseOS();
      this.parsePlatform();
      this.parseEngine();
      return this;
    }
    /**
     * Get parsed result
     * @return {ParsedResult}
     */
    getResult() {
      return Utils.assign({}, this.parsedResult);
    }
    /**
     * Check if parsed browser matches certain conditions
     *
     * @param {Object} checkTree It's one or two layered object,
     * which can include a platform or an OS on the first layer
     * and should have browsers specs on the bottom-laying layer
     *
     * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
     * Returns `undefined` when the browser is no described in the checkTree object.
     *
     * @example
     * const browser = Bowser.getParser(window.navigator.userAgent);
     * if (browser.satisfies({chrome: '>118.01.1322' }))
     * // or with os
     * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
     * // or with platforms
     * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
     */
    satisfies(checkTree) {
      const platformsAndOSes = {};
      let platformsAndOSCounter = 0;
      const browsers = {};
      let browsersCounter = 0;
      const allDefinitions = Object.keys(checkTree);
      allDefinitions.forEach((key) => {
        const currentDefinition = checkTree[key];
        if (typeof currentDefinition === "string") {
          browsers[key] = currentDefinition;
          browsersCounter += 1;
        } else if (typeof currentDefinition === "object") {
          platformsAndOSes[key] = currentDefinition;
          platformsAndOSCounter += 1;
        }
      });
      if (platformsAndOSCounter > 0) {
        const platformsAndOSNames = Object.keys(platformsAndOSes);
        const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
        if (OSMatchingDefinition) {
          const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
          if (osResult !== void 0) {
            return osResult;
          }
        }
        const platformMatchingDefinition = Utils.find(
          platformsAndOSNames,
          (name) => this.isPlatform(name)
        );
        if (platformMatchingDefinition) {
          const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
          if (platformResult !== void 0) {
            return platformResult;
          }
        }
      }
      if (browsersCounter > 0) {
        const browserNames = Object.keys(browsers);
        const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
        if (matchingDefinition !== void 0) {
          return this.compareVersion(browsers[matchingDefinition]);
        }
      }
      return void 0;
    }
    /**
     * Check if the browser name equals the passed string
     * @param browserName The string to compare with the browser name
     * @param [includingAlias=false] The flag showing whether alias will be included into comparison
     * @returns {boolean}
     */
    isBrowser(browserName, includingAlias = false) {
      const defaultBrowserName = this.getBrowserName().toLowerCase();
      let browserNameLower = browserName.toLowerCase();
      const alias = Utils.getBrowserTypeByAlias(browserNameLower);
      if (includingAlias && alias) {
        browserNameLower = alias.toLowerCase();
      }
      return browserNameLower === defaultBrowserName;
    }
    compareVersion(version) {
      let expectedResults = [0];
      let comparableVersion = version;
      let isLoose = false;
      const currentBrowserVersion = this.getBrowserVersion();
      if (typeof currentBrowserVersion !== "string") {
        return void 0;
      }
      if (version[0] === ">" || version[0] === "<") {
        comparableVersion = version.substr(1);
        if (version[1] === "=") {
          isLoose = true;
          comparableVersion = version.substr(2);
        } else {
          expectedResults = [];
        }
        if (version[0] === ">") {
          expectedResults.push(1);
        } else {
          expectedResults.push(-1);
        }
      } else if (version[0] === "=") {
        comparableVersion = version.substr(1);
      } else if (version[0] === "~") {
        isLoose = true;
        comparableVersion = version.substr(1);
      }
      return expectedResults.indexOf(
        Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
      ) > -1;
    }
    isOS(osName) {
      return this.getOSName(true) === String(osName).toLowerCase();
    }
    isPlatform(platformType) {
      return this.getPlatformType(true) === String(platformType).toLowerCase();
    }
    isEngine(engineName) {
      return this.getEngineName(true) === String(engineName).toLowerCase();
    }
    /**
     * Is anything? Check if the browser is called "anything",
     * the OS called "anything" or the platform called "anything"
     * @param {String} anything
     * @param [includingAlias=false] The flag showing whether alias will be included into comparison
     * @returns {Boolean}
     */
    is(anything, includingAlias = false) {
      return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
    }
    /**
     * Check if any of the given values satisfies this.is(anything)
     * @param {String[]} anythings
     * @returns {Boolean}
     */
    some(anythings = []) {
      return anythings.some((anything) => this.is(anything));
    }
  }
  /*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   */
  class Bowser {
    /**
     * Creates a {@link Parser} instance
     *
     * @param {String} UA UserAgent string
     * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
     * explicitly. Same as `skipParsing` for {@link Parser}.
     * @returns {Parser}
     * @throws {Error} when UA is not a String
     *
     * @example
     * const parser = Bowser.getParser(window.navigator.userAgent);
     * const result = parser.getResult();
     */
    static getParser(UA, skipParsing = false) {
      if (typeof UA !== "string") {
        throw new Error("UserAgent should be a string");
      }
      return new Parser(UA, skipParsing);
    }
    /**
     * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
     *
     * @param UA
     * @return {ParsedResult}
     *
     * @example
     * const result = Bowser.parse(window.navigator.userAgent);
     */
    static parse(UA) {
      return new Parser(UA).getResult();
    }
    static get BROWSER_MAP() {
      return BROWSER_MAP;
    }
    static get ENGINE_MAP() {
      return ENGINE_MAP;
    }
    static get OS_MAP() {
      return OS_MAP;
    }
    static get PLATFORMS_MAP() {
      return PLATFORMS_MAP;
    }
  }
  function assert$6(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(enumObject) {
    const t = enumObject[enumTypeSymbol];
    assert$6(t, "missing enum type on enum object");
    return t;
  }
  function setEnumType(enumObject, typeName, values, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v2) => ({
      no: v2.no,
      name: v2.name,
      localName: enumObject[v2.no]
    })));
  }
  function makeEnumType(typeName, values, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values) {
      const n = normalizeEnumValue(value);
      normalValues.push(n);
      names[value.name] = n;
      numbers[value.no] = n;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      }
    };
  }
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n = normalizeEnumValue(value);
      enumObject[n.localName] = n.no;
      enumObject[n.no] = n.localName;
    }
    setEnumType(enumObject, typeName, values);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), { localName: value.name });
  }
  class Message {
    /**
     * Compare with a message of the same type.
     * Note that this function disregards extensions and unknown fields.
     */
    equals(other) {
      return this.getType().runtime.util.equals(this.getType(), this, other);
    }
    /**
     * Create a deep copy.
     */
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    /**
     * Parse from binary data, merging fields.
     *
     * Repeated fields are appended. Map entries are added, overwriting
     * existing keys.
     *
     * If a message field is already present, it will be merged with the
     * new data.
     */
    fromBinary(bytes, options) {
      const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
      format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
      return this;
    }
    /**
     * Parse a message from a JSON value.
     */
    fromJson(jsonValue, options) {
      const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
      format.readMessage(type, jsonValue, opt, this);
      return this;
    }
    /**
     * Parse a message from a JSON string.
     */
    fromJsonString(jsonString, options) {
      let json;
      try {
        json = JSON.parse(jsonString);
      } catch (e) {
        throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
      }
      return this.fromJson(json, options);
    }
    /**
     * Serialize the message to binary data.
     */
    toBinary(options) {
      const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
      bin.writeMessage(this, writer, opt);
      return writer.finish();
    }
    /**
     * Serialize the message to a JSON value, a JavaScript value that can be
     * passed to JSON.stringify().
     */
    toJson(options) {
      const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
      return json.writeMessage(this, opt);
    }
    /**
     * Serialize the message to a JSON string.
     */
    toJsonString(options) {
      var _a2;
      const value = this.toJson(options);
      return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
    }
    /**
     * Override for serialization behavior. This will be invoked when calling
     * JSON.stringify on this message (i.e. JSON.stringify(msg)).
     *
     * Note that this will not serialize google.protobuf.Any with a packed
     * message because the protobuf JSON format specifies that it needs to be
     * unpacked, and this is only possible with a type registry to look up the
     * message type.  As a result, attempting to serialize a message with this
     * type will throw an Error.
     *
     * This method is protected because you should not need to invoke it
     * directly -- instead use JSON.stringify or toJsonString for
     * stringified JSON.  Alternatively, if actual JSON is desired, you should
     * use toJson.
     */
    toJSON() {
      return this.toJson({
        emitDefaultValues: true
      });
    }
    /**
     * Retrieve the MessageType of this message - a singleton that represents
     * the protobuf message declaration and provides metadata for reflection-
     * based operations.
     */
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  }
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a2;
    const localName = (_a2 = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a2 !== void 0 ? _a2 : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName];
    Object.setPrototypeOf(type.prototype, new Message());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a2, b) {
        return runtime.util.equals(type, a2, b);
      }
    });
    return type;
  }
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
      const shift = lo >>> i2;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
      const shift = hi >>> i2;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  const TWO_PWR_32_DBL = 4294967296;
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base2 = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base2;
      lowBits = lowBits * base2 + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result2 = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result2 : result2;
  }
  function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base2 = 1e7;
    if (digitA >= base2) {
      digitB += Math.floor(digitA / base2);
      digitA %= base2;
    }
    if (digitB >= base2) {
      digitC += Math.floor(digitB / base2);
      digitB %= base2;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return { lo: lo >>> 0, hi: hi >>> 0 };
  }
  function newBits(lo, hi) {
    return { lo: lo | 0, hi: hi | 0 };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  const decimalFrom1e7WithLeadingZeros = (digit1e7) => {
    const partial = String(digit1e7);
    return "0000000".slice(partial.length) + partial;
  };
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i2 = 0; i2 < 9; i2++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b = this.buf[this.pos++];
    let result2 = b & 127;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b = this.buf[this.pos++];
    result2 |= (b & 127) << 7;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b = this.buf[this.pos++];
    result2 |= (b & 127) << 14;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b = this.buf[this.pos++];
    result2 |= (b & 127) << 21;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result2;
    }
    b = this.buf[this.pos++];
    result2 |= (b & 15) << 28;
    for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result2 >>> 0;
  }
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error(`int64 invalid: ${value}`);
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error(`uint64 invalid: ${value}`);
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert$6(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
    const assertUInt64String = (value) => assert$6(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  const protoInt64 = makeInt64Support();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
  })(LongType || (LongType = {}));
  function scalarEquals(type, a2, b) {
    if (a2 === b) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a2 instanceof Uint8Array) || !(b instanceof Uint8Array)) {
        return false;
      }
      if (a2.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a2 == b;
    }
    return false;
  }
  function scalarZeroValue(type, longType) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return longType == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(type, value) {
    switch (type) {
      case ScalarType.BOOL:
        return value === false;
      case ScalarType.STRING:
        return value === "";
      case ScalarType.BYTES:
        return value instanceof Uint8Array && !value.byteLength;
      default:
        return value == 0;
    }
  }
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType || (WireType = {}));
  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
      this.chunks = [];
      this.buf = [];
    }
    /**
     * Return all bytes written and reset this writer.
     */
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++)
        len += this.chunks[i2].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i2 = 0; i2 < this.chunks.length; i2++) {
        bytes.set(this.chunks[i2], offset);
        offset += this.chunks[i2].length;
      }
      this.chunks = [];
      return bytes;
    }
    /**
     * Start a new fork for length-delimited data like a message
     * or a packed repeated field.
     *
     * Must be joined later with `join()`.
     */
    fork() {
      this.stack.push({ chunks: this.chunks, buf: this.buf });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    /**
     * Join the last fork. Write its length and bytes, then
     * return to the previous state.
     */
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Writes a tag (field number and wire type).
     *
     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
     *
     * Generated code should compute the tag ahead of time and call `uint32()`.
     */
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    /**
     * Write a chunk of raw bytes.
     */
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    /**
     * Write a `uint32` value, an unsigned 32 bit varint.
     */
    uint32(value) {
      assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    /**
     * Write a `int32` value, a signed 32 bit varint.
     */
    int32(value) {
      assertInt32(value);
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `bool` value, a variant.
     */
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    /**
     * Write a `bytes` value, length-delimited arbitrary data.
     */
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    /**
     * Write a `string` value, length-delimited data converted to UTF-8 text.
     */
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    /**
     * Write a `float` value, 32-bit floating point number.
     */
    float(value) {
      assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `double` value, a 64-bit floating point number.
     */
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
     */
    fixed32(value) {
      assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
     */
    sfixed32(value) {
      assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    /**
     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
     */
    sint32(value) {
      assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      varint32write(value, this.buf);
      return this;
    }
    /**
     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
     */
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
     */
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
      view.setInt32(0, tc.lo, true);
      view.setInt32(4, tc.hi, true);
      return this.raw(chunk);
    }
    /**
     * Write a `int64` value, a signed 64-bit varint.
     */
    int64(value) {
      let tc = protoInt64.enc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
    /**
     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64(value) {
      let tc = protoInt64.enc(value), sign2 = tc.hi >> 31, lo = tc.lo << 1 ^ sign2, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign2;
      varint64write(lo, hi, this.buf);
      return this;
    }
    /**
     * Write a `uint64` value, an unsigned 64-bit varint.
     */
    uint64(value) {
      let tc = protoInt64.uEnc(value);
      varint64write(tc.lo, tc.hi, this.buf);
      return this;
    }
  }
  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = varint64read;
      this.uint32 = varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
    }
    /**
     * Reads a tag - field number and wire type.
     */
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    /**
     * Skip one element and return the skipped data.
     *
     * When skipping StartGroup, provide the tags field number to check for
     * matching field number in the EndGroup tag.
     */
    skip(wireType, fieldNo) {
      let start = this.pos;
      switch (wireType) {
        case WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        case WireType.Bit64:
          this.pos += 4;
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case WireType.StartGroup:
          for (; ; ) {
            const [fn, wt] = this.tag();
            if (wt === WireType.EndGroup) {
              if (fieldNo !== void 0 && fn !== fieldNo) {
                throw new Error("invalid end group tag");
              }
              break;
            }
            this.skip(wt, fn);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    /**
     * Throws error if position in byte array is out of range.
     */
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    /**
     * Read a `int32` field, a signed 32 bit varint.
     */
    int32() {
      return this.uint32() | 0;
    }
    /**
     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
     */
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    /**
     * Read a `int64` field, a signed 64-bit varint.
     */
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    /**
     * Read a `uint64` field, an unsigned 64-bit varint.
     */
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    /**
     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
     */
    sint64() {
      let [lo, hi] = this.varint64();
      let s2 = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s2;
      hi = hi >>> 1 ^ s2;
      return protoInt64.dec(lo, hi);
    }
    /**
     * Read a `bool` field, a variant.
     */
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    /**
     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
     */
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
     */
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
     */
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
     */
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    /**
     * Read a `float` field, 32-bit floating point number.
     */
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    /**
     * Read a `double` field, a 64-bit floating point number.
     */
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    /**
     * Read a `bytes` field, length-delimited arbitrary data.
     */
    bytes() {
      let len = this.uint32(), start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    /**
     * Read a `string` field, length-delimited data converted to UTF-8 text.
     */
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  function makeExtension(runtime, typeName, extendee, field) {
    let fi;
    return {
      typeName,
      extendee,
      get field() {
        if (!fi) {
          const i2 = typeof field == "function" ? field() : field;
          i2.name = typeName.split(".").pop();
          i2.jsonName = `[${typeName}]`;
          fi = runtime.util.newFieldList([i2]).list()[0];
        }
        return fi;
      },
      runtime
    };
  }
  function createExtensionContainer(extension) {
    const localName = extension.field.localName;
    const container = /* @__PURE__ */ Object.create(null);
    container[localName] = initExtensionField(extension);
    return [container, () => container[localName]];
  }
  function initExtensionField(ext) {
    const field = ext.field;
    if (field.repeated) {
      return [];
    }
    if (field.default !== void 0) {
      return field.default;
    }
    switch (field.kind) {
      case "enum":
        return field.T.values[0].no;
      case "scalar":
        return scalarZeroValue(field.T, field.L);
      case "message":
        const T = field.T, value = new T();
        return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(unknownFields, field) {
    if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
      for (let i2 = unknownFields.length - 1; i2 >= 0; --i2) {
        if (unknownFields[i2].no == field.no) {
          return [unknownFields[i2]];
        }
      }
      return [];
    }
    return unknownFields.filter((uf) => uf.no === field.no);
  }
  let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  let decTable = [];
  for (let i2 = 0; i2 < encTable.length; i2++)
    decTable[encTable[i2].charCodeAt(0)] = i2;
  decTable["-".charCodeAt(0)] = encTable.indexOf("+");
  decTable["_".charCodeAt(0)] = encTable.indexOf("/");
  const protoBase64 = {
    /**
     * Decodes a base64 string to a byte array.
     *
     * - ignores white-space, including line breaks and tabs
     * - allows inner padding (can decode concatenated base64 strings)
     * - does not require padding
     * - understands base64url encoding:
     *   "-" instead of "+",
     *   "_" instead of "/",
     *   no padding
     */
    dec(base64Str) {
      let es = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p2 = 0;
      for (let i2 = 0; i2 < base64Str.length; i2++) {
        b = decTable[base64Str.charCodeAt(i2)];
        if (b === void 0) {
          switch (base64Str[i2]) {
            case "=":
              groupPos = 0;
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            default:
              throw Error("invalid base64 string.");
          }
        }
        switch (groupPos) {
          case 0:
            p2 = b;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p2 << 2 | (b & 48) >> 4;
            p2 = b;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p2 & 15) << 4 | (b & 60) >> 2;
            p2 = b;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p2 & 3) << 6 | b;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string.");
      return bytes.subarray(0, bytePos);
    },
    /**
     * Encode a byte array to a base64 string.
     */
    enc(bytes) {
      let base64 = "", groupPos = 0, b, p2 = 0;
      for (let i2 = 0; i2 < bytes.length; i2++) {
        b = bytes[i2];
        switch (groupPos) {
          case 0:
            base64 += encTable[b >> 2];
            p2 = (b & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += encTable[p2 | b >> 4];
            p2 = (b & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += encTable[p2 | b >> 6];
            base64 += encTable[b & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += encTable[p2];
        base64 += "=";
        if (groupPos == 1)
          base64 += "=";
      }
      return base64;
    }
  };
  function getExtension(message, extension, options) {
    assertExtendee(extension, message);
    const opt = extension.runtime.bin.makeReadOptions(options);
    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
    const [container, get] = createExtensionContainer(extension);
    for (const uf of ufs) {
      extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
    }
    return get();
  }
  function setExtension(message, extension, value, options) {
    assertExtendee(extension, message);
    const readOpt = extension.runtime.bin.makeReadOptions(options);
    const writeOpt = extension.runtime.bin.makeWriteOptions(options);
    if (hasExtension(message, extension)) {
      const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
      message.getType().runtime.bin.discardUnknownFields(message);
      for (const uf of ufs) {
        message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
      }
    }
    const writer = writeOpt.writerFactory();
    let f2 = extension.field;
    if (!f2.opt && !f2.repeated && (f2.kind == "enum" || f2.kind == "scalar")) {
      f2 = Object.assign(Object.assign({}, extension.field), { opt: true });
    }
    extension.runtime.bin.writeField(f2, value, writer, writeOpt);
    const reader = readOpt.readerFactory(writer.finish());
    while (reader.pos < reader.len) {
      const [no, wireType] = reader.tag();
      const data = reader.skip(wireType, no);
      message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
    }
  }
  function hasExtension(message, extension) {
    const messageType = message.getType();
    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
  }
  function assertExtendee(extension, message) {
    assert$6(extension.extendee.typeName == message.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
  }
  function isFieldSet(field, target) {
    const localName = field.localName;
    if (field.repeated) {
      return target[localName].length > 0;
    }
    if (field.oneof) {
      return target[field.oneof.localName].case === localName;
    }
    switch (field.kind) {
      case "enum":
      case "scalar":
        if (field.opt || field.req) {
          return target[localName] !== void 0;
        }
        if (field.kind == "enum") {
          return target[localName] !== field.T.values[0].no;
        }
        return !isScalarZeroValue(field.T, target[localName]);
      case "message":
        return target[localName] !== void 0;
      case "map":
        return Object.keys(target[localName]).length > 0;
    }
  }
  function clearField(field, target) {
    const localName = field.localName;
    const implicitPresence = !field.opt && !field.req;
    if (field.repeated) {
      target[localName] = [];
    } else if (field.oneof) {
      target[field.oneof.localName] = { case: void 0 };
    } else {
      switch (field.kind) {
        case "map":
          target[localName] = {};
          break;
        case "enum":
          target[localName] = implicitPresence ? field.T.values[0].no : void 0;
          break;
        case "scalar":
          target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
          break;
        case "message":
          target[localName] = void 0;
          break;
      }
    }
  }
  function isMessage(arg, type) {
    if (arg === null || typeof arg != "object") {
      return false;
    }
    if (!Object.getOwnPropertyNames(Message.prototype).every((m2) => m2 in arg && typeof arg[m2] == "function")) {
      return false;
    }
    const actualType = arg.getType();
    if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
      return false;
    }
    return type === void 0 ? true : actualType.typeName == type.typeName;
  }
  function wrapField(type, value) {
    if (isMessage(value) || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  ({
    "google.protobuf.DoubleValue": ScalarType.DOUBLE,
    "google.protobuf.FloatValue": ScalarType.FLOAT,
    "google.protobuf.Int64Value": ScalarType.INT64,
    "google.protobuf.UInt64Value": ScalarType.UINT64,
    "google.protobuf.Int32Value": ScalarType.INT32,
    "google.protobuf.UInt32Value": ScalarType.UINT32,
    "google.protobuf.BoolValue": ScalarType.BOOL,
    "google.protobuf.StringValue": ScalarType.STRING,
    "google.protobuf.BytesValue": ScalarType.BYTES
  });
  const jsonReadDefaults = {
    ignoreUnknownFields: false
  };
  const jsonWriteDefaults = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  function makeReadOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions$1(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  const tokenNull = Symbol();
  const tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions: makeReadOptions$1,
      makeWriteOptions: makeWriteOptions$1,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error(`cannot decode message ${type.typeName} from JSON: ${debugJsonValue(json)}`);
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = /* @__PURE__ */ new Map();
        const registry = options.typeRegistry;
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (field) {
            if (field.oneof) {
              if (jsonValue === null && field.kind == "scalar") {
                continue;
              }
              const seen = oneofSeen.get(field.oneof);
              if (seen !== void 0) {
                throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
              }
              oneofSeen.set(field.oneof, jsonKey);
            }
            readField$1(message, jsonValue, field, options, type);
          } else {
            let found = false;
            if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
              const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
              if (ext && ext.extendee.typeName == type.typeName) {
                found = true;
                const [container, get] = createExtensionContainer(ext);
                readField$1(container, jsonValue, ext.field, options, ext);
                setExtension(message, ext, get(), options);
              }
            }
            if (!found && !options.ignoreUnknownFields) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (field of type.fields.byNumber()) {
            if (!isFieldSet(field, message)) {
              if (field.req) {
                throw `required field not set`;
              }
              if (!options.emitDefaultValues) {
                continue;
              }
              if (!canEmitFieldDefaultValue(field)) {
                continue;
              }
            }
            const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
            const jsonValue = writeField$1(field, value, options);
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
          const registry = options.typeRegistry;
          if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
            for (const uf of type.runtime.bin.listUnknownFields(message)) {
              const ext = registry.findExtensionFor(type.typeName, uf.no);
              if (ext && hasExtension(message, ext)) {
                const value = getExtension(message, ext, options);
                const jsonValue = writeField$1(ext.field, value, options);
                if (jsonValue !== void 0) {
                  json[ext.field.jsonName] = jsonValue;
                }
              }
            }
          }
        } catch (e) {
          const m2 = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
          const r2 = e instanceof Error ? e.message : String(e);
          throw new Error(m2 + (r2.length > 0 ? `: ${r2}` : ""));
        }
        return json;
      },
      readScalar(type, json, longType) {
        return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
      },
      writeScalar(type, value, emitDefaultValues) {
        if (value === void 0) {
          return void 0;
        }
        if (emitDefaultValues || isScalarZeroValue(type, value)) {
          return writeScalar$1(type, value);
        }
        return void 0;
      },
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
      default:
        return String(json);
    }
  }
  function readField$1(target, jsonValue, field, options, parentType) {
    let localName = field.localName;
    if (field.repeated) {
      assert$6(field.kind != "map");
      if (jsonValue === null) {
        return;
      }
      if (!Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetArray = target[localName];
      for (const jsonItem of jsonValue) {
        if (jsonItem === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
        }
        switch (field.kind) {
          case "message":
            targetArray.push(field.T.fromJson(jsonItem, options));
            break;
          case "enum":
            const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetArray.push(enumValue);
            }
            break;
          case "scalar":
            try {
              targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));
            } catch (e) {
              let m2 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
              if (e instanceof Error && e.message.length > 0) {
                m2 += `: ${e.message}`;
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else if (field.kind == "map") {
      if (jsonValue === null) {
        return;
      }
      if (typeof jsonValue != "object" || Array.isArray(jsonValue)) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`);
      }
      const targetMap = target[localName];
      for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
        if (jsonMapValue === null) {
          throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
        }
        let key;
        try {
          key = readMapKey(field.K, jsonMapKey);
        } catch (e) {
          let m2 = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
          if (e instanceof Error && e.message.length > 0) {
            m2 += `: ${e.message}`;
          }
          throw new Error(m2);
        }
        switch (field.V.kind) {
          case "message":
            targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
            break;
          case "enum":
            const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
            if (enumValue !== tokenIgnoredUnknownEnum) {
              targetMap[key] = enumValue;
            }
            break;
          case "scalar":
            try {
              targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);
            } catch (e) {
              let m2 = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
              if (e instanceof Error && e.message.length > 0) {
                m2 += `: ${e.message}`;
              }
              throw new Error(m2);
            }
            break;
        }
      }
    } else {
      if (field.oneof) {
        target = target[field.oneof.localName] = { case: localName };
        localName = "value";
      }
      switch (field.kind) {
        case "message":
          const messageType = field.T;
          if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
            return;
          }
          let currentValue = target[localName];
          if (isMessage(currentValue)) {
            currentValue.fromJson(jsonValue, options);
          } else {
            target[localName] = currentValue = messageType.fromJson(jsonValue, options);
            if (messageType.fieldWrapper && !field.oneof) {
              target[localName] = messageType.fieldWrapper.unwrapField(currentValue);
            }
          }
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);
          switch (enumValue) {
            case tokenNull:
              clearField(field, target);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              target[localName] = enumValue;
              break;
          }
          break;
        case "scalar":
          try {
            const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);
            switch (scalarValue) {
              case tokenNull:
                clearField(field, target);
                break;
              default:
                target[localName] = scalarValue;
                break;
            }
          } catch (e) {
            let m2 = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue)}`;
            if (e instanceof Error && e.message.length > 0) {
              m2 += `: ${e.message}`;
            }
            throw new Error(m2);
          }
          break;
      }
    }
  }
  function readMapKey(type, json) {
    if (type === ScalarType.BOOL) {
      switch (json) {
        case "true":
          json = true;
          break;
        case "false":
          json = false;
          break;
      }
    }
    return readScalar$1(type, json, LongType.BIGINT, true).toString();
  }
  function readScalar$1(type, json, longType, nullAsZeroValue) {
    if (json === null) {
      if (nullAsZeroValue) {
        return scalarZeroValue(type, longType);
      }
      return tokenNull;
    }
    switch (type) {
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type == ScalarType.UINT32 || type == ScalarType.FIXED32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const long = protoInt64.parse(json);
        return longType ? long.toString() : long;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof json != "number" && typeof json != "string")
          break;
        const uLong = protoInt64.uParse(json);
        return longType ? uLong.toString() : uLong;
      case ScalarType.BOOL:
        if (typeof json !== "boolean")
          break;
        return json;
      case ScalarType.STRING:
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e) {
          throw new Error("invalid UTF8");
        }
        return json;
      case ScalarType.BYTES:
        if (json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {
    if (json === null) {
      if (type.typeName == "google.protobuf.NullValue") {
        return 0;
      }
      return nullAsZeroValue ? type.values[0].no : tokenNull;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value !== void 0) {
          return value.no;
        }
        if (ignoreUnknownFields) {
          return tokenIgnoredUnknownEnum;
        }
        break;
    }
    throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
  }
  function canEmitFieldDefaultValue(field) {
    if (field.repeated || field.kind == "map") {
      return true;
    }
    if (field.oneof) {
      return false;
    }
    if (field.kind == "message") {
      return false;
    }
    if (field.opt || field.req) {
      return false;
    }
    return true;
  }
  function writeField$1(field, value, options) {
    if (field.kind == "map") {
      assert$6(typeof value == "object" && value != null);
      const jsonObj = {};
      const entries = Object.entries(value);
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue);
          }
          break;
        case "message":
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = entryValue.toJson(options);
          }
          break;
        case "enum":
          const enumType2 = field.V.T;
          for (const [entryKey, entryValue] of entries) {
            jsonObj[entryKey.toString()] = writeEnum(enumType2, entryValue, options.enumAsInteger);
          }
          break;
      }
      return options.emitDefaultValues || entries.length > 0 ? jsonObj : void 0;
    }
    if (field.repeated) {
      assert$6(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeScalar$1(field.T, value[i2]));
          }
          break;
        case "enum":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(writeEnum(field.T, value[i2], options.enumAsInteger));
          }
          break;
        case "message":
          for (let i2 = 0; i2 < value.length; i2++) {
            jsonArr.push(value[i2].toJson(options));
          }
          break;
      }
      return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
    }
    switch (field.kind) {
      case "scalar":
        return writeScalar$1(field.T, value);
      case "enum":
        return writeEnum(field.T, value, options.enumAsInteger);
      case "message":
        return wrapField(field.T, value).toJson(options);
    }
  }
  function writeEnum(type, value, enumAsInteger) {
    var _a2;
    assert$6(typeof value == "number");
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    if (enumAsInteger) {
      return value;
    }
    const val = type.findNumber(value);
    return (_a2 = val === null || val === void 0 ? void 0 : val.name) !== null && _a2 !== void 0 ? _a2 : value;
  }
  function writeScalar$1(type, value) {
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert$6(typeof value == "number");
        return value;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        assert$6(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      case ScalarType.STRING:
        assert$6(typeof value == "string");
        return value;
      case ScalarType.BOOL:
        assert$6(typeof value == "boolean");
        return value;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert$6(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return value.toString();
      case ScalarType.BYTES:
        assert$6(value instanceof Uint8Array);
        return protoBase64.enc(value);
    }
  }
  const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
  const readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  const writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter()
  };
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a2;
        return (_a2 = message[unknownFieldsSymbol]) !== null && _a2 !== void 0 ? _a2 : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer) {
        const m2 = message;
        const c2 = m2[unknownFieldsSymbol];
        if (c2) {
          for (const f2 of c2) {
            writer.tag(f2.no, f2.wireType).raw(f2.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m2 = message;
        if (!Array.isArray(m2[unknownFieldsSymbol])) {
          m2[unknownFieldsSymbol] = [];
        }
        m2[unknownFieldsSymbol].push({ no, wireType, data });
      },
      readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
        const type = message.getType();
        const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
        let fieldNo, wireType;
        while (reader.pos < end) {
          [fieldNo, wireType] = reader.tag();
          if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
            break;
          }
          const field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType, fieldNo);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          readField(message, reader, field, wireType, options);
        }
        if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
        (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
          throw new Error(`invalid end group tag`);
        }
      },
      readField,
      writeMessage(message, writer, options) {
        const type = message.getType();
        for (const field of type.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
            }
            continue;
          }
          const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          writeField(field, value, writer, options);
        }
        if (options.writeUnknownFields) {
          this.writeUnknownFields(message, writer);
        }
        return writer;
      },
      writeField(field, value, writer, options) {
        if (value === void 0) {
          return void 0;
        }
        writeField(field, value, writer, options);
      }
    };
  }
  function readField(target, reader, field, wireType, options) {
    let { repeated, localName } = field;
    if (field.oneof) {
      target = target[field.oneof.localName];
      if (target.case != localName) {
        delete target.value;
      }
      target.case = localName;
      localName = "value";
    }
    switch (field.kind) {
      case "scalar":
      case "enum":
        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        let read = readScalar;
        if (field.kind == "scalar" && field.L > 0) {
          read = readScalarLTString;
        }
        if (repeated) {
          let arr = target[localName];
          const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
          if (isPacked) {
            let e = reader.uint32() + reader.pos;
            while (reader.pos < e) {
              arr.push(read(reader, scalarType));
            }
          } else {
            arr.push(read(reader, scalarType));
          }
        } else {
          target[localName] = read(reader, scalarType);
        }
        break;
      case "message":
        const messageType = field.T;
        if (repeated) {
          target[localName].push(readMessageField(reader, new messageType(), options, field));
        } else {
          if (isMessage(target[localName])) {
            readMessageField(reader, target[localName], options, field);
          } else {
            target[localName] = readMessageField(reader, new messageType(), options, field);
            if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
              target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
            }
          }
        }
        break;
      case "map":
        let [mapKey, mapVal] = readMapEntry(field, reader, options);
        target[localName][mapKey] = mapVal;
        break;
    }
  }
  function readMessageField(reader, message, options, field) {
    const format = message.getType().runtime.bin;
    const delimited = field === null || field === void 0 ? void 0 : field.delimited;
    format.readMessage(
      message,
      reader,
      delimited ? field.no : reader.uint32(),
      // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      options,
      delimited
    );
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      const [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options, void 0);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      key = scalarZeroValue(field.K, LongType.BIGINT);
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarZeroValue(field.V.T, LongType.BIGINT);
          break;
        case "enum":
          val = field.V.T.values[0].no;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalarLTString(reader, type) {
    const v2 = readScalar(reader, type);
    return typeof v2 == "bigint" ? v2.toString() : v2;
  }
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeField(field, value, writer, options) {
    assert$6(value !== void 0);
    const repeated = field.repeated;
    switch (field.kind) {
      case "scalar":
      case "enum":
        let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (repeated) {
          assert$6(Array.isArray(value));
          if (field.packed) {
            writePacked(writer, scalarType, field.no, value);
          } else {
            for (const item of value) {
              writeScalar(writer, scalarType, field.no, item);
            }
          }
        } else {
          writeScalar(writer, scalarType, field.no, value);
        }
        break;
      case "message":
        if (repeated) {
          assert$6(Array.isArray(value));
          for (const item of value) {
            writeMessageField(writer, options, field, item);
          }
        } else {
          writeMessageField(writer, options, field, value);
        }
        break;
      case "map":
        assert$6(typeof value == "object" && value != null);
        for (const [key, val] of Object.entries(value)) {
          writeMapEntry(writer, options, field, key, val);
        }
        break;
    }
  }
  function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert$6(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar(writer, field.K, 1, keyValue);
    switch (field.V.kind) {
      case "scalar":
        writeScalar(writer, field.V.T, 2, value);
        break;
      case "enum":
        writeScalar(writer, ScalarType.INT32, 2, value);
        break;
      case "message":
        assert$6(value !== void 0);
        writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));
        break;
    }
    writer.join();
  }
  function writeMessageField(writer, options, field, value) {
    const message = wrapField(field.T, value);
    if (field.delimited)
      writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
    else
      writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
  }
  function writeScalar(writer, type, fieldNo, value) {
    assert$6(value !== void 0);
    let [wireType, method] = scalarTypeInfo(type);
    writer.tag(fieldNo, wireType)[method](value);
  }
  function writePacked(writer, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i2 = 0; i2 < value.length; i2++) {
      writer[method](value[i2]);
    }
    writer.join();
  }
  function scalarTypeInfo(type) {
    let wireType = WireType.Varint;
    switch (type) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method];
  }
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName = member.localName, t = target, s2 = source;
          if (s2[localName] == null) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s2[localName].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s2[localName].value;
              if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t[localName] = { case: sk, value: val };
              break;
            case "scalar":
            case "enum":
              let copy = s2[localName];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t[localName] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k, v2] of Object.entries(s2[localName])) {
                      t[localName][k] = toU8Arr(v2);
                    }
                  } else {
                    Object.assign(t[localName], s2[localName]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k of Object.keys(s2[localName])) {
                    let val2 = s2[localName][k];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t[localName][k] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt = member.T;
              if (member.repeated) {
                t[localName] = s2[localName].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
              } else {
                const val2 = s2[localName];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t[localName] = toU8Arr(val2);
                  } else {
                    t[localName] = val2;
                  }
                } else {
                  t[localName] = isMessage(val2, mt) ? val2 : new mt(val2);
                }
              }
              break;
          }
        }
      },
      // TODO use isFieldSet() here to support future field presence
      equals(type, a2, b) {
        if (a2 === b) {
          return true;
        }
        if (!a2 || !b) {
          return false;
        }
        return type.fields.byMember().every((m2) => {
          const va = a2[m2.localName];
          const vb = b[m2.localName];
          if (m2.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m2.kind) {
              case "message":
                return va.every((a3, i2) => m2.T.equals(a3, vb[i2]));
              case "scalar":
                return va.every((a3, i2) => scalarEquals(m2.T, a3, vb[i2]));
              case "enum":
                return va.every((a3, i2) => scalarEquals(ScalarType.INT32, a3, vb[i2]));
            }
            throw new Error(`repeated cannot contain ${m2.kind}`);
          }
          switch (m2.kind) {
            case "message":
              return m2.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m2.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s2 = m2.findField(va.case);
              if (s2 === void 0) {
                return true;
              }
              switch (s2.kind) {
                case "message":
                  return s2.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s2.T, va.value, vb.value);
              }
              throw new Error(`oneof cannot contain ${s2.kind}`);
            case "map":
              const keys2 = Object.keys(va).concat(Object.keys(vb));
              switch (m2.V.kind) {
                case "message":
                  const messageType = m2.V.T;
                  return keys2.every((k) => messageType.equals(va[k], vb[k]));
                case "enum":
                  return keys2.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
                case "scalar":
                  const scalarType = m2.V.T;
                  return keys2.every((k) => scalarEquals(scalarType, va[k], vb[k]));
              }
              break;
          }
        });
      },
      // TODO use isFieldSet() here to support future field presence
      clone(message) {
        const type = message.getType(), target = new type(), any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (const [key, v2] of Object.entries(source)) {
              copy[key] = cloneSingularField(v2);
            }
          } else if (member.kind == "oneof") {
            const f2 = member.findField(source.case);
            copy = f2 ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        for (const uf of type.runtime.bin.listUnknownFields(message)) {
          type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (isMessage(value)) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c2 = new Uint8Array(value.byteLength);
      c2.set(value);
      return c2;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }
  function makeProtoRuntime(syntax, newFieldList, initFields) {
    return {
      syntax,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList,
        initFields
      }),
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(typeName, extendee, field) {
        return makeExtension(this, typeName, extendee, field);
      }
    };
  }
  class InternalFieldList {
    constructor(fields, normalizer) {
      this._fields = fields;
      this._normalizer = normalizer;
    }
    findJsonName(jsonName) {
      if (!this.jsonNames) {
        const t = {};
        for (const f2 of this.list()) {
          t[f2.jsonName] = t[f2.name] = f2;
        }
        this.jsonNames = t;
      }
      return this.jsonNames[jsonName];
    }
    find(fieldNo) {
      if (!this.numbers) {
        const t = {};
        for (const f2 of this.list()) {
          t[f2.no] = f2;
        }
        this.numbers = t;
      }
      return this.numbers[fieldNo];
    }
    list() {
      if (!this.all) {
        this.all = this._normalizer(this._fields);
      }
      return this.all;
    }
    byNumber() {
      if (!this.numbersAsc) {
        this.numbersAsc = this.list().concat().sort((a2, b) => a2.no - b.no);
      }
      return this.numbersAsc;
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const a2 = this.members;
        let o;
        for (const f2 of this.list()) {
          if (f2.oneof) {
            if (f2.oneof !== o) {
              o = f2.oneof;
              a2.push(o);
            }
          } else {
            a2.push(f2);
          }
        }
      }
      return this.members;
    }
  }
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  const fieldJsonName = protoCamelCase;
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b = [];
    for (let i2 = 0; i2 < snakeCase.length; i2++) {
      let c2 = snakeCase.charAt(i2);
      switch (c2) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b.push(c2);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c2 = c2.toUpperCase();
          }
          b.push(c2);
          break;
      }
    }
    return b.join("");
  }
  const reservedObjectProperties = /* @__PURE__ */ new Set([
    // names reserved by JavaScript
    "constructor",
    "toString",
    "toJSON",
    "valueOf"
  ]);
  const reservedMessageProperties = /* @__PURE__ */ new Set([
    // names reserved by the runtime
    "getType",
    "clone",
    "equals",
    "fromBinary",
    "fromJson",
    "fromJsonString",
    "toBinary",
    "toJson",
    "toJsonString",
    // names reserved by the runtime for the future
    "toObject"
  ]);
  const fallback = (name) => `${name}$`;
  const safeMessageProperty = (name) => {
    if (reservedMessageProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  const safeObjectProperty = (name) => {
    if (reservedObjectProperties.has(name)) {
      return fallback(name);
    }
    return name;
  };
  class InternalOneofInfo {
    constructor(name) {
      this.kind = "oneof";
      this.repeated = false;
      this.packed = false;
      this.opt = false;
      this.req = false;
      this.default = void 0;
      this.fields = [];
      this.name = name;
      this.localName = localOneofName(name);
    }
    addField(field) {
      assert$6(field.oneof === this, `field ${field.name} not one of ${this.name}`);
      this.fields.push(field);
    }
    findField(localName) {
      if (!this._lookup) {
        this._lookup = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < this.fields.length; i2++) {
          this._lookup[this.fields[i2].localName] = this.fields[i2];
        }
      }
      return this._lookup[localName];
    }
  }
  function normalizeFieldInfos(fieldInfos, packedByDefault) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const r2 = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f2 = field;
      f2.localName = localFieldName(field.name, field.oneof !== void 0);
      f2.jsonName = (_a2 = field.jsonName) !== null && _a2 !== void 0 ? _a2 : fieldJsonName(field.name);
      f2.repeated = (_b2 = field.repeated) !== null && _b2 !== void 0 ? _b2 : false;
      if (field.kind == "scalar") {
        f2.L = (_c2 = field.L) !== null && _c2 !== void 0 ? _c2 : LongType.BIGINT;
      }
      f2.delimited = (_d2 = field.delimited) !== null && _d2 !== void 0 ? _d2 : false;
      f2.req = (_e2 = field.req) !== null && _e2 !== void 0 ? _e2 : false;
      f2.opt = (_f2 = field.opt) !== null && _f2 !== void 0 ? _f2 : false;
      if (field.packed === void 0) {
        if (packedByDefault) {
          f2.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
        } else {
          f2.packed = false;
        }
      }
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f2.oneof = o;
        o.addField(f2);
      }
      r2.push(f2);
    }
    return r2;
  }
  const proto3 = makeProtoRuntime(
    "proto3",
    (fields) => {
      return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, true));
    },
    // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
    (target) => {
      for (const member of target.getType().fields.byMember()) {
        if (member.opt) {
          continue;
        }
        const name = member.localName, t = target;
        if (member.repeated) {
          t[name] = [];
          continue;
        }
        switch (member.kind) {
          case "oneof":
            t[name] = { case: void 0 };
            break;
          case "enum":
            t[name] = 0;
            break;
          case "map":
            t[name] = {};
            break;
          case "scalar":
            t[name] = scalarZeroValue(member.T, member.L);
            break;
        }
      }
    }
  );
  var MethodKind;
  (function(MethodKind2) {
    MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
    MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
    MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
    MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
  })(MethodKind || (MethodKind = {}));
  var MethodIdempotency;
  (function(MethodIdempotency2) {
    MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
    MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
  })(MethodIdempotency || (MethodIdempotency = {}));
  class Timestamp extends Message {
    constructor(data) {
      super();
      this.seconds = protoInt64.zero;
      this.nanos = 0;
      proto3.util.initPartial(data, this);
    }
    fromJson(json, options) {
      if (typeof json !== "string") {
        throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3.json.debug(json)}`);
      }
      const matches2 = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches2) {
        throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
      }
      const ms = Date.parse(matches2[1] + "-" + matches2[2] + "-" + matches2[3] + "T" + matches2[4] + ":" + matches2[5] + ":" + matches2[6] + (matches2[8] ? matches2[8] : "Z"));
      if (Number.isNaN(ms)) {
        throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
      }
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
      }
      this.seconds = protoInt64.parse(ms / 1e3);
      this.nanos = 0;
      if (matches2[7]) {
        this.nanos = parseInt("1" + matches2[7] + "0".repeat(9 - matches2[7].length)) - 1e9;
      }
      return this;
    }
    toJson(options) {
      const ms = Number(this.seconds) * 1e3;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
        throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
      }
      if (this.nanos < 0) {
        throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
      }
      let z2 = "Z";
      if (this.nanos > 0) {
        const nanosStr = (this.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000") {
          z2 = "." + nanosStr.substring(0, 3) + "Z";
        } else if (nanosStr.substring(6) === "000") {
          z2 = "." + nanosStr.substring(0, 6) + "Z";
        } else {
          z2 = "." + nanosStr + "Z";
        }
      }
      return new Date(ms).toISOString().replace(".000Z", z2);
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
    }
    static now() {
      return Timestamp.fromDate(/* @__PURE__ */ new Date());
    }
    static fromDate(date2) {
      const ms = date2.getTime();
      return new Timestamp({
        seconds: protoInt64.parse(Math.floor(ms / 1e3)),
        nanos: ms % 1e3 * 1e6
      });
    }
    static fromBinary(bytes, options) {
      return new Timestamp().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Timestamp().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Timestamp().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Timestamp, a2, b);
    }
  }
  Timestamp.runtime = proto3;
  Timestamp.typeName = "google.protobuf.Timestamp";
  Timestamp.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "seconds",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 2,
      name: "nanos",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class Any extends Message {
    constructor(data) {
      super();
      this.typeUrl = "";
      this.value = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      var _a2;
      if (this.typeUrl === "") {
        return {};
      }
      const typeName = this.typeUrlToName(this.typeUrl);
      const messageType = (_a2 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a2 === void 0 ? void 0 : _a2.findMessage(typeName);
      if (!messageType) {
        throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
      }
      const message = messageType.fromBinary(this.value);
      let json = message.toJson(options);
      if (typeName.startsWith("google.protobuf.") || (json === null || Array.isArray(json) || typeof json !== "object")) {
        json = { value: json };
      }
      json["@type"] = this.typeUrl;
      return json;
    }
    fromJson(json, options) {
      var _a2;
      if (json === null || Array.isArray(json) || typeof json != "object") {
        throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? "null" : Array.isArray(json) ? "array" : typeof json}`);
      }
      if (Object.keys(json).length == 0) {
        return this;
      }
      const typeUrl = json["@type"];
      if (typeof typeUrl != "string" || typeUrl == "") {
        throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
      }
      const typeName = this.typeUrlToName(typeUrl), messageType = (_a2 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a2 === void 0 ? void 0 : _a2.findMessage(typeName);
      if (!messageType) {
        throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
      }
      let message;
      if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
        message = messageType.fromJson(json["value"], options);
      } else {
        const copy = Object.assign({}, json);
        delete copy["@type"];
        message = messageType.fromJson(copy, options);
      }
      this.packFrom(message);
      return this;
    }
    packFrom(message) {
      this.value = message.toBinary();
      this.typeUrl = this.typeNameToUrl(message.getType().typeName);
    }
    unpackTo(target) {
      if (!this.is(target.getType())) {
        return false;
      }
      target.fromBinary(this.value);
      return true;
    }
    unpack(registry) {
      if (this.typeUrl === "") {
        return void 0;
      }
      const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));
      if (!messageType) {
        return void 0;
      }
      return messageType.fromBinary(this.value);
    }
    is(type) {
      if (this.typeUrl === "") {
        return false;
      }
      const name = this.typeUrlToName(this.typeUrl);
      let typeName = "";
      if (typeof type === "string") {
        typeName = type;
      } else {
        typeName = type.typeName;
      }
      return name === typeName;
    }
    typeNameToUrl(name) {
      return `type.googleapis.com/${name}`;
    }
    typeUrlToName(url) {
      if (!url.length) {
        throw new Error(`invalid type url: ${url}`);
      }
      const slash = url.lastIndexOf("/");
      const name = slash >= 0 ? url.substring(slash + 1) : url;
      if (!name.length) {
        throw new Error(`invalid type url: ${url}`);
      }
      return name;
    }
    static pack(message) {
      const any = new Any();
      any.packFrom(message);
      return any;
    }
    static fromBinary(bytes, options) {
      return new Any().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Any().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Any().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Any, a2, b);
    }
  }
  Any.runtime = proto3;
  Any.typeName = "google.protobuf.Any";
  Any.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "type_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "value",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class DoubleValue extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.DOUBLE, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.DOUBLE, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.DoubleValue from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new DoubleValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DoubleValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DoubleValue().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DoubleValue, a2, b);
    }
  }
  DoubleValue.runtime = proto3;
  DoubleValue.typeName = "google.protobuf.DoubleValue";
  DoubleValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 1
      /* ScalarType.DOUBLE */
    }
  ]);
  DoubleValue.fieldWrapper = {
    wrapField(value) {
      return new DoubleValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class FloatValue extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.FLOAT, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.FLOAT, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.FloatValue from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new FloatValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new FloatValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new FloatValue().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(FloatValue, a2, b);
    }
  }
  FloatValue.runtime = proto3;
  FloatValue.typeName = "google.protobuf.FloatValue";
  FloatValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    }
  ]);
  FloatValue.fieldWrapper = {
    wrapField(value) {
      return new FloatValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class Int64Value extends Message {
    constructor(data) {
      super();
      this.value = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.INT64, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.INT64, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.Int64Value from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new Int64Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Int64Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Int64Value().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Int64Value, a2, b);
    }
  }
  Int64Value.runtime = proto3;
  Int64Value.typeName = "google.protobuf.Int64Value";
  Int64Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]);
  Int64Value.fieldWrapper = {
    wrapField(value) {
      return new Int64Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class UInt64Value extends Message {
    constructor(data) {
      super();
      this.value = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.UINT64, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.UINT64, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.UInt64Value from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new UInt64Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UInt64Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UInt64Value().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UInt64Value, a2, b);
    }
  }
  UInt64Value.runtime = proto3;
  UInt64Value.typeName = "google.protobuf.UInt64Value";
  UInt64Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 4
      /* ScalarType.UINT64 */
    }
  ]);
  UInt64Value.fieldWrapper = {
    wrapField(value) {
      return new UInt64Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class Int32Value extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.INT32, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.INT32, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.Int32Value from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new Int32Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Int32Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Int32Value().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Int32Value, a2, b);
    }
  }
  Int32Value.runtime = proto3;
  Int32Value.typeName = "google.protobuf.Int32Value";
  Int32Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  Int32Value.fieldWrapper = {
    wrapField(value) {
      return new Int32Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class UInt32Value extends Message {
    constructor(data) {
      super();
      this.value = 0;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.UINT32, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.UINT32, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.UInt32Value from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new UInt32Value().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UInt32Value().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UInt32Value().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UInt32Value, a2, b);
    }
  }
  UInt32Value.runtime = proto3;
  UInt32Value.typeName = "google.protobuf.UInt32Value";
  UInt32Value.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]);
  UInt32Value.fieldWrapper = {
    wrapField(value) {
      return new UInt32Value({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class BoolValue extends Message {
    constructor(data) {
      super();
      this.value = false;
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.BOOL, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.BOOL, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.BoolValue from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new BoolValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new BoolValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new BoolValue().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(BoolValue, a2, b);
    }
  }
  BoolValue.runtime = proto3;
  BoolValue.typeName = "google.protobuf.BoolValue";
  BoolValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  BoolValue.fieldWrapper = {
    wrapField(value) {
      return new BoolValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class StringValue extends Message {
    constructor(data) {
      super();
      this.value = "";
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.STRING, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.STRING, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.StringValue from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new StringValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new StringValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new StringValue().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(StringValue, a2, b);
    }
  }
  StringValue.runtime = proto3;
  StringValue.typeName = "google.protobuf.StringValue";
  StringValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  StringValue.fieldWrapper = {
    wrapField(value) {
      return new StringValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  class BytesValue extends Message {
    constructor(data) {
      super();
      this.value = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    toJson(options) {
      return proto3.json.writeScalar(ScalarType.BYTES, this.value, true);
    }
    fromJson(json, options) {
      try {
        this.value = proto3.json.readScalar(ScalarType.BYTES, json);
      } catch (e) {
        let m2 = `cannot decode message google.protobuf.BytesValue from JSON"`;
        if (e instanceof Error && e.message.length > 0) {
          m2 += `: ${e.message}`;
        }
        throw new Error(m2);
      }
      return this;
    }
    static fromBinary(bytes, options) {
      return new BytesValue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new BytesValue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new BytesValue().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(BytesValue, a2, b);
    }
  }
  BytesValue.runtime = proto3;
  BytesValue.typeName = "google.protobuf.BytesValue";
  BytesValue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "value",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  BytesValue.fieldWrapper = {
    wrapField(value) {
      return new BytesValue({ value });
    },
    unwrapField(value) {
      return value.value;
    }
  };
  var RegistrationInfoStatus;
  (function(RegistrationInfoStatus2) {
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNKNOWN"] = 0] = "UNKNOWN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["AVAILABLE_FREE"] = 1] = "AVAILABLE_FREE";
    RegistrationInfoStatus2[RegistrationInfoStatus2["AVAILABLE_START_CODE_REQUIRED"] = 2] = "AVAILABLE_START_CODE_REQUIRED";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RESERVED_VERIFIED_DOMAIN"] = 3] = "UNAVAILABLE_RESERVED_VERIFIED_DOMAIN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RECOVER_VIA_BACKUP_CODE"] = 4] = "UNAVAILABLE_RECOVER_VIA_BACKUP_CODE";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RECOVER_VIA_ADMIN"] = 5] = "UNAVAILABLE_RECOVER_VIA_ADMIN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_RECOVER_VIA_BACKUP_CODE_OR_ADMIN"] = 6] = "UNAVAILABLE_RECOVER_VIA_BACKUP_CODE_OR_ADMIN";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_ADMIN_ACTION_REQUIRED"] = 7] = "UNAVAILABLE_ADMIN_ACTION_REQUIRED";
    RegistrationInfoStatus2[RegistrationInfoStatus2["UNAVAILABLE_NOT_RECOVERABLE"] = 8] = "UNAVAILABLE_NOT_RECOVERABLE";
  })(RegistrationInfoStatus || (RegistrationInfoStatus = {}));
  proto3.util.setEnumType(RegistrationInfoStatus, "domain.RegistrationInfoStatus", [
    { no: 0, name: "REGISTRATION_INFO_STATUS_UNKNOWN" },
    { no: 1, name: "REGISTRATION_INFO_STATUS_AVAILABLE_FREE" },
    { no: 2, name: "REGISTRATION_INFO_STATUS_AVAILABLE_START_CODE_REQUIRED" },
    { no: 3, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RESERVED_VERIFIED_DOMAIN" },
    { no: 4, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RECOVER_VIA_BACKUP_CODE" },
    { no: 5, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RECOVER_VIA_ADMIN" },
    { no: 6, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_RECOVER_VIA_BACKUP_CODE_OR_ADMIN" },
    { no: 7, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_ADMIN_ACTION_REQUIRED" },
    { no: 8, name: "REGISTRATION_INFO_STATUS_UNAVAILABLE_NOT_RECOVERABLE" }
  ]);
  const errorGroupFactor = 1e6;
  const pleaseUpdate$3 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  var ErrorGroup$1;
  (function(ErrorGroup2) {
    ErrorGroup2[ErrorGroup2["Backend"] = 0] = "Backend";
    ErrorGroup2[ErrorGroup2["BackendClient"] = 1e6] = "BackendClient";
    ErrorGroup2[ErrorGroup2["ClientCore"] = 2e6] = "ClientCore";
    ErrorGroup2[ErrorGroup2["LibVaultCrypto"] = 3e6] = "LibVaultCrypto";
    ErrorGroup2[ErrorGroup2["ClientNodeBridge"] = 4e6] = "ClientNodeBridge";
    ErrorGroup2[ErrorGroup2["ClientWebSdk"] = 5e6] = "ClientWebSdk";
    ErrorGroup2[ErrorGroup2["Heymerge"] = 6e6] = "Heymerge";
  })(ErrorGroup$1 || (ErrorGroup$1 = {}));
  let DomainError$1 = class DomainError extends Error {
    constructor(code, short, userTitle, userDetail) {
      super(short);
      this.code = code;
      this.short = short;
      this.userTitle = userTitle;
      this.userDetail = userDetail;
      this.name = "DomainError";
      Object.setPrototypeOf(this, new.target.prototype);
    }
    codeGroup() {
      return this.code - this.code % errorGroupFactor;
    }
    isClientError() {
      return this.codeGroup() === ErrorGroup$1.ClientCore;
    }
    isBackendError() {
      return this.codeGroup() === ErrorGroup$1.Backend;
    }
    isLibVaultCryptoError() {
      return this.codeGroup() === ErrorGroup$1.LibVaultCrypto;
    }
    isClientWebSdkError() {
      return this.codeGroup() === ErrorGroup$1.ClientWebSdk;
    }
    isHeymergeError() {
      return this.codeGroup() === ErrorGroup$1.Heymerge;
    }
  };
  var BackendClientErrorCode;
  (function(BackendClientErrorCode2) {
    BackendClientErrorCode2[BackendClientErrorCode2["NoResponse"] = 1000400] = "NoResponse";
    BackendClientErrorCode2[BackendClientErrorCode2["InvalidChannelMessage"] = 1000410] = "InvalidChannelMessage";
    BackendClientErrorCode2[BackendClientErrorCode2["InvalidGrpcResponse"] = 1000420] = "InvalidGrpcResponse";
    BackendClientErrorCode2[BackendClientErrorCode2["RequiredFieldMissing"] = 1000430] = "RequiredFieldMissing";
  })(BackendClientErrorCode || (BackendClientErrorCode = {}));
  class BackendClientDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$3);
    }
  }
  class NoResponseError extends BackendClientDomainError {
    constructor() {
      super(BackendClientErrorCode.NoResponse, "no response", "No response", `Our server did not respond to the client's request. ${pleaseUpdate$3}`);
    }
  }
  class InvalidGrpcResponseError extends BackendClientDomainError {
    constructor(grpcStatusCode) {
      super(BackendClientErrorCode.InvalidGrpcResponse, `invalid response (${grpcStatusCode})`, "invalid response", `Received an unexpected reply from the server. ${pleaseUpdate$3}`);
      this.grpcStatusCode = grpcStatusCode;
    }
  }
  class InvalidChannelMessageError extends BackendClientDomainError {
    constructor() {
      super(BackendClientErrorCode.InvalidChannelMessage, "invalid channel message", "Invalid channel message", `The message received on the channel is invalid. ${pleaseUpdate$3}`);
    }
  }
  class RequiredFieldMissingError extends BackendClientDomainError {
    constructor() {
      super(BackendClientErrorCode.RequiredFieldMissing, "required field missing");
    }
  }
  function requireFieldNotEmpty(arg) {
    if (arg === void 0 || arg === "" || arg === 0) {
      throw new RequiredFieldMissingError();
    }
    if (Array.isArray(arg) && arg.length === 0) {
      throw new RequiredFieldMissingError();
    }
    return arg;
  }
  function knownEnumOrDefault(value, enumObject) {
    const enumValues = Object.values(enumObject);
    if (enumValues.includes(value)) {
      return value;
    }
    return enumObject[enumObject[0]];
  }
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
  
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
  
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
  var __assign$3 = function() {
    __assign$3 = Object.assign || function __assign2(t) {
      for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t[p2] = s2[p2];
      }
      return t;
    };
    return __assign$3.apply(this, arguments);
  };
  function __read$1(o, n) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2)
      return o;
    var i2 = m2.call(o), r2, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread$1() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read$1(arguments[i2]));
    return ar;
  }
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
  
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
  
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
  var __assign$2 = function() {
    __assign$2 = Object.assign || function __assign2(t) {
      for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t[p2] = s2[p2];
      }
      return t;
    };
    return __assign$2.apply(this, arguments);
  };
  function __values$1(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i2 = 0;
    if (m2)
      return m2.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = void 0;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2)
      return o;
    var i2 = m2.call(o), r2, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"]))
          m2.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read(arguments[i2]));
    return ar;
  }
  function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
  }
  function isNodeEnv() {
    return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  }
  function dynamicRequire(mod, request) {
    return mod.require(request);
  }
  var fallbackGlobalObject = {};
  function getGlobalObject$1() {
    return isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
  }
  function getGlobalSingleton$1(name, creator, obj) {
    var global2 = obj || getGlobalObject$1();
    var __SENTRY__ = global2.__SENTRY__ = global2.__SENTRY__ || {};
    var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
  }
  var objectToString$2 = Object.prototype.toString;
  function isBuiltin$1(wat, ty) {
    return objectToString$2.call(wat) === "[object " + ty + "]";
  }
  function isPlainObject$1(wat) {
    return isBuiltin$1(wat, "Object");
  }
  function isThenable$1(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  var IS_DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;
  var global$1 = getGlobalObject$1();
  var PREFIX$1 = "Sentry Logger ";
  var CONSOLE_LEVELS$1 = ["debug", "info", "warn", "error", "log", "assert"];
  function consoleSandbox$1(callback) {
    var global2 = getGlobalObject$1();
    if (!("console" in global2)) {
      return callback();
    }
    var originalConsole = global2.console;
    var wrappedLevels = {};
    CONSOLE_LEVELS$1.forEach(function(level) {
      var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
      if (level in global2.console && originalWrappedFunc) {
        wrappedLevels[level] = originalConsole[level];
        originalConsole[level] = originalWrappedFunc;
      }
    });
    try {
      return callback();
    } finally {
      Object.keys(wrappedLevels).forEach(function(level) {
        originalConsole[level] = wrappedLevels[level];
      });
    }
  }
  function makeLogger$1() {
    var enabled = false;
    var logger2 = {
      enable: function() {
        enabled = true;
      },
      disable: function() {
        enabled = false;
      }
    };
    if (IS_DEBUG_BUILD$1) {
      CONSOLE_LEVELS$1.forEach(function(name) {
        logger2[name] = function() {
          var args = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args[_i2] = arguments[_i2];
          }
          if (enabled) {
            consoleSandbox$1(function() {
              var _a2;
              (_a2 = global$1.console)[name].apply(_a2, __spread([PREFIX$1 + "[" + name + "]:"], args));
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS$1.forEach(function(name) {
        logger2[name] = function() {
          return void 0;
        };
      });
    }
    return logger2;
  }
  var logger$1;
  if (IS_DEBUG_BUILD$1) {
    logger$1 = getGlobalSingleton$1("logger", makeLogger$1);
  } else {
    logger$1 = makeLogger$1();
  }
  function dropUndefinedKeys$1(val) {
    var e_1, _a2;
    if (isPlainObject$1(val)) {
      var rv = {};
      try {
        for (var _b2 = __values$1(Object.keys(val)), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
          var key = _c2.value;
          if (typeof val[key] !== "undefined") {
            rv[key] = dropUndefinedKeys$1(val[key]);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a2 = _b2.return))
            _a2.call(_b2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return rv;
    }
    if (Array.isArray(val)) {
      return val.map(dropUndefinedKeys$1);
    }
    return val;
  }
  function uuid4$1() {
    var global2 = getGlobalObject$1();
    var crypto2 = global2.crypto || global2.msCrypto;
    if (!(crypto2 === void 0) && crypto2.getRandomValues) {
      var arr = new Uint16Array(8);
      crypto2.getRandomValues(arr);
      arr[3] = arr[3] & 4095 | 16384;
      arr[4] = arr[4] & 16383 | 32768;
      var pad = function(num) {
        var v2 = num.toString(16);
        while (v2.length < 4) {
          v2 = "0" + v2;
        }
        return v2;
      };
      return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
      var r2 = Math.random() * 16 | 0;
      var v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  }
  var SyncPromise$1 = (
    /** @class */
    function() {
      function SyncPromise2(executor) {
        var _this = this;
        this._state = 0;
        this._handlers = [];
        this._resolve = function(value) {
          _this._setResult(1, value);
        };
        this._reject = function(reason) {
          _this._setResult(2, reason);
        };
        this._setResult = function(state, value) {
          if (_this._state !== 0) {
            return;
          }
          if (isThenable$1(value)) {
            void value.then(_this._resolve, _this._reject);
            return;
          }
          _this._state = state;
          _this._value = value;
          _this._executeHandlers();
        };
        this._executeHandlers = function() {
          if (_this._state === 0) {
            return;
          }
          var cachedHandlers = _this._handlers.slice();
          _this._handlers = [];
          cachedHandlers.forEach(function(handler) {
            if (handler[0]) {
              return;
            }
            if (_this._state === 1) {
              handler[1](_this._value);
            }
            if (_this._state === 2) {
              handler[2](_this._value);
            }
            handler[0] = true;
          });
        };
        try {
          executor(this._resolve, this._reject);
        } catch (e) {
          this._reject(e);
        }
      }
      SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise2(function(resolve, reject) {
          _this._handlers.push([
            false,
            function(result2) {
              if (!onfulfilled) {
                resolve(result2);
              } else {
                try {
                  resolve(onfulfilled(result2));
                } catch (e) {
                  reject(e);
                }
              }
            },
            function(reason) {
              if (!onrejected) {
                reject(reason);
              } else {
                try {
                  resolve(onrejected(reason));
                } catch (e) {
                  reject(e);
                }
              }
            }
          ]);
          _this._executeHandlers();
        });
      };
      SyncPromise2.prototype.catch = function(onrejected) {
        return this.then(function(val) {
          return val;
        }, onrejected);
      };
      SyncPromise2.prototype.finally = function(onfinally) {
        var _this = this;
        return new SyncPromise2(function(resolve, reject) {
          var val;
          var isRejected;
          return _this.then(function(value) {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          }, function(reason) {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }).then(function() {
            if (isRejected) {
              reject(val);
              return;
            }
            resolve(val);
          });
        });
      };
      return SyncPromise2;
    }()
  );
  var dateTimestampSource = {
    nowSeconds: function() {
      return Date.now() / 1e3;
    }
  };
  function getBrowserPerformance() {
    var performance = getGlobalObject$1().performance;
    if (!performance || !performance.now) {
      return void 0;
    }
    var timeOrigin = Date.now() - performance.now();
    return {
      now: function() {
        return performance.now();
      },
      timeOrigin
    };
  }
  function getNodePerformance() {
    try {
      var perfHooks = dynamicRequire(module, "perf_hooks");
      return perfHooks.performance;
    } catch (_) {
      return void 0;
    }
  }
  var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
  var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
    nowSeconds: function() {
      return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
    }
  };
  var dateTimestampInSeconds$1 = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
  var timestampInSeconds$1 = timestampSource.nowSeconds.bind(timestampSource);
  (function() {
    var performance = getGlobalObject$1().performance;
    if (!performance || !performance.now) {
      return void 0;
    }
    var threshold = 3600 * 1e3;
    var performanceNow = performance.now();
    var dateNow = Date.now();
    var timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : threshold;
    var timeOriginIsReliable = timeOriginDelta < threshold;
    var navigationStart = performance.timing && performance.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === "number";
    var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    var navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        return performance.timeOrigin;
      } else {
        return navigationStart;
      }
    }
    return dateNow;
  })();
  var MAX_BREADCRUMBS = 100;
  var Scope$1 = (
    /** @class */
    function() {
      function Scope2() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
      }
      Scope2.clone = function(scope) {
        var newScope = new Scope2();
        if (scope) {
          newScope._breadcrumbs = __spread(scope._breadcrumbs);
          newScope._tags = __assign$2({}, scope._tags);
          newScope._extra = __assign$2({}, scope._extra);
          newScope._contexts = __assign$2({}, scope._contexts);
          newScope._user = scope._user;
          newScope._level = scope._level;
          newScope._span = scope._span;
          newScope._session = scope._session;
          newScope._transactionName = scope._transactionName;
          newScope._fingerprint = scope._fingerprint;
          newScope._eventProcessors = __spread(scope._eventProcessors);
          newScope._requestSession = scope._requestSession;
        }
        return newScope;
      };
      Scope2.prototype.addScopeListener = function(callback) {
        this._scopeListeners.push(callback);
      };
      Scope2.prototype.addEventProcessor = function(callback) {
        this._eventProcessors.push(callback);
        return this;
      };
      Scope2.prototype.setUser = function(user) {
        this._user = user || {};
        if (this._session) {
          this._session.update({ user });
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getUser = function() {
        return this._user;
      };
      Scope2.prototype.getRequestSession = function() {
        return this._requestSession;
      };
      Scope2.prototype.setRequestSession = function(requestSession) {
        this._requestSession = requestSession;
        return this;
      };
      Scope2.prototype.setTags = function(tags) {
        this._tags = __assign$2(__assign$2({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTag = function(key, value) {
        var _a2;
        this._tags = __assign$2(__assign$2({}, this._tags), (_a2 = {}, _a2[key] = value, _a2));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtras = function(extras) {
        this._extra = __assign$2(__assign$2({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setExtra = function(key, extra) {
        var _a2;
        this._extra = __assign$2(__assign$2({}, this._extra), (_a2 = {}, _a2[key] = extra, _a2));
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setFingerprint = function(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setLevel = function(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransactionName = function(name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setTransaction = function(name) {
        return this.setTransactionName(name);
      };
      Scope2.prototype.setContext = function(key, context) {
        var _a2;
        if (context === null) {
          delete this._contexts[key];
        } else {
          this._contexts = __assign$2(__assign$2({}, this._contexts), (_a2 = {}, _a2[key] = context, _a2));
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.setSpan = function(span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSpan = function() {
        return this._span;
      };
      Scope2.prototype.getTransaction = function() {
        var span = this.getSpan();
        return span && span.transaction;
      };
      Scope2.prototype.setSession = function(session) {
        if (!session) {
          delete this._session;
        } else {
          this._session = session;
        }
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.getSession = function() {
        return this._session;
      };
      Scope2.prototype.update = function(captureContext) {
        if (!captureContext) {
          return this;
        }
        if (typeof captureContext === "function") {
          var updatedScope = captureContext(this);
          return updatedScope instanceof Scope2 ? updatedScope : this;
        }
        if (captureContext instanceof Scope2) {
          this._tags = __assign$2(__assign$2({}, this._tags), captureContext._tags);
          this._extra = __assign$2(__assign$2({}, this._extra), captureContext._extra);
          this._contexts = __assign$2(__assign$2({}, this._contexts), captureContext._contexts);
          if (captureContext._user && Object.keys(captureContext._user).length) {
            this._user = captureContext._user;
          }
          if (captureContext._level) {
            this._level = captureContext._level;
          }
          if (captureContext._fingerprint) {
            this._fingerprint = captureContext._fingerprint;
          }
          if (captureContext._requestSession) {
            this._requestSession = captureContext._requestSession;
          }
        } else if (isPlainObject$1(captureContext)) {
          captureContext = captureContext;
          this._tags = __assign$2(__assign$2({}, this._tags), captureContext.tags);
          this._extra = __assign$2(__assign$2({}, this._extra), captureContext.extra);
          this._contexts = __assign$2(__assign$2({}, this._contexts), captureContext.contexts);
          if (captureContext.user) {
            this._user = captureContext.user;
          }
          if (captureContext.level) {
            this._level = captureContext.level;
          }
          if (captureContext.fingerprint) {
            this._fingerprint = captureContext.fingerprint;
          }
          if (captureContext.requestSession) {
            this._requestSession = captureContext.requestSession;
          }
        }
        return this;
      };
      Scope2.prototype.clear = function() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = void 0;
        this._transactionName = void 0;
        this._fingerprint = void 0;
        this._requestSession = void 0;
        this._span = void 0;
        this._session = void 0;
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        if (maxCrumbs <= 0) {
          return this;
        }
        var mergedBreadcrumb = __assign$2({ timestamp: dateTimestampInSeconds$1() }, breadcrumb);
        this._breadcrumbs = __spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.clearBreadcrumbs = function() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      };
      Scope2.prototype.applyToEvent = function(event, hint) {
        if (this._extra && Object.keys(this._extra).length) {
          event.extra = __assign$2(__assign$2({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
          event.tags = __assign$2(__assign$2({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
          event.user = __assign$2(__assign$2({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
          event.contexts = __assign$2(__assign$2({}, this._contexts), event.contexts);
        }
        if (this._level) {
          event.level = this._level;
        }
        if (this._transactionName) {
          event.transaction = this._transactionName;
        }
        if (this._span) {
          event.contexts = __assign$2({ trace: this._span.getTraceContext() }, event.contexts);
          var transactionName = this._span.transaction && this._span.transaction.name;
          if (transactionName) {
            event.tags = __assign$2({ transaction: transactionName }, event.tags);
          }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = __spread(event.breadcrumbs || [], this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
        event.sdkProcessingMetadata = this._sdkProcessingMetadata;
        return this._notifyEventProcessors(__spread(getGlobalEventProcessors$1(), this._eventProcessors), event, hint);
      };
      Scope2.prototype.setSDKProcessingMetadata = function(newData) {
        this._sdkProcessingMetadata = __assign$2(__assign$2({}, this._sdkProcessingMetadata), newData);
        return this;
      };
      Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
        var _this = this;
        if (index === void 0) {
          index = 0;
        }
        return new SyncPromise$1(function(resolve, reject) {
          var processor = processors[index];
          if (event === null || typeof processor !== "function") {
            resolve(event);
          } else {
            var result2 = processor(__assign$2({}, event), hint);
            if (isThenable$1(result2)) {
              void result2.then(function(final) {
                return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
              }).then(null, reject);
            } else {
              void _this._notifyEventProcessors(processors, result2, hint, index + 1).then(resolve).then(null, reject);
            }
          }
        });
      };
      Scope2.prototype._notifyScopeListeners = function() {
        var _this = this;
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach(function(callback) {
            callback(_this);
          });
          this._notifyingListeners = false;
        }
      };
      Scope2.prototype._applyFingerprint = function(event) {
        event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
        if (this._fingerprint) {
          event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        if (event.fingerprint && !event.fingerprint.length) {
          delete event.fingerprint;
        }
      };
      return Scope2;
    }()
  );
  function getGlobalEventProcessors$1() {
    return getGlobalSingleton$1("globalEventProcessors", function() {
      return [];
    });
  }
  var Session$1 = (
    /** @class */
    function() {
      function Session2(context) {
        this.errors = 0;
        this.sid = uuid4$1();
        this.duration = 0;
        this.status = "ok";
        this.init = true;
        this.ignoreDuration = false;
        var startingTime = timestampInSeconds$1();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
          this.update(context);
        }
      }
      Session2.prototype.update = function(context) {
        if (context === void 0) {
          context = {};
        }
        if (context.user) {
          if (!this.ipAddress && context.user.ip_address) {
            this.ipAddress = context.user.ip_address;
          }
          if (!this.did && !context.did) {
            this.did = context.user.id || context.user.email || context.user.username;
          }
        }
        this.timestamp = context.timestamp || timestampInSeconds$1();
        if (context.ignoreDuration) {
          this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
          this.sid = context.sid.length === 32 ? context.sid : uuid4$1();
        }
        if (context.init !== void 0) {
          this.init = context.init;
        }
        if (!this.did && context.did) {
          this.did = "" + context.did;
        }
        if (typeof context.started === "number") {
          this.started = context.started;
        }
        if (this.ignoreDuration) {
          this.duration = void 0;
        } else if (typeof context.duration === "number") {
          this.duration = context.duration;
        } else {
          var duration = this.timestamp - this.started;
          this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
          this.release = context.release;
        }
        if (context.environment) {
          this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
          this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
          this.userAgent = context.userAgent;
        }
        if (typeof context.errors === "number") {
          this.errors = context.errors;
        }
        if (context.status) {
          this.status = context.status;
        }
      };
      Session2.prototype.close = function(status) {
        if (status) {
          this.update({ status });
        } else if (this.status === "ok") {
          this.update({ status: "exited" });
        } else {
          this.update();
        }
      };
      Session2.prototype.toJSON = function() {
        return dropUndefinedKeys$1({
          sid: "" + this.sid,
          init: this.init,
          // Make sure that sec is converted to ms for date constructor
          started: new Date(this.started * 1e3).toISOString(),
          timestamp: new Date(this.timestamp * 1e3).toISOString(),
          status: this.status,
          errors: this.errors,
          did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
          duration: this.duration,
          attrs: {
            release: this.release,
            environment: this.environment,
            ip_address: this.ipAddress,
            user_agent: this.userAgent
          }
        });
      };
      return Session2;
    }()
  );
  var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;
  var API_VERSION$1 = 4;
  var DEFAULT_BREADCRUMBS$1 = 100;
  var Hub$1 = (
    /** @class */
    function() {
      function Hub2(client, scope, _version) {
        if (scope === void 0) {
          scope = new Scope$1();
        }
        if (_version === void 0) {
          _version = API_VERSION$1;
        }
        this._version = _version;
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
          this.bindClient(client);
        }
      }
      Hub2.prototype.isOlderThan = function(version) {
        return this._version < version;
      };
      Hub2.prototype.bindClient = function(client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
          client.setupIntegrations();
        }
      };
      Hub2.prototype.pushScope = function() {
        var scope = Scope$1.clone(this.getScope());
        this.getStack().push({
          client: this.getClient(),
          scope
        });
        return scope;
      };
      Hub2.prototype.popScope = function() {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      };
      Hub2.prototype.withScope = function(callback) {
        var scope = this.pushScope();
        try {
          callback(scope);
        } finally {
          this.popScope();
        }
      };
      Hub2.prototype.getClient = function() {
        return this.getStackTop().client;
      };
      Hub2.prototype.getScope = function() {
        return this.getStackTop().scope;
      };
      Hub2.prototype.getStack = function() {
        return this._stack;
      };
      Hub2.prototype.getStackTop = function() {
        return this._stack[this._stack.length - 1];
      };
      Hub2.prototype.captureException = function(exception, hint) {
        var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4$1();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error("Sentry syntheticException");
          } catch (exception2) {
            syntheticException = exception2;
          }
          finalHint = {
            originalException: exception,
            syntheticException
          };
        }
        this._invokeClient("captureException", exception, __assign$2(__assign$2({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureMessage = function(message, level, hint) {
        var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4$1();
        var finalHint = hint;
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error(message);
          } catch (exception) {
            syntheticException = exception;
          }
          finalHint = {
            originalException: message,
            syntheticException
          };
        }
        this._invokeClient("captureMessage", message, level, __assign$2(__assign$2({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.captureEvent = function(event, hint) {
        var eventId = hint && hint.event_id ? hint.event_id : uuid4$1();
        if (event.type !== "transaction") {
          this._lastEventId = eventId;
        }
        this._invokeClient("captureEvent", event, __assign$2(__assign$2({}, hint), { event_id: eventId }));
        return eventId;
      };
      Hub2.prototype.lastEventId = function() {
        return this._lastEventId;
      };
      Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
        var _a2 = this.getStackTop(), scope = _a2.scope, client = _a2.client;
        if (!scope || !client)
          return;
        var _b2 = client.getOptions && client.getOptions() || {}, _c2 = _b2.beforeBreadcrumb, beforeBreadcrumb = _c2 === void 0 ? null : _c2, _d2 = _b2.maxBreadcrumbs, maxBreadcrumbs = _d2 === void 0 ? DEFAULT_BREADCRUMBS$1 : _d2;
        if (maxBreadcrumbs <= 0)
          return;
        var timestamp = dateTimestampInSeconds$1();
        var mergedBreadcrumb = __assign$2({ timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox$1(function() {
          return beforeBreadcrumb(mergedBreadcrumb, hint);
        }) : mergedBreadcrumb;
        if (finalBreadcrumb === null)
          return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
      };
      Hub2.prototype.setUser = function(user) {
        var scope = this.getScope();
        if (scope)
          scope.setUser(user);
      };
      Hub2.prototype.setTags = function(tags) {
        var scope = this.getScope();
        if (scope)
          scope.setTags(tags);
      };
      Hub2.prototype.setExtras = function(extras) {
        var scope = this.getScope();
        if (scope)
          scope.setExtras(extras);
      };
      Hub2.prototype.setTag = function(key, value) {
        var scope = this.getScope();
        if (scope)
          scope.setTag(key, value);
      };
      Hub2.prototype.setExtra = function(key, extra) {
        var scope = this.getScope();
        if (scope)
          scope.setExtra(key, extra);
      };
      Hub2.prototype.setContext = function(name, context) {
        var scope = this.getScope();
        if (scope)
          scope.setContext(name, context);
      };
      Hub2.prototype.configureScope = function(callback) {
        var _a2 = this.getStackTop(), scope = _a2.scope, client = _a2.client;
        if (scope && client) {
          callback(scope);
        }
      };
      Hub2.prototype.run = function(callback) {
        var oldHub = makeMain$1(this);
        try {
          callback(this);
        } finally {
          makeMain$1(oldHub);
        }
      };
      Hub2.prototype.getIntegration = function(integration) {
        var client = this.getClient();
        if (!client)
          return null;
        try {
          return client.getIntegration(integration);
        } catch (_oO) {
          IS_DEBUG_BUILD && logger$1.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
          return null;
        }
      };
      Hub2.prototype.startSpan = function(context) {
        return this._callExtensionMethod("startSpan", context);
      };
      Hub2.prototype.startTransaction = function(context, customSamplingContext) {
        return this._callExtensionMethod("startTransaction", context, customSamplingContext);
      };
      Hub2.prototype.traceHeaders = function() {
        return this._callExtensionMethod("traceHeaders");
      };
      Hub2.prototype.captureSession = function(endSession2) {
        if (endSession2 === void 0) {
          endSession2 = false;
        }
        if (endSession2) {
          return this.endSession();
        }
        this._sendSessionUpdate();
      };
      Hub2.prototype.endSession = function() {
        var layer = this.getStackTop();
        var scope = layer && layer.scope;
        var session = scope && scope.getSession();
        if (session) {
          session.close();
        }
        this._sendSessionUpdate();
        if (scope) {
          scope.setSession();
        }
      };
      Hub2.prototype.startSession = function(context) {
        var _a2 = this.getStackTop(), scope = _a2.scope, client = _a2.client;
        var _b2 = client && client.getOptions() || {}, release = _b2.release, environment = _b2.environment;
        var global2 = getGlobalObject$1();
        var userAgent = (global2.navigator || {}).userAgent;
        var session = new Session$1(__assign$2(__assign$2(__assign$2({
          release,
          environment
        }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
        if (scope) {
          var currentSession = scope.getSession && scope.getSession();
          if (currentSession && currentSession.status === "ok") {
            currentSession.update({ status: "exited" });
          }
          this.endSession();
          scope.setSession(session);
        }
        return session;
      };
      Hub2.prototype._sendSessionUpdate = function() {
        var _a2 = this.getStackTop(), scope = _a2.scope, client = _a2.client;
        if (!scope)
          return;
        var session = scope.getSession && scope.getSession();
        if (session) {
          if (client && client.captureSession) {
            client.captureSession(session);
          }
        }
      };
      Hub2.prototype._invokeClient = function(method) {
        var _a2;
        var args = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          args[_i2 - 1] = arguments[_i2];
        }
        var _b2 = this.getStackTop(), scope = _b2.scope, client = _b2.client;
        if (client && client[method]) {
          (_a2 = client)[method].apply(_a2, __spread(args, [scope]));
        }
      };
      Hub2.prototype._callExtensionMethod = function(method) {
        var args = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          args[_i2 - 1] = arguments[_i2];
        }
        var carrier = getMainCarrier$1();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
          return sentry.extensions[method].apply(this, args);
        }
        IS_DEBUG_BUILD && logger$1.warn("Extension method " + method + " couldn't be found, doing nothing.");
      };
      return Hub2;
    }()
  );
  function getMainCarrier$1() {
    var carrier = getGlobalObject$1();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return carrier;
  }
  function makeMain$1(hub) {
    var registry = getMainCarrier$1();
    var oldHub = getHubFromCarrier$1(registry);
    setHubOnCarrier$1(registry, hub);
    return oldHub;
  }
  function getCurrentHub$1() {
    var registry = getMainCarrier$1();
    if (!hasHubOnCarrier$1(registry) || getHubFromCarrier$1(registry).isOlderThan(API_VERSION$1)) {
      setHubOnCarrier$1(registry, new Hub$1());
    }
    if (isNodeEnv()) {
      return getHubFromActiveDomain(registry);
    }
    return getHubFromCarrier$1(registry);
  }
  function getHubFromActiveDomain(registry) {
    try {
      var sentry = getMainCarrier$1().__SENTRY__;
      var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
      if (!activeDomain) {
        return getHubFromCarrier$1(registry);
      }
      if (!hasHubOnCarrier$1(activeDomain) || getHubFromCarrier$1(activeDomain).isOlderThan(API_VERSION$1)) {
        var registryHubTopStack = getHubFromCarrier$1(registry).getStackTop();
        setHubOnCarrier$1(activeDomain, new Hub$1(registryHubTopStack.client, Scope$1.clone(registryHubTopStack.scope)));
      }
      return getHubFromCarrier$1(activeDomain);
    } catch (_Oo) {
      return getHubFromCarrier$1(registry);
    }
  }
  function hasHubOnCarrier$1(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier$1(carrier) {
    return getGlobalSingleton$1("hub", function() {
      return new Hub$1();
    }, carrier);
  }
  function setHubOnCarrier$1(carrier, hub) {
    if (!carrier)
      return false;
    var __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  }
  function callOnHub(method) {
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    var hub = getCurrentHub$1();
    if (hub && hub[method]) {
      return hub[method].apply(hub, __spread$1(args));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
  }
  function captureException$1(exception, captureContext) {
    var syntheticException = new Error("Sentry syntheticException");
    return callOnHub("captureException", exception, {
      captureContext,
      originalException: exception,
      syntheticException
    });
  }
  function captureMessage$1(message, captureContext) {
    var syntheticException = new Error(message);
    var level = typeof captureContext === "string" ? captureContext : void 0;
    var context = typeof captureContext !== "string" ? { captureContext } : void 0;
    return callOnHub("captureMessage", message, level, __assign$3({ originalException: message, syntheticException }, context));
  }
  function addBreadcrumb$1(breadcrumb) {
    callOnHub("addBreadcrumb", breadcrumb);
  }
  function withScope$1(callback) {
    callOnHub("withScope", callback);
  }
  const anyMap$1 = /* @__PURE__ */ new WeakMap();
  const eventsMap$1 = /* @__PURE__ */ new WeakMap();
  const producersMap$1 = /* @__PURE__ */ new WeakMap();
  const anyProducer$1 = Symbol("anyProducer");
  const resolvedPromise$1 = Promise.resolve();
  const listenerAdded$1 = Symbol("listenerAdded");
  const listenerRemoved$1 = Symbol("listenerRemoved");
  function assertEventName$1(eventName) {
    if (typeof eventName !== "string" && typeof eventName !== "symbol") {
      throw new TypeError("eventName must be a string or a symbol");
    }
  }
  function assertListener$1(listener) {
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
  }
  function getListeners$1(instance, eventName) {
    const events = eventsMap$1.get(instance);
    if (!events.has(eventName)) {
      events.set(eventName, /* @__PURE__ */ new Set());
    }
    return events.get(eventName);
  }
  function getEventProducers$1(instance, eventName) {
    const key = typeof eventName === "string" ? eventName : anyProducer$1;
    const producers = producersMap$1.get(instance);
    if (!producers.has(key)) {
      producers.set(key, /* @__PURE__ */ new Set());
    }
    return producers.get(key);
  }
  function enqueueProducers$1(instance, eventName, eventData) {
    const producers = producersMap$1.get(instance);
    if (producers.has(eventName)) {
      for (const producer of producers.get(eventName)) {
        producer.enqueue(eventData);
      }
    }
    if (producers.has(anyProducer$1)) {
      const item = Promise.all([eventName, eventData]);
      for (const producer of producers.get(anyProducer$1)) {
        producer.enqueue(item);
      }
    }
  }
  function iterator$1(instance, eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let isFinished = false;
    let flush = () => {
    };
    let queue = [];
    const producer = {
      enqueue(item) {
        queue.push(item);
        flush();
      },
      finish() {
        isFinished = true;
        flush();
      }
    };
    for (const eventName of eventNames) {
      getEventProducers$1(instance, eventName).add(producer);
    }
    return {
      async next() {
        if (!queue) {
          return { done: true };
        }
        if (queue.length === 0) {
          if (isFinished) {
            queue = void 0;
            return this.next();
          }
          await new Promise((resolve) => {
            flush = resolve;
          });
          return this.next();
        }
        return {
          done: false,
          value: await queue.shift()
        };
      },
      async return(value) {
        queue = void 0;
        for (const eventName of eventNames) {
          getEventProducers$1(instance, eventName).delete(producer);
        }
        flush();
        return arguments.length > 0 ? { done: true, value: await value } : { done: true };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function defaultMethodNamesOrAssert$1(methodNames) {
    if (methodNames === void 0) {
      return allEmitteryMethods$1;
    }
    if (!Array.isArray(methodNames)) {
      throw new TypeError("`methodNames` must be an array of strings");
    }
    for (const methodName of methodNames) {
      if (!allEmitteryMethods$1.includes(methodName)) {
        if (typeof methodName !== "string") {
          throw new TypeError("`methodNames` element must be a string");
        }
        throw new Error(`${methodName} is not Emittery method`);
      }
    }
    return methodNames;
  }
  const isListenerSymbol$1 = (symbol) => symbol === listenerAdded$1 || symbol === listenerRemoved$1;
  let Emittery$2 = class Emittery2 {
    static mixin(emitteryPropertyName, methodNames) {
      methodNames = defaultMethodNamesOrAssert$1(methodNames);
      return (target) => {
        if (typeof target !== "function") {
          throw new TypeError("`target` must be function");
        }
        for (const methodName of methodNames) {
          if (target.prototype[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
        }
        function getEmitteryProperty() {
          Object.defineProperty(this, emitteryPropertyName, {
            enumerable: false,
            value: new Emittery2()
          });
          return this[emitteryPropertyName];
        }
        Object.defineProperty(target.prototype, emitteryPropertyName, {
          enumerable: false,
          get: getEmitteryProperty
        });
        const emitteryMethodCaller = (methodName) => function(...args) {
          return this[emitteryPropertyName][methodName](...args);
        };
        for (const methodName of methodNames) {
          Object.defineProperty(target.prototype, methodName, {
            enumerable: false,
            value: emitteryMethodCaller(methodName)
          });
        }
        return target;
      };
    }
    constructor() {
      anyMap$1.set(this, /* @__PURE__ */ new Set());
      eventsMap$1.set(this, /* @__PURE__ */ new Map());
      producersMap$1.set(this, /* @__PURE__ */ new Map());
    }
    on(eventNames, listener) {
      assertListener$1(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName$1(eventName);
        getListeners$1(this, eventName).add(listener);
        if (!isListenerSymbol$1(eventName)) {
          this.emit(listenerAdded$1, { eventName, listener });
        }
      }
      return this.off.bind(this, eventNames, listener);
    }
    off(eventNames, listener) {
      assertListener$1(listener);
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName$1(eventName);
        getListeners$1(this, eventName).delete(listener);
        if (!isListenerSymbol$1(eventName)) {
          this.emit(listenerRemoved$1, { eventName, listener });
        }
      }
    }
    once(eventNames) {
      return new Promise((resolve) => {
        const off = this.on(eventNames, (data) => {
          off();
          resolve(data);
        });
      });
    }
    events(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        assertEventName$1(eventName);
      }
      return iterator$1(this, eventNames);
    }
    async emit(eventName, eventData) {
      assertEventName$1(eventName);
      enqueueProducers$1(this, eventName, eventData);
      const listeners = getListeners$1(this, eventName);
      const anyListeners = anyMap$1.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = isListenerSymbol$1(eventName) ? [] : [...anyListeners];
      await resolvedPromise$1;
      await Promise.all([
        ...staticListeners.map(async (listener) => {
          if (listeners.has(listener)) {
            return listener(eventData);
          }
        }),
        ...staticAnyListeners.map(async (listener) => {
          if (anyListeners.has(listener)) {
            return listener(eventName, eventData);
          }
        })
      ]);
    }
    async emitSerial(eventName, eventData) {
      assertEventName$1(eventName);
      const listeners = getListeners$1(this, eventName);
      const anyListeners = anyMap$1.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = [...anyListeners];
      await resolvedPromise$1;
      for (const listener of staticListeners) {
        if (listeners.has(listener)) {
          await listener(eventData);
        }
      }
      for (const listener of staticAnyListeners) {
        if (anyListeners.has(listener)) {
          await listener(eventName, eventData);
        }
      }
    }
    onAny(listener) {
      assertListener$1(listener);
      anyMap$1.get(this).add(listener);
      this.emit(listenerAdded$1, { listener });
      return this.offAny.bind(this, listener);
    }
    anyEvent() {
      return iterator$1(this);
    }
    offAny(listener) {
      assertListener$1(listener);
      this.emit(listenerRemoved$1, { listener });
      anyMap$1.get(this).delete(listener);
    }
    clearListeners(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      for (const eventName of eventNames) {
        if (typeof eventName === "string") {
          getListeners$1(this, eventName).clear();
          const producers = getEventProducers$1(this, eventName);
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        } else {
          anyMap$1.get(this).clear();
          for (const listeners of eventsMap$1.get(this).values()) {
            listeners.clear();
          }
          for (const producers of producersMap$1.get(this).values()) {
            for (const producer of producers) {
              producer.finish();
            }
            producers.clear();
          }
        }
      }
    }
    listenerCount(eventNames) {
      eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
      let count = 0;
      for (const eventName of eventNames) {
        if (typeof eventName === "string") {
          count += anyMap$1.get(this).size + getListeners$1(this, eventName).size + getEventProducers$1(this, eventName).size + getEventProducers$1(this).size;
          continue;
        }
        if (typeof eventName !== "undefined") {
          assertEventName$1(eventName);
        }
        count += anyMap$1.get(this).size;
        for (const value of eventsMap$1.get(this).values()) {
          count += value.size;
        }
        for (const value of producersMap$1.get(this).values()) {
          count += value.size;
        }
      }
      return count;
    }
    bindMethods(target, methodNames) {
      if (typeof target !== "object" || target === null) {
        throw new TypeError("`target` must be an object");
      }
      methodNames = defaultMethodNamesOrAssert$1(methodNames);
      for (const methodName of methodNames) {
        if (target[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
        Object.defineProperty(target, methodName, {
          enumerable: false,
          value: this[methodName].bind(this)
        });
      }
    }
  };
  const allEmitteryMethods$1 = Object.getOwnPropertyNames(Emittery$2.prototype).filter((v2) => v2 !== "constructor");
  Emittery$2.Typed = class extends Emittery$2 {
  };
  Object.defineProperty(Emittery$2.Typed, "Typed", {
    enumerable: false,
    value: void 0
  });
  Object.defineProperty(Emittery$2, "listenerAdded", {
    value: listenerAdded$1,
    writable: false,
    enumerable: true,
    configurable: false
  });
  Object.defineProperty(Emittery$2, "listenerRemoved", {
    value: listenerRemoved$1,
    writable: false,
    enumerable: true,
    configurable: false
  });
  var emittery$1 = Emittery$2;
  const Emittery$3 = /* @__PURE__ */ getDefaultExportFromCjs(emittery$1);
  class Cancel extends Error {
  }
  const SHOW_DEBUG_MESSAGES_PROP = "showDebugMessages";
  function createProxiedConsole() {
    let showDebugMessages = false;
    const proxyHandler = {
      get(target, prop, receiver) {
        if (prop === SHOW_DEBUG_MESSAGES_PROP) {
          return showDebugMessages;
        }
        if (!showDebugMessages) {
          return () => {
          };
        }
        return Reflect.get(target, prop, receiver);
      },
      set(obj, prop, value) {
        if (prop === SHOW_DEBUG_MESSAGES_PROP) {
          showDebugMessages = value;
          return true;
        }
        return Reflect.set(obj, prop, value);
      }
    };
    return new Proxy(console, proxyHandler);
  }
  const debugConsole = createProxiedConsole();
  var AuthenticatorType;
  (function(AuthenticatorType2) {
    AuthenticatorType2[AuthenticatorType2["UNKNOWN"] = 0] = "UNKNOWN";
    AuthenticatorType2[AuthenticatorType2["PUSH"] = 1] = "PUSH";
    AuthenticatorType2[AuthenticatorType2["BACKUP_CODE"] = 2] = "BACKUP_CODE";
    AuthenticatorType2[AuthenticatorType2["BACKUP_OS"] = 3] = "BACKUP_OS";
    AuthenticatorType2[AuthenticatorType2["DUMMY"] = 4] = "DUMMY";
    AuthenticatorType2[AuthenticatorType2["ORGANIZATION_ADMIN"] = 5] = "ORGANIZATION_ADMIN";
    AuthenticatorType2[AuthenticatorType2["SESSION_UNLOCK"] = 6] = "SESSION_UNLOCK";
    AuthenticatorType2[AuthenticatorType2["WEBAUTHN"] = 7] = "WEBAUTHN";
    AuthenticatorType2[AuthenticatorType2["ORGANIZATION_SERVICE"] = 8] = "ORGANIZATION_SERVICE";
  })(AuthenticatorType || (AuthenticatorType = {}));
  proto3.util.setEnumType(AuthenticatorType, "domain.AuthenticatorType", [
    { no: 0, name: "AUTHENTICATOR_TYPE_UNKNOWN" },
    { no: 1, name: "AUTHENTICATOR_TYPE_PUSH" },
    { no: 2, name: "AUTHENTICATOR_TYPE_BACKUP_CODE" },
    { no: 3, name: "AUTHENTICATOR_TYPE_BACKUP_OS" },
    { no: 4, name: "AUTHENTICATOR_TYPE_DUMMY" },
    { no: 5, name: "AUTHENTICATOR_TYPE_ORGANIZATION_ADMIN" },
    { no: 6, name: "AUTHENTICATOR_TYPE_SESSION_UNLOCK" },
    { no: 7, name: "AUTHENTICATOR_TYPE_WEBAUTHN" },
    { no: 8, name: "AUTHENTICATOR_TYPE_ORGANIZATION_SERVICE" }
  ]);
  var CredentialType;
  (function(CredentialType2) {
    CredentialType2[CredentialType2["UNKNOWN"] = 0] = "UNKNOWN";
    CredentialType2[CredentialType2["SECURITY_KEY"] = 1] = "SECURITY_KEY";
    CredentialType2[CredentialType2["PASSKEY"] = 2] = "PASSKEY";
  })(CredentialType || (CredentialType = {}));
  proto3.util.setEnumType(CredentialType, "domain.CredentialType", [
    { no: 0, name: "CREDENTIAL_TYPE_UNKNOWN" },
    { no: 1, name: "CREDENTIAL_TYPE_SECURITY_KEY" },
    { no: 2, name: "CREDENTIAL_TYPE_PASSKEY" }
  ]);
  var SessionType;
  (function(SessionType2) {
    SessionType2[SessionType2["UNKNOWN"] = 0] = "UNKNOWN";
    SessionType2[SessionType2["SELF_UNLOCKING_PRIMARY"] = 1] = "SELF_UNLOCKING_PRIMARY";
    SessionType2[SessionType2["SELF_UNLOCKING_SECONDARY"] = 2] = "SELF_UNLOCKING_SECONDARY";
    SessionType2[SessionType2["BACKUP_OS"] = 3] = "BACKUP_OS";
    SessionType2[SessionType2["BACKUP_CODE"] = 4] = "BACKUP_CODE";
    SessionType2[SessionType2["CONNECTED"] = 5] = "CONNECTED";
  })(SessionType || (SessionType = {}));
  proto3.util.setEnumType(SessionType, "domain.SessionType", [
    { no: 0, name: "SESSION_TYPE_UNKNOWN" },
    { no: 1, name: "SESSION_TYPE_SELF_UNLOCKING_PRIMARY" },
    { no: 2, name: "SESSION_TYPE_SELF_UNLOCKING_SECONDARY" },
    { no: 3, name: "SESSION_TYPE_BACKUP_OS" },
    { no: 4, name: "SESSION_TYPE_BACKUP_CODE" },
    { no: 5, name: "SESSION_TYPE_CONNECTED" }
  ]);
  var Achievement;
  (function(Achievement2) {
    Achievement2[Achievement2["UNKNOWN"] = 0] = "UNKNOWN";
    Achievement2[Achievement2["BAE_REGISTER_ANDROID"] = 1] = "BAE_REGISTER_ANDROID";
    Achievement2[Achievement2["BAE_REGISTER_IOS"] = 2] = "BAE_REGISTER_IOS";
    Achievement2[Achievement2["BAE_REGISTER_WEB"] = 11] = "BAE_REGISTER_WEB";
    Achievement2[Achievement2["BAE_REGISTER_BAK"] = 12] = "BAE_REGISTER_BAK";
    Achievement2[Achievement2["BAE_INACTIVE_MARKED_FOR_DELETION"] = 3] = "BAE_INACTIVE_MARKED_FOR_DELETION";
    Achievement2[Achievement2["BAE_REACTIVATED"] = 4] = "BAE_REACTIVATED";
    Achievement2[Achievement2["BAE_ORG_ICON_FOUND"] = 5] = "BAE_ORG_ICON_FOUND";
    Achievement2[Achievement2["BAE_LOGIN_RECOVERY"] = 6] = "BAE_LOGIN_RECOVERY";
    Achievement2[Achievement2["BAE_LOGIN_BACKUP"] = 7] = "BAE_LOGIN_BACKUP";
    Achievement2[Achievement2["BAE_PRIVATE_PROFILE_DELETE"] = 8] = "BAE_PRIVATE_PROFILE_DELETE";
    Achievement2[Achievement2["BAE_LOGIN_INBOX_CREATE"] = 9] = "BAE_LOGIN_INBOX_CREATE";
    Achievement2[Achievement2["BAE_LOGIN_INBOX_MESSAGE"] = 10] = "BAE_LOGIN_INBOX_MESSAGE";
    Achievement2[Achievement2["AND_AUTOFILL_SETUP"] = 1e6] = "AND_AUTOFILL_SETUP";
    Achievement2[Achievement2["AND_AUTOFILL_ENABLE"] = 1000001] = "AND_AUTOFILL_ENABLE";
    Achievement2[Achievement2["AND_AUTOFILL_INSERT"] = 1000002] = "AND_AUTOFILL_INSERT";
    Achievement2[Achievement2["AND_AUTOFILL_UPDATE"] = 1000003] = "AND_AUTOFILL_UPDATE";
    Achievement2[Achievement2["AND_BACKUP_REGULAR"] = 1000100] = "AND_BACKUP_REGULAR";
    Achievement2[Achievement2["AND_BACKUP_E2E"] = 1000101] = "AND_BACKUP_E2E";
    Achievement2[Achievement2["AND_BACKUP_TRANSFER"] = 1000102] = "AND_BACKUP_TRANSFER";
    Achievement2[Achievement2["AND_REVIEW_CONDITIONS_FULFILLED"] = 1000200] = "AND_REVIEW_CONDITIONS_FULFILLED";
    Achievement2[Achievement2["AND_REVIEW_SHOWN"] = 1000201] = "AND_REVIEW_SHOWN";
    Achievement2[Achievement2["AND_REVIEW_STAYED_3_SECONDS"] = 1000202] = "AND_REVIEW_STAYED_3_SECONDS";
    Achievement2[Achievement2["AND_SCAN_CAMERA_REQUESTED"] = 1000300] = "AND_SCAN_CAMERA_REQUESTED";
    Achievement2[Achievement2["AND_SCAN_CAMERA_GRANTED"] = 1000301] = "AND_SCAN_CAMERA_GRANTED";
    Achievement2[Achievement2["AND_SCAN_SCANNED"] = 1000302] = "AND_SCAN_SCANNED";
    Achievement2[Achievement2["AND_SCAN_FROM_EXTERNAL"] = 1000303] = "AND_SCAN_FROM_EXTERNAL";
    Achievement2[Achievement2["AND_KEYSTORE_LOST_SHOWN_NO_BACKUP"] = 1000400] = "AND_KEYSTORE_LOST_SHOWN_NO_BACKUP";
    Achievement2[Achievement2["AND_KEYSTORE_LOST_SHOWN_BACKUP_AVAILABLE"] = 1000401] = "AND_KEYSTORE_LOST_SHOWN_BACKUP_AVAILABLE";
    Achievement2[Achievement2["AND_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED"] = 1000500] = "AND_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED";
    Achievement2[Achievement2["WEB_SESSION_CREATE"] = 2e6] = "WEB_SESSION_CREATE";
    Achievement2[Achievement2["WEB_SESSION_UNLOCK"] = 2000001] = "WEB_SESSION_UNLOCK";
    Achievement2[Achievement2["WEB_SESSION_PHONE"] = 2000010] = "WEB_SESSION_PHONE";
    Achievement2[Achievement2["WEB_SESSION_TABLET"] = 2000011] = "WEB_SESSION_TABLET";
    Achievement2[Achievement2["WEB_IMPORT_HEYLOGIN"] = 2000100] = "WEB_IMPORT_HEYLOGIN";
    Achievement2[Achievement2["WEB_IMPORT_BITWARDEN"] = 2000101] = "WEB_IMPORT_BITWARDEN";
    Achievement2[Achievement2["WEB_IMPORT_LASTPASS"] = 2000102] = "WEB_IMPORT_LASTPASS";
    Achievement2[Achievement2["WEB_IMPORT_CHROME"] = 2000103] = "WEB_IMPORT_CHROME";
    Achievement2[Achievement2["WEB_IMPORT_FIREFOX"] = 2000104] = "WEB_IMPORT_FIREFOX";
    Achievement2[Achievement2["WEB_IMPORT_DASHLANE"] = 2000105] = "WEB_IMPORT_DASHLANE";
    Achievement2[Achievement2["WEB_IMPORT_ONEPASSWORD"] = 2000106] = "WEB_IMPORT_ONEPASSWORD";
    Achievement2[Achievement2["WEB_IMPORT_KEEPASS"] = 2000107] = "WEB_IMPORT_KEEPASS";
    Achievement2[Achievement2["WEB_IMPORT_SAFARI"] = 2000108] = "WEB_IMPORT_SAFARI";
    Achievement2[Achievement2["WEB_IMPORT_NORDPASS"] = 2000109] = "WEB_IMPORT_NORDPASS";
    Achievement2[Achievement2["WEB_IMPORT_STICKYPASSWORD"] = 2000110] = "WEB_IMPORT_STICKYPASSWORD";
    Achievement2[Achievement2["WEB_IMPORT_CSV"] = 2000111] = "WEB_IMPORT_CSV";
    Achievement2[Achievement2["WEB_IMPORT_EXCEL"] = 2000112] = "WEB_IMPORT_EXCEL";
    Achievement2[Achievement2["WEB_IMPORT_ENPASS"] = 2000113] = "WEB_IMPORT_ENPASS";
    Achievement2[Achievement2["WEB_EXPORT"] = 2000200] = "WEB_EXPORT";
    Achievement2[Achievement2["WEB_LOGIN_ADD"] = 2000300] = "WEB_LOGIN_ADD";
    Achievement2[Achievement2["WEB_LOGIN_ADD_FIRST_MANUAL"] = 2000301] = "WEB_LOGIN_ADD_FIRST_MANUAL";
    Achievement2[Achievement2["WEB_USE_SEARCH_SHORTCUT"] = 2000302] = "WEB_USE_SEARCH_SHORTCUT";
    Achievement2[Achievement2["WEB_LOGIN_CREATE_SHARE_LINK"] = 2000303] = "WEB_LOGIN_CREATE_SHARE_LINK";
    Achievement2[Achievement2["WEB_PADDLE_SUBSCRIBE_OPENED"] = 2000400] = "WEB_PADDLE_SUBSCRIBE_OPENED";
    Achievement2[Achievement2["WEB_PADDLE_SUBSCRIBE_CLOSED"] = 2000401] = "WEB_PADDLE_SUBSCRIBE_CLOSED";
    Achievement2[Achievement2["WEB_PADDLE_SUBSCRIBE_COMPLETED"] = 2000402] = "WEB_PADDLE_SUBSCRIBE_COMPLETED";
    Achievement2[Achievement2["WEB_PADDLE_MANAGE_OPENED"] = 2000420] = "WEB_PADDLE_MANAGE_OPENED";
    Achievement2[Achievement2["WEB_PADDLE_MANAGE_CLOSED"] = 2000421] = "WEB_PADDLE_MANAGE_CLOSED";
    Achievement2[Achievement2["WEB_PADDLE_MANAGE_COMPLETED"] = 2000422] = "WEB_PADDLE_MANAGE_COMPLETED";
    Achievement2[Achievement2["WEB_ORGANIZATION_CREATE"] = 2000500] = "WEB_ORGANIZATION_CREATE";
    Achievement2[Achievement2["WEB_ORGANIZATION_JOIN"] = 2000501] = "WEB_ORGANIZATION_JOIN";
    Achievement2[Achievement2["WEB_ORGANIZATION_ADMIN_ACCESS_PERSONAL"] = 2000502] = "WEB_ORGANIZATION_ADMIN_ACCESS_PERSONAL";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_ADD_EXISTING"] = 2000510] = "WEB_ORGANIZATION_USER_ADD_EXISTING";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_REMOVE_EXISTING"] = 2000511] = "WEB_ORGANIZATION_USER_REMOVE_EXISTING";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_ADD_NEW"] = 2000512] = "WEB_ORGANIZATION_USER_ADD_NEW";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_REMOVE_NEW"] = 2000513] = "WEB_ORGANIZATION_USER_REMOVE_NEW";
    Achievement2[Achievement2["WEB_ORGANIZATION_USER_CHANGE_ACCESS_LEVEL"] = 2000514] = "WEB_ORGANIZATION_USER_CHANGE_ACCESS_LEVEL";
    Achievement2[Achievement2["WEB_ORGANIZATION_TEAM_CREATE"] = 2000520] = "WEB_ORGANIZATION_TEAM_CREATE";
    Achievement2[Achievement2["EXT_INSTALL"] = 3e6] = "EXT_INSTALL";
    Achievement2[Achievement2["EXT_DISABLE_FOR_PAGE"] = 3000001] = "EXT_DISABLE_FOR_PAGE";
    Achievement2[Achievement2["EXT_REPORT_PAGE"] = 3000002] = "EXT_REPORT_PAGE";
    Achievement2[Achievement2["EXT_LOGIN_INSERT"] = 3000100] = "EXT_LOGIN_INSERT";
    Achievement2[Achievement2["EXT_LOGIN_UPDATE"] = 3000101] = "EXT_LOGIN_UPDATE";
    Achievement2[Achievement2["EXT_AUTOSNATCH_FROM_LOGIN"] = 3000110] = "EXT_AUTOSNATCH_FROM_LOGIN";
    Achievement2[Achievement2["EXT_AUTOSNATCH_FROM_REGISTRATION"] = 3000111] = "EXT_AUTOSNATCH_FROM_REGISTRATION";
    Achievement2[Achievement2["EXT_OVERLAY_LOGIN"] = 3000200] = "EXT_OVERLAY_LOGIN";
    Achievement2[Achievement2["EXT_OVERLAY_UNLOCK"] = 3000201] = "EXT_OVERLAY_UNLOCK";
    Achievement2[Achievement2["EXT_OVERLAY_UPDATE_GENERATED_PASSWORD"] = 3000204] = "EXT_OVERLAY_UPDATE_GENERATED_PASSWORD";
    Achievement2[Achievement2["EXT_OVERLAY_DISABLE_AUTOSNATCH"] = 3000004] = "EXT_OVERLAY_DISABLE_AUTOSNATCH";
    Achievement2[Achievement2["EXT_OVERLAY_SAW_NAG_SCREEN"] = 3000005] = "EXT_OVERLAY_SAW_NAG_SCREEN";
    Achievement2[Achievement2["EXT_POPUP_OPEN"] = 3000300] = "EXT_POPUP_OPEN";
    Achievement2[Achievement2["EXT_POPUP_UNLOCK"] = 3000301] = "EXT_POPUP_UNLOCK";
    Achievement2[Achievement2["EXT_POPUP_DISABLE_AUTOSNATCH"] = 3000003] = "EXT_POPUP_DISABLE_AUTOSNATCH";
    Achievement2[Achievement2["EXT_OMNIBOX_INPUT_CHANGED"] = 3000400] = "EXT_OMNIBOX_INPUT_CHANGED";
    Achievement2[Achievement2["EXT_OMNIBOX_INPUT_ENTERED"] = 3000401] = "EXT_OMNIBOX_INPUT_ENTERED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_HEYLOGIN_ENABLED"] = 3000500] = "EXT_CONTEXT_MENU_HEYLOGIN_ENABLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_USERNAME_FILLED"] = 3000510] = "EXT_CONTEXT_MENU_USERNAME_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_PASSWORD_FILLED"] = 3000511] = "EXT_CONTEXT_MENU_PASSWORD_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_CUSTOM_TOTP_FILLED"] = 3000512] = "EXT_CONTEXT_MENU_CUSTOM_TOTP_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_CUSTOM_PLAIN_FILLED"] = 3000513] = "EXT_CONTEXT_MENU_CUSTOM_PLAIN_FILLED";
    Achievement2[Achievement2["EXT_CONTEXT_MENU_CUSTOM_PROTECTED_FILLED"] = 3000514] = "EXT_CONTEXT_MENU_CUSTOM_PROTECTED_FILLED";
    Achievement2[Achievement2["EXT_GLOBAL_SEARCH_OPEN"] = 3000600] = "EXT_GLOBAL_SEARCH_OPEN";
    Achievement2[Achievement2["EXT_GLOBAL_SEARCH_UNLOCK"] = 3000601] = "EXT_GLOBAL_SEARCH_UNLOCK";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_1"] = 4e6] = "COR_LOGINS_TOTAL_1";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_2"] = 4000001] = "COR_LOGINS_TOTAL_2";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_4"] = 4000002] = "COR_LOGINS_TOTAL_4";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_8"] = 4000003] = "COR_LOGINS_TOTAL_8";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_16"] = 4000004] = "COR_LOGINS_TOTAL_16";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_32"] = 4000005] = "COR_LOGINS_TOTAL_32";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_64"] = 4000006] = "COR_LOGINS_TOTAL_64";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_128"] = 4000007] = "COR_LOGINS_TOTAL_128";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_256"] = 4000008] = "COR_LOGINS_TOTAL_256";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_512"] = 4000009] = "COR_LOGINS_TOTAL_512";
    Achievement2[Achievement2["COR_LOGINS_TOTAL_1024"] = 4000010] = "COR_LOGINS_TOTAL_1024";
    Achievement2[Achievement2["COR_STORE_BACKUP_CODE_META_VAULT"] = 4000011] = "COR_STORE_BACKUP_CODE_META_VAULT";
    Achievement2[Achievement2["COR_LINKED_LOGIN_CREATE_PERSONAL"] = 4000012] = "COR_LINKED_LOGIN_CREATE_PERSONAL";
    Achievement2[Achievement2["COR_LINKED_LOGIN_CREATE_TEAM"] = 4000013] = "COR_LINKED_LOGIN_CREATE_TEAM";
    Achievement2[Achievement2["IOS_AUTOFILL_GUIDE_SETUP"] = 5e6] = "IOS_AUTOFILL_GUIDE_SETUP";
    Achievement2[Achievement2["IOS_AUTOFILL_ENABLE"] = 5000001] = "IOS_AUTOFILL_ENABLE";
    Achievement2[Achievement2["IOS_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED"] = 5000100] = "IOS_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED";
  })(Achievement || (Achievement = {}));
  proto3.util.setEnumType(Achievement, "domain.Achievement", [
    { no: 0, name: "UNKNOWN" },
    { no: 1, name: "BAE_REGISTER_ANDROID" },
    { no: 2, name: "BAE_REGISTER_IOS" },
    { no: 11, name: "BAE_REGISTER_WEB" },
    { no: 12, name: "BAE_REGISTER_BAK" },
    { no: 3, name: "BAE_INACTIVE_MARKED_FOR_DELETION" },
    { no: 4, name: "BAE_REACTIVATED" },
    { no: 5, name: "BAE_ORG_ICON_FOUND" },
    { no: 6, name: "BAE_LOGIN_RECOVERY" },
    { no: 7, name: "BAE_LOGIN_BACKUP" },
    { no: 8, name: "BAE_PRIVATE_PROFILE_DELETE" },
    { no: 9, name: "BAE_LOGIN_INBOX_CREATE" },
    { no: 10, name: "BAE_LOGIN_INBOX_MESSAGE" },
    { no: 1e6, name: "AND_AUTOFILL_SETUP" },
    { no: 1000001, name: "AND_AUTOFILL_ENABLE" },
    { no: 1000002, name: "AND_AUTOFILL_INSERT" },
    { no: 1000003, name: "AND_AUTOFILL_UPDATE" },
    { no: 1000100, name: "AND_BACKUP_REGULAR" },
    { no: 1000101, name: "AND_BACKUP_E2E" },
    { no: 1000102, name: "AND_BACKUP_TRANSFER" },
    { no: 1000200, name: "AND_REVIEW_CONDITIONS_FULFILLED" },
    { no: 1000201, name: "AND_REVIEW_SHOWN" },
    { no: 1000202, name: "AND_REVIEW_STAYED_3_SECONDS" },
    { no: 1000300, name: "AND_SCAN_CAMERA_REQUESTED" },
    { no: 1000301, name: "AND_SCAN_CAMERA_GRANTED" },
    { no: 1000302, name: "AND_SCAN_SCANNED" },
    { no: 1000303, name: "AND_SCAN_FROM_EXTERNAL" },
    { no: 1000400, name: "AND_KEYSTORE_LOST_SHOWN_NO_BACKUP" },
    { no: 1000401, name: "AND_KEYSTORE_LOST_SHOWN_BACKUP_AVAILABLE" },
    { no: 1000500, name: "AND_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED" },
    { no: 2e6, name: "WEB_SESSION_CREATE" },
    { no: 2000001, name: "WEB_SESSION_UNLOCK" },
    { no: 2000010, name: "WEB_SESSION_PHONE" },
    { no: 2000011, name: "WEB_SESSION_TABLET" },
    { no: 2000100, name: "WEB_IMPORT_HEYLOGIN" },
    { no: 2000101, name: "WEB_IMPORT_BITWARDEN" },
    { no: 2000102, name: "WEB_IMPORT_LASTPASS" },
    { no: 2000103, name: "WEB_IMPORT_CHROME" },
    { no: 2000104, name: "WEB_IMPORT_FIREFOX" },
    { no: 2000105, name: "WEB_IMPORT_DASHLANE" },
    { no: 2000106, name: "WEB_IMPORT_ONEPASSWORD" },
    { no: 2000107, name: "WEB_IMPORT_KEEPASS" },
    { no: 2000108, name: "WEB_IMPORT_SAFARI" },
    { no: 2000109, name: "WEB_IMPORT_NORDPASS" },
    { no: 2000110, name: "WEB_IMPORT_STICKYPASSWORD" },
    { no: 2000111, name: "WEB_IMPORT_CSV" },
    { no: 2000112, name: "WEB_IMPORT_EXCEL" },
    { no: 2000113, name: "WEB_IMPORT_ENPASS" },
    { no: 2000200, name: "WEB_EXPORT" },
    { no: 2000300, name: "WEB_LOGIN_ADD" },
    { no: 2000301, name: "WEB_LOGIN_ADD_FIRST_MANUAL" },
    { no: 2000302, name: "WEB_USE_SEARCH_SHORTCUT" },
    { no: 2000303, name: "WEB_LOGIN_CREATE_SHARE_LINK" },
    { no: 2000400, name: "WEB_PADDLE_SUBSCRIBE_OPENED" },
    { no: 2000401, name: "WEB_PADDLE_SUBSCRIBE_CLOSED" },
    { no: 2000402, name: "WEB_PADDLE_SUBSCRIBE_COMPLETED" },
    { no: 2000420, name: "WEB_PADDLE_MANAGE_OPENED" },
    { no: 2000421, name: "WEB_PADDLE_MANAGE_CLOSED" },
    { no: 2000422, name: "WEB_PADDLE_MANAGE_COMPLETED" },
    { no: 2000500, name: "WEB_ORGANIZATION_CREATE" },
    { no: 2000501, name: "WEB_ORGANIZATION_JOIN" },
    { no: 2000502, name: "WEB_ORGANIZATION_ADMIN_ACCESS_PERSONAL" },
    { no: 2000510, name: "WEB_ORGANIZATION_USER_ADD_EXISTING" },
    { no: 2000511, name: "WEB_ORGANIZATION_USER_REMOVE_EXISTING" },
    { no: 2000512, name: "WEB_ORGANIZATION_USER_ADD_NEW" },
    { no: 2000513, name: "WEB_ORGANIZATION_USER_REMOVE_NEW" },
    { no: 2000514, name: "WEB_ORGANIZATION_USER_CHANGE_ACCESS_LEVEL" },
    { no: 2000520, name: "WEB_ORGANIZATION_TEAM_CREATE" },
    { no: 3e6, name: "EXT_INSTALL" },
    { no: 3000001, name: "EXT_DISABLE_FOR_PAGE" },
    { no: 3000002, name: "EXT_REPORT_PAGE" },
    { no: 3000100, name: "EXT_LOGIN_INSERT" },
    { no: 3000101, name: "EXT_LOGIN_UPDATE" },
    { no: 3000110, name: "EXT_AUTOSNATCH_FROM_LOGIN" },
    { no: 3000111, name: "EXT_AUTOSNATCH_FROM_REGISTRATION" },
    { no: 3000200, name: "EXT_OVERLAY_LOGIN" },
    { no: 3000201, name: "EXT_OVERLAY_UNLOCK" },
    { no: 3000204, name: "EXT_OVERLAY_UPDATE_GENERATED_PASSWORD" },
    { no: 3000004, name: "EXT_OVERLAY_DISABLE_AUTOSNATCH" },
    { no: 3000005, name: "EXT_OVERLAY_SAW_NAG_SCREEN" },
    { no: 3000300, name: "EXT_POPUP_OPEN" },
    { no: 3000301, name: "EXT_POPUP_UNLOCK" },
    { no: 3000003, name: "EXT_POPUP_DISABLE_AUTOSNATCH" },
    { no: 3000400, name: "EXT_OMNIBOX_INPUT_CHANGED" },
    { no: 3000401, name: "EXT_OMNIBOX_INPUT_ENTERED" },
    { no: 3000500, name: "EXT_CONTEXT_MENU_HEYLOGIN_ENABLED" },
    { no: 3000510, name: "EXT_CONTEXT_MENU_USERNAME_FILLED" },
    { no: 3000511, name: "EXT_CONTEXT_MENU_PASSWORD_FILLED" },
    { no: 3000512, name: "EXT_CONTEXT_MENU_CUSTOM_TOTP_FILLED" },
    { no: 3000513, name: "EXT_CONTEXT_MENU_CUSTOM_PLAIN_FILLED" },
    { no: 3000514, name: "EXT_CONTEXT_MENU_CUSTOM_PROTECTED_FILLED" },
    { no: 3000600, name: "EXT_GLOBAL_SEARCH_OPEN" },
    { no: 3000601, name: "EXT_GLOBAL_SEARCH_UNLOCK" },
    { no: 4e6, name: "COR_LOGINS_TOTAL_1" },
    { no: 4000001, name: "COR_LOGINS_TOTAL_2" },
    { no: 4000002, name: "COR_LOGINS_TOTAL_4" },
    { no: 4000003, name: "COR_LOGINS_TOTAL_8" },
    { no: 4000004, name: "COR_LOGINS_TOTAL_16" },
    { no: 4000005, name: "COR_LOGINS_TOTAL_32" },
    { no: 4000006, name: "COR_LOGINS_TOTAL_64" },
    { no: 4000007, name: "COR_LOGINS_TOTAL_128" },
    { no: 4000008, name: "COR_LOGINS_TOTAL_256" },
    { no: 4000009, name: "COR_LOGINS_TOTAL_512" },
    { no: 4000010, name: "COR_LOGINS_TOTAL_1024" },
    { no: 4000011, name: "COR_STORE_BACKUP_CODE_META_VAULT" },
    { no: 4000012, name: "COR_LINKED_LOGIN_CREATE_PERSONAL" },
    { no: 4000013, name: "COR_LINKED_LOGIN_CREATE_TEAM" },
    { no: 5e6, name: "IOS_AUTOFILL_GUIDE_SETUP" },
    { no: 5000001, name: "IOS_AUTOFILL_ENABLE" },
    { no: 5000100, name: "IOS_SECOND_FACTOR_ENFORCEMENT_GRANDFATHERED" }
  ]);
  class UnlockTimeLimit extends Message {
    constructor(data) {
      super();
      this.enabled = false;
      this.minutes = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockTimeLimit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockTimeLimit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockTimeLimit().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UnlockTimeLimit, a2, b);
    }
  }
  UnlockTimeLimit.runtime = proto3;
  UnlockTimeLimit.typeName = "domain.UnlockTimeLimit";
  UnlockTimeLimit.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "minutes",
      kind: "scalar",
      T: 13
      /* ScalarType.UINT32 */
    }
  ]);
  var VaultType;
  (function(VaultType2) {
    VaultType2[VaultType2["UNKNOWN"] = 0] = "UNKNOWN";
    VaultType2[VaultType2["META"] = 1] = "META";
    VaultType2[VaultType2["PRIVATE"] = 2] = "PRIVATE";
    VaultType2[VaultType2["TEAM"] = 3] = "TEAM";
    VaultType2[VaultType2["TEAM_META"] = 4] = "TEAM_META";
    VaultType2[VaultType2["LEGACY_ORGANIZATION_ADMIN"] = 5] = "LEGACY_ORGANIZATION_ADMIN";
    VaultType2[VaultType2["ORGANIZATION_PERSONAL"] = 6] = "ORGANIZATION_PERSONAL";
    VaultType2[VaultType2["INBOX"] = 7] = "INBOX";
    VaultType2[VaultType2["INBOX_META"] = 8] = "INBOX_META";
    VaultType2[VaultType2["ORGANIZATION_ADMIN"] = 9] = "ORGANIZATION_ADMIN";
  })(VaultType || (VaultType = {}));
  proto3.util.setEnumType(VaultType, "domain.VaultType", [
    { no: 0, name: "VAULT_TYPE_UNKNOWN" },
    { no: 1, name: "VAULT_TYPE_META" },
    { no: 2, name: "VAULT_TYPE_PRIVATE" },
    { no: 3, name: "VAULT_TYPE_TEAM" },
    { no: 4, name: "VAULT_TYPE_TEAM_META" },
    { no: 5, name: "VAULT_TYPE_LEGACY_ORGANIZATION_ADMIN" },
    { no: 6, name: "VAULT_TYPE_ORGANIZATION_PERSONAL" },
    { no: 7, name: "VAULT_TYPE_INBOX" },
    { no: 8, name: "VAULT_TYPE_INBOX_META" },
    { no: 9, name: "VAULT_TYPE_ORGANIZATION_ADMIN" }
  ]);
  var WebauthnPrfSupportStatus;
  (function(WebauthnPrfSupportStatus2) {
    WebauthnPrfSupportStatus2[WebauthnPrfSupportStatus2["UNKNOWN"] = 0] = "UNKNOWN";
    WebauthnPrfSupportStatus2[WebauthnPrfSupportStatus2["UNAVAILABLE"] = 1] = "UNAVAILABLE";
    WebauthnPrfSupportStatus2[WebauthnPrfSupportStatus2["AVAILABLE"] = 2] = "AVAILABLE";
  })(WebauthnPrfSupportStatus || (WebauthnPrfSupportStatus = {}));
  proto3.util.setEnumType(WebauthnPrfSupportStatus, "domain.WebauthnPrfSupportStatus", [
    { no: 0, name: "WEBAUTHN_PRF_SUPPORT_STATUS_UNKNOWN" },
    { no: 1, name: "WEBAUTHN_PRF_SUPPORT_STATUS_UNAVAILABLE" },
    { no: 2, name: "WEBAUTHN_PRF_SUPPORT_STATUS_AVAILABLE" }
  ]);
  var OrganizationType;
  (function(OrganizationType2) {
    OrganizationType2[OrganizationType2["UNKNOWN"] = 0] = "UNKNOWN";
    OrganizationType2[OrganizationType2["COMPANY"] = 1] = "COMPANY";
  })(OrganizationType || (OrganizationType = {}));
  proto3.util.setEnumType(OrganizationType, "domain.OrganizationType", [
    { no: 0, name: "ORGANIZATION_TYPE_UNKNOWN" },
    { no: 1, name: "ORGANIZATION_TYPE_COMPANY" }
  ]);
  let VaultAuthenticatorLock$1 = class VaultAuthenticatorLock2 extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.encryptedStorableVaultKey = new Uint8Array(0);
      this.encryptedHighSecurityVaultKey = new Uint8Array(0);
      this.encryptedVaultMessagePrivateKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultAuthenticatorLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultAuthenticatorLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultAuthenticatorLock2().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VaultAuthenticatorLock2, a2, b);
    }
  };
  VaultAuthenticatorLock$1.runtime = proto3;
  VaultAuthenticatorLock$1.typeName = "domain.VaultAuthenticatorLock";
  VaultAuthenticatorLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  let VaultProfileLock$1 = class VaultProfileLock2 extends Message {
    constructor(data) {
      super();
      this.lockingProfileId = "";
      this.lockingProfileKeyGenerationId = "";
      this.encryptedStorableVaultKey = new Uint8Array(0);
      this.encryptedHighSecurityVaultKey = new Uint8Array(0);
      this.encryptedVaultMessagePrivateKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultProfileLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultProfileLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultProfileLock2().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VaultProfileLock2, a2, b);
    }
  };
  VaultProfileLock$1.runtime = proto3;
  VaultProfileLock$1.typeName = "domain.VaultProfileLock";
  VaultProfileLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "locking_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "locking_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  let ProfileAuthenticatorLock$1 = class ProfileAuthenticatorLock2 extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.encryptedHighSecurityProfileSeed = new Uint8Array(0);
      this.encryptedStorableProfileSeed = new Uint8Array(0);
      this.profileId = "";
      this.profileKeyGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileAuthenticatorLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileAuthenticatorLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileAuthenticatorLock2().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileAuthenticatorLock2, a2, b);
    }
  };
  ProfileAuthenticatorLock$1.runtime = proto3;
  ProfileAuthenticatorLock$1.typeName = "domain.ProfileAuthenticatorLock";
  ProfileAuthenticatorLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_high_security_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "encrypted_storable_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class VaultLockCreationData extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.associatedVaultId = "";
      this.associatedGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultLockCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultLockCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultLockCreationData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VaultLockCreationData, a2, b);
    }
  }
  VaultLockCreationData.runtime = proto3;
  VaultLockCreationData.typeName = "domain.VaultLockCreationData";
  VaultLockCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 4,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "associated_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "associated_lock", kind: "message", T: VaultProfileLock$1 }
  ]);
  let ProfileProfileLock$1 = class ProfileProfileLock2 extends Message {
    constructor(data) {
      super();
      this.lockingProfileId = "";
      this.lockingProfileKeyGenerationId = "";
      this.encryptedHighSecurityProfileSeed = new Uint8Array(0);
      this.encryptedStorableProfileSeed = new Uint8Array(0);
      this.profileId = "";
      this.profileKeyGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileProfileLock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileProfileLock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileProfileLock2().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileProfileLock2, a2, b);
    }
  };
  ProfileProfileLock$1.runtime = proto3;
  ProfileProfileLock$1.typeName = "domain.ProfileProfileLock";
  ProfileProfileLock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "locking_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "locking_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "encrypted_high_security_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_storable_profile_seed",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AuthenticatorData extends Message {
    constructor(data) {
      super();
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.highSecurityLoginSigPubKey = new Uint8Array(0);
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.secretInfo = "";
      this.secretSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AuthenticatorData, a2, b);
    }
  }
  AuthenticatorData.runtime = proto3;
  AuthenticatorData.typeName = "domain.AuthenticatorData";
  AuthenticatorData.fields = proto3.util.newFieldList(() => [
    { no: 12, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 2,
      name: "high_security_login_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "secret_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 13, name: "webauthn", kind: "message", T: AuthenticatorData_Webauthn }
  ]);
  class AuthenticatorData_Webauthn extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.prfSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorData_Webauthn().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorData_Webauthn().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorData_Webauthn().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AuthenticatorData_Webauthn, a2, b);
    }
  }
  AuthenticatorData_Webauthn.runtime = proto3;
  AuthenticatorData_Webauthn.typeName = "domain.AuthenticatorData.Webauthn";
  AuthenticatorData_Webauthn.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "prf_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class AuthenticatorCreationData extends Message {
    constructor(data) {
      super();
      this.profileLocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorCreationData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AuthenticatorCreationData, a2, b);
    }
  }
  AuthenticatorCreationData.runtime = proto3;
  AuthenticatorCreationData.typeName = "domain.AuthenticatorCreationData";
  AuthenticatorCreationData.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: AuthenticatorData },
    { no: 2, name: "profile_locks", kind: "message", T: ProfileAuthenticatorLock$1, repeated: true },
    { no: 3, name: "webauthn", kind: "message", T: AuthenticatorCreationData_WebauthnAuthenticatorCreationData }
  ]);
  class AuthenticatorCreationData_WebauthnAuthenticatorCreationData extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.prfSalt = new Uint8Array(0);
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      this.registerRequestId = "";
      this.responseJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorCreationData_WebauthnAuthenticatorCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorCreationData_WebauthnAuthenticatorCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorCreationData_WebauthnAuthenticatorCreationData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AuthenticatorCreationData_WebauthnAuthenticatorCreationData, a2, b);
    }
  }
  AuthenticatorCreationData_WebauthnAuthenticatorCreationData.runtime = proto3;
  AuthenticatorCreationData_WebauthnAuthenticatorCreationData.typeName = "domain.AuthenticatorCreationData.WebauthnAuthenticatorCreationData";
  AuthenticatorCreationData_WebauthnAuthenticatorCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "prf_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 3, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) },
    {
      no: 4,
      name: "register_request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  let Authenticator$1 = class Authenticator2 extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new Authenticator2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Authenticator2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Authenticator2().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Authenticator2, a2, b);
    }
  };
  Authenticator$1.runtime = proto3;
  Authenticator$1.typeName = "domain.Authenticator";
  Authenticator$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "data", kind: "message", T: AuthenticatorData }
  ]);
  let AuthenticatorBlock$1 = class AuthenticatorBlock2 extends Message {
    constructor(data) {
      super();
      this.blob = new Uint8Array(0);
      this.signature = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorBlock2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorBlock2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorBlock2().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AuthenticatorBlock2, a2, b);
    }
  };
  AuthenticatorBlock$1.runtime = proto3;
  AuthenticatorBlock$1.typeName = "domain.AuthenticatorBlock";
  AuthenticatorBlock$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  var LicenseType;
  (function(LicenseType2) {
    LicenseType2[LicenseType2["UNKNOWN"] = 0] = "UNKNOWN";
    LicenseType2[LicenseType2["NONE"] = 1] = "NONE";
    LicenseType2[LicenseType2["COUPON"] = 2] = "COUPON";
    LicenseType2[LicenseType2["PADDLE"] = 3] = "PADDLE";
    LicenseType2[LicenseType2["NONPROFIT"] = 4] = "NONPROFIT";
    LicenseType2[LicenseType2["CONTRACT"] = 5] = "CONTRACT";
    LicenseType2[LicenseType2["CUSTOM"] = 6] = "CUSTOM";
    LicenseType2[LicenseType2["MSP"] = 7] = "MSP";
    LicenseType2[LicenseType2["EXAMPLE"] = 8] = "EXAMPLE";
  })(LicenseType || (LicenseType = {}));
  proto3.util.setEnumType(LicenseType, "domain.LicenseType", [
    { no: 0, name: "LICENSE_TYPE_UNKNOWN" },
    { no: 1, name: "LICENSE_TYPE_NONE" },
    { no: 2, name: "LICENSE_TYPE_COUPON" },
    { no: 3, name: "LICENSE_TYPE_PADDLE" },
    { no: 4, name: "LICENSE_TYPE_NONPROFIT" },
    { no: 5, name: "LICENSE_TYPE_CONTRACT" },
    { no: 6, name: "LICENSE_TYPE_CUSTOM" },
    { no: 7, name: "LICENSE_TYPE_MSP" },
    { no: 8, name: "LICENSE_TYPE_EXAMPLE" }
  ]);
  var PrimaryLoginDevice;
  (function(PrimaryLoginDevice2) {
    PrimaryLoginDevice2[PrimaryLoginDevice2["UNKNOWN"] = 0] = "UNKNOWN";
    PrimaryLoginDevice2[PrimaryLoginDevice2["NONE"] = 1] = "NONE";
    PrimaryLoginDevice2[PrimaryLoginDevice2["PHONE"] = 2] = "PHONE";
    PrimaryLoginDevice2[PrimaryLoginDevice2["SECURITY_KEY"] = 3] = "SECURITY_KEY";
    PrimaryLoginDevice2[PrimaryLoginDevice2["SERVICE"] = 4] = "SERVICE";
  })(PrimaryLoginDevice || (PrimaryLoginDevice = {}));
  proto3.util.setEnumType(PrimaryLoginDevice, "domain.PrimaryLoginDevice", [
    { no: 0, name: "PRIMARY_LOGIN_DEVICE_UNKNOWN" },
    { no: 1, name: "PRIMARY_LOGIN_DEVICE_NONE" },
    { no: 2, name: "PRIMARY_LOGIN_DEVICE_PHONE" },
    { no: 3, name: "PRIMARY_LOGIN_DEVICE_SECURITY_KEY" },
    { no: 4, name: "PRIMARY_LOGIN_DEVICE_SERVICE" }
  ]);
  var ProfileType;
  (function(ProfileType2) {
    ProfileType2[ProfileType2["UNKNOWN"] = 0] = "UNKNOWN";
    ProfileType2[ProfileType2["PREFERENCES"] = 1] = "PREFERENCES";
    ProfileType2[ProfileType2["INBOX"] = 2] = "INBOX";
    ProfileType2[ProfileType2["PRIVATE"] = 3] = "PRIVATE";
    ProfileType2[ProfileType2["ORGANIZATION"] = 4] = "ORGANIZATION";
    ProfileType2[ProfileType2["ORGANIZATION_ADMIN"] = 5] = "ORGANIZATION_ADMIN";
    ProfileType2[ProfileType2["ORGANIZATION_SERVICE"] = 6] = "ORGANIZATION_SERVICE";
  })(ProfileType || (ProfileType = {}));
  proto3.util.setEnumType(ProfileType, "domain.ProfileType", [
    { no: 0, name: "PROFILE_TYPE_UNKNOWN" },
    { no: 1, name: "PROFILE_TYPE_PREFERENCES" },
    { no: 2, name: "PROFILE_TYPE_INBOX" },
    { no: 3, name: "PROFILE_TYPE_PRIVATE" },
    { no: 4, name: "PROFILE_TYPE_ORGANIZATION" },
    { no: 5, name: "PROFILE_TYPE_ORGANIZATION_ADMIN" },
    { no: 6, name: "PROFILE_TYPE_ORGANIZATION_SERVICE" }
  ]);
  var MaintenanceTask;
  (function(MaintenanceTask2) {
    MaintenanceTask2[MaintenanceTask2["UNKNOWN"] = 0] = "UNKNOWN";
    MaintenanceTask2[MaintenanceTask2["TEAM_SYNC_ORGANIZATION_MEMBERS_V2"] = 9] = "TEAM_SYNC_ORGANIZATION_MEMBERS_V2";
    MaintenanceTask2[MaintenanceTask2["ORGANIZATION_PRELIMINARY_PROFILES_V3"] = 12] = "ORGANIZATION_PRELIMINARY_PROFILES_V3";
    MaintenanceTask2[MaintenanceTask2["ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2"] = 15] = "ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2";
    MaintenanceTask2[MaintenanceTask2["PROCESS_VAULT_MESSAGES_V2"] = 11] = "PROCESS_VAULT_MESSAGES_V2";
    MaintenanceTask2[MaintenanceTask2["MIGRATE_TO_PROFILES_V1"] = 7] = "MIGRATE_TO_PROFILES_V1";
    MaintenanceTask2[MaintenanceTask2["ENABLE_PRF_OPPORTUNISTICALLY_V1"] = 14] = "ENABLE_PRF_OPPORTUNISTICALLY_V1";
  })(MaintenanceTask || (MaintenanceTask = {}));
  proto3.util.setEnumType(MaintenanceTask, "domain.MaintenanceTask", [
    { no: 0, name: "MAINTENANCE_TASK_UNKNOWN" },
    { no: 9, name: "MAINTENANCE_TASK_TEAM_SYNC_ORGANIZATION_MEMBERS_V2" },
    { no: 12, name: "MAINTENANCE_TASK_ORGANIZATION_PRELIMINARY_PROFILES_V3" },
    { no: 15, name: "MAINTENANCE_TASK_ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2" },
    { no: 11, name: "MAINTENANCE_TASK_PROCESS_VAULT_MESSAGES_V2" },
    { no: 7, name: "MAINTENANCE_TASK_MIGRATE_TO_PROFILES_V1" },
    { no: 14, name: "MAINTENANCE_TASK_ENABLE_PRF_OPPORTUNISTICALLY_V1" }
  ]);
  var SyncUpdateField;
  (function(SyncUpdateField2) {
    SyncUpdateField2[SyncUpdateField2["SU_UNKNOWN"] = 0] = "SU_UNKNOWN";
    SyncUpdateField2[SyncUpdateField2["SU_USER"] = 1] = "SU_USER";
    SyncUpdateField2[SyncUpdateField2["SU_SESSIONS"] = 2] = "SU_SESSIONS";
    SyncUpdateField2[SyncUpdateField2["SU_VAULTS"] = 3] = "SU_VAULTS";
    SyncUpdateField2[SyncUpdateField2["SU_ACHIEVEMENTS"] = 4] = "SU_ACHIEVEMENTS";
    SyncUpdateField2[SyncUpdateField2["SU_CHANNELS"] = 5] = "SU_CHANNELS";
    SyncUpdateField2[SyncUpdateField2["SU_ORGANIZATIONS"] = 6] = "SU_ORGANIZATIONS";
    SyncUpdateField2[SyncUpdateField2["SU_RELATED_PROFILES"] = 7] = "SU_RELATED_PROFILES";
    SyncUpdateField2[SyncUpdateField2["SU_PROFILES"] = 8] = "SU_PROFILES";
    SyncUpdateField2[SyncUpdateField2["SU_MAINTENANCE_SETTINGS"] = 9] = "SU_MAINTENANCE_SETTINGS";
  })(SyncUpdateField || (SyncUpdateField = {}));
  proto3.util.setEnumType(SyncUpdateField, "domain.SyncUpdateField", [
    { no: 0, name: "SU_UNKNOWN" },
    { no: 1, name: "SU_USER" },
    { no: 2, name: "SU_SESSIONS" },
    { no: 3, name: "SU_VAULTS" },
    { no: 4, name: "SU_ACHIEVEMENTS" },
    { no: 5, name: "SU_CHANNELS" },
    { no: 6, name: "SU_ORGANIZATIONS" },
    { no: 7, name: "SU_RELATED_PROFILES" },
    { no: 8, name: "SU_PROFILES" },
    { no: 9, name: "SU_MAINTENANCE_SETTINGS" }
  ]);
  var SubscriptionError;
  (function(SubscriptionError2) {
    SubscriptionError2[SubscriptionError2["OK"] = 0] = "OK";
    SubscriptionError2[SubscriptionError2["TRIAL_EXCEEDED"] = 1] = "TRIAL_EXCEEDED";
    SubscriptionError2[SubscriptionError2["PADDLE_PAUSED"] = 2] = "PADDLE_PAUSED";
  })(SubscriptionError || (SubscriptionError = {}));
  proto3.util.setEnumType(SubscriptionError, "domain.SubscriptionError", [
    { no: 0, name: "SUBSCRIPTION_ERROR_OK" },
    { no: 1, name: "SUBSCRIPTION_ERROR_TRIAL_EXCEEDED" },
    { no: 2, name: "SUBSCRIPTION_ERROR_PADDLE_PAUSED" }
  ]);
  class SyncUpdate extends Message {
    constructor(data) {
      super();
      this.syncVersion = protoInt64.zero;
      this.tokenRefreshNeeded = false;
      this.clientOutdated = false;
      this.updatedFields = [];
      this.sessions = [];
      this.vaults = [];
      this.achievements = [];
      this.channels = [];
      this.organizations = [];
      this.relatedProfiles = [];
      this.profiles = [];
      this.preliminaryProfiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate, a2, b);
    }
  }
  SyncUpdate.runtime = proto3;
  SyncUpdate.typeName = "domain.SyncUpdate";
  SyncUpdate.fields = proto3.util.newFieldList(() => [
    { no: 7, name: "server_time", kind: "message", T: Timestamp },
    {
      no: 15,
      name: "sync_version",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 21,
      name: "token_refresh_needed",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 22,
      name: "client_outdated",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 11, name: "updated_fields", kind: "enum", T: proto3.getEnumType(SyncUpdateField), repeated: true },
    { no: 4, name: "session_unlock", kind: "message", T: SyncUpdate_SessionUnlock },
    { no: 8, name: "user", kind: "message", T: SyncUpdate_User },
    { no: 1, name: "sessions", kind: "message", T: SyncUpdate_Session, repeated: true },
    { no: 2, name: "vaults", kind: "message", T: SyncUpdate_Vault, repeated: true },
    { no: 6, name: "achievements", kind: "enum", T: proto3.getEnumType(Achievement), repeated: true },
    { no: 3, name: "channels", kind: "message", T: SyncUpdate_Channel, repeated: true },
    { no: 13, name: "organizations", kind: "message", T: SyncUpdate_Organization, repeated: true },
    { no: 18, name: "related_profiles", kind: "message", T: SyncUpdate_RelatedProfile, repeated: true },
    { no: 17, name: "profiles", kind: "message", T: SyncUpdate_Profile, repeated: true },
    { no: 19, name: "maintenance_settings", kind: "message", T: SyncUpdate_MaintenanceSettings },
    { no: 20, name: "preliminary_profiles", kind: "message", T: SyncUpdate_PreliminaryProfile, repeated: true }
  ]);
  class SyncUpdate_Session extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.sessionType = SessionType.UNKNOWN;
      this.clientSettings = "";
      this.enabledProfileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Session().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Session().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Session().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Session, a2, b);
    }
  }
  SyncUpdate_Session.runtime = proto3;
  SyncUpdate_Session.typeName = "domain.SyncUpdate.Session";
  SyncUpdate_Session.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "last_used_at", kind: "message", T: Timestamp },
    { no: 4, name: "unlocked_at", kind: "message", T: Timestamp },
    { no: 5, name: "unlocked_until", kind: "message", T: Timestamp },
    { no: 6, name: "unlock_requested_at", kind: "message", T: Timestamp },
    { no: 12, name: "unlock_extend_at", kind: "message", T: Timestamp },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
    { no: 9, name: "session_type", kind: "enum", T: proto3.getEnumType(SessionType) },
    {
      no: 8,
      name: "client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 10, name: "enabled_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 11, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit }
  ]);
  class SyncUpdate_Vault extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.commitId = "";
      this.generationId = "";
      this.associatedVaultId = "";
      this.organizationId = "";
      this.users = [];
      this.profiles = [];
      this.vaultType = VaultType.UNKNOWN;
      this.dirty = false;
      this.profileKeyGenerationId = "";
      this.adminProfileKeyGenerationId = "";
      this.messagePublicKey = new Uint8Array(0);
      this.hasMessagesQueued = false;
      this.inboxSlug = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Vault().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Vault().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Vault().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Vault, a2, b);
    }
  }
  SyncUpdate_Vault.runtime = proto3;
  SyncUpdate_Vault.typeName = "domain.SyncUpdate.Vault";
  SyncUpdate_Vault.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "users", kind: "message", T: SyncUpdate_Vault_User, repeated: true },
    { no: 11, name: "profiles", kind: "message", T: SyncUpdate_Vault_Profile, repeated: true },
    { no: 5, name: "vault_type", kind: "enum", T: proto3.getEnumType(VaultType) },
    {
      no: 19,
      name: "dirty",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 12,
      name: "profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 18,
      name: "admin_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 15,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 16,
      name: "has_messages_queued",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 17,
      name: "inbox_slug",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Vault_User extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Vault_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Vault_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Vault_User().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Vault_User, a2, b);
    }
  }
  SyncUpdate_Vault_User.runtime = proto3;
  SyncUpdate_Vault_User.typeName = "domain.SyncUpdate.Vault.User";
  SyncUpdate_Vault_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Vault_Profile extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Vault_Profile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Vault_Profile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Vault_Profile().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Vault_Profile, a2, b);
    }
  }
  SyncUpdate_Vault_Profile.runtime = proto3;
  SyncUpdate_Vault_Profile.typeName = "domain.SyncUpdate.Vault.Profile";
  SyncUpdate_Vault_Profile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Channel extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.channelType = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Channel().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Channel().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Channel().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Channel, a2, b);
    }
  }
  SyncUpdate_Channel.runtime = proto3;
  SyncUpdate_Channel.typeName = "domain.SyncUpdate.Channel";
  SyncUpdate_Channel.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "channel_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_SessionUnlock extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_SessionUnlock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_SessionUnlock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_SessionUnlock().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_SessionUnlock, a2, b);
    }
  }
  SyncUpdate_SessionUnlock.runtime = proto3;
  SyncUpdate_SessionUnlock.typeName = "domain.SyncUpdate.SessionUnlock";
  SyncUpdate_SessionUnlock.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Authenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.highSecurityLoginSigPubKey = new Uint8Array(0);
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.secretInfo = "";
      this.secretSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Authenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Authenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Authenticator().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Authenticator, a2, b);
    }
  }
  SyncUpdate_Authenticator.runtime = proto3;
  SyncUpdate_Authenticator.typeName = "domain.SyncUpdate.Authenticator";
  SyncUpdate_Authenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 13, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 3,
      name: "high_security_login_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "secret_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class SyncUpdate_User extends Message {
    constructor(data) {
      super();
      this.serverSideSettings = "";
      this.authenticatorBlockHash = new Uint8Array(0);
      this.preferredLocale = "";
      this.emails = [];
      this.preliminaryEmail = "";
      this.webauthnCredentials = [];
      this.userClientSettings = "";
      this.openUserConfirmationIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_User().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_User, a2, b);
    }
  }
  SyncUpdate_User.runtime = proto3;
  SyncUpdate_User.typeName = "domain.SyncUpdate.User";
  SyncUpdate_User.fields = proto3.util.newFieldList(() => [
    {
      no: 3,
      name: "server_side_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "authenticator_block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "preferred_locale",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "emails", kind: "message", T: SyncUpdate_User_Email, repeated: true },
    {
      no: 8,
      name: "preliminary_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "webauthn_credentials", kind: "message", T: SyncUpdate_User_WebauthnCredential, repeated: true },
    {
      no: 10,
      name: "user_client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 11, name: "open_user_confirmation_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class SyncUpdate_User_Email extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.verificationPending = false;
      this.primary = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_User_Email().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_User_Email().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_User_Email().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_User_Email, a2, b);
    }
  }
  SyncUpdate_User_Email.runtime = proto3;
  SyncUpdate_User_Email.typeName = "domain.SyncUpdate.User.Email";
  SyncUpdate_User_Email.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "verification_pending",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "primary",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class SyncUpdate_User_WebauthnCredential extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.aaguid = "";
      this.credentialType = CredentialType.UNKNOWN;
      this.sessionId = "";
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_User_WebauthnCredential().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_User_WebauthnCredential().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_User_WebauthnCredential().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_User_WebauthnCredential, a2, b);
    }
  }
  SyncUpdate_User_WebauthnCredential.runtime = proto3;
  SyncUpdate_User_WebauthnCredential.typeName = "domain.SyncUpdate.User.WebauthnCredential";
  SyncUpdate_User_WebauthnCredential.fields = proto3.util.newFieldList(() => [
    {
      no: 7,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "aaguid",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "last_used_at", kind: "message", T: Timestamp },
    { no: 5, name: "credential_type", kind: "enum", T: proto3.getEnumType(CredentialType) },
    {
      no: 6,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 8, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) }
  ]);
  class SyncUpdate_Organization extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.organizationType = OrganizationType.UNKNOWN;
      this.profiles = [];
      this.name = "";
      this.icon = "";
      this.restrictCreateTeam = false;
      this.restrictPersonalLogins = false;
      this.auditlogEnable = false;
      this.childOrganizationManagementEnable = false;
      this.passwordPolicy = "";
      this.isPreliminary = false;
      this.isAdmin = false;
      this.isManager = false;
      this.superUserId = "";
      this.adminProfileId = "";
      this.subscriptionError = SubscriptionError.OK;
      this.verifiedDomain = "";
      this.clientSettings = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Organization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Organization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Organization().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Organization, a2, b);
    }
  }
  SyncUpdate_Organization.runtime = proto3;
  SyncUpdate_Organization.typeName = "domain.SyncUpdate.Organization";
  SyncUpdate_Organization.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 20, name: "organization_type", kind: "enum", T: proto3.getEnumType(OrganizationType) },
    { no: 10, name: "profiles", kind: "message", T: SyncUpdate_OrganizationProfile, repeated: true },
    {
      no: 3,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 12,
      name: "restrict_create_team",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 19,
      name: "restrict_personal_logins",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 14,
      name: "auditlog_enable",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 21,
      name: "child_organization_management_enable",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 23,
      name: "password_policy",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 26, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit },
    {
      no: 13,
      name: "is_preliminary",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 24,
      name: "is_manager",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 7,
      name: "super_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 16,
      name: "admin_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 15, name: "admin_info", kind: "message", T: SyncUpdate_Organization_AdminInfo },
    { no: 11, name: "subscription_error", kind: "enum", T: proto3.getEnumType(SubscriptionError) },
    {
      no: 17,
      name: "verified_domain",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 25,
      name: "client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 27, name: "parent_organization_info", kind: "message", T: SyncUpdate_Organization_ParentOrganizationInfo }
  ]);
  class SyncUpdate_Organization_AdminInfo extends Message {
    constructor(data) {
      super();
      this.legacyAdminVaultId = "";
      this.entraTenantId = "";
      this.csvIntegrationActive = false;
      this.googleWorkspaceIntegrationActive = false;
      this.licenseType = LicenseType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Organization_AdminInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Organization_AdminInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Organization_AdminInfo().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Organization_AdminInfo, a2, b);
    }
  }
  SyncUpdate_Organization_AdminInfo.runtime = proto3;
  SyncUpdate_Organization_AdminInfo.typeName = "domain.SyncUpdate.Organization.AdminInfo";
  SyncUpdate_Organization_AdminInfo.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "legacy_admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticator", kind: "message", T: Authenticator$1 },
    { no: 9, name: "admin_profile", kind: "message", T: SyncUpdate_Profile },
    {
      no: 6,
      name: "entra_tenant_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "csv_integration_active",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: "google_workspace_integration_active",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 10, name: "trial_end_date", kind: "message", T: Timestamp },
    { no: 11, name: "license_type", kind: "enum", T: proto3.getEnumType(LicenseType) }
  ]);
  class SyncUpdate_Organization_ParentOrganizationInfo extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.name = "";
      this.icon = "";
      this.metadata = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Organization_ParentOrganizationInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Organization_ParentOrganizationInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Organization_ParentOrganizationInfo().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Organization_ParentOrganizationInfo, a2, b);
    }
  }
  SyncUpdate_Organization_ParentOrganizationInfo.runtime = proto3;
  SyncUpdate_Organization_ParentOrganizationInfo.typeName = "domain.SyncUpdate.Organization.ParentOrganizationInfo";
  SyncUpdate_Organization_ParentOrganizationInfo.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_OrganizationProfile extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      this.isAdmin = false;
      this.isNotConnected = false;
      this.isManager = false;
      this.isService = false;
      this.personalVaultId = "";
      this.preliminaryUserId = "";
      this.startCode = "";
      this.primaryLoginDevice = PrimaryLoginDevice.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_OrganizationProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_OrganizationProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_OrganizationProfile().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_OrganizationProfile, a2, b);
    }
  }
  SyncUpdate_OrganizationProfile.runtime = proto3;
  SyncUpdate_OrganizationProfile.typeName = "domain.SyncUpdate.OrganizationProfile";
  SyncUpdate_OrganizationProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: "is_not_connected",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 14,
      name: "is_manager",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 15,
      name: "is_service",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 8,
      name: "personal_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "preliminary_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 10, name: "start_code_generated_at", kind: "message", T: Timestamp },
    { no: 11, name: "start_code_email_sent_at", kind: "message", T: Timestamp },
    { no: 12, name: "primary_login_device", kind: "enum", T: proto3.getEnumType(PrimaryLoginDevice) },
    { no: 13, name: "last_active_at", kind: "message", T: Timestamp }
  ]);
  class SyncUpdate_RelatedProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_RelatedProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_RelatedProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_RelatedProfile().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_RelatedProfile, a2, b);
    }
  }
  SyncUpdate_RelatedProfile.runtime = proto3;
  SyncUpdate_RelatedProfile.typeName = "domain.SyncUpdate.RelatedProfile";
  SyncUpdate_RelatedProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_Profile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.profileType = ProfileType.UNKNOWN;
      this.keyGenerationId = "";
      this.organizationId = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKey = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableProfileSeedEncPubKey = new Uint8Array(0);
      this.storableProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.email = "";
      this.unverifiedEmail = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_Profile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_Profile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_Profile().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_Profile, a2, b);
    }
  }
  SyncUpdate_Profile.runtime = proto3;
  SyncUpdate_Profile.typeName = "domain.SyncUpdate.Profile";
  SyncUpdate_Profile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_type", kind: "enum", T: proto3.getEnumType(ProfileType) },
    {
      no: 3,
      name: "key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "high_security_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "high_security_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: "storable_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 15,
      name: "storable_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 16, name: "authenticator_locks", kind: "message", T: ProfileAuthenticatorLock$1, repeated: true },
    { no: 19, name: "profile_lock", kind: "message", T: ProfileProfileLock$1 },
    {
      no: 17,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 18,
      name: "unverified_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_PreliminaryProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.email = "";
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_PreliminaryProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_PreliminaryProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_PreliminaryProfile().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_PreliminaryProfile, a2, b);
    }
  }
  SyncUpdate_PreliminaryProfile.runtime = proto3;
  SyncUpdate_PreliminaryProfile.typeName = "domain.SyncUpdate.PreliminaryProfile";
  SyncUpdate_PreliminaryProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncUpdate_MaintenanceSettings extends Message {
    constructor(data) {
      super();
      this.allowedTasks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncUpdate_MaintenanceSettings().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncUpdate_MaintenanceSettings().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncUpdate_MaintenanceSettings().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncUpdate_MaintenanceSettings, a2, b);
    }
  }
  SyncUpdate_MaintenanceSettings.runtime = proto3;
  SyncUpdate_MaintenanceSettings.typeName = "domain.SyncUpdate.MaintenanceSettings";
  SyncUpdate_MaintenanceSettings.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed_tasks", kind: "enum", T: proto3.getEnumType(MaintenanceTask), repeated: true }
  ]);
  const trackErrorEmitterInternal = new Emittery$3.Typed();
  function trackError(errorObject) {
    let error2;
    trackErrorEmitterInternal.emit("error", errorObject).catch(suppressError);
    if (typeof errorObject === "object" && errorObject != null && "stack" in errorObject && errorObject.stack) {
      error2 = errorObject;
      debugConsole.error(error2);
    } else if (typeof errorObject === "object" && errorObject !== null) {
      const keys2 = Object.keys(errorObject).join(", ");
      if (hasMessage(errorObject)) {
        const message = errorObject.message;
        error2 = new Error(`Non-error object captured with message "${message}" and keys: ${keys2}`);
      } else {
        error2 = new Error(`Non-error object captured with keys: ${keys2}`);
      }
      debugConsole.error(error2, errorObject);
    } else {
      error2 = new Error(`Non-error captured`);
      debugConsole.error(error2, errorObject);
    }
    withScope$1((localScope) => {
      localScope.setExtra("__serialized__", errorObject);
      captureException$1(error2);
    });
  }
  function hasMessage(obj) {
    return "message" in obj;
  }
  function suppressError(_e2) {
  }
  var ChannelRecipient;
  (function(ChannelRecipient2) {
    ChannelRecipient2[ChannelRecipient2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    ChannelRecipient2[ChannelRecipient2["CLIENT"] = 1] = "CLIENT";
    ChannelRecipient2[ChannelRecipient2["AUTHENTICATOR"] = 2] = "AUTHENTICATOR";
  })(ChannelRecipient || (ChannelRecipient = {}));
  proto3.util.setEnumType(ChannelRecipient, "domain.ChannelRecipient", [
    { no: 0, name: "CHANNEL_RECIPIENT_UNSPECIFIED" },
    { no: 1, name: "CHANNEL_RECIPIENT_CLIENT" },
    { no: 2, name: "CHANNEL_RECIPIENT_AUTHENTICATOR" }
  ]);
  class CreateChannelRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.data = new Uint8Array(0);
      this.exposed = false;
      this.channelType = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateChannelRequest, a2, b);
    }
  }
  CreateChannelRequest.runtime = proto3;
  CreateChannelRequest.typeName = "domain.CreateChannelRequest";
  CreateChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "exposed",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 4,
      name: "channel_type",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateChannelResponse extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateChannelResponse, a2, b);
    }
  }
  CreateChannelResponse.runtime = proto3;
  CreateChannelResponse.typeName = "domain.CreateChannelResponse";
  CreateChannelResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      this.authenticatorId = "";
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ClaimChannelRequest, a2, b);
    }
  }
  ClaimChannelRequest.runtime = proto3;
  ClaimChannelRequest.typeName = "domain.ClaimChannelRequest";
  ClaimChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ClaimChannelResponse extends Message {
    constructor(data) {
      super();
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ClaimChannelResponse, a2, b);
    }
  }
  ClaimChannelResponse.runtime = proto3;
  ClaimChannelResponse.typeName = "domain.ClaimChannelResponse";
  ClaimChannelResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ReadChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      this.recipient = ChannelRecipient.UNSPECIFIED;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReadChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReadChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReadChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ReadChannelRequest, a2, b);
    }
  }
  ReadChannelRequest.runtime = proto3;
  ReadChannelRequest.typeName = "domain.ReadChannelRequest";
  ReadChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "recipient", kind: "enum", T: proto3.getEnumType(ChannelRecipient) }
  ]);
  class ReadChannelResponse extends Message {
    constructor(data) {
      super();
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReadChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReadChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReadChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ReadChannelResponse, a2, b);
    }
  }
  ReadChannelResponse.runtime = proto3;
  ReadChannelResponse.typeName = "domain.ReadChannelResponse";
  ReadChannelResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class WriteChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      this.recipient = ChannelRecipient.UNSPECIFIED;
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(WriteChannelRequest, a2, b);
    }
  }
  WriteChannelRequest.runtime = proto3;
  WriteChannelRequest.typeName = "domain.WriteChannelRequest";
  WriteChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "recipient", kind: "enum", T: proto3.getEnumType(ChannelRecipient) },
    {
      no: 3,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class WriteChannelResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(WriteChannelResponse, a2, b);
    }
  }
  WriteChannelResponse.runtime = proto3;
  WriteChannelResponse.typeName = "domain.WriteChannelResponse";
  WriteChannelResponse.fields = proto3.util.newFieldList(() => []);
  class DeleteChannelRequest extends Message {
    constructor(data) {
      super();
      this.channelId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteChannelRequest, a2, b);
    }
  }
  DeleteChannelRequest.runtime = proto3;
  DeleteChannelRequest.typeName = "domain.DeleteChannelRequest";
  DeleteChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "channel_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteChannelResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteChannelResponse, a2, b);
    }
  }
  DeleteChannelResponse.runtime = proto3;
  DeleteChannelResponse.typeName = "domain.DeleteChannelResponse";
  DeleteChannelResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ProfileData extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.keyGenerationId = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKey = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableProfileSeedEncPubKey = new Uint8Array(0);
      this.storableProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.upstreamProfileLocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileData, a2, b);
    }
  }
  ProfileData.runtime = proto3;
  ProfileData.typeName = "domain.ProfileData";
  ProfileData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "high_security_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "storable_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "storable_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 14, name: "authenticator_locks", kind: "message", T: ProfileAuthenticatorLock$1, repeated: true },
    { no: 16, name: "upstream_profile_locks", kind: "message", T: ProfileProfileLock$1, repeated: true }
  ]);
  class ForeignProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.keyGenerationId = "";
      this.profileType = ProfileType.UNKNOWN;
      this.organizationId = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKey = new Uint8Array(0);
      this.highSecurityProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableProfileSeedEncPubKey = new Uint8Array(0);
      this.storableProfileSeedEncPubKeySignature = new Uint8Array(0);
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ForeignProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ForeignProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ForeignProfile().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ForeignProfile, a2, b);
    }
  }
  ForeignProfile.runtime = proto3;
  ForeignProfile.typeName = "domain.ForeignProfile";
  ForeignProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "profile_type", kind: "enum", T: proto3.getEnumType(ProfileType) },
    {
      no: 4,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "high_security_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "high_security_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 11,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: "storable_profile_seed_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 15,
      name: "storable_profile_seed_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 16,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ProfileRegenerateData extends Message {
    constructor(data) {
      super();
      this.vaultLocks = [];
      this.downstreamProfileLocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileRegenerateData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileRegenerateData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileRegenerateData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileRegenerateData, a2, b);
    }
  }
  ProfileRegenerateData.runtime = proto3;
  ProfileRegenerateData.typeName = "domain.ProfileRegenerateData";
  ProfileRegenerateData.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile", kind: "message", T: ProfileData },
    { no: 2, name: "vault_locks", kind: "message", T: VaultLockCreationData, repeated: true },
    { no: 3, name: "downstream_profile_locks", kind: "message", T: ProfileProfileLock$1, repeated: true }
  ]);
  var AuditlogEventTypeGroup;
  (function(AuditlogEventTypeGroup2) {
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["UNKNOWN"] = 0] = "UNKNOWN";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["LOGIN_MIN"] = 1] = "LOGIN_MIN";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["LOGIN_MAX"] = 29999] = "LOGIN_MAX";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["PROFILE_MIN"] = 30001] = "PROFILE_MIN";
    AuditlogEventTypeGroup2[AuditlogEventTypeGroup2["PROFILE_MAX"] = 39999] = "PROFILE_MAX";
  })(AuditlogEventTypeGroup || (AuditlogEventTypeGroup = {}));
  proto3.util.setEnumType(AuditlogEventTypeGroup, "domain.AuditlogEventTypeGroup", [
    { no: 0, name: "AUDITLOG_EVENT_TYPE_GROUP_UNKNOWN" },
    { no: 1, name: "AUDITLOG_EVENT_TYPE_GROUP_LOGIN_MIN" },
    { no: 29999, name: "AUDITLOG_EVENT_TYPE_GROUP_LOGIN_MAX" },
    { no: 30001, name: "AUDITLOG_EVENT_TYPE_GROUP_PROFILE_MIN" },
    { no: 39999, name: "AUDITLOG_EVENT_TYPE_GROUP_PROFILE_MAX" }
  ]);
  var AuditlogEventType;
  (function(AuditlogEventType2) {
    AuditlogEventType2[AuditlogEventType2["UNKNOWN"] = 0] = "UNKNOWN";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_AUTOFILL"] = 1] = "LOGIN_R_AUTOFILL";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_PASSWORD_SHOW"] = 100] = "LOGIN_R_PASSWORD_SHOW";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_PASSWORD_COPY"] = 101] = "LOGIN_R_PASSWORD_COPY";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_PASSWORD_INSERT_CONTEXT_MENU"] = 102] = "LOGIN_R_PASSWORD_INSERT_CONTEXT_MENU";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_CUSTOM_FIELD_SHOW"] = 200] = "LOGIN_R_CUSTOM_FIELD_SHOW";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_CUSTOM_FIELD_COPY"] = 201] = "LOGIN_R_CUSTOM_FIELD_COPY";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_CUSTOM_FIELD_INSERT_CONTEXT_MENU"] = 202] = "LOGIN_R_CUSTOM_FIELD_INSERT_CONTEXT_MENU";
    AuditlogEventType2[AuditlogEventType2["LOGIN_R_TOTP_SECRET_SHOW"] = 300] = "LOGIN_R_TOTP_SECRET_SHOW";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_SECURITY_CODE_SHOW"] = 400] = "CREDIT_CARD_R_SECURITY_CODE_SHOW";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_SECURITY_CODE_COPY"] = 401] = "CREDIT_CARD_R_SECURITY_CODE_COPY";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_PIN_SHOW"] = 402] = "CREDIT_CARD_R_PIN_SHOW";
    AuditlogEventType2[AuditlogEventType2["CREDIT_CARD_R_PIN_COPY"] = 403] = "CREDIT_CARD_R_PIN_COPY";
    AuditlogEventType2[AuditlogEventType2["WIFI_R_QR_SHOW"] = 500] = "WIFI_R_QR_SHOW";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_CREATE"] = 10001] = "LOGIN_W_CREATE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_CHANGE"] = 10002] = "LOGIN_W_CHANGE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_DELETE"] = 10003] = "LOGIN_W_DELETE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_ARCHIVE"] = 10004] = "LOGIN_W_ARCHIVE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_W_RESTORE_FROM_ARCHIVE"] = 10005] = "LOGIN_W_RESTORE_FROM_ARCHIVE";
    AuditlogEventType2[AuditlogEventType2["LOGIN_SHARE_LINK_CREATE"] = 20001] = "LOGIN_SHARE_LINK_CREATE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_CREATE"] = 30001] = "PROFILE_CREATE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_DELETE"] = 30002] = "PROFILE_DELETE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_CLAIM_WITH_START_CODE"] = 30003] = "PROFILE_CLAIM_WITH_START_CODE";
    AuditlogEventType2[AuditlogEventType2["PROFILE_DISCONNECT"] = 30004] = "PROFILE_DISCONNECT";
    AuditlogEventType2[AuditlogEventType2["PROFILE_PROMOTE_TO_ADMIN"] = 30005] = "PROFILE_PROMOTE_TO_ADMIN";
    AuditlogEventType2[AuditlogEventType2["PROFILE_DEMOTE_ADMIN"] = 30006] = "PROFILE_DEMOTE_ADMIN";
  })(AuditlogEventType || (AuditlogEventType = {}));
  proto3.util.setEnumType(AuditlogEventType, "domain.AuditlogEventType", [
    { no: 0, name: "AUDITLOG_EVENT_TYPE_UNKNOWN" },
    { no: 1, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_AUTOFILL" },
    { no: 100, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_PASSWORD_SHOW" },
    { no: 101, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_PASSWORD_COPY" },
    { no: 102, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_PASSWORD_INSERT_CONTEXT_MENU" },
    { no: 200, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_CUSTOM_FIELD_SHOW" },
    { no: 201, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_CUSTOM_FIELD_COPY" },
    { no: 202, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_CUSTOM_FIELD_INSERT_CONTEXT_MENU" },
    { no: 300, name: "AUDITLOG_EVENT_TYPE_LOGIN_R_TOTP_SECRET_SHOW" },
    { no: 400, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_SECURITY_CODE_SHOW" },
    { no: 401, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_SECURITY_CODE_COPY" },
    { no: 402, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_PIN_SHOW" },
    { no: 403, name: "AUDITLOG_EVENT_TYPE_CREDIT_CARD_R_PIN_COPY" },
    { no: 500, name: "AUDITLOG_EVENT_TYPE_WIFI_R_QR_SHOW" },
    { no: 10001, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_CREATE" },
    { no: 10002, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_CHANGE" },
    { no: 10003, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_DELETE" },
    { no: 10004, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_ARCHIVE" },
    { no: 10005, name: "AUDITLOG_EVENT_TYPE_LOGIN_W_RESTORE_FROM_ARCHIVE" },
    { no: 20001, name: "AUDITLOG_EVENT_TYPE_LOGIN_SHARE_LINK_CREATE" },
    { no: 30001, name: "AUDITLOG_EVENT_TYPE_PROFILE_CREATE" },
    { no: 30002, name: "AUDITLOG_EVENT_TYPE_PROFILE_DELETE" },
    { no: 30003, name: "AUDITLOG_EVENT_TYPE_PROFILE_CLAIM_WITH_START_CODE" },
    { no: 30004, name: "AUDITLOG_EVENT_TYPE_PROFILE_DISCONNECT" },
    { no: 30005, name: "AUDITLOG_EVENT_TYPE_PROFILE_PROMOTE_TO_ADMIN" },
    { no: 30006, name: "AUDITLOG_EVENT_TYPE_PROFILE_DEMOTE_ADMIN" }
  ]);
  var ErrorGroup;
  (function(ErrorGroup2) {
    ErrorGroup2[ErrorGroup2["EG_UNDEFINED"] = 0] = "EG_UNDEFINED";
    ErrorGroup2[ErrorGroup2["EG_UNSPECIFIC"] = 1e4] = "EG_UNSPECIFIC";
    ErrorGroup2[ErrorGroup2["EG_ACCOUNT"] = 2e4] = "EG_ACCOUNT";
    ErrorGroup2[ErrorGroup2["EG_CREDENTIAL"] = 3e4] = "EG_CREDENTIAL";
    ErrorGroup2[ErrorGroup2["EG_AUTHENTICATOR"] = 4e4] = "EG_AUTHENTICATOR";
    ErrorGroup2[ErrorGroup2["EG_VAULT"] = 5e4] = "EG_VAULT";
    ErrorGroup2[ErrorGroup2["EG_ORGANIZATION"] = 6e4] = "EG_ORGANIZATION";
    ErrorGroup2[ErrorGroup2["EG_PROFILE"] = 7e4] = "EG_PROFILE";
    ErrorGroup2[ErrorGroup2["EG_INTEGRATION"] = 8e4] = "EG_INTEGRATION";
    ErrorGroup2[ErrorGroup2["EG_AUDITLOG"] = 9e4] = "EG_AUDITLOG";
    ErrorGroup2[ErrorGroup2["EG_WEBAUTHN"] = 1e5] = "EG_WEBAUTHN";
    ErrorGroup2[ErrorGroup2["EG_SHARELINK"] = 11e4] = "EG_SHARELINK";
    ErrorGroup2[ErrorGroup2["EG_USER_CONFIRMATION"] = 12e4] = "EG_USER_CONFIRMATION";
  })(ErrorGroup || (ErrorGroup = {}));
  proto3.util.setEnumType(ErrorGroup, "domainerr.ErrorGroup", [
    { no: 0, name: "EG_UNDEFINED" },
    { no: 1e4, name: "EG_UNSPECIFIC" },
    { no: 2e4, name: "EG_ACCOUNT" },
    { no: 3e4, name: "EG_CREDENTIAL" },
    { no: 4e4, name: "EG_AUTHENTICATOR" },
    { no: 5e4, name: "EG_VAULT" },
    { no: 6e4, name: "EG_ORGANIZATION" },
    { no: 7e4, name: "EG_PROFILE" },
    { no: 8e4, name: "EG_INTEGRATION" },
    { no: 9e4, name: "EG_AUDITLOG" },
    { no: 1e5, name: "EG_WEBAUTHN" },
    { no: 11e4, name: "EG_SHARELINK" },
    { no: 12e4, name: "EG_USER_CONFIRMATION" }
  ]);
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2[ErrorCode2["UNDEFINED"] = 0] = "UNDEFINED";
    ErrorCode2[ErrorCode2["PERMISSION_DENIED"] = 10100] = "PERMISSION_DENIED";
    ErrorCode2[ErrorCode2["TIMEOUT"] = 10200] = "TIMEOUT";
    ErrorCode2[ErrorCode2["CANCELED"] = 10300] = "CANCELED";
    ErrorCode2[ErrorCode2["BAD_REQUEST"] = 10400] = "BAD_REQUEST";
    ErrorCode2[ErrorCode2["CLIENT_OUTDATED"] = 10426] = "CLIENT_OUTDATED";
    ErrorCode2[ErrorCode2["INTERNAL"] = 10500] = "INTERNAL";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN"] = 20100] = "EMAIL_TAKEN";
    ErrorCode2[ErrorCode2["INVALID_EMAIL"] = 20101] = "INVALID_EMAIL";
    ErrorCode2[ErrorCode2["EMAIL_ALREADY_VERIFIED"] = 20102] = "EMAIL_ALREADY_VERIFIED";
    ErrorCode2[ErrorCode2["EMAIL_REQUIRED"] = 20103] = "EMAIL_REQUIRED";
    ErrorCode2[ErrorCode2["INVALID_LOCALE"] = 20105] = "INVALID_LOCALE";
    ErrorCode2[ErrorCode2["EMAIL_INVITE_NOT_ACTIVE"] = 20106] = "EMAIL_INVITE_NOT_ACTIVE";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN_NOT_RECOVERABLE"] = 20107] = "EMAIL_TAKEN_NOT_RECOVERABLE";
    ErrorCode2[ErrorCode2["MALFORMED_USER_SETTINGS"] = 20108] = "MALFORMED_USER_SETTINGS";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN_VERIFIED_DOMAIN"] = 20109] = "EMAIL_TAKEN_VERIFIED_DOMAIN";
    ErrorCode2[ErrorCode2["EMAIL_TAKEN_ORG_ADMIN_RECOVERABLE"] = 20110] = "EMAIL_TAKEN_ORG_ADMIN_RECOVERABLE";
    ErrorCode2[ErrorCode2["USER_NOT_FOUND"] = 20400] = "USER_NOT_FOUND";
    ErrorCode2[ErrorCode2["SESSION_NOT_FOUND"] = 20410] = "SESSION_NOT_FOUND";
    ErrorCode2[ErrorCode2["INVALID_TIMEOUT"] = 20420] = "INVALID_TIMEOUT";
    ErrorCode2[ErrorCode2["SESSION_ALREADY_UNLOCKED"] = 20430] = "SESSION_ALREADY_UNLOCKED";
    ErrorCode2[ErrorCode2["SESSION_NOT_UNLOCKED"] = 20431] = "SESSION_NOT_UNLOCKED";
    ErrorCode2[ErrorCode2["INVITATION_NOT_FOUND"] = 20450] = "INVITATION_NOT_FOUND";
    ErrorCode2[ErrorCode2["INVALID_VERIFICATION_TOKEN"] = 20460] = "INVALID_VERIFICATION_TOKEN";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_USER_TYPE"] = 20470] = "NOT_ALLOWED_FOR_USER_TYPE";
    ErrorCode2[ErrorCode2["MALFORMED_CLIENT_SETTINGS"] = 20480] = "MALFORMED_CLIENT_SETTINGS";
    ErrorCode2[ErrorCode2["REGISTER_USE_LEGACY"] = 20500] = "REGISTER_USE_LEGACY";
    ErrorCode2[ErrorCode2["MISSING_CREDENTIALS"] = 30100] = "MISSING_CREDENTIALS";
    ErrorCode2[ErrorCode2["INVALID_SIGNATURE"] = 30400] = "INVALID_SIGNATURE";
    ErrorCode2[ErrorCode2["INVALID_CHALLENGE"] = 30410] = "INVALID_CHALLENGE";
    ErrorCode2[ErrorCode2["INVALID_CREDENTIALS"] = 30420] = "INVALID_CREDENTIALS";
    ErrorCode2[ErrorCode2["CHALLENGE_USER_MISMATCH"] = 30430] = "CHALLENGE_USER_MISMATCH";
    ErrorCode2[ErrorCode2["LONG_POLL_CHANNEL_NOT_FOUND"] = 30440] = "LONG_POLL_CHANNEL_NOT_FOUND";
    ErrorCode2[ErrorCode2["LONG_POLL_CHANNEL_ALREADY_EXISTS"] = 30441] = "LONG_POLL_CHANNEL_ALREADY_EXISTS";
    ErrorCode2[ErrorCode2["INVALID_USER_SWITCH"] = 30450] = "INVALID_USER_SWITCH";
    ErrorCode2[ErrorCode2["INVALID_SESSION_TYPE"] = 30460] = "INVALID_SESSION_TYPE";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_BLOCK_OUT_OF_SYNC"] = 40100] = "AUTHENTICATOR_BLOCK_OUT_OF_SYNC";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_NOT_FOUND"] = 40400] = "AUTHENTICATOR_NOT_FOUND";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_CHANNEL_NOT_FOUND"] = 40410] = "AUTHENTICATOR_CHANNEL_NOT_FOUND";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_CHANNEL_ALREADY_CLAIMED"] = 40411] = "AUTHENTICATOR_CHANNEL_ALREADY_CLAIMED";
    ErrorCode2[ErrorCode2["NO_AUTHENTICATOR_OPERATION"] = 40420] = "NO_AUTHENTICATOR_OPERATION";
    ErrorCode2[ErrorCode2["MISSING_AUTHENTICATOR_BLOCK"] = 40430] = "MISSING_AUTHENTICATOR_BLOCK";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_BLOCK_NOT_FOUND"] = 40440] = "AUTHENTICATOR_BLOCK_NOT_FOUND";
    ErrorCode2[ErrorCode2["AUTHENTICATOR_BLOCK_EXISTS"] = 40450] = "AUTHENTICATOR_BLOCK_EXISTS";
    ErrorCode2[ErrorCode2["INVALID_AUTHENTICATOR_TYPE"] = 40460] = "INVALID_AUTHENTICATOR_TYPE";
    ErrorCode2[ErrorCode2["INVALID_RECIPIENT"] = 40500] = "INVALID_RECIPIENT";
    ErrorCode2[ErrorCode2["VAULT_OUT_OF_SYNC"] = 50100] = "VAULT_OUT_OF_SYNC";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_VAULT"] = 50110] = "NOT_ALLOWED_FOR_VAULT";
    ErrorCode2[ErrorCode2["VAULT_INSUFFICIENT_ACCESS"] = 50120] = "VAULT_INSUFFICIENT_ACCESS";
    ErrorCode2[ErrorCode2["EMPTY_COMMIT"] = 50200] = "EMPTY_COMMIT";
    ErrorCode2[ErrorCode2["VAULT_NOT_FOUND"] = 50400] = "VAULT_NOT_FOUND";
    ErrorCode2[ErrorCode2["MISSING_VAULT_AUTHENTICATOR_LOCK"] = 50410] = "MISSING_VAULT_AUTHENTICATOR_LOCK";
    ErrorCode2[ErrorCode2["MISSING_VAULT_PROFILE_LOCK"] = 50411] = "MISSING_VAULT_PROFILE_LOCK";
    ErrorCode2[ErrorCode2["MISSING_VAULT"] = 50420] = "MISSING_VAULT";
    ErrorCode2[ErrorCode2["INVALID_UPDATE_TIME"] = 50430] = "INVALID_UPDATE_TIME";
    ErrorCode2[ErrorCode2["INVALID_VAULT_TYPE"] = 50431] = "INVALID_VAULT_TYPE";
    ErrorCode2[ErrorCode2["MISSING_VAULT_ADMIN"] = 50440] = "MISSING_VAULT_ADMIN";
    ErrorCode2[ErrorCode2["VAULT_DIRTY"] = 50450] = "VAULT_DIRTY";
    ErrorCode2[ErrorCode2["MISSING_ENCRYPTED_VAULT_MESSAGE_PRIVATE_KEY"] = 50460] = "MISSING_ENCRYPTED_VAULT_MESSAGE_PRIVATE_KEY";
    ErrorCode2[ErrorCode2["MISSING_VAULT_MESSAGE_PUBLIC_KEY"] = 50461] = "MISSING_VAULT_MESSAGE_PUBLIC_KEY";
    ErrorCode2[ErrorCode2["UNHANDLED_VAULT_MESSAGE"] = 50462] = "UNHANDLED_VAULT_MESSAGE";
    ErrorCode2[ErrorCode2["INVALID_VAULT_MESSAGE_TYPE"] = 50463] = "INVALID_VAULT_MESSAGE_TYPE";
    ErrorCode2[ErrorCode2["VAULT_MESSAGE_NOT_FOUND"] = 50464] = "VAULT_MESSAGE_NOT_FOUND";
    ErrorCode2[ErrorCode2["VAULT_INBOX_SLUG_INVALID"] = 50470] = "VAULT_INBOX_SLUG_INVALID";
    ErrorCode2[ErrorCode2["VAULT_INBOX_SLUG_TAKEN"] = 50471] = "VAULT_INBOX_SLUG_TAKEN";
    ErrorCode2[ErrorCode2["ORGANIZATION_INSUEFFICIENT_ACCESS"] = 60100] = "ORGANIZATION_INSUEFFICIENT_ACCESS";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_ORGANIZATION"] = 60101] = "NOT_ALLOWED_FOR_ORGANIZATION";
    ErrorCode2[ErrorCode2["ORGANIZATION_NOT_FOUND"] = 60400] = "ORGANIZATION_NOT_FOUND";
    ErrorCode2[ErrorCode2["USER_ALREADY_IN_ORGANIZATION"] = 60401] = "USER_ALREADY_IN_ORGANIZATION";
    ErrorCode2[ErrorCode2["ORGANIZATION_MISSING_ADMIN"] = 60410] = "ORGANIZATION_MISSING_ADMIN";
    ErrorCode2[ErrorCode2["INVALID_ORGANIZATION_NAME"] = 60430] = "INVALID_ORGANIZATION_NAME";
    ErrorCode2[ErrorCode2["ORGANIZATION_INVALID_CONTACT"] = 60431] = "ORGANIZATION_INVALID_CONTACT";
    ErrorCode2[ErrorCode2["COUPON_INVALID"] = 60440] = "COUPON_INVALID";
    ErrorCode2[ErrorCode2["COUPON_ALREADY_REDEEMED"] = 60441] = "COUPON_ALREADY_REDEEMED";
    ErrorCode2[ErrorCode2["OTHER_PROFILE_EMAIL_CONFLICTS"] = 60450] = "OTHER_PROFILE_EMAIL_CONFLICTS";
    ErrorCode2[ErrorCode2["INVALID_ORGANIZATION_DELETION_TOKEN"] = 60460] = "INVALID_ORGANIZATION_DELETION_TOKEN";
    ErrorCode2[ErrorCode2["MALFORMED_PASSWORD_POLICY"] = 60470] = "MALFORMED_PASSWORD_POLICY";
    ErrorCode2[ErrorCode2["MALFORMED_PARENT_ORGANIZATION_METADATA"] = 60471] = "MALFORMED_PARENT_ORGANIZATION_METADATA";
    ErrorCode2[ErrorCode2["PROFILE_NOT_FOUND"] = 70400] = "PROFILE_NOT_FOUND";
    ErrorCode2[ErrorCode2["PROFILE_ALREADY_ENABLED"] = 70401] = "PROFILE_ALREADY_ENABLED";
    ErrorCode2[ErrorCode2["PROFILE_ALREADY_CONNECTED"] = 70402] = "PROFILE_ALREADY_CONNECTED";
    ErrorCode2[ErrorCode2["PROFILE_STARTCODE_INACTIVE"] = 70403] = "PROFILE_STARTCODE_INACTIVE";
    ErrorCode2[ErrorCode2["MISSING_PROFILE_AUTHENTICATOR_LOCK"] = 70410] = "MISSING_PROFILE_AUTHENTICATOR_LOCK";
    ErrorCode2[ErrorCode2["PROFILE_OUT_OF_SYNC"] = 70411] = "PROFILE_OUT_OF_SYNC";
    ErrorCode2[ErrorCode2["MISSING_PROFILE_PROFILE_LOCK"] = 70412] = "MISSING_PROFILE_PROFILE_LOCK";
    ErrorCode2[ErrorCode2["START_CODE_INVALID"] = 70430] = "START_CODE_INVALID";
    ErrorCode2[ErrorCode2["START_CODE_BLOCKED"] = 70431] = "START_CODE_BLOCKED";
    ErrorCode2[ErrorCode2["START_CODE_MISSING"] = 70432] = "START_CODE_MISSING";
    ErrorCode2[ErrorCode2["NOT_ALLOWED_FOR_PROFILE"] = 70433] = "NOT_ALLOWED_FOR_PROFILE";
    ErrorCode2[ErrorCode2["INTEGRATION_NOT_INITIALIZED"] = 80400] = "INTEGRATION_NOT_INITIALIZED";
    ErrorCode2[ErrorCode2["INTEGRATION_UNAUTHORIZED"] = 80401] = "INTEGRATION_UNAUTHORIZED";
    ErrorCode2[ErrorCode2["INTEGRATION_INTERNAL"] = 80500] = "INTEGRATION_INTERNAL";
    ErrorCode2[ErrorCode2["AUDITLOG_MALFORMED_EVENT"] = 90400] = "AUDITLOG_MALFORMED_EVENT";
    ErrorCode2[ErrorCode2["AUDITLOG_ADMIN_INVALID_CREDENTIALS"] = 90420] = "AUDITLOG_ADMIN_INVALID_CREDENTIALS";
    ErrorCode2[ErrorCode2["AUDITLOG_WRITE_INVALID_CREDENTIALS"] = 90421] = "AUDITLOG_WRITE_INVALID_CREDENTIALS";
    ErrorCode2[ErrorCode2["AUDITLOG_SUBMISSION_ERROR"] = 90500] = "AUDITLOG_SUBMISSION_ERROR";
    ErrorCode2[ErrorCode2["WEBAUTHN_VALIDATE_ERROR"] = 100400] = "WEBAUTHN_VALIDATE_ERROR";
    ErrorCode2[ErrorCode2["WEBAUTHN_DATA_ERROR"] = 100401] = "WEBAUTHN_DATA_ERROR";
    ErrorCode2[ErrorCode2["WEBAUTHN_REQUEST_NOT_FOUND"] = 100402] = "WEBAUTHN_REQUEST_NOT_FOUND";
    ErrorCode2[ErrorCode2["WEBAUTHN_INVALID_TRANSPORT"] = 100403] = "WEBAUTHN_INVALID_TRANSPORT";
    ErrorCode2[ErrorCode2["MISSING_WEBAUTHN_CREDENTIAL"] = 100404] = "MISSING_WEBAUTHN_CREDENTIAL";
    ErrorCode2[ErrorCode2["MISSING_WEBAUTHN_RESPONSE"] = 100405] = "MISSING_WEBAUTHN_RESPONSE";
    ErrorCode2[ErrorCode2["WEBAUTHN_MISSING_USER_VERIFICATION"] = 100406] = "WEBAUTHN_MISSING_USER_VERIFICATION";
    ErrorCode2[ErrorCode2["SHARE_LINK_NOT_FOUND"] = 110400] = "SHARE_LINK_NOT_FOUND";
    ErrorCode2[ErrorCode2["USER_CONFIRMATION_NOT_FOUND"] = 120400] = "USER_CONFIRMATION_NOT_FOUND";
  })(ErrorCode || (ErrorCode = {}));
  proto3.util.setEnumType(ErrorCode, "domainerr.ErrorCode", [
    { no: 0, name: "UNDEFINED" },
    { no: 10100, name: "PERMISSION_DENIED" },
    { no: 10200, name: "TIMEOUT" },
    { no: 10300, name: "CANCELED" },
    { no: 10400, name: "BAD_REQUEST" },
    { no: 10426, name: "CLIENT_OUTDATED" },
    { no: 10500, name: "INTERNAL" },
    { no: 20100, name: "EMAIL_TAKEN" },
    { no: 20101, name: "INVALID_EMAIL" },
    { no: 20102, name: "EMAIL_ALREADY_VERIFIED" },
    { no: 20103, name: "EMAIL_REQUIRED" },
    { no: 20105, name: "INVALID_LOCALE" },
    { no: 20106, name: "EMAIL_INVITE_NOT_ACTIVE" },
    { no: 20107, name: "EMAIL_TAKEN_NOT_RECOVERABLE" },
    { no: 20108, name: "MALFORMED_USER_SETTINGS" },
    { no: 20109, name: "EMAIL_TAKEN_VERIFIED_DOMAIN" },
    { no: 20110, name: "EMAIL_TAKEN_ORG_ADMIN_RECOVERABLE" },
    { no: 20400, name: "USER_NOT_FOUND" },
    { no: 20410, name: "SESSION_NOT_FOUND" },
    { no: 20420, name: "INVALID_TIMEOUT" },
    { no: 20430, name: "SESSION_ALREADY_UNLOCKED" },
    { no: 20431, name: "SESSION_NOT_UNLOCKED" },
    { no: 20450, name: "INVITATION_NOT_FOUND" },
    { no: 20460, name: "INVALID_VERIFICATION_TOKEN" },
    { no: 20470, name: "NOT_ALLOWED_FOR_USER_TYPE" },
    { no: 20480, name: "MALFORMED_CLIENT_SETTINGS" },
    { no: 20500, name: "REGISTER_USE_LEGACY" },
    { no: 30100, name: "MISSING_CREDENTIALS" },
    { no: 30400, name: "INVALID_SIGNATURE" },
    { no: 30410, name: "INVALID_CHALLENGE" },
    { no: 30420, name: "INVALID_CREDENTIALS" },
    { no: 30430, name: "CHALLENGE_USER_MISMATCH" },
    { no: 30440, name: "LONG_POLL_CHANNEL_NOT_FOUND" },
    { no: 30441, name: "LONG_POLL_CHANNEL_ALREADY_EXISTS" },
    { no: 30450, name: "INVALID_USER_SWITCH" },
    { no: 30460, name: "INVALID_SESSION_TYPE" },
    { no: 40100, name: "AUTHENTICATOR_BLOCK_OUT_OF_SYNC" },
    { no: 40400, name: "AUTHENTICATOR_NOT_FOUND" },
    { no: 40410, name: "AUTHENTICATOR_CHANNEL_NOT_FOUND" },
    { no: 40411, name: "AUTHENTICATOR_CHANNEL_ALREADY_CLAIMED" },
    { no: 40420, name: "NO_AUTHENTICATOR_OPERATION" },
    { no: 40430, name: "MISSING_AUTHENTICATOR_BLOCK" },
    { no: 40440, name: "AUTHENTICATOR_BLOCK_NOT_FOUND" },
    { no: 40450, name: "AUTHENTICATOR_BLOCK_EXISTS" },
    { no: 40460, name: "INVALID_AUTHENTICATOR_TYPE" },
    { no: 40500, name: "INVALID_RECIPIENT" },
    { no: 50100, name: "VAULT_OUT_OF_SYNC" },
    { no: 50110, name: "NOT_ALLOWED_FOR_VAULT" },
    { no: 50120, name: "VAULT_INSUFFICIENT_ACCESS" },
    { no: 50200, name: "EMPTY_COMMIT" },
    { no: 50400, name: "VAULT_NOT_FOUND" },
    { no: 50410, name: "MISSING_VAULT_AUTHENTICATOR_LOCK" },
    { no: 50411, name: "MISSING_VAULT_PROFILE_LOCK" },
    { no: 50420, name: "MISSING_VAULT" },
    { no: 50430, name: "INVALID_UPDATE_TIME" },
    { no: 50431, name: "INVALID_VAULT_TYPE" },
    { no: 50440, name: "MISSING_VAULT_ADMIN" },
    { no: 50450, name: "VAULT_DIRTY" },
    { no: 50460, name: "MISSING_ENCRYPTED_VAULT_MESSAGE_PRIVATE_KEY" },
    { no: 50461, name: "MISSING_VAULT_MESSAGE_PUBLIC_KEY" },
    { no: 50462, name: "UNHANDLED_VAULT_MESSAGE" },
    { no: 50463, name: "INVALID_VAULT_MESSAGE_TYPE" },
    { no: 50464, name: "VAULT_MESSAGE_NOT_FOUND" },
    { no: 50470, name: "VAULT_INBOX_SLUG_INVALID" },
    { no: 50471, name: "VAULT_INBOX_SLUG_TAKEN" },
    { no: 60100, name: "ORGANIZATION_INSUEFFICIENT_ACCESS" },
    { no: 60101, name: "NOT_ALLOWED_FOR_ORGANIZATION" },
    { no: 60400, name: "ORGANIZATION_NOT_FOUND" },
    { no: 60401, name: "USER_ALREADY_IN_ORGANIZATION" },
    { no: 60410, name: "ORGANIZATION_MISSING_ADMIN" },
    { no: 60430, name: "INVALID_ORGANIZATION_NAME" },
    { no: 60431, name: "ORGANIZATION_INVALID_CONTACT" },
    { no: 60440, name: "COUPON_INVALID" },
    { no: 60441, name: "COUPON_ALREADY_REDEEMED" },
    { no: 60450, name: "OTHER_PROFILE_EMAIL_CONFLICTS" },
    { no: 60460, name: "INVALID_ORGANIZATION_DELETION_TOKEN" },
    { no: 60470, name: "MALFORMED_PASSWORD_POLICY" },
    { no: 60471, name: "MALFORMED_PARENT_ORGANIZATION_METADATA" },
    { no: 70400, name: "PROFILE_NOT_FOUND" },
    { no: 70401, name: "PROFILE_ALREADY_ENABLED" },
    { no: 70402, name: "PROFILE_ALREADY_CONNECTED" },
    { no: 70403, name: "PROFILE_STARTCODE_INACTIVE" },
    { no: 70410, name: "MISSING_PROFILE_AUTHENTICATOR_LOCK" },
    { no: 70411, name: "PROFILE_OUT_OF_SYNC" },
    { no: 70412, name: "MISSING_PROFILE_PROFILE_LOCK" },
    { no: 70430, name: "START_CODE_INVALID" },
    { no: 70431, name: "START_CODE_BLOCKED" },
    { no: 70432, name: "START_CODE_MISSING" },
    { no: 70433, name: "NOT_ALLOWED_FOR_PROFILE" },
    { no: 80400, name: "INTEGRATION_NOT_INITIALIZED" },
    { no: 80401, name: "INTEGRATION_UNAUTHORIZED" },
    { no: 80500, name: "INTEGRATION_INTERNAL" },
    { no: 90400, name: "AUDITLOG_MALFORMED_EVENT" },
    { no: 90420, name: "AUDITLOG_ADMIN_INVALID_CREDENTIALS" },
    { no: 90421, name: "AUDITLOG_WRITE_INVALID_CREDENTIALS" },
    { no: 90500, name: "AUDITLOG_SUBMISSION_ERROR" },
    { no: 100400, name: "WEBAUTHN_VALIDATE_ERROR" },
    { no: 100401, name: "WEBAUTHN_DATA_ERROR" },
    { no: 100402, name: "WEBAUTHN_REQUEST_NOT_FOUND" },
    { no: 100403, name: "WEBAUTHN_INVALID_TRANSPORT" },
    { no: 100404, name: "MISSING_WEBAUTHN_CREDENTIAL" },
    { no: 100405, name: "MISSING_WEBAUTHN_RESPONSE" },
    { no: 100406, name: "WEBAUTHN_MISSING_USER_VERIFICATION" },
    { no: 110400, name: "SHARE_LINK_NOT_FOUND" },
    { no: 120400, name: "USER_CONFIRMATION_NOT_FOUND" }
  ]);
  var ReportPageProblem;
  (function(ReportPageProblem2) {
    ReportPageProblem2[ReportPageProblem2["UNKNOWN"] = 0] = "UNKNOWN";
    ReportPageProblem2[ReportPageProblem2["OTHER"] = 1] = "OTHER";
    ReportPageProblem2[ReportPageProblem2["DETECTION"] = 2] = "DETECTION";
    ReportPageProblem2[ReportPageProblem2["POSITION"] = 3] = "POSITION";
    ReportPageProblem2[ReportPageProblem2["SUBMISSION"] = 4] = "SUBMISSION";
    ReportPageProblem2[ReportPageProblem2["AUTOFILL"] = 5] = "AUTOFILL";
    ReportPageProblem2[ReportPageProblem2["FORM"] = 6] = "FORM";
  })(ReportPageProblem || (ReportPageProblem = {}));
  proto3.util.setEnumType(ReportPageProblem, "domain.ReportPageProblem", [
    { no: 0, name: "REPORT_PAGE_PROBLEM_UNKNOWN" },
    { no: 1, name: "REPORT_PAGE_PROBLEM_OTHER" },
    { no: 2, name: "REPORT_PAGE_PROBLEM_DETECTION" },
    { no: 3, name: "REPORT_PAGE_PROBLEM_POSITION" },
    { no: 4, name: "REPORT_PAGE_PROBLEM_SUBMISSION" },
    { no: 5, name: "REPORT_PAGE_PROBLEM_AUTOFILL" },
    { no: 6, name: "REPORT_PAGE_PROBLEM_FORM" }
  ]);
  class SendMessageRequest extends Message {
    constructor(data) {
      super();
      this.subject = "";
      this.message = "";
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendMessageRequest, a2, b);
    }
  }
  SendMessageRequest.runtime = proto3;
  SendMessageRequest.typeName = "domain.SendMessageRequest";
  SendMessageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "subject",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SendMessageResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendMessageResponse, a2, b);
    }
  }
  SendMessageResponse.runtime = proto3;
  SendMessageResponse.typeName = "domain.SendMessageResponse";
  SendMessageResponse.fields = proto3.util.newFieldList(() => []);
  class ReportPageRequest extends Message {
    constructor(data) {
      super();
      this.url = "";
      this.problem = ReportPageProblem.UNKNOWN;
      this.comment = "";
      this.screenshot = "";
      this.hasLogin = false;
      this.hasHideSecretsLogin = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReportPageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReportPageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReportPageRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ReportPageRequest, a2, b);
    }
  }
  ReportPageRequest.runtime = proto3;
  ReportPageRequest.typeName = "domain.ReportPageRequest";
  ReportPageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "problem", kind: "enum", T: proto3.getEnumType(ReportPageProblem) },
    {
      no: 3,
      name: "comment",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "screenshot",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "has_login",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 6,
      name: "has_hide_secrets_login",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ReportPageResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReportPageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReportPageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReportPageResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ReportPageResponse, a2, b);
    }
  }
  ReportPageResponse.runtime = proto3;
  ReportPageResponse.typeName = "domain.ReportPageResponse";
  ReportPageResponse.fields = proto3.util.newFieldList(() => []);
  var SubscriptionPlan;
  (function(SubscriptionPlan2) {
    SubscriptionPlan2[SubscriptionPlan2["UNKNOWN"] = 0] = "UNKNOWN";
    SubscriptionPlan2[SubscriptionPlan2["MONTHLY"] = 1] = "MONTHLY";
    SubscriptionPlan2[SubscriptionPlan2["YEARLY"] = 2] = "YEARLY";
  })(SubscriptionPlan || (SubscriptionPlan = {}));
  proto3.util.setEnumType(SubscriptionPlan, "domain.SubscriptionPlan", [
    { no: 0, name: "SUBSCRIPTION_PLAN_UNKNOWN" },
    { no: 1, name: "SUBSCRIPTION_PLAN_MONTHLY" },
    { no: 2, name: "SUBSCRIPTION_PLAN_YEARLY" }
  ]);
  var UserConfirmationResultType;
  (function(UserConfirmationResultType2) {
    UserConfirmationResultType2[UserConfirmationResultType2["OPEN"] = 0] = "OPEN";
    UserConfirmationResultType2[UserConfirmationResultType2["ACCEPTED"] = 1] = "ACCEPTED";
    UserConfirmationResultType2[UserConfirmationResultType2["REJECTED"] = 2] = "REJECTED";
  })(UserConfirmationResultType || (UserConfirmationResultType = {}));
  proto3.util.setEnumType(UserConfirmationResultType, "domain.UserConfirmationResultType", [
    { no: 0, name: "USER_CONFIRMATION_RESULT_TYPE_OPEN" },
    { no: 1, name: "USER_CONFIRMATION_RESULT_TYPE_ACCEPTED" },
    { no: 2, name: "USER_CONFIRMATION_RESULT_TYPE_REJECTED" }
  ]);
  var UserConfirmationType;
  (function(UserConfirmationType2) {
    UserConfirmationType2[UserConfirmationType2["UNKNOWN"] = 0] = "UNKNOWN";
    UserConfirmationType2[UserConfirmationType2["DEBUG"] = 1] = "DEBUG";
    UserConfirmationType2[UserConfirmationType2["USER_EXPORT_VAULT"] = 10001] = "USER_EXPORT_VAULT";
    UserConfirmationType2[UserConfirmationType2["USER_EXPORT_ALL"] = 10002] = "USER_EXPORT_ALL";
    UserConfirmationType2[UserConfirmationType2["ORG_ADMIN_DELETE_ORG"] = 3e4] = "ORG_ADMIN_DELETE_ORG";
  })(UserConfirmationType || (UserConfirmationType = {}));
  proto3.util.setEnumType(UserConfirmationType, "domain.UserConfirmationType", [
    { no: 0, name: "USER_CONFIRMATION_TYPE_UNKNOWN" },
    { no: 1, name: "USER_CONFIRMATION_TYPE_DEBUG" },
    { no: 10001, name: "USER_CONFIRMATION_TYPE_USER_EXPORT_VAULT" },
    { no: 10002, name: "USER_CONFIRMATION_TYPE_USER_EXPORT_ALL" },
    { no: 3e4, name: "USER_CONFIRMATION_TYPE_ORG_ADMIN_DELETE_ORG" }
  ]);
  var UserType;
  (function(UserType2) {
    UserType2[UserType2["DEFAULT"] = 0] = "DEFAULT";
    UserType2[UserType2["ORGANIZATION_SUPER"] = 1] = "ORGANIZATION_SUPER";
    UserType2[UserType2["ORGANIZATION_SERVICE"] = 2] = "ORGANIZATION_SERVICE";
  })(UserType || (UserType = {}));
  proto3.util.setEnumType(UserType, "domain.UserType", [
    { no: 0, name: "USER_TYPE_DEFAULT" },
    { no: 1, name: "USER_TYPE_ORGANIZATION_SUPER" },
    { no: 2, name: "USER_TYPE_ORGANIZATION_SERVICE" }
  ]);
  var VaultMessageType;
  (function(VaultMessageType2) {
    VaultMessageType2[VaultMessageType2["UNKNOWN"] = 0] = "UNKNOWN";
    VaultMessageType2[VaultMessageType2["LOGIN_INBOX_V1"] = 1] = "LOGIN_INBOX_V1";
    VaultMessageType2[VaultMessageType2["LINKED_VAULT_DELETED_V1"] = 3] = "LINKED_VAULT_DELETED_V1";
    VaultMessageType2[VaultMessageType2["SHARE_LINK_OPENED_V1"] = 4] = "SHARE_LINK_OPENED_V1";
    VaultMessageType2[VaultMessageType2["LINKED_LOGIN_UPDATE_V1"] = 2] = "LINKED_LOGIN_UPDATE_V1";
    VaultMessageType2[VaultMessageType2["DEBUG"] = 999999] = "DEBUG";
  })(VaultMessageType || (VaultMessageType = {}));
  proto3.util.setEnumType(VaultMessageType, "domain.VaultMessageType", [
    { no: 0, name: "VAULT_MESSAGE_TYPE_UNKNOWN" },
    { no: 1, name: "VAULT_MESSAGE_TYPE_LOGIN_INBOX_V1" },
    { no: 3, name: "VAULT_MESSAGE_TYPE_LINKED_VAULT_DELETED_V1" },
    { no: 4, name: "VAULT_MESSAGE_TYPE_SHARE_LINK_OPENED_V1" },
    { no: 2, name: "VAULT_MESSAGE_TYPE_LINKED_LOGIN_UPDATE_V1" },
    { no: 999999, name: "VAULT_MESSAGE_TYPE_DEBUG" }
  ]);
  var ClientType;
  (function(ClientType2) {
    ClientType2[ClientType2["UNKNOWN"] = 0] = "UNKNOWN";
    ClientType2[ClientType2["TEST"] = 1] = "TEST";
    ClientType2[ClientType2["WEB"] = 100] = "WEB";
    ClientType2[ClientType2["AND"] = 200] = "AND";
    ClientType2[ClientType2["IOS"] = 210] = "IOS";
    ClientType2[ClientType2["EXT"] = 300] = "EXT";
    ClientType2[ClientType2["EXT_IOS"] = 301] = "EXT_IOS";
    ClientType2[ClientType2["CLI"] = 400] = "CLI";
    ClientType2[ClientType2["BAK"] = 401] = "BAK";
    ClientType2[ClientType2["BAE_AUDITLOG"] = 500] = "BAE_AUDITLOG";
  })(ClientType || (ClientType = {}));
  proto3.util.setEnumType(ClientType, "domain.ClientType", [
    { no: 0, name: "CLIENT_TYPE_UNKNOWN" },
    { no: 1, name: "CLIENT_TYPE_TEST" },
    { no: 100, name: "CLIENT_TYPE_WEB" },
    { no: 200, name: "CLIENT_TYPE_AND" },
    { no: 210, name: "CLIENT_TYPE_IOS" },
    { no: 300, name: "CLIENT_TYPE_EXT" },
    { no: 301, name: "CLIENT_TYPE_EXT_IOS" },
    { no: 400, name: "CLIENT_TYPE_CLI" },
    { no: 401, name: "CLIENT_TYPE_BAK" },
    { no: 500, name: "CLIENT_TYPE_BAE_AUDITLOG" }
  ]);
  function toVaultProfileLockDto(pb) {
    if (!pb) {
      return void 0;
    }
    let encryptedVaultMessagePrivateKey = null;
    if (pb.encryptedVaultMessagePrivateKey.length > 0) {
      encryptedVaultMessagePrivateKey = pb.encryptedVaultMessagePrivateKey;
    }
    return {
      lockingProfileId: requireFieldNotEmpty(pb.lockingProfileId),
      lockingProfileKeyGenerationId: requireFieldNotEmpty(pb.lockingProfileKeyGenerationId),
      encryptedStorableVaultKey: pb.encryptedStorableVaultKey,
      encryptedHighSecurityVaultKey: pb.encryptedHighSecurityVaultKey,
      encryptedVaultMessagePrivateKey
    };
  }
  function toVaultAuthenticatorLockDto(pb) {
    let encryptedVaultMessagePrivateKey = null;
    if (pb.encryptedVaultMessagePrivateKey.length > 0) {
      encryptedVaultMessagePrivateKey = pb.encryptedVaultMessagePrivateKey;
    }
    return {
      authenticatorId: requireFieldNotEmpty(pb.authenticatorId),
      encryptedStorableVaultKey: pb.encryptedStorableVaultKey,
      encryptedHighSecurityVaultKey: pb.encryptedHighSecurityVaultKey,
      encryptedVaultMessagePrivateKey
    };
  }
  function toPbVaultAuthenticatorLock(dto) {
    var _a2;
    return new VaultAuthenticatorLock$1(Object.assign(Object.assign({}, dto), { encryptedVaultMessagePrivateKey: (_a2 = dto.encryptedVaultMessagePrivateKey) !== null && _a2 !== void 0 ? _a2 : void 0 }));
  }
  function toPbVaultProfileLock(dto) {
    var _a2;
    return new VaultProfileLock$1(Object.assign(Object.assign({}, dto), { encryptedVaultMessagePrivateKey: (_a2 = dto.encryptedVaultMessagePrivateKey) !== null && _a2 !== void 0 ? _a2 : void 0 }));
  }
  function toPbVaultLock(l) {
    return new VaultLockCreationData(Object.assign(Object.assign({}, l), { lock: toPbVaultProfileLock(l.lock), associatedLock: l.associatedLock ? toPbVaultProfileLock(l.associatedLock) : void 0 }));
  }
  function toPbProfileRegenerateData(p2) {
    return new ProfileRegenerateData({
      profile: p2.profile,
      vaultLocks: p2.vaultLocks.map(toPbVaultLock),
      downstreamProfileLocks: p2.downstreamProfileLocks
    });
  }
  var __awaiter$1d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues$5 = globalThis && globalThis.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  };
  function toSyncSessionUnlockDto(su) {
    if (!su || !su.authenticatorId) {
      return void 0;
    }
    return {
      authenticatorId: su.authenticatorId,
      encryptedSecret: su.encryptedSecret
    };
  }
  function toSyncUpdateProfileAuthenticatorLock(l) {
    return {
      authenticatorId: requireFieldNotEmpty(l.authenticatorId),
      encryptedHighSecurityProfileSeed: requireFieldNotEmpty(l.encryptedHighSecurityProfileSeed),
      encryptedStorableProfileSeed: requireFieldNotEmpty(l.encryptedStorableProfileSeed)
    };
  }
  function toSyncUpdateProfileProfileLock(l) {
    return {
      lockingProfileId: requireFieldNotEmpty(l.lockingProfileId),
      lockingProfileKeyGenerationId: requireFieldNotEmpty(l.lockingProfileKeyGenerationId),
      encryptedHighSecurityProfileSeed: requireFieldNotEmpty(l.encryptedHighSecurityProfileSeed),
      encryptedStorableProfileSeed: requireFieldNotEmpty(l.encryptedStorableProfileSeed)
    };
  }
  function toSyncUpdateProfile(sa) {
    return {
      id: requireFieldNotEmpty(sa.id),
      profileType: knownEnumOrDefault(sa.profileType, ProfileType),
      keyGenerationId: requireFieldNotEmpty(sa.keyGenerationId),
      email: sa.email || null,
      unverifiedEmail: sa.unverifiedEmail || null,
      organizationId: sa.organizationId || null,
      highSecurityIdentitySigPubKey: sa.highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey: sa.highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature: sa.highSecurityVaultKeyEncPubKeySignature,
      highSecurityProfileSeedEncPubKey: sa.highSecurityProfileSeedEncPubKey,
      highSecurityProfileSeedEncPubKeySignature: sa.highSecurityProfileSeedEncPubKeySignature,
      storableSigPubKey: sa.storableSigPubKey,
      storableSigPubKeySignature: sa.storableSigPubKeySignature,
      storableVaultKeyEncPubKey: sa.storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature: sa.storableVaultKeyEncPubKeySignature,
      storableProfileSeedEncPubKey: sa.storableProfileSeedEncPubKey,
      storableProfileSeedEncPubKeySignature: sa.storableProfileSeedEncPubKeySignature,
      authenticatorLocks: sa.authenticatorLocks.map(toSyncUpdateProfileAuthenticatorLock),
      profileLock: sa.profileLock ? toSyncUpdateProfileProfileLock(sa.profileLock) : null
    };
  }
  function toSyncUpdatePreliminaryProfile(sa) {
    return {
      id: requireFieldNotEmpty(sa.id),
      email: sa.email || null,
      organizationId: sa.organizationId || null
    };
  }
  function toSyncUpdateOrganizationAdminInfo(pbInfo) {
    var _a2;
    if (pbInfo === void 0) {
      return void 0;
    }
    const a2 = pbInfo.authenticator;
    let authenticator;
    if (a2) {
      const data = requireFieldNotEmpty(a2.data);
      authenticator = {
        id: requireFieldNotEmpty(a2.id),
        authenticatorType: knownEnumOrDefault(data.authenticatorType, AuthenticatorType),
        storableVaultKeyEncPubKey: requireFieldNotEmpty(data.storableVaultKeyEncPubKey),
        storableVaultKeyEncPubKeySignature: requireFieldNotEmpty(data.storableVaultKeyEncPubKeySignature),
        highSecurityVaultKeyEncPubKey: requireFieldNotEmpty(data.highSecurityVaultKeyEncPubKey),
        highSecurityVaultKeyEncPubKeySignature: requireFieldNotEmpty(data.highSecurityVaultKeyEncPubKeySignature),
        highSecurityIdentitySigPubKey: requireFieldNotEmpty(data.highSecurityIdentitySigPubKey),
        highSecurityLoginSigPubKey: requireFieldNotEmpty(data.highSecurityLoginSigPubKey),
        secretInfo: data.secretInfo,
        secretSalt: data.secretSalt,
        storableSigPubKey: requireFieldNotEmpty(data.storableSigPubKey),
        storableSigPubKeySignature: requireFieldNotEmpty(data.storableSigPubKeySignature)
      };
    }
    let adminProfile;
    const p2 = pbInfo.adminProfile;
    if (p2) {
      adminProfile = {
        id: requireFieldNotEmpty(p2.id),
        profileType: requireFieldNotEmpty(p2.profileType),
        keyGenerationId: requireFieldNotEmpty(p2.keyGenerationId),
        organizationId: requireFieldNotEmpty(p2.organizationId),
        highSecurityIdentitySigPubKey: p2.highSecurityIdentitySigPubKey,
        highSecurityVaultKeyEncPubKey: p2.highSecurityVaultKeyEncPubKey,
        highSecurityVaultKeyEncPubKeySignature: p2.highSecurityVaultKeyEncPubKeySignature,
        highSecurityProfileSeedEncPubKey: p2.highSecurityProfileSeedEncPubKey,
        highSecurityProfileSeedEncPubKeySignature: p2.highSecurityProfileSeedEncPubKeySignature,
        storableSigPubKey: p2.storableSigPubKey,
        storableSigPubKeySignature: p2.storableSigPubKeySignature,
        storableVaultKeyEncPubKey: p2.storableVaultKeyEncPubKey,
        storableVaultKeyEncPubKeySignature: p2.storableVaultKeyEncPubKeySignature,
        storableProfileSeedEncPubKey: p2.storableProfileSeedEncPubKey,
        storableProfileSeedEncPubKeySignature: p2.storableProfileSeedEncPubKeySignature,
        email: null,
        unverifiedEmail: null,
        authenticatorLocks: [],
        profileLock: p2.profileLock ? toSyncUpdateProfileProfileLock(p2.profileLock) : null
      };
    }
    return {
      legacyAdminVaultId: pbInfo.legacyAdminVaultId || void 0,
      authenticator,
      adminProfile,
      entraTenantId: pbInfo.entraTenantId || void 0,
      csvIntegrationActive: pbInfo.csvIntegrationActive,
      googleWorkspaceIntegrationActive: pbInfo.googleWorkspaceIntegrationActive,
      licenseType: pbInfo.licenseType,
      trialEndDate: (_a2 = pbInfo.trialEndDate) === null || _a2 === void 0 ? void 0 : _a2.toDate()
    };
  }
  function toSyncOrganization(so) {
    const profiles = so.profiles.map((m2) => {
      var _a2, _b2, _c2;
      return {
        profileId: m2.profileId,
        isAdmin: m2.isAdmin,
        isNotConnected: m2.isNotConnected,
        isManager: m2.isManager,
        isService: m2.isService,
        personalVaultId: m2.personalVaultId || void 0,
        // using undefined here, because this field is not persisted
        preliminaryUserId: m2.preliminaryUserId || void 0,
        startCode: m2.startCode || void 0,
        startCodeGeneratedAt: (_a2 = m2.startCodeGeneratedAt) === null || _a2 === void 0 ? void 0 : _a2.toDate(),
        startCodeEmailSentAt: (_b2 = m2.startCodeEmailSentAt) === null || _b2 === void 0 ? void 0 : _b2.toDate(),
        primaryLoginDevice: m2.primaryLoginDevice ? knownEnumOrDefault(m2.primaryLoginDevice, PrimaryLoginDevice) : void 0,
        lastActiveAt: (_c2 = m2.lastActiveAt) === null || _c2 === void 0 ? void 0 : _c2.toDate()
      };
    });
    const icon = so.icon;
    return {
      id: requireFieldNotEmpty(so.id),
      name: requireFieldNotEmpty(so.name),
      organizationType: knownEnumOrDefault(so.organizationType, OrganizationType),
      superUserId: requireFieldNotEmpty(so.superUserId),
      adminProfileId: so.adminProfileId || null,
      icon: icon.length ? icon : null,
      restrictCreateTeam: so.restrictCreateTeam,
      restrictPersonalLogins: so.restrictPersonalLogins,
      unlockTimeLimit: requireFieldNotEmpty(so.unlockTimeLimit),
      auditlogEnable: so.auditlogEnable,
      childOrganizationManagementEnable: so.childOrganizationManagementEnable,
      isAdmin: so.isAdmin,
      isManager: so.isManager,
      isPreliminary: so.isPreliminary,
      adminInfo: toSyncUpdateOrganizationAdminInfo(so.adminInfo),
      profiles,
      subscriptionError: so.subscriptionError || null,
      verifiedDomain: so.verifiedDomain || null,
      passwordPolicy: so.passwordPolicy || null,
      clientSettings: so.clientSettings || null,
      parentOrganizationInfo: so.parentOrganizationInfo ? {
        id: requireFieldNotEmpty(so.parentOrganizationInfo.id),
        name: requireFieldNotEmpty(so.parentOrganizationInfo.name),
        icon: so.parentOrganizationInfo.icon || void 0,
        metadata: so.parentOrganizationInfo.metadata || void 0
      } : void 0
    };
  }
  function toSyncRelatedProfile(su) {
    return {
      id: requireFieldNotEmpty(su.id),
      email: su.email || null
    };
  }
  function toSyncUpdateUser(su) {
    if (su === void 0) {
      return void 0;
    }
    let authenticatorBlockHash = su.authenticatorBlockHash;
    if (authenticatorBlockHash.length === 0) {
      authenticatorBlockHash = null;
    }
    const emails = su.emails.map((e) => ({
      email: requireFieldNotEmpty(e.email),
      verificationPending: e.verificationPending,
      primary: e.primary
    }));
    const webauthnCredentials = su.webauthnCredentials.map((wc) => ({
      webauthnId: wc.webauthnId,
      credentialType: knownEnumOrDefault(wc.credentialType, CredentialType),
      aaguid: wc.aaguid || null,
      sessionId: wc.sessionId || null,
      createdAt: requireFieldNotEmpty(wc.createdAt).toDate(),
      lastUsedAt: requireFieldNotEmpty(wc.lastUsedAt).toDate(),
      prfSupportStatus: wc.prfSupportStatus
    }));
    return {
      emails,
      preliminaryEmail: su.preliminaryEmail || null,
      serverSideSettings: su.serverSideSettings || null,
      authenticatorBlockHash,
      preferredLocale: su.preferredLocale || null,
      webauthnCredentials,
      userClientSettings: su.userClientSettings || null,
      openUserConfirmationIds: su.openUserConfirmationIds
    };
  }
  function toSyncUpdateVault(v2) {
    return {
      id: v2.id,
      commitId: v2.commitId,
      generationId: v2.generationId,
      profileKeyGenerationId: v2.profileKeyGenerationId || null,
      adminProfileKeyGenerationId: v2.adminProfileKeyGenerationId || null,
      users: v2.users,
      profiles: v2.profiles,
      vaultType: knownEnumOrDefault(v2.vaultType, VaultType),
      associatedVaultId: v2.associatedVaultId || null,
      dirty: v2.dirty,
      organizationId: v2.organizationId || null,
      messagePublicKey: v2.messagePublicKey.length > 0 ? v2.messagePublicKey : null,
      hasMessagesQueued: v2.hasMessagesQueued,
      inboxSlug: v2.inboxSlug || null
    };
  }
  function toSyncDto(resp) {
    const serverTime = requireFieldNotEmpty(resp.serverTime).toDate();
    const syncVersion = Number(resp.syncVersion);
    const tokenRefreshNeeded = resp.tokenRefreshNeeded;
    const clientOutdated = resp.clientOutdated;
    const sessionUnlock = toSyncSessionUnlockDto(resp.sessionUnlock);
    const uf = resp.updatedFields;
    const user = !uf.includes(SyncUpdateField.SU_USER) ? void 0 : toSyncUpdateUser(resp.user);
    const sessions = !uf.includes(SyncUpdateField.SU_SESSIONS) ? void 0 : resp.sessions.map((s2) => {
      var _a2, _b2, _c2, _d2;
      return {
        id: s2.id,
        createdAt: requireFieldNotEmpty(s2.createdAt).toDate(),
        lastUsedAt: requireFieldNotEmpty(s2.lastUsedAt).toDate(),
        unlockedAt: (_a2 = s2.unlockedAt) === null || _a2 === void 0 ? void 0 : _a2.toDate(),
        unlockedUntil: (_b2 = s2.unlockedUntil) === null || _b2 === void 0 ? void 0 : _b2.toDate(),
        unlockExtendAt: (_c2 = s2.unlockExtendAt) === null || _c2 === void 0 ? void 0 : _c2.toDate(),
        unlockRequestedAt: (_d2 = s2.unlockRequestedAt) === null || _d2 === void 0 ? void 0 : _d2.toDate(),
        clientSettings: s2.clientSettings || null,
        sessionType: knownEnumOrDefault(s2.sessionType, SessionType),
        enabledProfileIds: s2.enabledProfileIds,
        unlockTimeLimit: requireFieldNotEmpty(s2.unlockTimeLimit)
      };
    });
    const vaults = !uf.includes(SyncUpdateField.SU_VAULTS) ? void 0 : resp.vaults.map(toSyncUpdateVault);
    const achievementIds = !uf.includes(SyncUpdateField.SU_ACHIEVEMENTS) ? void 0 : resp.achievements;
    const channels = !uf.includes(SyncUpdateField.SU_CHANNELS) ? void 0 : resp.channels;
    const organizations = uf.includes(SyncUpdateField.SU_ORGANIZATIONS) ? resp.organizations.map(toSyncOrganization) : void 0;
    const relatedProfiles = uf.includes(SyncUpdateField.SU_RELATED_PROFILES) ? resp.relatedProfiles.map((p2) => toSyncRelatedProfile(p2)) : void 0;
    const profiles = uf.includes(SyncUpdateField.SU_PROFILES) ? resp.profiles.map(toSyncUpdateProfile) : void 0;
    const preliminaryProfiles = uf.includes(SyncUpdateField.SU_PROFILES) ? resp.preliminaryProfiles.map(toSyncUpdatePreliminaryProfile) : void 0;
    const maintenanceSettings = uf.includes(SyncUpdateField.SU_MAINTENANCE_SETTINGS) ? { allowedTasks: requireFieldNotEmpty(resp.maintenanceSettings).allowedTasks } : void 0;
    return {
      serverTime,
      clientOutdated,
      sessionUnlock,
      tokenRefreshNeeded,
      user,
      sessions,
      vaults,
      achievementIds,
      channels,
      syncVersion,
      organizations,
      relatedProfiles,
      profiles,
      preliminaryProfiles,
      maintenanceSettings
    };
  }
  class SyncServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    streamingSync(cancelToken, resetAndRequestUnlock = false) {
      return createEmitterFromAsyncIterable(this.espbClient.streamingSync({ resetAndRequestSessionUnlock: resetAndRequestUnlock }, { signal: cancelToken.signal }), (resp) => toSyncDto(requireFieldNotEmpty(resp.syncUpdate)));
    }
    longPoll(cancelToken, resetAndRequestSessionUnlock = false) {
      return __awaiter$1d(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.longPollSync({ resetAndRequestSessionUnlock }, { signal: cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.signal });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    poll(fcmMessageId) {
      return __awaiter$1d(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.sync({ fcmMessageId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
  }
  function createEmitterFromAsyncIterable(messages2, transform) {
    const emitter = new Emittery$3.Typed();
    (() => __awaiter$1d(this, void 0, void 0, function* () {
      var _a2, e_1, _b2, _c2;
      try {
        try {
          for (var _d2 = true, messages_1 = __asyncValues$5(messages2), messages_1_1; messages_1_1 = yield messages_1.next(), _a2 = messages_1_1.done, !_a2; _d2 = true) {
            _c2 = messages_1_1.value;
            _d2 = false;
            const raw = _c2;
            if (emitter.listenerCount() === 0) {
              debugConsole.log(`No active listeners during onMessage!`);
              captureMessage$1("No active listeners in onMessage!");
            }
            yield emitter.emit("message", { message: transform(raw) });
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a2 && (_b2 = messages_1.return))
              yield _b2.call(messages_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      } catch (e) {
        if (e instanceof Cancel) {
          emitter.emit("cancel").catch(trackError);
        } else {
          const error2 = e instanceof Error ? e : new Error(`${e}`);
          emitter.emit("error", { error: error2 }).catch(trackError);
        }
      }
      yield emitter.emit("end");
    }))().catch(trackError);
    return emitter;
  }
  class LinkedLoginUpdateMessage extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.type = VaultMessageType.UNKNOWN;
      this.encryptedData = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LinkedLoginUpdateMessage().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LinkedLoginUpdateMessage().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LinkedLoginUpdateMessage().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LinkedLoginUpdateMessage, a2, b);
    }
  }
  LinkedLoginUpdateMessage.runtime = proto3;
  LinkedLoginUpdateMessage.typeName = "domain.LinkedLoginUpdateMessage";
  LinkedLoginUpdateMessage.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 4,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class VaultRegenerateData extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.latestCommitId = "";
      this.newAuthenticatorEncryptedStorableVaultKeys = [];
      this.newAuthenticatorEncryptedHighSecurityVaultKeys = [];
      this.newAuthenticatorEncryptedVaultMessagePrivateKeys = [];
      this.authenticatorLocks = [];
      this.profileLocks = [];
      this.squashedCommits = new Uint8Array(0);
      this.messagePublicKey = new Uint8Array(0);
      this.deleteMessageIds = [];
      this.regeneratedMessages = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultRegenerateData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultRegenerateData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultRegenerateData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VaultRegenerateData, a2, b);
    }
  }
  VaultRegenerateData.runtime = proto3;
  VaultRegenerateData.typeName = "domain.VaultRegenerateData";
  VaultRegenerateData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "new_authenticator_encrypted_storable_vault_keys", kind: "scalar", T: 12, repeated: true },
    { no: 4, name: "new_authenticator_encrypted_high_security_vault_keys", kind: "scalar", T: 12, repeated: true },
    { no: 10, name: "new_authenticator_encrypted_vault_message_private_keys", kind: "scalar", T: 12, repeated: true },
    { no: 6, name: "authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 7, name: "profile_locks", kind: "message", T: VaultProfileLock$1, repeated: true },
    {
      no: 5,
      name: "squashed_commits",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 9, name: "delete_message_ids", kind: "scalar", T: 9, repeated: true },
    { no: 11, name: "regenerated_messages", kind: "message", T: VaultRegenerateData_RegeneratedMessage, repeated: true }
  ]);
  class VaultRegenerateData_RegeneratedMessage extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.encryptedData = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultRegenerateData_RegeneratedMessage().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultRegenerateData_RegeneratedMessage().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultRegenerateData_RegeneratedMessage().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VaultRegenerateData_RegeneratedMessage, a2, b);
    }
  }
  VaultRegenerateData_RegeneratedMessage.runtime = proto3;
  VaultRegenerateData_RegeneratedMessage.typeName = "domain.VaultRegenerateData.RegeneratedMessage";
  VaultRegenerateData_RegeneratedMessage.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class VaultCreationData extends Message {
    constructor(data) {
      super();
      this.firstCommitBlob = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.organizationId = "";
      this.messagePublicKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultCreationData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VaultCreationData, a2, b);
    }
  }
  VaultCreationData.runtime = proto3;
  VaultCreationData.typeName = "domain.VaultCreationData";
  VaultCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "first_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 2, name: "authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 4, name: "profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 3,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 6, name: "admin_profile_lock", kind: "message", T: VaultProfileLock$1 }
  ]);
  class VaultPairCreationData extends Message {
    constructor(data) {
      super();
      this.firstCommitBlob = new Uint8Array(0);
      this.authenticatorLocks = [];
      this.messagePublicKey = new Uint8Array(0);
      this.associatedFirstCommitBlob = new Uint8Array(0);
      this.associatedAuthenticatorLocks = [];
      this.associatedMessagePublicKey = new Uint8Array(0);
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VaultPairCreationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VaultPairCreationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VaultPairCreationData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VaultPairCreationData, a2, b);
    }
  }
  VaultPairCreationData.runtime = proto3;
  VaultPairCreationData.typeName = "domain.VaultPairCreationData";
  VaultPairCreationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "first_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 2, name: "authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 7, name: "profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 9,
      name: "message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 11, name: "admin_profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 4,
      name: "associated_first_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 5, name: "associated_authenticator_locks", kind: "message", T: VaultAuthenticatorLock$1, repeated: true },
    { no: 8, name: "associated_profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 10,
      name: "associated_message_public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 12, name: "associated_admin_profile_lock", kind: "message", T: VaultProfileLock$1 },
    {
      no: 6,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShareLinkUpdate extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.encryptedPayload = new Uint8Array(0);
      this.encryptedProtectedSecret = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShareLinkUpdate().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShareLinkUpdate().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShareLinkUpdate().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ShareLinkUpdate, a2, b);
    }
  }
  ShareLinkUpdate.runtime = proto3;
  ShareLinkUpdate.typeName = "domain.ShareLinkUpdate";
  ShareLinkUpdate.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "encrypted_protected_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ShareLinksDelete extends Message {
    constructor(data) {
      super();
      this.keepShareLinkIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShareLinksDelete().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShareLinksDelete().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShareLinksDelete().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ShareLinksDelete, a2, b);
    }
  }
  ShareLinksDelete.runtime = proto3;
  ShareLinksDelete.typeName = "domain.ShareLinksDelete";
  ShareLinksDelete.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "keep_share_link_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class CreateCommitRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.latestCommitId = "";
      this.newCommitBlob = new Uint8Array(0);
      this.deleteMessageIds = [];
      this.linkedUpdateMessages = [];
      this.shareLinkUpdates = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateCommitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateCommitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateCommitRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateCommitRequest, a2, b);
    }
  }
  CreateCommitRequest.runtime = proto3;
  CreateCommitRequest.typeName = "domain.CreateCommitRequest";
  CreateCommitRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "new_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 4, name: "update_time", kind: "message", T: Timestamp },
    { no: 7, name: "delete_message_ids", kind: "scalar", T: 9, repeated: true },
    { no: 8, name: "linked_update_messages", kind: "message", T: LinkedLoginUpdateMessage, repeated: true },
    { no: 9, name: "share_link_updates", kind: "message", T: ShareLinkUpdate, repeated: true },
    { no: 10, name: "delete_share_links", kind: "message", T: ShareLinksDelete }
  ]);
  class CreateCommitResponse extends Message {
    constructor(data) {
      super();
      this.commitId = "";
      this.linkedUpdateMessageIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateCommitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateCommitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateCommitResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateCommitResponse, a2, b);
    }
  }
  CreateCommitResponse.runtime = proto3;
  CreateCommitResponse.typeName = "domain.CreateCommitResponse";
  CreateCommitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "linked_update_message_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class CreateGenerationRequest extends Message {
    constructor(data) {
      super();
      this.linkedUpdateMessages = [];
      this.shareLinkUpdates = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateGenerationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateGenerationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateGenerationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateGenerationRequest, a2, b);
    }
  }
  CreateGenerationRequest.runtime = proto3;
  CreateGenerationRequest.typeName = "domain.CreateGenerationRequest";
  CreateGenerationRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "vault", kind: "message", T: VaultRegenerateData },
    { no: 2, name: "linked_update_messages", kind: "message", T: LinkedLoginUpdateMessage, repeated: true },
    { no: 3, name: "delete_share_links", kind: "message", T: ShareLinksDelete },
    { no: 4, name: "share_link_updates", kind: "message", T: ShareLinkUpdate, repeated: true }
  ]);
  class CreateGenerationResponse extends Message {
    constructor(data) {
      super();
      this.commitId = "";
      this.generationId = "";
      this.linkedUpdateMessageIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateGenerationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateGenerationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateGenerationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateGenerationResponse, a2, b);
    }
  }
  CreateGenerationResponse.runtime = proto3;
  CreateGenerationResponse.typeName = "domain.CreateGenerationResponse";
  CreateGenerationResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "sync_update", kind: "message", T: SyncUpdate },
    { no: 4, name: "linked_update_message_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListCommitsRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.forceLocks = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListCommitsRequest, a2, b);
    }
  }
  ListCommitsRequest.runtime = proto3;
  ListCommitsRequest.typeName = "domain.ListCommitsRequest";
  ListCommitsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "latest_commit_id", kind: "message", T: StringValue },
    { no: 4, name: "latest_first_commit_id", kind: "message", T: StringValue },
    {
      no: 3,
      name: "force_locks",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ListCommitsResponse extends Message {
    constructor(data) {
      super();
      this.currentGenerationId = "";
      this.newerCommits = [];
      this.authenticatorLocks = [];
      this.firstCommitId = "";
      this.messages = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListCommitsResponse, a2, b);
    }
  }
  ListCommitsResponse.runtime = proto3;
  ListCommitsResponse.typeName = "domain.ListCommitsResponse";
  ListCommitsResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "current_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "newer_commits", kind: "message", T: ListCommitsResponse_Commit, repeated: true },
    { no: 3, name: "authenticator_locks", kind: "message", T: ListCommitsResponse_AuthenticatorLock, repeated: true },
    { no: 6, name: "profile_lock", kind: "message", T: VaultProfileLock$1 },
    { no: 8, name: "admin_profile_lock", kind: "message", T: VaultProfileLock$1 },
    { no: 4, name: "server_time", kind: "message", T: Timestamp },
    {
      no: 5,
      name: "first_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "messages", kind: "message", T: ListCommitsResponse_Message, repeated: true }
  ]);
  class ListCommitsResponse_Commit extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.blob = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse_Commit().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse_Commit().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse_Commit().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListCommitsResponse_Commit, a2, b);
    }
  }
  ListCommitsResponse_Commit.runtime = proto3;
  ListCommitsResponse_Commit.typeName = "domain.ListCommitsResponse.Commit";
  ListCommitsResponse_Commit.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListCommitsResponse_AuthenticatorLock extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.encryptedStorableVaultKey = new Uint8Array(0);
      this.encryptedHighSecurityVaultKey = new Uint8Array(0);
      this.encryptedVaultMessagePrivateKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse_AuthenticatorLock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse_AuthenticatorLock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse_AuthenticatorLock().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListCommitsResponse_AuthenticatorLock, a2, b);
    }
  }
  ListCommitsResponse_AuthenticatorLock.runtime = proto3;
  ListCommitsResponse_AuthenticatorLock.typeName = "domain.ListCommitsResponse.AuthenticatorLock";
  ListCommitsResponse_AuthenticatorLock.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListCommitsResponse_Message extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.type = VaultMessageType.UNKNOWN;
      this.encryptedData = new Uint8Array(0);
      this.senderVaultId = "";
      this.backendMessage = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListCommitsResponse_Message().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListCommitsResponse_Message().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListCommitsResponse_Message().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListCommitsResponse_Message, a2, b);
    }
  }
  ListCommitsResponse_Message.runtime = proto3;
  ListCommitsResponse_Message.typeName = "domain.ListCommitsResponse.Message";
  ListCommitsResponse_Message.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 3,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "sender_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "backend_message",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateTeamRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTeamRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTeamRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTeamRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateTeamRequest, a2, b);
    }
  }
  CreateTeamRequest.runtime = proto3;
  CreateTeamRequest.typeName = "domain.CreateTeamRequest";
  CreateTeamRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "creation_data", kind: "message", T: VaultPairCreationData }
  ]);
  class CreateTeamResponse extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.associatedVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTeamResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTeamResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTeamResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateTeamResponse, a2, b);
    }
  }
  CreateTeamResponse.runtime = proto3;
  CreateTeamResponse.typeName = "domain.CreateTeamResponse";
  CreateTeamResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteTeamRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteTeamRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteTeamRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteTeamRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteTeamRequest, a2, b);
    }
  }
  DeleteTeamRequest.runtime = proto3;
  DeleteTeamRequest.typeName = "domain.DeleteTeamRequest";
  DeleteTeamRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteTeamResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteTeamResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteTeamResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteTeamResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteTeamResponse, a2, b);
    }
  }
  DeleteTeamResponse.runtime = proto3;
  DeleteTeamResponse.typeName = "domain.DeleteTeamResponse";
  DeleteTeamResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ModifyTeamUsersRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.addProfileOps = [];
      this.removeProfileIds = [];
      this.assocLatestCommitId = "";
      this.assocNewCommitBlob = new Uint8Array(0);
      this.generationId = "";
      this.assocGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyTeamUsersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyTeamUsersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyTeamUsersRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyTeamUsersRequest, a2, b);
    }
  }
  ModifyTeamUsersRequest.runtime = proto3;
  ModifyTeamUsersRequest.typeName = "domain.ModifyTeamUsersRequest";
  ModifyTeamUsersRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 11, name: "add_profile_ops", kind: "message", T: ModifyTeamUsersRequest_AddProfileOperation, repeated: true },
    { no: 12, name: "remove_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 4, name: "regenerate_data", kind: "message", T: VaultRegenerateData },
    { no: 5, name: "associated_regenerate_data", kind: "message", T: VaultRegenerateData },
    { no: 6, name: "update_time", kind: "message", T: Timestamp },
    {
      no: 7,
      name: "assoc_latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "assoc_new_commit_blob",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "assoc_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ModifyTeamUsersRequest_AddProfileOperation extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyTeamUsersRequest_AddProfileOperation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyTeamUsersRequest_AddProfileOperation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyTeamUsersRequest_AddProfileOperation().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyTeamUsersRequest_AddProfileOperation, a2, b);
    }
  }
  ModifyTeamUsersRequest_AddProfileOperation.runtime = proto3;
  ModifyTeamUsersRequest_AddProfileOperation.typeName = "domain.ModifyTeamUsersRequest.AddProfileOperation";
  ModifyTeamUsersRequest_AddProfileOperation.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "lock", kind: "message", T: VaultProfileLock$1 },
    { no: 3, name: "associated_lock", kind: "message", T: VaultProfileLock$1 }
  ]);
  class ModifyTeamUsersResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyTeamUsersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyTeamUsersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyTeamUsersResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyTeamUsersResponse, a2, b);
    }
  }
  ModifyTeamUsersResponse.runtime = proto3;
  ModifyTeamUsersResponse.typeName = "domain.ModifyTeamUsersResponse";
  ModifyTeamUsersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateInboxVaultRequest extends Message {
    constructor(data) {
      super();
      this.slug = "";
      this.metadata = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInboxVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInboxVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInboxVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateInboxVaultRequest, a2, b);
    }
  }
  CreateInboxVaultRequest.runtime = proto3;
  CreateInboxVaultRequest.typeName = "domain.CreateInboxVaultRequest";
  CreateInboxVaultRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "creation_data", kind: "message", T: VaultPairCreationData },
    {
      no: 2,
      name: "slug",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateInboxVaultResponse extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.associatedVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInboxVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInboxVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInboxVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateInboxVaultResponse, a2, b);
    }
  }
  CreateInboxVaultResponse.runtime = proto3;
  CreateInboxVaultResponse.typeName = "domain.CreateInboxVaultResponse";
  CreateInboxVaultResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class UpdateInboxRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateInboxRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateInboxRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateInboxRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateInboxRequest, a2, b);
    }
  }
  UpdateInboxRequest.runtime = proto3;
  UpdateInboxRequest.typeName = "domain.UpdateInboxRequest";
  UpdateInboxRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "slug", kind: "message", T: StringValue },
    { no: 3, name: "metadata", kind: "message", T: StringValue }
  ]);
  class UpdateInboxResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateInboxResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateInboxResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateInboxResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateInboxResponse, a2, b);
    }
  }
  UpdateInboxResponse.runtime = proto3;
  UpdateInboxResponse.typeName = "domain.UpdateInboxResponse";
  UpdateInboxResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteInboxVaultRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteInboxVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteInboxVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteInboxVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteInboxVaultRequest, a2, b);
    }
  }
  DeleteInboxVaultRequest.runtime = proto3;
  DeleteInboxVaultRequest.typeName = "domain.DeleteInboxVaultRequest";
  DeleteInboxVaultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteInboxVaultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteInboxVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteInboxVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteInboxVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteInboxVaultResponse, a2, b);
    }
  }
  DeleteInboxVaultResponse.runtime = proto3;
  DeleteInboxVaultResponse.typeName = "domain.DeleteInboxVaultResponse";
  DeleteInboxVaultResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ListMessagePublicKeysRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.vaultIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListMessagePublicKeysRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListMessagePublicKeysRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListMessagePublicKeysRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListMessagePublicKeysRequest, a2, b);
    }
  }
  ListMessagePublicKeysRequest.runtime = proto3;
  ListMessagePublicKeysRequest.typeName = "domain.ListMessagePublicKeysRequest";
  ListMessagePublicKeysRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "vault_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListMessagePublicKeysResponse extends Message {
    constructor(data) {
      super();
      this.messagePublicKeys = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListMessagePublicKeysResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListMessagePublicKeysResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListMessagePublicKeysResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListMessagePublicKeysResponse, a2, b);
    }
  }
  ListMessagePublicKeysResponse.runtime = proto3;
  ListMessagePublicKeysResponse.typeName = "domain.ListMessagePublicKeysResponse";
  ListMessagePublicKeysResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "message_public_keys", kind: "message", T: ListMessagePublicKeysResponse_MessagePublicKey, repeated: true }
  ]);
  class ListMessagePublicKeysResponse_MessagePublicKey extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.key = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListMessagePublicKeysResponse_MessagePublicKey().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListMessagePublicKeysResponse_MessagePublicKey().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListMessagePublicKeysResponse_MessagePublicKey().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListMessagePublicKeysResponse_MessagePublicKey, a2, b);
    }
  }
  ListMessagePublicKeysResponse_MessagePublicKey.runtime = proto3;
  ListMessagePublicKeysResponse_MessagePublicKey.typeName = "domain.ListMessagePublicKeysResponse.MessagePublicKey";
  ListMessagePublicKeysResponse_MessagePublicKey.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  var __awaiter$1c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class VaultServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    createCommit(vaultId, latestCommitId, newCommitBlob, updateTime, deleteMessageIds = [], linkedUpdateMessages = [], shareLinkUpdates = [], deleteShareLinks) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createCommit({
          vaultId,
          latestCommitId,
          newCommitBlob,
          updateTime: Timestamp.fromDate(updateTime),
          deleteMessageIds,
          linkedUpdateMessages,
          shareLinkUpdates,
          deleteShareLinks
        });
        return {
          commitId: requireFieldNotEmpty(resp.commitId),
          updateMessageIds: resp.linkedUpdateMessageIds
        };
      });
    }
    createGeneration(dto, linkedUpdateMessages = [], deleteShareLinks, shareLinkUpdates = []) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createGeneration({
          vault: toVaultRegenerateData(dto),
          linkedUpdateMessages,
          deleteShareLinks,
          shareLinkUpdates
        });
        return {
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate)),
          updateMessageIds: resp.linkedUpdateMessageIds
        };
      });
    }
    listCommits(vaultId, latestCommitId, latestFirstCommitId, forceLocks) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.listCommits({
          vaultId,
          latestCommitId: latestCommitId !== null && latestCommitId !== void 0 ? latestCommitId : void 0,
          latestFirstCommitId: latestFirstCommitId !== null && latestFirstCommitId !== void 0 ? latestFirstCommitId : void 0,
          forceLocks
        });
        const { commitDtos } = resp.newerCommits.reduce(({ parentId, commitDtos: dtos }, commit) => ({
          parentId: requireFieldNotEmpty(commit.id),
          commitDtos: [
            ...dtos,
            {
              id: requireFieldNotEmpty(commit.id),
              parentId,
              blob: commit.blob
            }
          ]
        }), { parentId: latestCommitId, commitDtos: [] });
        const lockDtos = resp.authenticatorLocks.map(toVaultAuthenticatorLockDto);
        const profileLockDto = toVaultProfileLockDto(resp.profileLock);
        const adminProfileLockDto = toVaultProfileLockDto(resp.adminProfileLock);
        const serverTime = requireFieldNotEmpty(resp.serverTime).toDate();
        const firstCommitId = requireFieldNotEmpty(resp.firstCommitId);
        const messages2 = resp.messages.map((im) => {
          return {
            id: requireFieldNotEmpty(im.id),
            type: requireFieldNotEmpty(im.type),
            senderVaultId: im.senderVaultId,
            encryptedData: im.encryptedData.length > 0 ? im.encryptedData : void 0,
            backendMessage: im.backendMessage.length > 0 ? im.backendMessage : void 0
          };
        });
        return {
          generationId: requireFieldNotEmpty(resp.currentGenerationId),
          commitDtos,
          lockDtos,
          profileLockDto,
          adminProfileLockDto,
          serverTime,
          firstCommitId,
          messages: messages2
        };
      });
    }
    createTeam(vcd) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createTeam({ creationData: toVaultPairCreationData(vcd) });
        return {
          vaultId: requireFieldNotEmpty(resp.vaultId),
          associatedVaultId: requireFieldNotEmpty(resp.associatedVaultId),
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate))
        };
      });
    }
    deleteTeam(vaultId) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.deleteTeam({ vaultId });
        return {
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate))
        };
      });
    }
    modifyTeamUsers(id, generationId, addProfiles, removeProfileIds, assocGenerationId, assocLatestCommitId, assocNewCommitBlob, updateTime, regenerateData, associatedRegenerateData) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.modifyTeamUsers({
          vaultId: id,
          generationId,
          assocGenerationId,
          addProfileOps: addProfiles.map((p2) => ({
            profileId: p2.id,
            lock: toPbVaultProfileLock(p2.lock),
            associatedLock: p2.associatedLock ? toPbVaultProfileLock(p2.associatedLock) : void 0
          })),
          removeProfileIds,
          assocLatestCommitId,
          assocNewCommitBlob,
          updateTime: updateTime ? Timestamp.fromDate(updateTime) : void 0,
          regenerateData: regenerateData ? toVaultRegenerateData(regenerateData) : void 0,
          associatedRegenerateData: associatedRegenerateData ? toVaultRegenerateData(associatedRegenerateData) : void 0
        });
        return {
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate))
        };
      });
    }
    createInboxVault(vcd, slug, metadataJson) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createInboxVault({
          creationData: toVaultPairCreationData(vcd),
          slug,
          metadata: metadataJson
        });
        return {
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate)),
          vaultId: requireFieldNotEmpty(resp.vaultId),
          associatedVaultId: requireFieldNotEmpty(resp.associatedVaultId)
        };
      });
    }
    updateInbox(vaultId, { slug, metadataJson }) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.updateInbox({
          vaultId,
          slug: slug ? slug : void 0,
          metadata: metadataJson ? metadataJson : void 0
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    deleteInboxVault(vaultId) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.deleteInboxVault({ vaultId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    listMessagePublicKeys(organizationId, vaultIds) {
      return __awaiter$1c(this, void 0, void 0, function* () {
        return this.espbClient.listMessagePublicKeys({ organizationId, vaultIds });
      });
    }
  }
  function toPbVaultCreationData({ blob, locks, profileLock, adminProfileLock, organizationId, messagePublicKey }) {
    return new VaultCreationData({
      firstCommitBlob: blob,
      profileLock: profileLock ? toPbVaultProfileLock(profileLock) : void 0,
      adminProfileLock: adminProfileLock ? toPbVaultProfileLock(adminProfileLock) : void 0,
      authenticatorLocks: locks.map(toPbVaultAuthenticatorLock),
      organizationId,
      messagePublicKey
    });
  }
  function toVaultPairCreationData({ blob, locks, profileLock, adminProfileLock, messagePublicKey, associatedBlob, associatedLocks, associatedProfileLock, associatedAdminProfileLock, associatedMessagePublicKey, organizationId }) {
    return new VaultPairCreationData({
      firstCommitBlob: blob,
      authenticatorLocks: locks.map(toPbVaultAuthenticatorLock),
      profileLock: profileLock ? toPbVaultProfileLock(profileLock) : void 0,
      adminProfileLock: adminProfileLock ? toPbVaultProfileLock(adminProfileLock) : void 0,
      messagePublicKey,
      associatedFirstCommitBlob: associatedBlob,
      associatedAuthenticatorLocks: associatedLocks.map(toPbVaultAuthenticatorLock),
      associatedProfileLock: associatedProfileLock ? toPbVaultProfileLock(associatedProfileLock) : void 0,
      associatedAdminProfileLock: associatedAdminProfileLock ? toPbVaultProfileLock(associatedAdminProfileLock) : void 0,
      associatedMessagePublicKey,
      organizationId
    });
  }
  function toVaultRegenerateData(dto) {
    const vault = new VaultRegenerateData(Object.assign(Object.assign({}, dto), { squashedCommits: dto.blob, authenticatorLocks: dto.locks.map(toPbVaultAuthenticatorLock), profileLocks: dto.profileLocks.map(toPbVaultProfileLock) }));
    return vault;
  }
  var __awaiter$1b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class AccountServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    getRegistrationInfo(email) {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.getRegistrationInfo({ email });
        return {
          status: knownEnumOrDefault(resp.status, RegistrationInfoStatus),
          organization: resp.organization ? {
            id: requireFieldNotEmpty(resp.organization.id),
            name: resp.organization.name,
            icon: resp.organization.icon || void 0,
            startCodePrefix: resp.organization.startCodePrefix || void 0,
            profileId: resp.organization.profileId || void 0,
            organizationType: knownEnumOrDefault(resp.organization.organizationType, OrganizationType)
          } : void 0,
          webauthnAllowed: resp.webauthnAllowed
        };
      });
    }
    createWithProfile(authenticators, prefsProfile, metaVault, inboxProfile, authenticatorBlock, referrerId, preliminaryEmail, sessionUnlockData, webauthnCredentialData, startCode, startCodeProfileId) {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createWithProfile({
          preliminaryEmail: preliminaryEmail !== null && preliminaryEmail !== void 0 ? preliminaryEmail : void 0,
          authenticators,
          authenticatorBlock: authenticatorBlock === null || authenticatorBlock === void 0 ? void 0 : authenticatorBlock.blob,
          authenticatorBlockSignature: authenticatorBlock === null || authenticatorBlock === void 0 ? void 0 : authenticatorBlock.signature,
          referrerId: referrerId !== null && referrerId !== void 0 ? referrerId : void 0,
          preferencesProfile: prefsProfile,
          inboxProfile,
          metaVault: toPbVaultCreationData(metaVault),
          sessionUnlockData: sessionUnlockData ? {
            encryptedSecret: sessionUnlockData.encryptedSecret,
            unlockMaxExpiresAt: sessionUnlockData.unlockMaxExpiresAt ? Timestamp.fromDate(sessionUnlockData.unlockMaxExpiresAt) : void 0
          } : void 0,
          webauthnCredentialData,
          startCode,
          startCodeProfileId
        });
        const authenticatorDtos = resp.authenticatorIds.map((id, i2) => Object.assign(Object.assign({}, authenticators[i2].data), { id }));
        const token = requireFieldNotEmpty(resp.accessToken);
        const loginData = {
          userId: requireFieldNotEmpty(resp.userId),
          sessionId: requireFieldNotEmpty(resp.sessionId),
          token: requireFieldNotEmpty(token.token)
        };
        return { userId: resp.userId, authenticatorDtos, loginData };
      });
    }
    createReferrer(referrer) {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createReferrer({ referrer });
        return requireFieldNotEmpty(resp.referrerId);
      });
    }
    addAchievements(achievementIds) {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.addAchievements({ achievements: achievementIds });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    update({ preferredLocale, userClientSettings }) {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.update({
          preferredLocale: preferredLocale === null ? "" : preferredLocale,
          userClientSettings: userClientSettings === null ? "" : userClientSettings
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    list(knownUsers, userEmails, profileIds) {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.list({ emails: userEmails, users: knownUsers, profileIds });
        const users = resp.users.map((u2) => {
          return Object.assign(Object.assign({}, u2), { id: requireFieldNotEmpty(u2.userId) });
        });
        return { users };
      });
    }
    resolveEmails(emails, failFast) {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const result2 = yield this.espbClient.resolveEmails({ emails, failFast });
        return result2.emails.map((e) => Object.assign(Object.assign({}, e), { userId: e.userId || null, profiles: e.profiles.map((p2) => ({
          profileId: requireFieldNotEmpty(p2.id),
          profileType: knownEnumOrDefault(p2.profileType, ProfileType),
          organizationId: p2.organizationId || null
        })) }));
      });
    }
    getPaddleConfig() {
      return __awaiter$1b(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.getPaddleConfig({});
        return Object.assign(Object.assign({}, resp), { vendorId: Number(resp.vendorId), productIdMonthly: Number(resp.productIdMonthly), productIdYearly: Number(resp.productIdYearly) });
      });
    }
    deleteAccount() {
      return __awaiter$1b(this, void 0, void 0, function* () {
        yield this.espbClient.delete({});
      });
    }
  }
  class WriteEventsRequest extends Message {
    constructor(data) {
      super();
      this.events = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteEventsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteEventsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteEventsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(WriteEventsRequest, a2, b);
    }
  }
  WriteEventsRequest.runtime = proto3;
  WriteEventsRequest.typeName = "domain.WriteEventsRequest";
  WriteEventsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: WriteEventsRequest_Event, repeated: true }
  ]);
  class WriteEventsRequest_Event extends Message {
    constructor(data) {
      super();
      this.eventJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteEventsRequest_Event().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteEventsRequest_Event().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteEventsRequest_Event().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(WriteEventsRequest_Event, a2, b);
    }
  }
  WriteEventsRequest_Event.runtime = proto3;
  WriteEventsRequest_Event.typeName = "domain.WriteEventsRequest.Event";
  WriteEventsRequest_Event.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "event_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "client_time", kind: "message", T: Timestamp },
    { no: 3, name: "last_known_server_time", kind: "message", T: Timestamp }
  ]);
  class WriteEventsResponse extends Message {
    constructor(data) {
      super();
      this.eventIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new WriteEventsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new WriteEventsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new WriteEventsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(WriteEventsResponse, a2, b);
    }
  }
  WriteEventsResponse.runtime = proto3;
  WriteEventsResponse.typeName = "domain.WriteEventsResponse";
  WriteEventsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "event_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListEventsRequest extends Message {
    constructor(data) {
      super();
      this.page = 0;
      this.eventTypes = [];
      this.filterProfileIds = [];
      this.filterTargetProfileIds = [];
      this.filterVaultIds = [];
      this.filterLoginIds = [];
      this.filterIpPrefix = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListEventsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListEventsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListEventsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListEventsRequest, a2, b);
    }
  }
  ListEventsRequest.runtime = proto3;
  ListEventsRequest.typeName = "domain.ListEventsRequest";
  ListEventsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "time_anchor", kind: "message", T: Timestamp },
    {
      no: 2,
      name: "page",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 3, name: "from_time", kind: "message", T: Timestamp },
    { no: 4, name: "to_time", kind: "message", T: Timestamp },
    { no: 5, name: "event_types", kind: "enum", T: proto3.getEnumType(AuditlogEventType), repeated: true },
    { no: 6, name: "filter_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 11, name: "filter_target_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 7, name: "filter_vault_ids", kind: "scalar", T: 9, repeated: true },
    { no: 8, name: "filter_login_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 10,
      name: "filter_ip_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "additional_filter", kind: "message", T: ListEventsRequest_MatchAnyFilter }
  ]);
  class ListEventsRequest_MatchAnyFilter extends Message {
    constructor(data) {
      super();
      this.profileIds = [];
      this.targetProfileIds = [];
      this.vaultIds = [];
      this.loginIds = [];
      this.filterIpPrefix = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListEventsRequest_MatchAnyFilter().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListEventsRequest_MatchAnyFilter().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListEventsRequest_MatchAnyFilter().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListEventsRequest_MatchAnyFilter, a2, b);
    }
  }
  ListEventsRequest_MatchAnyFilter.runtime = proto3;
  ListEventsRequest_MatchAnyFilter.typeName = "domain.ListEventsRequest.MatchAnyFilter";
  ListEventsRequest_MatchAnyFilter.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 5, name: "target_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 2, name: "vault_ids", kind: "scalar", T: 9, repeated: true },
    { no: 3, name: "login_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 4,
      name: "filter_ip_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ListEventsResponse extends Message {
    constructor(data) {
      super();
      this.envelopedEventJson = [];
      this.totalCount = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListEventsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListEventsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListEventsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListEventsResponse, a2, b);
    }
  }
  ListEventsResponse.runtime = proto3;
  ListEventsResponse.typeName = "domain.ListEventsResponse";
  ListEventsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "enveloped_event_json", kind: "scalar", T: 9, repeated: true },
    {
      no: 2,
      name: "total_count",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    { no: 3, name: "time_anchor", kind: "message", T: Timestamp }
  ]);
  const AuditlogService = {
    typeName: "domain.AuditlogService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - AuditlogMalformedEvent (90500)
       * - Internal (10500)
       *
       * @generated from rpc domain.AuditlogService.WriteEvents
       */
      writeEvents: {
        name: "WriteEvents",
        I: WriteEventsRequest,
        O: WriteEventsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.AuditlogService.ListEvents
       */
      listEvents: {
        name: "ListEvents",
        I: ListEventsRequest,
        O: ListEventsResponse,
        kind: MethodKind.Unary
      }
    }
  };
  var Code;
  (function(Code2) {
    Code2[Code2["Canceled"] = 1] = "Canceled";
    Code2[Code2["Unknown"] = 2] = "Unknown";
    Code2[Code2["InvalidArgument"] = 3] = "InvalidArgument";
    Code2[Code2["DeadlineExceeded"] = 4] = "DeadlineExceeded";
    Code2[Code2["NotFound"] = 5] = "NotFound";
    Code2[Code2["AlreadyExists"] = 6] = "AlreadyExists";
    Code2[Code2["PermissionDenied"] = 7] = "PermissionDenied";
    Code2[Code2["ResourceExhausted"] = 8] = "ResourceExhausted";
    Code2[Code2["FailedPrecondition"] = 9] = "FailedPrecondition";
    Code2[Code2["Aborted"] = 10] = "Aborted";
    Code2[Code2["OutOfRange"] = 11] = "OutOfRange";
    Code2[Code2["Unimplemented"] = 12] = "Unimplemented";
    Code2[Code2["Internal"] = 13] = "Internal";
    Code2[Code2["Unavailable"] = 14] = "Unavailable";
    Code2[Code2["DataLoss"] = 15] = "DataLoss";
    Code2[Code2["Unauthenticated"] = 16] = "Unauthenticated";
  })(Code || (Code = {}));
  function codeToString(value) {
    const name = Code[value];
    if (typeof name != "string") {
      return value.toString();
    }
    return name[0].toLowerCase() + name.substring(1).replace(/[A-Z]/g, (c2) => "_" + c2.toLowerCase());
  }
  class ConnectError extends Error {
    /**
     * Create a new ConnectError.
     * If no code is provided, code "unknown" is used.
     * Outgoing details are only relevant for the server side - a service may
     * raise an error with details, and it is up to the protocol implementation
     * to encode and send the details along with error.
     */
    constructor(message, code = Code.Unknown, metadata, outgoingDetails, cause) {
      super(createMessage(message, code));
      this.name = "ConnectError";
      Object.setPrototypeOf(this, new.target.prototype);
      this.rawMessage = message;
      this.code = code;
      this.metadata = new Headers(metadata !== null && metadata !== void 0 ? metadata : {});
      this.details = outgoingDetails !== null && outgoingDetails !== void 0 ? outgoingDetails : [];
      this.cause = cause;
    }
    /**
     * Convert any value - typically a caught error into a ConnectError,
     * following these rules:
     * - If the value is already a ConnectError, return it as is.
     * - If the value is an AbortError from the fetch API, return the message
     *   of the AbortError with code Canceled.
     * - For other Errors, return the error message with code Unknown by default.
     * - For other values, return the values String representation as a message,
     *   with the code Unknown by default.
     * The original value will be used for the "cause" property for the new
     * ConnectError.
     */
    static from(reason, code = Code.Unknown) {
      if (reason instanceof ConnectError) {
        return reason;
      }
      if (reason instanceof Error) {
        if (reason.name == "AbortError") {
          return new ConnectError(reason.message, Code.Canceled);
        }
        return new ConnectError(reason.message, code, void 0, void 0, reason);
      }
      return new ConnectError(String(reason), code, void 0, void 0, reason);
    }
    static [Symbol.hasInstance](v2) {
      if (!(v2 instanceof Error)) {
        return false;
      }
      if (Object.getPrototypeOf(v2) === ConnectError.prototype) {
        return true;
      }
      return v2.name === "ConnectError" && "code" in v2 && typeof v2.code === "number" && "metadata" in v2 && "details" in v2 && Array.isArray(v2.details) && "rawMessage" in v2 && typeof v2.rawMessage == "string" && "cause" in v2;
    }
    findDetails(typeOrRegistry) {
      const registry = "typeName" in typeOrRegistry ? {
        findMessage: (typeName) => typeName === typeOrRegistry.typeName ? typeOrRegistry : void 0
      } : typeOrRegistry;
      const details = [];
      for (const data of this.details) {
        if ("getType" in data) {
          if (registry.findMessage(data.getType().typeName)) {
            details.push(data);
          }
          continue;
        }
        const type = registry.findMessage(data.type);
        if (type) {
          try {
            details.push(type.fromBinary(data.value));
          } catch (_) {
          }
        }
      }
      return details;
    }
  }
  function createMessage(message, code) {
    return message.length ? `[${codeToString(code)}] ${message}` : `[${codeToString(code)}]`;
  }
  function decodeBinaryHeader(value, type, options) {
    try {
      const bytes = protoBase64.dec(value);
      if (type) {
        return type.fromBinary(bytes, options);
      }
      return bytes;
    } catch (e) {
      throw ConnectError.from(e, Code.DataLoss);
    }
  }
  function makeAnyClient(service, createMethod) {
    const client = {};
    for (const [localName, methodInfo] of Object.entries(service.methods)) {
      const method = createMethod(Object.assign(Object.assign({}, methodInfo), {
        localName,
        service
      }));
      if (method != null) {
        client[localName] = method;
      }
    }
    return client;
  }
  function createEnvelopeReadableStream(stream) {
    let reader;
    let buffer = new Uint8Array(0);
    function append(chunk) {
      const n = new Uint8Array(buffer.length + chunk.length);
      n.set(buffer);
      n.set(chunk, buffer.length);
      buffer = n;
    }
    return new ReadableStream({
      start() {
        reader = stream.getReader();
      },
      async pull(controller) {
        let header = void 0;
        for (; ; ) {
          if (header === void 0 && buffer.byteLength >= 5) {
            let length = 0;
            for (let i2 = 1; i2 < 5; i2++) {
              length = (length << 8) + buffer[i2];
            }
            header = { flags: buffer[0], length };
          }
          if (header !== void 0 && buffer.byteLength >= header.length + 5) {
            break;
          }
          const result2 = await reader.read();
          if (result2.done) {
            break;
          }
          append(result2.value);
        }
        if (header === void 0) {
          if (buffer.byteLength == 0) {
            controller.close();
            return;
          }
          controller.error(new ConnectError("premature end of stream", Code.DataLoss));
          return;
        }
        const data = buffer.subarray(5, 5 + header.length);
        buffer = buffer.subarray(5 + header.length);
        controller.enqueue({
          flags: header.flags,
          data
        });
      }
    });
  }
  function encodeEnvelope(flags2, data) {
    const bytes = new Uint8Array(data.length + 5);
    bytes.set(data, 5);
    const v2 = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    v2.setUint8(0, flags2);
    v2.setUint32(1, data.length);
    return bytes;
  }
  var __asyncValues$4 = globalThis && globalThis.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  };
  var __await$3 = globalThis && globalThis.__await || function(v2) {
    return this instanceof __await$3 ? (this.v = v2, this) : new __await$3(v2);
  };
  var __asyncGenerator$3 = globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function awaitReturn(f2) {
      return function(v2) {
        return Promise.resolve(v2).then(f2, reject);
      };
    }
    function verb(n, f2) {
      if (g2[n]) {
        i2[n] = function(v2) {
          return new Promise(function(a2, b) {
            q.push([n, v2, a2, b]) > 1 || resume(n, v2);
          });
        };
        if (f2)
          i2[n] = f2(i2[n]);
      }
    }
    function resume(n, v2) {
      try {
        step(g2[n](v2));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await$3 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var __asyncDelegator$1 = globalThis && globalThis.__asyncDelegator || function(o) {
    var i2, p2;
    return i2 = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i2[Symbol.iterator] = function() {
      return this;
    }, i2;
    function verb(n, f2) {
      i2[n] = o[n] ? function(v2) {
        return (p2 = !p2) ? { value: __await$3(o[n](v2)), done: false } : f2 ? f2(v2) : v2;
      } : f2;
    }
  };
  function createAsyncIterable(items) {
    return __asyncGenerator$3(this, arguments, function* createAsyncIterable_1() {
      yield __await$3(yield* __asyncDelegator$1(__asyncValues$4(items)));
    });
  }
  var __asyncValues$3 = globalThis && globalThis.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  };
  var __await$2 = globalThis && globalThis.__await || function(v2) {
    return this instanceof __await$2 ? (this.v = v2, this) : new __await$2(v2);
  };
  var __asyncDelegator = globalThis && globalThis.__asyncDelegator || function(o) {
    var i2, p2;
    return i2 = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i2[Symbol.iterator] = function() {
      return this;
    }, i2;
    function verb(n, f2) {
      i2[n] = o[n] ? function(v2) {
        return (p2 = !p2) ? { value: __await$2(o[n](v2)), done: false } : f2 ? f2(v2) : v2;
      } : f2;
    }
  };
  var __asyncGenerator$2 = globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function awaitReturn(f2) {
      return function(v2) {
        return Promise.resolve(v2).then(f2, reject);
      };
    }
    function verb(n, f2) {
      if (g2[n]) {
        i2[n] = function(v2) {
          return new Promise(function(a2, b) {
            q.push([n, v2, a2, b]) > 1 || resume(n, v2);
          });
        };
        if (f2)
          i2[n] = f2(i2[n]);
      }
    }
    function resume(n, v2) {
      try {
        step(g2[n](v2));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await$2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  function createPromiseClient(service, transport) {
    return makeAnyClient(service, (method) => {
      switch (method.kind) {
        case MethodKind.Unary:
          return createUnaryFn(transport, service, method);
        case MethodKind.ServerStreaming:
          return createServerStreamingFn(transport, service, method);
        case MethodKind.ClientStreaming:
          return createClientStreamingFn(transport, service, method);
        case MethodKind.BiDiStreaming:
          return createBiDiStreamingFn(transport, service, method);
        default:
          return null;
      }
    });
  }
  function createUnaryFn(transport, service, method) {
    return async function(input, options) {
      var _a2, _b2;
      const response = await transport.unary(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, input, options === null || options === void 0 ? void 0 : options.contextValues);
      (_a2 = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a2 === void 0 ? void 0 : _a2.call(options, response.header);
      (_b2 = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b2 === void 0 ? void 0 : _b2.call(options, response.trailer);
      return response.message;
    };
  }
  function createServerStreamingFn(transport, service, method) {
    return function(input, options) {
      return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, createAsyncIterable([input]), options === null || options === void 0 ? void 0 : options.contextValues), options);
    };
  }
  function createClientStreamingFn(transport, service, method) {
    return async function(request, options) {
      var _a2, e_1, _b2, _c2;
      var _d2, _e2;
      const response = await transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues);
      (_d2 = options === null || options === void 0 ? void 0 : options.onHeader) === null || _d2 === void 0 ? void 0 : _d2.call(options, response.header);
      let singleMessage;
      try {
        for (var _f2 = true, _g2 = __asyncValues$3(response.message), _h2; _h2 = await _g2.next(), _a2 = _h2.done, !_a2; _f2 = true) {
          _c2 = _h2.value;
          _f2 = false;
          const message = _c2;
          singleMessage = message;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_f2 && !_a2 && (_b2 = _g2.return))
            await _b2.call(_g2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (!singleMessage) {
        throw new ConnectError("protocol error: missing response message", Code.Internal);
      }
      (_e2 = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _e2 === void 0 ? void 0 : _e2.call(options, response.trailer);
      return singleMessage;
    };
  }
  function createBiDiStreamingFn(transport, service, method) {
    return function(request, options) {
      return handleStreamResponse(transport.stream(service, method, options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.timeoutMs, options === null || options === void 0 ? void 0 : options.headers, request, options === null || options === void 0 ? void 0 : options.contextValues), options);
    };
  }
  function handleStreamResponse(stream, options) {
    const it = function() {
      var _a2, _b2;
      return __asyncGenerator$2(this, arguments, function* () {
        const response = yield __await$2(stream);
        (_a2 = options === null || options === void 0 ? void 0 : options.onHeader) === null || _a2 === void 0 ? void 0 : _a2.call(options, response.header);
        yield __await$2(yield* __asyncDelegator(__asyncValues$3(response.message)));
        (_b2 = options === null || options === void 0 ? void 0 : options.onTrailer) === null || _b2 === void 0 ? void 0 : _b2.call(options, response.trailer);
      });
    }()[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => it.next()
      })
    };
  }
  function createLinkedAbortController(...signals) {
    const controller = new AbortController();
    const sa = signals.filter((s2) => s2 !== void 0).concat(controller.signal);
    for (const signal of sa) {
      if (signal.aborted) {
        onAbort.apply(signal);
        break;
      }
      signal.addEventListener("abort", onAbort);
    }
    function onAbort() {
      if (!controller.signal.aborted) {
        controller.abort(getAbortSignalReason(this));
      }
      for (const signal of sa) {
        signal.removeEventListener("abort", onAbort);
      }
    }
    return controller;
  }
  function createDeadlineSignal(timeoutMs) {
    const controller = new AbortController();
    const listener = () => {
      controller.abort(new ConnectError("the operation timed out", Code.DeadlineExceeded));
    };
    let timeoutId;
    if (timeoutMs !== void 0) {
      if (timeoutMs <= 0)
        listener();
      else
        timeoutId = setTimeout(listener, timeoutMs);
    }
    return {
      signal: controller.signal,
      cleanup: () => clearTimeout(timeoutId)
    };
  }
  function getAbortSignalReason(signal) {
    if (!signal.aborted) {
      return void 0;
    }
    if (signal.reason !== void 0) {
      return signal.reason;
    }
    const e = new Error("This operation was aborted");
    e.name = "AbortError";
    return e;
  }
  function createContextValues() {
    return {
      get(key) {
        return key.id in this ? this[key.id] : key.defaultValue;
      },
      set(key, value) {
        this[key.id] = value;
        return this;
      },
      delete(key) {
        delete this[key.id];
        return this;
      }
    };
  }
  const trailerFlag = 128;
  function trailerParse(data) {
    const headers = new Headers();
    const lines = new TextDecoder().decode(data).split("\r\n");
    for (const line of lines) {
      if (line === "") {
        continue;
      }
      const i2 = line.indexOf(":");
      if (i2 > 0) {
        const name = line.substring(0, i2).trim();
        const value = line.substring(i2 + 1).trim();
        headers.append(name, value);
      }
    }
    return headers;
  }
  const headerContentType = "Content-Type";
  const headerTimeout = "Grpc-Timeout";
  const headerGrpcStatus = "Grpc-Status";
  const headerGrpcMessage = "Grpc-Message";
  const headerStatusDetailsBin = "Grpc-Status-Details-Bin";
  const headerUserAgent = "User-Agent";
  const headerXUserAgent = "X-User-Agent";
  const headerXGrpcWeb = "X-Grpc-Web";
  const contentTypeProto = "application/grpc-web+proto";
  const contentTypeJson = "application/grpc-web+json";
  let Status$1 = class Status2 extends Message {
    constructor(data) {
      super();
      this.code = 0;
      this.message = "";
      this.details = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new Status2().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Status2().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Status2().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Status2, a2, b);
    }
  };
  Status$1.runtime = proto3;
  Status$1.typeName = "google.rpc.Status";
  Status$1.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "code",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "details", kind: "message", T: Any, repeated: true }
  ]);
  const grpcStatusOk = "0";
  function findTrailerError(headerOrTrailer) {
    var _a2;
    const statusBytes = headerOrTrailer.get(headerStatusDetailsBin);
    if (statusBytes != null) {
      const status = decodeBinaryHeader(statusBytes, Status$1);
      if (status.code == 0) {
        return void 0;
      }
      const error2 = new ConnectError(status.message, status.code, headerOrTrailer);
      error2.details = status.details.map((any) => ({
        type: any.typeUrl.substring(any.typeUrl.lastIndexOf("/") + 1),
        value: any.value
      }));
      return error2;
    }
    const grpcStatus = headerOrTrailer.get(headerGrpcStatus);
    if (grpcStatus != null) {
      if (grpcStatus === grpcStatusOk) {
        return void 0;
      }
      const code = parseInt(grpcStatus, 10);
      if (code in Code) {
        return new ConnectError(decodeURIComponent((_a2 = headerOrTrailer.get(headerGrpcMessage)) !== null && _a2 !== void 0 ? _a2 : ""), code, headerOrTrailer);
      }
      return new ConnectError(`invalid grpc-status: ${grpcStatus}`, Code.Internal, headerOrTrailer);
    }
    return void 0;
  }
  function createMethodUrl(baseUrl, service, method) {
    const s2 = typeof service == "string" ? service : service.typeName;
    const m2 = typeof method == "string" ? method : method.name;
    return baseUrl.toString().replace(/\/?$/, `/${s2}/${m2}`);
  }
  function normalize$1(type, message) {
    return message instanceof type ? message : new type(message);
  }
  function normalizeIterable(messageType, input) {
    function transform(result2) {
      if (result2.done === true) {
        return result2;
      }
      return {
        done: result2.done,
        value: normalize$1(messageType, result2.value)
      };
    }
    return {
      [Symbol.asyncIterator]() {
        const it = input[Symbol.asyncIterator]();
        const res = {
          next: () => it.next().then(transform)
        };
        if (it.throw !== void 0) {
          res.throw = (e) => it.throw(e).then(transform);
        }
        if (it.return !== void 0) {
          res.return = (v2) => it.return(v2).then(transform);
        }
        return res;
      }
    };
  }
  function applyInterceptors(next, interceptors) {
    var _a2;
    return (_a2 = interceptors === null || interceptors === void 0 ? void 0 : interceptors.concat().reverse().reduce(
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      (n, i2) => i2(n),
      next
    )) !== null && _a2 !== void 0 ? _a2 : next;
  }
  function getJsonOptions(options) {
    var _a2;
    const o = Object.assign({}, options);
    (_a2 = o.ignoreUnknownFields) !== null && _a2 !== void 0 ? _a2 : o.ignoreUnknownFields = true;
    return o;
  }
  function createClientMethodSerializers(method, useBinaryFormat, jsonOptions, binaryOptions) {
    const input = useBinaryFormat ? createBinarySerialization(method.I, binaryOptions) : createJsonSerialization(method.I, jsonOptions);
    const output = useBinaryFormat ? createBinarySerialization(method.O, binaryOptions) : createJsonSerialization(method.O, jsonOptions);
    return { parse: output.parse, serialize: input.serialize };
  }
  function createBinarySerialization(messageType, options) {
    return {
      parse(data) {
        try {
          return messageType.fromBinary(data, options);
        } catch (e) {
          const m2 = e instanceof Error ? e.message : String(e);
          throw new ConnectError(`parse binary: ${m2}`, Code.InvalidArgument);
        }
      },
      serialize(data) {
        try {
          return data.toBinary(options);
        } catch (e) {
          const m2 = e instanceof Error ? e.message : String(e);
          throw new ConnectError(`serialize binary: ${m2}`, Code.Internal);
        }
      }
    };
  }
  function createJsonSerialization(messageType, options) {
    var _a2, _b2;
    const textEncoder = (_a2 = options === null || options === void 0 ? void 0 : options.textEncoder) !== null && _a2 !== void 0 ? _a2 : new TextEncoder();
    const textDecoder = (_b2 = options === null || options === void 0 ? void 0 : options.textDecoder) !== null && _b2 !== void 0 ? _b2 : new TextDecoder();
    const o = getJsonOptions(options);
    return {
      parse(data) {
        try {
          const json = textDecoder.decode(data);
          return messageType.fromJsonString(json, o);
        } catch (e) {
          throw ConnectError.from(e, Code.InvalidArgument);
        }
      },
      serialize(data) {
        try {
          const json = data.toJsonString(o);
          return textEncoder.encode(json);
        } catch (e) {
          throw ConnectError.from(e, Code.Internal);
        }
      }
    };
  }
  function runUnaryCall(opt) {
    const next = applyInterceptors(opt.next, opt.interceptors);
    const [signal, abort, done] = setupSignal(opt);
    const req = Object.assign(Object.assign({}, opt.req), { message: normalize$1(opt.req.method.I, opt.req.message), signal });
    return next(req).then((res) => {
      done();
      return res;
    }, abort);
  }
  function runStreamingCall(opt) {
    const next = applyInterceptors(opt.next, opt.interceptors);
    const [signal, abort, done] = setupSignal(opt);
    const req = Object.assign(Object.assign({}, opt.req), { message: normalizeIterable(opt.req.method.I, opt.req.message), signal });
    let doneCalled = false;
    signal.addEventListener("abort", function() {
      var _a2, _b2;
      const it = opt.req.message[Symbol.asyncIterator]();
      if (!doneCalled) {
        (_a2 = it.throw) === null || _a2 === void 0 ? void 0 : _a2.call(it, this.reason).catch(() => {
        });
      }
      (_b2 = it.return) === null || _b2 === void 0 ? void 0 : _b2.call(it).catch(() => {
      });
    });
    return next(req).then((res) => {
      return Object.assign(Object.assign({}, res), { message: {
        [Symbol.asyncIterator]() {
          const it = res.message[Symbol.asyncIterator]();
          return {
            next() {
              return it.next().then((r2) => {
                if (r2.done == true) {
                  doneCalled = true;
                  done();
                }
                return r2;
              }, abort);
            }
            // We deliberately omit throw/return.
          };
        }
      } });
    }, abort);
  }
  function setupSignal(opt) {
    const { signal, cleanup } = createDeadlineSignal(opt.timeoutMs);
    const controller = createLinkedAbortController(opt.signal, signal);
    return [
      controller.signal,
      function abort(reason) {
        const e = ConnectError.from(signal.aborted ? getAbortSignalReason(signal) : reason);
        controller.abort(e);
        cleanup();
        return Promise.reject(e);
      },
      function done() {
        cleanup();
        controller.abort();
      }
    ];
  }
  function assertFetchApi() {
    try {
      new Headers();
    } catch (_) {
      throw new Error("connect-web requires the fetch API. Are you running on an old version of Node.js? Node.js is not supported in Connect for Web - please stay tuned for Connect for Node.");
    }
  }
  function validateTrailer(trailer, header) {
    const err = findTrailerError(trailer);
    if (err) {
      header.forEach((value, key) => {
        err.metadata.append(key, value);
      });
      throw err;
    }
  }
  function requestHeader(useBinaryFormat, timeoutMs, userProvidedHeaders, setUserAgent) {
    const result2 = new Headers(userProvidedHeaders !== null && userProvidedHeaders !== void 0 ? userProvidedHeaders : {});
    result2.set(headerContentType, useBinaryFormat ? contentTypeProto : contentTypeJson);
    result2.set(headerXGrpcWeb, "1");
    result2.set(headerXUserAgent, "connect-es/1.4.0");
    if (setUserAgent) {
      result2.set(headerUserAgent, "connect-es/1.4.0");
    }
    if (timeoutMs !== void 0) {
      result2.set(headerTimeout, `${timeoutMs}m`);
    }
    return result2;
  }
  function codeFromHttpStatus(httpStatus) {
    switch (httpStatus) {
      case 400:
        return Code.Internal;
      case 401:
        return Code.Unauthenticated;
      case 403:
        return Code.PermissionDenied;
      case 404:
        return Code.Unimplemented;
      case 429:
        return Code.Unavailable;
      case 502:
        return Code.Unavailable;
      case 503:
        return Code.Unavailable;
      case 504:
        return Code.Unavailable;
      default:
        return Code.Unknown;
    }
  }
  function validateResponse(status, headers) {
    var _a2;
    if (status >= 200 && status < 300) {
      const err = findTrailerError(headers);
      if (err) {
        throw err;
      }
      return { foundStatus: headers.has(headerGrpcStatus) };
    }
    throw new ConnectError(decodeURIComponent((_a2 = headers.get(headerGrpcMessage)) !== null && _a2 !== void 0 ? _a2 : `HTTP ${status}`), codeFromHttpStatus(status), headers);
  }
  var __await$1 = globalThis && globalThis.__await || function(v2) {
    return this instanceof __await$1 ? (this.v = v2, this) : new __await$1(v2);
  };
  var __asyncGenerator$1 = globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function awaitReturn(f2) {
      return function(v2) {
        return Promise.resolve(v2).then(f2, reject);
      };
    }
    function verb(n, f2) {
      if (g2[n]) {
        i2[n] = function(v2) {
          return new Promise(function(a2, b) {
            q.push([n, v2, a2, b]) > 1 || resume(n, v2);
          });
        };
        if (f2)
          i2[n] = f2(i2[n]);
      }
    }
    function resume(n, v2) {
      try {
        step(g2[n](v2));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await$1 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  function createGrpcWebTransport(options) {
    var _a2;
    assertFetchApi();
    const useBinaryFormat = (_a2 = options.useBinaryFormat) !== null && _a2 !== void 0 ? _a2 : true;
    return {
      async unary(service, method, signal, timeoutMs, header, message, contextValues) {
        var _a3;
        const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);
        timeoutMs = timeoutMs === void 0 ? options.defaultTimeoutMs : timeoutMs <= 0 ? void 0 : timeoutMs;
        return await runUnaryCall({
          interceptors: options.interceptors,
          signal,
          timeoutMs,
          req: {
            stream: false,
            service,
            method,
            url: createMethodUrl(options.baseUrl, service, method),
            init: {
              method: "POST",
              credentials: (_a3 = options.credentials) !== null && _a3 !== void 0 ? _a3 : "same-origin",
              redirect: "error",
              mode: "cors"
            },
            header: requestHeader(useBinaryFormat, timeoutMs, header, false),
            contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),
            message
          },
          next: async (req) => {
            var _a4;
            const fetch2 = (_a4 = options.fetch) !== null && _a4 !== void 0 ? _a4 : globalThis.fetch;
            const response = await fetch2(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: encodeEnvelope(0, serialize(req.message)) }));
            validateResponse(response.status, response.headers);
            if (!response.body) {
              throw "missing response body";
            }
            const reader = createEnvelopeReadableStream(response.body).getReader();
            let trailer;
            let message2;
            for (; ; ) {
              const r2 = await reader.read();
              if (r2.done) {
                break;
              }
              const { flags: flags2, data } = r2.value;
              if (flags2 === trailerFlag) {
                if (trailer !== void 0) {
                  throw "extra trailer";
                }
                trailer = trailerParse(data);
                continue;
              }
              if (message2 !== void 0) {
                throw "extra message";
              }
              message2 = parse(data);
            }
            if (trailer === void 0) {
              throw "missing trailer";
            }
            validateTrailer(trailer, response.headers);
            if (message2 === void 0) {
              throw "missing message";
            }
            return {
              stream: false,
              service,
              method,
              header: response.headers,
              message: message2,
              trailer
            };
          }
        });
      },
      async stream(service, method, signal, timeoutMs, header, input, contextValues) {
        var _a3;
        const { serialize, parse } = createClientMethodSerializers(method, useBinaryFormat, options.jsonOptions, options.binaryOptions);
        function parseResponseBody(body, foundStatus, trailerTarget, header2) {
          return __asyncGenerator$1(this, arguments, function* parseResponseBody_1() {
            const reader = createEnvelopeReadableStream(body).getReader();
            if (foundStatus) {
              if (!(yield __await$1(reader.read())).done) {
                throw "extra data for trailers-only";
              }
              return yield __await$1(void 0);
            }
            let trailerReceived = false;
            for (; ; ) {
              const result2 = yield __await$1(reader.read());
              if (result2.done) {
                break;
              }
              const { flags: flags2, data } = result2.value;
              if ((flags2 & trailerFlag) === trailerFlag) {
                if (trailerReceived) {
                  throw "extra trailer";
                }
                trailerReceived = true;
                const trailer = trailerParse(data);
                validateTrailer(trailer, header2);
                trailer.forEach((value, key) => trailerTarget.set(key, value));
                continue;
              }
              if (trailerReceived) {
                throw "extra message";
              }
              yield yield __await$1(parse(data));
              continue;
            }
            if (!trailerReceived) {
              throw "missing trailer";
            }
          });
        }
        async function createRequestBody(input2) {
          if (method.kind != MethodKind.ServerStreaming) {
            throw "The fetch API does not support streaming request bodies";
          }
          const r2 = await input2[Symbol.asyncIterator]().next();
          if (r2.done == true) {
            throw "missing request message";
          }
          return encodeEnvelope(0, serialize(r2.value));
        }
        timeoutMs = timeoutMs === void 0 ? options.defaultTimeoutMs : timeoutMs <= 0 ? void 0 : timeoutMs;
        return runStreamingCall({
          interceptors: options.interceptors,
          signal,
          timeoutMs,
          req: {
            stream: true,
            service,
            method,
            url: createMethodUrl(options.baseUrl, service, method),
            init: {
              method: "POST",
              credentials: (_a3 = options.credentials) !== null && _a3 !== void 0 ? _a3 : "same-origin",
              redirect: "error",
              mode: "cors"
            },
            header: requestHeader(useBinaryFormat, timeoutMs, header, false),
            contextValues: contextValues !== null && contextValues !== void 0 ? contextValues : createContextValues(),
            message: input
          },
          next: async (req) => {
            var _a4;
            const fetch2 = (_a4 = options.fetch) !== null && _a4 !== void 0 ? _a4 : globalThis.fetch;
            const fRes = await fetch2(req.url, Object.assign(Object.assign({}, req.init), { headers: req.header, signal: req.signal, body: await createRequestBody(req.message) }));
            const { foundStatus } = validateResponse(fRes.status, fRes.headers);
            if (!fRes.body) {
              throw "missing response body";
            }
            const trailer = new Headers();
            const res = Object.assign(Object.assign({}, req), { header: fRes.headers, trailer, message: parseResponseBody(fRes.body, foundStatus, trailer, fRes.headers) });
            return res;
          }
        });
      }
    };
  }
  const BackendErrorCode = ErrorCode;
  class BackendDomainError extends DomainError$1 {
    constructor(grpcStatus, code, short, userTitle, userDetail, requestId) {
      super(code, short, userTitle, userDetail);
      this.grpcStatus = grpcStatus;
      this.requestId = requestId;
      this.name = "BackendDomainError";
    }
  }
  class DomainError extends Message {
    constructor(data) {
      super();
      this.code = 0;
      this.userTitle = "";
      this.userDetail = "";
      this.requestId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DomainError().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DomainError().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DomainError().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DomainError, a2, b);
    }
  }
  DomainError.runtime = proto3;
  DomainError.typeName = "domain.DomainError";
  DomainError.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "code",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "user_title",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "user_detail",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class Status extends Message {
    constructor(data) {
      super();
      this.code = 0;
      this.message = "";
      this.details = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new Status().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Status().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Status().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Status, a2, b);
    }
  }
  Status.runtime = proto3;
  Status.typeName = "domain.Status";
  Status.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "code",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 2,
      name: "message",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "details", kind: "message", T: Any, repeated: true }
  ]);
  var __awaiter$1a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues$2 = globalThis && globalThis.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  };
  var __await = globalThis && globalThis.__await || function(v2) {
    return this instanceof __await ? (this.v = v2, this) : new __await(v2);
  };
  var __asyncGenerator = globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function awaitReturn(f2) {
      return function(v2) {
        return Promise.resolve(v2).then(f2, reject);
      };
    }
    function verb(n, f2) {
      if (g2[n]) {
        i2[n] = function(v2) {
          return new Promise(function(a2, b) {
            q.push([n, v2, a2, b]) > 1 || resume(n, v2);
          });
        };
        if (f2)
          i2[n] = f2(i2[n]);
      }
    }
    function resume(n, v2) {
      try {
        step(g2[n](v2));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  class EspbServiceClientFactory {
    static setDefaultTransport(createTransport2) {
      EspbServiceClientFactory.createTransport = createTransport2;
    }
    constructor(config) {
      this.config = Object.assign(Object.assign({}, config), { baseUri: config.baseUri.endsWith("/") ? config.baseUri.substring(0, config.baseUri.length - 1) : config.baseUri });
    }
    createServiceClient(service) {
      const transport = EspbServiceClientFactory.createTransport({
        baseUrl: this.config.baseUri,
        interceptors: [this.createMetadataInterceptor(), this.createLogInterceptor()],
        // Wrap fetch to handle type errors and turn them into ConnectErrors with an error code we can
        // match on down the line. See https://github.com/bufbuild/connect-es/issues/715
        fetch: fetchWithConnectErrors
      });
      return this.makeDomainErrorPromiseClient(service, transport);
    }
    makeDomainErrorPromiseClient(service, transport) {
      const baseClient = createPromiseClient(service, transport);
      return makeAnyClient(service, (method) => {
        switch (method.kind) {
          case MethodKind.Unary:
            return function(req, options) {
              return __awaiter$1a(this, void 0, void 0, function* () {
                try {
                  const message = baseClient[method.localName](req, options);
                  return yield message;
                } catch (e) {
                  domainErrorFromConnectError(e);
                }
              });
            };
          case MethodKind.ServerStreaming:
          case MethodKind.ClientStreaming:
          case MethodKind.BiDiStreaming:
            return function(req, options) {
              return __asyncGenerator(this, arguments, function* () {
                var _a2, e_1, _b2, _c2;
                const messages2 = baseClient[method.localName](req, options);
                try {
                  try {
                    for (var _d2 = true, messages_1 = __asyncValues$2(messages2), messages_1_1; messages_1_1 = yield __await(messages_1.next()), _a2 = messages_1_1.done, !_a2; _d2 = true) {
                      _c2 = messages_1_1.value;
                      _d2 = false;
                      const message = _c2;
                      yield yield __await(message);
                    }
                  } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                  } finally {
                    try {
                      if (!_d2 && !_a2 && (_b2 = messages_1.return))
                        yield __await(_b2.call(messages_1));
                    } finally {
                      if (e_1)
                        throw e_1.error;
                    }
                  }
                } catch (e) {
                  domainErrorFromConnectError(e);
                }
              });
            };
          default:
            return null;
        }
      });
    }
    createLogInterceptor() {
      return (next) => (req) => __awaiter$1a(this, void 0, void 0, function* () {
        var _a2;
        const clientOp = `${this.config.clientOperationName}/${this.config.clientOperationId}`;
        const requestId = `${Math.floor(Math.random() * 1e4)}`.padStart(5, "0");
        const methodName = `${req.service.typeName}/${req.method.name}`;
        const shortenedClientId = (_a2 = this.config.clientId) === null || _a2 === void 0 ? void 0 : _a2.split("-")[0];
        const log = (...data) => {
          if (EspbServiceClientFactory.silent) {
            return;
          }
          debugConsole.log(shortenedClientId, clientOp, requestId, methodName, ...data);
        };
        if (!req.stream) {
          log("->", req.message.toJson());
        }
        const result2 = yield next(req);
        if (result2.stream) {
          return Object.assign(Object.assign({}, result2), { message: this.wrapStreamLogger(result2.message, log) });
        } else {
          log("<-", result2.message.toJson());
          return result2;
        }
      });
    }
    wrapStreamLogger(messages2, log) {
      return __asyncGenerator(this, arguments, function* wrapStreamLogger_1() {
        var _a2, e_2, _b2, _c2;
        let firstResponseOk = false;
        try {
          for (var _d2 = true, messages_2 = __asyncValues$2(messages2), messages_2_1; messages_2_1 = yield __await(messages_2.next()), _a2 = messages_2_1.done, !_a2; _d2 = true) {
            _c2 = messages_2_1.value;
            _d2 = false;
            const message = _c2;
            if (!firstResponseOk) {
              firstResponseOk = true;
              log(`First response`);
            }
            log(`Got stream message`, message);
            yield yield __await(message);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d2 && !_a2 && (_b2 = messages_2.return))
              yield __await(_b2.call(messages_2));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    createMetadataInterceptor() {
      var _a2, _b2, _c2, _d2;
      const authHeaders = [];
      if ((_a2 = this.config.authTokens) === null || _a2 === void 0 ? void 0 : _a2.backend) {
        authHeaders.push("backend " + this.config.authTokens.backend);
      }
      if ((_b2 = this.config.authTokens) === null || _b2 === void 0 ? void 0 : _b2.auditlogWrite) {
        authHeaders.push("auditlog-write " + this.config.authTokens.auditlogWrite);
      }
      if ((_c2 = this.config.authTokens) === null || _c2 === void 0 ? void 0 : _c2.auditlogAdmin) {
        authHeaders.push("auditlog-admin " + this.config.authTokens.auditlogAdmin);
      }
      if ((_d2 = this.config.authTokens) === null || _d2 === void 0 ? void 0 : _d2.lfdOverridesAdmin) {
        authHeaders.push("lfd-overrides-admin " + this.config.authTokens.lfdOverridesAdmin);
      }
      const metadataInterceptor = (next) => (req) => __awaiter$1a(this, void 0, void 0, function* () {
        const metadata = req.header;
        metadata.set("authorization", authHeaders.join(","));
        if (this.config.clientId) {
          metadata.set("client-id", this.config.clientId);
        }
        if (this.config.clientType) {
          metadata.set("client-type", `${this.config.clientType}`);
        }
        if (this.config.clientVersion) {
          metadata.set("client-version", this.config.clientVersion);
        }
        if (this.config.syncVersion !== null) {
          metadata.set("sync-version", `${this.config.syncVersion}`);
        }
        if (this.config.permissionUserId) {
          metadata.set("permission-user-id", this.config.permissionUserId);
        }
        if (this.config.syncSuperUsers) {
          metadata.set("sync-superusers", "ok");
        }
        if (this.config.clientOperationId) {
          metadata.set("client-operation-id", this.config.clientOperationId);
        }
        if (this.config.clientOperationName) {
          metadata.set("client-operation-name", this.config.clientOperationName);
        }
        return next(req);
      });
      return metadataInterceptor;
    }
  }
  EspbServiceClientFactory.silent = true;
  EspbServiceClientFactory.createTransport = createGrpcWebTransport;
  function domainErrorFromConnectError(reason) {
    const error2 = ConnectError.from(reason);
    addBreadcrumb$1({
      type: "info",
      category: "connectError",
      data: {
        reason,
        error: error2
      }
    });
    if (error2.code === Code.Canceled) {
      throw new Cancel();
    }
    const domainErrorDetails = error2.findDetails(DomainError);
    if (domainErrorDetails.length > 0) {
      const espbDomainError = domainErrorDetails[0];
      throw new BackendDomainError(error2.code, espbDomainError.code, error2.message, espbDomainError.userTitle, espbDomainError.userDetail, espbDomainError.requestId);
    }
    if (error2.code === Code.Unavailable) {
      throw new NoResponseError();
    }
    if (error2.code === Code.Unknown || error2.code === Code.Internal) {
      switch (error2.rawMessage) {
        case "network error":
          throw new NoResponseError();
        case "missing trailer":
          throw new NoResponseError();
      }
      if (
        // e.g. read ECONNABORTED
        error2.rawMessage.includes("ECONNABORTED") || // e.g. connect ECONNABORTED 111.111.111.111:443
        error2.rawMessage.includes("ECONNRESET") || // e.g. connect EHOSTUNREACH 111.111.111.111:443
        error2.rawMessage.includes("EHOSTUNREACH")
      ) {
        throw new NoResponseError();
      }
    }
    if (error2.code === Code.InvalidArgument) {
      if (error2.rawMessage.startsWith("parse binary")) {
        throw new NoResponseError();
      }
      if (error2.rawMessage.startsWith("unexpected response content type")) {
        throw new NoResponseError();
      }
    }
    throw new BackendDomainError(error2.code, ErrorCode.UNDEFINED, error2.message, "An unexpected error occurred", `An unexpected error occurred while communicating with the server: ${error2.message}. We are investigating. Please make sure you are using the latest version of our software and try again.`, "no-request-id");
  }
  function fetchWithConnectErrors(...args) {
    return __awaiter$1a(this, void 0, void 0, function* () {
      let response;
      try {
        response = yield fetch(...args);
      } catch (e) {
        if (e instanceof TypeError) {
          throw new ConnectError("Fetch error", Code.Unavailable, void 0, void 0, e);
        }
        throw e;
      }
      if (!response.body) {
        return response;
      }
      const reader = response.body.getReader();
      const wrappedStream = new ReadableStream({
        start(controller) {
          function push() {
            return __awaiter$1a(this, void 0, void 0, function* () {
              try {
                while (true) {
                  const { done, value } = yield reader.read();
                  if (done) {
                    controller.close();
                    return;
                  }
                  controller.enqueue(value);
                }
              } catch (e) {
                if (e instanceof TypeError) {
                  controller.error(new ConnectError("Fetch error", Code.Unavailable, void 0, void 0, e));
                }
                controller.error(e);
              } finally {
                reader.releaseLock();
              }
            });
          }
          push().catch(trackError);
        }
      });
      const wrappedResponse = new Response(wrappedStream, {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers
      });
      return wrappedResponse;
    });
  }
  var __awaiter$19 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class AuditlogAdminClient {
    constructor(baseUri, authToken, clientType, clientId = null, clientVersion = null) {
      this.baseUri = baseUri;
      this.authToken = authToken;
      this.clientType = clientType;
      this.clientId = clientId;
      this.clientVersion = clientVersion;
      const factory = new EspbServiceClientFactory({
        authTokens: {
          auditlogAdmin: authToken
        },
        clientId,
        clientType,
        clientVersion,
        baseUri,
        clientOperationId: null,
        clientOperationName: null,
        syncVersion: null,
        syncSuperUsers: false,
        permissionUserId: null
      });
      this.espbClient = factory.createServiceClient(AuditlogService);
    }
    listEvents(page, filter2, timeAnchor, cancelToken) {
      return __awaiter$19(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.listEvents({
          page,
          timeAnchor: timeAnchor ? Timestamp.fromDate(timeAnchor) : void 0,
          fromTime: filter2.fromTime ? Timestamp.fromDate(filter2.fromTime) : void 0,
          toTime: filter2.toTime ? Timestamp.fromDate(filter2.toTime) : void 0,
          eventTypes: filter2.eventTypes,
          filterLoginIds: filter2.loginIds,
          filterProfileIds: filter2.profileIds,
          filterTargetProfileIds: filter2.targetProfileIds,
          filterVaultIds: filter2.vaultIds,
          filterIpPrefix: filter2.ipPrefix,
          additionalFilter: filter2.additionalFilter ? Object.assign(Object.assign({}, filter2.additionalFilter), { filterIpPrefix: filter2.additionalFilter.ipPrefix }) : void 0
        }, { signal: cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.signal });
        const events = resp.envelopedEventJson;
        const totalCount = Number(resp.totalCount);
        const respTimeAnchor = requireFieldNotEmpty(resp.timeAnchor).toDate();
        return { totalCount, events, timeAnchor: respTimeAnchor };
      });
    }
  }
  var __awaiter$18 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class AuditlogWriteClient {
    constructor(baseUri, authToken, clientType, clientId = null, clientVersion = null) {
      this.baseUri = baseUri;
      this.authToken = authToken;
      this.clientType = clientType;
      this.clientId = clientId;
      this.clientVersion = clientVersion;
      const factory = new EspbServiceClientFactory({
        authTokens: {
          auditlogWrite: authToken
        },
        clientId,
        clientType,
        clientVersion,
        baseUri,
        clientOperationId: null,
        clientOperationName: null,
        syncVersion: null,
        syncSuperUsers: false,
        permissionUserId: null
      });
      this.espbClient = factory.createServiceClient(AuditlogService);
    }
    writeEvents(eventData) {
      return __awaiter$18(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.writeEvents({
          events: eventData.map(({ clientTime, lastKnownServerTime, event }) => ({
            eventJson: JSON.stringify(event),
            lastKnownServerTime: Timestamp.fromDate(lastKnownServerTime),
            clientTime: Timestamp.fromDate(clientTime)
          }))
        });
        return requireFieldNotEmpty(resp.eventIds);
      });
    }
  }
  var __awaiter$17 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class AuthenticatorServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    modify(createAuthenticatorOps, deleteAuthenticatorIds, authenticatorBlock, regeneratedProfileDtos = []) {
      return __awaiter$17(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.modify({
          createAuthenticatorOps,
          authenticatorBlock: authenticatorBlock.blob,
          authenticatorBlockSignature: authenticatorBlock.signature,
          deleteAuthenticatorIds,
          profiles: regeneratedProfileDtos.map(toPbProfileRegenerateData)
        });
        return {
          authenticatorIds: resp.authenticatorIds,
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate))
        };
      });
    }
    setDeviceToken(fcmDeviceToken) {
      return __awaiter$17(this, void 0, void 0, function* () {
        yield this.espbClient.setDeviceToken({ fcmDeviceToken });
      });
    }
    list(latestAuthenticatorBlockHash) {
      return __awaiter$17(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.list({
          latestAuthenticatorBlockHash
        });
        const authenticators = resp.authenticators.map((a2) => {
          const data = requireFieldNotEmpty(a2.data);
          return {
            id: requireFieldNotEmpty(a2.id),
            authenticatorType: knownEnumOrDefault(data.authenticatorType, AuthenticatorType),
            storableVaultKeyEncPubKey: requireFieldNotEmpty(data.storableVaultKeyEncPubKey),
            storableVaultKeyEncPubKeySignature: requireFieldNotEmpty(data.storableVaultKeyEncPubKeySignature),
            highSecurityVaultKeyEncPubKey: requireFieldNotEmpty(data.highSecurityVaultKeyEncPubKey),
            highSecurityVaultKeyEncPubKeySignature: requireFieldNotEmpty(data.highSecurityVaultKeyEncPubKeySignature),
            highSecurityIdentitySigPubKey: requireFieldNotEmpty(data.highSecurityIdentitySigPubKey),
            highSecurityLoginSigPubKey: requireFieldNotEmpty(data.highSecurityLoginSigPubKey),
            secretInfo: data.secretInfo,
            secretSalt: data.secretSalt,
            storableSigPubKey: requireFieldNotEmpty(data.storableSigPubKey),
            storableSigPubKeySignature: requireFieldNotEmpty(data.storableSigPubKeySignature),
            webauthn: data.webauthn ? {
              webauthnId: requireFieldNotEmpty(data.webauthn.webauthnId),
              prfSalt: requireFieldNotEmpty(data.webauthn.prfSalt)
            } : void 0
          };
        });
        const blocks = resp.authenticatorBlocks.map((as) => ({
          blob: requireFieldNotEmpty(as.blob),
          signature: requireFieldNotEmpty(as.signature)
        }));
        return {
          blocks,
          authenticators
        };
      });
    }
    createInitialAuthenticatorBlock(blockDto) {
      return __awaiter$17(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createInitialAuthenticatorBlock({
          authenticatorBlock: blockDto
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
  }
  class LoginClientPubKeyBody extends Message {
    constructor(data) {
      super();
      this.clientPubKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginClientPubKeyBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginClientPubKeyBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginClientPubKeyBody().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LoginClientPubKeyBody, a2, b);
    }
  }
  LoginClientPubKeyBody.runtime = proto3;
  LoginClientPubKeyBody.typeName = "domain.LoginClientPubKeyBody";
  LoginClientPubKeyBody.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "client_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class LoginAuthenticatorPubKeyBody extends Message {
    constructor(data) {
      super();
      this.authenticatorPubKey = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginAuthenticatorPubKeyBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginAuthenticatorPubKeyBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginAuthenticatorPubKeyBody().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LoginAuthenticatorPubKeyBody, a2, b);
    }
  }
  LoginAuthenticatorPubKeyBody.runtime = proto3;
  LoginAuthenticatorPubKeyBody.typeName = "domain.LoginAuthenticatorPubKeyBody";
  LoginAuthenticatorPubKeyBody.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "authenticator_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class LoginHashCommitmentBody extends Message {
    constructor(data) {
      super();
      this.hashCommitment = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginHashCommitmentBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginHashCommitmentBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginHashCommitmentBody().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LoginHashCommitmentBody, a2, b);
    }
  }
  LoginHashCommitmentBody.runtime = proto3;
  LoginHashCommitmentBody.typeName = "domain.LoginHashCommitmentBody";
  LoginHashCommitmentBody.fields = proto3.util.newFieldList(() => [
    {
      no: 3,
      name: "hash_commitment",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class LoginEncryptedSecretBody extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LoginEncryptedSecretBody().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LoginEncryptedSecretBody().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LoginEncryptedSecretBody().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LoginEncryptedSecretBody, a2, b);
    }
  }
  LoginEncryptedSecretBody.runtime = proto3;
  LoginEncryptedSecretBody.typeName = "domain.LoginEncryptedSecretBody";
  LoginEncryptedSecretBody.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  var __awaiter$16 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class ChannelServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    create(userId, data, type, exposed) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.create({
          userId,
          data,
          channelType: type,
          exposed
        });
        return requireFieldNotEmpty(resp.channelId);
      });
    }
    claim(deserialize, channelId, authenticatorId, data) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.claim({ channelId, authenticatorId, data });
        try {
          return deserialize(resp.data);
        } catch (e) {
          throw new InvalidChannelMessageError();
        }
      });
    }
    read(deserialize, channelId, recipient, cancelToken) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.read({ channelId, recipient }, { signal: cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.signal });
        try {
          return deserialize(resp.data);
        } catch (e) {
          throw new InvalidChannelMessageError();
        }
      });
    }
    write(channelId, recipient, data) {
      return __awaiter$16(this, void 0, void 0, function* () {
        yield this.espbClient.write({ channelId, data, recipient });
      });
    }
    delete(channelId) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.delete({ channelId });
        const respSyncUpdate = resp.syncUpdate;
        if (respSyncUpdate) {
          const syncUpdate = toSyncDto(respSyncUpdate);
          return { syncUpdate };
        }
        return {};
      });
    }
    loginChannelInitialize(userId, hashCommitment) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const message = new LoginHashCommitmentBody({ hashCommitment });
        return this.create(userId, message.toBinary(), "login", true);
      });
    }
    loginChannelClose(channelId) {
      return __awaiter$16(this, void 0, void 0, function* () {
        return this.delete(channelId).then((resp) => resp.syncUpdate);
      });
    }
    loginChannelSendClientPubKey(pushChannelId, clientPubKey) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const message = new LoginClientPubKeyBody({ clientPubKey });
        yield this.write(pushChannelId, ChannelRecipient.AUTHENTICATOR, message.toBinary());
      });
    }
    loginChannelReceiveAuthenticatorPubKey(pushChannelId, cancelToken) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const message = yield this.read(LoginAuthenticatorPubKeyBody.fromBinary, pushChannelId, ChannelRecipient.CLIENT, cancelToken);
        return requireFieldNotEmpty(message.authenticatorPubKey);
      });
    }
    loginChannelReceiveEncryptedSecret(pushChannelId, cancelToken) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const message = yield this.read(LoginEncryptedSecretBody.fromBinary, pushChannelId, ChannelRecipient.CLIENT, cancelToken);
        return {
          authenticatorId: requireFieldNotEmpty(message.authenticatorId),
          encryptedSecret: requireFieldNotEmpty(message.encryptedSecret)
        };
      });
    }
    loginChannelSendEncryptedSecret(pushChannelId, encryptedSecret, authenticatorId) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const message = new LoginEncryptedSecretBody({ encryptedSecret, authenticatorId });
        yield this.write(pushChannelId, ChannelRecipient.CLIENT, message.toBinary());
      });
    }
    loginChannelClaimAndReceiveHashCommitment(pushChannelId, authenticatorId, authenticatorPubKey) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const authPubKeyMessage = new LoginAuthenticatorPubKeyBody({ authenticatorPubKey });
        const hashCommitmentMessage = yield this.claim(LoginHashCommitmentBody.fromBinary, pushChannelId, authenticatorId, authPubKeyMessage.toBinary());
        return requireFieldNotEmpty(hashCommitmentMessage.hashCommitment);
      });
    }
    loginChannelReceiveClientPubKey(pushChannelId) {
      return __awaiter$16(this, void 0, void 0, function* () {
        const message = yield this.read(LoginClientPubKeyBody.fromBinary, pushChannelId, ChannelRecipient.AUTHENTICATOR);
        return requireFieldNotEmpty(message.clientPubKey);
      });
    }
    loginChannelWaitUntilClosed(pushChannelId) {
      return __awaiter$16(this, void 0, void 0, function* () {
        try {
          yield this.read((b) => new Message().fromBinary(b), pushChannelId, ChannelRecipient.AUTHENTICATOR);
        } catch (e) {
        }
      });
    }
  }
  var __awaiter$15 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class ChildOrganizationServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    list(parentOrganizationId) {
      return __awaiter$15(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.list({ parentOrganizationId });
        return resp.childOrganizations.map((co) => ({
          id: requireFieldNotEmpty(co.id),
          name: requireFieldNotEmpty(co.name),
          licenseCount: co.licenseCount,
          users: co.users.map((u2) => {
            var _a2;
            return {
              isAdmin: u2.isAdmin,
              isNotConnected: u2.isNotConnected,
              hasStartCode: u2.hasStartCode,
              lastActiveAt: (_a2 = u2.lastActiveAt) === null || _a2 === void 0 ? void 0 : _a2.toDate()
            };
          }),
          managers: co.managers,
          createdAt: requireFieldNotEmpty(co.createdAt).toDate(),
          parentOrganizationMetadata: co.parentOrganizationMetadata || void 0
        }));
      });
    }
    addManager(childOrganizationId, parentOrganizationProfileId, { profile, personalVaultData, legacyAdminVaultLock, adminProfileLock }) {
      return __awaiter$15(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.addManager({
          adminProfileLock,
          legacyAdminVaultLock: legacyAdminVaultLock ? toPbVaultLock(legacyAdminVaultLock) : void 0,
          childOrganizationId,
          profile,
          personalVaultData: toPbVaultCreationData(personalVaultData),
          parentOrganizationProfileId
        });
        return {
          profileId: requireFieldNotEmpty(resp.profileId),
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate))
        };
      });
    }
    update(childOrganizationId, { parentOrganizationMetadata }) {
      return __awaiter$15(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.update({
          childOrganizationId,
          parentOrganizationMetadata: parentOrganizationMetadata === null ? "" : parentOrganizationMetadata
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
  }
  var __awaiter$14 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class CredentialServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    createChallenge(email, backupAuthenticatorId, userId) {
      return __awaiter$14(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createChallenge({
          email: email !== null && email !== void 0 ? email : void 0,
          userId: userId !== null && userId !== void 0 ? userId : void 0,
          backupAuthenticatorId: backupAuthenticatorId !== null && backupAuthenticatorId !== void 0 ? backupAuthenticatorId : void 0
        });
        return {
          userId: requireFieldNotEmpty(resp.userId),
          challenge: requireFieldNotEmpty(resp.challenge),
          authenticators: resp.authenticators.map((a2) => ({
            id: requireFieldNotEmpty(a2.id),
            authenticatorType: knownEnumOrDefault(a2.authenticatorType, AuthenticatorType),
            secretInfo: a2.secretInfo,
            webauthn: a2.webauthn ? {
              webauthnId: requireFieldNotEmpty(a2.webauthn.webauthnId),
              prfSalt: requireFieldNotEmpty(a2.webauthn.prfSalt)
            } : void 0
          }))
        };
      });
    }
    createLongPollChannelChallenge(publicKeyHash, cancelToken) {
      return __awaiter$14(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createLongPollChannelChallenge({ publicKeyHash }, { signal: cancelToken.signal });
        const auth = requireFieldNotEmpty(resp.authenticator);
        return {
          userId: requireFieldNotEmpty(resp.userId),
          challenge: requireFieldNotEmpty(resp.challenge),
          authenticator: {
            id: auth.id,
            authenticatorType: knownEnumOrDefault(auth.authenticatorType, AuthenticatorType),
            secretInfo: auth.secretInfo
          },
          authenticatorReply: requireFieldNotEmpty(resp.authenticatorReply)
        };
      });
    }
    completeLongPollChannel(publicKeyHash, authenticatorId, authenticatorReply) {
      return __awaiter$14(this, void 0, void 0, function* () {
        yield this.espbClient.completeLongPollChannel({
          publicKeyHash,
          authenticatorId,
          authenticatorReply
        });
      });
    }
    createTokens(userId, authenticatorId, challenge, responseData, sessionUnlock, sessionType) {
      return __awaiter$14(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createTokens({
          authenticatorId,
          challenge,
          response: responseData,
          sessionType,
          sessionUnlock: sessionUnlock ? Object.assign(Object.assign({}, sessionUnlock), { expiresAt: Timestamp.fromDate(sessionUnlock.expiresAt) }) : void 0
        });
        const token = requireFieldNotEmpty(resp.accessToken);
        const syncUpdate = toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
        const loginData = {
          userId,
          sessionId: requireFieldNotEmpty(resp.sessionId),
          token: requireFieldNotEmpty(token.token)
        };
        return { loginData, syncUpdate };
      });
    }
    createAuditlogWriteToken(organizationId) {
      return __awaiter$14(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createAuditlogWriteToken({ organizationId });
        const token = requireFieldNotEmpty(resp.token);
        return {
          token: requireFieldNotEmpty(token.token),
          expiresAt: requireFieldNotEmpty(token.expiresAt).toDate()
        };
      });
    }
    createAuditlogAdminToken(organizationId, cancelToken) {
      return __awaiter$14(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createAuditlogAdminToken({ organizationId }, { signal: cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.signal });
        const token = requireFieldNotEmpty(resp.token);
        return {
          token: requireFieldNotEmpty(token.token),
          expiresAt: requireFieldNotEmpty(token.expiresAt).toDate()
        };
      });
    }
    createLFDOverridesAdminToken() {
      return __awaiter$14(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createLFDOverridesAdminToken({});
        const token = requireFieldNotEmpty(resp.token);
        return {
          token: requireFieldNotEmpty(token.token),
          expiresAt: requireFieldNotEmpty(token.expiresAt).toDate()
        };
      });
    }
    refreshToken() {
      return __awaiter$14(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.refreshToken({});
        const token = requireFieldNotEmpty(resp.newAccessToken);
        return token.token;
      });
    }
  }
  class Token extends Message {
    constructor(data) {
      super();
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new Token().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new Token().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new Token().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(Token, a2, b);
    }
  }
  Token.runtime = proto3;
  Token.typeName = "domain.Token";
  Token.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "expires_at", kind: "message", T: Timestamp }
  ]);
  class CreateChallengeRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.backupAuthenticatorId = "";
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateChallengeRequest, a2, b);
    }
  }
  CreateChallengeRequest.runtime = proto3;
  CreateChallengeRequest.typeName = "domain.CreateChallengeRequest";
  CreateChallengeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "backup_authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateChallengeResponse extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.challenge = "";
      this.authenticators = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateChallengeResponse, a2, b);
    }
  }
  CreateChallengeResponse.runtime = proto3;
  CreateChallengeResponse.typeName = "domain.CreateChallengeResponse";
  CreateChallengeResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "challenge",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticators", kind: "message", T: CreateChallengeResponse_Authenticator, repeated: true }
  ]);
  class CreateChallengeResponse_Authenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.secretInfo = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeResponse_Authenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeResponse_Authenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeResponse_Authenticator().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateChallengeResponse_Authenticator, a2, b);
    }
  }
  CreateChallengeResponse_Authenticator.runtime = proto3;
  CreateChallengeResponse_Authenticator.typeName = "domain.CreateChallengeResponse.Authenticator";
  CreateChallengeResponse_Authenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 3,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "webauthn", kind: "message", T: CreateChallengeResponse_Authenticator_Webauthn }
  ]);
  class CreateChallengeResponse_Authenticator_Webauthn extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      this.prfSalt = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateChallengeResponse_Authenticator_Webauthn().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateChallengeResponse_Authenticator_Webauthn().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateChallengeResponse_Authenticator_Webauthn().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateChallengeResponse_Authenticator_Webauthn, a2, b);
    }
  }
  CreateChallengeResponse_Authenticator_Webauthn.runtime = proto3;
  CreateChallengeResponse_Authenticator_Webauthn.typeName = "domain.CreateChallengeResponse.Authenticator.Webauthn";
  CreateChallengeResponse_Authenticator_Webauthn.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "prf_salt",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateLongPollChannelChallengeRequest extends Message {
    constructor(data) {
      super();
      this.publicKeyHash = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLongPollChannelChallengeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLongPollChannelChallengeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLongPollChannelChallengeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateLongPollChannelChallengeRequest, a2, b);
    }
  }
  CreateLongPollChannelChallengeRequest.runtime = proto3;
  CreateLongPollChannelChallengeRequest.typeName = "domain.CreateLongPollChannelChallengeRequest";
  CreateLongPollChannelChallengeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "public_key_hash",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateLongPollChannelChallengeResponse extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.challenge = "";
      this.authenticatorReply = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLongPollChannelChallengeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLongPollChannelChallengeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLongPollChannelChallengeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateLongPollChannelChallengeResponse, a2, b);
    }
  }
  CreateLongPollChannelChallengeResponse.runtime = proto3;
  CreateLongPollChannelChallengeResponse.typeName = "domain.CreateLongPollChannelChallengeResponse";
  CreateLongPollChannelChallengeResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "challenge",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticator", kind: "message", T: CreateLongPollChannelChallengeResponse_Authenticator },
    {
      no: 4,
      name: "authenticator_reply",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateLongPollChannelChallengeResponse_Authenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorType = AuthenticatorType.UNKNOWN;
      this.secretInfo = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLongPollChannelChallengeResponse_Authenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLongPollChannelChallengeResponse_Authenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLongPollChannelChallengeResponse_Authenticator().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateLongPollChannelChallengeResponse_Authenticator, a2, b);
    }
  }
  CreateLongPollChannelChallengeResponse_Authenticator.runtime = proto3;
  CreateLongPollChannelChallengeResponse_Authenticator.typeName = "domain.CreateLongPollChannelChallengeResponse.Authenticator";
  CreateLongPollChannelChallengeResponse_Authenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "authenticator_type", kind: "enum", T: proto3.getEnumType(AuthenticatorType) },
    {
      no: 3,
      name: "secret_info",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CompleteLongPollChannelRequest extends Message {
    constructor(data) {
      super();
      this.publicKeyHash = "";
      this.authenticatorId = "";
      this.authenticatorReply = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CompleteLongPollChannelRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CompleteLongPollChannelRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CompleteLongPollChannelRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CompleteLongPollChannelRequest, a2, b);
    }
  }
  CompleteLongPollChannelRequest.runtime = proto3;
  CompleteLongPollChannelRequest.typeName = "domain.CompleteLongPollChannelRequest";
  CompleteLongPollChannelRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "public_key_hash",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "authenticator_reply",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CompleteLongPollChannelResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CompleteLongPollChannelResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CompleteLongPollChannelResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CompleteLongPollChannelResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CompleteLongPollChannelResponse, a2, b);
    }
  }
  CompleteLongPollChannelResponse.runtime = proto3;
  CompleteLongPollChannelResponse.typeName = "domain.CompleteLongPollChannelResponse";
  CompleteLongPollChannelResponse.fields = proto3.util.newFieldList(() => []);
  class CreateTokensRequest extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      this.challenge = "";
      this.response = new Uint8Array(0);
      this.sessionType = SessionType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTokensRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTokensRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTokensRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateTokensRequest, a2, b);
    }
  }
  CreateTokensRequest.runtime = proto3;
  CreateTokensRequest.typeName = "domain.CreateTokensRequest";
  CreateTokensRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "challenge",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "response",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 5, name: "session_unlock", kind: "message", T: CreateTokensRequest_SessionUnlock },
    { no: 6, name: "session_type", kind: "enum", T: proto3.getEnumType(SessionType) }
  ]);
  class CreateTokensRequest_SessionUnlock extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.singleUse = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTokensRequest_SessionUnlock().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTokensRequest_SessionUnlock().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTokensRequest_SessionUnlock().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateTokensRequest_SessionUnlock, a2, b);
    }
  }
  CreateTokensRequest_SessionUnlock.runtime = proto3;
  CreateTokensRequest_SessionUnlock.typeName = "domain.CreateTokensRequest.SessionUnlock";
  CreateTokensRequest_SessionUnlock.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 3, name: "expires_at", kind: "message", T: Timestamp },
    {
      no: 5,
      name: "single_use",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class CreateTokensResponse extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateTokensResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateTokensResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateTokensResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateTokensResponse, a2, b);
    }
  }
  CreateTokensResponse.runtime = proto3;
  CreateTokensResponse.typeName = "domain.CreateTokensResponse";
  CreateTokensResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "access_token", kind: "message", T: Token },
    {
      no: 2,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateAuditlogWriteTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogWriteTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogWriteTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogWriteTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAuditlogWriteTokenRequest, a2, b);
    }
  }
  CreateAuditlogWriteTokenRequest.runtime = proto3;
  CreateAuditlogWriteTokenRequest.typeName = "domain.CreateAuditlogWriteTokenRequest";
  CreateAuditlogWriteTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateAuditlogWriteTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogWriteTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogWriteTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogWriteTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAuditlogWriteTokenResponse, a2, b);
    }
  }
  CreateAuditlogWriteTokenResponse.runtime = proto3;
  CreateAuditlogWriteTokenResponse.typeName = "domain.CreateAuditlogWriteTokenResponse";
  CreateAuditlogWriteTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "message", T: Token }
  ]);
  class CreateAuditlogAdminTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogAdminTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogAdminTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogAdminTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAuditlogAdminTokenRequest, a2, b);
    }
  }
  CreateAuditlogAdminTokenRequest.runtime = proto3;
  CreateAuditlogAdminTokenRequest.typeName = "domain.CreateAuditlogAdminTokenRequest";
  CreateAuditlogAdminTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateAuditlogAdminTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAuditlogAdminTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAuditlogAdminTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAuditlogAdminTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAuditlogAdminTokenResponse, a2, b);
    }
  }
  CreateAuditlogAdminTokenResponse.runtime = proto3;
  CreateAuditlogAdminTokenResponse.typeName = "domain.CreateAuditlogAdminTokenResponse";
  CreateAuditlogAdminTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "message", T: Token }
  ]);
  class CreateLFDOverridesAdminTokenRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLFDOverridesAdminTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLFDOverridesAdminTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLFDOverridesAdminTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateLFDOverridesAdminTokenRequest, a2, b);
    }
  }
  CreateLFDOverridesAdminTokenRequest.runtime = proto3;
  CreateLFDOverridesAdminTokenRequest.typeName = "domain.CreateLFDOverridesAdminTokenRequest";
  CreateLFDOverridesAdminTokenRequest.fields = proto3.util.newFieldList(() => []);
  class CreateLFDOverridesAdminTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLFDOverridesAdminTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLFDOverridesAdminTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLFDOverridesAdminTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateLFDOverridesAdminTokenResponse, a2, b);
    }
  }
  CreateLFDOverridesAdminTokenResponse.runtime = proto3;
  CreateLFDOverridesAdminTokenResponse.typeName = "domain.CreateLFDOverridesAdminTokenResponse";
  CreateLFDOverridesAdminTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "message", T: Token }
  ]);
  class RefreshTokenRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RefreshTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RefreshTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RefreshTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RefreshTokenRequest, a2, b);
    }
  }
  RefreshTokenRequest.runtime = proto3;
  RefreshTokenRequest.typeName = "domain.RefreshTokenRequest";
  RefreshTokenRequest.fields = proto3.util.newFieldList(() => []);
  class RefreshTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RefreshTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RefreshTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RefreshTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RefreshTokenResponse, a2, b);
    }
  }
  RefreshTokenResponse.runtime = proto3;
  RefreshTokenResponse.typeName = "domain.RefreshTokenResponse";
  RefreshTokenResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "new_access_token", kind: "message", T: Token }
  ]);
  class GetRegistrationInfoRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetRegistrationInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetRegistrationInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetRegistrationInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetRegistrationInfoRequest, a2, b);
    }
  }
  GetRegistrationInfoRequest.runtime = proto3;
  GetRegistrationInfoRequest.typeName = "domain.GetRegistrationInfoRequest";
  GetRegistrationInfoRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetRegistrationInfoResponse extends Message {
    constructor(data) {
      super();
      this.status = RegistrationInfoStatus.UNKNOWN;
      this.webauthnAllowed = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetRegistrationInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetRegistrationInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetRegistrationInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetRegistrationInfoResponse, a2, b);
    }
  }
  GetRegistrationInfoResponse.runtime = proto3;
  GetRegistrationInfoResponse.typeName = "domain.GetRegistrationInfoResponse";
  GetRegistrationInfoResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(RegistrationInfoStatus) },
    { no: 2, name: "organization", kind: "message", T: GetRegistrationInfoResponse_Organization },
    {
      no: 3,
      name: "webauthn_allowed",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class GetRegistrationInfoResponse_Organization extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.icon = "";
      this.id = "";
      this.profileId = "";
      this.startCodePrefix = "";
      this.organizationType = OrganizationType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetRegistrationInfoResponse_Organization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetRegistrationInfoResponse_Organization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetRegistrationInfoResponse_Organization().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetRegistrationInfoResponse_Organization, a2, b);
    }
  }
  GetRegistrationInfoResponse_Organization.runtime = proto3;
  GetRegistrationInfoResponse_Organization.typeName = "domain.GetRegistrationInfoResponse.Organization";
  GetRegistrationInfoResponse_Organization.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "start_code_prefix",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "organization_type", kind: "enum", T: proto3.getEnumType(OrganizationType) }
  ]);
  class CreateAccountWithProfileRequest extends Message {
    constructor(data) {
      super();
      this.authenticators = [];
      this.referrerId = "";
      this.authenticatorBlock = new Uint8Array(0);
      this.authenticatorBlockSignature = new Uint8Array(0);
      this.preliminaryEmail = "";
      this.startCode = "";
      this.startCodeProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAccountWithProfileRequest, a2, b);
    }
  }
  CreateAccountWithProfileRequest.runtime = proto3;
  CreateAccountWithProfileRequest.typeName = "domain.CreateAccountWithProfileRequest";
  CreateAccountWithProfileRequest.fields = proto3.util.newFieldList(() => [
    { no: 14, name: "authenticators", kind: "message", T: AuthenticatorCreationData, repeated: true },
    { no: 2, name: "preferences_profile", kind: "message", T: ProfileData },
    { no: 3, name: "inbox_profile", kind: "message", T: ProfileData },
    { no: 4, name: "meta_vault", kind: "message", T: VaultCreationData },
    {
      no: 5,
      name: "referrer_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "authenticator_block",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "authenticator_block_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 10,
      name: "preliminary_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 13,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 15, name: "session_unlock_data", kind: "message", T: CreateAccountWithProfileRequest_SessionUnlockData },
    { no: 16, name: "webauthn_credential_data", kind: "message", T: CreateAccountWithProfileRequest_WebauthnCredentialData },
    {
      no: 17,
      name: "start_code_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateAccountWithProfileRequest_WebauthnCredentialData extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.responseJson = "";
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileRequest_WebauthnCredentialData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileRequest_WebauthnCredentialData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileRequest_WebauthnCredentialData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAccountWithProfileRequest_WebauthnCredentialData, a2, b);
    }
  }
  CreateAccountWithProfileRequest_WebauthnCredentialData.runtime = proto3;
  CreateAccountWithProfileRequest_WebauthnCredentialData.typeName = "domain.CreateAccountWithProfileRequest.WebauthnCredentialData";
  CreateAccountWithProfileRequest_WebauthnCredentialData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) }
  ]);
  class CreateAccountWithProfileRequest_SessionUnlockData extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileRequest_SessionUnlockData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileRequest_SessionUnlockData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileRequest_SessionUnlockData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAccountWithProfileRequest_SessionUnlockData, a2, b);
    }
  }
  CreateAccountWithProfileRequest_SessionUnlockData.runtime = proto3;
  CreateAccountWithProfileRequest_SessionUnlockData.typeName = "domain.CreateAccountWithProfileRequest.SessionUnlockData";
  CreateAccountWithProfileRequest_SessionUnlockData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 2, name: "unlock_max_expires_at", kind: "message", T: Timestamp }
  ]);
  class CreateAccountWithProfileResponse extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.sessionId = "";
      this.authenticatorIds = [];
      this.preferencesProfileId = "";
      this.metaVaultId = "";
      this.inboxProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateAccountWithProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateAccountWithProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateAccountWithProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateAccountWithProfileResponse, a2, b);
    }
  }
  CreateAccountWithProfileResponse.runtime = proto3;
  CreateAccountWithProfileResponse.typeName = "domain.CreateAccountWithProfileResponse";
  CreateAccountWithProfileResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "access_token", kind: "message", T: Token },
    {
      no: 3,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "authenticator_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 5,
      name: "preferences_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "meta_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "inbox_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UpdateAccountRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateAccountRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateAccountRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateAccountRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateAccountRequest, a2, b);
    }
  }
  UpdateAccountRequest.runtime = proto3;
  UpdateAccountRequest.typeName = "domain.UpdateAccountRequest";
  UpdateAccountRequest.fields = proto3.util.newFieldList(() => [
    { no: 2, name: "preferred_locale", kind: "message", T: StringValue },
    { no: 3, name: "user_client_settings", kind: "message", T: StringValue }
  ]);
  class UpdateAccountResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateAccountResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateAccountResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateAccountResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateAccountResponse, a2, b);
    }
  }
  UpdateAccountResponse.runtime = proto3;
  UpdateAccountResponse.typeName = "domain.UpdateAccountResponse";
  UpdateAccountResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateReferrerRequest extends Message {
    constructor(data) {
      super();
      this.referrer = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateReferrerRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateReferrerRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateReferrerRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateReferrerRequest, a2, b);
    }
  }
  CreateReferrerRequest.runtime = proto3;
  CreateReferrerRequest.typeName = "domain.CreateReferrerRequest";
  CreateReferrerRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "referrer",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateReferrerResponse extends Message {
    constructor(data) {
      super();
      this.referrerId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateReferrerResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateReferrerResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateReferrerResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateReferrerResponse, a2, b);
    }
  }
  CreateReferrerResponse.runtime = proto3;
  CreateReferrerResponse.typeName = "domain.CreateReferrerResponse";
  CreateReferrerResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "referrer_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AddAchievementsRequest extends Message {
    constructor(data) {
      super();
      this.achievements = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddAchievementsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddAchievementsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddAchievementsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AddAchievementsRequest, a2, b);
    }
  }
  AddAchievementsRequest.runtime = proto3;
  AddAchievementsRequest.typeName = "domain.AddAchievementsRequest";
  AddAchievementsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "achievements", kind: "enum", T: proto3.getEnumType(Achievement), repeated: true }
  ]);
  class AddAchievementsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddAchievementsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddAchievementsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddAchievementsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AddAchievementsResponse, a2, b);
    }
  }
  AddAchievementsResponse.runtime = proto3;
  AddAchievementsResponse.typeName = "domain.AddAchievementsResponse";
  AddAchievementsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ListAccountsRequest extends Message {
    constructor(data) {
      super();
      this.users = [];
      this.emails = [];
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListAccountsRequest, a2, b);
    }
  }
  ListAccountsRequest.runtime = proto3;
  ListAccountsRequest.typeName = "domain.ListAccountsRequest";
  ListAccountsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "message", T: ListAccountsRequest_User, repeated: true },
    { no: 2, name: "emails", kind: "scalar", T: 9, repeated: true },
    { no: 3, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListAccountsRequest_User extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.authenticatorBlockHash = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsRequest_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsRequest_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsRequest_User().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListAccountsRequest_User, a2, b);
    }
  }
  ListAccountsRequest_User.runtime = proto3;
  ListAccountsRequest_User.typeName = "domain.ListAccountsRequest.User";
  ListAccountsRequest_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "authenticator_block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListAccountsResponse extends Message {
    constructor(data) {
      super();
      this.users = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListAccountsResponse, a2, b);
    }
  }
  ListAccountsResponse.runtime = proto3;
  ListAccountsResponse.typeName = "domain.ListAccountsResponse";
  ListAccountsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "users", kind: "message", T: ListAccountsResponse_User, repeated: true }
  ]);
  class ListAccountsResponse_User extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.email = "";
      this.authenticators = [];
      this.authenticatorBlocks = [];
      this.isProfilesEnabled = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsResponse_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsResponse_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsResponse_User().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListAccountsResponse_User, a2, b);
    }
  }
  ListAccountsResponse_User.runtime = proto3;
  ListAccountsResponse_User.typeName = "domain.ListAccountsResponse.User";
  ListAccountsResponse_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "authenticators", kind: "message", T: ListAccountsResponse_User_ForeignAuthenticator, repeated: true },
    { no: 4, name: "authenticator_blocks", kind: "message", T: AuthenticatorBlock$1, repeated: true },
    {
      no: 5,
      name: "is_profiles_enabled",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ListAccountsResponse_User_ForeignAuthenticator extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.highSecurityIdentitySigPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKey = new Uint8Array(0);
      this.highSecurityVaultKeyEncPubKeySignature = new Uint8Array(0);
      this.storableSigPubKey = new Uint8Array(0);
      this.storableSigPubKeySignature = new Uint8Array(0);
      this.storableVaultKeyEncPubKey = new Uint8Array(0);
      this.storableVaultKeyEncPubKeySignature = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAccountsResponse_User_ForeignAuthenticator().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAccountsResponse_User_ForeignAuthenticator().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAccountsResponse_User_ForeignAuthenticator().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListAccountsResponse_User_ForeignAuthenticator, a2, b);
    }
  }
  ListAccountsResponse_User_ForeignAuthenticator.runtime = proto3;
  ListAccountsResponse_User_ForeignAuthenticator.typeName = "domain.ListAccountsResponse.User.ForeignAuthenticator";
  ListAccountsResponse_User_ForeignAuthenticator.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "high_security_identity_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "high_security_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 5,
      name: "high_security_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "storable_sig_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 7,
      name: "storable_sig_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 8,
      name: "storable_vault_key_enc_pub_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "storable_vault_key_enc_pub_key_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ResolveEmailsRequest extends Message {
    constructor(data) {
      super();
      this.emails = [];
      this.failFast = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ResolveEmailsRequest, a2, b);
    }
  }
  ResolveEmailsRequest.runtime = proto3;
  ResolveEmailsRequest.typeName = "domain.ResolveEmailsRequest";
  ResolveEmailsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "emails", kind: "scalar", T: 9, repeated: true },
    {
      no: 2,
      name: "fail_fast",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ResolveEmailsResponse extends Message {
    constructor(data) {
      super();
      this.emails = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ResolveEmailsResponse, a2, b);
    }
  }
  ResolveEmailsResponse.runtime = proto3;
  ResolveEmailsResponse.typeName = "domain.ResolveEmailsResponse";
  ResolveEmailsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "emails", kind: "message", T: ResolveEmailsResponse_ResolvedEmail, repeated: true }
  ]);
  class ResolveEmailsResponse_ResolvedProfile extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.organizationId = "";
      this.profileType = ProfileType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsResponse_ResolvedProfile().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsResponse_ResolvedProfile().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsResponse_ResolvedProfile().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ResolveEmailsResponse_ResolvedProfile, a2, b);
    }
  }
  ResolveEmailsResponse_ResolvedProfile.runtime = proto3;
  ResolveEmailsResponse_ResolvedProfile.typeName = "domain.ResolveEmailsResponse.ResolvedProfile";
  ResolveEmailsResponse_ResolvedProfile.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "profile_type", kind: "enum", T: proto3.getEnumType(ProfileType) }
  ]);
  class ResolveEmailsResponse_ResolvedEmail extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.emailInvalid = false;
      this.profiles = [];
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ResolveEmailsResponse_ResolvedEmail().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ResolveEmailsResponse_ResolvedEmail().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ResolveEmailsResponse_ResolvedEmail().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ResolveEmailsResponse_ResolvedEmail, a2, b);
    }
  }
  ResolveEmailsResponse_ResolvedEmail.runtime = proto3;
  ResolveEmailsResponse_ResolvedEmail.typeName = "domain.ResolveEmailsResponse.ResolvedEmail";
  ResolveEmailsResponse_ResolvedEmail.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "email_invalid",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 2, name: "profiles", kind: "message", T: ResolveEmailsResponse_ResolvedProfile, repeated: true },
    {
      no: 3,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetPaddleConfigRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetPaddleConfigRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetPaddleConfigRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetPaddleConfigRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetPaddleConfigRequest, a2, b);
    }
  }
  GetPaddleConfigRequest.runtime = proto3;
  GetPaddleConfigRequest.typeName = "domain.GetPaddleConfigRequest";
  GetPaddleConfigRequest.fields = proto3.util.newFieldList(() => []);
  class GetPaddleConfigResponse extends Message {
    constructor(data) {
      super();
      this.isSandbox = false;
      this.wrapperHost = "";
      this.vendorId = protoInt64.zero;
      this.productIdMonthly = protoInt64.zero;
      this.productIdYearly = protoInt64.zero;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetPaddleConfigResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetPaddleConfigResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetPaddleConfigResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetPaddleConfigResponse, a2, b);
    }
  }
  GetPaddleConfigResponse.runtime = proto3;
  GetPaddleConfigResponse.typeName = "domain.GetPaddleConfigResponse";
  GetPaddleConfigResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "is_sandbox",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "wrapper_host",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "vendor_id",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "product_id_monthly",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: "product_id_yearly",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    }
  ]);
  class DeleteAccountRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteAccountRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteAccountRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteAccountRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteAccountRequest, a2, b);
    }
  }
  DeleteAccountRequest.runtime = proto3;
  DeleteAccountRequest.typeName = "domain.DeleteAccountRequest";
  DeleteAccountRequest.fields = proto3.util.newFieldList(() => []);
  class DeleteAccountResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteAccountResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteAccountResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteAccountResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteAccountResponse, a2, b);
    }
  }
  DeleteAccountResponse.runtime = proto3;
  DeleteAccountResponse.typeName = "domain.DeleteAccountResponse";
  DeleteAccountResponse.fields = proto3.util.newFieldList(() => []);
  class CreatePrivateProfileRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreatePrivateProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreatePrivateProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreatePrivateProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreatePrivateProfileRequest, a2, b);
    }
  }
  CreatePrivateProfileRequest.runtime = proto3;
  CreatePrivateProfileRequest.typeName = "domain.CreatePrivateProfileRequest";
  CreatePrivateProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "private_profile", kind: "message", T: ProfileData },
    { no: 3, name: "private_vault", kind: "message", T: VaultCreationData }
  ]);
  class CreatePrivateProfileResponse extends Message {
    constructor(data) {
      super();
      this.privateProfileId = "";
      this.privateVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreatePrivateProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreatePrivateProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreatePrivateProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreatePrivateProfileResponse, a2, b);
    }
  }
  CreatePrivateProfileResponse.runtime = proto3;
  CreatePrivateProfileResponse.typeName = "domain.CreatePrivateProfileResponse";
  CreatePrivateProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "private_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "private_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeletePrivateProfileRequest extends Message {
    constructor(data) {
      super();
      this.privateProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeletePrivateProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeletePrivateProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeletePrivateProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeletePrivateProfileRequest, a2, b);
    }
  }
  DeletePrivateProfileRequest.runtime = proto3;
  DeletePrivateProfileRequest.typeName = "domain.DeletePrivateProfileRequest";
  DeletePrivateProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "private_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeletePrivateProfileResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeletePrivateProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeletePrivateProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeletePrivateProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeletePrivateProfileResponse, a2, b);
    }
  }
  DeletePrivateProfileResponse.runtime = proto3;
  DeletePrivateProfileResponse.typeName = "domain.DeletePrivateProfileResponse";
  DeletePrivateProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RegenerateProfilesRequest extends Message {
    constructor(data) {
      super();
      this.profiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateProfilesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateProfilesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateProfilesRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegenerateProfilesRequest, a2, b);
    }
  }
  RegenerateProfilesRequest.runtime = proto3;
  RegenerateProfilesRequest.typeName = "domain.RegenerateProfilesRequest";
  RegenerateProfilesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profiles", kind: "message", T: ProfileRegenerateData, repeated: true }
  ]);
  class RegenerateProfilesResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateProfilesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateProfilesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateProfilesResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegenerateProfilesResponse, a2, b);
    }
  }
  RegenerateProfilesResponse.runtime = proto3;
  RegenerateProfilesResponse.typeName = "domain.RegenerateProfilesResponse";
  RegenerateProfilesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ListProfilesRequest extends Message {
    constructor(data) {
      super();
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListProfilesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListProfilesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListProfilesRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListProfilesRequest, a2, b);
    }
  }
  ListProfilesRequest.runtime = proto3;
  ListProfilesRequest.typeName = "domain.ListProfilesRequest";
  ListProfilesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class ListProfilesResponse extends Message {
    constructor(data) {
      super();
      this.profiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListProfilesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListProfilesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListProfilesResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListProfilesResponse, a2, b);
    }
  }
  ListProfilesResponse.runtime = proto3;
  ListProfilesResponse.typeName = "domain.ListProfilesResponse";
  ListProfilesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profiles", kind: "message", T: ForeignProfile, repeated: true }
  ]);
  class ProfileRequestEmailChangeRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileRequestEmailChangeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileRequestEmailChangeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileRequestEmailChangeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileRequestEmailChangeRequest, a2, b);
    }
  }
  ProfileRequestEmailChangeRequest.runtime = proto3;
  ProfileRequestEmailChangeRequest.typeName = "domain.ProfileRequestEmailChangeRequest";
  ProfileRequestEmailChangeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ProfileRequestEmailChangeResponse extends Message {
    constructor(data) {
      super();
      this.verificationEmailSent = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileRequestEmailChangeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileRequestEmailChangeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileRequestEmailChangeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileRequestEmailChangeResponse, a2, b);
    }
  }
  ProfileRequestEmailChangeResponse.runtime = proto3;
  ProfileRequestEmailChangeResponse.typeName = "domain.ProfileRequestEmailChangeResponse";
  ProfileRequestEmailChangeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "verification_email_sent",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ProfileCancelEmailChangeRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileCancelEmailChangeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileCancelEmailChangeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileCancelEmailChangeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileCancelEmailChangeRequest, a2, b);
    }
  }
  ProfileCancelEmailChangeRequest.runtime = proto3;
  ProfileCancelEmailChangeRequest.typeName = "domain.ProfileCancelEmailChangeRequest";
  ProfileCancelEmailChangeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ProfileCancelEmailChangeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ProfileCancelEmailChangeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ProfileCancelEmailChangeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ProfileCancelEmailChangeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ProfileCancelEmailChangeResponse, a2, b);
    }
  }
  ProfileCancelEmailChangeResponse.runtime = proto3;
  ProfileCancelEmailChangeResponse.typeName = "domain.ProfileCancelEmailChangeResponse";
  ProfileCancelEmailChangeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class VerifyEmailAddressRequest extends Message {
    constructor(data) {
      super();
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VerifyEmailAddressRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VerifyEmailAddressRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VerifyEmailAddressRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VerifyEmailAddressRequest, a2, b);
    }
  }
  VerifyEmailAddressRequest.runtime = proto3;
  VerifyEmailAddressRequest.typeName = "domain.VerifyEmailAddressRequest";
  VerifyEmailAddressRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class VerifyEmailAddressResponse extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new VerifyEmailAddressResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new VerifyEmailAddressResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new VerifyEmailAddressResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(VerifyEmailAddressResponse, a2, b);
    }
  }
  VerifyEmailAddressResponse.runtime = proto3;
  VerifyEmailAddressResponse.typeName = "domain.VerifyEmailAddressResponse";
  VerifyEmailAddressResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimWithStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.startCode = "";
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimWithStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimWithStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimWithStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ClaimWithStartCodeRequest, a2, b);
    }
  }
  ClaimWithStartCodeRequest.runtime = proto3;
  ClaimWithStartCodeRequest.typeName = "domain.ClaimWithStartCodeRequest";
  ClaimWithStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimWithStartCodeResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimWithStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimWithStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimWithStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ClaimWithStartCodeResponse, a2, b);
    }
  }
  ClaimWithStartCodeResponse.runtime = proto3;
  ClaimWithStartCodeResponse.typeName = "domain.ClaimWithStartCodeResponse";
  ClaimWithStartCodeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetProfileInfoRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetProfileInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetProfileInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetProfileInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetProfileInfoRequest, a2, b);
    }
  }
  GetProfileInfoRequest.runtime = proto3;
  GetProfileInfoRequest.typeName = "domain.GetProfileInfoRequest";
  GetProfileInfoRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetProfileInfoResponse extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.organizationId = "";
      this.organizationName = "";
      this.organizationIcon = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetProfileInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetProfileInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetProfileInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetProfileInfoResponse, a2, b);
    }
  }
  GetProfileInfoResponse.runtime = proto3;
  GetProfileInfoResponse.typeName = "domain.GetProfileInfoResponse";
  GetProfileInfoResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "organization_icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CheckProfileStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      this.startCode = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CheckProfileStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CheckProfileStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CheckProfileStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CheckProfileStartCodeRequest, a2, b);
    }
  }
  CheckProfileStartCodeRequest.runtime = proto3;
  CheckProfileStartCodeRequest.typeName = "domain.CheckProfileStartCodeRequest";
  CheckProfileStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "start_code",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CheckProfileStartCodeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CheckProfileStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CheckProfileStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CheckProfileStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CheckProfileStartCodeResponse, a2, b);
    }
  }
  CheckProfileStartCodeResponse.runtime = proto3;
  CheckProfileStartCodeResponse.typeName = "domain.CheckProfileStartCodeResponse";
  CheckProfileStartCodeResponse.fields = proto3.util.newFieldList(() => []);
  const AccountService = {
    typeName: "domain.AccountService",
    methods: {
      /**
       * - InvalidEmail (20101)
       * - Internal (10500)
       *
       * @generated from rpc domain.AccountService.GetRegistrationInfo
       */
      getRegistrationInfo: {
        name: "GetRegistrationInfo",
        I: GetRegistrationInfoRequest,
        O: GetRegistrationInfoResponse,
        kind: MethodKind.Unary
      },
      /**
       * - EmailTaken (20100): email address taken, backup code is available
       * - InvalidEmail (20101): invalid email address
       * - EmailInviteNotActive (20106): email belongs to an org profile that has no active email invite
       * - EmailTakenNotRecoverable (20107): email address taken, no backup code available
       * - ProfileNotFound (70400): profile not found, or is not an organization profile
       * - MissingProfileAuthenticatorLock (70410)
       * - InvalidProfileSignature (70420)
       * - NotAllowedForProfile (70433): service profile must be registered as service user
       * - WebathnDataError (1000401): there is a parsing error with the webauthn response
       * - WebauthnRequestNotFound (1000402)
       * - WebauthnValidateError (1000400): there is a cryptographic error with the webauthn response
       * - WebauthnInvalidTransport (1000403): tried to register with passkey
       * - StartCodeInvalid (70430)
       * - StartCodeBlocked (70431)
       * - StartCodeMissing (70432)
       * - Internal (10500): internal server error
       * - BadRequest (10400): no authenticators sent
       *
       * @generated from rpc domain.AccountService.CreateWithProfile
       */
      createWithProfile: {
        name: "CreateWithProfile",
        I: CreateAccountWithProfileRequest,
        O: CreateAccountWithProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidLocale (20105): invalid locale
       * - MalformedUserClientSettings (20108): user settings are not valid json
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.Update
       */
      update: {
        name: "Update",
        I: UpdateAccountRequest,
        O: UpdateAccountResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.CreateReferrer
       */
      createReferrer: {
        name: "CreateReferrer",
        I: CreateReferrerRequest,
        O: CreateReferrerResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.AddAchievements
       */
      addAchievements: {
        name: "AddAchievements",
        I: AddAchievementsRequest,
        O: AddAchievementsResponse,
        kind: MethodKind.Unary
      },
      /**
       * Deprecated, use ProfileService.VerifyEmailAddress instead
       * TODO: remove this (min client version 2024-08-05)
       * errors:
       * - PermissionDenied (10100): the credentials provided didn't match the verification token
       * - UserNotFound (20400): no user with that email address found
       * - InvalidVerificationToken (20460): the verification token provided is invalid or outdated or the email has been verified for another account
       * - Internal (10500): internal server error
       * This endpoint can be called with or without credentials. If credentials are given, they must
       * match with the verification token.
       *
       * @generated from rpc domain.AccountService.VerifyEmailAddress
       */
      verifyEmailAddress: {
        name: "VerifyEmailAddress",
        I: VerifyEmailAddressRequest,
        O: VerifyEmailAddressResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidEmail (20101): invalid email address
       * - UserNotFound (20400): user not found
       * - ProfileNotFound (70400): profile not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.List
       */
      list: {
        name: "List",
        I: ListAccountsRequest,
        O: ListAccountsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidEmail (20101): invalid email address (only if fail_fast is set)
       * - UserNotFound (20400): user not found (only if fail_fast is set)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.ResolveEmails
       */
      resolveEmails: {
        name: "ResolveEmails",
        I: ResolveEmailsRequest,
        O: ResolveEmailsResponse,
        kind: MethodKind.Unary
      },
      /**
       * no errors, this is a static endpoint
       *
       * @generated from rpc domain.AccountService.GetPaddleConfig
       */
      getPaddleConfig: {
        name: "GetPaddleConfig",
        I: GetPaddleConfigRequest,
        O: GetPaddleConfigResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationMissingAdmin (60410): user is last admin in an organization with other users
       * - UserNotFound (20400): user not found (this should never happen)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AccountService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteAccountRequest,
        O: DeleteAccountResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class ModifyAuthenticatorsRequest extends Message {
    constructor(data) {
      super();
      this.createAuthenticatorOps = [];
      this.deleteAuthenticatorIds = [];
      this.authenticatorBlock = new Uint8Array(0);
      this.authenticatorBlockSignature = new Uint8Array(0);
      this.profiles = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyAuthenticatorsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyAuthenticatorsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyAuthenticatorsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyAuthenticatorsRequest, a2, b);
    }
  }
  ModifyAuthenticatorsRequest.runtime = proto3;
  ModifyAuthenticatorsRequest.typeName = "domain.ModifyAuthenticatorsRequest";
  ModifyAuthenticatorsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "create_authenticator_ops", kind: "message", T: AuthenticatorCreationData, repeated: true },
    { no: 2, name: "delete_authenticator_ids", kind: "scalar", T: 9, repeated: true },
    {
      no: 3,
      name: "authenticator_block",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "authenticator_block_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 5, name: "profiles", kind: "message", T: ProfileRegenerateData, repeated: true }
  ]);
  class ModifyAuthenticatorsResponse extends Message {
    constructor(data) {
      super();
      this.authenticatorIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyAuthenticatorsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyAuthenticatorsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyAuthenticatorsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyAuthenticatorsResponse, a2, b);
    }
  }
  ModifyAuthenticatorsResponse.runtime = proto3;
  ModifyAuthenticatorsResponse.typeName = "domain.ModifyAuthenticatorsResponse";
  ModifyAuthenticatorsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    { no: 2, name: "authenticator_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class SetDeviceTokenRequest extends Message {
    constructor(data) {
      super();
      this.fcmDeviceToken = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetDeviceTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetDeviceTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetDeviceTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SetDeviceTokenRequest, a2, b);
    }
  }
  SetDeviceTokenRequest.runtime = proto3;
  SetDeviceTokenRequest.typeName = "domain.SetDeviceTokenRequest";
  SetDeviceTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 3,
      name: "fcm_device_token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SetDeviceTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetDeviceTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetDeviceTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetDeviceTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SetDeviceTokenResponse, a2, b);
    }
  }
  SetDeviceTokenResponse.runtime = proto3;
  SetDeviceTokenResponse.typeName = "domain.SetDeviceTokenResponse";
  SetDeviceTokenResponse.fields = proto3.util.newFieldList(() => []);
  class ListAuthenticatorsRequest extends Message {
    constructor(data) {
      super();
      this.latestAuthenticatorBlockHash = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAuthenticatorsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAuthenticatorsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAuthenticatorsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListAuthenticatorsRequest, a2, b);
    }
  }
  ListAuthenticatorsRequest.runtime = proto3;
  ListAuthenticatorsRequest.typeName = "domain.ListAuthenticatorsRequest";
  ListAuthenticatorsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "latest_authenticator_block_hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class ListAuthenticatorsResponse extends Message {
    constructor(data) {
      super();
      this.authenticators = [];
      this.authenticatorBlocks = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListAuthenticatorsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListAuthenticatorsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListAuthenticatorsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListAuthenticatorsResponse, a2, b);
    }
  }
  ListAuthenticatorsResponse.runtime = proto3;
  ListAuthenticatorsResponse.typeName = "domain.ListAuthenticatorsResponse";
  ListAuthenticatorsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "authenticators", kind: "message", T: Authenticator$1, repeated: true },
    { no: 2, name: "authenticator_blocks", kind: "message", T: AuthenticatorBlock$1, repeated: true }
  ]);
  class CreateInitialAuthenticatorBlockRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInitialAuthenticatorBlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInitialAuthenticatorBlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInitialAuthenticatorBlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateInitialAuthenticatorBlockRequest, a2, b);
    }
  }
  CreateInitialAuthenticatorBlockRequest.runtime = proto3;
  CreateInitialAuthenticatorBlockRequest.typeName = "domain.CreateInitialAuthenticatorBlockRequest";
  CreateInitialAuthenticatorBlockRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "authenticator_block", kind: "message", T: AuthenticatorBlock$1 }
  ]);
  class CreateInitialAuthenticatorBlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateInitialAuthenticatorBlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateInitialAuthenticatorBlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateInitialAuthenticatorBlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateInitialAuthenticatorBlockResponse, a2, b);
    }
  }
  CreateInitialAuthenticatorBlockResponse.runtime = proto3;
  CreateInitialAuthenticatorBlockResponse.typeName = "domain.CreateInitialAuthenticatorBlockResponse";
  CreateInitialAuthenticatorBlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  const AuthenticatorService = {
    typeName: "domain.AuthenticatorService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorBlockOutOfSync (40100): the authenticator blocks parent hash does not match the latest authenticator block
       * - AuthenticatorNotFound (40400): authenticator not found
       * - MissingAuthenticatorBlock (40430): the request is lacking a follow-up authenticator block
       * - VaultNotFound (50400): vault not found
       * - VaultOutOfSync (50100): latest_commit_id does not match
       * - EmptyCommit (50200): commit blob is empty
       * - MissingLock (50410): a lock is missing for regneration or no keks were provided for a new authenticator
       * - MissingVault (50420): VaultRegenerateData is missing for a vault
       * - WebauthnValidateError (80400)
       * - WebauthnDataError (80401)
       * - WebauthnRequestNotFound (80402)
       * - MissingWebauthnCredential (80404)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.Modify
       */
      modify: {
        name: "Modify",
        I: ModifyAuthenticatorsRequest,
        O: ModifyAuthenticatorsResponse,
        kind: MethodKind.Unary
      },
      /**
       * DEPRECATED
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorNotFound (40400): combination of authenticator and user not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.SetDeviceToken
       */
      setDeviceToken: {
        name: "SetDeviceToken",
        I: SetDeviceTokenRequest,
        O: SetDeviceTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorBlockNotFound (40440): the authenticator block with given hash was not found or belongs to another user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.List
       */
      list: {
        name: "List",
        I: ListAuthenticatorsRequest,
        O: ListAuthenticatorsResponse,
        kind: MethodKind.Unary
      },
      /**
       * TODO: deprecate and later remove this endpoint once migration to authenticator blocks is completed
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorBlockExists (40450): the account already has an authenticator block
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.AuthenticatorService.CreateInitialAuthenticatorBlock
       */
      createInitialAuthenticatorBlock: {
        name: "CreateInitialAuthenticatorBlock",
        I: CreateInitialAuthenticatorBlockRequest,
        O: CreateInitialAuthenticatorBlockResponse,
        kind: MethodKind.Unary
      }
    }
  };
  const ChannelService = {
    typeName: "domain.ChannelService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): exposed == false and credentials are missing
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): exposed == false and user_id does not match token
       * - UserNotFound (20400): user not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Create
       */
      create: {
        name: "Create",
        I: CreateChannelRequest,
        O: CreateChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): credentials are missing
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - AuthenticatorNotFound (40400): authenticator not found
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - AuthenticatorChannelAlreadyClaimed (40411): channel was already claimed
       * - PermissionDenied (10100): channel does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Claim
       */
      claim: {
        name: "Claim",
        I: ClaimChannelRequest,
        O: ClaimChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): channel is not exposed and no valid credentials were provided
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): channel does not belong to user
       * - InvalidRecipient (40500): invalid recipient
       * - Timeout (10200): timeout, client might retry
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Read
       */
      read: {
        name: "Read",
        I: ReadChannelRequest,
        O: ReadChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): channel is not exposed and no valid credentials were provided
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): channel does not belong to user
       * - InvalidRecipient (40500): invalid recipient
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Write
       */
      write: {
        name: "Write",
        I: WriteChannelRequest,
        O: WriteChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): channel is not exposed and no valid credentials were provided
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - PermissionDenied (10100): channel does not belong to user
       * - AuthenticatorChannelNotFound (40410): channel not found
       * - Internal (10500)(10500): internal server error
       *
       * @generated from rpc domain.ChannelService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteChannelRequest,
        O: DeleteChannelResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class ListChildOrganizationsRequest extends Message {
    constructor(data) {
      super();
      this.parentOrganizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListChildOrganizationsRequest, a2, b);
    }
  }
  ListChildOrganizationsRequest.runtime = proto3;
  ListChildOrganizationsRequest.typeName = "domain.ListChildOrganizationsRequest";
  ListChildOrganizationsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "parent_organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ListChildOrganizationsResponse extends Message {
    constructor(data) {
      super();
      this.childOrganizations = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListChildOrganizationsResponse, a2, b);
    }
  }
  ListChildOrganizationsResponse.runtime = proto3;
  ListChildOrganizationsResponse.typeName = "domain.ListChildOrganizationsResponse";
  ListChildOrganizationsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "child_organizations", kind: "message", T: ListChildOrganizationsResponse_ChildOrganization, repeated: true }
  ]);
  class ListChildOrganizationsResponse_ChildOrganization extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.name = "";
      this.licenseCount = 0;
      this.users = [];
      this.managers = [];
      this.parentOrganizationMetadata = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse_ChildOrganization().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse_ChildOrganization().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse_ChildOrganization().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListChildOrganizationsResponse_ChildOrganization, a2, b);
    }
  }
  ListChildOrganizationsResponse_ChildOrganization.runtime = proto3;
  ListChildOrganizationsResponse_ChildOrganization.typeName = "domain.ListChildOrganizationsResponse.ChildOrganization";
  ListChildOrganizationsResponse_ChildOrganization.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "license_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 4, name: "users", kind: "message", T: ListChildOrganizationsResponse_ChildOrganization_User, repeated: true },
    { no: 5, name: "managers", kind: "message", T: ListChildOrganizationsResponse_ChildOrganization_Manager, repeated: true },
    { no: 6, name: "created_at", kind: "message", T: Timestamp },
    {
      no: 7,
      name: "parent_organization_metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ListChildOrganizationsResponse_ChildOrganization_User extends Message {
    constructor(data) {
      super();
      this.isAdmin = false;
      this.isNotConnected = false;
      this.hasStartCode = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_User().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListChildOrganizationsResponse_ChildOrganization_User, a2, b);
    }
  }
  ListChildOrganizationsResponse_ChildOrganization_User.runtime = proto3;
  ListChildOrganizationsResponse_ChildOrganization_User.typeName = "domain.ListChildOrganizationsResponse.ChildOrganization.User";
  ListChildOrganizationsResponse_ChildOrganization_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "is_not_connected",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 3,
      name: "has_start_code",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 4, name: "last_active_at", kind: "message", T: Timestamp }
  ]);
  class ListChildOrganizationsResponse_ChildOrganization_Manager extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      this.parentOrganizationProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_Manager().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_Manager().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListChildOrganizationsResponse_ChildOrganization_Manager().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListChildOrganizationsResponse_ChildOrganization_Manager, a2, b);
    }
  }
  ListChildOrganizationsResponse_ChildOrganization_Manager.runtime = proto3;
  ListChildOrganizationsResponse_ChildOrganization_Manager.typeName = "domain.ListChildOrganizationsResponse.ChildOrganization.Manager";
  ListChildOrganizationsResponse_ChildOrganization_Manager.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "parent_organization_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AddManagerRequest extends Message {
    constructor(data) {
      super();
      this.childOrganizationId = "";
      this.parentOrganizationProfileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddManagerRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddManagerRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddManagerRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AddManagerRequest, a2, b);
    }
  }
  AddManagerRequest.runtime = proto3;
  AddManagerRequest.typeName = "domain.AddManagerRequest";
  AddManagerRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "child_organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "parent_organization_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "profile", kind: "message", T: ProfileData },
    { no: 4, name: "personal_vault_data", kind: "message", T: VaultCreationData },
    { no: 5, name: "admin_profile_lock", kind: "message", T: ProfileProfileLock$1 },
    { no: 6, name: "legacy_admin_vault_lock", kind: "message", T: VaultLockCreationData }
  ]);
  class AddManagerResponse extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AddManagerResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AddManagerResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AddManagerResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AddManagerResponse, a2, b);
    }
  }
  AddManagerResponse.runtime = proto3;
  AddManagerResponse.typeName = "domain.AddManagerResponse";
  AddManagerResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UpdateChildOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.childOrganizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateChildOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateChildOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateChildOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateChildOrganizationRequest, a2, b);
    }
  }
  UpdateChildOrganizationRequest.runtime = proto3;
  UpdateChildOrganizationRequest.typeName = "domain.UpdateChildOrganizationRequest";
  UpdateChildOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "child_organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 9, name: "parent_organization_metadata", kind: "message", T: StringValue }
  ]);
  class UpdateChildOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateChildOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateChildOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateChildOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateChildOrganizationResponse, a2, b);
    }
  }
  UpdateChildOrganizationResponse.runtime = proto3;
  UpdateChildOrganizationResponse.typeName = "domain.UpdateChildOrganizationResponse";
  UpdateChildOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  const ChildOrganizationService = {
    typeName: "domain.ChildOrganizationService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400): not member of the given parent organization
       * - Internal (10500)
       *
       * @generated from rpc domain.ChildOrganizationService.List
       */
      list: {
        name: "List",
        I: ListChildOrganizationsRequest,
        O: ListChildOrganizationsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): profile in parent organization not found
       * - UserNotFound (20400): profile in parent organization is free
       * - UserAlreadyInOrganization(60401)
       * - EmailTaken(20100): A disconnected profile with the same email already exists in the child organization
       * - OrganizationNotFound (60400): not member of the parent or child organization or organization is no child organization
       * - OrganizationInsufficientAccess (60100): not admin of the child organization
       * - BadRequest (10400)
       * - ProfileOutOfSync (70411)
       * - MissingProfileProfileLock (70412): missing admin profile lock (for admin-profile-enabled orgs)
       * - AuthenticatorNotFound (40400): additional authenticator lock provided
       * - MissingProfileAuthenticatorLock (70410)
       * - VaultOutOfSync (50100)
       * - VaultNotFound (50400)
       * - MissingVault (50420): Missing personal vault data
       * - MissingVaultProfileLock (50411): missing personal vault lock or admin vault lock
       * - Internal (10500): Internal server error
       *
       * @generated from rpc domain.ChildOrganizationService.AddManager
       */
      addManager: {
        name: "AddManager",
        I: AddManagerRequest,
        O: AddManagerResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not manager of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.ChildOrganizationService.Update
       */
      update: {
        name: "Update",
        I: UpdateChildOrganizationRequest,
        O: UpdateChildOrganizationResponse,
        kind: MethodKind.Unary
      }
    }
  };
  const CredentialService = {
    typeName: "domain.CredentialService",
    methods: {
      /**
       * errors:
       * - UserNotFound (20400): email does not belong to a user
       * - AuthenticatorNotFound (40400): backup authenticator was not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CreateChallenge
       */
      createChallenge: {
        name: "CreateChallenge",
        I: CreateChallengeRequest,
        O: CreateChallengeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CreateLongPollChannelChallenge
       */
      createLongPollChannelChallenge: {
        name: "CreateLongPollChannelChallenge",
        I: CreateLongPollChannelChallengeRequest,
        O: CreateLongPollChannelChallengeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CompleteLongPollChannel
       */
      completeLongPollChannel: {
        name: "CompleteLongPollChannel",
        I: CompleteLongPollChannelRequest,
        O: CompleteLongPollChannelResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidTimeout (20420): expires_at of given session_unlock ist already expired
       * - AuthenticatorNotFound (40400): invalid combination of user_id and authenticator_id
       * - InvalidChallenge (30410): invalid challenge
       * - InvalidSignature (30400): invalid response fo the hcallenge
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.CredentialService.CreateTokens
       */
      createTokens: {
        name: "CreateTokens",
        I: CreateTokensRequest,
        O: CreateTokensResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - OrganizationNotFound (60400): not member of the given organization, or auditlog not enabled
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.CreateAuditlogWriteToken
       */
      createAuditlogWriteToken: {
        name: "CreateAuditlogWriteToken",
        I: CreateAuditlogWriteTokenRequest,
        O: CreateAuditlogWriteTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - OrganizationNotFound (60400): not member of the given organization, or auditlog not enabled
       * - OrganizationInsufficientAccess (60100)
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.CreateAuditlogAdminToken
       */
      createAuditlogAdminToken: {
        name: "CreateAuditlogAdminToken",
        I: CreateAuditlogAdminTokenRequest,
        O: CreateAuditlogAdminTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - PermissionDenied (10100)
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.CreateLFDOverridesAdminToken
       */
      createLFDOverridesAdminToken: {
        name: "CreateLFDOverridesAdminToken",
        I: CreateLFDOverridesAdminTokenRequest,
        O: CreateLFDOverridesAdminTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500)
       *
       * @generated from rpc domain.CredentialService.RefreshToken
       */
      refreshToken: {
        name: "RefreshToken",
        I: RefreshTokenRequest,
        O: RefreshTokenResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class PingRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PingRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PingRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PingRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(PingRequest, a2, b);
    }
  }
  PingRequest.runtime = proto3;
  PingRequest.typeName = "domain.PingRequest";
  PingRequest.fields = proto3.util.newFieldList(() => []);
  class PingResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PingResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PingResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PingResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(PingResponse, a2, b);
    }
  }
  PingResponse.runtime = proto3;
  PingResponse.typeName = "domain.PingResponse";
  PingResponse.fields = proto3.util.newFieldList(() => []);
  const HealthService = {
    typeName: "domain.HealthService",
    methods: {
      /**
       * @generated from rpc domain.HealthService.Ping
       */
      ping: {
        name: "Ping",
        I: PingRequest,
        O: PingResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class EntraGetAuthorizeUriRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.redirectUri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetAuthorizeUriRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetAuthorizeUriRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetAuthorizeUriRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraGetAuthorizeUriRequest, a2, b);
    }
  }
  EntraGetAuthorizeUriRequest.runtime = proto3;
  EntraGetAuthorizeUriRequest.typeName = "domain.EntraGetAuthorizeUriRequest";
  EntraGetAuthorizeUriRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "redirect_uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraGetAuthorizeUriResponse extends Message {
    constructor(data) {
      super();
      this.uri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetAuthorizeUriResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetAuthorizeUriResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetAuthorizeUriResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraGetAuthorizeUriResponse, a2, b);
    }
  }
  EntraGetAuthorizeUriResponse.runtime = proto3;
  EntraGetAuthorizeUriResponse.typeName = "domain.EntraGetAuthorizeUriResponse";
  EntraGetAuthorizeUriResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraFinishAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.resultQueryString = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraFinishAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraFinishAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraFinishAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraFinishAuthorizationRequest, a2, b);
    }
  }
  EntraFinishAuthorizationRequest.runtime = proto3;
  EntraFinishAuthorizationRequest.typeName = "domain.EntraFinishAuthorizationRequest";
  EntraFinishAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "result_query_string",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraFinishAuthorizationResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraFinishAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraFinishAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraFinishAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraFinishAuthorizationResponse, a2, b);
    }
  }
  EntraFinishAuthorizationResponse.runtime = proto3;
  EntraFinishAuthorizationResponse.typeName = "domain.EntraFinishAuthorizationResponse";
  EntraFinishAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraGetTenantRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.forceRefresh = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraGetTenantRequest, a2, b);
    }
  }
  EntraGetTenantRequest.runtime = proto3;
  EntraGetTenantRequest.typeName = "domain.EntraGetTenantRequest";
  EntraGetTenantRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "force_refresh",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class EntraGetTenantResponse extends Message {
    constructor(data) {
      super();
      this.users = [];
      this.groups = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraGetTenantResponse, a2, b);
    }
  }
  EntraGetTenantResponse.runtime = proto3;
  EntraGetTenantResponse.typeName = "domain.EntraGetTenantResponse";
  EntraGetTenantResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "updated_at", kind: "message", T: Timestamp },
    { no: 2, name: "users", kind: "message", T: EntraGetTenantResponse_User, repeated: true },
    { no: 3, name: "groups", kind: "message", T: EntraGetTenantResponse_Group, repeated: true }
  ]);
  class EntraGetTenantResponse_User extends Message {
    constructor(data) {
      super();
      this.entraUserId = "";
      this.email = "";
      this.memberOf = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantResponse_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantResponse_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantResponse_User().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraGetTenantResponse_User, a2, b);
    }
  }
  EntraGetTenantResponse_User.runtime = proto3;
  EntraGetTenantResponse_User.typeName = "domain.EntraGetTenantResponse.User";
  EntraGetTenantResponse_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "entra_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "member_of", kind: "scalar", T: 9, repeated: true }
  ]);
  class EntraGetTenantResponse_Group extends Message {
    constructor(data) {
      super();
      this.entraGroupId = "";
      this.name = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraGetTenantResponse_Group().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraGetTenantResponse_Group().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraGetTenantResponse_Group().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraGetTenantResponse_Group, a2, b);
    }
  }
  EntraGetTenantResponse_Group.runtime = proto3;
  EntraGetTenantResponse_Group.typeName = "domain.EntraGetTenantResponse.Group";
  EntraGetTenantResponse_Group.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "entra_group_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraClearAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraClearAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraClearAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraClearAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraClearAuthorizationRequest, a2, b);
    }
  }
  EntraClearAuthorizationRequest.runtime = proto3;
  EntraClearAuthorizationRequest.typeName = "domain.EntraClearAuthorizationRequest";
  EntraClearAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class EntraClearAuthorizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EntraClearAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EntraClearAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EntraClearAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EntraClearAuthorizationResponse, a2, b);
    }
  }
  EntraClearAuthorizationResponse.runtime = proto3;
  EntraClearAuthorizationResponse.typeName = "domain.EntraClearAuthorizationResponse";
  EntraClearAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CsvSetIntegrationDataRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.dataJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvSetIntegrationDataRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvSetIntegrationDataRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvSetIntegrationDataRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CsvSetIntegrationDataRequest, a2, b);
    }
  }
  CsvSetIntegrationDataRequest.runtime = proto3;
  CsvSetIntegrationDataRequest.typeName = "domain.CsvSetIntegrationDataRequest";
  CsvSetIntegrationDataRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "data_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CsvSetIntegrationDataResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvSetIntegrationDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvSetIntegrationDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvSetIntegrationDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CsvSetIntegrationDataResponse, a2, b);
    }
  }
  CsvSetIntegrationDataResponse.runtime = proto3;
  CsvSetIntegrationDataResponse.typeName = "domain.CsvSetIntegrationDataResponse";
  CsvSetIntegrationDataResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CsvGetIntegrationDataRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvGetIntegrationDataRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvGetIntegrationDataRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvGetIntegrationDataRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CsvGetIntegrationDataRequest, a2, b);
    }
  }
  CsvGetIntegrationDataRequest.runtime = proto3;
  CsvGetIntegrationDataRequest.typeName = "domain.CsvGetIntegrationDataRequest";
  CsvGetIntegrationDataRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CsvGetIntegrationDataResponse extends Message {
    constructor(data) {
      super();
      this.dataJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CsvGetIntegrationDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CsvGetIntegrationDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CsvGetIntegrationDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CsvGetIntegrationDataResponse, a2, b);
    }
  }
  CsvGetIntegrationDataResponse.runtime = proto3;
  CsvGetIntegrationDataResponse.typeName = "domain.CsvGetIntegrationDataResponse";
  CsvGetIntegrationDataResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceGetAuthorizeUriRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.redirectUri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceGetAuthorizeUriRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceGetAuthorizeUriRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceGetAuthorizeUriRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceGetAuthorizeUriRequest, a2, b);
    }
  }
  GWorkspaceGetAuthorizeUriRequest.runtime = proto3;
  GWorkspaceGetAuthorizeUriRequest.typeName = "domain.GWorkspaceGetAuthorizeUriRequest";
  GWorkspaceGetAuthorizeUriRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "redirect_uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceGetAuthorizeUriResponse extends Message {
    constructor(data) {
      super();
      this.uri = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceGetAuthorizeUriResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceGetAuthorizeUriResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceGetAuthorizeUriResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceGetAuthorizeUriResponse, a2, b);
    }
  }
  GWorkspaceGetAuthorizeUriResponse.runtime = proto3;
  GWorkspaceGetAuthorizeUriResponse.typeName = "domain.GWorkspaceGetAuthorizeUriResponse";
  GWorkspaceGetAuthorizeUriResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "uri",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceFinishAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.resultQueryString = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceFinishAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceFinishAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceFinishAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceFinishAuthorizationRequest, a2, b);
    }
  }
  GWorkspaceFinishAuthorizationRequest.runtime = proto3;
  GWorkspaceFinishAuthorizationRequest.typeName = "domain.GWorkspaceFinishAuthorizationRequest";
  GWorkspaceFinishAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "result_query_string",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceFinishAuthorizationResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceFinishAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceFinishAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceFinishAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceFinishAuthorizationResponse, a2, b);
    }
  }
  GWorkspaceFinishAuthorizationResponse.runtime = proto3;
  GWorkspaceFinishAuthorizationResponse.typeName = "domain.GWorkspaceFinishAuthorizationResponse";
  GWorkspaceFinishAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceClearAuthorizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceClearAuthorizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceClearAuthorizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceClearAuthorizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceClearAuthorizationRequest, a2, b);
    }
  }
  GWorkspaceClearAuthorizationRequest.runtime = proto3;
  GWorkspaceClearAuthorizationRequest.typeName = "domain.GWorkspaceClearAuthorizationRequest";
  GWorkspaceClearAuthorizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GWorkspaceClearAuthorizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceClearAuthorizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceClearAuthorizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceClearAuthorizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceClearAuthorizationResponse, a2, b);
    }
  }
  GWorkspaceClearAuthorizationResponse.runtime = proto3;
  GWorkspaceClearAuthorizationResponse.typeName = "domain.GWorkspaceClearAuthorizationResponse";
  GWorkspaceClearAuthorizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class GWorkspaceListRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.forceRefresh = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceListRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceListRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceListRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceListRequest, a2, b);
    }
  }
  GWorkspaceListRequest.runtime = proto3;
  GWorkspaceListRequest.typeName = "domain.GWorkspaceListRequest";
  GWorkspaceListRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "force_refresh",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class GWorkspaceListResponse extends Message {
    constructor(data) {
      super();
      this.users = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceListResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceListResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceListResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceListResponse, a2, b);
    }
  }
  GWorkspaceListResponse.runtime = proto3;
  GWorkspaceListResponse.typeName = "domain.GWorkspaceListResponse";
  GWorkspaceListResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "updated_at", kind: "message", T: Timestamp },
    { no: 2, name: "users", kind: "message", T: GWorkspaceListResponse_User, repeated: true }
  ]);
  class GWorkspaceListResponse_User extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GWorkspaceListResponse_User().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GWorkspaceListResponse_User().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GWorkspaceListResponse_User().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GWorkspaceListResponse_User, a2, b);
    }
  }
  GWorkspaceListResponse_User.runtime = proto3;
  GWorkspaceListResponse_User.typeName = "domain.GWorkspaceListResponse.User";
  GWorkspaceListResponse_User.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  const IntegrationsService = {
    typeName: "domain.IntegrationsService",
    methods: {
      /**
       * no errors
       *
       * @generated from rpc domain.IntegrationsService.EntraGetAuthorizeUri
       */
      entraGetAuthorizeUri: {
        name: "EntraGetAuthorizeUri",
        I: EntraGetAuthorizeUriRequest,
        O: EntraGetAuthorizeUriResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - BadRequest (10400): result_query_string failed to parse
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationUnauthorized (80401): if authorization failed for unknown reasons
       * - IntegrationNotInitialized (80400): the user canceled the authorization flow
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.EntraFinishAuthorization
       */
      entraFinishAuthorization: {
        name: "EntraFinishAuthorization",
        I: EntraFinishAuthorizationRequest,
        O: EntraFinishAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationNotInitialized (80400)
       * - IntegrationUnauthorized (80401)
       * - IntegrationInternal (80500)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.EntraGetTenant
       */
      entraGetTenant: {
        name: "EntraGetTenant",
        I: EntraGetTenantRequest,
        O: EntraGetTenantResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.EntraClearAuthorization
       */
      entraClearAuthorization: {
        name: "EntraClearAuthorization",
        I: EntraClearAuthorizationRequest,
        O: EntraClearAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100)
       * - OrganizationNotFound (60400)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.CsvSetIntegrationData
       */
      csvSetIntegrationData: {
        name: "CsvSetIntegrationData",
        I: CsvSetIntegrationDataRequest,
        O: CsvSetIntegrationDataResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100)
       * - OrganizationNotFound (60400)
       * - IntegrationNotInitialized (80400)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.CsvGetIntegrationData
       */
      csvGetIntegrationData: {
        name: "CsvGetIntegrationData",
        I: CsvGetIntegrationDataRequest,
        O: CsvGetIntegrationDataResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationUnauthorized (80401): if authorization initialization failed for unknown reasons
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceGetAuthorizeUri
       */
      gWorkspaceGetAuthorizeUri: {
        name: "GWorkspaceGetAuthorizeUri",
        I: GWorkspaceGetAuthorizeUriRequest,
        O: GWorkspaceGetAuthorizeUriResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationUnauthorized (80401): if authorization failed for unknown reasons
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceFinishAuthorization
       */
      gWorkspaceFinishAuthorization: {
        name: "GWorkspaceFinishAuthorization",
        I: GWorkspaceFinishAuthorizationRequest,
        O: GWorkspaceFinishAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceClearAuthorization
       */
      gWorkspaceClearAuthorization: {
        name: "GWorkspaceClearAuthorization",
        I: GWorkspaceClearAuthorizationRequest,
        O: GWorkspaceClearAuthorizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - OrganizationInsufficientAccess (60100)
       * - IntegrationNotInitialized (80400)
       * - IntegrationUnauthorized (80401)
       * - IntegrationInternal (80500)
       * - Internal (10500)
       *
       * @generated from rpc domain.IntegrationsService.GWorkspaceList
       */
      gWorkspaceList: {
        name: "GWorkspaceList",
        I: GWorkspaceListRequest,
        O: GWorkspaceListResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class ReplaceLFDOverridesRequest extends Message {
    constructor(data) {
      super();
      this.overrideJson = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReplaceLFDOverridesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReplaceLFDOverridesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReplaceLFDOverridesRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ReplaceLFDOverridesRequest, a2, b);
    }
  }
  ReplaceLFDOverridesRequest.runtime = proto3;
  ReplaceLFDOverridesRequest.typeName = "domain.ReplaceLFDOverridesRequest";
  ReplaceLFDOverridesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "override_json", kind: "scalar", T: 9, repeated: true }
  ]);
  class ReplaceLFDOverridesResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ReplaceLFDOverridesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ReplaceLFDOverridesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ReplaceLFDOverridesResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ReplaceLFDOverridesResponse, a2, b);
    }
  }
  ReplaceLFDOverridesResponse.runtime = proto3;
  ReplaceLFDOverridesResponse.typeName = "domain.ReplaceLFDOverridesResponse";
  ReplaceLFDOverridesResponse.fields = proto3.util.newFieldList(() => []);
  class DeleteLFDOverridesRequest extends Message {
    constructor(data) {
      super();
      this.overrideIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteLFDOverridesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteLFDOverridesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteLFDOverridesRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteLFDOverridesRequest, a2, b);
    }
  }
  DeleteLFDOverridesRequest.runtime = proto3;
  DeleteLFDOverridesRequest.typeName = "domain.DeleteLFDOverridesRequest";
  DeleteLFDOverridesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "override_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class DeleteLFDOverridesResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteLFDOverridesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteLFDOverridesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteLFDOverridesResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteLFDOverridesResponse, a2, b);
    }
  }
  DeleteLFDOverridesResponse.runtime = proto3;
  DeleteLFDOverridesResponse.typeName = "domain.DeleteLFDOverridesResponse";
  DeleteLFDOverridesResponse.fields = proto3.util.newFieldList(() => []);
  class ListLFDOverridesRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListLFDOverridesRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListLFDOverridesRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListLFDOverridesRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListLFDOverridesRequest, a2, b);
    }
  }
  ListLFDOverridesRequest.runtime = proto3;
  ListLFDOverridesRequest.typeName = "domain.ListLFDOverridesRequest";
  ListLFDOverridesRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "last_known_overrides_update_time", kind: "message", T: Timestamp }
  ]);
  class ListLFDOverridesResponse extends Message {
    constructor(data) {
      super();
      this.overridesJson = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ListLFDOverridesResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ListLFDOverridesResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ListLFDOverridesResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ListLFDOverridesResponse, a2, b);
    }
  }
  ListLFDOverridesResponse.runtime = proto3;
  ListLFDOverridesResponse.typeName = "domain.ListLFDOverridesResponse";
  ListLFDOverridesResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "overrides_update_time", kind: "message", T: Timestamp },
    { no: 2, name: "overrides_json", kind: "scalar", T: 9, repeated: true }
  ]);
  const LFDOverridesService = {
    typeName: "domain.LFDOverridesService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - BadRequest (10400): if json is malformed or missing required attributes
       * - Internal (10500)
       *
       * @generated from rpc domain.LFDOverridesService.Replace
       */
      replace: {
        name: "Replace",
        I: ReplaceLFDOverridesRequest,
        O: ReplaceLFDOverridesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.LFDOverridesService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteLFDOverridesRequest,
        O: DeleteLFDOverridesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.LFDOverridesService.List
       */
      list: {
        name: "List",
        I: ListLFDOverridesRequest,
        O: ListLFDOverridesResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class ShowInboxRequest extends Message {
    constructor(data) {
      super();
      this.slug = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowInboxRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowInboxRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowInboxRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ShowInboxRequest, a2, b);
    }
  }
  ShowInboxRequest.runtime = proto3;
  ShowInboxRequest.typeName = "domain.ShowInboxRequest";
  ShowInboxRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "slug",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowInboxResponse extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.publicKey = new Uint8Array(0);
      this.metadata = "";
      this.url = "";
      this.baseUrl = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowInboxResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowInboxResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowInboxResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ShowInboxResponse, a2, b);
    }
  }
  ShowInboxResponse.runtime = proto3;
  ShowInboxResponse.typeName = "domain.ShowInboxResponse";
  ShowInboxResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "public_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 4,
      name: "metadata",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 5, name: "organization_data", kind: "message", T: ShowInboxResponse_OrganizationData },
    {
      no: 6,
      name: "url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowInboxResponse_OrganizationData extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.icon = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowInboxResponse_OrganizationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowInboxResponse_OrganizationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowInboxResponse_OrganizationData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ShowInboxResponse_OrganizationData, a2, b);
    }
  }
  ShowInboxResponse_OrganizationData.runtime = proto3;
  ShowInboxResponse_OrganizationData.typeName = "domain.ShowInboxResponse.OrganizationData";
  ShowInboxResponse_OrganizationData.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateLoginInboxMessageRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.generationId = "";
      this.type = VaultMessageType.UNKNOWN;
      this.encryptedData = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLoginInboxMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLoginInboxMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLoginInboxMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateLoginInboxMessageRequest, a2, b);
    }
  }
  CreateLoginInboxMessageRequest.runtime = proto3;
  CreateLoginInboxMessageRequest.typeName = "domain.CreateLoginInboxMessageRequest";
  CreateLoginInboxMessageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 4,
      name: "encrypted_data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateLoginInboxMessageResponse extends Message {
    constructor(data) {
      super();
      this.inboxMessageId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateLoginInboxMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateLoginInboxMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateLoginInboxMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateLoginInboxMessageResponse, a2, b);
    }
  }
  CreateLoginInboxMessageResponse.runtime = proto3;
  CreateLoginInboxMessageResponse.typeName = "domain.CreateLoginInboxMessageResponse";
  CreateLoginInboxMessageResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "inbox_message_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  const LoginInboxService = {
    typeName: "domain.LoginInboxService",
    methods: {
      /**
       * errors:
       * - VaultNotFound (50400): no vault for this slug
       * - VaultInboxSlugInvalid (50470)
       * - Internal (10500)
       *
       * @generated from rpc domain.LoginInboxService.Show
       */
      show: {
        name: "Show",
        I: ShowInboxRequest,
        O: ShowInboxResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - VaultNotFound (50400)
       * - InvalidVaultMessageType (50463): vault message type not allowed for this endpoint
       * - VaultOutOfSync (50100)
       * - Internal (10500)
       *
       * @generated from rpc domain.LoginInboxService.CreateMessage
       */
      createMessage: {
        name: "CreateMessage",
        I: CreateLoginInboxMessageRequest,
        O: CreateLoginInboxMessageResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class SubscriptionStatus extends Message {
    constructor(data) {
      super();
      this.status = { case: void 0 };
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus, a2, b);
    }
  }
  SubscriptionStatus.runtime = proto3;
  SubscriptionStatus.typeName = "domain.SubscriptionStatus";
  SubscriptionStatus.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "status_paddle_active", kind: "message", T: SubscriptionStatus_PaddleActive, oneof: "status" },
    { no: 2, name: "status_paddle_past_due", kind: "message", T: SubscriptionStatus_PaddlePastDue, oneof: "status" },
    { no: 3, name: "status_paddle_paused_delinquent", kind: "message", T: SubscriptionStatus_PaddlePausedDelinquent, oneof: "status" },
    { no: 4, name: "status_paddle_paused_voluntary", kind: "message", T: SubscriptionStatus_PaddlePausedVoluntary, oneof: "status" },
    { no: 5, name: "status_paddle_deleted", kind: "message", T: SubscriptionStatus_PaddleDeleted, oneof: "status" },
    { no: 6, name: "status_trial", kind: "message", T: SubscriptionStatus_Trial, oneof: "status" },
    { no: 7, name: "status_custom", kind: "message", T: SubscriptionStatus_Custom, oneof: "status" },
    { no: 8, name: "status_active_free", kind: "message", T: SubscriptionStatus_ActiveFree, oneof: "status" },
    { no: 9, name: "status_example", kind: "message", T: SubscriptionStatus_Example, oneof: "status" }
  ]);
  class SubscriptionStatus_PaddleActive extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddleActive().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddleActive().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddleActive().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_PaddleActive, a2, b);
    }
  }
  SubscriptionStatus_PaddleActive.runtime = proto3;
  SubscriptionStatus_PaddleActive.typeName = "domain.SubscriptionStatus.PaddleActive";
  SubscriptionStatus_PaddleActive.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "next_bill_date", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SubscriptionStatus_PaddlePastDue extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddlePastDue().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddlePastDue().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddlePastDue().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_PaddlePastDue, a2, b);
    }
  }
  SubscriptionStatus_PaddlePastDue.runtime = proto3;
  SubscriptionStatus_PaddlePastDue.typeName = "domain.SubscriptionStatus.PaddlePastDue";
  SubscriptionStatus_PaddlePastDue.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "next_bill_date", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_PaddlePausedDelinquent extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddlePausedDelinquent().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddlePausedDelinquent().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddlePausedDelinquent().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_PaddlePausedDelinquent, a2, b);
    }
  }
  SubscriptionStatus_PaddlePausedDelinquent.runtime = proto3;
  SubscriptionStatus_PaddlePausedDelinquent.typeName = "domain.SubscriptionStatus.PaddlePausedDelinquent";
  SubscriptionStatus_PaddlePausedDelinquent.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "paused_at", kind: "message", T: Timestamp },
    { no: 3, name: "paused_from", kind: "message", T: Timestamp },
    {
      no: 4,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_PaddlePausedVoluntary extends Message {
    constructor(data) {
      super();
      this.baseUrl = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddlePausedVoluntary().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddlePausedVoluntary().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddlePausedVoluntary().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_PaddlePausedVoluntary, a2, b);
    }
  }
  SubscriptionStatus_PaddlePausedVoluntary.runtime = proto3;
  SubscriptionStatus_PaddlePausedVoluntary.typeName = "domain.SubscriptionStatus.PaddlePausedVoluntary";
  SubscriptionStatus_PaddlePausedVoluntary.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "base_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "paused_at", kind: "message", T: Timestamp },
    { no: 3, name: "paused_from", kind: "message", T: Timestamp },
    {
      no: 4,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_PaddleDeleted extends Message {
    constructor(data) {
      super();
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_PaddleDeleted().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_PaddleDeleted().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_PaddleDeleted().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_PaddleDeleted, a2, b);
    }
  }
  SubscriptionStatus_PaddleDeleted.runtime = proto3;
  SubscriptionStatus_PaddleDeleted.typeName = "domain.SubscriptionStatus.PaddleDeleted";
  SubscriptionStatus_PaddleDeleted.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "cancellation_effective_date", kind: "message", T: Timestamp },
    {
      no: 2,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_Trial extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_Trial().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_Trial().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_Trial().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_Trial, a2, b);
    }
  }
  SubscriptionStatus_Trial.runtime = proto3;
  SubscriptionStatus_Trial.typeName = "domain.SubscriptionStatus.Trial";
  SubscriptionStatus_Trial.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "trial_end_date", kind: "message", T: Timestamp }
  ]);
  class SubscriptionStatus_ActiveFree extends Message {
    constructor(data) {
      super();
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_ActiveFree().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_ActiveFree().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_ActiveFree().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_ActiveFree, a2, b);
    }
  }
  SubscriptionStatus_ActiveFree.runtime = proto3;
  SubscriptionStatus_ActiveFree.typeName = "domain.SubscriptionStatus.ActiveFree";
  SubscriptionStatus_ActiveFree.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class SubscriptionStatus_Custom extends Message {
    constructor(data) {
      super();
      this.left = "";
      this.right = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_Custom().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_Custom().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_Custom().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_Custom, a2, b);
    }
  }
  SubscriptionStatus_Custom.runtime = proto3;
  SubscriptionStatus_Custom.typeName = "domain.SubscriptionStatus.Custom";
  SubscriptionStatus_Custom.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "left",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "right",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SubscriptionStatus_Example extends Message {
    constructor(data) {
      super();
      this.left = "";
      this.right = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SubscriptionStatus_Example().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SubscriptionStatus_Example().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SubscriptionStatus_Example().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SubscriptionStatus_Example, a2, b);
    }
  }
  SubscriptionStatus_Example.runtime = proto3;
  SubscriptionStatus_Example.typeName = "domain.SubscriptionStatus.Example";
  SubscriptionStatus_Example.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "left",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "right",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.icon = "";
      this.email = "";
      this.authenticatorBlock = new Uint8Array(0);
      this.authenticatorBlockSignature = new Uint8Array(0);
      this.personalVaultSuperuserEncryptedStorableVaultKey = new Uint8Array(0);
      this.personalVaultSuperuserEncryptedHighSecurityVaultKey = new Uint8Array(0);
      this.personalVaultSuperuserEncryptedVaultMessagePrivateKey = new Uint8Array(0);
      this.teamVaultSuperuserEncryptedStorableVaultKey = new Uint8Array(0);
      this.teamVaultSuperuserEncryptedHighSecurityVaultKey = new Uint8Array(0);
      this.teamVaultSuperuserEncryptedVaultMessagePrivateKey = new Uint8Array(0);
      this.teamAssociatedVaultSuperuserEncryptedStorableVaultKey = new Uint8Array(0);
      this.teamAssociatedVaultSuperuserEncryptedHighSecurityVaultKey = new Uint8Array(0);
      this.teamAssociatedVaultSuperuserEncryptedVaultMessagePrivateKey = new Uint8Array(0);
      this.contactJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateOrganizationRequest, a2, b);
    }
  }
  CreateOrganizationRequest.runtime = proto3;
  CreateOrganizationRequest.typeName = "domain.CreateOrganizationRequest";
  CreateOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "icon",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 17,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 16, name: "user_profile", kind: "message", T: ProfileData },
    { no: 21, name: "admin_profile", kind: "message", T: ProfileData },
    { no: 3, name: "authenticator", kind: "message", T: AuthenticatorData },
    { no: 4, name: "legacy_admin_vault_data", kind: "message", T: VaultCreationData },
    {
      no: 5,
      name: "authenticator_block",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 6,
      name: "authenticator_block_signature",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 23, name: "admin_vault_data", kind: "message", T: VaultCreationData },
    { no: 7, name: "personal_vault_data", kind: "message", T: VaultCreationData },
    {
      no: 8,
      name: "personal_vault_superuser_encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 9,
      name: "personal_vault_superuser_encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 18,
      name: "personal_vault_superuser_encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    { no: 10, name: "team_vault_data", kind: "message", T: VaultPairCreationData },
    {
      no: 11,
      name: "team_vault_superuser_encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 12,
      name: "team_vault_superuser_encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 19,
      name: "team_vault_superuser_encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 13,
      name: "team_associated_vault_superuser_encrypted_storable_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 14,
      name: "team_associated_vault_superuser_encrypted_high_security_vault_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 20,
      name: "team_associated_vault_superuser_encrypted_vault_message_private_key",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 15,
      name: "contact_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 22, name: "parent_organization_info", kind: "message", T: CreateOrganizationRequest_ParentOrganizationInfo }
  ]);
  class CreateOrganizationRequest_ParentOrganizationInfo extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateOrganizationRequest_ParentOrganizationInfo().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateOrganizationRequest_ParentOrganizationInfo().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateOrganizationRequest_ParentOrganizationInfo().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateOrganizationRequest_ParentOrganizationInfo, a2, b);
    }
  }
  CreateOrganizationRequest_ParentOrganizationInfo.runtime = proto3;
  CreateOrganizationRequest_ParentOrganizationInfo.typeName = "domain.CreateOrganizationRequest.ParentOrganizationInfo";
  CreateOrganizationRequest_ParentOrganizationInfo.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateOrganizationResponse extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.superUserId = "";
      this.authenticatorId = "";
      this.legacyAdminVaultId = "";
      this.personalVaultId = "";
      this.teamVaultId = "";
      this.teamAssociatedVaultId = "";
      this.profileId = "";
      this.adminProfileId = "";
      this.adminVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateOrganizationResponse, a2, b);
    }
  }
  CreateOrganizationResponse.runtime = proto3;
  CreateOrganizationResponse.typeName = "domain.CreateOrganizationResponse";
  CreateOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "super_user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "legacy_admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "personal_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 7,
      name: "team_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "team_associated_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 9,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 10,
      name: "admin_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 11,
      name: "admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UpdateOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateOrganizationRequest, a2, b);
    }
  }
  UpdateOrganizationRequest.runtime = proto3;
  UpdateOrganizationRequest.typeName = "domain.UpdateOrganizationRequest";
  UpdateOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "name", kind: "message", T: StringValue },
    { no: 3, name: "icon", kind: "message", T: StringValue },
    { no: 4, name: "restrict_create_team", kind: "message", T: BoolValue },
    { no: 5, name: "auditlog_enable", kind: "message", T: BoolValue },
    { no: 11, name: "child_organization_management_enable", kind: "message", T: BoolValue },
    { no: 8, name: "restrict_personal_logins", kind: "message", T: BoolValue },
    { no: 7, name: "monitored_domains", kind: "message", T: UpdateOrganizationRequest_StringArray },
    { no: 9, name: "password_policy", kind: "message", T: StringValue },
    { no: 10, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit },
    { no: 12, name: "client_settings", kind: "message", T: StringValue }
  ]);
  class UpdateOrganizationRequest_StringArray extends Message {
    constructor(data) {
      super();
      this.value = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateOrganizationRequest_StringArray().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateOrganizationRequest_StringArray().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateOrganizationRequest_StringArray().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateOrganizationRequest_StringArray, a2, b);
    }
  }
  UpdateOrganizationRequest_StringArray.runtime = proto3;
  UpdateOrganizationRequest_StringArray.typeName = "domain.UpdateOrganizationRequest.StringArray";
  UpdateOrganizationRequest_StringArray.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9, repeated: true }
  ]);
  class UpdateOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateOrganizationResponse, a2, b);
    }
  }
  UpdateOrganizationResponse.runtime = proto3;
  UpdateOrganizationResponse.typeName = "domain.UpdateOrganizationResponse";
  UpdateOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ModifyMembersRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.createProfileOps = [];
      this.updateProfileOps = [];
      this.deleteProfileIds = [];
      this.legacyAdminVaultGenerationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyMembersRequest, a2, b);
    }
  }
  ModifyMembersRequest.runtime = proto3;
  ModifyMembersRequest.typeName = "domain.ModifyMembersRequest";
  ModifyMembersRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 7, name: "create_profile_ops", kind: "message", T: ModifyMembersRequest_CreateProfileOperation, repeated: true },
    { no: 8, name: "update_profile_ops", kind: "message", T: ModifyMembersRequest_UpdateProfileOperation, repeated: true },
    { no: 9, name: "delete_profile_ids", kind: "scalar", T: 9, repeated: true },
    { no: 5, name: "legacy_admin_vault_regenerate_data", kind: "message", T: VaultRegenerateData },
    {
      no: 10,
      name: "legacy_admin_vault_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ModifyMembersRequest_CreateProfileOperation extends Message {
    constructor(data) {
      super();
      this.isAdmin = false;
      this.email = "";
      this.createStartCodeAndSendMail = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersRequest_CreateProfileOperation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersRequest_CreateProfileOperation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersRequest_CreateProfileOperation().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyMembersRequest_CreateProfileOperation, a2, b);
    }
  }
  ModifyMembersRequest_CreateProfileOperation.runtime = proto3;
  ModifyMembersRequest_CreateProfileOperation.typeName = "domain.ModifyMembersRequest.CreateProfileOperation";
  ModifyMembersRequest_CreateProfileOperation.fields = proto3.util.newFieldList(() => [
    {
      no: 2,
      name: "is_admin",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    { no: 3, name: "personal_vault_data", kind: "message", T: VaultCreationData },
    { no: 4, name: "profile", kind: "message", T: ProfileData },
    { no: 5, name: "legacy_admin_vault_lock", kind: "message", T: VaultProfileLock$1 },
    { no: 9, name: "admin_profile_lock", kind: "message", T: ProfileProfileLock$1 },
    {
      no: 6,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 8,
      name: "create_start_code_and_send_mail",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class ModifyMembersRequest_UpdateProfileOperation extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersRequest_UpdateProfileOperation().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersRequest_UpdateProfileOperation().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersRequest_UpdateProfileOperation().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyMembersRequest_UpdateProfileOperation, a2, b);
    }
  }
  ModifyMembersRequest_UpdateProfileOperation.runtime = proto3;
  ModifyMembersRequest_UpdateProfileOperation.typeName = "domain.ModifyMembersRequest.UpdateProfileOperation";
  ModifyMembersRequest_UpdateProfileOperation.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "is_admin", kind: "message", T: BoolValue },
    { no: 4, name: "admin_profile_lock", kind: "message", T: ProfileProfileLock$1 }
  ]);
  class ModifyMembersResponse extends Message {
    constructor(data) {
      super();
      this.personalVaultIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ModifyMembersResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ModifyMembersResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ModifyMembersResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ModifyMembersResponse, a2, b);
    }
  }
  ModifyMembersResponse.runtime = proto3;
  ModifyMembersResponse.typeName = "domain.ModifyMembersResponse";
  ModifyMembersResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    { no: 2, name: "personal_vault_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class CreateServiceProfileRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateServiceProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateServiceProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateServiceProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateServiceProfileRequest, a2, b);
    }
  }
  CreateServiceProfileRequest.runtime = proto3;
  CreateServiceProfileRequest.typeName = "domain.CreateServiceProfileRequest";
  CreateServiceProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile", kind: "message", T: ProfileData },
    { no: 3, name: "downstream_admin_profile_lock", kind: "message", T: ProfileProfileLock$1 }
  ]);
  class CreateServiceProfileResponse extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateServiceProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateServiceProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateServiceProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateServiceProfileResponse, a2, b);
    }
  }
  CreateServiceProfileResponse.runtime = proto3;
  CreateServiceProfileResponse.typeName = "domain.CreateServiceProfileResponse";
  CreateServiceProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class LeaveOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LeaveOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LeaveOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LeaveOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LeaveOrganizationRequest, a2, b);
    }
  }
  LeaveOrganizationRequest.runtime = proto3;
  LeaveOrganizationRequest.typeName = "domain.LeaveOrganizationRequest";
  LeaveOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class LeaveOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LeaveOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LeaveOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LeaveOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LeaveOrganizationResponse, a2, b);
    }
  }
  LeaveOrganizationResponse.runtime = proto3;
  LeaveOrganizationResponse.typeName = "domain.LeaveOrganizationResponse";
  LeaveOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class AcceptInviteRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AcceptInviteRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AcceptInviteRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AcceptInviteRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AcceptInviteRequest, a2, b);
    }
  }
  AcceptInviteRequest.runtime = proto3;
  AcceptInviteRequest.typeName = "domain.AcceptInviteRequest";
  AcceptInviteRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class AcceptInviteResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AcceptInviteResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AcceptInviteResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AcceptInviteResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AcceptInviteResponse, a2, b);
    }
  }
  AcceptInviteResponse.runtime = proto3;
  AcceptInviteResponse.typeName = "domain.AcceptInviteResponse";
  AcceptInviteResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RedeemCouponRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.couponText = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RedeemCouponRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RedeemCouponRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RedeemCouponRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RedeemCouponRequest, a2, b);
    }
  }
  RedeemCouponRequest.runtime = proto3;
  RedeemCouponRequest.typeName = "domain.RedeemCouponRequest";
  RedeemCouponRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "coupon_text",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RedeemCouponResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RedeemCouponResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RedeemCouponResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RedeemCouponResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RedeemCouponResponse, a2, b);
    }
  }
  RedeemCouponResponse.runtime = proto3;
  RedeemCouponResponse.typeName = "domain.RedeemCouponResponse";
  RedeemCouponResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteOrganizationRequest, a2, b);
    }
  }
  DeleteOrganizationRequest.runtime = proto3;
  DeleteOrganizationRequest.typeName = "domain.DeleteOrganizationRequest";
  DeleteOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteOrganizationResponse, a2, b);
    }
  }
  DeleteOrganizationResponse.runtime = proto3;
  DeleteOrganizationResponse.typeName = "domain.DeleteOrganizationResponse";
  DeleteOrganizationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class GetSubscriptionDetailsRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetSubscriptionDetailsRequest, a2, b);
    }
  }
  GetSubscriptionDetailsRequest.runtime = proto3;
  GetSubscriptionDetailsRequest.typeName = "domain.GetSubscriptionDetailsRequest";
  GetSubscriptionDetailsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetSubscriptionDetailsResponse extends Message {
    constructor(data) {
      super();
      this.payments = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetSubscriptionDetailsResponse, a2, b);
    }
  }
  GetSubscriptionDetailsResponse.runtime = proto3;
  GetSubscriptionDetailsResponse.typeName = "domain.GetSubscriptionDetailsResponse";
  GetSubscriptionDetailsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "payments", kind: "message", T: GetSubscriptionDetailsResponse_Payment, repeated: true },
    { no: 4, name: "paddle_subscription", kind: "message", T: GetSubscriptionDetailsResponse_PaddleSubscription },
    { no: 5, name: "status", kind: "message", T: SubscriptionStatus }
  ]);
  class GetSubscriptionDetailsResponse_Payment extends Message {
    constructor(data) {
      super();
      this.receiptUrl = "";
      this.saleGrossCents = protoInt64.zero;
      this.paymentTaxCents = protoInt64.zero;
      this.currency = "";
      this.orderId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsResponse_Payment().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsResponse_Payment().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsResponse_Payment().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetSubscriptionDetailsResponse_Payment, a2, b);
    }
  }
  GetSubscriptionDetailsResponse_Payment.runtime = proto3;
  GetSubscriptionDetailsResponse_Payment.typeName = "domain.GetSubscriptionDetailsResponse.Payment";
  GetSubscriptionDetailsResponse_Payment.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "event_time", kind: "message", T: Timestamp },
    {
      no: 2,
      name: "receipt_url",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "sale_gross_cents",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 4,
      name: "payment_tax_cents",
      kind: "scalar",
      T: 3
      /* ScalarType.INT64 */
    },
    {
      no: 5,
      name: "currency",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 6,
      name: "order_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetSubscriptionDetailsResponse_PaddleSubscription extends Message {
    constructor(data) {
      super();
      this.plan = SubscriptionPlan.UNKNOWN;
      this.quantity = 0;
      this.unitPriceCents = 0;
      this.totalPriceCents = 0;
      this.currency = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetSubscriptionDetailsResponse_PaddleSubscription().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetSubscriptionDetailsResponse_PaddleSubscription().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetSubscriptionDetailsResponse_PaddleSubscription().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetSubscriptionDetailsResponse_PaddleSubscription, a2, b);
    }
  }
  GetSubscriptionDetailsResponse_PaddleSubscription.runtime = proto3;
  GetSubscriptionDetailsResponse_PaddleSubscription.typeName = "domain.GetSubscriptionDetailsResponse.PaddleSubscription";
  GetSubscriptionDetailsResponse_PaddleSubscription.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "plan", kind: "enum", T: proto3.getEnumType(SubscriptionPlan) },
    {
      no: 2,
      name: "quantity",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "unit_price_cents",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 4,
      name: "total_price_cents",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 5,
      name: "currency",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 6, name: "next_bill_date", kind: "message", T: Timestamp }
  ]);
  class RegenerateOrganizationProfileRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateOrganizationProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateOrganizationProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateOrganizationProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegenerateOrganizationProfileRequest, a2, b);
    }
  }
  RegenerateOrganizationProfileRequest.runtime = proto3;
  RegenerateOrganizationProfileRequest.typeName = "domain.RegenerateOrganizationProfileRequest";
  RegenerateOrganizationProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile", kind: "message", T: ProfileRegenerateData },
    {
      no: 3,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegenerateOrganizationProfileResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateOrganizationProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateOrganizationProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateOrganizationProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegenerateOrganizationProfileResponse, a2, b);
    }
  }
  RegenerateOrganizationProfileResponse.runtime = proto3;
  RegenerateOrganizationProfileResponse.typeName = "domain.RegenerateOrganizationProfileResponse";
  RegenerateOrganizationProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ClaimPreliminaryProfileRequest extends Message {
    constructor(data) {
      super();
      this.profileId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimPreliminaryProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimPreliminaryProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimPreliminaryProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ClaimPreliminaryProfileRequest, a2, b);
    }
  }
  ClaimPreliminaryProfileRequest.runtime = proto3;
  ClaimPreliminaryProfileRequest.typeName = "domain.ClaimPreliminaryProfileRequest";
  ClaimPreliminaryProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ClaimPreliminaryProfileResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ClaimPreliminaryProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ClaimPreliminaryProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ClaimPreliminaryProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ClaimPreliminaryProfileResponse, a2, b);
    }
  }
  ClaimPreliminaryProfileResponse.runtime = proto3;
  ClaimPreliminaryProfileResponse.typeName = "domain.ClaimPreliminaryProfileResponse";
  ClaimPreliminaryProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RegenerateAdminProfileRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateAdminProfileRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateAdminProfileRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateAdminProfileRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegenerateAdminProfileRequest, a2, b);
    }
  }
  RegenerateAdminProfileRequest.runtime = proto3;
  RegenerateAdminProfileRequest.typeName = "domain.RegenerateAdminProfileRequest";
  RegenerateAdminProfileRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile", kind: "message", T: ProfileRegenerateData },
    { no: 3, name: "admin_vault_data", kind: "message", T: VaultCreationData }
  ]);
  class RegenerateAdminProfileResponse extends Message {
    constructor(data) {
      super();
      this.adminProfileId = "";
      this.adminProfileKeyGenerationId = "";
      this.adminVaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegenerateAdminProfileResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegenerateAdminProfileResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegenerateAdminProfileResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegenerateAdminProfileResponse, a2, b);
    }
  }
  RegenerateAdminProfileResponse.runtime = proto3;
  RegenerateAdminProfileResponse.typeName = "domain.RegenerateAdminProfileResponse";
  RegenerateAdminProfileResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "admin_profile_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "admin_profile_key_generation_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "admin_vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RenewProfileStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RenewProfileStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RenewProfileStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RenewProfileStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RenewProfileStartCodeRequest, a2, b);
    }
  }
  RenewProfileStartCodeRequest.runtime = proto3;
  RenewProfileStartCodeRequest.typeName = "domain.RenewProfileStartCodeRequest";
  RenewProfileStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class RenewProfileStartCodeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RenewProfileStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RenewProfileStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RenewProfileStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RenewProfileStartCodeResponse, a2, b);
    }
  }
  RenewProfileStartCodeResponse.runtime = proto3;
  RenewProfileStartCodeResponse.typeName = "domain.RenewProfileStartCodeResponse";
  RenewProfileStartCodeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class SendStartCodeEmailRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendStartCodeEmailRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendStartCodeEmailRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendStartCodeEmailRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendStartCodeEmailRequest, a2, b);
    }
  }
  SendStartCodeEmailRequest.runtime = proto3;
  SendStartCodeEmailRequest.typeName = "domain.SendStartCodeEmailRequest";
  SendStartCodeEmailRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class SendStartCodeEmailResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendStartCodeEmailResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendStartCodeEmailResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendStartCodeEmailResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendStartCodeEmailResponse, a2, b);
    }
  }
  SendStartCodeEmailResponse.runtime = proto3;
  SendStartCodeEmailResponse.typeName = "domain.SendStartCodeEmailResponse";
  SendStartCodeEmailResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RevokeProfileStartCodeRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RevokeProfileStartCodeRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RevokeProfileStartCodeRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RevokeProfileStartCodeRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RevokeProfileStartCodeRequest, a2, b);
    }
  }
  RevokeProfileStartCodeRequest.runtime = proto3;
  RevokeProfileStartCodeRequest.typeName = "domain.RevokeProfileStartCodeRequest";
  RevokeProfileStartCodeRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class RevokeProfileStartCodeResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RevokeProfileStartCodeResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RevokeProfileStartCodeResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RevokeProfileStartCodeResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RevokeProfileStartCodeResponse, a2, b);
    }
  }
  RevokeProfileStartCodeResponse.runtime = proto3;
  RevokeProfileStartCodeResponse.typeName = "domain.RevokeProfileStartCodeResponse";
  RevokeProfileStartCodeResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class GetOrganizationDeletionInfoRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetOrganizationDeletionInfoRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetOrganizationDeletionInfoRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetOrganizationDeletionInfoRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetOrganizationDeletionInfoRequest, a2, b);
    }
  }
  GetOrganizationDeletionInfoRequest.runtime = proto3;
  GetOrganizationDeletionInfoRequest.typeName = "domain.GetOrganizationDeletionInfoRequest";
  GetOrganizationDeletionInfoRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetOrganizationDeletionInfoResponse extends Message {
    constructor(data) {
      super();
      this.organizationName = "";
      this.requestedByEmail = "";
      this.userCount = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetOrganizationDeletionInfoResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetOrganizationDeletionInfoResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetOrganizationDeletionInfoResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetOrganizationDeletionInfoResponse, a2, b);
    }
  }
  GetOrganizationDeletionInfoResponse.runtime = proto3;
  GetOrganizationDeletionInfoResponse.typeName = "domain.GetOrganizationDeletionInfoResponse";
  GetOrganizationDeletionInfoResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "requested_by_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "user_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    { no: 4, name: "requested_at", kind: "message", T: Timestamp }
  ]);
  class DeleteOrganizationWithTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationWithTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationWithTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationWithTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteOrganizationWithTokenRequest, a2, b);
    }
  }
  DeleteOrganizationWithTokenRequest.runtime = proto3;
  DeleteOrganizationWithTokenRequest.typeName = "domain.DeleteOrganizationWithTokenRequest";
  DeleteOrganizationWithTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteOrganizationWithTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteOrganizationWithTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteOrganizationWithTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteOrganizationWithTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteOrganizationWithTokenResponse, a2, b);
    }
  }
  DeleteOrganizationWithTokenResponse.runtime = proto3;
  DeleteOrganizationWithTokenResponse.typeName = "domain.DeleteOrganizationWithTokenResponse";
  DeleteOrganizationWithTokenResponse.fields = proto3.util.newFieldList(() => []);
  class RemoveOrganizationDeletionTokenRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.token = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RemoveOrganizationDeletionTokenRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RemoveOrganizationDeletionTokenRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RemoveOrganizationDeletionTokenRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RemoveOrganizationDeletionTokenRequest, a2, b);
    }
  }
  RemoveOrganizationDeletionTokenRequest.runtime = proto3;
  RemoveOrganizationDeletionTokenRequest.typeName = "domain.RemoveOrganizationDeletionTokenRequest";
  RemoveOrganizationDeletionTokenRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "token",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RemoveOrganizationDeletionTokenResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RemoveOrganizationDeletionTokenResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RemoveOrganizationDeletionTokenResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RemoveOrganizationDeletionTokenResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RemoveOrganizationDeletionTokenResponse, a2, b);
    }
  }
  RemoveOrganizationDeletionTokenResponse.runtime = proto3;
  RemoveOrganizationDeletionTokenResponse.typeName = "domain.RemoveOrganizationDeletionTokenResponse";
  RemoveOrganizationDeletionTokenResponse.fields = proto3.util.newFieldList(() => []);
  class GetBreachDataRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetBreachDataRequest, a2, b);
    }
  }
  GetBreachDataRequest.runtime = proto3;
  GetBreachDataRequest.typeName = "domain.GetBreachDataRequest";
  GetBreachDataRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetBreachDataResponse extends Message {
    constructor(data) {
      super();
      this.domains = [];
      this.totalPwnCountBillions = 0;
      this.totalBreachCount = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetBreachDataResponse, a2, b);
    }
  }
  GetBreachDataResponse.runtime = proto3;
  GetBreachDataResponse.typeName = "domain.GetBreachDataResponse";
  GetBreachDataResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "domains", kind: "message", T: GetBreachDataResponse_MonitoredDomain, repeated: true },
    { no: 2, name: "last_check_date", kind: "message", T: Timestamp },
    {
      no: 3,
      name: "total_pwn_count_billions",
      kind: "scalar",
      T: 2
      /* ScalarType.FLOAT */
    },
    {
      no: 4,
      name: "total_breach_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class GetBreachDataResponse_BreachModel extends Message {
    constructor(data) {
      super();
      this.name = "";
      this.title = "";
      this.dataClasses = [];
      this.logoPath = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse_BreachModel().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse_BreachModel().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse_BreachModel().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetBreachDataResponse_BreachModel, a2, b);
    }
  }
  GetBreachDataResponse_BreachModel.runtime = proto3;
  GetBreachDataResponse_BreachModel.typeName = "domain.GetBreachDataResponse.BreachModel";
  GetBreachDataResponse_BreachModel.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "title",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "breach_date", kind: "message", T: Timestamp },
    { no: 4, name: "added_date", kind: "message", T: Timestamp },
    { no: 5, name: "data_classes", kind: "scalar", T: 9, repeated: true },
    {
      no: 6,
      name: "logo_path",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetBreachDataResponse_Breach extends Message {
    constructor(data) {
      super();
      this.aliases = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse_Breach().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse_Breach().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse_Breach().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetBreachDataResponse_Breach, a2, b);
    }
  }
  GetBreachDataResponse_Breach.runtime = proto3;
  GetBreachDataResponse_Breach.typeName = "domain.GetBreachDataResponse.Breach";
  GetBreachDataResponse_Breach.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "model", kind: "message", T: GetBreachDataResponse_BreachModel },
    { no: 2, name: "aliases", kind: "scalar", T: 9, repeated: true }
  ]);
  class GetBreachDataResponse_MonitoredDomain extends Message {
    constructor(data) {
      super();
      this.domain = "";
      this.breaches = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetBreachDataResponse_MonitoredDomain().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetBreachDataResponse_MonitoredDomain().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetBreachDataResponse_MonitoredDomain().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetBreachDataResponse_MonitoredDomain, a2, b);
    }
  }
  GetBreachDataResponse_MonitoredDomain.runtime = proto3;
  GetBreachDataResponse_MonitoredDomain.typeName = "domain.GetBreachDataResponse.MonitoredDomain";
  GetBreachDataResponse_MonitoredDomain.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "domain",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "breaches", kind: "message", T: GetBreachDataResponse_Breach, repeated: true }
  ]);
  const OrganizationService = {
    typeName: "domain.OrganizationService",
    methods: {
      /**
       * errors:
       * - EmailTaken (20100): email address taken
       * - InvalidEmail (20101): invalid email address
       * - NotAllowedForUserType (20470)
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - UserNotFound (20400): no account matching credentials
       * - MissingAuthenticatorBlock (40430): the request is lacking a follow-up authenticator block
       * - InvalidAuthenticatorType (40460): The given authenticator is no organization authenticator
       * - InvalidOrganizationName (60430): name is empty or contains unprintable characters
       * - OrganizationInvalidContact (60431): contact is not json-formatted
       * - ProfileNotFound (70400): tried to create with profile when account is not profile enabled
       * - ProfileAlreadyEnabled (70401): tried to create without profile when account is profile enabled
       * - ClientOutdated (10426): tried to create admin profile org with legacy admin vault
       * - Internal (10500): Internal server error
       *
       * @generated from rpc domain.OrganizationService.Create
       */
      create: {
        name: "Create",
        I: CreateOrganizationRequest,
        O: CreateOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - InvalidOrganizationName (60430): name is empty or contains unprintable characters
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.Update
       */
      update: {
        name: "Update",
        I: UpdateOrganizationRequest,
        O: UpdateOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - EmailTaken (20100): email address taken
       * - InvalidEmail (20101): invalid email address
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - UserNotFound (20400): A user added to the organization was not found
       * - UserAlreadyInOrganization (60401): A user added to the organization is already in it
       * - OrganizationInsufficientAccess (60100): Tried to manipulate other members without admin access
       * - OrganizationMissingAdmin (60410): after the call there would be no admin left
       * - NotAllowedForUserType (20470): Tried to manipulate a non-default user
       * - VaultOutOfSync (50100)
       * - MissingVault (50420): Tried to add admin without admin vault regenerate data
       * - NotAllowedForProfile (70433): tried to demote an organization manager
       * - AuditlogSubmissionError (90500)
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.ModifyMembers
       */
      modifyMembers: {
        name: "ModifyMembers",
        I: ModifyMembersRequest,
        O: ModifyMembersResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - BadRequest (10400): called on an org without admin profiles
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - NotAllowedForOrganization (60101): organization must have admin profiles enabled
       * - OrganizationNotFound (60400): not member of the given organization
       * - UserAlreadyInOrganization (60401): A service user already exists in this organization
       * - OrganizationInsufficientAccess (60100)
       * - MissingProfileProfileLock (70412)
       * - AuditlogSubmissionError (90500)
       * - Internal (10500)
       *
       * @generated from rpc domain.OrganizationService.CreateServiceProfile
       */
      createServiceProfile: {
        name: "CreateServiceProfile",
        I: CreateServiceProfileRequest,
        O: CreateServiceProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationNotFound (60400): not member of the given organization
       * - OrganizationMissingAdmin (60410): after the call there would be no admin left
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.Leave
       */
      leave: {
        name: "Leave",
        I: LeaveOrganizationRequest,
        O: LeaveOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.AcceptInvite
       */
      acceptInvite: {
        name: "AcceptInvite",
        I: AcceptInviteRequest,
        O: AcceptInviteResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - CouponInvalid (60440)
       * - CouponAlreadyRedeemed (60441)
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.RedeemCoupon
       */
      redeemCoupon: {
        name: "RedeemCoupon",
        I: RedeemCouponRequest,
        O: RedeemCouponResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): not logged in
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.Delete
       */
      delete: {
        name: "Delete",
        I: DeleteOrganizationRequest,
        O: DeleteOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * - MissingCredentials (30100): not logged in
       * - UserNotFound (20400): no account matching credentials
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - OrganizationNotFound (60400): not member of the given organization
       * - Internal (10500):
       *
       * @generated from rpc domain.OrganizationService.GetSubscriptionDetails
       */
      getSubscriptionDetails: {
        name: "GetSubscriptionDetails",
        I: GetSubscriptionDetailsRequest,
        O: GetSubscriptionDetailsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserNotFound (20400): user to assign profile was not found
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - UserAlreadyInOrganization (60401): user to assign profile is already in organization
       * - OtherProfileEmailConflicts (60450): another profile with this email address exists
       * - ProfileNotFound (70400): if profile not found, or is user's own profile
       * - ProfileOutOfSync (70400): if KeyGenerationId is not the null uuid, or authenticator locks are not empty
       * - MissingProfileAuthenticatorLock (70410)
       * - AuditlogSubmissionError (90500)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RegenerateOrganizationProfile
       */
      regenerateOrganizationProfile: {
        name: "RegenerateOrganizationProfile",
        I: RegenerateOrganizationProfileRequest,
        O: RegenerateOrganizationProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - BadRequest (10400): if authenticator locks are not empty and org is admin profile enabled
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - VaultOutOfSync (50100)
       * - EmptyCommit (50200)
       * - MissingVault (50420): admin vault creation data is missing
       * - VaultOutOfSync (50100): admin vault already exists, but creation data was provided
       * - MissingVaultProfileLock (50411): if vault profile locks do not match all organization vaults
       * - OrganizationInsufficientAccess (60100)
       * - ProfileOutOfSync (70400): if KeyGenerationId does not match / is the null uuid for creation
       * - Internal (10500)
       *
       * @generated from rpc domain.OrganizationService.RegenerateAdminProfile
       */
      regenerateAdminProfile: {
        name: "RegenerateAdminProfile",
        I: RegenerateAdminProfileRequest,
        O: RegenerateAdminProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - ProfileNotFound (70400): if profile not found or is not free
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RenewProfileStartCode
       */
      renewProfileStartCode: {
        name: "RenewProfileStartCode",
        I: RenewProfileStartCodeRequest,
        O: RenewProfileStartCodeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - ProfileNotFound (70400): if profile not found, is not free or has no start code
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.SendStartCodeEmail
       */
      sendStartCodeEmail: {
        name: "SendStartCodeEmail",
        I: SendStartCodeEmailRequest,
        O: SendStartCodeEmailResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationInsufficientAccess (60100): not admin of the given organzation
       * - ProfileNotFound (70400): if profile not found or is not free
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RevokeProfileStartCode
       */
      revokeProfileStartCode: {
        name: "RevokeProfileStartCode",
        I: RevokeProfileStartCodeRequest,
        O: RevokeProfileStartCodeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       * - InvalidOrganizationDeletionToken (60460)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.GetDeletionInfo
       */
      getDeletionInfo: {
        name: "GetDeletionInfo",
        I: GetOrganizationDeletionInfoRequest,
        O: GetOrganizationDeletionInfoResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       * - InvalidOrganizationDeletionToken (60460)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.DeleteWithToken
       */
      deleteWithToken: {
        name: "DeleteWithToken",
        I: DeleteOrganizationWithTokenRequest,
        O: DeleteOrganizationWithTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       * - InvalidOrganizationDeletionToken (60460)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.OrganizationService.RemoveDeletionToken
       */
      removeDeletionToken: {
        name: "RemoveDeletionToken",
        I: RemoveOrganizationDeletionTokenRequest,
        O: RemoveOrganizationDeletionTokenResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - OrganizationNotFound (60400)
       *
       * @generated from rpc domain.OrganizationService.GetBreachData
       */
      getBreachData: {
        name: "GetBreachData",
        I: GetBreachDataRequest,
        O: GetBreachDataResponse,
        kind: MethodKind.Unary
      }
    }
  };
  const ProfileService = {
    typeName: "domain.ProfileService",
    methods: {
      /**
       * errors:
       * - EmailTaken (20100): email address taken
       * - InvalidEmail (20101): invalid email address
       * - NotAllowedForUserType (20470)
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): account is not profile enabled
       * - ProfileAlreadyEnabled (70401): private profile already exists
       * - MissingProfileAuthenticatorLock (70410): a profile lock is missing for an authenticator
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.CreatePrivate
       */
      createPrivate: {
        name: "CreatePrivate",
        I: CreatePrivateProfileRequest,
        O: CreatePrivateProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): profile could not be found by id
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.DeletePrivate
       */
      deletePrivate: {
        name: "DeletePrivate",
        I: DeletePrivateProfileRequest,
        O: DeletePrivateProfileResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultOutOfSync (50100): generation_id does not match for some vault
       * - VaultNotFound (50400): some vault profile lock had an unknown vault_id
       * - MissingLock (70510): missing locks for one or more authenticators
       * - ProfileNotFound (70400): some profile could not be found by id
       * - MissingProfileLock (70410): missing profile locks for one or more authenticators
       * - ProfileOutOfSync (70411): key_generation_id does not match for some profile
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.Regenerate
       */
      regenerate: {
        name: "Regenerate",
        I: RegenerateProfilesRequest,
        O: RegenerateProfilesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - ProfileNotFound (70400): if any profile id could not be found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ProfileService.List
       */
      list: {
        name: "List",
        I: ListProfilesRequest,
        O: ListProfilesResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - InvalidEmail (20101)
       * - EmailTaken (20100)
       * - ProfileNotFound (70400): profile doesn't exist or can't have an email address
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.RequestEmailChange
       */
      requestEmailChange: {
        name: "RequestEmailChange",
        I: ProfileRequestEmailChangeRequest,
        O: ProfileRequestEmailChangeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - PermissionDenied (10100): email change may not be cancelled (in semi-verified state)
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - ProfileNotFound (70400): profile doesn't exist or can't have an email address
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.CancelEmailChange
       */
      cancelEmailChange: {
        name: "CancelEmailChange",
        I: ProfileCancelEmailChangeRequest,
        O: ProfileCancelEmailChangeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - PermissionDenied (10100): the credentials provided didn't match the verification token
       * - InvalidVerificationToken (20460): the verification token provided is invalid or outdated or the email has been verified for another account
       * - Internal (10500): internal server error
       * This endpoint can be called with or without credentials. If credentials are given, they must
       * match with the verification token.
       *
       * @generated from rpc domain.ProfileService.VerifyEmailAddress
       */
      verifyEmailAddress: {
        name: "VerifyEmailAddress",
        I: VerifyEmailAddressRequest,
        O: VerifyEmailAddressResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - ProfileNotFound (70400): profile not found, or is not an organization profile
       * - ProfileAlreadyConnected (70402)
       * - ProfileStartCodeInactive (70403)
       * - UserAlreadyInOrganization (60401)
       * - StartCodeInvalid (70430)
       * - StartCodeBlocked (70431)
       * - EmailTaken (20100)
       * - AuditlogSubmissionError (90500)
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.ClaimWithStartCode
       */
      claimWithStartCode: {
        name: "ClaimWithStartCode",
        I: ClaimWithStartCodeRequest,
        O: ClaimWithStartCodeResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - ProfileNotFound (70400)
       * - Internal (10500)
       *
       * @generated from rpc domain.ProfileService.GetProfileInfo
       */
      getProfileInfo: {
        name: "GetProfileInfo",
        I: GetProfileInfoRequest,
        O: GetProfileInfoResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidEmail (20101)
       * - EmailInviteNotActive (20106)
       * - ProfileNotFound (70400)
       * - StartCodeInvalid (70430)
       * - StartCodeBlocked (70431)
       * - EmailInviteNotActive (20106)
       *
       * @generated from rpc domain.ProfileService.CheckStartCode
       */
      checkStartCode: {
        name: "CheckStartCode",
        I: CheckProfileStartCodeRequest,
        O: CheckProfileStartCodeResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class DeleteSessionRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteSessionRequest, a2, b);
    }
  }
  DeleteSessionRequest.runtime = proto3;
  DeleteSessionRequest.typeName = "domain.DeleteSessionRequest";
  DeleteSessionRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class DeleteSessionResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteSessionResponse, a2, b);
    }
  }
  DeleteSessionResponse.runtime = proto3;
  DeleteSessionResponse.typeName = "domain.DeleteSessionResponse";
  DeleteSessionResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class CreateSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.encryptedSecret = new Uint8Array(0);
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateSessionUnlockRequest, a2, b);
    }
  }
  CreateSessionUnlockRequest.runtime = proto3;
  CreateSessionUnlockRequest.typeName = "domain.CreateSessionUnlockRequest";
  CreateSessionUnlockRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 4, name: "max_expires_at", kind: "message", T: Timestamp }
  ]);
  class CreateSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateSessionUnlockResponse, a2, b);
    }
  }
  CreateSessionUnlockResponse.runtime = proto3;
  CreateSessionUnlockResponse.typeName = "domain.CreateSessionUnlockResponse";
  CreateSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.onlyPendingRequest = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteSessionUnlockRequest, a2, b);
    }
  }
  DeleteSessionUnlockRequest.runtime = proto3;
  DeleteSessionUnlockRequest.typeName = "domain.DeleteSessionUnlockRequest";
  DeleteSessionUnlockRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "only_pending_request",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class DeleteSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteSessionUnlockResponse, a2, b);
    }
  }
  DeleteSessionUnlockResponse.runtime = proto3;
  DeleteSessionUnlockResponse.typeName = "domain.DeleteSessionUnlockResponse";
  DeleteSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RequestSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RequestSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RequestSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RequestSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RequestSessionUnlockRequest, a2, b);
    }
  }
  RequestSessionUnlockRequest.runtime = proto3;
  RequestSessionUnlockRequest.typeName = "domain.RequestSessionUnlockRequest";
  RequestSessionUnlockRequest.fields = proto3.util.newFieldList(() => []);
  class RequestSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RequestSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RequestSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RequestSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RequestSessionUnlockResponse, a2, b);
    }
  }
  RequestSessionUnlockResponse.runtime = proto3;
  RequestSessionUnlockResponse.typeName = "domain.RequestSessionUnlockResponse";
  RequestSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class ExtendSessionUnlockRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ExtendSessionUnlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ExtendSessionUnlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ExtendSessionUnlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ExtendSessionUnlockRequest, a2, b);
    }
  }
  ExtendSessionUnlockRequest.runtime = proto3;
  ExtendSessionUnlockRequest.typeName = "domain.ExtendSessionUnlockRequest";
  ExtendSessionUnlockRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "last_user_activity", kind: "message", T: Timestamp }
  ]);
  class ExtendSessionUnlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ExtendSessionUnlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ExtendSessionUnlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ExtendSessionUnlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ExtendSessionUnlockResponse, a2, b);
    }
  }
  ExtendSessionUnlockResponse.runtime = proto3;
  ExtendSessionUnlockResponse.typeName = "domain.ExtendSessionUnlockResponse";
  ExtendSessionUnlockResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class SendSessionMessageRequest extends Message {
    constructor(data) {
      super();
      this.messages = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendSessionMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendSessionMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendSessionMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendSessionMessageRequest, a2, b);
    }
  }
  SendSessionMessageRequest.runtime = proto3;
  SendSessionMessageRequest.typeName = "domain.SendSessionMessageRequest";
  SendSessionMessageRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "messages", kind: "message", T: SendSessionMessageRequest_Message, repeated: true }
  ]);
  class SendSessionMessageRequest_Message extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.payload = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendSessionMessageRequest_Message().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendSessionMessageRequest_Message().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendSessionMessageRequest_Message().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendSessionMessageRequest_Message, a2, b);
    }
  }
  SendSessionMessageRequest_Message.runtime = proto3;
  SendSessionMessageRequest_Message.typeName = "domain.SendSessionMessageRequest.Message";
  SendSessionMessageRequest_Message.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class SendSessionMessageResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendSessionMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendSessionMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendSessionMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendSessionMessageResponse, a2, b);
    }
  }
  SendSessionMessageResponse.runtime = proto3;
  SendSessionMessageResponse.typeName = "domain.SendSessionMessageResponse";
  SendSessionMessageResponse.fields = proto3.util.newFieldList(() => []);
  class UpdateSessionRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.fieldsToUpdate = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateSessionRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateSessionRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateSessionRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateSessionRequest, a2, b);
    }
  }
  UpdateSessionRequest.runtime = proto3;
  UpdateSessionRequest.typeName = "domain.UpdateSessionRequest";
  UpdateSessionRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "fields_to_update", kind: "enum", T: proto3.getEnumType(SyncUpdateField), repeated: true },
    { no: 3, name: "client_settings", kind: "message", T: StringValue },
    { no: 4, name: "enabled_profiles", kind: "message", T: UpdateSessionRequest_EnabledProfiles },
    { no: 5, name: "unlock_time_limit", kind: "message", T: UnlockTimeLimit },
    { no: 6, name: "fcm_device_token", kind: "message", T: StringValue }
  ]);
  class UpdateSessionRequest_EnabledProfiles extends Message {
    constructor(data) {
      super();
      this.profileIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateSessionRequest_EnabledProfiles().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateSessionRequest_EnabledProfiles().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateSessionRequest_EnabledProfiles().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateSessionRequest_EnabledProfiles, a2, b);
    }
  }
  UpdateSessionRequest_EnabledProfiles.runtime = proto3;
  UpdateSessionRequest_EnabledProfiles.typeName = "domain.UpdateSessionRequest.EnabledProfiles";
  UpdateSessionRequest_EnabledProfiles.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "profile_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class UpdateSessionResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UpdateSessionResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UpdateSessionResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UpdateSessionResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UpdateSessionResponse, a2, b);
    }
  }
  UpdateSessionResponse.runtime = proto3;
  UpdateSessionResponse.typeName = "domain.UpdateSessionResponse";
  UpdateSessionResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class SetClientSettingsRequest extends Message {
    constructor(data) {
      super();
      this.sessionId = "";
      this.clientSettings = "";
      this.fieldsToUpdate = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetClientSettingsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetClientSettingsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetClientSettingsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SetClientSettingsRequest, a2, b);
    }
  }
  SetClientSettingsRequest.runtime = proto3;
  SetClientSettingsRequest.typeName = "domain.SetClientSettingsRequest";
  SetClientSettingsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "client_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "fields_to_update", kind: "enum", T: proto3.getEnumType(SyncUpdateField), repeated: true }
  ]);
  class SetClientSettingsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SetClientSettingsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SetClientSettingsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SetClientSettingsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SetClientSettingsResponse, a2, b);
    }
  }
  SetClientSettingsResponse.runtime = proto3;
  SetClientSettingsResponse.typeName = "domain.SetClientSettingsResponse";
  SetClientSettingsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  const SessionService = {
    typeName: "domain.SessionService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session_id not in database
       * - PermissionDenied (10100) : session does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.DeleteSession
       */
      deleteSession: {
        name: "DeleteSession",
        I: DeleteSessionRequest,
        O: DeleteSessionResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - InvalidTimeout (20420): expires_at ist already expired
       * - AuthenticatorNotFound (40400): authenticator does not belong to user
       * - SessionNotFound (20410): session does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.CreateSessionUnlock
       */
      createSessionUnlock: {
        name: "CreateSessionUnlock",
        I: CreateSessionUnlockRequest,
        O: CreateSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.DeleteSessionUnlock
       */
      deleteSessionUnlock: {
        name: "DeleteSessionUnlock",
        I: DeleteSessionUnlockRequest,
        O: DeleteSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.RequestSessionUnlock
       */
      requestSessionUnlock: {
        name: "RequestSessionUnlock",
        I: RequestSessionUnlockRequest,
        O: RequestSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotFound (20410)
       * - SessionNotUnlocked (20431)
       * - Internal (10500)
       *
       * @generated from rpc domain.SessionService.ExtendSessionUnlock
       */
      extendSessionUnlock: {
        name: "ExtendSessionUnlock",
        I: ExtendSessionUnlockRequest,
        O: ExtendSessionUnlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * TODO Note: currently only sends FCM messages, thus only works for authenticator sessions
       * Note: This call does not throw an error even if no messages was actually sent.
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.SendSessionMessage
       */
      sendSessionMessage: {
        name: "SendSessionMessage",
        I: SendSessionMessageRequest,
        O: SendSessionMessageResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - MalformedClientSettings (20480): the client settings are not valid JSON
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.Update
       */
      update: {
        name: "Update",
        I: UpdateSessionRequest,
        O: UpdateSessionResponse,
        kind: MethodKind.Unary
      },
      /**
       * deprecated, use UpdateSession endpoint
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - MalformedClientSettings (20480): the client settings are not valid JSON
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SessionService.SetClientSettings
       */
      setClientSettings: {
        name: "SetClientSettings",
        I: SetClientSettingsRequest,
        O: SetClientSettingsResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class PreviewShareLinkRequest extends Message {
    constructor(data) {
      super();
      this.shareLinkId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PreviewShareLinkRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PreviewShareLinkRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PreviewShareLinkRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(PreviewShareLinkRequest, a2, b);
    }
  }
  PreviewShareLinkRequest.runtime = proto3;
  PreviewShareLinkRequest.typeName = "domain.PreviewShareLinkRequest";
  PreviewShareLinkRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "share_link_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class PreviewShareLinkResponse extends Message {
    constructor(data) {
      super();
      this.encryptedPayload = new Uint8Array(0);
      this.senderEmail = "";
      this.organizationName = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new PreviewShareLinkResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new PreviewShareLinkResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new PreviewShareLinkResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(PreviewShareLinkResponse, a2, b);
    }
  }
  PreviewShareLinkResponse.runtime = proto3;
  PreviewShareLinkResponse.typeName = "domain.PreviewShareLinkResponse";
  PreviewShareLinkResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "sender_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowShareLinkRequest extends Message {
    constructor(data) {
      super();
      this.shareLinkId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowShareLinkRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowShareLinkRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowShareLinkRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ShowShareLinkRequest, a2, b);
    }
  }
  ShowShareLinkRequest.runtime = proto3;
  ShowShareLinkRequest.typeName = "domain.ShowShareLinkRequest";
  ShowShareLinkRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "share_link_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class ShowShareLinkResponse extends Message {
    constructor(data) {
      super();
      this.encryptedPayload = new Uint8Array(0);
      this.encryptedProtectedSecret = new Uint8Array(0);
      this.senderEmail = "";
      this.organizationName = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new ShowShareLinkResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new ShowShareLinkResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new ShowShareLinkResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(ShowShareLinkResponse, a2, b);
    }
  }
  ShowShareLinkResponse.runtime = proto3;
  ShowShareLinkResponse.typeName = "domain.ShowShareLinkResponse";
  ShowShareLinkResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_payload",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "encrypted_protected_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 3,
      name: "sender_email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "organization_name",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  const ShareLinkService = {
    typeName: "domain.ShareLinkService",
    methods: {
      /**
       * errors:
       * - ShareLinkNotFound (110400): share link not found or already used
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ShareLinkService.Preview
       */
      preview: {
        name: "Preview",
        I: PreviewShareLinkRequest,
        O: PreviewShareLinkResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - ShareLinkNotFound (110400): share link not found or already used
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.ShareLinkService.Show
       */
      show: {
        name: "Show",
        I: ShowShareLinkRequest,
        O: ShowShareLinkResponse,
        kind: MethodKind.Unary
      }
    }
  };
  const SupportService = {
    typeName: "domain.SupportService",
    methods: {
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - OrganizationNotFound (60400): not member of the given organization
       * - ProfileNotFound (): not a profile of this user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SupportService.SendMessage
       */
      sendMessage: {
        name: "SendMessage",
        I: SendMessageRequest,
        O: SendMessageResponse,
        kind: MethodKind.Unary
      },
      /**
       * @generated from rpc domain.SupportService.ReportPage
       */
      reportPage: {
        name: "ReportPage",
        I: ReportPageRequest,
        O: ReportPageResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class StreamingSyncRequest extends Message {
    constructor(data) {
      super();
      this.resetAndRequestSessionUnlock = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new StreamingSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new StreamingSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new StreamingSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(StreamingSyncRequest, a2, b);
    }
  }
  StreamingSyncRequest.runtime = proto3;
  StreamingSyncRequest.typeName = "domain.StreamingSyncRequest";
  StreamingSyncRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "reset_and_request_session_unlock",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class LongPollSyncRequest extends Message {
    constructor(data) {
      super();
      this.resetAndRequestSessionUnlock = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new LongPollSyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new LongPollSyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new LongPollSyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(LongPollSyncRequest, a2, b);
    }
  }
  LongPollSyncRequest.runtime = proto3;
  LongPollSyncRequest.typeName = "domain.LongPollSyncRequest";
  LongPollSyncRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "reset_and_request_session_unlock",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  class SyncRequest extends Message {
    constructor(data) {
      super();
      this.fcmMessageId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncRequest, a2, b);
    }
  }
  SyncRequest.runtime = proto3;
  SyncRequest.typeName = "domain.SyncRequest";
  SyncRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "fcm_message_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SyncResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SyncResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SyncResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SyncResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SyncResponse, a2, b);
    }
  }
  SyncResponse.runtime = proto3;
  SyncResponse.typeName = "domain.SyncResponse";
  SyncResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  const SyncService = {
    typeName: "domain.SyncService",
    methods: {
      /**
       * The StreamingSync call is an event stream that will send a SyncResponse to the client whenever
       * updates are available. This only includes updates that originate from a different client-id
       * than the StreamingSync call.
       *
       * This call takes an optional request_session_unlock parameter, which requests the session to be
       * unlocked if set. This allows clients to refresh their StreamingSync connection at the same time
       * as requesting an unlock, which is a typical initiation point for user interaction.
       *
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Timeout (10200): timed out
       *
       * @generated from rpc domain.SyncService.StreamingSync
       */
      streamingSync: {
        name: "StreamingSync",
        I: StreamingSyncRequest,
        O: SyncResponse,
        kind: MethodKind.ServerStreaming
      },
      /**
       * The Sync call is a single unary request for a SyncResponse, but returns only once the user
       * syncVersion is bigger than the client-specified one.
       *
       * This call takes an optional request_session_unlock parameter, as above.
       *
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - SessionNotFound (20410): session not in database or does not belong to user
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SyncService.LongPollSync
       */
      longPollSync: {
        name: "LongPollSync",
        I: LongPollSyncRequest,
        O: SyncResponse,
        kind: MethodKind.Unary
      },
      /**
       * The Sync call is a single unary request for a SyncResponse.
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.SyncService.Sync
       */
      sync: {
        name: "Sync",
        I: SyncRequest,
        O: SyncResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class UserConfirmationData extends Message {
    constructor(data) {
      super();
      this.type = UserConfirmationType.UNKNOWN;
      this.vaultId = "";
      this.loginId = "";
      this.profileId = "";
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UserConfirmationData().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UserConfirmationData().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UserConfirmationData().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UserConfirmationData, a2, b);
    }
  }
  UserConfirmationData.runtime = proto3;
  UserConfirmationData.typeName = "domain.UserConfirmationData";
  UserConfirmationData.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(UserConfirmationType) },
    {
      no: 2,
      name: "vaultId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "loginId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "profileId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 5,
      name: "organizationId",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CreateUserConfirmationRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateUserConfirmationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateUserConfirmationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateUserConfirmationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateUserConfirmationRequest, a2, b);
    }
  }
  CreateUserConfirmationRequest.runtime = proto3;
  CreateUserConfirmationRequest.typeName = "domain.CreateUserConfirmationRequest";
  CreateUserConfirmationRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: UserConfirmationData }
  ]);
  class CreateUserConfirmationResponse extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.webauthnOptionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateUserConfirmationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateUserConfirmationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateUserConfirmationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateUserConfirmationResponse, a2, b);
    }
  }
  CreateUserConfirmationResponse.runtime = proto3;
  CreateUserConfirmationResponse.typeName = "domain.CreateUserConfirmationResponse";
  CreateUserConfirmationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate },
    {
      no: 2,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 3,
      name: "webauthn_options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetUserConfirmationRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetUserConfirmationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetUserConfirmationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetUserConfirmationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetUserConfirmationRequest, a2, b);
    }
  }
  GetUserConfirmationRequest.runtime = proto3;
  GetUserConfirmationRequest.typeName = "domain.GetUserConfirmationRequest";
  GetUserConfirmationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class GetUserConfirmationResponse extends Message {
    constructor(data) {
      super();
      this.requestingSessionId = "";
      this.fallbackString = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new GetUserConfirmationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new GetUserConfirmationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new GetUserConfirmationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(GetUserConfirmationResponse, a2, b);
    }
  }
  GetUserConfirmationResponse.runtime = proto3;
  GetUserConfirmationResponse.typeName = "domain.GetUserConfirmationResponse";
  GetUserConfirmationResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "requesting_session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "data", kind: "message", T: UserConfirmationData },
    {
      no: 3,
      name: "fallback_string",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SendUserConfirmationResultRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      this.type = UserConfirmationResultType.OPEN;
      this.webauthnResponseJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendUserConfirmationResultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendUserConfirmationResultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendUserConfirmationResultRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendUserConfirmationResultRequest, a2, b);
    }
  }
  SendUserConfirmationResultRequest.runtime = proto3;
  SendUserConfirmationResultRequest.typeName = "domain.SendUserConfirmationResultRequest";
  SendUserConfirmationResultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(UserConfirmationResultType) },
    {
      no: 3,
      name: "webauthn_response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class SendUserConfirmationResultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new SendUserConfirmationResultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new SendUserConfirmationResultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new SendUserConfirmationResultResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(SendUserConfirmationResultResponse, a2, b);
    }
  }
  SendUserConfirmationResultResponse.runtime = proto3;
  SendUserConfirmationResultResponse.typeName = "domain.SendUserConfirmationResultResponse";
  SendUserConfirmationResultResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class RetrieveUserConfirmationResultRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RetrieveUserConfirmationResultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RetrieveUserConfirmationResultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RetrieveUserConfirmationResultRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RetrieveUserConfirmationResultRequest, a2, b);
    }
  }
  RetrieveUserConfirmationResultRequest.runtime = proto3;
  RetrieveUserConfirmationResultRequest.typeName = "domain.RetrieveUserConfirmationResultRequest";
  RetrieveUserConfirmationResultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RetrieveUserConfirmationResultResponse extends Message {
    constructor(data) {
      super();
      this.resultType = UserConfirmationResultType.OPEN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RetrieveUserConfirmationResultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RetrieveUserConfirmationResultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RetrieveUserConfirmationResultResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RetrieveUserConfirmationResultResponse, a2, b);
    }
  }
  RetrieveUserConfirmationResultResponse.runtime = proto3;
  RetrieveUserConfirmationResultResponse.typeName = "domain.RetrieveUserConfirmationResultResponse";
  RetrieveUserConfirmationResultResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "result_type", kind: "enum", T: proto3.getEnumType(UserConfirmationResultType) }
  ]);
  class CancelUserConfirmationRequest extends Message {
    constructor(data) {
      super();
      this.id = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CancelUserConfirmationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CancelUserConfirmationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CancelUserConfirmationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CancelUserConfirmationRequest, a2, b);
    }
  }
  CancelUserConfirmationRequest.runtime = proto3;
  CancelUserConfirmationRequest.typeName = "domain.CancelUserConfirmationRequest";
  CancelUserConfirmationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class CancelUserConfirmationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CancelUserConfirmationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CancelUserConfirmationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CancelUserConfirmationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CancelUserConfirmationResponse, a2, b);
    }
  }
  CancelUserConfirmationResponse.runtime = proto3;
  CancelUserConfirmationResponse.typeName = "domain.CancelUserConfirmationResponse";
  CancelUserConfirmationResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  const UserConfirmationService = {
    typeName: "domain.UserConfirmationService",
    methods: {
      /**
       * errors:
       * - BadRequest (10400): user confirmation data is invalid
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.Create
       */
      create: {
        name: "Create",
        I: CreateUserConfirmationRequest,
        O: CreateUserConfirmationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserConfirmationNotFound (120400)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.Get
       */
      get: {
        name: "Get",
        I: GetUserConfirmationRequest,
        O: GetUserConfirmationResponse,
        kind: MethodKind.Unary
      },
      /**
       * Restricted to authenticator sessions, unless called with webauthn_credential_data filled.
       * errors:
       * - BadRequest (10400): invalid result type was sent, or by session that is not self unlocking
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserConfirmationNotFound (120400)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.SendResult
       */
      sendResult: {
        name: "SendResult",
        I: SendUserConfirmationResultRequest,
        O: SendUserConfirmationResultResponse,
        kind: MethodKind.Unary
      },
      /**
       * Restricted to session which created the UserConfirmation. Calling this endpoint clears the
       * UserConfirmation on the backend as well.
       * errors:
       * - BadRequest (10400): user confirmation did not have a result yet, or did not belong to session
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - UserConfirmationNotFound (120400)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.RetrieveResult
       */
      retrieveResult: {
        name: "RetrieveResult",
        I: RetrieveUserConfirmationResultRequest,
        O: RetrieveUserConfirmationResultResponse,
        kind: MethodKind.Unary
      },
      /**
       * Restricted to session which created the UserConfirmation. This endpoint is idempotent, and
       * returns success if a confirmation was already cancelled or resolved.
       * errors:
       * - BadRequest (10400): user confirmation did not belong to session
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.UserConfirmationService.Cancel
       */
      cancel: {
        name: "Cancel",
        I: CancelUserConfirmationRequest,
        O: CancelUserConfirmationResponse,
        kind: MethodKind.Unary
      }
    }
  };
  const VaultService = {
    typeName: "domain.VaultService",
    methods: {
      /**
       * errors:
       * - BadRequest (10400): trying to update share link from another vault
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400)
       * - InvalidUpdateTime (50430): invalid update time
       * - VaultDirty (50450): vault needs to be regenerated before commit can be made (is flagged dirty)
       * - EmptyCommit (50200): commit blob is empty
       * - PermissionDenied (10100): insufficient permissions
       * - VaultOutOfSync (50100): latest_commit_id does not match, or generation_id of message does not match
       * - NotAllowedForVault (50110): target vault of vault message not valid
       * - MissingVaultMessagePublicKey (50461): the vault has no message public key, but it is required for the operation
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.CreateCommit
       */
      createCommit: {
        name: "CreateCommit",
        I: CreateCommitRequest,
        O: CreateCommitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400): vault not found
       * - EmptyCommit (50200): commit blob is empty
       * - PermissionDenied (10100): insufficient permissions
       * - VaultOutOfSync (50100): latest_commit_id does not match, or generation_id of message does not match
       * - NotAllowedForVault (50110): target vault of vault message not valid
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.CreateGeneration
       */
      createGeneration: {
        name: "CreateGeneration",
        I: CreateGenerationRequest,
        O: CreateGenerationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400): vault not found
       * - PermissionDenied (10100): insufficient permissions
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.ListCommits
       */
      listCommits: {
        name: "ListCommits",
        I: ListCommitsRequest,
        O: ListCommitsResponse,
        kind: MethodKind.Unary
      },
      /**
       * Create creates a new vault for the authenticated user.
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - UserNotFound (20400): user not found
       * - InvalidVaultType (50431): given vault types are not allowed
       * - OrganizationInsufficientAccess (60100): user may not create team in specified organization
       * - OrganizationNotFound (60400): organization does not exist or user is not a member
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.CreateTeam
       */
      createTeam: {
        name: "CreateTeam",
        I: CreateTeamRequest,
        O: CreateTeamResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - VaultNotFound (50400): vault not found
       * - PermissionDenied (10100): insufficient permissions
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.DeleteTeam
       */
      deleteTeam: {
        name: "DeleteTeam",
        I: DeleteTeamRequest,
        O: DeleteTeamResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - UserNotFound (20400): one of the users to add was not found
       * - NotAllowedForUserType (20470): tried to add/remove an organization user
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - NotAllowedForVault (50110): tried to change users on a personal vault
       * - VaultNotFound (50400): vault not found or associated vault id does not match
       * - EmptyCommit (50200): commit blob is empty
       * - InvalidUpdateTime (50430): invalid update time
       * - VaultOutOfSync (50100): latest_commit_id, generation_id or assoc_generation_id does not match
       * - MissingLock (50410): a lock is missing for regneration or no keks were provided for a new authenticator
       * - MissingVault (50420): missing associated regenerate data
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.VaultService.ModifyTeamUsers
       */
      modifyTeamUsers: {
        name: "ModifyTeamUsers",
        I: ModifyTeamUsersRequest,
        O: ModifyTeamUsersResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100): missing credentials
       * - InvalidCredentials (30420): the credentials provided are invalid (e.g. session was deleted)
       * - MissingVaultAuthenticatorLock (50410): a vault authenticator lock is missing
       * - MissingVault (50420): missing VaultPairCreationData
       * - MissingEncryptedVaultMessagePrivateKey (50460): a lock is missing the encrypted private key
       * - MissingVaultMessagePublicKey (50461): no message public key was provided
       * - VaultInboxSlugInvalid (50470): the inbox slug is invalid
       * - VaultInboxSlugTaken (50471): the inbox slug is already in use
       * - OrganizationInsufficientAccess (60100): not allowed to create vaults in organization
       * - OrganizationNotFound (60400): organization not found or no access
       * - ProfileNotFound (70400): the profile was not found for the user
       * - ProfileAlreadyEnabled (70401): got authenticatelocks for profile-enabled user
       * - ProfileOutOfSync (70411): ProfileLock does not have curren KeyGenerationId
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.CreateInboxVault
       */
      createInboxVault: {
        name: "CreateInboxVault",
        I: CreateInboxVaultRequest,
        O: CreateInboxVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - PermissionDenied (10100): no access to the vault
       * - NotAllowedForVault (50110): specified vault is not an inbox Vault
       * - VaultInboxSlugInvalid (50470)
       * - VaultInboxSlugTaken (50471)
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.UpdateInbox
       */
      updateInbox: {
        name: "UpdateInbox",
        I: UpdateInboxRequest,
        O: UpdateInboxResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - VaultNotFound (50400)
       * - NotAllowedForVault (50110): specified vault is not an inbox Vault
       * - PermissionDenied (10100): no access to the vault
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.DeleteInboxVault
       */
      deleteInboxVault: {
        name: "DeleteInboxVault",
        I: DeleteInboxVaultRequest,
        O: DeleteInboxVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * Note this method does not throw VaultNotFound.
       * Missing vaults will just be missing from the result.
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - OrganizationNotFound (60400)
       * - Internal (10500)
       *
       * @generated from rpc domain.VaultService.ListMessagePublicKeys
       */
      listMessagePublicKeys: {
        name: "ListMessagePublicKeys",
        I: ListMessagePublicKeysRequest,
        O: ListMessagePublicKeysResponse,
        kind: MethodKind.Unary
      }
    }
  };
  class RegisterCredentialInitRequest extends Message {
    constructor(data) {
      super();
      this.credentialType = CredentialType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialInitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialInitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialInitRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegisterCredentialInitRequest, a2, b);
    }
  }
  RegisterCredentialInitRequest.runtime = proto3;
  RegisterCredentialInitRequest.typeName = "domain.RegisterCredentialInitRequest";
  RegisterCredentialInitRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "credential_type", kind: "enum", T: proto3.getEnumType(CredentialType) }
  ]);
  class RegisterCredentialInitResponse extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.optionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialInitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialInitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialInitResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegisterCredentialInitResponse, a2, b);
    }
  }
  RegisterCredentialInitResponse.runtime = proto3;
  RegisterCredentialInitResponse.typeName = "domain.RegisterCredentialInitResponse";
  RegisterCredentialInitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegisterCredentialForAccountCreationInitRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialForAccountCreationInitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialForAccountCreationInitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialForAccountCreationInitRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegisterCredentialForAccountCreationInitRequest, a2, b);
    }
  }
  RegisterCredentialForAccountCreationInitRequest.runtime = proto3;
  RegisterCredentialForAccountCreationInitRequest.typeName = "domain.RegisterCredentialForAccountCreationInitRequest";
  RegisterCredentialForAccountCreationInitRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegisterCredentialForAccountCreationInitResponse extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.optionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialForAccountCreationInitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialForAccountCreationInitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialForAccountCreationInitResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegisterCredentialForAccountCreationInitResponse, a2, b);
    }
  }
  RegisterCredentialForAccountCreationInitResponse.runtime = proto3;
  RegisterCredentialForAccountCreationInitResponse.typeName = "domain.RegisterCredentialForAccountCreationInitResponse";
  RegisterCredentialForAccountCreationInitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class RegisterCredentialFinishRequest extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.responseJson = "";
      this.prfSupportStatus = WebauthnPrfSupportStatus.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialFinishRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialFinishRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialFinishRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegisterCredentialFinishRequest, a2, b);
    }
  }
  RegisterCredentialFinishRequest.runtime = proto3;
  RegisterCredentialFinishRequest.typeName = "domain.RegisterCredentialFinishRequest";
  RegisterCredentialFinishRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "prf_support_status", kind: "enum", T: proto3.getEnumType(WebauthnPrfSupportStatus) }
  ]);
  class RegisterCredentialFinishResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new RegisterCredentialFinishResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new RegisterCredentialFinishResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new RegisterCredentialFinishResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(RegisterCredentialFinishResponse, a2, b);
    }
  }
  RegisterCredentialFinishResponse.runtime = proto3;
  RegisterCredentialFinishResponse.typeName = "domain.RegisterCredentialFinishResponse";
  RegisterCredentialFinishResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class UnlockSessionInitRequest extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionInitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionInitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionInitRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UnlockSessionInitRequest, a2, b);
    }
  }
  UnlockSessionInitRequest.runtime = proto3;
  UnlockSessionInitRequest.typeName = "domain.UnlockSessionInitRequest";
  UnlockSessionInitRequest.fields = proto3.util.newFieldList(() => []);
  class UnlockSessionInitResponse extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.optionsJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionInitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionInitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionInitResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UnlockSessionInitResponse, a2, b);
    }
  }
  UnlockSessionInitResponse.runtime = proto3;
  UnlockSessionInitResponse.typeName = "domain.UnlockSessionInitResponse";
  UnlockSessionInitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "options_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class UnlockSessionFinishRequest extends Message {
    constructor(data) {
      super();
      this.requestId = "";
      this.responseJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionFinishRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionFinishRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionFinishRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UnlockSessionFinishRequest, a2, b);
    }
  }
  UnlockSessionFinishRequest.runtime = proto3;
  UnlockSessionFinishRequest.typeName = "domain.UnlockSessionFinishRequest";
  UnlockSessionFinishRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "request_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "response_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "max_expires_at", kind: "message", T: Timestamp }
  ]);
  class UnlockSessionFinishResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new UnlockSessionFinishResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new UnlockSessionFinishResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new UnlockSessionFinishResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(UnlockSessionFinishResponse, a2, b);
    }
  }
  UnlockSessionFinishResponse.runtime = proto3;
  UnlockSessionFinishResponse.typeName = "domain.UnlockSessionFinishResponse";
  UnlockSessionFinishResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  class DeleteCredentialsRequest extends Message {
    constructor(data) {
      super();
      this.webauthnIds = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteCredentialsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteCredentialsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteCredentialsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteCredentialsRequest, a2, b);
    }
  }
  DeleteCredentialsRequest.runtime = proto3;
  DeleteCredentialsRequest.typeName = "domain.DeleteCredentialsRequest";
  DeleteCredentialsRequest.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "webauthn_ids", kind: "scalar", T: 9, repeated: true }
  ]);
  class DeleteCredentialsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new DeleteCredentialsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new DeleteCredentialsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new DeleteCredentialsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(DeleteCredentialsResponse, a2, b);
    }
  }
  DeleteCredentialsResponse.runtime = proto3;
  DeleteCredentialsResponse.typeName = "domain.DeleteCredentialsResponse";
  DeleteCredentialsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_update", kind: "message", T: SyncUpdate }
  ]);
  const WebauthnService = {
    typeName: "domain.WebauthnService",
    methods: {
      /**
       * errors:
       * - BadRequest (10400): if an unknown credential type is given
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotUnlocked (20431)
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.RegisterCredentialInit
       */
      registerCredentialInit: {
        name: "RegisterCredentialInit",
        I: RegisterCredentialInitRequest,
        O: RegisterCredentialInitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - InvalidEmail (20101)
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.RegisterCredentialForAccountCreationInit
       */
      registerCredentialForAccountCreationInit: {
        name: "RegisterCredentialForAccountCreationInit",
        I: RegisterCredentialForAccountCreationInitRequest,
        O: RegisterCredentialForAccountCreationInitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotUnlocked (20431)
       * - WebauthnValidateError (80400): there is a cryptographic error with the response
       * - WebauthnDataError (80401): there is a parsing error with the response
       * - WebauthnInvalidTransport (80403): credential had an invalid transport (for its type)
       * - WebauthnRequestNotFound (80402): the request_id was not found, or timed out
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.RegisterCredentialFinish
       */
      registerCredentialFinish: {
        name: "RegisterCredentialFinish",
        I: RegisterCredentialFinishRequest,
        O: RegisterCredentialFinishResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - SessionNotUnlocked (20431): session can't be unlocked due to missing encrypted_session_unlock
       * - MissingWebauthnCredential (80404): if no webauthn credentials are registered
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.UnlockSessionInit
       */
      unlockSessionInit: {
        name: "UnlockSessionInit",
        I: UnlockSessionInitRequest,
        O: UnlockSessionInitResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - InvalidTimeout (20420): expires_at is already expired
       * - WebauthnValidateError (80400): there is a cryptographic error with the response
       * - WebauthnDataError (80401): there is a parsing error with the response
       * - WebauthnRequestNotFound (80402): the request_id was not found, or timed out
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.UnlockSessionFinish
       */
      unlockSessionFinish: {
        name: "UnlockSessionFinish",
        I: UnlockSessionFinishRequest,
        O: UnlockSessionFinishResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - MissingCredentials (30100)
       * - InvalidCredentials (30420)
       * - Internal (10500)
       *
       * @generated from rpc domain.WebauthnService.DeleteCredentials
       */
      deleteCredentials: {
        name: "DeleteCredentials",
        I: DeleteCredentialsRequest,
        O: DeleteCredentialsResponse,
        kind: MethodKind.Unary
      }
    }
  };
  var __awaiter$13 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class HealthServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    ping() {
      return __awaiter$13(this, void 0, void 0, function* () {
        yield this.espbClient.ping({});
      });
    }
  }
  var __awaiter$12 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class IntegrationsServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    entraFinishAuthorization(resultQueryString) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.entraFinishAuthorization({ resultQueryString });
        return {
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate)),
          organizationId: requireFieldNotEmpty(resp.organizationId)
        };
      });
    }
    entraGetAuthorizeUri(organizationId, redirectUri) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.entraGetAuthorizeUri({ organizationId, redirectUri });
        return requireFieldNotEmpty(resp.uri);
      });
    }
    entraGetTenant(organizationId, forceRefresh, cancelToken) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.entraGetTenant({ organizationId, forceRefresh }, { signal: cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.signal });
        return {
          updatedAt: requireFieldNotEmpty(resp.updatedAt).toDate(),
          users: resp.users.map((u2) => ({
            id: u2.entraUserId,
            email: u2.email,
            groups: u2.memberOf
          })),
          groups: resp.groups.map((g2) => ({
            id: g2.entraGroupId,
            name: g2.name
          }))
        };
      });
    }
    entraClearAuthorization(organizationId) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.entraClearAuthorization({ organizationId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    csvSetIntegrationData(organizationId, dataJson, cancelToken) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.csvSetIntegrationData({ organizationId, dataJson: dataJson !== null && dataJson !== void 0 ? dataJson : void 0 }, { signal: cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.signal });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    csvGetIntegrationData(organizationId) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.csvGetIntegrationData({ organizationId });
        return requireFieldNotEmpty(resp.dataJson);
      });
    }
    googleWorkspaceGetAuthorizationUri(organizationId, redirectUri) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.gWorkspaceGetAuthorizeUri({ organizationId, redirectUri });
        return requireFieldNotEmpty(resp.uri);
      });
    }
    googleWorkspaceFinishAuthorization(resultQueryString) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.gWorkspaceFinishAuthorization({ resultQueryString });
        return {
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate)),
          organizationId: requireFieldNotEmpty(resp.organizationId)
        };
      });
    }
    googleWorkspaceClearAuthorization(organizationId) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.gWorkspaceClearAuthorization({ organizationId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    googleWorkspaceList(organizationId, forceRefresh = false, cancelToken) {
      return __awaiter$12(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.gWorkspaceList({ organizationId, forceRefresh }, { signal: cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.signal });
        return {
          updatedAt: requireFieldNotEmpty(resp.updatedAt).toDate(),
          users: resp.users.map((u2) => ({
            id: u2.id,
            email: u2.email
          }))
        };
      });
    }
  }
  var __awaiter$11 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class LFDOverridesClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    list(lastKnownOverridesUpdateTime) {
      return __awaiter$11(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.list({
          lastKnownOverridesUpdateTime: lastKnownOverridesUpdateTime ? Timestamp.fromDate(lastKnownOverridesUpdateTime) : void 0
        });
        return {
          overridesJson: resp.overridesJson,
          overridesUpdateTime: requireFieldNotEmpty(resp.overridesUpdateTime).toDate()
        };
      });
    }
  }
  var __awaiter$10 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class LFDOverridesAdminClient {
    constructor(baseUri, authToken, clientType, clientId = null, clientVersion = null) {
      this.baseUri = baseUri;
      this.authToken = authToken;
      this.clientType = clientType;
      this.clientId = clientId;
      this.clientVersion = clientVersion;
      const factory = new EspbServiceClientFactory({
        authTokens: {
          lfdOverridesAdmin: authToken
        },
        clientId,
        clientType,
        clientVersion,
        baseUri,
        clientOperationId: null,
        clientOperationName: null,
        syncVersion: null,
        syncSuperUsers: false,
        permissionUserId: null
      });
      this.espbClient = factory.createServiceClient(LFDOverridesService);
    }
    replace(...overrideJson) {
      return __awaiter$10(this, void 0, void 0, function* () {
        yield this.espbClient.replace({ overrideJson });
      });
    }
    delete(...overrideIds) {
      return __awaiter$10(this, void 0, void 0, function* () {
        yield this.espbClient.delete({ overrideIds });
      });
    }
  }
  var __awaiter$$ = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class LoginInboxServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    show(slug) {
      var _a2;
      return __awaiter$$(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.show({ slug });
        let organizationData;
        const orgDataGrpc = resp.organizationData;
        if (orgDataGrpc) {
          organizationData = {
            name: requireFieldNotEmpty(orgDataGrpc.name),
            icon: (_a2 = orgDataGrpc.icon) !== null && _a2 !== void 0 ? _a2 : null
          };
        }
        return {
          vaultId: requireFieldNotEmpty(resp.vaultId),
          generationId: requireFieldNotEmpty(resp.generationId),
          publicKey: resp.publicKey,
          metadataJson: requireFieldNotEmpty(resp.metadata),
          organizationData,
          url: requireFieldNotEmpty(resp.url),
          baseUrl: requireFieldNotEmpty(resp.baseUrl)
        };
      });
    }
    createMessage(vaultId, generationId, type, encryptedData) {
      return __awaiter$$(this, void 0, void 0, function* () {
        yield this.espbClient.createMessage({ vaultId, generationId, type, encryptedData });
      });
    }
  }
  var __awaiter$_ = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class OrganizationServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    create({ name, email, icon, userProfile, orgAuth, adminProfile, legacyAdminVaultDto, authenticatorBlock, personalVaultDto, personalVaultSuperuserLock, teamVaultDto, teamVaultSuperuserLock, teamAssociatedVaultSuperuserLock, contactJson, parentOrganizationInfo, adminVaultDto }) {
      var _a2, _b2, _c2;
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.create({
          name,
          email,
          icon: icon !== null && icon !== void 0 ? icon : void 0,
          userProfile: userProfile !== null && userProfile !== void 0 ? userProfile : void 0,
          adminProfile,
          authenticator: orgAuth,
          adminVaultData: adminVaultDto ? toPbVaultCreationData(adminVaultDto) : void 0,
          legacyAdminVaultData: legacyAdminVaultDto ? toPbVaultCreationData(legacyAdminVaultDto) : void 0,
          authenticatorBlock: authenticatorBlock ? authenticatorBlock.blob : void 0,
          authenticatorBlockSignature: authenticatorBlock ? authenticatorBlock.signature : void 0,
          personalVaultData: toPbVaultCreationData(personalVaultDto),
          personalVaultSuperuserEncryptedStorableVaultKey: personalVaultSuperuserLock === null || personalVaultSuperuserLock === void 0 ? void 0 : personalVaultSuperuserLock.encryptedStorableVaultKey,
          personalVaultSuperuserEncryptedHighSecurityVaultKey: personalVaultSuperuserLock === null || personalVaultSuperuserLock === void 0 ? void 0 : personalVaultSuperuserLock.encryptedHighSecurityVaultKey,
          personalVaultSuperuserEncryptedVaultMessagePrivateKey: (_a2 = personalVaultSuperuserLock === null || personalVaultSuperuserLock === void 0 ? void 0 : personalVaultSuperuserLock.encryptedVaultMessagePrivateKey) !== null && _a2 !== void 0 ? _a2 : void 0,
          teamVaultData: teamVaultDto ? toVaultPairCreationData(teamVaultDto) : void 0,
          teamVaultSuperuserEncryptedStorableVaultKey: teamVaultSuperuserLock === null || teamVaultSuperuserLock === void 0 ? void 0 : teamVaultSuperuserLock.encryptedStorableVaultKey,
          teamVaultSuperuserEncryptedHighSecurityVaultKey: teamVaultSuperuserLock === null || teamVaultSuperuserLock === void 0 ? void 0 : teamVaultSuperuserLock.encryptedHighSecurityVaultKey,
          teamVaultSuperuserEncryptedVaultMessagePrivateKey: (_b2 = teamVaultSuperuserLock === null || teamVaultSuperuserLock === void 0 ? void 0 : teamVaultSuperuserLock.encryptedVaultMessagePrivateKey) !== null && _b2 !== void 0 ? _b2 : void 0,
          teamAssociatedVaultSuperuserEncryptedStorableVaultKey: teamAssociatedVaultSuperuserLock === null || teamAssociatedVaultSuperuserLock === void 0 ? void 0 : teamAssociatedVaultSuperuserLock.encryptedStorableVaultKey,
          teamAssociatedVaultSuperuserEncryptedHighSecurityVaultKey: teamAssociatedVaultSuperuserLock === null || teamAssociatedVaultSuperuserLock === void 0 ? void 0 : teamAssociatedVaultSuperuserLock.encryptedHighSecurityVaultKey,
          teamAssociatedVaultSuperuserEncryptedVaultMessagePrivateKey: (_c2 = teamAssociatedVaultSuperuserLock === null || teamAssociatedVaultSuperuserLock === void 0 ? void 0 : teamAssociatedVaultSuperuserLock.encryptedVaultMessagePrivateKey) !== null && _c2 !== void 0 ? _c2 : void 0,
          contactJson,
          parentOrganizationInfo
        });
        return {
          organizationId: requireFieldNotEmpty(resp.organizationId),
          profileId: requireFieldNotEmpty(resp.profileId),
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate))
        };
      });
    }
    update(organizationId, { name, icon, restrictCreateTeam, restrictPersonalLogins, auditlogEnable, childOrganizationManagementEnable, monitoredDomains, passwordPolicy, unlockTimeLimit, clientSettings }) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.update({
          organizationId,
          name,
          icon: icon === null ? "" : icon,
          restrictCreateTeam,
          restrictPersonalLogins,
          auditlogEnable,
          childOrganizationManagementEnable,
          monitoredDomains: monitoredDomains ? new UpdateOrganizationRequest_StringArray({ value: monitoredDomains }) : void 0,
          passwordPolicy: passwordPolicy === null ? "" : passwordPolicy,
          unlockTimeLimit,
          clientSettings
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    modifyMembers(orgId, createProfiles, updateProfiles, deleteProfileIds, legacyAdminVaultRegData) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.modifyMembers({
          legacyAdminVaultRegenerateData: legacyAdminVaultRegData ? toVaultRegenerateData(legacyAdminVaultRegData) : void 0,
          organizationId: orgId,
          createProfileOps: createProfiles.map((p2) => {
            var _a2;
            return {
              userId: (_a2 = p2.userId) !== null && _a2 !== void 0 ? _a2 : void 0,
              email: p2.email,
              isAdmin: p2.isAdmin,
              profile: p2.profileDto,
              legacyAdminVaultLock: p2.legacyAdminVaultLock ? toPbVaultProfileLock(p2.legacyAdminVaultLock) : void 0,
              adminProfileLock: p2.adminProfileLock,
              personalVaultData: toPbVaultCreationData(p2.personalVaultDto),
              createStartCodeAndSendMail: p2.createStartCodeAndSendMail
            };
          }),
          updateProfileOps: updateProfiles.map((p2) => ({
            profileId: p2.profileId,
            isAdmin: p2.isAdmin,
            adminProfileLock: p2.adminProfileLock
          })),
          deleteProfileIds
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    createServiceProfile(orgId, profile, downstreamAdminProfileLock) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createServiceProfile({
          organizationId: orgId,
          profile,
          downstreamAdminProfileLock
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    acceptInvitation(organizationId) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.acceptInvite({ organizationId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    redeemCoupon(organizationId, couponText) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.redeemCoupon({ organizationId, couponText });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    leave(organizationId) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.leave({ organizationId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    getSubscriptionDetails(organizationId) {
      var _a2;
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.getSubscriptionDetails({ organizationId });
        const payments = resp.payments.map((p2) => ({
          eventTime: requireFieldNotEmpty(p2.eventTime).toDate(),
          receiptUrl: requireFieldNotEmpty(p2.receiptUrl),
          saleGrossCents: Number(p2.saleGrossCents),
          paymentTaxCents: Number(p2.paymentTaxCents),
          currency: requireFieldNotEmpty(p2.currency),
          orderId: requireFieldNotEmpty(p2.orderId)
        }));
        return {
          payments,
          paddleSubscription: resp.paddleSubscription ? Object.assign(Object.assign({}, resp.paddleSubscription), { subscriptionPlan: knownEnumOrDefault(resp.paddleSubscription.plan, SubscriptionPlan), nextBillDate: (_a2 = resp.paddleSubscription.nextBillDate) === null || _a2 === void 0 ? void 0 : _a2.toDate() }) : void 0,
          status: toSubscriptionStatus(resp.status)
        };
      });
    }
    regenerateUser(organizationId, userId, p2) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.regenerateOrganizationProfile({
          organizationId,
          userId: userId !== null && userId !== void 0 ? userId : void 0,
          profile: toPbProfileRegenerateData(p2)
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    regenerateAdmin(orgId, p2, adminVault) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.regenerateAdminProfile({
          organizationId: orgId,
          profile: toPbProfileRegenerateData(p2),
          adminVaultData: adminVault ? toPbVaultCreationData(adminVault) : void 0
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    delete(organizationId) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.delete({ organizationId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    renewProfileStartCode(organizationId, ...profileIds) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.renewProfileStartCode({ organizationId, profileIds });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    sendStartCodeEmail(organizationId, ...profileIds) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.sendStartCodeEmail({ organizationId, profileIds });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    revokeProfileStartCode(organizationId, ...profileIds) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.revokeProfileStartCode({ organizationId, profileIds });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    getDeletionInfo(organizationId, token) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.getDeletionInfo({ organizationId, token });
        return {
          organizationName: resp.organizationName,
          requestedAt: requireFieldNotEmpty(resp.requestedAt).toDate(),
          requestedByEmail: resp.requestedByEmail,
          userCount: resp.userCount
        };
      });
    }
    deleteWithToken(organizationId, token) {
      return __awaiter$_(this, void 0, void 0, function* () {
        yield this.espbClient.deleteWithToken({ organizationId, token });
      });
    }
    removeDeletionToken(organizationId, token) {
      return __awaiter$_(this, void 0, void 0, function* () {
        yield this.espbClient.removeDeletionToken({ organizationId, token });
      });
    }
    getBreachData(organizationId) {
      return __awaiter$_(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.getBreachData({ organizationId });
        return Object.assign(Object.assign({}, resp), { lastCheckDate: requireFieldNotEmpty(resp.lastCheckDate).toDate(), domains: resp.domains.map((domain) => Object.assign(Object.assign({}, domain), { breaches: domain.breaches.map((breach) => {
          const model = requireFieldNotEmpty(breach.model);
          return Object.assign(Object.assign({}, breach), { model: Object.assign(Object.assign({}, model), { breachDate: requireFieldNotEmpty(model === null || model === void 0 ? void 0 : model.breachDate).toDate(), addedDate: requireFieldNotEmpty(model === null || model === void 0 ? void 0 : model.addedDate).toDate() }) });
        }) })) });
      });
    }
  }
  function toSubscriptionStatus(ps) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    if (ps == void 0) {
      return void 0;
    }
    switch (ps === null || ps === void 0 ? void 0 : ps.status.case) {
      case "statusTrial":
        const trial = requireFieldNotEmpty(ps.status.value);
        return {
          status: "trial",
          trialEndDate: requireFieldNotEmpty((_a2 = trial.trialEndDate) === null || _a2 === void 0 ? void 0 : _a2.toDate())
        };
      case "statusPaddleActive":
        const active = requireFieldNotEmpty(ps.status.value);
        return {
          status: "paddleActive",
          freeMembers: active.freeMembers,
          nextBillDate: requireFieldNotEmpty((_b2 = active.nextBillDate) === null || _b2 === void 0 ? void 0 : _b2.toDate()),
          baseUrl: requireFieldNotEmpty(active.baseUrl),
          email: requireFieldNotEmpty(active.email)
        };
      case "statusPaddlePastDue":
        const pastDue = requireFieldNotEmpty(ps.status.value);
        return {
          status: "paddlePastDue",
          freeMembers: pastDue.freeMembers,
          nextBillDate: requireFieldNotEmpty((_c2 = pastDue.nextBillDate) === null || _c2 === void 0 ? void 0 : _c2.toDate()),
          baseUrl: requireFieldNotEmpty(pastDue.baseUrl)
        };
      case "statusPaddlePausedVoluntary":
        const pausedVoluntary = requireFieldNotEmpty(ps.status.value);
        return {
          status: "paddlePausedVoluntary",
          freeMembers: pausedVoluntary.freeMembers,
          baseUrl: requireFieldNotEmpty(pausedVoluntary.baseUrl),
          pausedAt: requireFieldNotEmpty((_d2 = pausedVoluntary.pausedAt) === null || _d2 === void 0 ? void 0 : _d2.toDate()),
          pausedFrom: requireFieldNotEmpty((_e2 = pausedVoluntary.pausedFrom) === null || _e2 === void 0 ? void 0 : _e2.toDate())
        };
      case "statusPaddlePausedDelinquent":
        const pausedDelinquent = requireFieldNotEmpty(ps.status.value);
        return {
          status: "paddlePausedDelinquent",
          freeMembers: pausedDelinquent.freeMembers,
          baseUrl: requireFieldNotEmpty(pausedDelinquent.baseUrl),
          pausedAt: requireFieldNotEmpty((_f2 = pausedDelinquent.pausedAt) === null || _f2 === void 0 ? void 0 : _f2.toDate()),
          pausedFrom: requireFieldNotEmpty((_g2 = pausedDelinquent.pausedFrom) === null || _g2 === void 0 ? void 0 : _g2.toDate())
        };
      case "statusPaddleDeleted":
        const deleted = requireFieldNotEmpty(ps.status.value);
        return {
          status: "paddleDeleted",
          freeMembers: deleted.freeMembers,
          cancellationEffectiveDate: requireFieldNotEmpty((_h2 = deleted.cancellationEffectiveDate) === null || _h2 === void 0 ? void 0 : _h2.toDate())
        };
      case "statusActiveFree":
        const activeFree = requireFieldNotEmpty(ps.status.value);
        return {
          status: "activeFree",
          freeMembers: activeFree.freeMembers
        };
      case "statusCustom":
        const custom2 = requireFieldNotEmpty(ps.status.value);
        return {
          status: "custom",
          left: custom2.left,
          right: custom2.right
        };
      case "statusExample":
        const example = requireFieldNotEmpty(ps.status.value);
        return {
          status: "example",
          left: example.left,
          right: example.right
        };
    }
    return void 0;
  }
  var __awaiter$Z = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class ProfileServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    regenerate(profiles) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.regenerate({
          profiles: profiles.map(toPbProfileRegenerateData)
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    list(profileIds) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.list({ profileIds });
        return resp.profiles.map((p2) => {
          const profile = Object.assign(Object.assign({}, p2), { organizationId: p2.organizationId || null, email: p2.email || null });
          return profile;
        });
      });
    }
    createPrivate(email, privateProfile, privateVault) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createPrivate({
          email,
          privateProfile,
          privateVault: toPbVaultCreationData(privateVault)
        });
        return {
          privateProfileId: requireFieldNotEmpty(resp.privateProfileId),
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate))
        };
      });
    }
    deletePrivate(privateProfileId) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.deletePrivate({ privateProfileId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    requestEmailChange(profileId, email) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.requestEmailChange({ profileId, email });
        return Object.assign(Object.assign({}, resp), { syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate)) });
      });
    }
    cancelEmailChange(profileId) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.cancelEmailChange({ profileId });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    verifyEmailAddress(token) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const response = yield this.espbClient.verifyEmailAddress({ token });
        return {
          email: requireFieldNotEmpty(response.email)
        };
      });
    }
    getProfileInfo(profileId) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.getProfileInfo({ profileId });
        return {
          email: resp.email,
          organizationId: resp.organizationId,
          organizationName: resp.organizationName,
          organizationIcon: resp.organizationIcon || void 0
        };
      });
    }
    checkStartCode(email, startCode) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        yield this.espbClient.checkStartCode({ email, startCode });
      });
    }
    claimWithStartCode(profileId, startCode) {
      return __awaiter$Z(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.claimWithStartCode({ profileId, startCode });
        return {
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate)),
          organizationId: resp.organizationId
        };
      });
    }
  }
  var __awaiter$Y = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SessionServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    deleteSession(sessionId) {
      return __awaiter$Y(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.deleteSession({ sessionId });
        const syncUpdate = resp.syncUpdate;
        return syncUpdate ? toSyncDto(syncUpdate) : null;
      });
    }
    createSessionUnlock(sessionId, authenticatorId, encryptedSecret, maxExpiresAt) {
      return __awaiter$Y(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.createSessionUnlock({
          sessionId,
          authenticatorId,
          encryptedSecret,
          maxExpiresAt: Timestamp.fromDate(maxExpiresAt)
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    extendSessionUnlock(lastUserActivity) {
      return __awaiter$Y(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.extendSessionUnlock({
          lastUserActivity: Timestamp.fromDate(lastUserActivity)
        });
        const syncUpdate = resp.syncUpdate;
        return syncUpdate ? toSyncDto(syncUpdate) : null;
      });
    }
    deleteSessionUnlock(sessionId, onlyPendingRequest = false) {
      return __awaiter$Y(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.deleteSessionUnlock({
          sessionId,
          onlyPendingRequest
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    requestSessionUnlock() {
      return __awaiter$Y(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.requestSessionUnlock({});
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    sendSessionMessage(messages2) {
      return __awaiter$Y(this, void 0, void 0, function* () {
        yield this.espbClient.sendSessionMessage({ messages: messages2 });
      });
    }
    update(sessionId, fieldsToUpdate, { clientSettings, enabledProfileIds, unlockTimeLimit, fcmDeviceToken }) {
      return __awaiter$Y(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.update({
          sessionId,
          fieldsToUpdate,
          clientSettings,
          enabledProfiles: enabledProfileIds ? { profileIds: enabledProfileIds } : void 0,
          unlockTimeLimit,
          fcmDeviceToken
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
  }
  var __awaiter$X = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class ShareLinkServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    preview(shareLinkId) {
      return __awaiter$X(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.preview({ shareLinkId });
        return {
          encryptedPayload: resp.encryptedPayload,
          organizationName: resp.organizationName || void 0,
          senderEmail: resp.senderEmail
        };
      });
    }
    show(shareLinkId) {
      return __awaiter$X(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.show({ shareLinkId });
        return {
          encryptedPayload: resp.encryptedPayload,
          encryptedProtectedSecret: resp.encryptedProtectedSecret,
          organizationName: resp.organizationName || void 0,
          senderEmail: resp.senderEmail
        };
      });
    }
  }
  var __awaiter$W = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class SupportServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    sendMessage(subject, message, profileId) {
      return __awaiter$W(this, void 0, void 0, function* () {
        yield this.espbClient.sendMessage({ subject, message, profileId });
      });
    }
    reportPage(url, problem, comment, screenshot, hasLogin, hasHideSecretsLogin) {
      return __awaiter$W(this, void 0, void 0, function* () {
        yield this.espbClient.reportPage({
          url: url !== null && url !== void 0 ? url : void 0,
          problem,
          comment,
          screenshot: screenshot !== null && screenshot !== void 0 ? screenshot : void 0,
          hasLogin,
          hasHideSecretsLogin
        });
      });
    }
  }
  var __awaiter$V = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class UserConfirmationServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    create({ type, loginId = "", vaultId = "", profileId = "", organizationId = "" }) {
      return __awaiter$V(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.create({
          data: { type, loginId, vaultId, profileId, organizationId }
        });
        return {
          id: requireFieldNotEmpty(resp.id),
          syncUpdate: toSyncDto(requireFieldNotEmpty(resp.syncUpdate)),
          webauthnOptionsJson: resp.webauthnOptionsJson || void 0
        };
      });
    }
    get(id) {
      return __awaiter$V(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.get({ id });
        const data = requireFieldNotEmpty(resp.data);
        return {
          fallbackString: resp.fallbackString,
          requestingSessionId: resp.requestingSessionId,
          data: {
            type: knownEnumOrDefault(data.type, UserConfirmationType),
            vaultId: data.vaultId || void 0,
            loginId: data.loginId || void 0,
            profileId: data.profileId || void 0,
            organizationId: data.organizationId || void 0
          }
        };
      });
    }
    sendResult(id, type, webauthnResponseJson) {
      return __awaiter$V(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.sendResult({ id, type, webauthnResponseJson });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    retrieveResult(id) {
      return __awaiter$V(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.retrieveResult({ id });
        return {
          resultType: knownEnumOrDefault(resp.resultType, UserConfirmationResultType)
        };
      });
    }
    cancel(id) {
      return __awaiter$V(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.cancel({ id });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
  }
  var __awaiter$U = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class WebauthnServiceClient {
    constructor(espbClient) {
      this.espbClient = espbClient;
    }
    unlockSessionInit() {
      return __awaiter$U(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.unlockSessionInit({});
        return {
          optionsJson: requireFieldNotEmpty(resp.optionsJson),
          requestId: requireFieldNotEmpty(resp.requestId)
        };
      });
    }
    unlockSessionFinish(requestId, responseJson, maxExpiresAt) {
      return __awaiter$U(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.unlockSessionFinish({
          requestId,
          responseJson,
          maxExpiresAt: Timestamp.fromDate(maxExpiresAt)
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    registerCredentialInit(credentialType) {
      return __awaiter$U(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.registerCredentialInit({ credentialType });
        return {
          optionsJson: requireFieldNotEmpty(resp.optionsJson),
          requestId: requireFieldNotEmpty(resp.requestId)
        };
      });
    }
    RegisterCredentialForAccountCreationInit(email) {
      return __awaiter$U(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.registerCredentialForAccountCreationInit({ email });
        return {
          optionsJson: requireFieldNotEmpty(resp.optionsJson),
          requestId: requireFieldNotEmpty(resp.requestId)
        };
      });
    }
    registerCredentialFinish(requestId, responseJson, prfSupportStatus) {
      return __awaiter$U(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.registerCredentialFinish({
          requestId,
          responseJson,
          prfSupportStatus
        });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
    deleteCredentials(webauthnIds) {
      return __awaiter$U(this, void 0, void 0, function* () {
        const resp = yield this.espbClient.deleteCredentials({ webauthnIds });
        return toSyncDto(requireFieldNotEmpty(resp.syncUpdate));
      });
    }
  }
  var __awaiter$T = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class BackendClient {
    constructor(config) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
      this.config = Object.assign({ auditlogBaseUri: config.backendBaseUri, syncSuperUsers: false }, config);
      const authTokens = {
        backend: (_a2 = this.config.loginData) === null || _a2 === void 0 ? void 0 : _a2.token
      };
      this.espbClientFactory = new EspbServiceClientFactory({
        authTokens,
        clientId: (_b2 = this.config.clientId) !== null && _b2 !== void 0 ? _b2 : null,
        clientType: this.config.clientType,
        clientVersion: (_c2 = this.config.clientVersion) !== null && _c2 !== void 0 ? _c2 : null,
        baseUri: this.config.backendBaseUri,
        clientOperationId: (_d2 = this.config.clientOperationId) !== null && _d2 !== void 0 ? _d2 : null,
        clientOperationName: (_e2 = this.config.clientOperationName) !== null && _e2 !== void 0 ? _e2 : null,
        syncVersion: (_f2 = this.config.syncVersion) !== null && _f2 !== void 0 ? _f2 : null,
        syncSuperUsers: this.config.syncSuperUsers,
        permissionUserId: (_g2 = this.config.permissionUserId) !== null && _g2 !== void 0 ? _g2 : null
      });
      this.account = new AccountServiceClient(this.espbClientFactory.createServiceClient(AccountService));
      this.credential = new CredentialServiceClient(this.espbClientFactory.createServiceClient(CredentialService));
      this.vault = new VaultServiceClient(this.espbClientFactory.createServiceClient(VaultService));
      this.authenticator = new AuthenticatorServiceClient(this.espbClientFactory.createServiceClient(AuthenticatorService));
      this.channel = new ChannelServiceClient(this.espbClientFactory.createServiceClient(ChannelService));
      this.sync = new SyncServiceClient(this.espbClientFactory.createServiceClient(SyncService));
      this.session = new SessionServiceClient(this.espbClientFactory.createServiceClient(SessionService));
      this.support = new SupportServiceClient(this.espbClientFactory.createServiceClient(SupportService));
      this.organization = new OrganizationServiceClient(this.espbClientFactory.createServiceClient(OrganizationService));
      this.profile = new ProfileServiceClient(this.espbClientFactory.createServiceClient(ProfileService));
      this.loginInbox = new LoginInboxServiceClient(this.espbClientFactory.createServiceClient(LoginInboxService));
      this.integrations = new IntegrationsServiceClient(this.espbClientFactory.createServiceClient(IntegrationsService));
      this.webauthn = new WebauthnServiceClient(this.espbClientFactory.createServiceClient(WebauthnService));
      this.lfdOverrides = new LFDOverridesClient(this.espbClientFactory.createServiceClient(LFDOverridesService));
      this.health = new HealthServiceClient(this.espbClientFactory.createServiceClient(HealthService));
      this.shareLinks = new ShareLinkServiceClient(this.espbClientFactory.createServiceClient(ShareLinkService));
      this.userConfirmations = new UserConfirmationServiceClient(this.espbClientFactory.createServiceClient(UserConfirmationService));
      this.childOrganization = new ChildOrganizationServiceClient(this.espbClientFactory.createServiceClient(ChildOrganizationService));
    }
    withLogin(loginData) {
      return this.withConfig({ loginData });
    }
    withClientId(clientId) {
      return this.withConfig({ clientId });
    }
    withSyncVersion(syncVersion) {
      if (syncVersion === this.config.syncVersion) {
        return this;
      }
      return this.withConfig({ syncVersion });
    }
    withPermissionUserId(permissionUserId) {
      if (permissionUserId === this.config.permissionUserId) {
        return this;
      }
      return this.withConfig({ permissionUserId });
    }
    withSyncSuperUsers(syncSuperUsers) {
      if (syncSuperUsers === this.config.syncSuperUsers) {
        return this;
      }
      return this.withConfig({ syncSuperUsers });
    }
    withClientOperation(clientOperationId, clientOperationName, syncVersion) {
      return this.withConfig({ clientOperationId, clientOperationName, syncVersion });
    }
    withConfig(newConfig) {
      return new BackendClient(Object.assign(Object.assign({}, this.config), newConfig));
    }
    getSessionId() {
      return this.ensureLoginData().sessionId;
    }
    ensureLoginData() {
      if (!this.config.loginData) {
        throw new Error("Login Data is missing!");
      }
      return this.config.loginData;
    }
    setFcmDeviceToken(deviceToken) {
      return __awaiter$T(this, void 0, void 0, function* () {
        return this.authenticator.setDeviceToken(deviceToken);
      });
    }
    deleteSession(sessionId) {
      return __awaiter$T(this, void 0, void 0, function* () {
        return this.session.deleteSession(sessionId);
      });
    }
    getAuditlogWriteClient(authToken) {
      return new AuditlogWriteClient(this.config.auditlogBaseUri, authToken.token, this.config.clientType, this.config.clientId, this.config.clientVersion);
    }
    getAuditlogAdminClient(authToken) {
      return new AuditlogAdminClient(this.config.auditlogBaseUri, authToken.token, this.config.clientType, this.config.clientId, this.config.clientVersion);
    }
    getLFDOverridesAdminClient(authToken) {
      return new LFDOverridesAdminClient(this.config.backendBaseUri, authToken.token, this.config.clientType, this.config.clientId, this.config.clientVersion);
    }
  }
  var __awaiter$S = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class CancelToken {
    constructor() {
      this.isCancelled = false;
      this.emitter = new Emittery$3.Typed();
    }
    static create() {
      return new CancelToken();
    }
    cancel() {
      this.performCancel().catch(trackError);
    }
    onCancel(cancelHandler) {
      if (this.isCancelled) {
        cancelHandler();
      } else {
        this.emitter.on("cancel", cancelHandler);
      }
    }
    offCancel(cancelHandler) {
      this.emitter.off("cancel", cancelHandler);
    }
    get signal() {
      if (!this.abortController) {
        this.abortController = new AbortController();
        if (this.isCancelled) {
          this.abortController.abort();
        }
      }
      return this.abortController.signal;
    }
    performCancel() {
      var _a2;
      return __awaiter$S(this, void 0, void 0, function* () {
        if (!this.isCancelled) {
          this.isCancelled = true;
          yield this.emitter.emit("cancel");
          this.emitter.clearListeners("cancel");
          (_a2 = this.abortController) === null || _a2 === void 0 ? void 0 : _a2.abort();
        }
      });
    }
  }
  class AuthenticatorReply extends Message {
    constructor(data) {
      super();
      this.replyOneof = { case: void 0 };
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new AuthenticatorReply().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new AuthenticatorReply().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new AuthenticatorReply().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(AuthenticatorReply, a2, b);
    }
  }
  AuthenticatorReply.runtime = proto3;
  AuthenticatorReply.typeName = "domain.AuthenticatorReply";
  AuthenticatorReply.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "encrypted_secret_reply", kind: "message", T: EncryptedSecretAuthenticatorReply, oneof: "reply_oneof" }
  ]);
  class EncryptedSecretAuthenticatorReply extends Message {
    constructor(data) {
      super();
      this.encryptedSecret = new Uint8Array(0);
      this.registration = false;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new EncryptedSecretAuthenticatorReply().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new EncryptedSecretAuthenticatorReply().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new EncryptedSecretAuthenticatorReply().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(EncryptedSecretAuthenticatorReply, a2, b);
    }
  }
  EncryptedSecretAuthenticatorReply.runtime = proto3;
  EncryptedSecretAuthenticatorReply.typeName = "domain.EncryptedSecretAuthenticatorReply";
  EncryptedSecretAuthenticatorReply.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "encrypted_secret",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    },
    {
      no: 2,
      name: "registration",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    }
  ]);
  function createEncryptedSecretAuthenticatorReply(dto) {
    const reply = new AuthenticatorReply({
      replyOneof: { case: "encryptedSecretReply", value: dto }
    });
    return reply.toBinary();
  }
  class TestingDropLatestCommitRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDropLatestCommitRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDropLatestCommitRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDropLatestCommitRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDropLatestCommitRequest, a2, b);
    }
  }
  TestingDropLatestCommitRequest.runtime = proto3;
  TestingDropLatestCommitRequest.typeName = "domain.TestingDropLatestCommitRequest";
  TestingDropLatestCommitRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDropLatestCommitResponse extends Message {
    constructor(data) {
      super();
      this.latestCommitId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDropLatestCommitResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDropLatestCommitResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDropLatestCommitResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDropLatestCommitResponse, a2, b);
    }
  }
  TestingDropLatestCommitResponse.runtime = proto3;
  TestingDropLatestCommitResponse.typeName = "domain.TestingDropLatestCommitResponse";
  TestingDropLatestCommitResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "latest_commit_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingListEmailsRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingListEmailsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingListEmailsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingListEmailsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingListEmailsRequest, a2, b);
    }
  }
  TestingListEmailsRequest.runtime = proto3;
  TestingListEmailsRequest.typeName = "domain.TestingListEmailsRequest";
  TestingListEmailsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingListEmailsResponse extends Message {
    constructor(data) {
      super();
      this.emails = [];
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingListEmailsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingListEmailsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingListEmailsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingListEmailsResponse, a2, b);
    }
  }
  TestingListEmailsResponse.runtime = proto3;
  TestingListEmailsResponse.typeName = "domain.TestingListEmailsResponse";
  TestingListEmailsResponse.fields = proto3.util.newFieldList(() => [
    { no: 1, name: "emails", kind: "message", T: TestingListEmailsResponse_Email, repeated: true }
  ]);
  class TestingListEmailsResponse_Email extends Message {
    constructor(data) {
      super();
      this.to = "";
      this.template = "";
      this.data = {};
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingListEmailsResponse_Email().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingListEmailsResponse_Email().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingListEmailsResponse_Email().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingListEmailsResponse_Email, a2, b);
    }
  }
  TestingListEmailsResponse_Email.runtime = proto3;
  TestingListEmailsResponse_Email.typeName = "domain.TestingListEmailsResponse.Email";
  TestingListEmailsResponse_Email.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "to",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "template",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 3, name: "data", kind: "map", K: 9, V: {
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    } }
  ]);
  class TestingSetServerSideSettingsRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.serverSideSettings = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingSetServerSideSettingsRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingSetServerSideSettingsRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingSetServerSideSettingsRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingSetServerSideSettingsRequest, a2, b);
    }
  }
  TestingSetServerSideSettingsRequest.runtime = proto3;
  TestingSetServerSideSettingsRequest.typeName = "domain.TestingSetServerSideSettingsRequest";
  TestingSetServerSideSettingsRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "server_side_settings",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingSetServerSideSettingsResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingSetServerSideSettingsResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingSetServerSideSettingsResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingSetServerSideSettingsResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingSetServerSideSettingsResponse, a2, b);
    }
  }
  TestingSetServerSideSettingsResponse.runtime = proto3;
  TestingSetServerSideSettingsResponse.typeName = "domain.TestingSetServerSideSettingsResponse";
  TestingSetServerSideSettingsResponse.fields = proto3.util.newFieldList(() => []);
  class TestingDeleteUserRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteUserRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteUserRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteUserRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteUserRequest, a2, b);
    }
  }
  TestingDeleteUserRequest.runtime = proto3;
  TestingDeleteUserRequest.typeName = "domain.TestingDeleteUserRequest";
  TestingDeleteUserRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteUserResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteUserResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteUserResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteUserResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteUserResponse, a2, b);
    }
  }
  TestingDeleteUserResponse.runtime = proto3;
  TestingDeleteUserResponse.typeName = "domain.TestingDeleteUserResponse";
  TestingDeleteUserResponse.fields = proto3.util.newFieldList(() => []);
  class TestingAddAuthenticatorRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingAddAuthenticatorRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingAddAuthenticatorRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingAddAuthenticatorRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingAddAuthenticatorRequest, a2, b);
    }
  }
  TestingAddAuthenticatorRequest.runtime = proto3;
  TestingAddAuthenticatorRequest.typeName = "domain.TestingAddAuthenticatorRequest";
  TestingAddAuthenticatorRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "authenticator", kind: "message", T: AuthenticatorData },
    { no: 3, name: "block", kind: "message", T: AuthenticatorBlock$1 }
  ]);
  class TestingAddAuthenticatorResponse extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingAddAuthenticatorResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingAddAuthenticatorResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingAddAuthenticatorResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingAddAuthenticatorResponse, a2, b);
    }
  }
  TestingAddAuthenticatorResponse.runtime = proto3;
  TestingAddAuthenticatorResponse.typeName = "domain.TestingAddAuthenticatorResponse";
  TestingAddAuthenticatorResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteAuthenticatorRequest extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteAuthenticatorRequest, a2, b);
    }
  }
  TestingDeleteAuthenticatorRequest.runtime = proto3;
  TestingDeleteAuthenticatorRequest.typeName = "domain.TestingDeleteAuthenticatorRequest";
  TestingDeleteAuthenticatorRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteAuthenticatorResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteAuthenticatorResponse, a2, b);
    }
  }
  TestingDeleteAuthenticatorResponse.runtime = proto3;
  TestingDeleteAuthenticatorResponse.typeName = "domain.TestingDeleteAuthenticatorResponse";
  TestingDeleteAuthenticatorResponse.fields = proto3.util.newFieldList(() => []);
  class TestingEditAuthenticatorRequest extends Message {
    constructor(data) {
      super();
      this.authenticatorId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingEditAuthenticatorRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingEditAuthenticatorRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingEditAuthenticatorRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingEditAuthenticatorRequest, a2, b);
    }
  }
  TestingEditAuthenticatorRequest.runtime = proto3;
  TestingEditAuthenticatorRequest.typeName = "domain.TestingEditAuthenticatorRequest";
  TestingEditAuthenticatorRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "authenticator_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "data", kind: "message", T: AuthenticatorData }
  ]);
  class TestingEditAuthenticatorResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingEditAuthenticatorResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingEditAuthenticatorResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingEditAuthenticatorResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingEditAuthenticatorResponse, a2, b);
    }
  }
  TestingEditAuthenticatorResponse.runtime = proto3;
  TestingEditAuthenticatorResponse.typeName = "domain.TestingEditAuthenticatorResponse";
  TestingEditAuthenticatorResponse.fields = proto3.util.newFieldList(() => []);
  class TestingDeleteAuthenticatorBlockRequest extends Message {
    constructor(data) {
      super();
      this.hash = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorBlockRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorBlockRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorBlockRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteAuthenticatorBlockRequest, a2, b);
    }
  }
  TestingDeleteAuthenticatorBlockRequest.runtime = proto3;
  TestingDeleteAuthenticatorBlockRequest.typeName = "domain.TestingDeleteAuthenticatorBlockRequest";
  TestingDeleteAuthenticatorBlockRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "hash",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class TestingDeleteAuthenticatorBlockResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteAuthenticatorBlockResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteAuthenticatorBlockResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteAuthenticatorBlockResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteAuthenticatorBlockResponse, a2, b);
    }
  }
  TestingDeleteAuthenticatorBlockResponse.runtime = proto3;
  TestingDeleteAuthenticatorBlockResponse.typeName = "domain.TestingDeleteAuthenticatorBlockResponse";
  TestingDeleteAuthenticatorBlockResponse.fields = proto3.util.newFieldList(() => []);
  class TestingDeleteVaultRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteVaultRequest, a2, b);
    }
  }
  TestingDeleteVaultRequest.runtime = proto3;
  TestingDeleteVaultRequest.typeName = "domain.TestingDeleteVaultRequest";
  TestingDeleteVaultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingDeleteVaultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingDeleteVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingDeleteVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingDeleteVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingDeleteVaultResponse, a2, b);
    }
  }
  TestingDeleteVaultResponse.runtime = proto3;
  TestingDeleteVaultResponse.typeName = "domain.TestingDeleteVaultResponse";
  TestingDeleteVaultResponse.fields = proto3.util.newFieldList(() => []);
  class TestingInjectPaddleWebhookRequest extends Message {
    constructor(data) {
      super();
      this.dataJson = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingInjectPaddleWebhookRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingInjectPaddleWebhookRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingInjectPaddleWebhookRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingInjectPaddleWebhookRequest, a2, b);
    }
  }
  TestingInjectPaddleWebhookRequest.runtime = proto3;
  TestingInjectPaddleWebhookRequest.typeName = "domain.TestingInjectPaddleWebhookRequest";
  TestingInjectPaddleWebhookRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "data_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingInjectPaddleWebhookResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingInjectPaddleWebhookResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingInjectPaddleWebhookResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingInjectPaddleWebhookResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingInjectPaddleWebhookResponse, a2, b);
    }
  }
  TestingInjectPaddleWebhookResponse.runtime = proto3;
  TestingInjectPaddleWebhookResponse.typeName = "domain.TestingInjectPaddleWebhookResponse";
  TestingInjectPaddleWebhookResponse.fields = proto3.util.newFieldList(() => []);
  class TestingUpdatePaddleRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdatePaddleRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdatePaddleRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdatePaddleRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingUpdatePaddleRequest, a2, b);
    }
  }
  TestingUpdatePaddleRequest.runtime = proto3;
  TestingUpdatePaddleRequest.typeName = "domain.TestingUpdatePaddleRequest";
  TestingUpdatePaddleRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingUpdatePaddleResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdatePaddleResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdatePaddleResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdatePaddleResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingUpdatePaddleResponse, a2, b);
    }
  }
  TestingUpdatePaddleResponse.runtime = proto3;
  TestingUpdatePaddleResponse.typeName = "domain.TestingUpdatePaddleResponse";
  TestingUpdatePaddleResponse.fields = proto3.util.newFieldList(() => []);
  class TestingCreateCouponRequest extends Message {
    constructor(data) {
      super();
      this.couponText = "";
      this.freeMembers = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCreateCouponRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCreateCouponRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCreateCouponRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingCreateCouponRequest, a2, b);
    }
  }
  TestingCreateCouponRequest.runtime = proto3;
  TestingCreateCouponRequest.typeName = "domain.TestingCreateCouponRequest";
  TestingCreateCouponRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "coupon_text",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 2,
      name: "free_members",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  class TestingCreateCouponResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCreateCouponResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCreateCouponResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCreateCouponResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingCreateCouponResponse, a2, b);
    }
  }
  TestingCreateCouponResponse.runtime = proto3;
  TestingCreateCouponResponse.typeName = "domain.TestingCreateCouponResponse";
  TestingCreateCouponResponse.fields = proto3.util.newFieldList(() => []);
  class TestingUpdateOrganizationRequest extends Message {
    constructor(data) {
      super();
      this.organizationId = "";
      this.licenseType = LicenseType.UNKNOWN;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdateOrganizationRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdateOrganizationRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdateOrganizationRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingUpdateOrganizationRequest, a2, b);
    }
  }
  TestingUpdateOrganizationRequest.runtime = proto3;
  TestingUpdateOrganizationRequest.typeName = "domain.TestingUpdateOrganizationRequest";
  TestingUpdateOrganizationRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "organization_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "created_at", kind: "message", T: Timestamp },
    { no: 3, name: "license_type", kind: "enum", T: proto3.getEnumType(LicenseType) }
  ]);
  class TestingUpdateOrganizationResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingUpdateOrganizationResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingUpdateOrganizationResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingUpdateOrganizationResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingUpdateOrganizationResponse, a2, b);
    }
  }
  TestingUpdateOrganizationResponse.runtime = proto3;
  TestingUpdateOrganizationResponse.typeName = "domain.TestingUpdateOrganizationResponse";
  TestingUpdateOrganizationResponse.fields = proto3.util.newFieldList(() => []);
  class CreateVaultMessageRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      this.type = VaultMessageType.UNKNOWN;
      this.data = new Uint8Array(0);
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateVaultMessageRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateVaultMessageRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateVaultMessageRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateVaultMessageRequest, a2, b);
    }
  }
  CreateVaultMessageRequest.runtime = proto3;
  CreateVaultMessageRequest.typeName = "domain.CreateVaultMessageRequest";
  CreateVaultMessageRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(VaultMessageType) },
    {
      no: 3,
      name: "data",
      kind: "scalar",
      T: 12
      /* ScalarType.BYTES */
    }
  ]);
  class CreateVaultMessageResponse extends Message {
    constructor(data) {
      super();
      this.messageId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new CreateVaultMessageResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new CreateVaultMessageResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new CreateVaultMessageResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(CreateVaultMessageResponse, a2, b);
    }
  }
  CreateVaultMessageResponse.runtime = proto3;
  CreateVaultMessageResponse.typeName = "domain.CreateVaultMessageResponse";
  CreateVaultMessageResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "message_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingWebauthnCreateCredentialRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      this.credentialType = CredentialType.UNKNOWN;
      this.credentialJson = "";
      this.sessionId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingWebauthnCreateCredentialRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingWebauthnCreateCredentialRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingWebauthnCreateCredentialRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingWebauthnCreateCredentialRequest, a2, b);
    }
  }
  TestingWebauthnCreateCredentialRequest.runtime = proto3;
  TestingWebauthnCreateCredentialRequest.typeName = "domain.TestingWebauthnCreateCredentialRequest";
  TestingWebauthnCreateCredentialRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "credential_type", kind: "enum", T: proto3.getEnumType(CredentialType) },
    {
      no: 3,
      name: "credential_json",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    {
      no: 4,
      name: "session_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingWebauthnCreateCredentialResponse extends Message {
    constructor(data) {
      super();
      this.webauthnId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingWebauthnCreateCredentialResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingWebauthnCreateCredentialResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingWebauthnCreateCredentialResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingWebauthnCreateCredentialResponse, a2, b);
    }
  }
  TestingWebauthnCreateCredentialResponse.runtime = proto3;
  TestingWebauthnCreateCredentialResponse.typeName = "domain.TestingWebauthnCreateCredentialResponse";
  TestingWebauthnCreateCredentialResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "webauthn_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingManipulateVaultRequest extends Message {
    constructor(data) {
      super();
      this.vaultId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingManipulateVaultRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingManipulateVaultRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingManipulateVaultRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingManipulateVaultRequest, a2, b);
    }
  }
  TestingManipulateVaultRequest.runtime = proto3;
  TestingManipulateVaultRequest.typeName = "domain.TestingManipulateVaultRequest";
  TestingManipulateVaultRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "vault_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    },
    { no: 2, name: "dirty", kind: "scalar", T: 8, opt: true },
    { no: 3, name: "message_public_key", kind: "scalar", T: 12, opt: true }
  ]);
  class TestingManipulateVaultResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingManipulateVaultResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingManipulateVaultResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingManipulateVaultResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingManipulateVaultResponse, a2, b);
    }
  }
  TestingManipulateVaultResponse.runtime = proto3;
  TestingManipulateVaultResponse.typeName = "domain.TestingManipulateVaultResponse";
  TestingManipulateVaultResponse.fields = proto3.util.newFieldList(() => []);
  class TestingCancelUserStreamingRequest extends Message {
    constructor(data) {
      super();
      this.userId = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCancelUserStreamingRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCancelUserStreamingRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCancelUserStreamingRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingCancelUserStreamingRequest, a2, b);
    }
  }
  TestingCancelUserStreamingRequest.runtime = proto3;
  TestingCancelUserStreamingRequest.typeName = "domain.TestingCancelUserStreamingRequest";
  TestingCancelUserStreamingRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "user_id",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingCancelUserStreamingResponse extends Message {
    constructor(data) {
      super();
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingCancelUserStreamingResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingCancelUserStreamingResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingCancelUserStreamingResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingCancelUserStreamingResponse, a2, b);
    }
  }
  TestingCancelUserStreamingResponse.runtime = proto3;
  TestingCancelUserStreamingResponse.typeName = "domain.TestingCancelUserStreamingResponse";
  TestingCancelUserStreamingResponse.fields = proto3.util.newFieldList(() => []);
  class TestingGetEmailStateRequest extends Message {
    constructor(data) {
      super();
      this.email = "";
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingGetEmailStateRequest().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingGetEmailStateRequest().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingGetEmailStateRequest().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingGetEmailStateRequest, a2, b);
    }
  }
  TestingGetEmailStateRequest.runtime = proto3;
  TestingGetEmailStateRequest.typeName = "domain.TestingGetEmailStateRequest";
  TestingGetEmailStateRequest.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "email",
      kind: "scalar",
      T: 9
      /* ScalarType.STRING */
    }
  ]);
  class TestingGetEmailStateResponse extends Message {
    constructor(data) {
      super();
      this.privateProfileExists = false;
      this.freeOrgProfileCount = 0;
      this.connectedOrgProfileCount = 0;
      proto3.util.initPartial(data, this);
    }
    static fromBinary(bytes, options) {
      return new TestingGetEmailStateResponse().fromBinary(bytes, options);
    }
    static fromJson(jsonValue, options) {
      return new TestingGetEmailStateResponse().fromJson(jsonValue, options);
    }
    static fromJsonString(jsonString, options) {
      return new TestingGetEmailStateResponse().fromJsonString(jsonString, options);
    }
    static equals(a2, b) {
      return proto3.util.equals(TestingGetEmailStateResponse, a2, b);
    }
  }
  TestingGetEmailStateResponse.runtime = proto3;
  TestingGetEmailStateResponse.typeName = "domain.TestingGetEmailStateResponse";
  TestingGetEmailStateResponse.fields = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "private_profile_exists",
      kind: "scalar",
      T: 8
      /* ScalarType.BOOL */
    },
    {
      no: 2,
      name: "free_org_profile_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    },
    {
      no: 3,
      name: "connected_org_profile_count",
      kind: "scalar",
      T: 5
      /* ScalarType.INT32 */
    }
  ]);
  ({
    typeName: "domain.TestingService",
    methods: {
      /**
       * errors:
       * - VaultNotFound (50400): vault not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingDropLatestCommit
       */
      testingDropLatestCommit: {
        name: "TestingDropLatestCommit",
        I: TestingDropLatestCommitRequest,
        O: TestingDropLatestCommitResponse,
        kind: MethodKind.Unary
      },
      /**
       * no errors
       *
       * @generated from rpc domain.TestingService.TestingListEmails
       */
      testingListEmails: {
        name: "TestingListEmails",
        I: TestingListEmailsRequest,
        O: TestingListEmailsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingSetServerSideSettings
       */
      testingSetServerSideSettings: {
        name: "TestingSetServerSideSettings",
        I: TestingSetServerSideSettingsRequest,
        O: TestingSetServerSideSettingsResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - UserNotFound (20400): user not found
       * - Internal (10500): internal server error
       * NOTE: this endpoint is mapped to the corresponding admin interface endpoint
       *
       * @generated from rpc domain.TestingService.TestingDeleteUser
       */
      testingDeleteUser: {
        name: "TestingDeleteUser",
        I: TestingDeleteUserRequest,
        O: TestingDeleteUserResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - UserNotFound (20400): user not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingAddAuthenticator
       */
      testingAddAuthenticator: {
        name: "TestingAddAuthenticator",
        I: TestingAddAuthenticatorRequest,
        O: TestingAddAuthenticatorResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - AuthenticatorNotFound (40400): authenticator not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingDeleteAuthenticator
       */
      testingDeleteAuthenticator: {
        name: "TestingDeleteAuthenticator",
        I: TestingDeleteAuthenticatorRequest,
        O: TestingDeleteAuthenticatorResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - AuthenticatorNotFound (40400): authenticator not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingEditAuthenticator
       */
      testingEditAuthenticator: {
        name: "TestingEditAuthenticator",
        I: TestingEditAuthenticatorRequest,
        O: TestingEditAuthenticatorResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - AuthenticatorBlockNotFound (40440): the authenticator block with given hash was not found
       * - Internal (10500): internal server error
       *
       * @generated from rpc domain.TestingService.TestingDeleteAuthenticatorBlock
       */
      testingDeleteAuthenticatorBlock: {
        name: "TestingDeleteAuthenticatorBlock",
        I: TestingDeleteAuthenticatorBlockRequest,
        O: TestingDeleteAuthenticatorBlockResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - VaultNotFound (50400)
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingDeleteVault
       */
      testingDeleteVault: {
        name: "TestingDeleteVault",
        I: TestingDeleteVaultRequest,
        O: TestingDeleteVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       * - OrganizationNotFound (60400)
       *
       * @generated from rpc domain.TestingService.TestingInjectPaddleWebhook
       */
      testingInjectPaddleWebhook: {
        name: "TestingInjectPaddleWebhook",
        I: TestingInjectPaddleWebhookRequest,
        O: TestingInjectPaddleWebhookResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingUpdatePaddle
       */
      testingUpdatePaddle: {
        name: "TestingUpdatePaddle",
        I: TestingUpdatePaddleRequest,
        O: TestingUpdatePaddleResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingCreateCoupon
       */
      testingCreateCoupon: {
        name: "TestingCreateCoupon",
        I: TestingCreateCouponRequest,
        O: TestingCreateCouponResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       * - OrganizationNotFound (60400)
       *
       * @generated from rpc domain.TestingService.TestingUpdateOrganization
       */
      testingUpdateOrganization: {
        name: "TestingUpdateOrganization",
        I: TestingUpdateOrganizationRequest,
        O: TestingUpdateOrganizationResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - VaultNotFound (50400)
       * - InvalidVaultMessageType (50463): The message provided has invalid type
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.CreateVaultMessage
       */
      createVaultMessage: {
        name: "CreateVaultMessage",
        I: CreateVaultMessageRequest,
        O: CreateVaultMessageResponse,
        kind: MethodKind.Unary
      },
      /**
       * errors:
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingWebauthnCreateCredential
       */
      testingWebauthnCreateCredential: {
        name: "TestingWebauthnCreateCredential",
        I: TestingWebauthnCreateCredentialRequest,
        O: TestingWebauthnCreateCredentialResponse,
        kind: MethodKind.Unary
      },
      /**
       * this endpoint can be used to manipulate vaults in a couple of ways
       * errors:
       * - VaultNotFound (50400)
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingManipulateVault
       */
      testingManipulateVault: {
        name: "TestingManipulateVault",
        I: TestingManipulateVaultRequest,
        O: TestingManipulateVaultResponse,
        kind: MethodKind.Unary
      },
      /**
       * this endpoint cancels all active streaming sync
       * no errors
       *
       * @generated from rpc domain.TestingService.TestingCancelUserStreaming
       */
      testingCancelUserStreaming: {
        name: "TestingCancelUserStreaming",
        I: TestingCancelUserStreamingRequest,
        O: TestingCancelUserStreamingResponse,
        kind: MethodKind.Unary
      },
      /**
       * this endpoint give information of how and where an email address is used
       * - Internal (10500)
       *
       * @generated from rpc domain.TestingService.TestingGetEmailState
       */
      testingGetEmailState: {
        name: "TestingGetEmailState",
        I: TestingGetEmailStateRequest,
        O: TestingGetEmailStateResponse,
        kind: MethodKind.Unary
      }
    }
  });
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  function assertExhaustive(_val) {
    throw new Error("This should never happen");
  }
  const objectToString$1 = Object.prototype.toString;
  function isError$1(wat) {
    switch (objectToString$1.call(wat)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  }
  function isBuiltin(wat, className) {
    return objectToString$1.call(wat) === `[object ${className}]`;
  }
  function isErrorEvent$1(wat) {
    return isBuiltin(wat, "ErrorEvent");
  }
  function isDOMError(wat) {
    return isBuiltin(wat, "DOMError");
  }
  function isDOMException(wat) {
    return isBuiltin(wat, "DOMException");
  }
  function isString$5(wat) {
    return isBuiltin(wat, "String");
  }
  function isParameterizedString(wat) {
    return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
  }
  function isPrimitive(wat) {
    return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
  }
  function isPlainObject(wat) {
    return isBuiltin(wat, "Object");
  }
  function isEvent(wat) {
    return typeof Event !== "undefined" && isInstanceOf(wat, Event);
  }
  function isElement$1(wat) {
    return typeof Element !== "undefined" && isInstanceOf(wat, Element);
  }
  function isRegExp$1(wat) {
    return isBuiltin(wat, "RegExp");
  }
  function isThenable(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  function isSyntheticEvent(wat) {
    return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
  }
  function isNaN$1(wat) {
    return typeof wat === "number" && wat !== wat;
  }
  function isInstanceOf(wat, base2) {
    try {
      return wat instanceof base2;
    } catch (_e2) {
      return false;
    }
  }
  function isVueViewModel(wat) {
    return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
  }
  function truncate(str, max2 = 0) {
    if (typeof str !== "string" || max2 === 0) {
      return str;
    }
    return str.length <= max2 ? str : `${str.slice(0, max2)}...`;
  }
  function safeJoin(input, delimiter2) {
    if (!Array.isArray(input)) {
      return "";
    }
    const output = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const value = input[i2];
      try {
        if (isVueViewModel(value)) {
          output.push("[VueViewModel]");
        } else {
          output.push(String(value));
        }
      } catch (e) {
        output.push("[value cannot be serialized]");
      }
    }
    return output.join(delimiter2);
  }
  function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
    if (!isString$5(value)) {
      return false;
    }
    if (isRegExp$1(pattern)) {
      return pattern.test(value);
    }
    if (isString$5(pattern)) {
      return requireExactStringMatch ? value === pattern : value.includes(pattern);
    }
    return false;
  }
  function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
    return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
  }
  function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
      return;
    }
    const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
    if (originalException) {
      event.exception.values = truncateAggregateExceptions(
        aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          hint.originalException,
          key,
          event.exception.values,
          originalException,
          0
        ),
        maxValueLimit
      );
    }
  }
  function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error2, key, prevExceptions, exception, exceptionId) {
    if (prevExceptions.length >= limit + 1) {
      return prevExceptions;
    }
    let newExceptions = [...prevExceptions];
    if (isInstanceOf(error2[key], Error)) {
      applyExceptionGroupFieldsForParentException(exception, exceptionId);
      const newException = exceptionFromErrorImplementation(parser, error2[key]);
      const newExceptionId = newExceptions.length;
      applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
      newExceptions = aggregateExceptionsFromError(
        exceptionFromErrorImplementation,
        parser,
        limit,
        error2[key],
        key,
        [newException, ...newExceptions],
        newException,
        newExceptionId
      );
    }
    if (Array.isArray(error2.errors)) {
      error2.errors.forEach((childError, i2) => {
        if (isInstanceOf(childError, Error)) {
          applyExceptionGroupFieldsForParentException(exception, exceptionId);
          const newException = exceptionFromErrorImplementation(parser, childError);
          const newExceptionId = newExceptions.length;
          applyExceptionGroupFieldsForChildException(newException, `errors[${i2}]`, newExceptionId, exceptionId);
          newExceptions = aggregateExceptionsFromError(
            exceptionFromErrorImplementation,
            parser,
            limit,
            childError,
            key,
            [newException, ...newExceptions],
            newException,
            newExceptionId
          );
        }
      });
    }
    return newExceptions;
  }
  function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      ...exception.type === "AggregateError" && { is_exception_group: true },
      exception_id: exceptionId
    };
  }
  function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
    exception.mechanism = exception.mechanism || { type: "generic", handled: true };
    exception.mechanism = {
      ...exception.mechanism,
      type: "chained",
      source,
      exception_id: exceptionId,
      parent_id: parentId
    };
  }
  function truncateAggregateExceptions(exceptions, maxValueLength) {
    return exceptions.map((exception) => {
      if (exception.value) {
        exception.value = truncate(exception.value, maxValueLength);
      }
      return exception;
    });
  }
  function isGlobalObj(obj) {
    return obj && obj.Math == Math ? obj : void 0;
  }
  const GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || // eslint-disable-next-line no-restricted-globals
  typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global == "object" && isGlobalObj(global) || function() {
    return this;
  }() || {};
  function getGlobalObject() {
    return GLOBAL_OBJ;
  }
  function getGlobalSingleton(name, creator, obj) {
    const gbl = obj || GLOBAL_OBJ;
    const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
    const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
  }
  const WINDOW$6 = getGlobalObject();
  const DEFAULT_MAX_STRING_LENGTH = 80;
  function htmlTreeAsString(elem, options = {}) {
    if (!elem) {
      return "<unknown>";
    }
    try {
      let currentElem = elem;
      const MAX_TRAVERSE_HEIGHT = 5;
      const out = [];
      let height = 0;
      let len = 0;
      const separator = " > ";
      const sepLength = separator.length;
      let nextStr;
      const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
      const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
        nextStr = _htmlElementAsString(currentElem, keyAttrs);
        if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
          break;
        }
        out.push(nextStr);
        len += nextStr.length;
        currentElem = currentElem.parentNode;
      }
      return out.reverse().join(separator);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function _htmlElementAsString(el, keyAttrs) {
    const elem = el;
    const out = [];
    let className;
    let classes;
    let key;
    let attr;
    let i2;
    if (!elem || !elem.tagName) {
      return "";
    }
    if (WINDOW$6.HTMLElement) {
      if (elem instanceof HTMLElement && elem.dataset && elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
    }
    out.push(elem.tagName.toLowerCase());
    const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
    if (keyAttrPairs && keyAttrPairs.length) {
      keyAttrPairs.forEach((keyAttrPair) => {
        out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
      });
    } else {
      if (elem.id) {
        out.push(`#${elem.id}`);
      }
      className = elem.className;
      if (className && isString$5(className)) {
        classes = className.split(/\s+/);
        for (i2 = 0; i2 < classes.length; i2++) {
          out.push(`.${classes[i2]}`);
        }
      }
    }
    const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
    for (i2 = 0; i2 < allowedAttrs.length; i2++) {
      key = allowedAttrs[i2];
      attr = elem.getAttribute(key);
      if (attr) {
        out.push(`[${key}="${attr}"]`);
      }
    }
    return out.join("");
  }
  function getLocationHref() {
    try {
      return WINDOW$6.document.location.href;
    } catch (oO) {
      return "";
    }
  }
  function getComponentName(elem) {
    if (!WINDOW$6.HTMLElement) {
      return null;
    }
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    for (let i2 = 0; i2 < MAX_TRAVERSE_HEIGHT; i2++) {
      if (!currentElem) {
        return null;
      }
      if (currentElem instanceof HTMLElement && currentElem.dataset["sentryComponent"]) {
        return currentElem.dataset["sentryComponent"];
      }
      currentElem = currentElem.parentNode;
    }
    return null;
  }
  const DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  const PREFIX = "Sentry Logger ";
  const CONSOLE_LEVELS = [
    "debug",
    "info",
    "warn",
    "error",
    "log",
    "assert",
    "trace"
  ];
  const originalConsoleMethods = {};
  function consoleSandbox(callback) {
    if (!("console" in GLOBAL_OBJ)) {
      return callback();
    }
    const console2 = GLOBAL_OBJ.console;
    const wrappedFuncs = {};
    const wrappedLevels = Object.keys(originalConsoleMethods);
    wrappedLevels.forEach((level) => {
      const originalConsoleMethod = originalConsoleMethods[level];
      wrappedFuncs[level] = console2[level];
      console2[level] = originalConsoleMethod;
    });
    try {
      return callback();
    } finally {
      wrappedLevels.forEach((level) => {
        console2[level] = wrappedFuncs[level];
      });
    }
  }
  function makeLogger() {
    let enabled = false;
    const logger2 = {
      enable: () => {
        enabled = true;
      },
      disable: () => {
        enabled = false;
      },
      isEnabled: () => enabled
    };
    if (DEBUG_BUILD$2) {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = (...args) => {
          if (enabled) {
            consoleSandbox(() => {
              GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS.forEach((name) => {
        logger2[name] = () => void 0;
      });
    }
    return logger2;
  }
  const logger = makeLogger();
  const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
  function isValidProtocol(protocol) {
    return protocol === "http" || protocol === "https";
  }
  function dsnToString(dsn, withPassword = false) {
    const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
    return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
  }
  function dsnFromString(str) {
    const match2 = DSN_REGEX.exec(str);
    if (!match2) {
      consoleSandbox(() => {
        console.error(`Invalid Sentry Dsn: ${str}`);
      });
      return void 0;
    }
    const [protocol, publicKey, pass = "", host, port = "", lastPath] = match2.slice(1);
    let path = "";
    let projectId = lastPath;
    const split = projectId.split("/");
    if (split.length > 1) {
      path = split.slice(0, -1).join("/");
      projectId = split.pop();
    }
    if (projectId) {
      const projectMatch = projectId.match(/^\d+/);
      if (projectMatch) {
        projectId = projectMatch[0];
      }
    }
    return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
  }
  function dsnFromComponents(components) {
    return {
      protocol: components.protocol,
      publicKey: components.publicKey || "",
      pass: components.pass || "",
      host: components.host,
      port: components.port || "",
      path: components.path || "",
      projectId: components.projectId
    };
  }
  function validateDsn(dsn) {
    if (!DEBUG_BUILD$2) {
      return true;
    }
    const { port, projectId, protocol } = dsn;
    const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
    const hasMissingRequiredComponent = requiredComponents.find((component) => {
      if (!dsn[component]) {
        logger.error(`Invalid Sentry Dsn: ${component} missing`);
        return true;
      }
      return false;
    });
    if (hasMissingRequiredComponent) {
      return false;
    }
    if (!projectId.match(/^\d+$/)) {
      logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
      return false;
    }
    if (!isValidProtocol(protocol)) {
      logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
      return false;
    }
    if (port && isNaN(parseInt(port, 10))) {
      logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
      return false;
    }
    return true;
  }
  function makeDsn(from) {
    const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
    if (!components || !validateDsn(components)) {
      return void 0;
    }
    return components;
  }
  class SentryError extends Error {
    /** Display name of this error instance. */
    constructor(message, logLevel = "warn") {
      super(message);
      this.message = message;
      this.name = new.target.prototype.constructor.name;
      Object.setPrototypeOf(this, new.target.prototype);
      this.logLevel = logLevel;
    }
  }
  function fill(source, name, replacementFactory) {
    if (!(name in source)) {
      return;
    }
    const original = source[name];
    const wrapped = replacementFactory(original);
    if (typeof wrapped === "function") {
      markFunctionWrapped(wrapped, original);
    }
    source[name] = wrapped;
  }
  function addNonEnumerableProperty(obj, name, value) {
    try {
      Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value,
        writable: true,
        configurable: true
      });
    } catch (o_O) {
      DEBUG_BUILD$2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
    }
  }
  function markFunctionWrapped(wrapped, original) {
    try {
      const proto = original.prototype || {};
      wrapped.prototype = original.prototype = proto;
      addNonEnumerableProperty(wrapped, "__sentry_original__", original);
    } catch (o_O) {
    }
  }
  function getOriginalFunction(func) {
    return func.__sentry_original__;
  }
  function urlEncode(object) {
    return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
  }
  function convertToPlainObject(value) {
    if (isError$1(value)) {
      return {
        message: value.message,
        name: value.name,
        stack: value.stack,
        ...getOwnProperties(value)
      };
    } else if (isEvent(value)) {
      const newObj = {
        type: value.type,
        target: serializeEventTarget(value.target),
        currentTarget: serializeEventTarget(value.currentTarget),
        ...getOwnProperties(value)
      };
      if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
        newObj.detail = value.detail;
      }
      return newObj;
    } else {
      return value;
    }
  }
  function serializeEventTarget(target) {
    try {
      return isElement$1(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function getOwnProperties(obj) {
    if (typeof obj === "object" && obj !== null) {
      const extractedProps = {};
      for (const property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
          extractedProps[property] = obj[property];
        }
      }
      return extractedProps;
    } else {
      return {};
    }
  }
  function extractExceptionKeysForMessage(exception, maxLength = 40) {
    const keys2 = Object.keys(convertToPlainObject(exception));
    keys2.sort();
    if (!keys2.length) {
      return "[object has no keys]";
    }
    if (keys2[0].length >= maxLength) {
      return truncate(keys2[0], maxLength);
    }
    for (let includedKeys = keys2.length; includedKeys > 0; includedKeys--) {
      const serialized = keys2.slice(0, includedKeys).join(", ");
      if (serialized.length > maxLength) {
        continue;
      }
      if (includedKeys === keys2.length) {
        return serialized;
      }
      return truncate(serialized, maxLength);
    }
    return "";
  }
  function dropUndefinedKeys(inputValue) {
    const memoizationMap = /* @__PURE__ */ new Map();
    return _dropUndefinedKeys(inputValue, memoizationMap);
  }
  function _dropUndefinedKeys(inputValue, memoizationMap) {
    if (isPojo(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== void 0) {
        return memoVal;
      }
      const returnValue = {};
      memoizationMap.set(inputValue, returnValue);
      for (const key of Object.keys(inputValue)) {
        if (typeof inputValue[key] !== "undefined") {
          returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
        }
      }
      return returnValue;
    }
    if (Array.isArray(inputValue)) {
      const memoVal = memoizationMap.get(inputValue);
      if (memoVal !== void 0) {
        return memoVal;
      }
      const returnValue = [];
      memoizationMap.set(inputValue, returnValue);
      inputValue.forEach((item) => {
        returnValue.push(_dropUndefinedKeys(item, memoizationMap));
      });
      return returnValue;
    }
    return inputValue;
  }
  function isPojo(input) {
    if (!isPlainObject(input)) {
      return false;
    }
    try {
      const name = Object.getPrototypeOf(input).constructor.name;
      return !name || name === "Object";
    } catch (e) {
      return true;
    }
  }
  const STACKTRACE_FRAME_LIMIT = 50;
  const WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
  const STRIP_FRAME_REGEXP = /captureMessage|captureException/;
  function createStackParser(...parsers) {
    const sortedParsers = parsers.sort((a2, b) => a2[0] - b[0]).map((p2) => p2[1]);
    return (stack, skipFirst = 0) => {
      const frames = [];
      const lines = stack.split("\n");
      for (let i2 = skipFirst; i2 < lines.length; i2++) {
        const line = lines[i2];
        if (line.length > 1024) {
          continue;
        }
        const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
        if (cleanedLine.match(/\S*Error: /)) {
          continue;
        }
        for (const parser of sortedParsers) {
          const frame = parser(cleanedLine);
          if (frame) {
            frames.push(frame);
            break;
          }
        }
        if (frames.length >= STACKTRACE_FRAME_LIMIT) {
          break;
        }
      }
      return stripSentryFramesAndReverse(frames);
    };
  }
  function stackParserFromStackParserOptions(stackParser) {
    if (Array.isArray(stackParser)) {
      return createStackParser(...stackParser);
    }
    return stackParser;
  }
  function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
      return [];
    }
    const localStack = Array.from(stack);
    if (/sentryWrapped/.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
    }
    localStack.reverse();
    if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
      if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
      }
    }
    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
      ...frame,
      filename: frame.filename || localStack[localStack.length - 1].filename,
      function: frame.function || "?"
    }));
  }
  const defaultFunctionName = "<anonymous>";
  function getFunctionName(fn) {
    try {
      if (!fn || typeof fn !== "function") {
        return defaultFunctionName;
      }
      return fn.name || defaultFunctionName;
    } catch (e) {
      return defaultFunctionName;
    }
  }
  const handlers = {};
  const instrumented = {};
  function addHandler(type, handler) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(handler);
  }
  function maybeInstrument(type, instrumentFn) {
    if (!instrumented[type]) {
      instrumentFn();
      instrumented[type] = true;
    }
  }
  function triggerHandlers(type, data) {
    const typeHandlers = type && handlers[type];
    if (!typeHandlers) {
      return;
    }
    for (const handler of typeHandlers) {
      try {
        handler(data);
      } catch (e) {
        DEBUG_BUILD$2 && logger.error(
          `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
          e
        );
      }
    }
  }
  function addConsoleInstrumentationHandler(handler) {
    const type = "console";
    addHandler(type, handler);
    maybeInstrument(type, instrumentConsole);
  }
  function instrumentConsole() {
    if (!("console" in GLOBAL_OBJ)) {
      return;
    }
    CONSOLE_LEVELS.forEach(function(level) {
      if (!(level in GLOBAL_OBJ.console)) {
        return;
      }
      fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
        originalConsoleMethods[level] = originalConsoleMethod;
        return function(...args) {
          const handlerData = { args, level };
          triggerHandlers("console", handlerData);
          const log = originalConsoleMethods[level];
          log && log.apply(GLOBAL_OBJ.console, args);
        };
      });
    });
  }
  function uuid4() {
    const gbl = GLOBAL_OBJ;
    const crypto2 = gbl.crypto || gbl.msCrypto;
    let getRandomByte = () => Math.random() * 16;
    try {
      if (crypto2 && crypto2.randomUUID) {
        return crypto2.randomUUID().replace(/-/g, "");
      }
      if (crypto2 && crypto2.getRandomValues) {
        getRandomByte = () => {
          const typedArray = new Uint8Array(1);
          crypto2.getRandomValues(typedArray);
          return typedArray[0];
        };
      }
    } catch (_) {
    }
    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(
      /[018]/g,
      (c2) => (
        // eslint-disable-next-line no-bitwise
        (c2 ^ (getRandomByte() & 15) >> c2 / 4).toString(16)
      )
    );
  }
  function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : void 0;
  }
  function getEventDescription(event) {
    const { message, event_id: eventId } = event;
    if (message) {
      return message;
    }
    const firstException = getFirstException(event);
    if (firstException) {
      if (firstException.type && firstException.value) {
        return `${firstException.type}: ${firstException.value}`;
      }
      return firstException.type || firstException.value || eventId || "<unknown>";
    }
    return eventId || "<unknown>";
  }
  function addExceptionTypeValue(event, value, type) {
    const exception = event.exception = event.exception || {};
    const values = exception.values = exception.values || [];
    const firstException = values[0] = values[0] || {};
    if (!firstException.value) {
      firstException.value = value || "";
    }
    if (!firstException.type) {
      firstException.type = type || "Error";
    }
  }
  function addExceptionMechanism(event, newMechanism) {
    const firstException = getFirstException(event);
    if (!firstException) {
      return;
    }
    const defaultMechanism = { type: "generic", handled: true };
    const currentMechanism = firstException.mechanism;
    firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
    if (newMechanism && "data" in newMechanism) {
      const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
      firstException.mechanism.data = mergedData;
    }
  }
  function checkOrSetAlreadyCaught(exception) {
    if (exception && exception.__sentry_captured__) {
      return true;
    }
    try {
      addNonEnumerableProperty(exception, "__sentry_captured__", true);
    } catch (err) {
    }
    return false;
  }
  function arrayify(maybeArray) {
    return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
  }
  const WINDOW$5 = GLOBAL_OBJ;
  const DEBOUNCE_DURATION = 1e3;
  let debounceTimerID;
  let lastCapturedEventType;
  let lastCapturedEventTargetId;
  function addClickKeypressInstrumentationHandler(handler) {
    const type = "dom";
    addHandler(type, handler);
    maybeInstrument(type, instrumentDOM);
  }
  function instrumentDOM() {
    if (!WINDOW$5.document) {
      return;
    }
    const triggerDOMHandler = triggerHandlers.bind(null, "dom");
    const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    WINDOW$5.document.addEventListener("click", globalDOMEventHandler, false);
    WINDOW$5.document.addEventListener("keypress", globalDOMEventHandler, false);
    ["EventTarget", "Node"].forEach((target) => {
      const proto = WINDOW$5[target] && WINDOW$5[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      fill(proto, "addEventListener", function(originalAddEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              const el = this;
              const handlers2 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers2[type] = handlers2[type] || { refCount: 0 };
              if (!handlerForType.handler) {
                const handler = makeDOMEventHandler(triggerDOMHandler);
                handlerForType.handler = handler;
                originalAddEventListener.call(this, type, handler, options);
              }
              handlerForType.refCount++;
            } catch (e) {
            }
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
      });
      fill(
        proto,
        "removeEventListener",
        function(originalRemoveEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                const el = this;
                const handlers2 = el.__sentry_instrumentation_handlers__ || {};
                const handlerForType = handlers2[type];
                if (handlerForType) {
                  handlerForType.refCount--;
                  if (handlerForType.refCount <= 0) {
                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                    handlerForType.handler = void 0;
                    delete handlers2[type];
                  }
                  if (Object.keys(handlers2).length === 0) {
                    delete el.__sentry_instrumentation_handlers__;
                  }
                }
              } catch (e) {
              }
            }
            return originalRemoveEventListener.call(this, type, listener, options);
          };
        }
      );
    });
  }
  function isSimilarToLastCapturedEvent(event) {
    if (event.type !== lastCapturedEventType) {
      return false;
    }
    try {
      if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
        return false;
      }
    } catch (e) {
    }
    return true;
  }
  function shouldSkipDOMEvent(eventType, target) {
    if (eventType !== "keypress") {
      return false;
    }
    if (!target || !target.tagName) {
      return true;
    }
    if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
      return false;
    }
    return true;
  }
  function makeDOMEventHandler(handler, globalListener = false) {
    return (event) => {
      if (!event || event["_sentryCaptured"]) {
        return;
      }
      const target = getEventTarget(event);
      if (shouldSkipDOMEvent(event.type, target)) {
        return;
      }
      addNonEnumerableProperty(event, "_sentryCaptured", true);
      if (target && !target._sentryId) {
        addNonEnumerableProperty(target, "_sentryId", uuid4());
      }
      const name = event.type === "keypress" ? "input" : event.type;
      if (!isSimilarToLastCapturedEvent(event)) {
        const handlerData = { event, name, global: globalListener };
        handler(handlerData);
        lastCapturedEventType = event.type;
        lastCapturedEventTargetId = target ? target._sentryId : void 0;
      }
      clearTimeout(debounceTimerID);
      debounceTimerID = WINDOW$5.setTimeout(() => {
        lastCapturedEventTargetId = void 0;
        lastCapturedEventType = void 0;
      }, DEBOUNCE_DURATION);
    };
  }
  function getEventTarget(event) {
    try {
      return event.target;
    } catch (e) {
      return null;
    }
  }
  const WINDOW$4 = getGlobalObject();
  function supportsFetch() {
    if (!("fetch" in WINDOW$4)) {
      return false;
    }
    try {
      new Headers();
      new Request("http://www.example.com");
      new Response();
      return true;
    } catch (e) {
      return false;
    }
  }
  function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
  }
  function supportsNativeFetch() {
    if (typeof EdgeRuntime === "string") {
      return true;
    }
    if (!supportsFetch()) {
      return false;
    }
    if (isNativeFetch(WINDOW$4.fetch)) {
      return true;
    }
    let result2 = false;
    const doc = WINDOW$4.document;
    if (doc && typeof doc.createElement === "function") {
      try {
        const sandbox = doc.createElement("iframe");
        sandbox.hidden = true;
        doc.head.appendChild(sandbox);
        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
          result2 = isNativeFetch(sandbox.contentWindow.fetch);
        }
        doc.head.removeChild(sandbox);
      } catch (err) {
        DEBUG_BUILD$2 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
      }
    }
    return result2;
  }
  function addFetchInstrumentationHandler(handler) {
    const type = "fetch";
    addHandler(type, handler);
    maybeInstrument(type, instrumentFetch);
  }
  function instrumentFetch() {
    if (!supportsNativeFetch()) {
      return;
    }
    fill(GLOBAL_OBJ, "fetch", function(originalFetch) {
      return function(...args) {
        const { method, url } = parseFetchArgs(args);
        const handlerData = {
          args,
          fetchData: {
            method,
            url
          },
          startTimestamp: Date.now()
        };
        triggerHandlers("fetch", {
          ...handlerData
        });
        return originalFetch.apply(GLOBAL_OBJ, args).then(
          (response) => {
            const finishedHandlerData = {
              ...handlerData,
              endTimestamp: Date.now(),
              response
            };
            triggerHandlers("fetch", finishedHandlerData);
            return response;
          },
          (error2) => {
            const erroredHandlerData = {
              ...handlerData,
              endTimestamp: Date.now(),
              error: error2
            };
            triggerHandlers("fetch", erroredHandlerData);
            throw error2;
          }
        );
      };
    });
  }
  function hasProp(obj, prop) {
    return !!obj && typeof obj === "object" && !!obj[prop];
  }
  function getUrlFromResource(resource) {
    if (typeof resource === "string") {
      return resource;
    }
    if (!resource) {
      return "";
    }
    if (hasProp(resource, "url")) {
      return resource.url;
    }
    if (resource.toString) {
      return resource.toString();
    }
    return "";
  }
  function parseFetchArgs(fetchArgs) {
    if (fetchArgs.length === 0) {
      return { method: "GET", url: "" };
    }
    if (fetchArgs.length === 2) {
      const [url, options] = fetchArgs;
      return {
        url: getUrlFromResource(url),
        method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
      };
    }
    const arg = fetchArgs[0];
    return {
      url: getUrlFromResource(arg),
      method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
    };
  }
  let _oldOnErrorHandler = null;
  function addGlobalErrorInstrumentationHandler(handler) {
    const type = "error";
    addHandler(type, handler);
    maybeInstrument(type, instrumentError);
  }
  function instrumentError() {
    _oldOnErrorHandler = GLOBAL_OBJ.onerror;
    GLOBAL_OBJ.onerror = function(msg, url, line, column, error2) {
      const handlerData = {
        column,
        error: error2,
        line,
        msg,
        url
      };
      triggerHandlers("error", handlerData);
      if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
        return _oldOnErrorHandler.apply(this, arguments);
      }
      return false;
    };
    GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
  }
  let _oldOnUnhandledRejectionHandler = null;
  function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
    const type = "unhandledrejection";
    addHandler(type, handler);
    maybeInstrument(type, instrumentUnhandledRejection);
  }
  function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
    GLOBAL_OBJ.onunhandledrejection = function(e) {
      const handlerData = e;
      triggerHandlers("unhandledrejection", handlerData);
      if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
        return _oldOnUnhandledRejectionHandler.apply(this, arguments);
      }
      return true;
    };
    GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
  }
  const WINDOW$3 = getGlobalObject();
  function supportsHistory() {
    const chromeVar = WINDOW$3.chrome;
    const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;
    const hasHistoryApi = "history" in WINDOW$3 && !!WINDOW$3.history.pushState && !!WINDOW$3.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
  }
  const WINDOW$2 = GLOBAL_OBJ;
  let lastHref;
  function addHistoryInstrumentationHandler(handler) {
    const type = "history";
    addHandler(type, handler);
    maybeInstrument(type, instrumentHistory);
  }
  function instrumentHistory() {
    if (!supportsHistory()) {
      return;
    }
    const oldOnPopState = WINDOW$2.onpopstate;
    WINDOW$2.onpopstate = function(...args) {
      const to = WINDOW$2.location.href;
      const from = lastHref;
      lastHref = to;
      const handlerData = { from, to };
      triggerHandlers("history", handlerData);
      if (oldOnPopState) {
        try {
          return oldOnPopState.apply(this, args);
        } catch (_oO) {
        }
      }
    };
    function historyReplacementFunction(originalHistoryFunction) {
      return function(...args) {
        const url = args.length > 2 ? args[2] : void 0;
        if (url) {
          const from = lastHref;
          const to = String(url);
          lastHref = to;
          const handlerData = { from, to };
          triggerHandlers("history", handlerData);
        }
        return originalHistoryFunction.apply(this, args);
      };
    }
    fill(WINDOW$2.history, "pushState", historyReplacementFunction);
    fill(WINDOW$2.history, "replaceState", historyReplacementFunction);
  }
  const WINDOW$1 = GLOBAL_OBJ;
  const SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
  function addXhrInstrumentationHandler(handler) {
    const type = "xhr";
    addHandler(type, handler);
    maybeInstrument(type, instrumentXHR);
  }
  function instrumentXHR() {
    if (!WINDOW$1.XMLHttpRequest) {
      return;
    }
    const xhrproto = XMLHttpRequest.prototype;
    fill(xhrproto, "open", function(originalOpen) {
      return function(...args) {
        const startTimestamp = Date.now();
        const method = isString$5(args[0]) ? args[0].toUpperCase() : void 0;
        const url = parseUrl$1(args[1]);
        if (!method || !url) {
          return originalOpen.apply(this, args);
        }
        this[SENTRY_XHR_DATA_KEY] = {
          method,
          url,
          request_headers: {}
        };
        if (method === "POST" && url.match(/sentry_key/)) {
          this.__sentry_own_request__ = true;
        }
        const onreadystatechangeHandler = () => {
          const xhrInfo = this[SENTRY_XHR_DATA_KEY];
          if (!xhrInfo) {
            return;
          }
          if (this.readyState === 4) {
            try {
              xhrInfo.status_code = this.status;
            } catch (e) {
            }
            const handlerData = {
              args: [method, url],
              endTimestamp: Date.now(),
              startTimestamp,
              xhr: this
            };
            triggerHandlers("xhr", handlerData);
          }
        };
        if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
          fill(this, "onreadystatechange", function(original) {
            return function(...readyStateArgs) {
              onreadystatechangeHandler();
              return original.apply(this, readyStateArgs);
            };
          });
        } else {
          this.addEventListener("readystatechange", onreadystatechangeHandler);
        }
        fill(this, "setRequestHeader", function(original) {
          return function(...setRequestHeaderArgs) {
            const [header, value] = setRequestHeaderArgs;
            const xhrInfo = this[SENTRY_XHR_DATA_KEY];
            if (xhrInfo && isString$5(header) && isString$5(value)) {
              xhrInfo.request_headers[header.toLowerCase()] = value;
            }
            return original.apply(this, setRequestHeaderArgs);
          };
        });
        return originalOpen.apply(this, args);
      };
    });
    fill(xhrproto, "send", function(originalSend) {
      return function(...args) {
        const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
        if (!sentryXhrData) {
          return originalSend.apply(this, args);
        }
        if (args[0] !== void 0) {
          sentryXhrData.body = args[0];
        }
        const handlerData = {
          args: [sentryXhrData.method, sentryXhrData.url],
          startTimestamp: Date.now(),
          xhr: this
        };
        triggerHandlers("xhr", handlerData);
        return originalSend.apply(this, args);
      };
    });
  }
  function parseUrl$1(url) {
    if (isString$5(url)) {
      return url;
    }
    try {
      return url.toString();
    } catch (e2) {
    }
    return void 0;
  }
  function getSDKSource() {
    return "npm";
  }
  function memoBuilder() {
    const hasWeakSet2 = typeof WeakSet === "function";
    const inner = hasWeakSet2 ? /* @__PURE__ */ new WeakSet() : [];
    function memoize(obj) {
      if (hasWeakSet2) {
        if (inner.has(obj)) {
          return true;
        }
        inner.add(obj);
        return false;
      }
      for (let i2 = 0; i2 < inner.length; i2++) {
        const value = inner[i2];
        if (value === obj) {
          return true;
        }
      }
      inner.push(obj);
      return false;
    }
    function unmemoize(obj) {
      if (hasWeakSet2) {
        inner.delete(obj);
      } else {
        for (let i2 = 0; i2 < inner.length; i2++) {
          if (inner[i2] === obj) {
            inner.splice(i2, 1);
            break;
          }
        }
      }
    }
    return [memoize, unmemoize];
  }
  function normalize(input, depth = 100, maxProperties = Infinity) {
    try {
      return visit("", input, depth, maxProperties);
    } catch (err) {
      return { ERROR: `**non-serializable** (${err})` };
    }
  }
  function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
    const normalized = normalize(object, depth);
    if (jsonSize(normalized) > maxSize) {
      return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
  }
  function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
    const [memoize, unmemoize] = memo;
    if (value == null || // this matches null and undefined -> eqeq not eqeqeq
    ["number", "boolean", "string"].includes(typeof value) && !isNaN$1(value)) {
      return value;
    }
    const stringified = stringifyValue(key, value);
    if (!stringified.startsWith("[object ")) {
      return stringified;
    }
    if (value["__sentry_skip_normalization__"]) {
      return value;
    }
    const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
    if (remainingDepth === 0) {
      return stringified.replace("object ", "");
    }
    if (memoize(value)) {
      return "[Circular ~]";
    }
    const valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
      try {
        const jsonValue = valueWithToJSON.toJSON();
        return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
      } catch (err) {
      }
    }
    const normalized = Array.isArray(value) ? [] : {};
    let numAdded = 0;
    const visitable = convertToPlainObject(value);
    for (const visitKey in visitable) {
      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
        continue;
      }
      if (numAdded >= maxProperties) {
        normalized[visitKey] = "[MaxProperties ~]";
        break;
      }
      const visitValue = visitable[visitKey];
      normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
      numAdded++;
    }
    unmemoize(value);
    return normalized;
  }
  function stringifyValue(key, value) {
    try {
      if (key === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (isVueViewModel(value)) {
        return "[VueViewModel]";
      }
      if (isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (typeof value === "function") {
        return `[Function: ${getFunctionName(value)}]`;
      }
      if (typeof value === "symbol") {
        return `[${String(value)}]`;
      }
      if (typeof value === "bigint") {
        return `[BigInt: ${String(value)}]`;
      }
      const objName = getConstructorName(value);
      if (/^HTML(\w*)Element$/.test(objName)) {
        return `[HTMLElement: ${objName}]`;
      }
      return `[object ${objName}]`;
    } catch (err) {
      return `**non-serializable** (${err})`;
    }
  }
  function getConstructorName(value) {
    const prototype = Object.getPrototypeOf(value);
    return prototype ? prototype.constructor.name : "null prototype";
  }
  function utf8Length(value) {
    return ~-encodeURI(value).split(/%..|./).length;
  }
  function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
  }
  var States;
  (function(States2) {
    const PENDING = 0;
    States2[States2["PENDING"] = PENDING] = "PENDING";
    const RESOLVED = 1;
    States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
    const REJECTED = 2;
    States2[States2["REJECTED"] = REJECTED] = "REJECTED";
  })(States || (States = {}));
  function resolvedSyncPromise(value) {
    return new SyncPromise((resolve) => {
      resolve(value);
    });
  }
  function rejectedSyncPromise(reason) {
    return new SyncPromise((_, reject) => {
      reject(reason);
    });
  }
  class SyncPromise {
    constructor(executor) {
      SyncPromise.prototype.__init.call(this);
      SyncPromise.prototype.__init2.call(this);
      SyncPromise.prototype.__init3.call(this);
      SyncPromise.prototype.__init4.call(this);
      this._state = States.PENDING;
      this._handlers = [];
      try {
        executor(this._resolve, this._reject);
      } catch (e) {
        this._reject(e);
      }
    }
    /** JSDoc */
    then(onfulfilled, onrejected) {
      return new SyncPromise((resolve, reject) => {
        this._handlers.push([
          false,
          (result2) => {
            if (!onfulfilled) {
              resolve(result2);
            } else {
              try {
                resolve(onfulfilled(result2));
              } catch (e) {
                reject(e);
              }
            }
          },
          (reason) => {
            if (!onrejected) {
              reject(reason);
            } else {
              try {
                resolve(onrejected(reason));
              } catch (e) {
                reject(e);
              }
            }
          }
        ]);
        this._executeHandlers();
      });
    }
    /** JSDoc */
    catch(onrejected) {
      return this.then((val) => val, onrejected);
    }
    /** JSDoc */
    finally(onfinally) {
      return new SyncPromise((resolve, reject) => {
        let val;
        let isRejected;
        return this.then(
          (value) => {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          },
          (reason) => {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }
        ).then(() => {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    }
    /** JSDoc */
    __init() {
      this._resolve = (value) => {
        this._setResult(States.RESOLVED, value);
      };
    }
    /** JSDoc */
    __init2() {
      this._reject = (reason) => {
        this._setResult(States.REJECTED, reason);
      };
    }
    /** JSDoc */
    __init3() {
      this._setResult = (state, value) => {
        if (this._state !== States.PENDING) {
          return;
        }
        if (isThenable(value)) {
          void value.then(this._resolve, this._reject);
          return;
        }
        this._state = state;
        this._value = value;
        this._executeHandlers();
      };
    }
    /** JSDoc */
    __init4() {
      this._executeHandlers = () => {
        if (this._state === States.PENDING) {
          return;
        }
        const cachedHandlers = this._handlers.slice();
        this._handlers = [];
        cachedHandlers.forEach((handler) => {
          if (handler[0]) {
            return;
          }
          if (this._state === States.RESOLVED) {
            handler[1](this._value);
          }
          if (this._state === States.REJECTED) {
            handler[2](this._value);
          }
          handler[0] = true;
        });
      };
    }
  }
  function makePromiseBuffer(limit) {
    const buffer = [];
    function isReady() {
      return limit === void 0 || buffer.length < limit;
    }
    function remove(task) {
      return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    function add(taskProducer) {
      if (!isReady()) {
        return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
      }
      const task = taskProducer();
      if (buffer.indexOf(task) === -1) {
        buffer.push(task);
      }
      void task.then(() => remove(task)).then(
        null,
        () => remove(task).then(null, () => {
        })
      );
      return task;
    }
    function drain(timeout) {
      return new SyncPromise((resolve, reject) => {
        let counter = buffer.length;
        if (!counter) {
          return resolve(true);
        }
        const capturedSetTimeout = setTimeout(() => {
          if (timeout && timeout > 0) {
            resolve(false);
          }
        }, timeout);
        buffer.forEach((item) => {
          void resolvedSyncPromise(item).then(() => {
            if (!--counter) {
              clearTimeout(capturedSetTimeout);
              resolve(true);
            }
          }, reject);
        });
      });
    }
    return {
      $: buffer,
      add,
      drain
    };
  }
  function parseUrl(url) {
    if (!url) {
      return {};
    }
    const match2 = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match2) {
      return {};
    }
    const query = match2[6] || "";
    const fragment = match2[8] || "";
    return {
      host: match2[4],
      path: match2[5],
      protocol: match2[2],
      search: query,
      hash: fragment,
      relative: match2[5] + query + fragment
      // everything minus origin
    };
  }
  const validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
  function severityLevelFromString(level) {
    return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
  }
  const ONE_SECOND_IN_MS = 1e3;
  function dateTimestampInSeconds() {
    return Date.now() / ONE_SECOND_IN_MS;
  }
  function createUnixTimestampInSecondsFunc() {
    const { performance } = GLOBAL_OBJ;
    if (!performance || !performance.now) {
      return dateTimestampInSeconds;
    }
    const approxStartingTimeOrigin = Date.now() - performance.now();
    const timeOrigin = performance.timeOrigin == void 0 ? approxStartingTimeOrigin : performance.timeOrigin;
    return () => {
      return (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;
    };
  }
  const timestampInSeconds = createUnixTimestampInSecondsFunc();
  (() => {
    const { performance } = GLOBAL_OBJ;
    if (!performance || !performance.now) {
      return void 0;
    }
    const threshold = 3600 * 1e3;
    const performanceNow = performance.now();
    const dateNow = Date.now();
    const timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : threshold;
    const timeOriginIsReliable = timeOriginDelta < threshold;
    const navigationStart = performance.timing && performance.timing.navigationStart;
    const hasNavigationStart = typeof navigationStart === "number";
    const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    const navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        return performance.timeOrigin;
      } else {
        return navigationStart;
      }
    }
    return dateNow;
  })();
  function createEnvelope(headers, items = []) {
    return [headers, items];
  }
  function addItemToEnvelope(envelope, newItem) {
    const [headers, items] = envelope;
    return [headers, [...items, newItem]];
  }
  function forEachEnvelopeItem(envelope, callback) {
    const envelopeItems = envelope[1];
    for (const envelopeItem of envelopeItems) {
      const envelopeItemType = envelopeItem[0].type;
      const result2 = callback(envelopeItem, envelopeItemType);
      if (result2) {
        return true;
      }
    }
    return false;
  }
  function encodeUTF8(input, textEncoder) {
    const utf8 = textEncoder || new TextEncoder();
    return utf8.encode(input);
  }
  function serializeEnvelope(envelope, textEncoder) {
    const [envHeaders, items] = envelope;
    let parts = JSON.stringify(envHeaders);
    function append(next) {
      if (typeof parts === "string") {
        parts = typeof next === "string" ? parts + next : [encodeUTF8(parts, textEncoder), next];
      } else {
        parts.push(typeof next === "string" ? encodeUTF8(next, textEncoder) : next);
      }
    }
    for (const item of items) {
      const [itemHeaders, payload] = item;
      append(`
${JSON.stringify(itemHeaders)}
`);
      if (typeof payload === "string" || payload instanceof Uint8Array) {
        append(payload);
      } else {
        let stringifiedPayload;
        try {
          stringifiedPayload = JSON.stringify(payload);
        } catch (e) {
          stringifiedPayload = JSON.stringify(normalize(payload));
        }
        append(stringifiedPayload);
      }
    }
    return typeof parts === "string" ? parts : concatBuffers(parts);
  }
  function concatBuffers(buffers) {
    const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
    const merged = new Uint8Array(totalLength);
    let offset = 0;
    for (const buffer of buffers) {
      merged.set(buffer, offset);
      offset += buffer.length;
    }
    return merged;
  }
  function createAttachmentEnvelopeItem(attachment, textEncoder) {
    const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
    return [
      dropUndefinedKeys({
        type: "attachment",
        length: buffer.length,
        filename: attachment.filename,
        content_type: attachment.contentType,
        attachment_type: attachment.attachmentType
      }),
      buffer
    ];
  }
  const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    span: "span",
    statsd: "metric_bucket"
  };
  function envelopeItemTypeToDataCategory(type) {
    return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
  }
  function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
    if (!metadataOrEvent || !metadataOrEvent.sdk) {
      return;
    }
    const { name, version } = metadataOrEvent.sdk;
    return { name, version };
  }
  function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
    const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
    return {
      event_id: event.event_id,
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
      ...dynamicSamplingContext && {
        trace: dropUndefinedKeys({ ...dynamicSamplingContext })
      }
    };
  }
  function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    const clientReportItem = [
      { type: "client_report" },
      {
        timestamp: timestamp || dateTimestampInSeconds(),
        discarded_events
      }
    ];
    return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
  }
  const DEFAULT_RETRY_AFTER = 60 * 1e3;
  function parseRetryAfterHeader(header, now = Date.now()) {
    const headerDelay = parseInt(`${header}`, 10);
    if (!isNaN(headerDelay)) {
      return headerDelay * 1e3;
    }
    const headerDate = Date.parse(`${header}`);
    if (!isNaN(headerDate)) {
      return headerDate - now;
    }
    return DEFAULT_RETRY_AFTER;
  }
  function disabledUntil(limits, dataCategory) {
    return limits[dataCategory] || limits.all || 0;
  }
  function isRateLimited(limits, dataCategory, now = Date.now()) {
    return disabledUntil(limits, dataCategory) > now;
  }
  function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
    const updatedRateLimits = {
      ...limits
    };
    const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
    const retryAfterHeader = headers && headers["retry-after"];
    if (rateLimitHeader) {
      for (const limit of rateLimitHeader.trim().split(",")) {
        const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
        const headerDelay = parseInt(retryAfter, 10);
        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
        if (!categories) {
          updatedRateLimits.all = now + delay;
        } else {
          for (const category of categories.split(";")) {
            if (category === "metric_bucket") {
              if (!namespaces || namespaces.split(";").includes("custom")) {
                updatedRateLimits[category] = now + delay;
              }
            } else {
              updatedRateLimits[category] = now + delay;
            }
          }
        }
      }
    } else if (retryAfterHeader) {
      updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    } else if (statusCode === 429) {
      updatedRateLimits.all = now + 60 * 1e3;
    }
    return updatedRateLimits;
  }
  const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  const DEFAULT_ENVIRONMENT = "production";
  function getGlobalEventProcessors() {
    return getGlobalSingleton("globalEventProcessors", () => []);
  }
  function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
  }
  function notifyEventProcessors(processors, event, hint, index = 0) {
    return new SyncPromise((resolve, reject) => {
      const processor = processors[index];
      if (event === null || typeof processor !== "function") {
        resolve(event);
      } else {
        const result2 = processor({ ...event }, hint);
        DEBUG_BUILD$1 && processor.id && result2 === null && logger.log(`Event processor "${processor.id}" dropped event`);
        if (isThenable(result2)) {
          void result2.then((final) => notifyEventProcessors(processors, final, hint, index + 1).then(resolve)).then(null, reject);
        } else {
          void notifyEventProcessors(processors, result2, hint, index + 1).then(resolve).then(null, reject);
        }
      }
    });
  }
  function makeSession(context) {
    const startingTime = timestampInSeconds();
    const session = {
      sid: uuid4(),
      init: true,
      timestamp: startingTime,
      started: startingTime,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: false,
      toJSON: () => sessionToJSON(session)
    };
    if (context) {
      updateSession(session, context);
    }
    return session;
  }
  function updateSession(session, context = {}) {
    if (context.user) {
      if (!session.ipAddress && context.user.ip_address) {
        session.ipAddress = context.user.ip_address;
      }
      if (!session.did && !context.did) {
        session.did = context.user.id || context.user.email || context.user.username;
      }
    }
    session.timestamp = context.timestamp || timestampInSeconds();
    if (context.abnormal_mechanism) {
      session.abnormal_mechanism = context.abnormal_mechanism;
    }
    if (context.ignoreDuration) {
      session.ignoreDuration = context.ignoreDuration;
    }
    if (context.sid) {
      session.sid = context.sid.length === 32 ? context.sid : uuid4();
    }
    if (context.init !== void 0) {
      session.init = context.init;
    }
    if (!session.did && context.did) {
      session.did = `${context.did}`;
    }
    if (typeof context.started === "number") {
      session.started = context.started;
    }
    if (session.ignoreDuration) {
      session.duration = void 0;
    } else if (typeof context.duration === "number") {
      session.duration = context.duration;
    } else {
      const duration = session.timestamp - session.started;
      session.duration = duration >= 0 ? duration : 0;
    }
    if (context.release) {
      session.release = context.release;
    }
    if (context.environment) {
      session.environment = context.environment;
    }
    if (!session.ipAddress && context.ipAddress) {
      session.ipAddress = context.ipAddress;
    }
    if (!session.userAgent && context.userAgent) {
      session.userAgent = context.userAgent;
    }
    if (typeof context.errors === "number") {
      session.errors = context.errors;
    }
    if (context.status) {
      session.status = context.status;
    }
  }
  function closeSession(session, status) {
    let context = {};
    if (status) {
      context = { status };
    } else if (session.status === "ok") {
      context = { status: "exited" };
    }
    updateSession(session, context);
  }
  function sessionToJSON(session) {
    return dropUndefinedKeys({
      sid: `${session.sid}`,
      init: session.init,
      // Make sure that sec is converted to ms for date constructor
      started: new Date(session.started * 1e3).toISOString(),
      timestamp: new Date(session.timestamp * 1e3).toISOString(),
      status: session.status,
      errors: session.errors,
      did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
      duration: session.duration,
      abnormal_mechanism: session.abnormal_mechanism,
      attrs: {
        release: session.release,
        environment: session.environment,
        ip_address: session.ipAddress,
        user_agent: session.userAgent
      }
    });
  }
  const TRACE_FLAG_SAMPLED = 1;
  function spanToTraceContext(span) {
    const { spanId: span_id, traceId: trace_id } = span.spanContext();
    const { data, op, parent_span_id, status, tags, origin } = spanToJSON(span);
    return dropUndefinedKeys({
      data,
      op,
      parent_span_id,
      span_id,
      status,
      tags,
      trace_id,
      origin
    });
  }
  function spanToJSON(span) {
    if (spanIsSpanClass(span)) {
      return span.getSpanJSON();
    }
    if (typeof span.toJSON === "function") {
      return span.toJSON();
    }
    return {};
  }
  function spanIsSpanClass(span) {
    return typeof span.getSpanJSON === "function";
  }
  function spanIsSampled(span) {
    const { traceFlags } = span.spanContext();
    return Boolean(traceFlags & TRACE_FLAG_SAMPLED);
  }
  function prepareEvent(options, event, hint, scope, client, isolationScope) {
    const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
    const prepared = {
      ...event,
      event_id: event.event_id || hint.event_id || uuid4(),
      timestamp: event.timestamp || dateTimestampInSeconds()
    };
    const integrations = hint.integrations || options.integrations.map((i2) => i2.name);
    applyClientOptions(prepared, options);
    applyIntegrationsMetadata(prepared, integrations);
    if (event.type === void 0) {
      applyDebugIds(prepared, options.stackParser);
    }
    const finalScope = getFinalScope(scope, hint.captureContext);
    if (hint.mechanism) {
      addExceptionMechanism(prepared, hint.mechanism);
    }
    const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];
    const data = getGlobalScope().getScopeData();
    if (isolationScope) {
      const isolationData = isolationScope.getScopeData();
      mergeScopeData(data, isolationData);
    }
    if (finalScope) {
      const finalScopeData = finalScope.getScopeData();
      mergeScopeData(data, finalScopeData);
    }
    const attachments = [...hint.attachments || [], ...data.attachments];
    if (attachments.length) {
      hint.attachments = attachments;
    }
    applyScopeDataToEvent(prepared, data);
    const eventProcessors = [
      ...clientEventProcessors,
      // eslint-disable-next-line deprecation/deprecation
      ...getGlobalEventProcessors(),
      // Run scope event processors _after_ all other processors
      ...data.eventProcessors
    ];
    const result2 = notifyEventProcessors(eventProcessors, prepared, hint);
    return result2.then((evt) => {
      if (evt) {
        applyDebugMeta(evt);
      }
      if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
        return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
      }
      return evt;
    });
  }
  function applyClientOptions(event, options) {
    const { environment, release, dist: dist2, maxValueLength = 250 } = options;
    if (!("environment" in event)) {
      event.environment = "environment" in options ? environment : DEFAULT_ENVIRONMENT;
    }
    if (event.release === void 0 && release !== void 0) {
      event.release = release;
    }
    if (event.dist === void 0 && dist2 !== void 0) {
      event.dist = dist2;
    }
    if (event.message) {
      event.message = truncate(event.message, maxValueLength);
    }
    const exception = event.exception && event.exception.values && event.exception.values[0];
    if (exception && exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }
    const request = event.request;
    if (request && request.url) {
      request.url = truncate(request.url, maxValueLength);
    }
  }
  const debugIdStackParserCache = /* @__PURE__ */ new WeakMap();
  function applyDebugIds(event, stackParser) {
    const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
    if (!debugIdMap) {
      return;
    }
    let debugIdStackFramesCache;
    const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
    if (cachedDebugIdStackFrameCache) {
      debugIdStackFramesCache = cachedDebugIdStackFrameCache;
    } else {
      debugIdStackFramesCache = /* @__PURE__ */ new Map();
      debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
    }
    const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
      let parsedStack;
      const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
      if (cachedParsedStack) {
        parsedStack = cachedParsedStack;
      } else {
        parsedStack = stackParser(debugIdStackTrace);
        debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
      }
      for (let i2 = parsedStack.length - 1; i2 >= 0; i2--) {
        const stackFrame = parsedStack[i2];
        if (stackFrame.filename) {
          acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
          break;
        }
      }
      return acc;
    }, {});
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame) => {
          if (frame.filename) {
            frame.debug_id = filenameDebugIdMap[frame.filename];
          }
        });
      });
    } catch (e) {
    }
  }
  function applyDebugMeta(event) {
    const filenameDebugIdMap = {};
    try {
      event.exception.values.forEach((exception) => {
        exception.stacktrace.frames.forEach((frame) => {
          if (frame.debug_id) {
            if (frame.abs_path) {
              filenameDebugIdMap[frame.abs_path] = frame.debug_id;
            } else if (frame.filename) {
              filenameDebugIdMap[frame.filename] = frame.debug_id;
            }
            delete frame.debug_id;
          }
        });
      });
    } catch (e) {
    }
    if (Object.keys(filenameDebugIdMap).length === 0) {
      return;
    }
    event.debug_meta = event.debug_meta || {};
    event.debug_meta.images = event.debug_meta.images || [];
    const images = event.debug_meta.images;
    Object.keys(filenameDebugIdMap).forEach((filename) => {
      images.push({
        type: "sourcemap",
        code_file: filename,
        debug_id: filenameDebugIdMap[filename]
      });
    });
  }
  function applyIntegrationsMetadata(event, integrationNames) {
    if (integrationNames.length > 0) {
      event.sdk = event.sdk || {};
      event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
    }
  }
  function normalizeEvent(event, depth, maxBreadth) {
    if (!event) {
      return null;
    }
    const normalized = {
      ...event,
      ...event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map((b) => ({
          ...b,
          ...b.data && {
            data: normalize(b.data, depth, maxBreadth)
          }
        }))
      },
      ...event.user && {
        user: normalize(event.user, depth, maxBreadth)
      },
      ...event.contexts && {
        contexts: normalize(event.contexts, depth, maxBreadth)
      },
      ...event.extra && {
        extra: normalize(event.extra, depth, maxBreadth)
      }
    };
    if (event.contexts && event.contexts.trace && normalized.contexts) {
      normalized.contexts.trace = event.contexts.trace;
      if (event.contexts.trace.data) {
        normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
      }
    }
    if (event.spans) {
      normalized.spans = event.spans.map((span) => {
        const data = spanToJSON(span).data;
        if (data) {
          span.data = normalize(data, depth, maxBreadth);
        }
        return span;
      });
    }
    return normalized;
  }
  function getFinalScope(scope, captureContext) {
    if (!captureContext) {
      return scope;
    }
    const finalScope = scope ? scope.clone() : new Scope();
    finalScope.update(captureContext);
    return finalScope;
  }
  function parseEventHintOrCaptureContext(hint) {
    if (!hint) {
      return void 0;
    }
    if (hintIsScopeOrFunction(hint)) {
      return { captureContext: hint };
    }
    if (hintIsScopeContext(hint)) {
      return {
        captureContext: hint
      };
    }
    return hint;
  }
  function hintIsScopeOrFunction(hint) {
    return hint instanceof Scope || typeof hint === "function";
  }
  const captureContextKeys = [
    "user",
    "level",
    "extra",
    "contexts",
    "tags",
    "fingerprint",
    "requestSession",
    "propagationContext"
  ];
  function hintIsScopeContext(hint) {
    return Object.keys(hint).some((key) => captureContextKeys.includes(key));
  }
  function captureException(exception, hint) {
    return getCurrentHub().captureException(exception, parseEventHintOrCaptureContext(hint));
  }
  function captureMessage(message, captureContext) {
    const level = typeof captureContext === "string" ? captureContext : void 0;
    const context = typeof captureContext !== "string" ? { captureContext } : void 0;
    return getCurrentHub().captureMessage(message, level, context);
  }
  function captureEvent(event, hint) {
    return getCurrentHub().captureEvent(event, hint);
  }
  function configureScope$1(callback) {
    getCurrentHub().configureScope(callback);
  }
  function addBreadcrumb(breadcrumb, hint) {
    getCurrentHub().addBreadcrumb(breadcrumb, hint);
  }
  function setExtra(key, extra) {
    getCurrentHub().setExtra(key, extra);
  }
  function withScope(...rest) {
    const hub = getCurrentHub();
    if (rest.length === 2) {
      const [scope, callback] = rest;
      if (!scope) {
        return hub.withScope(callback);
      }
      return hub.withScope(() => {
        hub.getStackTop().scope = scope;
        return callback(scope);
      });
    }
    return hub.withScope(rest[0]);
  }
  function getClient() {
    return getCurrentHub().getClient();
  }
  function getCurrentScope() {
    return getCurrentHub().getScope();
  }
  function startSession(context) {
    const client = getClient();
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
    const { userAgent } = GLOBAL_OBJ.navigator || {};
    const session = makeSession({
      release,
      environment,
      user: currentScope.getUser() || isolationScope.getUser(),
      ...userAgent && { userAgent },
      ...context
    });
    const currentSession = isolationScope.getSession();
    if (currentSession && currentSession.status === "ok") {
      updateSession(currentSession, { status: "exited" });
    }
    endSession();
    isolationScope.setSession(session);
    currentScope.setSession(session);
    return session;
  }
  function endSession() {
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const session = currentScope.getSession() || isolationScope.getSession();
    if (session) {
      closeSession(session);
    }
    _sendSessionUpdate();
    isolationScope.setSession();
    currentScope.setSession();
  }
  function _sendSessionUpdate() {
    const isolationScope = getIsolationScope();
    const currentScope = getCurrentScope();
    const client = getClient();
    const session = currentScope.getSession() || isolationScope.getSession();
    if (session && client && client.captureSession) {
      client.captureSession(session);
    }
  }
  function captureSession(end = false) {
    if (end) {
      endSession();
      return;
    }
    _sendSessionUpdate();
  }
  function getRootSpan(span) {
    return span.transaction;
  }
  function getDynamicSamplingContextFromClient(trace_id, client, scope) {
    const options = client.getOptions();
    const { publicKey: public_key } = client.getDsn() || {};
    const { segment: user_segment } = scope && scope.getUser() || {};
    const dsc = dropUndefinedKeys({
      environment: options.environment || DEFAULT_ENVIRONMENT,
      release: options.release,
      user_segment,
      public_key,
      trace_id
    });
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  }
  function getDynamicSamplingContextFromSpan(span) {
    const client = getClient();
    if (!client) {
      return {};
    }
    const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || "", client, getCurrentScope());
    const txn = getRootSpan(span);
    if (!txn) {
      return dsc;
    }
    const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;
    if (v7FrozenDsc) {
      return v7FrozenDsc;
    }
    const { sampleRate: maybeSampleRate, source } = txn.metadata;
    if (maybeSampleRate != null) {
      dsc.sample_rate = `${maybeSampleRate}`;
    }
    const jsonSpan = spanToJSON(txn);
    if (source && source !== "url") {
      dsc.transaction = jsonSpan.description;
    }
    dsc.sampled = String(spanIsSampled(txn));
    client.emit && client.emit("createDsc", dsc);
    return dsc;
  }
  function applyScopeDataToEvent(event, data) {
    const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
    applyDataToEvent(event, data);
    if (span) {
      applySpanToEvent(event, span);
    }
    applyFingerprintToEvent(event, fingerprint);
    applyBreadcrumbsToEvent(event, breadcrumbs);
    applySdkMetadataToEvent(event, sdkProcessingMetadata);
  }
  function mergeScopeData(data, mergeData) {
    const {
      extra,
      tags,
      user,
      contexts,
      level,
      sdkProcessingMetadata,
      breadcrumbs,
      fingerprint,
      eventProcessors,
      attachments,
      propagationContext,
      // eslint-disable-next-line deprecation/deprecation
      transactionName,
      span
    } = mergeData;
    mergeAndOverwriteScopeData(data, "extra", extra);
    mergeAndOverwriteScopeData(data, "tags", tags);
    mergeAndOverwriteScopeData(data, "user", user);
    mergeAndOverwriteScopeData(data, "contexts", contexts);
    mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata);
    if (level) {
      data.level = level;
    }
    if (transactionName) {
      data.transactionName = transactionName;
    }
    if (span) {
      data.span = span;
    }
    if (breadcrumbs.length) {
      data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
    }
    if (fingerprint.length) {
      data.fingerprint = [...data.fingerprint, ...fingerprint];
    }
    if (eventProcessors.length) {
      data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
    }
    if (attachments.length) {
      data.attachments = [...data.attachments, ...attachments];
    }
    data.propagationContext = { ...data.propagationContext, ...propagationContext };
  }
  function mergeAndOverwriteScopeData(data, prop, mergeVal) {
    if (mergeVal && Object.keys(mergeVal).length) {
      data[prop] = { ...data[prop] };
      for (const key in mergeVal) {
        if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {
          data[prop][key] = mergeVal[key];
        }
      }
    }
  }
  function applyDataToEvent(event, data) {
    const {
      extra,
      tags,
      user,
      contexts,
      level,
      // eslint-disable-next-line deprecation/deprecation
      transactionName
    } = data;
    const cleanedExtra = dropUndefinedKeys(extra);
    if (cleanedExtra && Object.keys(cleanedExtra).length) {
      event.extra = { ...cleanedExtra, ...event.extra };
    }
    const cleanedTags = dropUndefinedKeys(tags);
    if (cleanedTags && Object.keys(cleanedTags).length) {
      event.tags = { ...cleanedTags, ...event.tags };
    }
    const cleanedUser = dropUndefinedKeys(user);
    if (cleanedUser && Object.keys(cleanedUser).length) {
      event.user = { ...cleanedUser, ...event.user };
    }
    const cleanedContexts = dropUndefinedKeys(contexts);
    if (cleanedContexts && Object.keys(cleanedContexts).length) {
      event.contexts = { ...cleanedContexts, ...event.contexts };
    }
    if (level) {
      event.level = level;
    }
    if (transactionName) {
      event.transaction = transactionName;
    }
  }
  function applyBreadcrumbsToEvent(event, breadcrumbs) {
    const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
    event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
  }
  function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
    event.sdkProcessingMetadata = {
      ...event.sdkProcessingMetadata,
      ...sdkProcessingMetadata
    };
  }
  function applySpanToEvent(event, span) {
    event.contexts = { trace: spanToTraceContext(span), ...event.contexts };
    const rootSpan = getRootSpan(span);
    if (rootSpan) {
      event.sdkProcessingMetadata = {
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
        ...event.sdkProcessingMetadata
      };
      const transactionName = spanToJSON(rootSpan).description;
      if (transactionName) {
        event.tags = { transaction: transactionName, ...event.tags };
      }
    }
  }
  function applyFingerprintToEvent(event, fingerprint) {
    event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];
    if (fingerprint) {
      event.fingerprint = event.fingerprint.concat(fingerprint);
    }
    if (event.fingerprint && !event.fingerprint.length) {
      delete event.fingerprint;
    }
  }
  const DEFAULT_MAX_BREADCRUMBS = 100;
  let globalScope;
  class Scope {
    /** Flag if notifying is happening. */
    /** Callback for client to receive scope changes. */
    /** Callback list that will be called after {@link applyToEvent}. */
    /** Array of breadcrumbs. */
    /** User */
    /** Tags */
    /** Extra */
    /** Contexts */
    /** Attachments */
    /** Propagation Context for distributed tracing */
    /**
     * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
     * sent to Sentry
     */
    /** Fingerprint */
    /** Severity */
    // eslint-disable-next-line deprecation/deprecation
    /**
     * Transaction Name
     */
    /** Span */
    /** Session */
    /** Request Mode Session Status */
    /** The client on this scope */
    // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
    constructor() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._attachments = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
      this._propagationContext = generatePropagationContext();
    }
    /**
     * Inherit values from the parent scope.
     * @deprecated Use `scope.clone()` and `new Scope()` instead.
     */
    static clone(scope) {
      return scope ? scope.clone() : new Scope();
    }
    /**
     * Clone this scope instance.
     */
    clone() {
      const newScope = new Scope();
      newScope._breadcrumbs = [...this._breadcrumbs];
      newScope._tags = { ...this._tags };
      newScope._extra = { ...this._extra };
      newScope._contexts = { ...this._contexts };
      newScope._user = this._user;
      newScope._level = this._level;
      newScope._span = this._span;
      newScope._session = this._session;
      newScope._transactionName = this._transactionName;
      newScope._fingerprint = this._fingerprint;
      newScope._eventProcessors = [...this._eventProcessors];
      newScope._requestSession = this._requestSession;
      newScope._attachments = [...this._attachments];
      newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
      newScope._propagationContext = { ...this._propagationContext };
      newScope._client = this._client;
      return newScope;
    }
    /** Update the client on the scope. */
    setClient(client) {
      this._client = client;
    }
    /**
     * Get the client assigned to this scope.
     *
     * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.
     */
    getClient() {
      return this._client;
    }
    /**
     * Add internal on change listener. Used for sub SDKs that need to store the scope.
     * @hidden
     */
    addScopeListener(callback) {
      this._scopeListeners.push(callback);
    }
    /**
     * @inheritDoc
     */
    addEventProcessor(callback) {
      this._eventProcessors.push(callback);
      return this;
    }
    /**
     * @inheritDoc
     */
    setUser(user) {
      this._user = user || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        segment: void 0,
        username: void 0
      };
      if (this._session) {
        updateSession(this._session, { user });
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getUser() {
      return this._user;
    }
    /**
     * @inheritDoc
     */
    getRequestSession() {
      return this._requestSession;
    }
    /**
     * @inheritDoc
     */
    setRequestSession(requestSession) {
      this._requestSession = requestSession;
      return this;
    }
    /**
     * @inheritDoc
     */
    setTags(tags) {
      this._tags = {
        ...this._tags,
        ...tags
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setTag(key, value) {
      this._tags = { ...this._tags, [key]: value };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setExtras(extras) {
      this._extra = {
        ...this._extra,
        ...extras
      };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setExtra(key, extra) {
      this._extra = { ...this._extra, [key]: extra };
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setFingerprint(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setLevel(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the transaction name on the scope for future events.
     */
    setTransactionName(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    setContext(key, context) {
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts[key] = context;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Sets the Span on the scope.
     * @param span Span
     * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.
     */
    setSpan(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * Returns the `Span` if there is one.
     * @deprecated Use `getActiveSpan()` instead.
     */
    getSpan() {
      return this._span;
    }
    /**
     * Returns the `Transaction` attached to the scope (if there is one).
     * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
     */
    getTransaction() {
      const span = this._span;
      return span && span.transaction;
    }
    /**
     * @inheritDoc
     */
    setSession(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getSession() {
      return this._session;
    }
    /**
     * @inheritDoc
     */
    update(captureContext) {
      if (!captureContext) {
        return this;
      }
      const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
      if (scopeToMerge instanceof Scope) {
        const scopeData = scopeToMerge.getScopeData();
        this._tags = { ...this._tags, ...scopeData.tags };
        this._extra = { ...this._extra, ...scopeData.extra };
        this._contexts = { ...this._contexts, ...scopeData.contexts };
        if (scopeData.user && Object.keys(scopeData.user).length) {
          this._user = scopeData.user;
        }
        if (scopeData.level) {
          this._level = scopeData.level;
        }
        if (scopeData.fingerprint.length) {
          this._fingerprint = scopeData.fingerprint;
        }
        if (scopeToMerge.getRequestSession()) {
          this._requestSession = scopeToMerge.getRequestSession();
        }
        if (scopeData.propagationContext) {
          this._propagationContext = scopeData.propagationContext;
        }
      } else if (isPlainObject(scopeToMerge)) {
        const scopeContext = captureContext;
        this._tags = { ...this._tags, ...scopeContext.tags };
        this._extra = { ...this._extra, ...scopeContext.extra };
        this._contexts = { ...this._contexts, ...scopeContext.contexts };
        if (scopeContext.user) {
          this._user = scopeContext.user;
        }
        if (scopeContext.level) {
          this._level = scopeContext.level;
        }
        if (scopeContext.fingerprint) {
          this._fingerprint = scopeContext.fingerprint;
        }
        if (scopeContext.requestSession) {
          this._requestSession = scopeContext.requestSession;
        }
        if (scopeContext.propagationContext) {
          this._propagationContext = scopeContext.propagationContext;
        }
      }
      return this;
    }
    /**
     * @inheritDoc
     */
    clear() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._requestSession = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      this._attachments = [];
      this._propagationContext = generatePropagationContext();
      return this;
    }
    /**
     * @inheritDoc
     */
    addBreadcrumb(breadcrumb, maxBreadcrumbs) {
      const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      const mergedBreadcrumb = {
        timestamp: dateTimestampInSeconds(),
        ...breadcrumb
      };
      const breadcrumbs = this._breadcrumbs;
      breadcrumbs.push(mergedBreadcrumb);
      this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    getLastBreadcrumb() {
      return this._breadcrumbs[this._breadcrumbs.length - 1];
    }
    /**
     * @inheritDoc
     */
    clearBreadcrumbs() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    }
    /**
     * @inheritDoc
     */
    addAttachment(attachment) {
      this._attachments.push(attachment);
      return this;
    }
    /**
     * @inheritDoc
     * @deprecated Use `getScopeData()` instead.
     */
    getAttachments() {
      const data = this.getScopeData();
      return data.attachments;
    }
    /**
     * @inheritDoc
     */
    clearAttachments() {
      this._attachments = [];
      return this;
    }
    /** @inheritDoc */
    getScopeData() {
      const {
        _breadcrumbs,
        _attachments,
        _contexts,
        _tags,
        _extra,
        _user,
        _level,
        _fingerprint,
        _eventProcessors,
        _propagationContext,
        _sdkProcessingMetadata,
        _transactionName,
        _span
      } = this;
      return {
        breadcrumbs: _breadcrumbs,
        attachments: _attachments,
        contexts: _contexts,
        tags: _tags,
        extra: _extra,
        user: _user,
        level: _level,
        fingerprint: _fingerprint || [],
        eventProcessors: _eventProcessors,
        propagationContext: _propagationContext,
        sdkProcessingMetadata: _sdkProcessingMetadata,
        transactionName: _transactionName,
        span: _span
      };
    }
    /**
     * Applies data from the scope to the event and runs all event processors on it.
     *
     * @param event Event
     * @param hint Object containing additional information about the original exception, for use by the event processors.
     * @hidden
     * @deprecated Use `applyScopeDataToEvent()` directly
     */
    applyToEvent(event, hint = {}, additionalEventProcessors = []) {
      applyScopeDataToEvent(event, this.getScopeData());
      const eventProcessors = [
        ...additionalEventProcessors,
        // eslint-disable-next-line deprecation/deprecation
        ...getGlobalEventProcessors(),
        ...this._eventProcessors
      ];
      return notifyEventProcessors(eventProcessors, event, hint);
    }
    /**
     * Add data which will be accessible during event processing but won't get sent to Sentry
     */
    setSDKProcessingMetadata(newData) {
      this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
      return this;
    }
    /**
     * @inheritDoc
     */
    setPropagationContext(context) {
      this._propagationContext = context;
      return this;
    }
    /**
     * @inheritDoc
     */
    getPropagationContext() {
      return this._propagationContext;
    }
    /**
     * Capture an exception for this scope.
     *
     * @param exception The exception to capture.
     * @param hint Optinal additional data to attach to the Sentry event.
     * @returns the id of the captured Sentry event.
     */
    captureException(exception, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture exception!");
        return eventId;
      }
      const syntheticException = new Error("Sentry syntheticException");
      this._client.captureException(
        exception,
        {
          originalException: exception,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Capture a message for this scope.
     *
     * @param message The message to capture.
     * @param level An optional severity level to report the message with.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured message.
     */
    captureMessage(message, level, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture message!");
        return eventId;
      }
      const syntheticException = new Error(message);
      this._client.captureMessage(
        message,
        level,
        {
          originalException: message,
          syntheticException,
          ...hint,
          event_id: eventId
        },
        this
      );
      return eventId;
    }
    /**
     * Captures a manually created event for this scope and sends it to Sentry.
     *
     * @param exception The event to capture.
     * @param hint Optional additional data to attach to the Sentry event.
     * @returns the id of the captured event.
     */
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!this._client) {
        logger.warn("No client configured on scope - will not capture event!");
        return eventId;
      }
      this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
      return eventId;
    }
    /**
     * This will be called on every set call.
     */
    _notifyScopeListeners() {
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach((callback) => {
          callback(this);
        });
        this._notifyingListeners = false;
      }
    }
  }
  function getGlobalScope() {
    if (!globalScope) {
      globalScope = new Scope();
    }
    return globalScope;
  }
  function generatePropagationContext() {
    return {
      traceId: uuid4(),
      spanId: uuid4().substring(16)
    };
  }
  const SDK_VERSION = "7.119.2";
  const API_VERSION = parseFloat(SDK_VERSION);
  const DEFAULT_BREADCRUMBS = 100;
  class Hub {
    /** Is a {@link Layer}[] containing the client and scope */
    /** Contains the last event id of a captured event.  */
    /**
     * Creates a new instance of the hub, will push one {@link Layer} into the
     * internal stack on creation.
     *
     * @param client bound to the hub.
     * @param scope bound to the hub.
     * @param version number, higher number means higher priority.
     *
     * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.
     *
     * If you are currently using the Hub for multi-client use like so:
     *
     * ```
     * // OLD
     * const hub = new Hub();
     * hub.bindClient(client);
     * makeMain(hub)
     * ```
     *
     * instead initialize the client as follows:
     *
     * ```
     * // NEW
     * Sentry.withIsolationScope(() => {
     *    Sentry.setCurrentClient(client);
     *    client.init();
     * });
     * ```
     *
     * If you are using the Hub to capture events like so:
     *
     * ```
     * // OLD
     * const client = new Client();
     * const hub = new Hub(client);
     * hub.captureException()
     * ```
     *
     * instead capture isolated events as follows:
     *
     * ```
     * // NEW
     * const client = new Client();
     * const scope = new Scope();
     * scope.setClient(client);
     * scope.captureException();
     * ```
     */
    constructor(client, scope, isolationScope, _version = API_VERSION) {
      this._version = _version;
      let assignedScope;
      if (!scope) {
        assignedScope = new Scope();
        assignedScope.setClient(client);
      } else {
        assignedScope = scope;
      }
      let assignedIsolationScope;
      if (!isolationScope) {
        assignedIsolationScope = new Scope();
        assignedIsolationScope.setClient(client);
      } else {
        assignedIsolationScope = isolationScope;
      }
      this._stack = [{ scope: assignedScope }];
      if (client) {
        this.bindClient(client);
      }
      this._isolationScope = assignedIsolationScope;
    }
    /**
     * Checks if this hub's version is older than the given version.
     *
     * @param version A version number to compare to.
     * @return True if the given version is newer; otherwise false.
     *
     * @deprecated This will be removed in v8.
     */
    isOlderThan(version) {
      return this._version < version;
    }
    /**
     * This binds the given client to the current scope.
     * @param client An SDK client (client) instance.
     *
     * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.
     */
    bindClient(client) {
      const top = this.getStackTop();
      top.client = client;
      top.scope.setClient(client);
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `withScope` instead.
     */
    pushScope() {
      const scope = this.getScope().clone();
      this.getStack().push({
        // eslint-disable-next-line deprecation/deprecation
        client: this.getClient(),
        scope
      });
      return scope;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `withScope` instead.
     */
    popScope() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.withScope()` instead.
     */
    withScope(callback) {
      const scope = this.pushScope();
      let maybePromiseResult;
      try {
        maybePromiseResult = callback(scope);
      } catch (e) {
        this.popScope();
        throw e;
      }
      if (isThenable(maybePromiseResult)) {
        return maybePromiseResult.then(
          (res) => {
            this.popScope();
            return res;
          },
          (e) => {
            this.popScope();
            throw e;
          }
        );
      }
      this.popScope();
      return maybePromiseResult;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.getClient()` instead.
     */
    getClient() {
      return this.getStackTop().client;
    }
    /**
     * Returns the scope of the top stack.
     *
     * @deprecated Use `Sentry.getCurrentScope()` instead.
     */
    getScope() {
      return this.getStackTop().scope;
    }
    /**
     * @deprecated Use `Sentry.getIsolationScope()` instead.
     */
    getIsolationScope() {
      return this._isolationScope;
    }
    /**
     * Returns the scope stack for domains or the process.
     * @deprecated This will be removed in v8.
     */
    getStack() {
      return this._stack;
    }
    /**
     * Returns the topmost scope layer in the order domain > local > process.
     * @deprecated This will be removed in v8.
     */
    getStackTop() {
      return this._stack[this._stack.length - 1];
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.captureException()` instead.
     */
    captureException(exception, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      const syntheticException = new Error("Sentry syntheticException");
      this.getScope().captureException(exception, {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use  `Sentry.captureMessage()` instead.
     */
    captureMessage(message, level, hint) {
      const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      const syntheticException = new Error(message);
      this.getScope().captureMessage(message, level, {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.captureEvent()` instead.
     */
    captureEvent(event, hint) {
      const eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (!event.type) {
        this._lastEventId = eventId;
      }
      this.getScope().captureEvent(event, { ...hint, event_id: eventId });
      return eventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated This will be removed in v8.
     */
    lastEventId() {
      return this._lastEventId;
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `Sentry.addBreadcrumb()` instead.
     */
    addBreadcrumb(breadcrumb, hint) {
      const { scope, client } = this.getStackTop();
      if (!client)
        return;
      const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};
      if (maxBreadcrumbs <= 0)
        return;
      const timestamp = dateTimestampInSeconds();
      const mergedBreadcrumb = { timestamp, ...breadcrumb };
      const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      if (client.emit) {
        client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
      }
      scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setUser()` instead.
     */
    setUser(user) {
      this.getScope().setUser(user);
      this.getIsolationScope().setUser(user);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setTags()` instead.
     */
    setTags(tags) {
      this.getScope().setTags(tags);
      this.getIsolationScope().setTags(tags);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setExtras()` instead.
     */
    setExtras(extras) {
      this.getScope().setExtras(extras);
      this.getIsolationScope().setExtras(extras);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setTag()` instead.
     */
    setTag(key, value) {
      this.getScope().setTag(key, value);
      this.getIsolationScope().setTag(key, value);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setExtra()` instead.
     */
    setExtra(key, extra) {
      this.getScope().setExtra(key, extra);
      this.getIsolationScope().setExtra(key, extra);
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.setContext()` instead.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setContext(name, context) {
      this.getScope().setContext(name, context);
      this.getIsolationScope().setContext(name, context);
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use `getScope()` directly.
     */
    configureScope(callback) {
      const { scope, client } = this.getStackTop();
      if (client) {
        callback(scope);
      }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line deprecation/deprecation
    run(callback) {
      const oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    }
    /**
     * @inheritDoc
     * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.
     */
    getIntegration(integration) {
      const client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        DEBUG_BUILD$1 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
        return null;
      }
    }
    /**
     * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
     *
     * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
     * new child span within the transaction or any span, call the respective `.startChild()` method.
     *
     * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
     *
     * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its
     * finished child spans will be sent to Sentry.
     *
     * @param context Properties of the new `Transaction`.
     * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
     * default values). See {@link Options.tracesSampler}.
     *
     * @returns The transaction which was just started
     *
     * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
     */
    startTransaction(context, customSamplingContext) {
      const result2 = this._callExtensionMethod("startTransaction", context, customSamplingContext);
      if (DEBUG_BUILD$1 && !result2) {
        const client = this.getClient();
        if (!client) {
          logger.warn(
            "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
          );
        } else {
          logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`);
        }
      }
      return result2;
    }
    /**
     * @inheritDoc
     * @deprecated Use `spanToTraceHeader()` instead.
     */
    traceHeaders() {
      return this._callExtensionMethod("traceHeaders");
    }
    /**
     * @inheritDoc
     *
     * @deprecated Use top level `captureSession` instead.
     */
    captureSession(endSession2 = false) {
      if (endSession2) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    }
    /**
     * @inheritDoc
     * @deprecated Use top level `endSession` instead.
     */
    endSession() {
      const layer = this.getStackTop();
      const scope = layer.scope;
      const session = scope.getSession();
      if (session) {
        closeSession(session);
      }
      this._sendSessionUpdate();
      scope.setSession();
    }
    /**
     * @inheritDoc
     * @deprecated Use top level `startSession` instead.
     */
    startSession(context) {
      const { scope, client } = this.getStackTop();
      const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
      const { userAgent } = GLOBAL_OBJ.navigator || {};
      const session = makeSession({
        release,
        environment,
        user: scope.getUser(),
        ...userAgent && { userAgent },
        ...context
      });
      const currentSession = scope.getSession && scope.getSession();
      if (currentSession && currentSession.status === "ok") {
        updateSession(currentSession, { status: "exited" });
      }
      this.endSession();
      scope.setSession(session);
      return session;
    }
    /**
     * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
     * when Tracing is used.
     *
     * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function
     * only unnecessarily increased API surface but only wrapped accessing the option.
     */
    shouldSendDefaultPii() {
      const client = this.getClient();
      const options = client && client.getOptions();
      return Boolean(options && options.sendDefaultPii);
    }
    /**
     * Sends the current Session on the scope
     */
    _sendSessionUpdate() {
      const { scope, client } = this.getStackTop();
      const session = scope.getSession();
      if (session && client && client.captureSession) {
        client.captureSession(session);
      }
    }
    /**
     * Calls global extension method and binding current instance to the function call
     */
    // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _callExtensionMethod(method, ...args) {
      const carrier = getMainCarrier();
      const sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      DEBUG_BUILD$1 && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
    }
  }
  function getMainCarrier() {
    GLOBAL_OBJ.__SENTRY__ = GLOBAL_OBJ.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return GLOBAL_OBJ;
  }
  function makeMain(hub) {
    const registry = getMainCarrier();
    const oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
  }
  function getCurrentHub() {
    const registry = getMainCarrier();
    if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
      const hub = registry.__SENTRY__.acs.getCurrentHub();
      if (hub) {
        return hub;
      }
    }
    return getGlobalHub(registry);
  }
  function getIsolationScope() {
    return getCurrentHub().getIsolationScope();
  }
  function getGlobalHub(registry = getMainCarrier()) {
    if (!hasHubOnCarrier(registry) || // eslint-disable-next-line deprecation/deprecation
    getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
      setHubOnCarrier(registry, new Hub());
    }
    return getHubFromCarrier(registry);
  }
  function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier(carrier) {
    return getGlobalSingleton("hub", () => new Hub(), carrier);
  }
  function setHubOnCarrier(carrier, hub) {
    if (!carrier)
      return false;
    const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  }
  function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
      return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
    event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
    return event;
  }
  function createSessionEnvelope(session, dsn, metadata, tunnel) {
    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
    const envelopeHeaders = {
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...sdkInfo && { sdk: sdkInfo },
      ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
    };
    const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
    return createEnvelope(envelopeHeaders, [envelopeItem]);
  }
  function createEventEnvelope(event, dsn, metadata, tunnel) {
    const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
    const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
    enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
    const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
    delete event.sdkProcessingMetadata;
    const eventItem = [{ type: eventType }, event];
    return createEnvelope(envelopeHeaders, [eventItem]);
  }
  const SENTRY_API_VERSION = "7";
  function getBaseApiEndpoint(dsn) {
    const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
    const port = dsn.port ? `:${dsn.port}` : "";
    return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
  }
  function _getIngestEndpoint(dsn) {
    return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
  }
  function _encodedAuth(dsn, sdkInfo) {
    return urlEncode({
      // We send only the minimum set of required information. See
      // https://github.com/getsentry/sentry-javascript/issues/2572.
      sentry_key: dsn.publicKey,
      sentry_version: SENTRY_API_VERSION,
      ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
    });
  }
  function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnelOrOptions = {}) {
    const tunnel = typeof tunnelOrOptions === "string" ? tunnelOrOptions : tunnelOrOptions.tunnel;
    const sdkInfo = typeof tunnelOrOptions === "string" || !tunnelOrOptions._metadata ? void 0 : tunnelOrOptions._metadata.sdk;
    return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
  }
  const installedIntegrations = [];
  function filterDuplicates(integrations) {
    const integrationsByName = {};
    integrations.forEach((currentInstance) => {
      const { name } = currentInstance;
      const existingInstance = integrationsByName[name];
      if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
        return;
      }
      integrationsByName[name] = currentInstance;
    });
    return Object.keys(integrationsByName).map((k) => integrationsByName[k]);
  }
  function getIntegrationsToSetup(options) {
    const defaultIntegrations2 = options.defaultIntegrations || [];
    const userIntegrations = options.integrations;
    defaultIntegrations2.forEach((integration) => {
      integration.isDefaultInstance = true;
    });
    let integrations;
    if (Array.isArray(userIntegrations)) {
      integrations = [...defaultIntegrations2, ...userIntegrations];
    } else if (typeof userIntegrations === "function") {
      integrations = arrayify(userIntegrations(defaultIntegrations2));
    } else {
      integrations = defaultIntegrations2;
    }
    const finalIntegrations = filterDuplicates(integrations);
    const debugIndex = findIndex(finalIntegrations, (integration) => integration.name === "Debug");
    if (debugIndex !== -1) {
      const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
      finalIntegrations.push(debugInstance);
    }
    return finalIntegrations;
  }
  function setupIntegrations(client, integrations) {
    const integrationIndex = {};
    integrations.forEach((integration) => {
      if (integration) {
        setupIntegration(client, integration, integrationIndex);
      }
    });
    return integrationIndex;
  }
  function afterSetupIntegrations(client, integrations) {
    for (const integration of integrations) {
      if (integration && integration.afterAllSetup) {
        integration.afterAllSetup(client);
      }
    }
  }
  function setupIntegration(client, integration, integrationIndex) {
    if (integrationIndex[integration.name]) {
      DEBUG_BUILD$1 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
      return;
    }
    integrationIndex[integration.name] = integration;
    if (installedIntegrations.indexOf(integration.name) === -1) {
      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
      installedIntegrations.push(integration.name);
    }
    if (integration.setup && typeof integration.setup === "function") {
      integration.setup(client);
    }
    if (client.on && typeof integration.preprocessEvent === "function") {
      const callback = integration.preprocessEvent.bind(integration);
      client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
    }
    if (client.addEventProcessor && typeof integration.processEvent === "function") {
      const callback = integration.processEvent.bind(integration);
      const processor = Object.assign((event, hint) => callback(event, hint, client), {
        id: integration.name
      });
      client.addEventProcessor(processor);
    }
    DEBUG_BUILD$1 && logger.log(`Integration installed: ${integration.name}`);
  }
  function findIndex(arr, callback) {
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (callback(arr[i2]) === true) {
        return i2;
      }
    }
    return -1;
  }
  function convertIntegrationFnToClass(name, fn) {
    return Object.assign(
      function ConvertedIntegration(...args) {
        return fn(...args);
      },
      { id: name }
    );
  }
  function defineIntegration(fn) {
    return fn;
  }
  function serializeMetricBuckets(metricBucketItems) {
    let out = "";
    for (const item of metricBucketItems) {
      const tagEntries = Object.entries(item.tags);
      const maybeTags = tagEntries.length > 0 ? `|#${tagEntries.map(([key, value]) => `${key}:${value}`).join(",")}` : "";
      out += `${item.name}@${item.unit}:${item.metric}|${item.metricType}${maybeTags}|T${item.timestamp}
`;
    }
    return out;
  }
  function createMetricEnvelope(metricBucketItems, dsn, metadata, tunnel) {
    const headers = {
      sent_at: (/* @__PURE__ */ new Date()).toISOString()
    };
    if (metadata && metadata.sdk) {
      headers.sdk = {
        name: metadata.sdk.name,
        version: metadata.sdk.version
      };
    }
    if (!!tunnel && dsn) {
      headers.dsn = dsnToString(dsn);
    }
    const item = createMetricEnvelopeItem(metricBucketItems);
    return createEnvelope(headers, [item]);
  }
  function createMetricEnvelopeItem(metricBucketItems) {
    const payload = serializeMetricBuckets(metricBucketItems);
    const metricHeaders = {
      type: "statsd",
      length: payload.length
    };
    return [metricHeaders, payload];
  }
  const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
  class BaseClient {
    /**
     * A reference to a metrics aggregator
     *
     * @experimental Note this is alpha API. It may experience breaking changes in the future.
     */
    /** Options passed to the SDK. */
    /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
    /** Array of set up integrations. */
    /** Indicates whether this client's integrations have been set up. */
    /** Number of calls being processed */
    /** Holds flushable  */
    // eslint-disable-next-line @typescript-eslint/ban-types
    /**
     * Initializes this client instance.
     *
     * @param options Options for the client.
     */
    constructor(options) {
      this._options = options;
      this._integrations = {};
      this._integrationsInitialized = false;
      this._numProcessing = 0;
      this._outcomes = {};
      this._hooks = {};
      this._eventProcessors = [];
      if (options.dsn) {
        this._dsn = makeDsn(options.dsn);
      } else {
        DEBUG_BUILD$1 && logger.warn("No DSN provided, client will not send events.");
      }
      if (this._dsn) {
        const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
        this._transport = options.transport({
          tunnel: this._options.tunnel,
          recordDroppedEvent: this.recordDroppedEvent.bind(this),
          ...options.transportOptions,
          url
        });
      }
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    captureException(exception, hint, scope) {
      if (checkOrSetAlreadyCaught(exception)) {
        DEBUG_BUILD$1 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      this._process(
        this.eventFromException(exception, hint).then((event) => this._captureEvent(event, hint, scope)).then((result2) => {
          eventId = result2;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureMessage(message, level, hint, scope) {
      let eventId = hint && hint.event_id;
      const eventMessage = isParameterizedString(message) ? message : String(message);
      const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);
      this._process(
        promisedEvent.then((event) => this._captureEvent(event, hint, scope)).then((result2) => {
          eventId = result2;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureEvent(event, hint, scope) {
      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
        DEBUG_BUILD$1 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      let eventId = hint && hint.event_id;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
      this._process(
        this._captureEvent(event, hint, capturedSpanScope || scope).then((result2) => {
          eventId = result2;
        })
      );
      return eventId;
    }
    /**
     * @inheritDoc
     */
    captureSession(session) {
      if (!(typeof session.release === "string")) {
        DEBUG_BUILD$1 && logger.warn("Discarded session because of missing or non-string release");
      } else {
        this.sendSession(session);
        updateSession(session, { init: false });
      }
    }
    /**
     * @inheritDoc
     */
    getDsn() {
      return this._dsn;
    }
    /**
     * @inheritDoc
     */
    getOptions() {
      return this._options;
    }
    /**
     * @see SdkMetadata in @sentry/types
     *
     * @return The metadata of the SDK
     */
    getSdkMetadata() {
      return this._options._metadata;
    }
    /**
     * @inheritDoc
     */
    getTransport() {
      return this._transport;
    }
    /**
     * @inheritDoc
     */
    flush(timeout) {
      const transport = this._transport;
      if (transport) {
        if (this.metricsAggregator) {
          this.metricsAggregator.flush();
        }
        return this._isClientDoneProcessing(timeout).then((clientFinished) => {
          return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
        });
      } else {
        return resolvedSyncPromise(true);
      }
    }
    /**
     * @inheritDoc
     */
    close(timeout) {
      return this.flush(timeout).then((result2) => {
        this.getOptions().enabled = false;
        if (this.metricsAggregator) {
          this.metricsAggregator.close();
        }
        return result2;
      });
    }
    /** Get all installed event processors. */
    getEventProcessors() {
      return this._eventProcessors;
    }
    /** @inheritDoc */
    addEventProcessor(eventProcessor) {
      this._eventProcessors.push(eventProcessor);
    }
    /**
     * This is an internal function to setup all integrations that should run on the client.
     * @deprecated Use `client.init()` instead.
     */
    setupIntegrations(forceInitialize) {
      if (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) {
        this._setupIntegrations();
      }
    }
    /** @inheritdoc */
    init() {
      if (this._isEnabled()) {
        this._setupIntegrations();
      }
    }
    /**
     * Gets an installed integration by its `id`.
     *
     * @returns The installed integration or `undefined` if no integration with that `id` was installed.
     * @deprecated Use `getIntegrationByName()` instead.
     */
    getIntegrationById(integrationId) {
      return this.getIntegrationByName(integrationId);
    }
    /**
     * Gets an installed integration by its name.
     *
     * @returns The installed integration or `undefined` if no integration with that `name` was installed.
     */
    getIntegrationByName(integrationName) {
      return this._integrations[integrationName];
    }
    /**
     * Returns the client's instance of the given integration class, it any.
     * @deprecated Use `getIntegrationByName()` instead.
     */
    getIntegration(integration) {
      try {
        return this._integrations[integration.id] || null;
      } catch (_oO) {
        DEBUG_BUILD$1 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);
        return null;
      }
    }
    /**
     * @inheritDoc
     */
    addIntegration(integration) {
      const isAlreadyInstalled = this._integrations[integration.name];
      setupIntegration(this, integration, this._integrations);
      if (!isAlreadyInstalled) {
        afterSetupIntegrations(this, [integration]);
      }
    }
    /**
     * @inheritDoc
     */
    sendEvent(event, hint = {}) {
      this.emit("beforeSendEvent", event, hint);
      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
      for (const attachment of hint.attachments || []) {
        env = addItemToEnvelope(
          env,
          createAttachmentEnvelopeItem(
            attachment,
            this._options.transportOptions && this._options.transportOptions.textEncoder
          )
        );
      }
      const promise = this._sendEnvelope(env);
      if (promise) {
        promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
      }
    }
    /**
     * @inheritDoc
     */
    sendSession(session) {
      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(env);
    }
    /**
     * @inheritDoc
     */
    recordDroppedEvent(reason, category, eventOrCount) {
      if (this._options.sendClientReports) {
        const count = typeof eventOrCount === "number" ? eventOrCount : 1;
        const key = `${reason}:${category}`;
        DEBUG_BUILD$1 && logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
        this._outcomes[key] = (this._outcomes[key] || 0) + count;
      }
    }
    /**
     * @inheritDoc
     */
    captureAggregateMetrics(metricBucketItems) {
      DEBUG_BUILD$1 && logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);
      const metricsEnvelope = createMetricEnvelope(
        metricBucketItems,
        this._dsn,
        this._options._metadata,
        this._options.tunnel
      );
      this._sendEnvelope(metricsEnvelope);
    }
    // Keep on() & emit() signatures in sync with types' client.ts interface
    /* eslint-disable @typescript-eslint/unified-signatures */
    /** @inheritdoc */
    /** @inheritdoc */
    on(hook, callback) {
      if (!this._hooks[hook]) {
        this._hooks[hook] = [];
      }
      this._hooks[hook].push(callback);
    }
    /** @inheritdoc */
    /** @inheritdoc */
    emit(hook, ...rest) {
      if (this._hooks[hook]) {
        this._hooks[hook].forEach((callback) => callback(...rest));
      }
    }
    /* eslint-enable @typescript-eslint/unified-signatures */
    /** Setup integrations for this client. */
    _setupIntegrations() {
      const { integrations } = this._options;
      this._integrations = setupIntegrations(this, integrations);
      afterSetupIntegrations(this, integrations);
      this._integrationsInitialized = true;
    }
    /** Updates existing session based on the provided event */
    _updateSessionFromEvent(session, event) {
      let crashed = false;
      let errored = false;
      const exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        for (const ex of exceptions) {
          const mechanism = ex.mechanism;
          if (mechanism && mechanism.handled === false) {
            crashed = true;
            break;
          }
        }
      }
      const sessionNonTerminal = session.status === "ok";
      const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
      if (shouldUpdateAndSend) {
        updateSession(session, {
          ...crashed && { status: "crashed" },
          errors: session.errors || Number(errored || crashed)
        });
        this.captureSession(session);
      }
    }
    /**
     * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
     * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
     *
     * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
     * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
     * `true`.
     * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
     * `false` otherwise
     */
    _isClientDoneProcessing(timeout) {
      return new SyncPromise((resolve) => {
        let ticked = 0;
        const tick = 1;
        const interval = setInterval(() => {
          if (this._numProcessing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    }
    /** Determines whether this SDK is enabled and a transport is present. */
    _isEnabled() {
      return this.getOptions().enabled !== false && this._transport !== void 0;
    }
    /**
     * Adds common information to events.
     *
     * The information includes release and environment from `options`,
     * breadcrumbs and context (extra, tags and user) from the scope.
     *
     * Information that is already present in the event is never overwritten. For
     * nested objects, such as the context, keys are merged.
     *
     * @param event The original event.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A new event with more information.
     */
    _prepareEvent(event, hint, scope, isolationScope = getIsolationScope()) {
      const options = this.getOptions();
      const integrations = Object.keys(this._integrations);
      if (!hint.integrations && integrations.length > 0) {
        hint.integrations = integrations;
      }
      this.emit("preprocessEvent", event, hint);
      return prepareEvent(options, event, hint, scope, this, isolationScope).then((evt) => {
        if (evt === null) {
          return evt;
        }
        const propagationContext = {
          ...isolationScope.getPropagationContext(),
          ...scope ? scope.getPropagationContext() : void 0
        };
        const trace = evt.contexts && evt.contexts.trace;
        if (!trace && propagationContext) {
          const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
          evt.contexts = {
            trace: {
              trace_id,
              span_id: spanId,
              parent_span_id: parentSpanId
            },
            ...evt.contexts
          };
          const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this, scope);
          evt.sdkProcessingMetadata = {
            dynamicSamplingContext,
            ...evt.sdkProcessingMetadata
          };
        }
        return evt;
      });
    }
    /**
     * Processes the event and logs an error in case of rejection
     * @param event
     * @param hint
     * @param scope
     */
    _captureEvent(event, hint = {}, scope) {
      return this._processEvent(event, hint, scope).then(
        (finalEvent) => {
          return finalEvent.event_id;
        },
        (reason) => {
          if (DEBUG_BUILD$1) {
            const sentryError = reason;
            if (sentryError.logLevel === "log") {
              logger.log(sentryError.message);
            } else {
              logger.warn(sentryError);
            }
          }
          return void 0;
        }
      );
    }
    /**
     * Processes an event (either error or message) and sends it to Sentry.
     *
     * This also adds breadcrumbs and context information to the event. However,
     * platform specific meta data (such as the User's IP address) must be added
     * by the SDK implementor.
     *
     *
     * @param event The event to send to Sentry.
     * @param hint May contain additional information about the original exception.
     * @param scope A scope containing event metadata.
     * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
     */
    _processEvent(event, hint, scope) {
      const options = this.getOptions();
      const { sampleRate } = options;
      const isTransaction = isTransactionEvent(event);
      const isError2 = isErrorEvent(event);
      const eventType = event.type || "error";
      const beforeSendLabel = `before send for type \`${eventType}\``;
      if (isError2 && typeof sampleRate === "number" && Math.random() > sampleRate) {
        this.recordDroppedEvent("sample_rate", "error", event);
        return rejectedSyncPromise(
          new SentryError(
            `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
            "log"
          )
        );
      }
      const dataCategory = eventType === "replay_event" ? "replay" : eventType;
      const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
      const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
      return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then((prepared) => {
        if (prepared === null) {
          this.recordDroppedEvent("event_processor", dataCategory, event);
          throw new SentryError("An event processor returned `null`, will not send event.", "log");
        }
        const isInternalException = hint.data && hint.data.__sentry__ === true;
        if (isInternalException) {
          return prepared;
        }
        const result2 = processBeforeSend(options, prepared, hint);
        return _validateBeforeSendResult(result2, beforeSendLabel);
      }).then((processedEvent) => {
        if (processedEvent === null) {
          this.recordDroppedEvent("before_send", dataCategory, event);
          if (isTransaction) {
            const spans = event.spans || [];
            const spanCount = 1 + spans.length;
            this.recordDroppedEvent("before_send", "span", spanCount);
          }
          throw new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
        }
        const session = scope && scope.getSession();
        if (!isTransaction && session) {
          this._updateSessionFromEvent(session, processedEvent);
        }
        if (isTransaction) {
          const spanCountBefore = processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing || 0;
          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
          const droppedSpanCount = spanCountBefore - spanCountAfter;
          if (droppedSpanCount > 0) {
            this.recordDroppedEvent("before_send", "span", droppedSpanCount);
          }
        }
        const transactionInfo = processedEvent.transaction_info;
        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
          const source = "custom";
          processedEvent.transaction_info = {
            ...transactionInfo,
            source
          };
        }
        this.sendEvent(processedEvent, hint);
        return processedEvent;
      }).then(null, (reason) => {
        if (reason instanceof SentryError) {
          throw reason;
        }
        this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new SentryError(
          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
        );
      });
    }
    /**
     * Occupies the client with processing and event
     */
    _process(promise) {
      this._numProcessing++;
      void promise.then(
        (value) => {
          this._numProcessing--;
          return value;
        },
        (reason) => {
          this._numProcessing--;
          return reason;
        }
      );
    }
    /**
     * @inheritdoc
     */
    _sendEnvelope(envelope) {
      this.emit("beforeEnvelope", envelope);
      if (this._isEnabled() && this._transport) {
        return this._transport.send(envelope).then(null, (reason) => {
          DEBUG_BUILD$1 && logger.error("Error while sending event:", reason);
        });
      } else {
        DEBUG_BUILD$1 && logger.error("Transport disabled");
      }
    }
    /**
     * Clears outcomes on this client and returns them.
     */
    _clearOutcomes() {
      const outcomes = this._outcomes;
      this._outcomes = {};
      return Object.keys(outcomes).map((key) => {
        const [reason, category] = key.split(":");
        return {
          reason,
          category,
          quantity: outcomes[key]
        };
      });
    }
    /**
     * @inheritDoc
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  }
  function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
    const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
    if (isThenable(beforeSendResult)) {
      return beforeSendResult.then(
        (event) => {
          if (!isPlainObject(event) && event !== null) {
            throw new SentryError(invalidValueError);
          }
          return event;
        },
        (e) => {
          throw new SentryError(`${beforeSendLabel} rejected with ${e}`);
        }
      );
    } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
      throw new SentryError(invalidValueError);
    }
    return beforeSendResult;
  }
  function processBeforeSend(options, event, hint) {
    const { beforeSend, beforeSendTransaction } = options;
    if (isErrorEvent(event) && beforeSend) {
      return beforeSend(event, hint);
    }
    if (isTransactionEvent(event) && beforeSendTransaction) {
      if (event.spans) {
        const spanCountBefore = event.spans.length;
        event.sdkProcessingMetadata = {
          ...event.sdkProcessingMetadata,
          spanCountBeforeProcessing: spanCountBefore
        };
      }
      return beforeSendTransaction(event, hint);
    }
    return event;
  }
  function isErrorEvent(event) {
    return event.type === void 0;
  }
  function isTransactionEvent(event) {
    return event.type === "transaction";
  }
  function initAndBind(clientClass, options) {
    if (options.debug === true) {
      if (DEBUG_BUILD$1) {
        logger.enable();
      } else {
        consoleSandbox(() => {
          console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
        });
      }
    }
    const scope = getCurrentScope();
    scope.update(options.initialScope);
    const client = new clientClass(options);
    setCurrentClient(client);
    initializeClient(client);
  }
  function setCurrentClient(client) {
    const hub = getCurrentHub();
    const top = hub.getStackTop();
    top.client = client;
    top.scope.setClient(client);
  }
  function initializeClient(client) {
    if (client.init) {
      client.init();
    } else if (client.setupIntegrations) {
      client.setupIntegrations();
    }
  }
  const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
  function createTransport(options, makeRequest, buffer = makePromiseBuffer(
    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
  )) {
    let rateLimits = {};
    const flush = (timeout) => buffer.drain(timeout);
    function send(envelope) {
      const filteredEnvelopeItems = [];
      forEachEnvelopeItem(envelope, (item, type) => {
        const dataCategory = envelopeItemTypeToDataCategory(type);
        if (isRateLimited(rateLimits, dataCategory)) {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
        } else {
          filteredEnvelopeItems.push(item);
        }
      });
      if (filteredEnvelopeItems.length === 0) {
        return resolvedSyncPromise();
      }
      const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
      const recordEnvelopeLoss = (reason) => {
        forEachEnvelopeItem(filteredEnvelope, (item, type) => {
          const event = getEventForEnvelopeItem(item, type);
          options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
        });
      };
      const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
        (response) => {
          if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
            DEBUG_BUILD$1 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
          }
          rateLimits = updateRateLimits(rateLimits, response);
          return response;
        },
        (error2) => {
          recordEnvelopeLoss("network_error");
          throw error2;
        }
      );
      return buffer.add(requestTask).then(
        (result2) => result2,
        (error2) => {
          if (error2 instanceof SentryError) {
            DEBUG_BUILD$1 && logger.error("Skipped sending event because buffer is full.");
            recordEnvelopeLoss("queue_overflow");
            return resolvedSyncPromise();
          } else {
            throw error2;
          }
        }
      );
    }
    send.__sentry__baseTransport__ = true;
    return {
      send,
      flush
    };
  }
  function getEventForEnvelopeItem(item, type) {
    if (type !== "event" && type !== "transaction") {
      return void 0;
    }
    return Array.isArray(item) ? item[1] : void 0;
  }
  function applySdkMetadata(options, name, names = [name], source = "npm") {
    const metadata = options._metadata || {};
    if (!metadata.sdk) {
      metadata.sdk = {
        name: `sentry.javascript.${name}`,
        packages: names.map((name2) => ({
          name: `${source}:@sentry/${name2}`,
          version: SDK_VERSION
        })),
        version: SDK_VERSION
      };
    }
    options._metadata = metadata;
  }
  const DEFAULT_IGNORE_ERRORS = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/
  ];
  const DEFAULT_IGNORE_TRANSACTIONS = [
    /^.*\/healthcheck$/,
    /^.*\/healthy$/,
    /^.*\/live$/,
    /^.*\/ready$/,
    /^.*\/heartbeat$/,
    /^.*\/health$/,
    /^.*\/healthz$/
  ];
  const INTEGRATION_NAME$7 = "InboundFilters";
  const _inboundFiltersIntegration = (options = {}) => {
    return {
      name: INTEGRATION_NAME$7,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      processEvent(event, _hint, client) {
        const clientOptions = client.getOptions();
        const mergedOptions = _mergeOptions(options, clientOptions);
        return _shouldDropEvent$1(event, mergedOptions) ? null : event;
      }
    };
  };
  const inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME$7,
    inboundFiltersIntegration
  );
  function _mergeOptions(internalOptions = {}, clientOptions = {}) {
    return {
      allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
      denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
      ignoreErrors: [
        ...internalOptions.ignoreErrors || [],
        ...clientOptions.ignoreErrors || [],
        ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
      ],
      ignoreTransactions: [
        ...internalOptions.ignoreTransactions || [],
        ...clientOptions.ignoreTransactions || [],
        ...internalOptions.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS
      ],
      ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
    };
  }
  function _shouldDropEvent$1(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
      DEBUG_BUILD$1 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(event)}`);
      return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
      );
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      DEBUG_BUILD$1 && logger.warn(
        `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
          event
        )}.
Url: ${_getEventFilterUrl(event)}`
      );
      return true;
    }
    return false;
  }
  function _isIgnoredError(event, ignoreErrors) {
    if (event.type || !ignoreErrors || !ignoreErrors.length) {
      return false;
    }
    return _getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
  }
  function _isIgnoredTransaction(event, ignoreTransactions) {
    if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
      return false;
    }
    const name = event.transaction;
    return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
  }
  function _isDeniedUrl(event, denyUrls) {
    if (!denyUrls || !denyUrls.length) {
      return false;
    }
    const url = _getEventFilterUrl(event);
    return !url ? false : stringMatchesSomePattern(url, denyUrls);
  }
  function _isAllowedUrl(event, allowUrls) {
    if (!allowUrls || !allowUrls.length) {
      return true;
    }
    const url = _getEventFilterUrl(event);
    return !url ? true : stringMatchesSomePattern(url, allowUrls);
  }
  function _getPossibleEventMessages(event) {
    const possibleMessages = [];
    if (event.message) {
      possibleMessages.push(event.message);
    }
    let lastException;
    try {
      lastException = event.exception.values[event.exception.values.length - 1];
    } catch (e) {
    }
    if (lastException) {
      if (lastException.value) {
        possibleMessages.push(lastException.value);
        if (lastException.type) {
          possibleMessages.push(`${lastException.type}: ${lastException.value}`);
        }
      }
    }
    if (DEBUG_BUILD$1 && possibleMessages.length === 0) {
      logger.error(`Could not extract message for event ${getEventDescription(event)}`);
    }
    return possibleMessages;
  }
  function _isSentryError(event) {
    try {
      return event.exception.values[0].type === "SentryError";
    } catch (e) {
    }
    return false;
  }
  function _getLastValidUrl(frames = []) {
    for (let i2 = frames.length - 1; i2 >= 0; i2--) {
      const frame = frames[i2];
      if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
        return frame.filename || null;
      }
    }
    return null;
  }
  function _getEventFilterUrl(event) {
    try {
      let frames;
      try {
        frames = event.exception.values[0].stacktrace.frames;
      } catch (e) {
      }
      return frames ? _getLastValidUrl(frames) : null;
    } catch (oO) {
      DEBUG_BUILD$1 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
      return null;
    }
  }
  let originalFunctionToString;
  const INTEGRATION_NAME$6 = "FunctionToString";
  const SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
  const _functionToStringIntegration = () => {
    return {
      name: INTEGRATION_NAME$6,
      setupOnce() {
        originalFunctionToString = Function.prototype.toString;
        try {
          Function.prototype.toString = function(...args) {
            const originalFunction = getOriginalFunction(this);
            const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
            return originalFunctionToString.apply(context, args);
          };
        } catch (e) {
        }
      },
      setup(client) {
        SETUP_CLIENTS.set(client, true);
      }
    };
  };
  const functionToStringIntegration = defineIntegration(_functionToStringIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME$6,
    functionToStringIntegration
  );
  const WINDOW = GLOBAL_OBJ;
  let ignoreOnError = 0;
  function shouldIgnoreOnError() {
    return ignoreOnError > 0;
  }
  function ignoreNextOnError() {
    ignoreOnError++;
    setTimeout(() => {
      ignoreOnError--;
    });
  }
  function wrap(fn, options = {}, before) {
    if (typeof fn !== "function") {
      return fn;
    }
    try {
      const wrapper = fn.__sentry_wrapped__;
      if (wrapper) {
        if (typeof wrapper === "function") {
          return wrapper;
        } else {
          return fn;
        }
      }
      if (getOriginalFunction(fn)) {
        return fn;
      }
    } catch (e) {
      return fn;
    }
    const sentryWrapped = function() {
      const args = Array.prototype.slice.call(arguments);
      try {
        if (before && typeof before === "function") {
          before.apply(this, arguments);
        }
        const wrappedArguments = args.map((arg) => wrap(arg, options));
        return fn.apply(this, wrappedArguments);
      } catch (ex) {
        ignoreNextOnError();
        withScope((scope) => {
          scope.addEventProcessor((event) => {
            if (options.mechanism) {
              addExceptionTypeValue(event, void 0, void 0);
              addExceptionMechanism(event, options.mechanism);
            }
            event.extra = {
              ...event.extra,
              arguments: args
            };
            return event;
          });
          captureException(ex);
        });
        throw ex;
      }
    };
    try {
      for (const property in fn) {
        if (Object.prototype.hasOwnProperty.call(fn, property)) {
          sentryWrapped[property] = fn[property];
        }
      }
    } catch (_oO) {
    }
    markFunctionWrapped(sentryWrapped, fn);
    addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
    try {
      const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
      if (descriptor.configurable) {
        Object.defineProperty(sentryWrapped, "name", {
          get() {
            return fn.name;
          }
        });
      }
    } catch (_oO) {
    }
    return sentryWrapped;
  }
  const DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
  function exceptionFromError(stackParser, ex) {
    const frames = parseStackFrames(stackParser, ex);
    const exception = {
      type: ex && ex.name,
      value: extractMessage(ex)
    };
    if (frames.length) {
      exception.stacktrace = { frames };
    }
    if (exception.type === void 0 && exception.value === "") {
      exception.value = "Unrecoverable error caught";
    }
    return exception;
  }
  function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
    const client = getClient();
    const normalizeDepth = client && client.getOptions().normalizeDepth;
    const event = {
      exception: {
        values: [
          {
            type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
            value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })
          }
        ]
      },
      extra: {
        __serialized__: normalizeToSize(exception, normalizeDepth)
      }
    };
    if (syntheticException) {
      const frames = parseStackFrames(stackParser, syntheticException);
      if (frames.length) {
        event.exception.values[0].stacktrace = { frames };
      }
    }
    return event;
  }
  function eventFromError(stackParser, ex) {
    return {
      exception: {
        values: [exceptionFromError(stackParser, ex)]
      }
    };
  }
  function parseStackFrames(stackParser, ex) {
    const stacktrace = ex.stacktrace || ex.stack || "";
    const popSize = getPopSize(ex);
    try {
      return stackParser(stacktrace, popSize);
    } catch (e) {
    }
    return [];
  }
  const reactMinifiedRegexp = /Minified React error #\d+;/i;
  function getPopSize(ex) {
    if (ex) {
      if (typeof ex.framesToPop === "number") {
        return ex.framesToPop;
      }
      if (reactMinifiedRegexp.test(ex.message)) {
        return 1;
      }
    }
    return 0;
  }
  function extractMessage(ex) {
    const message = ex && ex.message;
    if (!message) {
      return "No error message";
    }
    if (message.error && typeof message.error.message === "string") {
      return message.error.message;
    }
    return message;
  }
  function eventFromException(stackParser, exception, hint, attachStacktrace) {
    const syntheticException = hint && hint.syntheticException || void 0;
    const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
    addExceptionMechanism(event);
    event.level = "error";
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
    const syntheticException = hint && hint.syntheticException || void 0;
    const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
    event.level = level;
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
    let event;
    if (isErrorEvent$1(exception) && exception.error) {
      const errorEvent = exception;
      return eventFromError(stackParser, errorEvent.error);
    }
    if (isDOMError(exception) || isDOMException(exception)) {
      const domException = exception;
      if ("stack" in exception) {
        event = eventFromError(stackParser, exception);
      } else {
        const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
        const message = domException.message ? `${name}: ${domException.message}` : name;
        event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
        addExceptionTypeValue(event, message);
      }
      if ("code" in domException) {
        event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
      }
      return event;
    }
    if (isError$1(exception)) {
      return eventFromError(stackParser, exception);
    }
    if (isPlainObject(exception) || isEvent(exception)) {
      const objectException = exception;
      event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
      addExceptionMechanism(event, {
        synthetic: true
      });
      return event;
    }
    event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
    addExceptionTypeValue(event, `${exception}`, void 0);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  function eventFromString(stackParser, message, syntheticException, attachStacktrace) {
    const event = {};
    if (attachStacktrace && syntheticException) {
      const frames = parseStackFrames(stackParser, syntheticException);
      if (frames.length) {
        event.exception = {
          values: [{ value: message, stacktrace: { frames } }]
        };
      }
    }
    if (isParameterizedString(message)) {
      const { __sentry_template_string__, __sentry_template_values__ } = message;
      event.logentry = {
        message: __sentry_template_string__,
        params: __sentry_template_values__
      };
      return event;
    }
    event.message = message;
    return event;
  }
  function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {
    const keys2 = extractExceptionKeysForMessage(exception);
    const captureType = isUnhandledRejection ? "promise rejection" : "exception";
    if (isErrorEvent$1(exception)) {
      return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
    }
    if (isEvent(exception)) {
      const className = getObjectClassName(exception);
      return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
    }
    return `Object captured as ${captureType} with keys: ${keys2}`;
  }
  function getObjectClassName(obj) {
    try {
      const prototype = Object.getPrototypeOf(obj);
      return prototype ? prototype.constructor.name : void 0;
    } catch (e) {
    }
  }
  function createUserFeedbackEnvelope(feedback, {
    metadata,
    tunnel,
    dsn
  }) {
    const headers = {
      event_id: feedback.event_id,
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      ...metadata && metadata.sdk && {
        sdk: {
          name: metadata.sdk.name,
          version: metadata.sdk.version
        }
      },
      ...!!tunnel && !!dsn && { dsn: dsnToString(dsn) }
    };
    const item = createUserFeedbackEnvelopeItem(feedback);
    return createEnvelope(headers, [item]);
  }
  function createUserFeedbackEnvelopeItem(feedback) {
    const feedbackHeaders = {
      type: "user_report"
    };
    return [feedbackHeaders, feedback];
  }
  class BrowserClient extends BaseClient {
    /**
     * Creates a new Browser SDK instance.
     *
     * @param options Configuration options for this SDK.
     */
    constructor(options) {
      const sdkSource = WINDOW.SENTRY_SDK_SOURCE || getSDKSource();
      applySdkMetadata(options, "browser", ["browser"], sdkSource);
      super(options);
      if (options.sendClientReports && WINDOW.document) {
        WINDOW.document.addEventListener("visibilitychange", () => {
          if (WINDOW.document.visibilityState === "hidden") {
            this._flushOutcomes();
          }
        });
      }
    }
    /**
     * @inheritDoc
     */
    eventFromException(exception, hint) {
      return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
    }
    /**
     * @inheritDoc
     */
    eventFromMessage(message, level = "info", hint) {
      return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
    }
    /**
     * Sends user feedback to Sentry.
     */
    captureUserFeedback(feedback) {
      if (!this._isEnabled()) {
        DEBUG_BUILD && logger.warn("SDK not enabled, will not capture user feedback.");
        return;
      }
      const envelope = createUserFeedbackEnvelope(feedback, {
        metadata: this.getSdkMetadata(),
        dsn: this.getDsn(),
        tunnel: this.getOptions().tunnel
      });
      this._sendEnvelope(envelope);
    }
    /**
     * @inheritDoc
     */
    _prepareEvent(event, hint, scope) {
      event.platform = event.platform || "javascript";
      return super._prepareEvent(event, hint, scope);
    }
    /**
     * Sends client reports as an envelope.
     */
    _flushOutcomes() {
      const outcomes = this._clearOutcomes();
      if (outcomes.length === 0) {
        DEBUG_BUILD && logger.log("No outcomes to send");
        return;
      }
      if (!this._dsn) {
        DEBUG_BUILD && logger.log("No dsn provided, will not send outcomes");
        return;
      }
      DEBUG_BUILD && logger.log("Sending outcomes:", outcomes);
      const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
      this._sendEnvelope(envelope);
    }
  }
  let cachedFetchImpl = void 0;
  function getNativeFetchImplementation() {
    if (cachedFetchImpl) {
      return cachedFetchImpl;
    }
    if (isNativeFetch(WINDOW.fetch)) {
      return cachedFetchImpl = WINDOW.fetch.bind(WINDOW);
    }
    const document2 = WINDOW.document;
    let fetchImpl = WINDOW.fetch;
    if (document2 && typeof document2.createElement === "function") {
      try {
        const sandbox = document2.createElement("iframe");
        sandbox.hidden = true;
        document2.head.appendChild(sandbox);
        const contentWindow = sandbox.contentWindow;
        if (contentWindow && contentWindow.fetch) {
          fetchImpl = contentWindow.fetch;
        }
        document2.head.removeChild(sandbox);
      } catch (e) {
        DEBUG_BUILD && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e);
      }
    }
    return cachedFetchImpl = fetchImpl.bind(WINDOW);
  }
  function clearCachedFetchImplementation() {
    cachedFetchImpl = void 0;
  }
  function makeFetchTransport(options, nativeFetch = getNativeFetchImplementation()) {
    let pendingBodySize = 0;
    let pendingCount = 0;
    function makeRequest(request) {
      const requestSize = request.body.length;
      pendingBodySize += requestSize;
      pendingCount++;
      const requestOptions = {
        body: request.body,
        method: "POST",
        referrerPolicy: "origin",
        headers: options.headers,
        // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
        // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
        // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
        // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
        // Gotchas:
        // - `keepalive` isn't supported by Firefox
        // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
        //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
        //   We will therefore only activate the flag when we're below that limit.
        // There is also a limit of requests that can be open at the same time, so we also limit this to 15
        // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
        keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
        ...options.fetchOptions
      };
      try {
        return nativeFetch(options.url, requestOptions).then((response) => {
          pendingBodySize -= requestSize;
          pendingCount--;
          return {
            statusCode: response.status,
            headers: {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            }
          };
        });
      } catch (e) {
        clearCachedFetchImplementation();
        pendingBodySize -= requestSize;
        pendingCount--;
        return rejectedSyncPromise(e);
      }
    }
    return createTransport(options, makeRequest);
  }
  const XHR_READYSTATE_DONE = 4;
  function makeXHRTransport(options) {
    function makeRequest(request) {
      return new SyncPromise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.onerror = reject;
        xhr.onreadystatechange = () => {
          if (xhr.readyState === XHR_READYSTATE_DONE) {
            resolve({
              statusCode: xhr.status,
              headers: {
                "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
                "retry-after": xhr.getResponseHeader("Retry-After")
              }
            });
          }
        };
        xhr.open("POST", options.url);
        for (const header in options.headers) {
          if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
            xhr.setRequestHeader(header, options.headers[header]);
          }
        }
        xhr.send(request.body);
      });
    }
    return createTransport(options, makeRequest);
  }
  const UNKNOWN_FUNCTION = "?";
  const CHROME_PRIORITY = 30;
  const WINJS_PRIORITY = 40;
  const GECKO_PRIORITY = 50;
  function createFrame(filename, func, lineno, colno) {
    const frame = {
      filename,
      function: func,
      in_app: true
      // All browser frames are considered in_app
    };
    if (lineno !== void 0) {
      frame.lineno = lineno;
    }
    if (colno !== void 0) {
      frame.colno = colno;
    }
    return frame;
  }
  const chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  const chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  const chromeStackParserFn = (line) => {
    const parts = chromeRegex.exec(line);
    if (parts) {
      const isEval = parts[2] && parts[2].indexOf("eval") === 0;
      if (isEval) {
        const subMatch = chromeEvalRegex.exec(parts[2]);
        if (subMatch) {
          parts[2] = subMatch[1];
          parts[3] = subMatch[2];
          parts[4] = subMatch[3];
        }
      }
      const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
      return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
    }
    return;
  };
  const chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];
  const geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
  const geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  const gecko = (line) => {
    const parts = geckoREgex.exec(line);
    if (parts) {
      const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      if (isEval) {
        const subMatch = geckoEvalRegex.exec(parts[3]);
        if (subMatch) {
          parts[1] = parts[1] || "eval";
          parts[3] = subMatch[1];
          parts[4] = subMatch[2];
          parts[5] = "";
        }
      }
      let filename = parts[3];
      let func = parts[1] || UNKNOWN_FUNCTION;
      [func, filename] = extractSafariExtensionDetails(func, filename);
      return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
    }
    return;
  };
  const geckoStackLineParser = [GECKO_PRIORITY, gecko];
  const winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  const winjs = (line) => {
    const parts = winjsRegex.exec(line);
    return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
  };
  const winjsStackLineParser = [WINJS_PRIORITY, winjs];
  const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];
  const defaultStackParser = createStackParser(...defaultStackLineParsers);
  const extractSafariExtensionDetails = (func, filename) => {
    const isSafariExtension = func.indexOf("safari-extension") !== -1;
    const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
    return isSafariExtension || isSafariWebExtension ? [
      func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
      isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
    ] : [func, filename];
  };
  const MAX_ALLOWED_STRING_LENGTH = 1024;
  const INTEGRATION_NAME$5 = "Breadcrumbs";
  const _breadcrumbsIntegration = (options = {}) => {
    const _options = {
      console: true,
      dom: true,
      fetch: true,
      history: true,
      sentry: true,
      xhr: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME$5,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      setup(client) {
        if (_options.console) {
          addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));
        }
        if (_options.dom) {
          addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));
        }
        if (_options.xhr) {
          addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));
        }
        if (_options.fetch) {
          addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));
        }
        if (_options.history) {
          addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));
        }
        if (_options.sentry && client.on) {
          client.on("beforeSendEvent", _getSentryBreadcrumbHandler(client));
        }
      }
    };
  };
  const breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$5, breadcrumbsIntegration);
  function _getSentryBreadcrumbHandler(client) {
    return function addSentryBreadcrumb(event) {
      if (getClient() !== client) {
        return;
      }
      addBreadcrumb(
        {
          category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
          event_id: event.event_id,
          level: event.level,
          message: getEventDescription(event)
        },
        {
          event
        }
      );
    };
  }
  function _getDomBreadcrumbHandler(client, dom) {
    return function _innerDomBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      let target;
      let componentName;
      let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
      let maxStringLength = typeof dom === "object" && typeof dom.maxStringLength === "number" ? dom.maxStringLength : void 0;
      if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
        DEBUG_BUILD && logger.warn(
          `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`
        );
        maxStringLength = MAX_ALLOWED_STRING_LENGTH;
      }
      if (typeof keyAttrs === "string") {
        keyAttrs = [keyAttrs];
      }
      try {
        const event = handlerData.event;
        const element = _isEvent(event) ? event.target : event;
        target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
        componentName = getComponentName(element);
      } catch (e) {
        target = "<unknown>";
      }
      if (target.length === 0) {
        return;
      }
      const breadcrumb = {
        category: `ui.${handlerData.name}`,
        message: target
      };
      if (componentName) {
        breadcrumb.data = { "ui.component_name": componentName };
      }
      addBreadcrumb(breadcrumb, {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global
      });
    };
  }
  function _getConsoleBreadcrumbHandler(client) {
    return function _consoleBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const breadcrumb = {
        category: "console",
        data: {
          arguments: handlerData.args,
          logger: "console"
        },
        level: severityLevelFromString(handlerData.level),
        message: safeJoin(handlerData.args, " ")
      };
      if (handlerData.level === "assert") {
        if (handlerData.args[0] === false) {
          breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
          breadcrumb.data.arguments = handlerData.args.slice(1);
        } else {
          return;
        }
      }
      addBreadcrumb(breadcrumb, {
        input: handlerData.args,
        level: handlerData.level
      });
    };
  }
  function _getXhrBreadcrumbHandler(client) {
    return function _xhrBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const { startTimestamp, endTimestamp } = handlerData;
      const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
      if (!startTimestamp || !endTimestamp || !sentryXhrData) {
        return;
      }
      const { method, url, status_code, body } = sentryXhrData;
      const data = {
        method,
        url,
        status_code
      };
      const hint = {
        xhr: handlerData.xhr,
        input: body,
        startTimestamp,
        endTimestamp
      };
      addBreadcrumb(
        {
          category: "xhr",
          data,
          type: "http"
        },
        hint
      );
    };
  }
  function _getFetchBreadcrumbHandler(client) {
    return function _fetchBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      const { startTimestamp, endTimestamp } = handlerData;
      if (!endTimestamp) {
        return;
      }
      if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
        return;
      }
      if (handlerData.error) {
        const data = handlerData.fetchData;
        const hint = {
          data: handlerData.error,
          input: handlerData.args,
          startTimestamp,
          endTimestamp
        };
        addBreadcrumb(
          {
            category: "fetch",
            data,
            level: "error",
            type: "http"
          },
          hint
        );
      } else {
        const response = handlerData.response;
        const data = {
          ...handlerData.fetchData,
          status_code: response && response.status
        };
        const hint = {
          input: handlerData.args,
          response,
          startTimestamp,
          endTimestamp
        };
        addBreadcrumb(
          {
            category: "fetch",
            data,
            type: "http"
          },
          hint
        );
      }
    };
  }
  function _getHistoryBreadcrumbHandler(client) {
    return function _historyBreadcrumb(handlerData) {
      if (getClient() !== client) {
        return;
      }
      let from = handlerData.from;
      let to = handlerData.to;
      const parsedLoc = parseUrl(WINDOW.location.href);
      let parsedFrom = from ? parseUrl(from) : void 0;
      const parsedTo = parseUrl(to);
      if (!parsedFrom || !parsedFrom.path) {
        parsedFrom = parsedLoc;
      }
      if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
        to = parsedTo.relative;
      }
      if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
        from = parsedFrom.relative;
      }
      addBreadcrumb({
        category: "navigation",
        data: {
          from,
          to
        }
      });
    };
  }
  function _isEvent(event) {
    return !!event && !!event.target;
  }
  const INTEGRATION_NAME$4 = "Dedupe";
  const _dedupeIntegration = () => {
    let previousEvent;
    return {
      name: INTEGRATION_NAME$4,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      processEvent(currentEvent) {
        if (currentEvent.type) {
          return currentEvent;
        }
        try {
          if (_shouldDropEvent(currentEvent, previousEvent)) {
            DEBUG_BUILD && logger.warn("Event dropped due to being a duplicate of previously captured event.");
            return null;
          }
        } catch (_oO) {
        }
        return previousEvent = currentEvent;
      }
    };
  };
  const dedupeIntegration = defineIntegration(_dedupeIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$4, dedupeIntegration);
  function _shouldDropEvent(currentEvent, previousEvent) {
    if (!previousEvent) {
      return false;
    }
    if (_isSameMessageEvent(currentEvent, previousEvent)) {
      return true;
    }
    if (_isSameExceptionEvent(currentEvent, previousEvent)) {
      return true;
    }
    return false;
  }
  function _isSameMessageEvent(currentEvent, previousEvent) {
    const currentMessage = currentEvent.message;
    const previousMessage = previousEvent.message;
    if (!currentMessage && !previousMessage) {
      return false;
    }
    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
      return false;
    }
    if (currentMessage !== previousMessage) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameExceptionEvent(currentEvent, previousEvent) {
    const previousException = _getExceptionFromEvent(previousEvent);
    const currentException = _getExceptionFromEvent(currentEvent);
    if (!previousException || !currentException) {
      return false;
    }
    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameStacktrace(currentEvent, previousEvent) {
    let currentFrames = _getFramesFromEvent(currentEvent);
    let previousFrames = _getFramesFromEvent(previousEvent);
    if (!currentFrames && !previousFrames) {
      return true;
    }
    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
      return false;
    }
    currentFrames = currentFrames;
    previousFrames = previousFrames;
    if (previousFrames.length !== currentFrames.length) {
      return false;
    }
    for (let i2 = 0; i2 < previousFrames.length; i2++) {
      const frameA = previousFrames[i2];
      const frameB = currentFrames[i2];
      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
        return false;
      }
    }
    return true;
  }
  function _isSameFingerprint(currentEvent, previousEvent) {
    let currentFingerprint = currentEvent.fingerprint;
    let previousFingerprint = previousEvent.fingerprint;
    if (!currentFingerprint && !previousFingerprint) {
      return true;
    }
    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
      return false;
    }
    currentFingerprint = currentFingerprint;
    previousFingerprint = previousFingerprint;
    try {
      return !!(currentFingerprint.join("") === previousFingerprint.join(""));
    } catch (_oO) {
      return false;
    }
  }
  function _getExceptionFromEvent(event) {
    return event.exception && event.exception.values && event.exception.values[0];
  }
  function _getFramesFromEvent(event) {
    const exception = event.exception;
    if (exception) {
      try {
        return exception.values[0].stacktrace.frames;
      } catch (_oO) {
        return void 0;
      }
    }
    return void 0;
  }
  const INTEGRATION_NAME$3 = "GlobalHandlers";
  const _globalHandlersIntegration = (options = {}) => {
    const _options = {
      onerror: true,
      onunhandledrejection: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME$3,
      setupOnce() {
        Error.stackTraceLimit = 50;
      },
      setup(client) {
        if (_options.onerror) {
          _installGlobalOnErrorHandler(client);
          globalHandlerLog("onerror");
        }
        if (_options.onunhandledrejection) {
          _installGlobalOnUnhandledRejectionHandler(client);
          globalHandlerLog("onunhandledrejection");
        }
      }
    };
  };
  const globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME$3,
    globalHandlersIntegration
  );
  function _installGlobalOnErrorHandler(client) {
    addGlobalErrorInstrumentationHandler((data) => {
      const { stackParser, attachStacktrace } = getOptions();
      if (getClient() !== client || shouldIgnoreOnError()) {
        return;
      }
      const { msg, url, line, column, error: error2 } = data;
      const event = error2 === void 0 && isString$5(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(
        eventFromUnknownInput(stackParser, error2 || msg, void 0, attachStacktrace, false),
        url,
        line,
        column
      );
      event.level = "error";
      captureEvent(event, {
        originalException: error2,
        mechanism: {
          handled: false,
          type: "onerror"
        }
      });
    });
  }
  function _installGlobalOnUnhandledRejectionHandler(client) {
    addGlobalUnhandledRejectionInstrumentationHandler((e) => {
      const { stackParser, attachStacktrace } = getOptions();
      if (getClient() !== client || shouldIgnoreOnError()) {
        return;
      }
      const error2 = _getUnhandledRejectionError(e);
      const event = isPrimitive(error2) ? _eventFromRejectionWithPrimitive(error2) : eventFromUnknownInput(stackParser, error2, void 0, attachStacktrace, true);
      event.level = "error";
      captureEvent(event, {
        originalException: error2,
        mechanism: {
          handled: false,
          type: "onunhandledrejection"
        }
      });
    });
  }
  function _getUnhandledRejectionError(error2) {
    if (isPrimitive(error2)) {
      return error2;
    }
    const e = error2;
    try {
      if ("reason" in e) {
        return e.reason;
      } else if ("detail" in e && "reason" in e.detail) {
        return e.detail.reason;
      }
    } catch (e2) {
    }
    return error2;
  }
  function _eventFromRejectionWithPrimitive(reason) {
    return {
      exception: {
        values: [
          {
            type: "UnhandledRejection",
            // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
            value: `Non-Error promise rejection captured with value: ${String(reason)}`
          }
        ]
      }
    };
  }
  function _eventFromIncompleteOnError(msg, url, line, column) {
    const ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    let message = isErrorEvent$1(msg) ? msg.message : msg;
    let name = "Error";
    const groups = message.match(ERROR_TYPES_RE);
    if (groups) {
      name = groups[1];
      message = groups[2];
    }
    const event = {
      exception: {
        values: [
          {
            type: name,
            value: message
          }
        ]
      }
    };
    return _enhanceEventWithInitialFrame(event, url, line, column);
  }
  function _enhanceEventWithInitialFrame(event, url, line, column) {
    const e = event.exception = event.exception || {};
    const ev = e.values = e.values || [];
    const ev0 = ev[0] = ev[0] || {};
    const ev0s = ev0.stacktrace = ev0.stacktrace || {};
    const ev0sf = ev0s.frames = ev0s.frames || [];
    const colno = isNaN(parseInt(column, 10)) ? void 0 : column;
    const lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
    const filename = isString$5(url) && url.length > 0 ? url : getLocationHref();
    if (ev0sf.length === 0) {
      ev0sf.push({
        colno,
        filename,
        function: "?",
        in_app: true,
        lineno
      });
    }
    return event;
  }
  function globalHandlerLog(type) {
    DEBUG_BUILD && logger.log(`Global Handler attached: ${type}`);
  }
  function getOptions() {
    const client = getClient();
    const options = client && client.getOptions() || {
      stackParser: () => [],
      attachStacktrace: false
    };
    return options;
  }
  const INTEGRATION_NAME$2 = "HttpContext";
  const _httpContextIntegration = () => {
    return {
      name: INTEGRATION_NAME$2,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      preprocessEvent(event) {
        if (!WINDOW.navigator && !WINDOW.location && !WINDOW.document) {
          return;
        }
        const url = event.request && event.request.url || WINDOW.location && WINDOW.location.href;
        const { referrer } = WINDOW.document || {};
        const { userAgent } = WINDOW.navigator || {};
        const headers = {
          ...event.request && event.request.headers,
          ...referrer && { Referer: referrer },
          ...userAgent && { "User-Agent": userAgent }
        };
        const request = { ...event.request, ...url && { url }, headers };
        event.request = request;
      }
    };
  };
  const httpContextIntegration = defineIntegration(_httpContextIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$2, httpContextIntegration);
  const DEFAULT_KEY = "cause";
  const DEFAULT_LIMIT = 5;
  const INTEGRATION_NAME$1 = "LinkedErrors";
  const _linkedErrorsIntegration = (options = {}) => {
    const limit = options.limit || DEFAULT_LIMIT;
    const key = options.key || DEFAULT_KEY;
    return {
      name: INTEGRATION_NAME$1,
      // TODO v8: Remove this
      setupOnce() {
      },
      // eslint-disable-line @typescript-eslint/no-empty-function
      preprocessEvent(event, hint, client) {
        const options2 = client.getOptions();
        applyAggregateErrorsToEvent(
          // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
          exceptionFromError,
          options2.stackParser,
          options2.maxValueLength,
          key,
          limit,
          event,
          hint
        );
      }
    };
  };
  const linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
  convertIntegrationFnToClass(INTEGRATION_NAME$1, linkedErrorsIntegration);
  const DEFAULT_EVENT_TARGET = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "BroadcastChannel",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "SharedWorker",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload"
  ];
  const INTEGRATION_NAME = "TryCatch";
  const _browserApiErrorsIntegration = (options = {}) => {
    const _options = {
      XMLHttpRequest: true,
      eventTarget: true,
      requestAnimationFrame: true,
      setInterval: true,
      setTimeout: true,
      ...options
    };
    return {
      name: INTEGRATION_NAME,
      // TODO: This currently only works for the first client this is setup
      // We may want to adjust this to check for client etc.
      setupOnce() {
        if (_options.setTimeout) {
          fill(WINDOW, "setTimeout", _wrapTimeFunction);
        }
        if (_options.setInterval) {
          fill(WINDOW, "setInterval", _wrapTimeFunction);
        }
        if (_options.requestAnimationFrame) {
          fill(WINDOW, "requestAnimationFrame", _wrapRAF);
        }
        if (_options.XMLHttpRequest && "XMLHttpRequest" in WINDOW) {
          fill(XMLHttpRequest.prototype, "send", _wrapXHR);
        }
        const eventTargetOption = _options.eventTarget;
        if (eventTargetOption) {
          const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
          eventTarget.forEach(_wrapEventTarget);
        }
      }
    };
  };
  const browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);
  convertIntegrationFnToClass(
    INTEGRATION_NAME,
    browserApiErrorsIntegration
  );
  function _wrapTimeFunction(original) {
    return function(...args) {
      const originalCallback = args[0];
      args[0] = wrap(originalCallback, {
        mechanism: {
          data: { function: getFunctionName(original) },
          handled: false,
          type: "instrument"
        }
      });
      return original.apply(this, args);
    };
  }
  function _wrapRAF(original) {
    return function(callback) {
      return original.apply(this, [
        wrap(callback, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: getFunctionName(original)
            },
            handled: false,
            type: "instrument"
          }
        })
      ]);
    };
  }
  function _wrapXHR(originalSend) {
    return function(...args) {
      const xhr = this;
      const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
      xmlHttpRequestProps.forEach((prop) => {
        if (prop in xhr && typeof xhr[prop] === "function") {
          fill(xhr, prop, function(original) {
            const wrapOptions = {
              mechanism: {
                data: {
                  function: prop,
                  handler: getFunctionName(original)
                },
                handled: false,
                type: "instrument"
              }
            };
            const originalFunction = getOriginalFunction(original);
            if (originalFunction) {
              wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
            }
            return wrap(original, wrapOptions);
          });
        }
      });
      return originalSend.apply(this, args);
    };
  }
  function _wrapEventTarget(target) {
    const globalObject = WINDOW;
    const proto = globalObject[target] && globalObject[target].prototype;
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(original) {
      return function(eventName, fn, options) {
        try {
          if (typeof fn.handleEvent === "function") {
            fn.handleEvent = wrap(fn.handleEvent, {
              mechanism: {
                data: {
                  function: "handleEvent",
                  handler: getFunctionName(fn),
                  target
                },
                handled: false,
                type: "instrument"
              }
            });
          }
        } catch (err) {
        }
        return original.apply(this, [
          eventName,
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          wrap(fn, {
            mechanism: {
              data: {
                function: "addEventListener",
                handler: getFunctionName(fn),
                target
              },
              handled: false,
              type: "instrument"
            }
          }),
          options
        ]);
      };
    });
    fill(
      proto,
      "removeEventListener",
      function(originalRemoveEventListener) {
        return function(eventName, fn, options) {
          const wrappedEventHandler = fn;
          try {
            const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
            if (originalEventHandler) {
              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
            }
          } catch (e) {
          }
          return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
        };
      }
    );
  }
  const defaultIntegrations = [
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    browserApiErrorsIntegration(),
    breadcrumbsIntegration(),
    globalHandlersIntegration(),
    linkedErrorsIntegration(),
    dedupeIntegration(),
    httpContextIntegration()
  ];
  function getDefaultIntegrations(_options) {
    return [
      // eslint-disable-next-line deprecation/deprecation
      ...defaultIntegrations
    ];
  }
  function init$2(options = {}) {
    if (options.defaultIntegrations === void 0) {
      options.defaultIntegrations = getDefaultIntegrations();
    }
    if (options.release === void 0) {
      if (typeof __SENTRY_RELEASE__ === "string") {
        options.release = __SENTRY_RELEASE__;
      }
      if (WINDOW.SENTRY_RELEASE && WINDOW.SENTRY_RELEASE.id) {
        options.release = WINDOW.SENTRY_RELEASE.id;
      }
    }
    if (options.autoSessionTracking === void 0) {
      options.autoSessionTracking = true;
    }
    if (options.sendClientReports === void 0) {
      options.sendClientReports = true;
    }
    const clientOptions = {
      ...options,
      stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
      integrations: getIntegrationsToSetup(options),
      transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport)
    };
    initAndBind(BrowserClient, clientOptions);
    if (options.autoSessionTracking) {
      startSessionTracking();
    }
  }
  function startSessionTracking() {
    if (typeof WINDOW.document === "undefined") {
      DEBUG_BUILD && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
      return;
    }
    startSession({ ignoreDuration: true });
    captureSession();
    addHistoryInstrumentationHandler(({ from, to }) => {
      if (from !== void 0 && from !== to) {
        startSession({ ignoreDuration: true });
        captureSession();
      }
    });
  }
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  function init$1(options) {
    const opts = {
      ...options
    };
    applySdkMetadata(opts, "react");
    init$2(opts);
  }
  function isWebExtError(obj, ...errorTypes) {
    const message = getMessage(obj);
    if (message === void 0) {
      return false;
    }
    return errorTypes.some((errorType) => {
      const matcher = ERRORS[errorType];
      return typeof matcher === "string" ? matcher === message : matcher.test(message);
    });
  }
  function hasMessageProperty(obj) {
    return typeof obj === "object" && obj !== null && "message" in obj && typeof obj.message === "string";
  }
  function getMessage(obj) {
    if (typeof obj === "string") {
      return obj;
    }
    if (hasMessageProperty(obj)) {
      return obj.message;
    }
    return void 0;
  }
  const ERRORS = {
    // Happens in content scripts on sending messages, after the extension has been unloaded (e.g.
    // during update or uninstall).
    CONTEXT_INVALIDATED: "Extension context invalidated.",
    TAB_DRAG_IN_PROGRESS: "Tabs cannot be edited right now (user may be dragging a tab).",
    COULD_NOT_ESTABLISH_CONNECTION: "Could not establish connection. Receiving end does not exist.",
    MISSING_HOST_PERMISSION_FOR_TAB: "Missing host permission for the tab",
    TAB_CLOSED: "The tab was closed.",
    NO_TAB_WITH_ID: /^No tab with id: \d+\.$/,
    // Chrome
    INVALID_TAB_ID: /^Invalid tab ID: \d+$/,
    // Firefox
    ACTIVE_TAB_PERMISSION_NOT_IN_EFFECT: "The 'activeTab' permission is not in effect because this extension has not been in invoked.",
    CAPTURE_TAB_IMAGE_READBACK_FAILED: "Failed to capture tab: image readback failed",
    CANNOT_ACCESS_CONTENTS_OF_URL: 'Cannot access contents of url "". Extension manifest must request permission to access this host.',
    ALL_URLS_OR_ACTIVE_TAB_PERMISSION_REQUIRED: "Either the '<all_urls>' or 'activeTab' permission is required.",
    UNEXPECTED_ERROR: "An unexpected error occurred",
    ERROR_CAPTURING_VISIBLE_TAB: "Error capturing visible tab.",
    INVALID_VALUE_FOR_BOUNDS: "Invalid value for bounds. Bounds must be at least 50% within visible screen space.",
    CLOSED_BEFORE_RESPONSE_RECEIVED: "A listener indicated an asynchronous response by returning true, but the message channel closed before a response was received",
    PERMISSION_ERROR: "Invalid call to tabs.captureVisibleTab(). Either the 'activeTab' permission or granted host permissions for the current website are required."
  };
  background;
  function isMessageResponseEnvelope(response) {
    return typeof response === "object" && response !== null;
  }
  const messageError = Symbol("messageError");
  async function sendMessage(m2) {
    return doSendMessage(() => browser$1.runtime.sendMessage(m2));
  }
  async function sendMessageToTab(tabId, m2, frameId) {
    return doSendMessage(() => browser$1.tabs.sendMessage(tabId, m2, {
      frameId
    }));
  }
  async function doSendMessage(send) {
    try {
      const response = await send();
      if (response === null || response === void 0) {
        return messageError;
      }
      if (isMessageResponseEnvelope(response)) {
        return response.value;
      }
      trackError(new Error(`Received unexpected response sending message: ${JSON.stringify(response)}`));
      return messageError;
    } catch (e) {
      reportMessageError(e);
      return messageError;
    }
  }
  async function sendMessageToAllTabs(m2) {
    const tabs = await browser$1.tabs.query({});
    const tabMessages = tabs.map((t) => t.id ? sendMessageToTab(t.id, m2) : Promise.resolve(messageError));
    const results = await Promise.allSettled(tabMessages);
    return results.flatMap((r2) => {
      if (r2.status !== "fulfilled") {
        return [];
      }
      const {
        value
      } = r2;
      return value !== messageError ? [value] : [];
    });
  }
  async function broadcastMessage(m2) {
    return Promise.allSettled([sendMessage(m2), sendMessageToAllTabs(m2)]);
  }
  function makeMessageListener(handlers2) {
    return (msg, sender) => {
      const handler = handlers2[msg.type];
      if (handler) {
        try {
          return (async () => {
            const value = await handler(msg, sender);
            return {
              value
            };
          })();
        } catch (e) {
          reportMessageError(e);
        }
      }
      return void 0;
    };
  }
  const IGNORED_ERROR_MESSAGES = [
    // happens when the other side goes away unexpectedly (e.g. tab close)
    "COULD_NOT_ESTABLISH_CONNECTION",
    // for urls on which extensions are never allowed to run (e.g. chrome://*, some about:* pages)
    "MISSING_HOST_PERMISSION_FOR_TAB",
    // Sending message to tab that was closed in the meantime
    "TAB_CLOSED",
    "NO_TAB_WITH_ID",
    // Chrome
    "INVALID_TAB_ID",
    // Firefox
    // Should be handled by polyfill, but isn't - https://github.com/mozilla/webextension-polyfill/issues/384
    "CLOSED_BEFORE_RESPONSE_RECEIVED",
    // Seems to happen in Firefox for some messages: https://sentry.heylogin.dev/organizations/heylogin/issues/755
    "UNEXPECTED_ERROR",
    // No need to report this one.
    // FIXME: When this error comes up, the content script is no longer in a functional state and we
    // might as well unload it entirely. This happens e.g. with lingering content scripts after the
    // extension is unloaded/reloaded.
    "CONTEXT_INVALIDATED"
  ];
  function reportMessageError(e) {
    if (isWebExtError(e, ...IGNORED_ERROR_MESSAGES)) {
      return;
    }
    trackError(new Error("Failed to send message", {
      cause: e
    }));
  }
  background;
  const HEYLOGIN_VERSION = "2024-11-29-99ee37d32";
  const CLIPBOARD_CLEAR_TIMEOUT_MS = 3e4;
  background;
  function getBackendUrl() {
    return "https://heylogin.app/api/v1";
  }
  function getAuditlogUrl() {
    return "https://log.heylogin.app/api/v1";
  }
  function getFrontendServerUrl() {
    return `https://${getFrontendServerHost()}`;
  }
  function getFrontendServerHost() {
    return "heylogin.app";
  }
  background;
  function initSentry({
    entryPoint,
    contentScript,
    skipProductionCheck
  }) {
    var _a2;
    const prodOrStagingBackend = (_a2 = getBackendHostname()) == null ? void 0 : _a2.endsWith("heylogin.app");
    const isProdOrStaging = prodOrStagingBackend;
    if (!isProdOrStaging && !skipProductionCheck) {
      return;
    }
    if (browser$1.extension.inIncognitoContext) {
      return;
    }
    const browserInfo = Bowser.parse(navigator.userAgent);
    if (browserInfo.browser.name === "Firefox") {
      return;
    }
    try {
      init$1({
        dsn: "https://a84c0408f0864d0bb6002a42294d213b@stackreports.heylogin.app/5338044",
        release: HEYLOGIN_VERSION || "unknown version",
        // TODO reconsider this if we ever create staging build of the extension
        environment: "production",
        autoSessionTracking: false,
        integrations: (integrations) => {
          let filteredIntegrations = integrations;
          if (contentScript) {
            const disabledIntegrationNames = ["Breadcrumbs", "TryCatch", "GlobalHandlers"];
            filteredIntegrations = filteredIntegrations.filter((integration) => !disabledIntegrationNames.includes(integration.name));
          }
          return filteredIntegrations;
        },
        // see https://develop.sentry.dev/sdk/data-model/event-payloads/breadcrumbs/#breadcrumb-types
        beforeBreadcrumb: (breadcrumb, _hint) => {
          if (breadcrumb.type === "http") {
            if (breadcrumb.data && typeof breadcrumb.data.url === "string" && breadcrumb.data.url.startsWith("data:")) {
              return null;
            }
          }
          return breadcrumb;
        },
        beforeSend: (event) => {
          if (event.request) {
            event.request.url = void 0;
          }
          return event;
        },
        ignoreErrors: [
          // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
          "ResizeObserver loop limit exceeded",
          "ResizeObserver loop completed with undelivered notifications.",
          // Temporary fix, to avoid exhausting our sentry quota with this error: https://sentry.io/organizations/heylogin/issues/2274010196/
          // This is due to a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1213925
          "Tabs cannot be queried right now (user may be dragging a tab).",
          // Nothing we can do about this error, no need to report
          "The browser is shutting down."
        ]
      });
      configureScope$1((scope) => {
        scope.setTag("entryPoint", entryPoint);
      });
      configureScope().catch(trackError);
      browser$1.runtime.onMessage.addListener(makeMessageListener({
        DataUpdate: configureScope
      }));
      if (!HEYLOGIN_VERSION && !skipProductionCheck && entryPoint === "background")
        ;
    } catch (e) {
      console.error("Error while initializing error reporting ¯\\_(ツ)_/¯", e);
    }
  }
  async function configureScope() {
    const response = await sendMessage({
      type: "GetUser"
    });
    if (response === messageError) {
      return;
    }
    const {
      userId,
      clientId
    } = {
      userId: void 0,
      clientId: void 0,
      ...response
    };
    updateSentryScope(userId, clientId);
  }
  function updateSentryScope(userId, clientId) {
    configureScope$1((scope) => {
      scope.setUser({
        id: userId
      });
      scope.setTag("clientId", clientId ?? "empty");
    });
  }
  function getBackendHostname() {
    try {
      return new URL(getBackendUrl()).hostname;
    } catch (e) {
      return void 0;
    }
  }
  background;
  var dist$2 = {};
  var errors$1 = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorMessages = exports.ErrorType = void 0;
    var ErrorType;
    (function(ErrorType2) {
      ErrorType2["MalformedUnicode"] = "MALFORMED_UNICODE";
      ErrorType2["MalformedHexadecimal"] = "MALFORMED_HEXADECIMAL";
      ErrorType2["CodePointLimit"] = "CODE_POINT_LIMIT";
      ErrorType2["OctalDeprecation"] = "OCTAL_DEPRECATION";
      ErrorType2["EndOfString"] = "END_OF_STRING";
    })(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
    exports.errorMessages = /* @__PURE__ */ new Map([
      [ErrorType.MalformedUnicode, "malformed Unicode character escape sequence"],
      [
        ErrorType.MalformedHexadecimal,
        "malformed hexadecimal character escape sequence"
      ],
      [
        ErrorType.CodePointLimit,
        "Unicode codepoint must not be greater than 0x10FFFF in escape sequence"
      ],
      [
        ErrorType.OctalDeprecation,
        '"0"-prefixed octal literals and octal escape sequences are deprecated; for octal literals use the "0o" prefix instead'
      ],
      [ErrorType.EndOfString, "malformed escape sequence at end of string"]
    ]);
  })(errors$1);
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unraw = exports.errorMessages = exports.ErrorType = void 0;
    const errors_1 = errors$1;
    Object.defineProperty(exports, "ErrorType", { enumerable: true, get: function() {
      return errors_1.ErrorType;
    } });
    Object.defineProperty(exports, "errorMessages", { enumerable: true, get: function() {
      return errors_1.errorMessages;
    } });
    function parseHexToInt(hex) {
      const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);
      return isOnlyHexChars ? parseInt(hex, 16) : NaN;
    }
    function validateAndParseHex(hex, errorName, enforcedLength) {
      const parsedHex = parseHexToInt(hex);
      if (Number.isNaN(parsedHex) || enforcedLength !== void 0 && enforcedLength !== hex.length) {
        throw new SyntaxError(errors_1.errorMessages.get(errorName));
      }
      return parsedHex;
    }
    function parseHexadecimalCode(code) {
      const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);
      return String.fromCharCode(parsedCode);
    }
    function parseUnicodeCode(code, surrogateCode) {
      const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);
      if (surrogateCode !== void 0) {
        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);
        return String.fromCharCode(parsedCode, parsedSurrogateCode);
      }
      return String.fromCharCode(parsedCode);
    }
    function isCurlyBraced(text) {
      return text.charAt(0) === "{" && text.charAt(text.length - 1) === "}";
    }
    function parseUnicodeCodePointCode(codePoint) {
      if (!isCurlyBraced(codePoint)) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));
      }
      const withoutBraces = codePoint.slice(1, -1);
      const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);
      try {
        return String.fromCodePoint(parsedCode);
      } catch (err) {
        throw err instanceof RangeError ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit)) : err;
      }
    }
    function parseOctalCode(code, error2 = false) {
      if (error2) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));
      }
      const parsedCode = parseInt(code, 8);
      return String.fromCharCode(parsedCode);
    }
    const singleCharacterEscapes = /* @__PURE__ */ new Map([
      ["b", "\b"],
      ["f", "\f"],
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["v", "\v"],
      ["0", "\0"]
    ]);
    function parseSingleCharacterCode(code) {
      return singleCharacterEscapes.get(code) || code;
    }
    const escapeMatch = /\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;
    function unraw2(raw, allowOctals = false) {
      return raw.replace(escapeMatch, function(_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {
        if (backslash !== void 0) {
          return "\\";
        }
        if (hex !== void 0) {
          return parseHexadecimalCode(hex);
        }
        if (codePoint !== void 0) {
          return parseUnicodeCodePointCode(codePoint);
        }
        if (unicodeWithSurrogate !== void 0) {
          return parseUnicodeCode(unicodeWithSurrogate, surrogate);
        }
        if (unicode !== void 0) {
          return parseUnicodeCode(unicode);
        }
        if (octal === "0") {
          return "\0";
        }
        if (octal !== void 0) {
          return parseOctalCode(octal, !allowOctals);
        }
        if (singleCharacter !== void 0) {
          return parseSingleCharacterCode(singleCharacter);
        }
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));
      });
    }
    exports.unraw = unraw2;
    exports.default = unraw2;
  })(dist$2);
  const unraw = /* @__PURE__ */ getDefaultExportFromCjs(dist$2);
  const isString$4 = (s2) => typeof s2 === "string";
  const isFunction$1 = (f2) => typeof f2 === "function";
  const cache = /* @__PURE__ */ new Map();
  function normalizeLocales(locales) {
    const out = Array.isArray(locales) ? locales : [locales];
    return [...out, "en"];
  }
  function date(locales, value, format) {
    const _locales = normalizeLocales(locales);
    const formatter = getMemoized(
      () => cacheKey("date", _locales, format),
      () => new Intl.DateTimeFormat(_locales, format)
    );
    return formatter.format(isString$4(value) ? new Date(value) : value);
  }
  function number(locales, value, format) {
    const _locales = normalizeLocales(locales);
    const formatter = getMemoized(
      () => cacheKey("number", _locales, format),
      () => new Intl.NumberFormat(_locales, format)
    );
    return formatter.format(value);
  }
  function plural(locales, ordinal, value, { offset = 0, ...rules }) {
    const _locales = normalizeLocales(locales);
    const plurals = ordinal ? getMemoized(
      () => cacheKey("plural-ordinal", _locales),
      () => new Intl.PluralRules(_locales, { type: "ordinal" })
    ) : getMemoized(
      () => cacheKey("plural-cardinal", _locales),
      () => new Intl.PluralRules(_locales, { type: "cardinal" })
    );
    return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;
  }
  function getMemoized(getKey, construct) {
    const key = getKey();
    let formatter = cache.get(key);
    if (!formatter) {
      formatter = construct();
      cache.set(key, formatter);
    }
    return formatter;
  }
  function cacheKey(type, locales, options) {
    const localeKey = locales.join("-");
    return `${type}-${localeKey}-${JSON.stringify(options)}`;
  }
  const UNICODE_REGEX = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g;
  const getDefaultFormats = (locale, locales, formats = {}) => {
    locales = locales || locale;
    const style = (format) => isString$4(format) ? formats[format] || { style: format } : format;
    const replaceOctothorpe = (value, message) => {
      const numberFormat = Object.keys(formats).length ? style("number") : {};
      const valueStr = number(locales, value, numberFormat);
      return message.replace("#", valueStr);
    };
    return {
      plural: (value, cases) => {
        const { offset = 0 } = cases;
        const message = plural(locales, false, value, cases);
        return replaceOctothorpe(value - offset, message);
      },
      selectordinal: (value, cases) => {
        const { offset = 0 } = cases;
        const message = plural(locales, true, value, cases);
        return replaceOctothorpe(value - offset, message);
      },
      select: (value, rules) => rules[value] ?? rules.other,
      number: (value, format) => number(locales, value, style(format)),
      date: (value, format) => date(locales, value, style(format)),
      undefined: (value) => value
    };
  };
  function interpolate(translation, locale, locales) {
    return (values, formats = {}) => {
      const formatters = getDefaultFormats(locale, locales, formats);
      const formatMessage = (message) => {
        if (!Array.isArray(message))
          return message;
        return message.reduce((message2, token) => {
          if (isString$4(token))
            return message2 + token;
          const [name, type, format] = token;
          let interpolatedFormat = {};
          if (format != null && !isString$4(format)) {
            Object.keys(format).forEach((key) => {
              interpolatedFormat[key] = formatMessage(format[key]);
            });
          } else {
            interpolatedFormat = format;
          }
          const value = formatters[type](values[name], interpolatedFormat);
          if (value == null)
            return message2;
          return message2 + value;
        }, "");
      };
      const result2 = formatMessage(translation);
      if (isString$4(result2) && UNICODE_REGEX.test(result2)) {
        return unraw(result2.trim());
      }
      if (isString$4(result2))
        return result2.trim();
      return result2;
    };
  }
  var __defProp$1 = Object.defineProperty;
  var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField$1 = (obj, key, value) => {
    __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  class EventEmitter {
    constructor() {
      __publicField$1(this, "_events", {});
    }
    on(event, listener) {
      if (!this._hasEvent(event))
        this._events[event] = [];
      this._events[event].push(listener);
      return () => this.removeListener(event, listener);
    }
    removeListener(event, listener) {
      if (!this._hasEvent(event))
        return;
      const index = this._events[event].indexOf(listener);
      if (~index)
        this._events[event].splice(index, 1);
    }
    emit(event, ...args) {
      if (!this._hasEvent(event))
        return;
      this._events[event].map((listener) => listener.apply(this, args));
    }
    _hasEvent(event) {
      return Array.isArray(this._events[event]);
    }
  }
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  class I18n extends EventEmitter {
    constructor(params) {
      super();
      __publicField2(this, "_locale");
      __publicField2(this, "_locales");
      __publicField2(this, "_localeData");
      __publicField2(this, "_messages");
      __publicField2(this, "_missing");
      __publicField2(this, "t", this._.bind(this));
      this._messages = {};
      this._localeData = {};
      if (params.missing != null)
        this._missing = params.missing;
      if (params.messages != null)
        this.load(params.messages);
      if (params.localeData != null)
        this.loadLocaleData(params.localeData);
      if (params.locale != null || params.locales != null) {
        this.activate(params.locale, params.locales);
      }
    }
    get locale() {
      return this._locale;
    }
    get locales() {
      return this._locales;
    }
    get messages() {
      return this._messages[this._locale] ?? {};
    }
    /**
     * @deprecated this has no effect. Please remove this from the code. Deprecated in v4
     */
    get localeData() {
      return this._localeData[this._locale] ?? {};
    }
    _loadLocaleData(locale, localeData) {
      if (this._localeData[locale] == null) {
        this._localeData[locale] = localeData;
      } else {
        Object.assign(this._localeData[locale], localeData);
      }
    }
    /**
     * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4
     */
    loadLocaleData(localeOrAllData, localeData) {
      if (localeData != null) {
        this._loadLocaleData(localeOrAllData, localeData);
      } else {
        Object.keys(localeOrAllData).forEach(
          (locale) => this._loadLocaleData(locale, localeOrAllData[locale])
        );
      }
      this.emit("change");
    }
    _load(locale, messages2) {
      if (this._messages[locale] == null) {
        this._messages[locale] = messages2;
      } else {
        Object.assign(this._messages[locale], messages2);
      }
    }
    load(localeOrMessages, messages2) {
      if (messages2 != null) {
        this._load(localeOrMessages, messages2);
      } else {
        Object.keys(localeOrMessages).forEach(
          (locale) => this._load(locale, localeOrMessages[locale])
        );
      }
      this.emit("change");
    }
    /**
     * @param options {@link LoadAndActivateOptions}
     */
    loadAndActivate({ locale, locales, messages: messages2 }) {
      this._locale = locale;
      this._locales = locales || void 0;
      this._messages[this._locale] = messages2;
      this.emit("change");
    }
    activate(locale, locales) {
      this._locale = locale;
      this._locales = locales;
      this.emit("change");
    }
    _(id, values = {}, { message, formats } = {}) {
      if (!isString$4(id)) {
        values = id.values || values;
        message = id.message;
        id = id.id;
      }
      const messageMissing = !this.messages[id];
      const missing = this._missing;
      if (missing && messageMissing) {
        return isFunction$1(missing) ? missing(this._locale, id) : missing;
      }
      if (messageMissing) {
        this.emit("missing", { id, locale: this._locale });
      }
      let translation = this.messages[id] || message || id;
      if (isString$4(translation) && UNICODE_REGEX.test(translation))
        return JSON.parse(`"${translation}"`);
      if (isString$4(translation))
        return translation;
      return interpolate(
        translation,
        this._locale,
        this._locales
      )(values, formats);
    }
    date(value, format) {
      return date(this._locales || this._locale, value, format);
    }
    number(value, format) {
      return number(this._locales || this._locale, value, format);
    }
  }
  function setupI18n(params = {}) {
    return new I18n(params);
  }
  const i18n = setupI18n();
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever2(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever2;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys2 = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys2.push(key);
        }
      }
      return keys2;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  const ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  class ZodError extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error2) => {
        for (const issue of error2.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i2 = 0;
            while (i2 < issue.path.length) {
              const el = issue.path[i2];
              const terminal = i2 === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i2++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  }
  ZodError.create = (issues) => {
    const error2 = new ZodError(issues);
    return error2;
  };
  const errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  let overrideErrorMap = errorMap;
  function setErrorMap(map2) {
    overrideErrorMap = map2;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
    for (const map2 of maps) {
      errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  const EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x2) => !!x2)
    });
    ctx.common.issues.push(issue);
  }
  class ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s2 of results) {
        if (s2.status === "aborted")
          return INVALID;
        if (s2.status === "dirty")
          status.dirty();
        arrayValue.push(s2.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  }
  const INVALID = Object.freeze({
    status: "aborted"
  });
  const DIRTY = (value) => ({ status: "dirty", value });
  const OK = (value) => ({ status: "valid", value });
  const isAborted = (x2) => x2.status === "aborted";
  const isDirty = (x2) => x2.status === "dirty";
  const isValid = (x2) => x2.status === "valid";
  const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  class ParseInputLazyPath {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  }
  const handleResult = (ctx, result2) => {
    if (isValid(result2)) {
      return { success: true, data: result2.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error2 = new ZodError(ctx.common.issues);
          this._error = error2;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  class ZodType {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result2 = this._parse(input);
      if (isAsync(result2)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result2;
    }
    _parseAsync(input) {
      const result2 = this._parse(input);
      return Promise.resolve(result2);
    }
    parse(data, params) {
      const result2 = this.safeParse(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    safeParse(data, params) {
      var _a2;
      const ctx = {
        common: {
          issues: [],
          async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result2);
    }
    async parseAsync(data, params) {
      const result2 = await this.safeParseAsync(data, params);
      if (result2.success)
        return result2.data;
      throw result2.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result2);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result2 = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result2 instanceof Promise) {
          return result2.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result2) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  }
  const cuidRegex = /^c[^\s-]{8,}$/i;
  const cuid2Regex = /^[a-z][a-z0-9]*$/;
  const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  let emojiRegex;
  const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  const datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a2) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex2 = datetimeRegex(check);
          if (!regex2.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex2, validation, message) {
      return this.refinement((data) => regex2.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a2;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex2, message) {
      return this._addCheck({
        kind: "regex",
        regex: regex2,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodString.create = (params) => {
    var _a2;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max2 = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max2);
    }
  }
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2;
    }
  }
  ZodBigInt.create = (params) => {
    var _a2;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
      ...processCreateParams(params)
    });
  };
  class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max2 = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max2 === null || ch.value < max2)
            max2 = ch.value;
        }
      }
      return max2 != null ? new Date(max2) : null;
    }
  }
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  }
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  }
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  }
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i2) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
        })).then((result3) => {
          return ParseStatus.mergeArray(status, result3);
        });
      }
      const result2 = [...ctx.data].map((item, i2) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      });
      return ParseStatus.mergeArray(status, result2);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys2 = util.objectKeys(shape);
      return this._cached = { shape, keys: keys2 };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a2, _b2, _c2, _d2;
            const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d2 = errorUtil.errToObj(message).message) !== null && _d2 !== void 0 ? _d2 : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      });
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  }
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result2 of results) {
          if (result2.result.status === "valid") {
            return result2.result;
          }
        }
        for (const result2 of results) {
          if (result2.result.status === "dirty") {
            ctx.common.issues.push(...result2.ctx.common.issues);
            return result2.result;
          }
        }
        const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result2 = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result2.status === "valid") {
            return result2;
          } else if (result2.status === "dirty" && !dirty) {
            dirty = { result: result2, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  }
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  }
  function mergeValues(a2, b) {
    const aType = getParsedType(a2);
    const bType = getParsedType(b);
    if (a2 === b) {
      return { valid: true, data: a2 };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a2, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a2[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a2.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a2.length; index++) {
        const itemA = a2[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b) {
      return { valid: true, data: a2 };
    } else {
      return { valid: false };
    }
  }
  class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  }
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x2) => !!x2);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  }
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  }
  class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  }
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  }
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error2) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error2
          }
        });
      }
      function makeReturnsIssue(returns, error2) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x2) => !!x2),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error2
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error2 = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error2.addIssue(makeArgsIssue(args, e));
            throw error2;
          });
          const result2 = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result2, params).catch((e) => {
            error2.addIssue(makeReturnsIssue(result2, e));
            throw error2;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result2 = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result2, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  }
  class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  }
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  }
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return ZodEnum.create(values);
    }
    exclude(values) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
  }
  ZodEnum.create = createZodEnum;
  class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  }
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  }
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result2 = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result2);
          }
          if (result2 instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base2 = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base2))
            return base2;
          const result2 = effect.transform(base2.value, checkCtx);
          if (result2 instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result2 };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
            if (!isValid(base2))
              return base2;
            return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));
          });
        }
      }
      util.assertNever(effect);
    }
  }
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  }
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  }
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result2 = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result2)) {
        return result2.then((result3) => {
          return {
            status: "valid",
            value: result3.status === "valid" ? result3.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  }
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  }
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  const BRAND = Symbol("zod_brand");
  class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  }
  class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a2, b) {
      return new ZodPipeline({
        in: a2,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  }
  class ZodReadonly extends ZodType {
    _parse(input) {
      const result2 = this._def.innerType._parse(input);
      if (isValid(result2)) {
        result2.value = Object.freeze(result2.value);
      }
      return result2;
    }
  }
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  const custom = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a2, _b2;
        if (!check(data)) {
          const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b2 = (_a2 = p2.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
          const p22 = typeof p2 === "string" ? { message: p2 } : p2;
          ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  const late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  const instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  const stringType = ZodString.create;
  const numberType = ZodNumber.create;
  const nanType = ZodNaN.create;
  const bigIntType = ZodBigInt.create;
  const booleanType = ZodBoolean.create;
  const dateType = ZodDate.create;
  const symbolType = ZodSymbol.create;
  const undefinedType = ZodUndefined.create;
  const nullType = ZodNull.create;
  const anyType = ZodAny.create;
  const unknownType = ZodUnknown.create;
  const neverType = ZodNever.create;
  const voidType = ZodVoid.create;
  const arrayType = ZodArray.create;
  const objectType = ZodObject.create;
  const strictObjectType = ZodObject.strictCreate;
  const unionType = ZodUnion.create;
  const discriminatedUnionType = ZodDiscriminatedUnion.create;
  const intersectionType = ZodIntersection.create;
  const tupleType = ZodTuple.create;
  const recordType = ZodRecord.create;
  const mapType = ZodMap.create;
  const setType = ZodSet.create;
  const functionType = ZodFunction.create;
  const lazyType = ZodLazy.create;
  const literalType = ZodLiteral.create;
  const enumType = ZodEnum.create;
  const nativeEnumType = ZodNativeEnum.create;
  const promiseType = ZodPromise.create;
  const effectsType = ZodEffects.create;
  const optionalType = ZodOptional.create;
  const nullableType = ZodNullable.create;
  const preprocessType = ZodEffects.createWithPreprocess;
  const pipelineType = ZodPipeline.create;
  const ostring = () => stringType().optional();
  const onumber = () => numberType().optional();
  const oboolean = () => booleanType().optional();
  const coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  const NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });
  var naclFast = { exports: {} };
  const __viteBrowserExternal = {};
  const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
  (function(module2) {
    (function(nacl) {
      var gf = function(init2) {
        var i2, r2 = new Float64Array(16);
        if (init2)
          for (i2 = 0; i2 < init2.length; i2++)
            r2[i2] = init2[i2];
        return r2;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i2, h2, l) {
        x2[i2] = h2 >> 24 & 255;
        x2[i2 + 1] = h2 >> 16 & 255;
        x2[i2 + 2] = h2 >> 8 & 255;
        x2[i2 + 3] = h2 & 255;
        x2[i2 + 4] = l >> 24 & 255;
        x2[i2 + 5] = l >> 16 & 255;
        x2[i2 + 6] = l >> 8 & 255;
        x2[i2 + 7] = l & 255;
      }
      function vn(x2, xi, y2, yi, n) {
        var i2, d = 0;
        for (i2 = 0; i2 < n; i2++)
          d |= x2[xi + i2] ^ y2[yi + i2];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 16);
      }
      function crypto_verify_32(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 32);
      }
      function core_salsa20(o, p2, k, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p2, k, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c2) {
        core_salsa20(out, inp, k, c2);
      }
      function crypto_core_hsalsa20(out, inp, k, c2) {
        core_hsalsa20(out, inp, k, c2);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c2, cpos, m2, mpos, b, n, k) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++)
          z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++)
          z2[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x2, z2, k, sigma);
          for (i2 = 0; i2 < 64; i2++)
            c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x2, z2, k, sigma);
          for (i2 = 0; i2 < b; i2++)
            c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c2, cpos, b, n, k) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++)
          z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++)
          z2[i2] = n[i2];
        while (b >= 64) {
          crypto_core_salsa20(x2, z2, k, sigma);
          for (i2 = 0; i2 < 64; i2++)
            c2[cpos + i2] = x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x2, z2, k, sigma);
          for (i2 = 0; i2 < b; i2++)
            c2[cpos + i2] = x2[i2];
        }
        return 0;
      }
      function crypto_stream(c2, cpos, d, n, k) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++)
          sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20(c2, cpos, d, sn, s2);
      }
      function crypto_stream_xor(c2, cpos, m2, mpos, d, n, k) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++)
          sn[i2] = n[i2 + 16];
        return crypto_stream_salsa20_xor(c2, cpos, m2, mpos, d, sn, s2);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m2, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c2;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c2 = 0;
          d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          d2 = c2;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c2, mask, f2, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++)
            this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c2;
          c2 = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c2 * 5;
        c2 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c2;
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c2;
        g2[0] = this.h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this.h[i2] + c2;
          c2 = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++)
          g2[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++)
          this.h[i2] = this.h[i2] & mask | g2[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f2 = this.h[0] + this.pad[0];
        this.h[0] = f2 & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f2 = (this.h[i2] + this.pad[i2] | 0) + (f2 >>> 16) | 0;
          this.h[i2] = f2 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m2, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m2, mpos, n, k) {
        var s2 = new poly1305(k);
        s2.update(m2, mpos, n);
        s2.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n, k) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m2, mpos, n, k);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c2, m2, d, n, k) {
        var i2;
        if (d < 32)
          return -1;
        crypto_stream_xor(c2, 0, m2, 0, d, n, k);
        crypto_onetimeauth(c2, 16, c2, 32, d - 32, c2);
        for (i2 = 0; i2 < 16; i2++)
          c2[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m2, c2, d, n, k) {
        var i2;
        var x2 = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x2, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c2, 16, c2, 32, d - 32, x2) !== 0)
          return -1;
        crypto_stream_xor(m2, 0, c2, 0, d, n, k);
        for (i2 = 0; i2 < 32; i2++)
          m2[i2] = 0;
        return 0;
      }
      function set25519(r2, a2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++)
          r2[i2] = a2[i2] | 0;
      }
      function car25519(o) {
        var i2, v2, c2 = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v2 = o[i2] + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          o[i2] = v2 - c2 * 65536;
        }
        o[0] += c2 - 1 + 37 * (c2 - 1);
      }
      function sel25519(p2, q, b) {
        var t, c2 = ~(b - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t = c2 & (p2[i2] ^ q[i2]);
          p2[i2] ^= t;
          q[i2] ^= t;
        }
      }
      function pack25519(o, n) {
        var i2, j, b;
        var m2 = gf(), t = gf();
        for (i2 = 0; i2 < 16; i2++)
          t[i2] = n[i2];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m2[0] = t[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m2[i2] = t[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
            m2[i2 - 1] &= 65535;
          }
          m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
          b = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t, m2, 1 - b);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o[2 * i2] = t[i2] & 255;
          o[2 * i2 + 1] = t[i2] >> 8;
        }
      }
      function neq25519(a2, b) {
        var c2 = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c2, a2);
        pack25519(d, b);
        return crypto_verify_32(c2, 0, d, 0);
      }
      function par25519(a2) {
        var d = new Uint8Array(32);
        pack25519(d, a2);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i2;
        for (i2 = 0; i2 < 16; i2++)
          o[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
        o[15] &= 32767;
      }
      function A(o, a2, b) {
        for (var i2 = 0; i2 < 16; i2++)
          o[i2] = a2[i2] + b[i2];
      }
      function Z(o, a2, b) {
        for (var i2 = 0; i2 < 16; i2++)
          o[i2] = a2[i2] - b[i2];
      }
      function M2(o, a2, b) {
        var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v2 = a2[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b2;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a2[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b2;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a2[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b2;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a2[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b2;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a2[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b2;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a2[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b2;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a2[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b2;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a2[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b2;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a2[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b2;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a2[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b2;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a2[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b2;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a2[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b2;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a2[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b2;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a2[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b2;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a2[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b2;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a2[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b2;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c2 = 1;
        v2 = t0 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t0 = v2 - c2 * 65536;
        v2 = t1 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t1 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t0 += c2 - 1 + 37 * (c2 - 1);
        c2 = 1;
        v2 = t0 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t0 = v2 - c2 * 65536;
        v2 = t1 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t1 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t0 += c2 - 1 + 37 * (c2 - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S2(o, a2) {
        M2(o, a2, a2);
      }
      function inv25519(o, i2) {
        var c2 = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++)
          c2[a2] = i2[a2];
        for (a2 = 253; a2 >= 0; a2--) {
          S2(c2, c2);
          if (a2 !== 2 && a2 !== 4)
            M2(c2, c2, i2);
        }
        for (a2 = 0; a2 < 16; a2++)
          o[a2] = c2[a2];
      }
      function pow2523(o, i2) {
        var c2 = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++)
          c2[a2] = i2[a2];
        for (a2 = 250; a2 >= 0; a2--) {
          S2(c2, c2);
          if (a2 !== 1)
            M2(c2, c2, i2);
        }
        for (a2 = 0; a2 < 16; a2++)
          o[a2] = c2[a2];
      }
      function crypto_scalarmult(q, n, p2) {
        var z2 = new Uint8Array(32);
        var x2 = new Float64Array(80), r2, i2;
        var a2 = gf(), b = gf(), c2 = gf(), d = gf(), e = gf(), f2 = gf();
        for (i2 = 0; i2 < 31; i2++)
          z2[i2] = n[i2];
        z2[31] = n[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x2, p2);
        for (i2 = 0; i2 < 16; i2++) {
          b[i2] = x2[i2];
          d[i2] = a2[i2] = c2[i2] = 0;
        }
        a2[0] = d[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r2 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a2, b, r2);
          sel25519(c2, d, r2);
          A(e, a2, c2);
          Z(a2, a2, c2);
          A(c2, b, d);
          Z(b, b, d);
          S2(d, e);
          S2(f2, a2);
          M2(a2, c2, a2);
          M2(c2, b, e);
          A(e, a2, c2);
          Z(a2, a2, c2);
          S2(b, a2);
          Z(c2, d, f2);
          M2(a2, c2, _121665);
          A(a2, a2, d);
          M2(c2, c2, a2);
          M2(a2, d, f2);
          M2(d, b, x2);
          S2(b, e);
          sel25519(a2, b, r2);
          sel25519(c2, d, r2);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x2[i2 + 16] = a2[i2];
          x2[i2 + 32] = c2[i2];
          x2[i2 + 48] = b[i2];
          x2[i2 + 64] = d[i2];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y2, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y2, x2);
      }
      function crypto_box_beforenm(k, y2, x2) {
        var s2 = new Uint8Array(32);
        crypto_scalarmult(s2, x2, y2);
        return crypto_core_hsalsa20(k, _0, s2, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c2, m2, d, n, y2, x2) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y2, x2);
        return crypto_box_afternm(c2, m2, d, n, k);
      }
      function crypto_box_open(m2, c2, d, n, y2, x2) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y2, x2);
        return crypto_box_open_afternm(m2, c2, d, n, k);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m2, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j, h2, l, a2, b, c2, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j = 8 * i2 + pos;
            wh[i2] = m2[j + 0] << 24 | m2[j + 1] << 16 | m2[j + 2] << 8 | m2[j + 3];
            wl[i2] = m2[j + 4] << 24 | m2[j + 5] << 16 | m2[j + 6] << 8 | m2[j + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l = al7;
            a2 = l & 65535;
            b = l >>> 16;
            c2 = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a2 += l & 65535;
            b += l >>> 16;
            c2 += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a2 += l & 65535;
            b += l >>> 16;
            c2 += h2 & 65535;
            d += h2 >>> 16;
            h2 = K2[i2 * 2];
            l = K2[i2 * 2 + 1];
            a2 += l & 65535;
            b += l >>> 16;
            c2 += h2 & 65535;
            d += h2 >>> 16;
            h2 = wh[i2 % 16];
            l = wl[i2 % 16];
            a2 += l & 65535;
            b += l >>> 16;
            c2 += h2 & 65535;
            d += h2 >>> 16;
            b += a2 >>> 16;
            c2 += b >>> 16;
            d += c2 >>> 16;
            th = c2 & 65535 | d << 16;
            tl = a2 & 65535 | b << 16;
            h2 = th;
            l = tl;
            a2 = l & 65535;
            b = l >>> 16;
            c2 = h2 & 65535;
            d = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a2 += l & 65535;
            b += l >>> 16;
            c2 += h2 & 65535;
            d += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a2 += l & 65535;
            b += l >>> 16;
            c2 += h2 & 65535;
            d += h2 >>> 16;
            b += a2 >>> 16;
            c2 += b >>> 16;
            d += c2 >>> 16;
            bh7 = c2 & 65535 | d << 16;
            bl7 = a2 & 65535 | b << 16;
            h2 = bh3;
            l = bl3;
            a2 = l & 65535;
            b = l >>> 16;
            c2 = h2 & 65535;
            d = h2 >>> 16;
            h2 = th;
            l = tl;
            a2 += l & 65535;
            b += l >>> 16;
            c2 += h2 & 65535;
            d += h2 >>> 16;
            b += a2 >>> 16;
            c2 += b >>> 16;
            d += c2 >>> 16;
            bh3 = c2 & 65535 | d << 16;
            bl3 = a2 & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h2 = wh[j];
                l = wl[j];
                a2 = l & 65535;
                b = l >>> 16;
                c2 = h2 & 65535;
                d = h2 >>> 16;
                h2 = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a2 += l & 65535;
                b += l >>> 16;
                c2 += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a2 += l & 65535;
                b += l >>> 16;
                c2 += h2 & 65535;
                d += h2 >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a2 += l & 65535;
                b += l >>> 16;
                c2 += h2 & 65535;
                d += h2 >>> 16;
                b += a2 >>> 16;
                c2 += b >>> 16;
                d += c2 >>> 16;
                wh[j] = c2 & 65535 | d << 16;
                wl[j] = a2 & 65535 | b << 16;
              }
            }
          }
          h2 = ah0;
          l = al0;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[0];
          l = hl[0];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[0] = ah0 = c2 & 65535 | d << 16;
          hl[0] = al0 = a2 & 65535 | b << 16;
          h2 = ah1;
          l = al1;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[1];
          l = hl[1];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[1] = ah1 = c2 & 65535 | d << 16;
          hl[1] = al1 = a2 & 65535 | b << 16;
          h2 = ah2;
          l = al2;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[2];
          l = hl[2];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[2] = ah2 = c2 & 65535 | d << 16;
          hl[2] = al2 = a2 & 65535 | b << 16;
          h2 = ah3;
          l = al3;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[3];
          l = hl[3];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[3] = ah3 = c2 & 65535 | d << 16;
          hl[3] = al3 = a2 & 65535 | b << 16;
          h2 = ah4;
          l = al4;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[4];
          l = hl[4];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[4] = ah4 = c2 & 65535 | d << 16;
          hl[4] = al4 = a2 & 65535 | b << 16;
          h2 = ah5;
          l = al5;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[5];
          l = hl[5];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[5] = ah5 = c2 & 65535 | d << 16;
          hl[5] = al5 = a2 & 65535 | b << 16;
          h2 = ah6;
          l = al6;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[6];
          l = hl[6];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[6] = ah6 = c2 & 65535 | d << 16;
          hl[6] = al6 = a2 & 65535 | b << 16;
          h2 = ah7;
          l = al7;
          a2 = l & 65535;
          b = l >>> 16;
          c2 = h2 & 65535;
          d = h2 >>> 16;
          h2 = hh[7];
          l = hl[7];
          a2 += l & 65535;
          b += l >>> 16;
          c2 += h2 & 65535;
          d += h2 >>> 16;
          b += a2 >>> 16;
          c2 += b >>> 16;
          d += c2 >>> 16;
          hh[7] = ah7 = c2 & 65535 | d << 16;
          hl[7] = al7 = a2 & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m2, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i2, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m2, n);
        n %= 128;
        for (i2 = 0; i2 < n; i2++)
          x2[i2] = m2[b - n + i2];
        x2[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x2[n - 9] = 0;
        ts64(x2, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x2, n);
        for (i2 = 0; i2 < 8; i2++)
          ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p2, q) {
        var a2 = gf(), b = gf(), c2 = gf(), d = gf(), e = gf(), f2 = gf(), g2 = gf(), h2 = gf(), t = gf();
        Z(a2, p2[1], p2[0]);
        Z(t, q[1], q[0]);
        M2(a2, a2, t);
        A(b, p2[0], p2[1]);
        A(t, q[0], q[1]);
        M2(b, b, t);
        M2(c2, p2[3], q[3]);
        M2(c2, c2, D2);
        M2(d, p2[2], q[2]);
        A(d, d, d);
        Z(e, b, a2);
        Z(f2, d, c2);
        A(g2, d, c2);
        A(h2, b, a2);
        M2(p2[0], e, f2);
        M2(p2[1], h2, g2);
        M2(p2[2], g2, f2);
        M2(p2[3], e, h2);
      }
      function cswap(p2, q, b) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p2[i2], q[i2], b);
        }
      }
      function pack(r2, p2) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p2[2]);
        M2(tx, p2[0], zi);
        M2(ty, p2[1], zi);
        pack25519(r2, ty);
        r2[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p2, q, s2) {
        var b, i2;
        set25519(p2[0], gf0);
        set25519(p2[1], gf1);
        set25519(p2[2], gf1);
        set25519(p2[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p2, q, b);
          add(q, p2);
          add(p2, p2);
          cswap(p2, q, b);
        }
      }
      function scalarbase(p2, s2) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M2(q[3], X, Y);
        scalarmult(p2, q, s2);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p2, d);
        pack(pk, p2);
        for (i2 = 0; i2 < 32; i2++)
          sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r2, x2) {
        var carry, i2, j, k;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j = i2 - 32, k = i2 - 12; j < k; ++j) {
            x2[j] += carry - 16 * x2[i2] * L2[j - (i2 - 32)];
            carry = Math.floor((x2[j] + 128) / 256);
            x2[j] -= carry * 256;
          }
          x2[j] += carry;
          x2[i2] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x2[j] += carry - (x2[31] >> 4) * L2[j];
          carry = x2[j] >> 8;
          x2[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x2[j] -= carry * L2[j];
        for (i2 = 0; i2 < 32; i2++) {
          x2[i2 + 1] += x2[i2] >> 8;
          r2[i2] = x2[i2] & 255;
        }
      }
      function reduce(r2) {
        var x2 = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++)
          x2[i2] = r2[i2];
        for (i2 = 0; i2 < 64; i2++)
          r2[i2] = 0;
        modL(r2, x2);
      }
      function crypto_sign(sm, m2, n, sk) {
        var d = new Uint8Array(64), h2 = new Uint8Array(64), r2 = new Uint8Array(64);
        var i2, j, x2 = new Float64Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i2 = 0; i2 < n; i2++)
          sm[64 + i2] = m2[i2];
        for (i2 = 0; i2 < 32; i2++)
          sm[32 + i2] = d[32 + i2];
        crypto_hash(r2, sm.subarray(32), n + 32);
        reduce(r2);
        scalarbase(p2, r2);
        pack(sm, p2);
        for (i2 = 32; i2 < 64; i2++)
          sm[i2] = sk[i2];
        crypto_hash(h2, sm, n + 64);
        reduce(h2);
        for (i2 = 0; i2 < 64; i2++)
          x2[i2] = 0;
        for (i2 = 0; i2 < 32; i2++)
          x2[i2] = r2[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j = 0; j < 32; j++) {
            x2[i2 + j] += h2[i2] * d[j];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r2, p2) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r2[2], gf1);
        unpack25519(r2[1], p2);
        S2(num, r2[1]);
        M2(den, num, D);
        Z(num, num, r2[2]);
        A(den, r2[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r2[0], t, den);
        S2(chk, r2[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num))
          M2(r2[0], r2[0], I);
        S2(chk, r2[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r2[0]) === p2[31] >> 7)
          Z(r2[0], gf0, r2[0]);
        M2(r2[3], r2[0], r2[1]);
        return 0;
      }
      function crypto_sign_open(m2, sm, n, pk) {
        var i2;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i2 = 0; i2 < n; i2++)
          m2[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++)
          m2[i2 + 32] = pk[i2];
        crypto_hash(h2, m2, n);
        reduce(h2);
        scalarmult(p2, q, h2);
        scalarbase(q, sm.subarray(32));
        add(p2, q);
        pack(t, p2);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i2 = 0; i2 < n; i2++)
            m2[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n; i2++)
          m2[i2] = sm[i2 + 64];
        return n;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D,
        L: L2,
        pack25519,
        unpack25519,
        M: M2,
        A,
        S: S2,
        Z,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++)
          arr[i2] = 0;
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c2 = new Uint8Array(m2.length);
        for (var i2 = 0; i2 < msg.length; i2++)
          m2[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c2, m2, m2.length, nonce, key);
        return c2.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m2 = new Uint8Array(c2.length);
        for (var i2 = 0; i2 < box.length; i2++)
          c2[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c2.length < 32)
          return null;
        if (crypto_secretbox_open(m2, c2, c2.length, nonce, key) !== 0)
          return null;
        return m2.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p2) {
        checkArrayTypes(n, p2);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p2.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p2);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m2 = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m2.length; i2++)
          m2[i2] = tmp[i2];
        return m2;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++)
          sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++)
          sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++)
          sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++)
          pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++)
          sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x2, y2) {
        checkArrayTypes(x2, y2);
        if (x2.length === 0 || y2.length === 0)
          return false;
        if (x2.length !== y2.length)
          return false;
        return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x2, n) {
            var i2, v2 = new Uint8Array(n);
            for (i2 = 0; i2 < n; i2 += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n; i2++)
              x2[i2] = v2[i2];
            cleanup(v2);
          });
        } else if (typeof commonjsRequire !== "undefined") {
          crypto2 = require$$0$1;
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x2, n) {
              var i2, v2 = crypto2.randomBytes(n);
              for (i2 = 0; i2 < n; i2++)
                x2[i2] = v2[i2];
              cleanup(v2);
            });
          }
        }
      })();
    })(module2.exports ? module2.exports : self.nacl = self.nacl || {});
  })(naclFast);
  var naclFastExports = naclFast.exports;
  const SALT_SYMMETRIC = "salt-key-symmetric-";
  const SALT_SIGNING = "salt-key-signing-";
  const SALT_ENCRYPTION = "salt-key-encryption-";
  const SALT_SHARED = "salt-shared-";
  const SALT_SIG_SIGNING = "salt-sig-signing-";
  const SALT_SIG_ENCRYPTION = "salt-sig-encryption-";
  const SALT_SIG_HASH = "salt-sig-hash-";
  var naclUtil = { exports: {} };
  (function(module2) {
    (function(root, f2) {
      if (module2.exports)
        module2.exports = f2();
      else if (root.nacl)
        root.nacl.util = f2();
      else {
        root.nacl = {};
        root.nacl.util = f2();
      }
    })(commonjsGlobal, function() {
      var util2 = {};
      function validateBase64(s2) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s2)) {
          throw new TypeError("invalid encoding");
        }
      }
      util2.decodeUTF8 = function(s2) {
        if (typeof s2 !== "string")
          throw new TypeError("expected string");
        var i2, d = unescape(encodeURIComponent(s2)), b = new Uint8Array(d.length);
        for (i2 = 0; i2 < d.length; i2++)
          b[i2] = d.charCodeAt(i2);
        return b;
      };
      util2.encodeUTF8 = function(arr) {
        var i2, s2 = [];
        for (i2 = 0; i2 < arr.length; i2++)
          s2.push(String.fromCharCode(arr[i2]));
        return decodeURIComponent(escape(s2.join("")));
      };
      if (typeof atob === "undefined") {
        if (typeof Buffer.from !== "undefined") {
          util2.encodeBase64 = function(arr) {
            return Buffer.from(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(Buffer.from(s2, "base64"), 0));
          };
        } else {
          util2.encodeBase64 = function(arr) {
            return new Buffer(arr).toString("base64");
          };
          util2.decodeBase64 = function(s2) {
            validateBase64(s2);
            return new Uint8Array(Array.prototype.slice.call(new Buffer(s2, "base64"), 0));
          };
        }
      } else {
        util2.encodeBase64 = function(arr) {
          var i2, s2 = [], len = arr.length;
          for (i2 = 0; i2 < len; i2++)
            s2.push(String.fromCharCode(arr[i2]));
          return btoa(s2.join(""));
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          var i2, d = atob(s2), b = new Uint8Array(d.length);
          for (i2 = 0; i2 < d.length; i2++)
            b[i2] = d.charCodeAt(i2);
          return b;
        };
      }
      return util2;
    });
  })(naclUtil);
  var naclUtilExports = naclUtil.exports;
  var LvcErrorCode;
  (function(LvcErrorCode2) {
    LvcErrorCode2[LvcErrorCode2["Undefined"] = 0] = "Undefined";
    LvcErrorCode2[LvcErrorCode2["CouldNotDecrypt"] = 3000500] = "CouldNotDecrypt";
    LvcErrorCode2[LvcErrorCode2["InvalidLength"] = 3000400] = "InvalidLength";
    LvcErrorCode2[LvcErrorCode2["LoadingFromUnknownType"] = 3000401] = "LoadingFromUnknownType";
    LvcErrorCode2[LvcErrorCode2["InvalidSeedLength"] = 3000410] = "InvalidSeedLength";
    LvcErrorCode2[LvcErrorCode2["InvalidSecondarySeedLength"] = 3000411] = "InvalidSecondarySeedLength";
    LvcErrorCode2[LvcErrorCode2["InvalidSaltLength"] = 3000412] = "InvalidSaltLength";
    LvcErrorCode2[LvcErrorCode2["InvalidSecretLength"] = 3000413] = "InvalidSecretLength";
    LvcErrorCode2[LvcErrorCode2["InvalidTotpSecret"] = 3000414] = "InvalidTotpSecret";
    LvcErrorCode2[LvcErrorCode2["UnknownTotpAlgorithmError"] = 3000415] = "UnknownTotpAlgorithmError";
  })(LvcErrorCode || (LvcErrorCode = {}));
  const pleaseUpdate$2 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  class LvcDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$2);
    }
  }
  class CouldNotDecryptError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.CouldNotDecrypt, "could not decrypt message", "Could not decrypt", "The client tried to decrypt data using the wrong key.");
    }
  }
  class InvalidLengthError extends LvcDomainError {
    constructor(got, want) {
      super(LvcErrorCode.InvalidLength, `Found data of length ${got}, expected ${want}.`);
    }
  }
  class LoadingFromUnknownTypeError extends LvcDomainError {
    constructor(type) {
      super(LvcErrorCode.LoadingFromUnknownType, `Loading failed from unknown type ${type}}`);
    }
  }
  class InvalidSeedLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSeedLength, "Seed for derived key must be 32 bytes in length!");
    }
  }
  class InvalidSecondarySeedLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSecondarySeedLength, "Secondary seed for derived key must be 32 bytes in length!");
    }
  }
  class InvalidSaltLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSaltLength, "Salt for a derived key must be at least 8 bytes in length!");
    }
  }
  class InvalidSecretLengthError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidSecretLength, "Length of derived secret must be 32 or 64 bytes!");
    }
  }
  class InvalidTotpSecretError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.InvalidTotpSecret, "TOTP secret could not be decoded.");
    }
  }
  class UnknownTotpAlgorithmError extends LvcDomainError {
    constructor() {
      super(LvcErrorCode.UnknownTotpAlgorithmError, "TOTP algorithm unknown.", "Unknown TOTP algorithm", "Your client does not support the requested algorithm. Make sure you are using the latest version of our software then try again");
    }
  }
  function loadArrayOrBase64(data, expectedLength) {
    if (expectedLength !== void 0) {
      const array = loadArrayOrBase64(data);
      if (array.length !== expectedLength) {
        throw new InvalidLengthError(array.length, expectedLength);
      }
      return array;
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    if (typeof data === "string") {
      return naclUtilExports.decodeBase64(data);
    }
    if (data.constructor.name === "ArrayBuffer" || data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    }
    throw new LoadingFromUnknownTypeError(typeof data);
  }
  function concatArrays(...inputs) {
    const totalLength = inputs.map((a2) => a2.length).reduce((a2, b) => a2 + b, 0);
    const result2 = new Uint8Array(totalLength);
    let offset = 0;
    for (const input of inputs) {
      result2.set(input, offset);
      offset += input.length;
    }
    return result2;
  }
  function deriveSecretFromSeed(seed, secondarySeed, salt, length = 32) {
    if (seed.length !== 32) {
      throw new InvalidSeedLengthError();
    }
    if (secondarySeed !== null && secondarySeed.length !== 32) {
      throw new InvalidSecondarySeedLengthError();
    }
    if (salt.length < 8) {
      throw new InvalidSaltLengthError();
    }
    if (length !== 32 && length !== 64) {
      throw new InvalidSecretLengthError();
    }
    let hashedSeed;
    if (secondarySeed === null) {
      hashedSeed = naclFastExports.hash(seed);
    } else {
      hashedSeed = naclFastExports.hash(concatArrays(seed, secondarySeed));
    }
    const hashedData = naclFastExports.hash(concatArrays(naclUtilExports.decodeUTF8(salt), hashedSeed));
    return hashedData.slice(0, length);
  }
  function randomSeed() {
    return naclFastExports.randomBytes(32);
  }
  function loadSymEncryptedBlob(data) {
    return loadArrayOrBase64(data);
  }
  function loadSymEncryptionKey(data) {
    return loadArrayOrBase64(data, naclFastExports.secretbox.keyLength);
  }
  function deriveSymEncryptionKey(seed, secondarySeed, salt) {
    return loadSymEncryptionKey(deriveSecretFromSeed(seed, secondarySeed, SALT_SYMMETRIC + salt, naclFastExports.secretbox.keyLength));
  }
  function newSymmetricSecret() {
    return naclFastExports.randomBytes(naclFastExports.secretbox.keyLength);
  }
  function symEncrypt(symKey, data) {
    const nonce = naclFastExports.randomBytes(naclFastExports.secretbox.nonceLength);
    const box = naclFastExports.secretbox(data, nonce, symKey);
    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);
    return loadSymEncryptedBlob(fullMessage);
  }
  function symDecrypt(symKey, data) {
    const messageWithNonceAsUint8Array = data;
    const nonce = messageWithNonceAsUint8Array.slice(0, naclFastExports.secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(naclFastExports.secretbox.nonceLength, messageWithNonceAsUint8Array.length);
    const decrypted = naclFastExports.secretbox.open(message, nonce, symKey);
    if (!decrypted) {
      throw new CouldNotDecryptError();
    }
    return decrypted;
  }
  function symKeyToSas(symEncryptionKey) {
    const keyHash = naclFastExports.hash(symEncryptionKey);
    return keyHash.slice(0, 4).reduce((sas, value) => sas.concat((value % 10).toString()), "");
  }
  function loadSharedSecretPrivKey(data) {
    return loadArrayOrBase64(data, naclFastExports.scalarMult.scalarLength);
  }
  function loadSharedSecretPubKey(data) {
    return loadArrayOrBase64(data, naclFastExports.scalarMult.groupElementLength);
  }
  function newSharedSecretKeyPair() {
    const scalar = naclFastExports.randomBytes(naclFastExports.scalarMult.scalarLength);
    const sharedPrivKey = loadSharedSecretPrivKey(scalar);
    const sharedPubKey = loadSharedSecretPubKey(naclFastExports.scalarMult.base(sharedPrivKey));
    return { sharedPubKey, sharedPrivKey };
  }
  function combineSharedSecret(sharedPrivKey, sharedPubKey, salt) {
    const keyData = naclFastExports.scalarMult(sharedPrivKey, sharedPubKey);
    return deriveSymEncryptionKey(keyData, null, SALT_SHARED + salt);
  }
  function loadEncryptionPublicKey(data) {
    return loadArrayOrBase64(data, naclFastExports.box.publicKeyLength);
  }
  function loadEncryptionPrivateKey(data) {
    return loadArrayOrBase64(data, naclFastExports.box.secretKeyLength);
  }
  function loadAsymEncryptedBlob(data) {
    return loadArrayOrBase64(data);
  }
  function loadAsymEncryptedEncryptionPrivateKey(data) {
    return loadArrayOrBase64(data);
  }
  function deriveEncryptionKeyPair(seed, secondarySeed, salt) {
    const keyPair = naclFastExports.box.keyPair.fromSecretKey(deriveSecretFromSeed(seed, secondarySeed, SALT_ENCRYPTION + salt, naclFastExports.box.secretKeyLength));
    const encPrivKey = loadEncryptionPrivateKey(keyPair.secretKey);
    const encPubKey = loadEncryptionPublicKey(keyPair.publicKey);
    return { encPrivKey, encPubKey };
  }
  function newEncryptionKeyPair() {
    const keyPair = naclFastExports.box.keyPair();
    const encPrivKey = loadEncryptionPrivateKey(keyPair.secretKey);
    const encPubKey = loadEncryptionPublicKey(keyPair.publicKey);
    return { encPrivKey, encPubKey };
  }
  function asymEncrypt(encPubKey, data) {
    const ephemeralKeyPair = naclFastExports.box.keyPair();
    const nonce = naclFastExports.randomBytes(naclFastExports.box.nonceLength);
    const encryptedMessage = naclFastExports.box(data, nonce, encPubKey, ephemeralKeyPair.secretKey);
    const fullMessage = new Uint8Array(nonce.length + ephemeralKeyPair.publicKey.length + encryptedMessage.length);
    fullMessage.set(nonce);
    fullMessage.set(ephemeralKeyPair.publicKey, nonce.length);
    fullMessage.set(encryptedMessage, nonce.length + ephemeralKeyPair.publicKey.length);
    return loadAsymEncryptedBlob(fullMessage);
  }
  function asymDecrypt(encPrivKey, encryptedBlob) {
    const nonce = encryptedBlob.slice(0, naclFastExports.box.nonceLength);
    const publicKey = encryptedBlob.slice(naclFastExports.box.nonceLength, naclFastExports.box.nonceLength + naclFastExports.box.publicKeyLength);
    const message = encryptedBlob.slice(naclFastExports.box.nonceLength + naclFastExports.box.publicKeyLength, encryptedBlob.length);
    const decryptedMessage = naclFastExports.box.open(message, nonce, publicKey, encPrivKey);
    if (!decryptedMessage) {
      throw new CouldNotDecryptError();
    }
    return decryptedMessage;
  }
  function loadSigningPublicKey(data) {
    return loadArrayOrBase64(data, naclFastExports.sign.publicKeyLength);
  }
  function loadSigningPrivateKey(data) {
    return loadArrayOrBase64(data, naclFastExports.sign.secretKeyLength);
  }
  function loadSignature(data) {
    return loadArrayOrBase64(data, naclFastExports.sign.signatureLength);
  }
  function deriveSigningKeyPair(seed, secondarySeed, salt) {
    const keyPair = naclFastExports.sign.keyPair.fromSeed(deriveSecretFromSeed(seed, secondarySeed, SALT_SIGNING + salt, naclFastExports.sign.seedLength));
    const sigPrivKey = loadSigningPrivateKey(keyPair.secretKey);
    const sigPubKey = loadSigningPublicKey(keyPair.publicKey);
    return { sigPrivKey, sigPubKey };
  }
  function sign(sigPrivKey, data, salt) {
    const signedData = salt ? concatArrays(naclUtilExports.decodeUTF8(salt), data) : data;
    const signature = naclFastExports.sign.detached(signedData, sigPrivKey);
    return loadSignature(signature);
  }
  function verifySignature(sigPubKey, signature, data, salt) {
    const signedData = salt ? concatArrays(naclUtilExports.decodeUTF8(salt), data) : data;
    return naclFastExports.sign.detached.verify(signedData, signature, sigPubKey);
  }
  function signString(key, data, salt) {
    return sign(key, naclUtilExports.decodeUTF8(data), salt);
  }
  function signingPublicKeyEqual(sigPubKey1, sigPubKey2) {
    return naclFastExports.verify(sigPubKey1, sigPubKey2);
  }
  const HASH_LENGTH = 32;
  function loadHash(data) {
    return loadArrayOrBase64(data, HASH_LENGTH);
  }
  function hashData(blob) {
    return loadHash(naclFastExports.hash(blob).slice(0, HASH_LENGTH));
  }
  function hashEqual(hash1, hash2) {
    return naclFastExports.verify(hash1, hash2);
  }
  function verifyHash(hash2, blob) {
    return hashEqual(hash2, hashData(blob));
  }
  function loadEncryptionPublicKeySignature(data) {
    return loadSignature(data);
  }
  function loadSigningPublicKeySignature(data) {
    return loadSignature(data);
  }
  function loadAsymEncryptedSymmetricKey(data) {
    return loadAsymEncryptedBlob(data);
  }
  function symEncryptSymmetricEncryptionKey(symKey, symKeyToEncrypt) {
    const symKeyEncrypted = symEncrypt(symKey, symKeyToEncrypt);
    return symKeyEncrypted;
  }
  function asymCreateKek(asymKey, symKey) {
    const asymEncryptedBlob = asymEncrypt(asymKey, symKey);
    return loadAsymEncryptedSymmetricKey(asymEncryptedBlob);
  }
  function asymDecryptKek(asymKey, kek) {
    const symKey = asymDecrypt(asymKey, kek);
    return loadSymEncryptionKey(symKey);
  }
  function asymEncryptEncryptionPrivateKey(encryptionKey, payloadKey) {
    const asymEncryptedBlob = asymEncrypt(encryptionKey, payloadKey);
    return loadAsymEncryptedEncryptionPrivateKey(asymEncryptedBlob);
  }
  function asymDecryptEncryptionPrivateKey(decryptionKey, encryptedKey) {
    const decryptedKey = asymDecrypt(decryptionKey, encryptedKey);
    return loadEncryptionPrivateKey(decryptedKey);
  }
  function signEncryptionPublicKey(sigPrivKey, encPubKey, salt) {
    const encPubKeySignature = sign(sigPrivKey, encPubKey, SALT_SIG_ENCRYPTION + salt);
    return encPubKeySignature;
  }
  function verifySignedEncryptionPublicKey(verifyingKey, encPubKey, encPubKeySignature, salt) {
    return verifySignature(verifyingKey, encPubKeySignature, encPubKey, SALT_SIG_ENCRYPTION + salt);
  }
  function signSigningPublicKey(sigPrivKey, sigPubKey, salt) {
    const sigPubKeySignature = sign(sigPrivKey, sigPubKey, SALT_SIG_SIGNING + salt);
    return sigPubKeySignature;
  }
  function verifySignedSigningPublicKey(verifyingSigPubKey, sigPubKey, sigPubKeySignature, salt) {
    return verifySignature(verifyingSigPubKey, sigPubKeySignature, sigPubKey, SALT_SIG_SIGNING + salt);
  }
  function signHash(signKey, hash2) {
    const hashSig = sign(signKey, hash2, SALT_SIG_HASH);
    return hashSig;
  }
  function hashAndSign(signKey, data) {
    const hash2 = hashData(data);
    return signHash(signKey, hash2);
  }
  function verifyHashSignature(verifyingKey, signature, hash2) {
    return verifySignature(verifyingKey, signature, hash2, SALT_SIG_HASH);
  }
  var hash$2 = {};
  var utils$9 = {};
  var minimalisticAssert = assert$5;
  function assert$5(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert$5.equal = function assertEqual(l, r2, msg) {
    if (l != r2)
      throw new Error(msg || "Assertion failed: " + l + " != " + r2);
  };
  var inherits_browser = { exports: {} };
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  var inherits_browserExports = inherits_browser.exports;
  var assert$4 = minimalisticAssert;
  var inherits = inherits_browserExports;
  utils$9.inherits = inherits;
  function isSurrogatePair(msg, i2) {
    if ((msg.charCodeAt(i2) & 64512) !== 55296) {
      return false;
    }
    if (i2 < 0 || i2 + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p2 = 0;
        for (var i2 = 0; i2 < msg.length; i2++) {
          var c2 = msg.charCodeAt(i2);
          if (c2 < 128) {
            res[p2++] = c2;
          } else if (c2 < 2048) {
            res[p2++] = c2 >> 6 | 192;
            res[p2++] = c2 & 63 | 128;
          } else if (isSurrogatePair(msg, i2)) {
            c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
            res[p2++] = c2 >> 18 | 240;
            res[p2++] = c2 >> 12 & 63 | 128;
            res[p2++] = c2 >> 6 & 63 | 128;
            res[p2++] = c2 & 63 | 128;
          } else {
            res[p2++] = c2 >> 12 | 224;
            res[p2++] = c2 >> 6 & 63 | 128;
            res[p2++] = c2 & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i2 = 0; i2 < msg.length; i2 += 2)
          res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
      }
    } else {
      for (i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
    }
    return res;
  }
  utils$9.toArray = toArray;
  function toHex(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero2(msg[i2].toString(16));
    return res;
  }
  utils$9.toHex = toHex;
  function htonl(w2) {
    var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
    return res >>> 0;
  }
  utils$9.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++) {
      var w2 = msg[i2];
      if (endian === "little")
        w2 = htonl(w2);
      res += zero8(w2.toString(16));
    }
    return res;
  }
  utils$9.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils$9.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  utils$9.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert$4(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i2 = 0, k = start; i2 < res.length; i2++, k += 4) {
      var w2;
      if (endian === "big")
        w2 = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
      else
        w2 = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i2] = w2 >>> 0;
    }
    return res;
  }
  utils$9.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i2 = 0, k = 0; i2 < msg.length; i2++, k += 4) {
      var m2 = msg[i2];
      if (endian === "big") {
        res[k] = m2 >>> 24;
        res[k + 1] = m2 >>> 16 & 255;
        res[k + 2] = m2 >>> 8 & 255;
        res[k + 3] = m2 & 255;
      } else {
        res[k + 3] = m2 >>> 24;
        res[k + 2] = m2 >>> 16 & 255;
        res[k + 1] = m2 >>> 8 & 255;
        res[k] = m2 & 255;
      }
    }
    return res;
  }
  utils$9.split32 = split32;
  function rotr32$1(w2, b) {
    return w2 >>> b | w2 << 32 - b;
  }
  utils$9.rotr32 = rotr32$1;
  function rotl32$2(w2, b) {
    return w2 << b | w2 >>> 32 - b;
  }
  utils$9.rotl32 = rotl32$2;
  function sum32$3(a2, b) {
    return a2 + b >>> 0;
  }
  utils$9.sum32 = sum32$3;
  function sum32_3$1(a2, b, c2) {
    return a2 + b + c2 >>> 0;
  }
  utils$9.sum32_3 = sum32_3$1;
  function sum32_4$2(a2, b, c2, d) {
    return a2 + b + c2 + d >>> 0;
  }
  utils$9.sum32_4 = sum32_4$2;
  function sum32_5$2(a2, b, c2, d, e) {
    return a2 + b + c2 + d + e >>> 0;
  }
  utils$9.sum32_5 = sum32_5$2;
  function sum64$1(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils$9.sum64 = sum64$1;
  function sum64_hi$1(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils$9.sum64_hi = sum64_hi$1;
  function sum64_lo$1(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils$9.sum64_lo = sum64_lo$1;
  function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  utils$9.sum64_4_hi = sum64_4_hi$1;
  function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils$9.sum64_4_lo = sum64_4_lo$1;
  function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  utils$9.sum64_5_hi = sum64_5_hi$1;
  function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  utils$9.sum64_5_lo = sum64_5_lo$1;
  function rotr64_hi$1(ah, al, num) {
    var r2 = al << 32 - num | ah >>> num;
    return r2 >>> 0;
  }
  utils$9.rotr64_hi = rotr64_hi$1;
  function rotr64_lo$1(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils$9.rotr64_lo = rotr64_lo$1;
  function shr64_hi$1(ah, al, num) {
    return ah >>> num;
  }
  utils$9.shr64_hi = shr64_hi$1;
  function shr64_lo$1(ah, al, num) {
    var r2 = ah << 32 - num | al >>> num;
    return r2 >>> 0;
  }
  utils$9.shr64_lo = shr64_lo$1;
  var common$5 = {};
  var utils$8 = utils$9;
  var assert$3 = minimalisticAssert;
  function BlockHash$4() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$5.BlockHash = BlockHash$4;
  BlockHash$4.prototype.update = function update(msg, enc) {
    msg = utils$8.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r2 = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r2, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils$8.join32(msg, 0, msg.length - r2, this.endian);
      for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
        this._update(msg, i2, i2 + this._delta32);
    }
    return this;
  };
  BlockHash$4.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert$3(this.pending === null);
    return this._digest(enc);
  };
  BlockHash$4.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 128;
    for (var i2 = 1; i2 < k; i2++)
      res[i2] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t = 8; t < this.padLength; t++)
        res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = len >>> 24 & 255;
      res[i2++] = len >>> 16 & 255;
      res[i2++] = len >>> 8 & 255;
      res[i2++] = len & 255;
    } else {
      res[i2++] = len & 255;
      res[i2++] = len >>> 8 & 255;
      res[i2++] = len >>> 16 & 255;
      res[i2++] = len >>> 24 & 255;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      res[i2++] = 0;
      for (t = 8; t < this.padLength; t++)
        res[i2++] = 0;
    }
    return res;
  };
  var sha = {};
  var common$4 = {};
  var utils$7 = utils$9;
  var rotr32 = utils$7.rotr32;
  function ft_1$1(s2, x2, y2, z2) {
    if (s2 === 0)
      return ch32$1(x2, y2, z2);
    if (s2 === 1 || s2 === 3)
      return p32(x2, y2, z2);
    if (s2 === 2)
      return maj32$1(x2, y2, z2);
  }
  common$4.ft_1 = ft_1$1;
  function ch32$1(x2, y2, z2) {
    return x2 & y2 ^ ~x2 & z2;
  }
  common$4.ch32 = ch32$1;
  function maj32$1(x2, y2, z2) {
    return x2 & y2 ^ x2 & z2 ^ y2 & z2;
  }
  common$4.maj32 = maj32$1;
  function p32(x2, y2, z2) {
    return x2 ^ y2 ^ z2;
  }
  common$4.p32 = p32;
  function s0_256$1(x2) {
    return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
  }
  common$4.s0_256 = s0_256$1;
  function s1_256$1(x2) {
    return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
  }
  common$4.s1_256 = s1_256$1;
  function g0_256$1(x2) {
    return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
  }
  common$4.g0_256 = g0_256$1;
  function g1_256$1(x2) {
    return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
  }
  common$4.g1_256 = g1_256$1;
  var utils$6 = utils$9;
  var common$3 = common$5;
  var shaCommon$1 = common$4;
  var rotl32$1 = utils$6.rotl32;
  var sum32$2 = utils$6.sum32;
  var sum32_5$1 = utils$6.sum32_5;
  var ft_1 = shaCommon$1.ft_1;
  var BlockHash$3 = common$3.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash$3.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils$6.inherits(SHA1, BlockHash$3);
  var _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2++)
      W[i2] = rotl32$1(W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16], 1);
    var a2 = this.h[0];
    var b = this.h[1];
    var c2 = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i2 = 0; i2 < W.length; i2++) {
      var s2 = ~~(i2 / 20);
      var t = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b, c2, d), e, W[i2], sha1_K[s2]);
      e = d;
      d = c2;
      c2 = rotl32$1(b, 30);
      b = a2;
      a2 = t;
    }
    this.h[0] = sum32$2(this.h[0], a2);
    this.h[1] = sum32$2(this.h[1], b);
    this.h[2] = sum32$2(this.h[2], c2);
    this.h[3] = sum32$2(this.h[3], d);
    this.h[4] = sum32$2(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$6.toHex32(this.h, "big");
    else
      return utils$6.split32(this.h, "big");
  };
  var utils$5 = utils$9;
  var common$2 = common$5;
  var shaCommon = common$4;
  var assert$2 = minimalisticAssert;
  var sum32$1 = utils$5.sum32;
  var sum32_4$1 = utils$5.sum32_4;
  var sum32_5 = utils$5.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash$2 = common$2.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA256$1() {
    if (!(this instanceof SHA256$1))
      return new SHA256$1();
    BlockHash$2.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils$5.inherits(SHA256$1, BlockHash$2);
  var _256 = SHA256$1;
  SHA256$1.blockSize = 512;
  SHA256$1.outSize = 256;
  SHA256$1.hmacStrength = 192;
  SHA256$1.padLength = 64;
  SHA256$1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 16; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2++)
      W[i2] = sum32_4$1(g1_256(W[i2 - 2]), W[i2 - 7], g0_256(W[i2 - 15]), W[i2 - 16]);
    var a2 = this.h[0];
    var b = this.h[1];
    var c2 = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f2 = this.h[5];
    var g2 = this.h[6];
    var h2 = this.h[7];
    assert$2(this.k.length === W.length);
    for (i2 = 0; i2 < W.length; i2++) {
      var T1 = sum32_5(h2, s1_256(e), ch32(e, f2, g2), this.k[i2], W[i2]);
      var T2 = sum32$1(s0_256(a2), maj32(a2, b, c2));
      h2 = g2;
      g2 = f2;
      f2 = e;
      e = sum32$1(d, T1);
      d = c2;
      c2 = b;
      b = a2;
      a2 = sum32$1(T1, T2);
    }
    this.h[0] = sum32$1(this.h[0], a2);
    this.h[1] = sum32$1(this.h[1], b);
    this.h[2] = sum32$1(this.h[2], c2);
    this.h[3] = sum32$1(this.h[3], d);
    this.h[4] = sum32$1(this.h[4], e);
    this.h[5] = sum32$1(this.h[5], f2);
    this.h[6] = sum32$1(this.h[6], g2);
    this.h[7] = sum32$1(this.h[7], h2);
  };
  SHA256$1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$5.toHex32(this.h, "big");
    else
      return utils$5.split32(this.h, "big");
  };
  var utils$4 = utils$9;
  var SHA256 = _256;
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils$4.inherits(SHA224, SHA256);
  var _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$4.toHex32(this.h.slice(0, 7), "big");
    else
      return utils$4.split32(this.h.slice(0, 7), "big");
  };
  var utils$3 = utils$9;
  var common$1 = common$5;
  var assert$1 = minimalisticAssert;
  var rotr64_hi = utils$3.rotr64_hi;
  var rotr64_lo = utils$3.rotr64_lo;
  var shr64_hi = utils$3.shr64_hi;
  var shr64_lo = utils$3.shr64_lo;
  var sum64 = utils$3.sum64;
  var sum64_hi = utils$3.sum64_hi;
  var sum64_lo = utils$3.sum64_lo;
  var sum64_4_hi = utils$3.sum64_4_hi;
  var sum64_4_lo = utils$3.sum64_4_lo;
  var sum64_5_hi = utils$3.sum64_5_hi;
  var sum64_5_lo = utils$3.sum64_5_lo;
  var BlockHash$1 = common$1.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA512$1() {
    if (!(this instanceof SHA512$1))
      return new SHA512$1();
    BlockHash$1.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils$3.inherits(SHA512$1, BlockHash$1);
  var _512 = SHA512$1;
  SHA512$1.blockSize = 1024;
  SHA512$1.outSize = 512;
  SHA512$1.hmacStrength = 192;
  SHA512$1.padLength = 128;
  SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i2 = 0; i2 < 32; i2++)
      W[i2] = msg[start + i2];
    for (; i2 < W.length; i2 += 2) {
      var c0_hi = g1_512_hi(W[i2 - 4], W[i2 - 3]);
      var c0_lo = g1_512_lo(W[i2 - 4], W[i2 - 3]);
      var c1_hi = W[i2 - 14];
      var c1_lo = W[i2 - 13];
      var c2_hi = g0_512_hi(W[i2 - 30], W[i2 - 29]);
      var c2_lo = g0_512_lo(W[i2 - 30], W[i2 - 29]);
      var c3_hi = W[i2 - 32];
      var c3_lo = W[i2 - 31];
      W[i2] = sum64_4_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
      W[i2 + 1] = sum64_4_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo
      );
    }
  };
  SHA512$1.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert$1(this.k.length === W.length);
    for (var i2 = 0; i2 < W.length; i2 += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i2];
      var c3_lo = this.k[i2 + 1];
      var c4_hi = W[i2];
      var c4_lo = W[i2 + 1];
      var T1_hi = sum64_5_hi(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      var T1_lo = sum64_5_lo(
        c0_hi,
        c0_lo,
        c1_hi,
        c1_lo,
        c2_hi,
        c2_lo,
        c3_hi,
        c3_lo,
        c4_hi,
        c4_lo
      );
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512$1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$3.toHex32(this.h, "big");
    else
      return utils$3.split32(this.h, "big");
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ ~xh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r2 = xl & yl ^ ~xl & zl;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r2 = xh & yh ^ xh & zh ^ yh & zh;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r2 = xl & yl ^ xl & zl ^ yl & zl;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r2 = c0_hi ^ c1_hi ^ c2_hi;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r2 = c0_lo ^ c1_lo ^ c2_lo;
    if (r2 < 0)
      r2 += 4294967296;
    return r2;
  }
  var utils$2 = utils$9;
  var SHA512 = _512;
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils$2.inherits(SHA384, SHA512);
  var _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$2.toHex32(this.h.slice(0, 12), "big");
    else
      return utils$2.split32(this.h.slice(0, 12), "big");
  };
  sha.sha1 = _1;
  sha.sha224 = _224;
  sha.sha256 = _256;
  sha.sha384 = _384;
  sha.sha512 = _512;
  var ripemd = {};
  var utils$1 = utils$9;
  var common = common$5;
  var rotl32 = utils$1.rotl32;
  var sum32 = utils$1.sum32;
  var sum32_3 = utils$1.sum32_3;
  var sum32_4 = utils$1.sum32_4;
  var BlockHash = common.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils$1.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C2 = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C2;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A, f$3(j, B, C2, D), msg[r[j] + start], K(j)),
          s$1[j]
        ),
        E
      );
      A = E;
      E = D;
      D = rotl32(C2, 10);
      C2 = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f$3(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]
        ),
        Eh
      );
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C2, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils$1.toHex32(this.h, "little");
    else
      return utils$1.split32(this.h, "little");
  };
  function f$3(j, x2, y2, z2) {
    if (j <= 15)
      return x2 ^ y2 ^ z2;
    else if (j <= 31)
      return x2 & y2 | ~x2 & z2;
    else if (j <= 47)
      return (x2 | ~y2) ^ z2;
    else if (j <= 63)
      return x2 & z2 | y2 & ~z2;
    else
      return x2 ^ (y2 | ~z2);
  }
  function K(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s$1 = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  var utils = utils$9;
  var assert = minimalisticAssert;
  function Hmac(hash2, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash2, key, enc);
    this.Hash = hash2;
    this.blockSize = hash2.blockSize / 8;
    this.outSize = hash2.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
  }
  var hmac = Hmac;
  Hmac.prototype._init = function init2(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i2 = key.length; i2 < this.blockSize; i2++)
      key.push(0);
    for (i2 = 0; i2 < key.length; i2++)
      key[i2] ^= 54;
    this.inner = new this.Hash().update(key);
    for (i2 = 0; i2 < key.length; i2++)
      key[i2] ^= 106;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
  (function(exports) {
    var hash2 = exports;
    hash2.utils = utils$9;
    hash2.common = common$5;
    hash2.sha = sha;
    hash2.ripemd = ripemd;
    hash2.hmac = hmac;
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  })(hash$2);
  const hash$1 = /* @__PURE__ */ getDefaultExportFromCjs(hash$2);
  var TotpAlgorithm;
  (function(TotpAlgorithm2) {
    TotpAlgorithm2["unknown"] = "unknown";
    TotpAlgorithm2["sha1"] = "sha1";
    TotpAlgorithm2["sha256"] = "sha256";
    TotpAlgorithm2["sha512"] = "sha512";
  })(TotpAlgorithm || (TotpAlgorithm = {}));
  const DEFAULT_TOTP_ALGORITHM = TotpAlgorithm.sha1;
  const DEFAULT_TOTP_DIGITS = 6;
  const DEFAULT_TOTP_PERIOD = 30;
  const B32_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  function calculateTotp(secretBase32, algorithm, digits, period, now = Date.now()) {
    const epoch = Math.round(now / 1e3);
    const counter = Math.floor(epoch / period);
    const epochStart = counter * period * 1e3;
    const epochEnd = (counter + 1) * period * 1e3;
    const epochLeftMs = epochEnd - now;
    const totp = calculateHotp(secretBase32, algorithm, digits, counter);
    return { totp, epochStart, epochEnd, epochLeftMs };
  }
  function calculateHotp(secretBase32, algorithm, digits, counter) {
    const secret = base32tohex(secretBase32);
    const hexCounter = zeropad(counter.toString(16), 16);
    let hashAlgorithm;
    switch (algorithm) {
      case TotpAlgorithm.sha1:
        hashAlgorithm = hash$1.sha1;
        break;
      case TotpAlgorithm.sha256:
        hashAlgorithm = hash$1.sha256;
        break;
      case TotpAlgorithm.sha512:
        hashAlgorithm = hash$1.sha512;
        break;
      default:
        throw new UnknownTotpAlgorithmError();
    }
    const hmac2 = hash$1.hmac(hashAlgorithm, secret, "hex").update(hexCounter, "hex").digest("hex");
    const offset = parseInt(hmac2.substring(hmac2.length - 1), 16);
    const otpFull = (parseInt(hmac2.substring(offset * 2, offset * 2 + 8), 16) & 2147483647).toString();
    const otp = otpFull.substring(otpFull.length - digits, otpFull.length);
    return otp;
  }
  function base32tohex(base32) {
    base32 = base32.toUpperCase();
    const missingPaddingCharacters = 8 - base32.length % 8;
    if (missingPaddingCharacters !== 8) {
      base32 += "=".repeat(missingPaddingCharacters);
    }
    let bits = "";
    for (let i2 = 0; i2 < base32.length; i2 += 1) {
      const c2 = base32.charAt(i2);
      const val = B32_CHARS.indexOf(c2);
      if (val === -1) {
        if (c2 === "=") {
          const pad = base32.slice(i2, base32.length);
          if (pad === "=") {
            bits = bits.slice(0, -3);
          } else if (pad === "===") {
            bits = bits.slice(0, -1);
          } else if (pad === "====") {
            bits = bits.slice(0, -4);
          } else if (pad === "======") {
            bits = bits.slice(0, -2);
          } else {
            throw new InvalidTotpSecretError();
          }
          break;
        }
        throw new InvalidTotpSecretError();
      }
      bits += zeropad(val.toString(2), 5);
    }
    let hex = "";
    for (let i2 = 0; i2 + 4 <= bits.length; i2 += 4) {
      const chunk = bits.substr(i2, 4);
      hex += parseInt(chunk, 2).toString(16);
    }
    return hex;
  }
  function zeropad(str, len) {
    if (len <= str.length) {
      return str;
    }
    return Array(len + 1 - str.length).join("0") + str;
  }
  function shouldShowTotpTimeOffsetWarning(clientServerTimeOffsetMs) {
    return clientServerTimeOffsetMs !== null && Math.abs(clientServerTimeOffsetMs) > DEFAULT_TOTP_PERIOD * 1e3;
  }
  function canonicalize(obj) {
    var buffer = "";
    serialize(obj);
    return buffer;
    function serialize(object) {
      if (object === null || typeof object !== "object" || object.toJSON != null) {
        buffer += JSON.stringify(object);
      } else if (Array.isArray(object)) {
        buffer += "[";
        var next_1 = false;
        object.forEach(function(element) {
          if (next_1) {
            buffer += ",";
          }
          next_1 = true;
          serialize(element);
        });
        buffer += "]";
      } else {
        buffer += "{";
        var vKeys = Object.keys(object).sort();
        vKeys.forEach(function(property, index) {
          return addProp(object, property, index);
        });
        buffer += "}";
      }
    }
    function addProp(object, property, index) {
      if (index > 0) {
        buffer += ",";
      }
      buffer += JSON.stringify(property);
      buffer += ":";
      serialize(object[property]);
    }
  }
  function brandedUint8Array(loader) {
    return z.instanceof(Uint8Array).transform((arr) => loader(arr));
  }
  function makeProtobufEnumSchema(protobufEnum) {
    const enumValues = Object.values(protobufEnum);
    return z.number().transform((value, ctx) => {
      if (enumValues.includes(value)) {
        return value;
      }
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Invalid protobuf enum value: ${value}`
      });
      return z.NEVER;
    });
  }
  function makeTypescriptEnumSchema(typescriptEnum) {
    const enumValues = Object.values(typescriptEnum);
    return z.number().or(z.string()).transform((value, ctx) => {
      if (enumValues.includes(value)) {
        return value;
      }
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Invalid typescript enum value: ${value}`
      });
      return z.NEVER;
    });
  }
  function makeExcludeValuesTransform(...excludeValues) {
    return (v2, ctx) => {
      if (excludeValues.includes(v2)) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Unexpected value ${v2}`
        });
        return z.NEVER;
      }
      return v2;
    };
  }
  var __rest$M = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const AuthenticatorWebauthn = z.object({
    webauthnId: z.string(),
    prfSalt: z.instanceof(Uint8Array)
  });
  function deviceTypeToAuthenticatorType(deviceType) {
    switch (deviceType) {
      case "push":
        return AuthenticatorType.PUSH;
      case "recovery":
        return AuthenticatorType.BACKUP_CODE;
      case "backup":
        return AuthenticatorType.BACKUP_OS;
      case "dummy":
        return AuthenticatorType.DUMMY;
      case "organization":
        return AuthenticatorType.ORGANIZATION_ADMIN;
      default:
        return AuthenticatorType.UNKNOWN;
    }
  }
  const schemaAuthenticatorType = makeProtobufEnumSchema(AuthenticatorType);
  const AuthenticatorKeyNamesV3 = z.object({
    id: z.string().uuid(),
    authenticatorType: schemaAuthenticatorType,
    highSecurityLoginSigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
    storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    secretInfo: z.string(),
    secretSalt: z.instanceof(Uint8Array),
    webauthn: AuthenticatorWebauthn.optional()
  });
  const AuthenticatorKeyNamesV2 = z.object({
    id: z.string().uuid(),
    deviceType: z.string(),
    highSecurityLoginSigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
    storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    secretInfo: z.string(),
    secretSalt: z.instanceof(Uint8Array)
  }).transform((_a2) => {
    var { deviceType } = _a2, rest = __rest$M(_a2, ["deviceType"]);
    return Object.assign({ authenticatorType: deviceTypeToAuthenticatorType(deviceType) }, rest);
  });
  const AuthenticatorKeyNamesV1 = z.object({
    id: z.string().uuid(),
    deviceType: z.string(),
    loginSigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecuritySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    sigPubKey: brandedUint8Array(loadSigningPublicKey),
    sigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    encPubKey: brandedUint8Array(loadEncryptionPublicKey),
    encPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    secretInfo: z.string(),
    secretSalt: z.instanceof(Uint8Array)
  }).transform((_a2) => {
    var { deviceType, loginSigPubKey, highSecuritySigPubKey, highSecurityEncPubKey, highSecurityEncPubKeySignature, sigPubKey, sigPubKeySignature, encPubKey, encPubKeySignature } = _a2, rest = __rest$M(_a2, ["deviceType", "loginSigPubKey", "highSecuritySigPubKey", "highSecurityEncPubKey", "highSecurityEncPubKeySignature", "sigPubKey", "sigPubKeySignature", "encPubKey", "encPubKeySignature"]);
    return Object.assign({ authenticatorType: deviceTypeToAuthenticatorType(deviceType), highSecurityLoginSigPubKey: loginSigPubKey, highSecurityIdentitySigPubKey: highSecuritySigPubKey, highSecurityVaultKeyEncPubKey: highSecurityEncPubKey, highSecurityVaultKeyEncPubKeySignature: highSecurityEncPubKeySignature, storableSigPubKey: sigPubKey, storableSigPubKeySignature: sigPubKeySignature, storableVaultKeyEncPubKey: encPubKey, storableVaultKeyEncPubKeySignature: encPubKeySignature }, rest);
  });
  const Authenticator = z.union([
    AuthenticatorKeyNamesV1,
    AuthenticatorKeyNamesV2,
    AuthenticatorKeyNamesV3
  ]);
  var __rest$L = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const UnlockedAuthenticatorNewKeyNames = z.object({
    authenticator: Authenticator,
    storableSigPrivKey: brandedUint8Array(loadSigningPrivateKey),
    storableVaultKeyEncPrivKey: brandedUint8Array(loadEncryptionPrivateKey)
  });
  const UnlockedAuthenticatorOldKeyNames = z.object({
    authenticator: Authenticator,
    sigPrivKey: brandedUint8Array(loadSigningPrivateKey),
    encPrivKey: brandedUint8Array(loadEncryptionPrivateKey)
  }).transform((_a2) => {
    var { sigPrivKey, encPrivKey } = _a2, rest = __rest$L(_a2, ["sigPrivKey", "encPrivKey"]);
    return Object.assign({ storableSigPrivKey: sigPrivKey, storableVaultKeyEncPrivKey: encPrivKey }, rest);
  });
  const UnlockedAuthenticator$1 = z.union([
    UnlockedAuthenticatorOldKeyNames,
    UnlockedAuthenticatorNewKeyNames
  ]);
  const schemaLoginData = z.object({
    userId: z.string().uuid(),
    sessionId: z.string().uuid(),
    token: z.string()
  });
  const SessionKeys$1 = z.object({
    encPrivKey: brandedUint8Array(loadEncryptionPrivateKey),
    encPubKey: brandedUint8Array(loadEncryptionPublicKey),
    encPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    signingAuthId: z.string().uuid()
  });
  const ClientCoreParameters = z.object({
    loginData: schemaLoginData,
    unlockedAuthenticator: UnlockedAuthenticator$1,
    sessionKeys: SessionKeys$1
  });
  var isISO8601$1 = { exports: {} };
  var assertString = { exports: {} };
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = assertString2;
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function assertString2(input) {
      var isString2 = typeof input === "string" || input instanceof String;
      if (!isString2) {
        var invalidType = _typeof(input);
        if (input === null)
          invalidType = "null";
        else if (invalidType === "object")
          invalidType = input.constructor.name;
        throw new TypeError("Expected a string but received a ".concat(invalidType));
      }
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  })(assertString, assertString.exports);
  var assertStringExports = assertString.exports;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isISO86012;
    var _assertString = _interopRequireDefault(assertStringExports);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
    var isValidDate = function isValidDate2(str) {
      var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
      if (ordinalMatch) {
        var oYear = Number(ordinalMatch[1]);
        var oDay = Number(ordinalMatch[2]);
        if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
          return oDay <= 366;
        return oDay <= 365;
      }
      var match2 = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
      var year = match2[1];
      var month = match2[2];
      var day = match2[3];
      var monthString = month ? "0".concat(month).slice(-2) : month;
      var dayString = day ? "0".concat(day).slice(-2) : day;
      var d = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
      if (month && day) {
        return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
      }
      return true;
    };
    function isISO86012(str) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      (0, _assertString.default)(str);
      var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
      if (check && options.strict)
        return isValidDate(str);
      return check;
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  })(isISO8601$1, isISO8601$1.exports);
  var isISO8601Exports = isISO8601$1.exports;
  const isISO8601 = /* @__PURE__ */ getDefaultExportFromCjs(isISO8601Exports);
  function objectPassthrough(x2) {
    const result2 = z.object(x2);
    return result2.passthrough();
  }
  const unknownValuePlaceholderMarker = "fa9fc083-53f0-4616-a4da-2ca792b8f4f8";
  const fallbackValueKey = Symbol("fallbackValueKey");
  const schemaSerializedUnknownValuePlaceholder = z.object({
    marker: z.literal(unknownValuePlaceholderMarker),
    unknownValueJson: z.string()
  });
  function isUnknownValuePlaceholder(value) {
    if (typeof value !== "object") {
      return false;
    }
    return schemaSerializedUnknownValuePlaceholder.safeParse(value).success;
  }
  function getValueWithPlaceholder(value) {
    if (isUnknownValuePlaceholder(value)) {
      return value[fallbackValueKey];
    }
    return value;
  }
  function makeUnknownValuePlaceholderSchema(schema, fallbackValue) {
    return z.union([
      schema,
      schemaSerializedUnknownValuePlaceholder.transform((placeholder) => {
        try {
          const result2 = schema.safeParse(JSON.parse(placeholder.unknownValueJson));
          if (result2.success) {
            return result2.data;
          }
        } catch (e) {
        }
        return Object.assign(Object.assign({}, placeholder), { [fallbackValueKey]: fallbackValue });
      })
    ]).catch((ctx) => ({
      marker: unknownValuePlaceholderMarker,
      // We store the original value as JSON serialized so we can deal with a consistent string type when parsing
      unknownValueJson: JSON.stringify(ctx.input),
      [fallbackValueKey]: fallbackValue
    }));
  }
  var isBase64$1 = { exports: {} };
  var merge = { exports: {} };
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = merge2;
    function merge2() {
      var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var defaults = arguments.length > 1 ? arguments[1] : void 0;
      for (var key in defaults) {
        if (typeof obj[key] === "undefined") {
          obj[key] = defaults[key];
        }
      }
      return obj;
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  })(merge, merge.exports);
  var mergeExports = merge.exports;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = isBase642;
    var _assertString = _interopRequireDefault(assertStringExports);
    var _merge = _interopRequireDefault(mergeExports);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var notBase64 = /[^A-Z0-9+\/=]/i;
    var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
    var defaultBase64Options = {
      urlSafe: false
    };
    function isBase642(str, options) {
      (0, _assertString.default)(str);
      options = (0, _merge.default)(options, defaultBase64Options);
      var len = str.length;
      if (options.urlSafe) {
        return urlSafeBase64.test(str);
      }
      if (len % 4 !== 0 || notBase64.test(str)) {
        return false;
      }
      var firstPaddingChar = str.indexOf("=");
      return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
    }
    module2.exports = exports.default;
    module2.exports.default = exports.default;
  })(isBase64$1, isBase64$1.exports);
  var isBase64Exports = isBase64$1.exports;
  const isBase64 = /* @__PURE__ */ getDefaultExportFromCjs(isBase64Exports);
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return stringify(rnds);
  }
  const nullUuid = "00000000-0000-0000-0000-000000000000";
  function newUuid$1() {
    return v4();
  }
  function uuidEqual(id1, id2) {
    return id1.toLowerCase() === id2.toLowerCase();
  }
  const ProtectedValue = objectPassthrough({
    // Content identity only changes on user edits. The field should be set most of the time, since
    // it was set for all ProtectedValues during the automerge migration. However contentId-less
    // fields may have been re-introduced after the heymerge migration. In this case we generate an
    // id during parsing.
    contentId: z.string().uuid().default(newUuid$1),
    encrypted: z.string().refine(isBase64),
    isEmpty: z.boolean().optional()
  });
  const UnprotectedValue = objectPassthrough({
    // See ProtectedValue.contentId. Note that this field was previously `UUID | null` and therefore
    // uses a different transformation here.
    contentId: z.union([z.string().uuid(), z.null()]).transform((arg) => arg === null ? newUuid$1() : arg),
    unencrypted: z.string()
  });
  const ProtectedCustomField = objectPassthrough({
    // Id should be set most of the time, since it was set for all CustomFields during the automerge
    // migration. However at that time not all importers set the id correctly, so performed in
    // heymerge accounts may have re-introduced id-less CustomFields. In this case we generate an id
    // during parsing.
    id: z.string().uuid().default(newUuid$1),
    name: z.string(),
    protected: z.literal(true),
    value: ProtectedValue
  });
  const UnprotectedProtectedCustomField = objectPassthrough({
    // see ProtectedCustomField.id
    id: z.string().uuid().default(newUuid$1),
    name: z.string(),
    protected: z.literal(true),
    value: UnprotectedValue
  });
  const PlainCustomField = objectPassthrough({
    // see ProtectedCustomField.id
    id: z.string().uuid().default(newUuid$1),
    name: z.string(),
    protected: z.literal(false),
    value: z.string()
  });
  const CustomField = z.union([ProtectedCustomField, PlainCustomField]);
  const UnprotectedCustomField = z.union([UnprotectedProtectedCustomField, PlainCustomField]);
  const LoginAndroidApp = objectPassthrough({
    // TODO make id non optional after migration to heymerge
    id: z.string().uuid().optional(),
    appId: z.string(),
    signature: z.string().refine(isBase64),
    displayName: z.string(),
    iconDataUri: z.string().optional()
  });
  const LoginCreditCard = objectPassthrough({
    number: z.string(),
    cardHolder: z.string(),
    expiration: z.string(),
    securityCode: ProtectedValue,
    pin: ProtectedValue,
    displayType: z.string(),
    displayMaskedNumber: z.string()
  });
  const LOGIN_CREDIT_CARD_KEYS = [
    "number",
    "cardHolder",
    "expiration",
    "securityCode",
    "pin",
    "displayType",
    "displayMaskedNumber"
  ];
  var __rest$K = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  var LoginWebsiteProtocol;
  (function(LoginWebsiteProtocol2) {
    LoginWebsiteProtocol2["http"] = "http";
    LoginWebsiteProtocol2["https"] = "https";
  })(LoginWebsiteProtocol || (LoginWebsiteProtocol = {}));
  const schemaLoginWebsiteProtocol = makeTypescriptEnumSchema(LoginWebsiteProtocol);
  const LoginWebsiteAttributesEntry = objectPassthrough({
    protocol: makeUnknownValuePlaceholderSchema(schemaLoginWebsiteProtocol, void 0).optional()
  });
  const LoginWebsiteAttributes = z.record(LoginWebsiteAttributesEntry);
  var LoginUiType;
  (function(LoginUiType2) {
    LoginUiType2["login"] = "login";
    LoginUiType2["creditCard"] = "creditCard";
    LoginUiType2["note"] = "note";
    LoginUiType2["wifi"] = "wifi";
  })(LoginUiType || (LoginUiType = {}));
  const schemaLoginUiType = makeTypescriptEnumSchema(LoginUiType);
  const LoginSender = objectPassthrough({
    name: z.string(),
    company: z.string().optional()
  });
  var LoginSource;
  (function(LoginSource2) {
    LoginSource2["manual"] = "manual";
    LoginSource2["autosave"] = "autosave";
    LoginSource2["registrationPasswordGeneration"] = "registrationPasswordGeneration";
    LoginSource2["addTotpFromOverlay"] = "addTotpFromOverlay";
    LoginSource2["updateLoginFromOverlay"] = "updateLoginFromOverlay";
    LoginSource2["menuDragDrop"] = "menuDragDrop";
    LoginSource2["import"] = "import";
    LoginSource2["shareLink"] = "shareLink";
    LoginSource2["undo"] = "undo";
  })(LoginSource || (LoginSource = {}));
  const schemaLoginSource = makeTypescriptEnumSchema(LoginSource);
  const ShareLink = objectPassthrough({
    id: z.string(),
    createdAt: z.string().refine((str) => isISO8601(str)),
    openedAt: z.string().refine((str) => isISO8601(str)).optional(),
    secret: ProtectedValue
  });
  const schemaTotpAlgorithm = makeTypescriptEnumSchema(TotpAlgorithm);
  const LeakedPasswordCheckInfo = objectPassthrough({
    leakCount: z.number(),
    checkedAt: z.string().refine((str) => isISO8601(str)),
    checkedPasswordContentId: z.string().uuid()
  });
  const LoginWithoutHistory = objectPassthrough({
    uiType: z.undefined().transform((_) => LoginUiType.login).or(makeUnknownValuePlaceholderSchema(schemaLoginUiType, LoginUiType.login)),
    title: z.string(),
    websites: z.array(z.string()),
    websiteAttributes: LoginWebsiteAttributes.optional(),
    androidApps: z.array(LoginAndroidApp).optional(),
    username: z.string(),
    password: ProtectedValue,
    note: z.string(),
    creationTime: z.string().refine((str) => isISO8601(str)),
    changeTime: z.string().refine((str) => isISO8601(str)).optional(),
    editTime: z.string().refine((str) => isISO8601(str)),
    creationSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional(),
    editSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional(),
    creationProfileId: z.string().uuid().optional(),
    editProfileId: z.string().uuid().optional(),
    customFields: z.array(CustomField),
    totp: ProtectedValue.optional(),
    totpAlgorithm: makeUnknownValuePlaceholderSchema(schemaTotpAlgorithm, TotpAlgorithm.unknown).optional(),
    totpDigits: z.number().int().gte(1).optional(),
    totpPeriod: z.number().int().gte(1).optional(),
    tags: z.array(z.string()).optional(),
    creditCard: LoginCreditCard.optional(),
    wifiSsid: z.string().optional(),
    sender: LoginSender.optional(),
    pendingInboxConfirmation: z.boolean().optional(),
    linkedViewSecrets: z.boolean().optional(),
    linkedFrom: z.object({
      linkedByProfileId: z.string().uuid(),
      originPersonalProfileId: z.string().uuid().nullable(),
      originVaultId: z.string().uuid()
    }).optional(),
    linkedTo: z.array(z.object({
      linkedByProfileId: z.string().uuid(),
      targetPersonalProfileId: z.string().uuid().nullable(),
      targetVaultId: z.string().uuid(),
      addTime: z.string().refine((str) => isISO8601(str)),
      removeTime: z.string().refine((str) => isISO8601(str)).nullable()
    })).optional(),
    shareLinks: z.array(ShareLink).optional(),
    // This field is dropped as a transform. See LoginRevision below, and LoginListElement in
    // LoginVaultContentV2.ts
    internal: z.unknown(),
    archiveInfo: z.object({
      archivedByProfileId: z.string().uuid().optional(),
      archiveTime: z.string().refine((str) => isISO8601(str))
    }).optional(),
    leakedPasswordCheck: LeakedPasswordCheckInfo.optional()
    // deprecated fields
    // icon: z.string().optional(),
  });
  const LoginRevision = LoginWithoutHistory.merge(objectPassthrough({
    baseRevisionId: z.string().uuid().optional()
  })).transform((_a2) => {
    var l = __rest$K(_a2, ["internal"]);
    return l;
  });
  const LoginRevisionHistory = z.object({
    currentRevisionId: z.string().uuid(),
    revisions: z.record(LoginRevision)
  });
  const Login = LoginWithoutHistory.merge(objectPassthrough({
    history: LoginRevisionHistory.optional()
  }));
  const LOGIN_WITHOUT_HISTORY_KEYS = [
    "uiType",
    "title",
    "websites",
    "websiteAttributes",
    "androidApps",
    "username",
    "password",
    "note",
    "creationTime",
    "changeTime",
    "editTime",
    "creationProfileId",
    "editProfileId",
    "creationSource",
    "editSource",
    "customFields",
    "totp",
    "totpAlgorithm",
    "totpDigits",
    "totpPeriod",
    "tags",
    "creditCard",
    "wifiSsid",
    "sender",
    "pendingInboxConfirmation",
    "linkedViewSecrets",
    "linkedFrom",
    "linkedTo",
    "shareLinks",
    "archiveInfo",
    "leakedPasswordCheck"
  ];
  const LOGIN_KEYS = [...LOGIN_WITHOUT_HISTORY_KEYS, "history"];
  const LOGIN_REVISION_KEYS = [...LOGIN_WITHOUT_HISTORY_KEYS, "baseRevisionId"];
  const emptyUnprotectedLogin = {
    uiType: LoginUiType.login,
    creationTime: "",
    editTime: "",
    title: "",
    username: "",
    password: "",
    note: "",
    customFields: [],
    websites: [],
    totp: ""
  };
  const ActiveElement = objectPassthrough({
    updateTime: z.string().refine((str) => isISO8601(str)),
    isDeleted: z.literal(false)
  });
  const Tombstone = objectPassthrough({
    updateTime: z.string().refine((str) => isISO8601(str)),
    isDeleted: z.literal(true),
    isArchived: z.literal(false).optional()
  });
  const ArchivedElement = objectPassthrough({
    updateTime: z.string().refine((str) => isISO8601(str)),
    isDeleted: z.literal(true),
    isArchived: z.literal(true)
  });
  z.union([ActiveElement, ArchivedElement]);
  const UnprotectedShareLink = ShareLink.merge(objectPassthrough({ secret: UnprotectedValue }));
  const UnprotectedLoginWithoutHistory = Login.merge(objectPassthrough({
    password: UnprotectedValue,
    totp: UnprotectedValue.optional(),
    customFields: z.array(UnprotectedCustomField),
    creditCard: LoginCreditCard.merge(z.object({
      pin: UnprotectedValue,
      securityCode: UnprotectedValue
    })).optional(),
    shareLinks: z.array(UnprotectedShareLink).optional()
  }));
  const UnprotectedLoginRevision = UnprotectedLoginWithoutHistory.merge(objectPassthrough({
    baseRevisionId: z.string().uuid().optional()
  }));
  const UnprotectedLogin = UnprotectedLoginWithoutHistory.merge(objectPassthrough({
    history: z.object({
      currentRevisionId: z.string().uuid(),
      revisions: z.record(UnprotectedLoginRevision)
    }).optional()
  }));
  const UnprotectedLoginListElement = z.union([
    UnprotectedLogin.merge(ActiveElement),
    UnprotectedLogin.merge(ArchivedElement),
    Tombstone
  ]);
  var __rest$J = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const LoginListElement = z.union([
    // This is a hack. We would rather apply the transformation to Login directly, but can't because
    // the resulting ZodEffects type would no longer allow us to `.merge` here. So we apply this
    // transformation here, instead of in Login.ts
    // see https://github.com/colinhacks/zod/issues/2474
    Login.merge(ActiveElement).transform((_a2) => {
      var l = __rest$J(_a2, ["internal"]);
      return l;
    }),
    // As archived elements are only written by newer client versions, they will never have the internal field
    Login.merge(ArchivedElement),
    Tombstone
  ]);
  const LoginVaultContentV2 = objectPassthrough({ logins: z.record(LoginListElement) });
  objectPassthrough({ logins: z.record(Login) });
  const SessionMetadata = objectPassthrough({
    description: z.string().optional(),
    iconType: z.string().optional(),
    isSelfUnlocking: z.boolean().optional(),
    encPubKey: z.string().refine((str) => isBase64(str)),
    encPubKeySignature: z.string().refine((str) => isBase64(str)),
    signingAuthId: z.string().uuid(),
    creationTime: z.string().refine((str) => isISO8601(str)),
    editTime: z.string().refine((str) => isISO8601(str)),
    autosnatchTarget: z.string().uuid().optional(),
    autosnatchDisabled: z.boolean().optional()
  });
  const SiteSettings = objectPassthrough({
    extensionDisabled: z.boolean().optional()
    // extensionLoginAutosnatchDisabled: z.boolean().optional(), // deprecated
  });
  const PasswordGeneratorSettings = z.object({
    length: z.number().default(16),
    letters: z.boolean().default(true),
    numbers: z.boolean().default(true),
    special: z.boolean().default(true)
  });
  const HideHints = z.object({
    personalLoginsInfoBox: z.boolean().optional(),
    newFeatureOrganizationMonitoring: z.boolean().optional()
  });
  z.object({
    passwordGenerator: PasswordGeneratorSettings.optional(),
    backupCode: ProtectedValue.optional(),
    hideHints: HideHints.optional()
  });
  const SessionMetadataListElement = z.union([
    SessionMetadata.merge(ActiveElement),
    SessionMetadata.merge(ArchivedElement),
    Tombstone
  ]);
  const SiteSettingsListElement = z.union([
    SiteSettings.merge(ActiveElement),
    SiteSettings.merge(ArchivedElement),
    Tombstone
  ]);
  const MetaVaultContentV2 = objectPassthrough({
    sessions: z.record(SessionMetadataListElement),
    siteSettings: z.record(SiteSettingsListElement).optional()
  });
  objectPassthrough({
    sessions: z.record(SessionMetadata),
    siteSettings: z.record(SiteSettings).optional()
  });
  var __rest$I = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  var PermissionLevel$1;
  (function(PermissionLevel2) {
    PermissionLevel2["admin"] = "admin";
    PermissionLevel2["member"] = "member";
    PermissionLevel2["restricted"] = "restricted";
  })(PermissionLevel$1 || (PermissionLevel$1 = {}));
  const schemaPermissionLevel = makeTypescriptEnumSchema(PermissionLevel$1);
  const TeamVaultPendingUserRegistration = objectPassthrough({
    email: z.string(),
    // fall back to most restrictive permission level
    permissionLevel: makeUnknownValuePlaceholderSchema(schemaPermissionLevel, PermissionLevel$1.restricted).optional()
  });
  const TeamVaultInfo = objectPassthrough({
    name: z.string(),
    icon: z.string().optional(),
    description: z.string().optional(),
    hideSecretsForRestrictedUsers: z.boolean().optional(),
    hideOnMobile: z.boolean().optional(),
    isSyncOrganizationMembers: z.boolean().optional(),
    /**
     * @deprecated Replaced by backend maintained email invites. Only present for migration purposes.
     */
    pendingUserRegistrations: z.array(TeamVaultPendingUserRegistration).optional()
  });
  const TeamVaultUser = objectPassthrough({
    joinedAt: z.string().refine((str) => isISO8601(str)),
    email: z.string().nullish().transform((_) => null),
    newlyJoined: objectPassthrough({
      addedByUserId: z.string().uuid().optional(),
      addedByEmail: z.string()
    }).optional(),
    pendingInvite: objectPassthrough({
      invitedByUserId: z.string().uuid(),
      invitedByEmail: z.string()
    }).optional().transform((pendingInvite) => pendingInvite ? {
      addedByUserId: pendingInvite.invitedByUserId,
      addedByEmail: pendingInvite.invitedByEmail
    } : void 0).optional(),
    // fall back to most restrictive permission level
    permissionLevel: makeUnknownValuePlaceholderSchema(schemaPermissionLevel, PermissionLevel$1.restricted).optional()
  }).transform((_a2) => {
    var { pendingInvite } = _a2, rest = __rest$I(_a2, ["pendingInvite"]);
    return pendingInvite ? Object.assign(Object.assign({}, rest), { newlyJoined: pendingInvite }) : Object.assign({}, rest);
  });
  const MetadataListElement = z.union([
    TeamVaultInfo.merge(ActiveElement),
    TeamVaultInfo.merge(ArchivedElement),
    Tombstone
  ]);
  const UserListElement = z.union([
    z.intersection(TeamVaultUser, ArchivedElement.strip()),
    z.intersection(TeamVaultUser, ActiveElement.strip()),
    Tombstone
  ]);
  const TeamMetaVaultContentV2 = objectPassthrough({
    info: z.record(MetadataListElement),
    users: z.record(UserListElement)
  });
  const TeamMetaVaultContentExternalV2 = objectPassthrough({
    info: z.record(TeamVaultInfo),
    users: z.record(TeamVaultUser)
  });
  const GV2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get PermissionLevel() {
      return PermissionLevel$1;
    },
    TeamMetaVaultContentExternalV2,
    TeamMetaVaultContentV2,
    TeamVaultInfo,
    TeamVaultPendingUserRegistration,
    TeamVaultUser
  }, Symbol.toStringTag, { value: "Module" }));
  const OrganizationPendingUserRegistration = objectPassthrough({
    email: z.string()
  });
  const LegacyOrganizationAdminVaultInfo = objectPassthrough({
    authenticatorSecret: objectPassthrough({
      // authenticatorId: z.string().uuid(),
      seed: ProtectedValue
    }).optional(),
    profileSecret: objectPassthrough({
      seed: ProtectedValue
    }).optional(),
    /**
     * @deprecated Replaced by backend maintained email invites. Only present for migration purposes.
     */
    pendingUserRegistrations: OrganizationPendingUserRegistration.array().optional(),
    unsafeStoredVaultContents: z.record(objectPassthrough({
      logins: z.record(UnprotectedLogin),
      archivedLogins: z.record(UnprotectedLogin)
    })).optional()
  });
  const InfoListElement$1 = z.union([
    LegacyOrganizationAdminVaultInfo.merge(ActiveElement),
    LegacyOrganizationAdminVaultInfo.merge(ArchivedElement),
    Tombstone
  ]);
  const LegacyOrganizationAdminVaultContent$1 = objectPassthrough({
    info: z.record(InfoListElement$1)
  });
  const LegacyOrganizationAdminVaultContentExternal = objectPassthrough({
    info: z.record(LegacyOrganizationAdminVaultInfo)
  });
  const LOAV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    LegacyOrganizationAdminVaultContent: LegacyOrganizationAdminVaultContent$1,
    LegacyOrganizationAdminVaultContentExternal,
    LegacyOrganizationAdminVaultInfo,
    OrganizationPendingUserRegistration
  }, Symbol.toStringTag, { value: "Module" }));
  const OrganizationAdminVaultInfo = objectPassthrough({
    unsafeStoredVaultContents: z.record(objectPassthrough({
      logins: z.record(UnprotectedLogin),
      archivedLogins: z.record(UnprotectedLogin)
    })).optional()
  });
  const InfoListElement = z.union([
    OrganizationAdminVaultInfo.merge(ActiveElement),
    OrganizationAdminVaultInfo.merge(ArchivedElement),
    Tombstone
  ]);
  const OrganizationAdminVaultContent$1 = objectPassthrough({
    info: z.record(InfoListElement)
  });
  const OrganizationAdminVaultContentExternal = objectPassthrough({
    info: z.record(OrganizationAdminVaultInfo)
  });
  const OAV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    OrganizationAdminVaultContent: OrganizationAdminVaultContent$1,
    OrganizationAdminVaultContentExternal,
    OrganizationAdminVaultInfo
  }, Symbol.toStringTag, { value: "Module" }));
  const RelatedProfile = z.object({
    id: z.string().uuid(),
    email: z.string().nullable()
  });
  const schemaGroups = objectPassthrough({
    enable: z.boolean()
  });
  const schemaEventNotifications = objectPassthrough({
    enable: z.boolean()
  });
  const schemaSubscriptionErrorKnownValue$1 = makeProtobufEnumSchema(SubscriptionError).transform(makeExcludeValuesTransform(SubscriptionError.OK));
  const ServerSideSettings = objectPassthrough({
    groups: schemaGroups.optional(),
    eventNotifications: schemaEventNotifications.optional(),
    persistLastKnownSyncVersion: z.boolean().optional(),
    migrateToProfiles: z.boolean().optional(),
    migrateRedundantPrivateProfile: z.boolean().optional(),
    injectSubscriptionError: z.record(schemaSubscriptionErrorKnownValue$1).optional(),
    preferLongPollForProtoClientTypes: z.array(z.number()).optional(),
    allowLoginInbox: z.boolean().optional(),
    lfdAdmin: z.boolean().optional(),
    showInternalBetas: z.boolean().optional()
  });
  const SessionClientProfileSettings = z.object({
    enabled: z.boolean()
  });
  const SessionClientSettings = z.object({
    enableAllProfiles: z.boolean().default(true),
    profileSettings: z.record(SessionClientProfileSettings).default({})
  });
  const unlockTimeLimitSchema = z.object({
    enabled: z.boolean(),
    minutes: z.number()
  });
  const schemaSessionType = makeProtobufEnumSchema(SessionType);
  const Session = z.object({
    id: z.string().uuid(),
    createdAt: z.instanceof(Date),
    lastUsedAt: z.instanceof(Date),
    unlockedAt: z.instanceof(Date).optional(),
    unlockedUntil: z.instanceof(Date).optional(),
    unlockRequestedAt: z.instanceof(Date).optional(),
    unlockExtendAt: z.instanceof(Date).optional(),
    clientSettings: SessionClientSettings.default({ enableAllProfiles: true, profileSettings: {} }),
    sessionType: schemaSessionType.default(SessionType.UNKNOWN),
    enabledProfileIds: z.string().uuid().array().default([]),
    unlockTimeLimit: unlockTimeLimitSchema.default({ enabled: false, minutes: 60 })
  });
  const UserClientSettings = objectPassthrough({
    enableBetaOrganizationUserManagement: z.boolean().optional(),
    enableBetaHeyloginMe: z.boolean().optional(),
    enableBetaLeakedPasswordCheck: z.boolean().optional(),
    enableBetaPasswordPolicy: z.boolean().optional(),
    enableBetaShowPersonalLoginsOnMobile: z.boolean().optional()
  });
  var decode$1;
  var encode$1;
  (function() {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = new Uint8Array(256);
    for (var i2 = 0; i2 < chars.length; i2++) {
      lookup[chars.charCodeAt(i2)] = i2;
    }
    encode$1 = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i3, len = bytes.length, base64 = "";
      for (i3 = 0; i3 < len; i3 += 3) {
        base64 += chars[bytes[i3] >> 2];
        base64 += chars[(bytes[i3] & 3) << 4 | bytes[i3 + 1] >> 4];
        base64 += chars[(bytes[i3 + 1] & 15) << 2 | bytes[i3 + 2] >> 6];
        base64 += chars[bytes[i3 + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    decode$1 = function(base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i3, p2 = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i3 = 0; i3 < len; i3 += 4) {
        encoded1 = lookup[base64.charCodeAt(i3)];
        encoded2 = lookup[base64.charCodeAt(i3 + 1)];
        encoded3 = lookup[base64.charCodeAt(i3 + 2)];
        encoded4 = lookup[base64.charCodeAt(i3 + 3)];
        bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })();
  const FLAG_UINT8_ARRAY = "FLAG_UINT8_ARRAY";
  const FLAG_DATE = "FLAG_DATE";
  const FLAG_UNDEFINED = "FLAG_UNDEFINED";
  function jsonThaw(_key, value) {
    if (value instanceof Object && "flag" in value) {
      switch (value.flag) {
        case FLAG_UINT8_ARRAY:
          return new Uint8Array(decode$1(value.data));
        case FLAG_DATE:
          return new Date(value.data);
        case FLAG_UNDEFINED:
          return void 0;
        default:
          return value;
      }
    }
    return value;
  }
  function jsonFreeze(key) {
    const value = this[key];
    if (value instanceof Uint8Array) {
      return {
        flag: FLAG_UINT8_ARRAY,
        data: encode$1(value)
      };
    }
    if (value instanceof Date) {
      return {
        flag: FLAG_DATE,
        data: value.toISOString()
      };
    }
    if (value === void 0) {
      return {
        flag: FLAG_UNDEFINED
      };
    }
    return value;
  }
  function jsonStringifyFreeze(value, space) {
    return JSON.stringify(value, jsonFreeze, space);
  }
  function jsonParseThaw(text) {
    return JSON.parse(text, jsonThaw);
  }
  const OrganizationClientSettings = objectPassthrough({
    hidePersonalLoginsOnMobile: z.boolean().optional()
  });
  const ContactInfo = z.object({
    name: z.string().optional(),
    icon: z.string().optional(),
    addressLine1: z.string().optional(),
    addressLine2: z.string().optional()
  });
  const ParentOrganizationMetadata = z.object({
    contact: ContactInfo.optional()
  });
  const PasswordRules = z.object({
    length: z.number(),
    upper: z.boolean(),
    numbers: z.boolean(),
    special: z.boolean()
  });
  const PasswordPolicy = makeUnknownValuePlaceholderSchema(z.discriminatedUnion("type", [
    z.object({ type: z.literal("default") }),
    z.object({ type: z.literal("custom"), rules: PasswordRules })
  ]), { type: "default" });
  const schemaProfileAuthenticatorLock = z.object({
    authenticatorId: z.string().uuid(),
    encryptedHighSecurityProfileSeed: z.instanceof(Uint8Array),
    encryptedStorableProfileSeed: z.instanceof(Uint8Array)
  });
  const schemaProfileProfileLock = z.object({
    lockingProfileId: z.string().uuid(),
    lockingProfileKeyGenerationId: z.string().uuid(),
    encryptedHighSecurityProfileSeed: z.instanceof(Uint8Array),
    encryptedStorableProfileSeed: z.instanceof(Uint8Array)
  });
  const schemaProfileType = makeProtobufEnumSchema(ProfileType);
  const PersistableProfile = z.object({
    id: z.string().uuid(),
    profileType: schemaProfileType,
    keyGenerationId: z.string().uuid(),
    email: z.string().nullable(),
    unverifiedEmail: z.string().nullable().default(null),
    organizationId: z.string().uuid().nullable(),
    highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
    highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    highSecurityProfileSeedEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    highSecurityProfileSeedEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
    storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
    storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    storableProfileSeedEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
    storableProfileSeedEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
    authenticatorLocks: z.array(schemaProfileAuthenticatorLock),
    profileLock: schemaProfileProfileLock.nullable().default(null),
    localEncryptedStorableSeed: brandedUint8Array(loadAsymEncryptedBlob).optional()
  });
  var __rest$H = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const PersistableOrganizationAdminInfo = z.object({
    vaultId: z.string().uuid().nullable().default(null),
    legacyAdminVaultId: z.string().uuid().nullable().default(null),
    authenticator: Authenticator.optional(),
    adminProfile: PersistableProfile.optional(),
    entraTenantId: z.string().optional(),
    csvIntegrationActive: z.boolean().default(false),
    googleWorkspaceIntegrationActive: z.boolean().default(false),
    trialEndDate: z.date().optional(),
    licenseType: makeProtobufEnumSchema(LicenseType).default(LicenseType.NONE)
  }).transform((_a2) => {
    var { vaultId, legacyAdminVaultId } = _a2, remainingAdminInfo = __rest$H(_a2, ["vaultId", "legacyAdminVaultId"]);
    return Object.assign(Object.assign({}, remainingAdminInfo), { legacyAdminVaultId: legacyAdminVaultId !== null && legacyAdminVaultId !== void 0 ? legacyAdminVaultId : vaultId });
  });
  const PersistableOrganizationProfile = z.object({
    profileId: z.string().uuid(),
    isAdmin: z.boolean().default(false),
    isManager: z.boolean().default(false),
    isService: z.boolean().default(false),
    isNotConnected: z.boolean().default(false),
    personalVaultId: z.string().uuid().optional(),
    invitedAt: z.date().optional(),
    preliminaryUserId: z.string().uuid().optional(),
    startCode: z.string().optional(),
    startCodeGeneratedAt: z.date().optional(),
    startCodeEmailSentAt: z.date().optional(),
    lastActiveAt: z.date().optional(),
    primaryLoginDevice: makeProtobufEnumSchema(PrimaryLoginDevice).optional()
  });
  const ParentOrganizationInfo = z.object({
    id: z.string().uuid(),
    name: z.string(),
    icon: z.string().optional(),
    metadata: ParentOrganizationMetadata.optional()
  });
  const schemaSubscriptionErrorKnownValue = makeProtobufEnumSchema(SubscriptionError).transform(makeExcludeValuesTransform(SubscriptionError.OK));
  const passwordPolicyFallback = z.string().nullable().transform((oldValue) => {
    if (oldValue === null) {
      return void 0;
    }
    try {
      return PasswordPolicy.parse(jsonParseThaw(oldValue));
    } catch (e) {
      return void 0;
    }
  });
  const passwordPolicyWithFallback = z.union([
    passwordPolicyFallback,
    PasswordPolicy.optional()
  ]);
  const PersistableOrganization = z.object({
    id: z.string().uuid(),
    name: z.string(),
    icon: z.string().nullable(),
    organizationType: makeProtobufEnumSchema(OrganizationType).default(OrganizationType.UNKNOWN),
    restrictCreateTeam: z.boolean().default(false),
    restrictPersonalLogins: z.boolean().default(false),
    auditlogEnable: z.boolean().default(false),
    childOrganizationManagementEnable: z.boolean().default(false),
    superUserId: z.string().uuid(),
    adminProfileId: z.string().uuid().nullable().default(null),
    isAdmin: z.boolean().default(false),
    isManager: z.boolean().default(false),
    isPreliminary: z.boolean().default(false),
    profiles: z.array(PersistableOrganizationProfile).default([]),
    adminInfo: PersistableOrganizationAdminInfo.optional(),
    subscriptionError: schemaSubscriptionErrorKnownValue.nullable(),
    verifiedDomain: z.string().nullable().default(null),
    passwordPolicy: passwordPolicyWithFallback,
    unlockTimeLimit: unlockTimeLimitSchema.default({ enabled: false, minutes: 60 }),
    clientSettings: OrganizationClientSettings.nullable(),
    parentOrganizationInfo: ParentOrganizationInfo.optional()
  });
  const WebauthnCredential = z.object({
    // this field was added late, so we default to a random id if it was missing. this will fix itself
    // on the next sync update, and operations that work on this value will fail reasonably gracefully
    // until then.
    // TODO remove this fallback when minimum version hits 2023-09-28
    webauthnId: z.string().default(() => (
      // b64 urlsafe encoding
      naclUtilExports.encodeBase64(randomSeed()).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "")
    )),
    credentialType: makeProtobufEnumSchema(CredentialType).default(CredentialType.UNKNOWN),
    aaguid: z.string().nullable(),
    sessionId: z.string().nullable().default(null),
    createdAt: z.date(),
    lastUsedAt: z.date(),
    prfSupportStatus: makeProtobufEnumSchema(WebauthnPrfSupportStatus).default(WebauthnPrfSupportStatus.UNKNOWN)
  });
  const PersistableAccountState = z.object({
    userId: z.string().uuid(),
    emails: z.array(z.object({
      email: z.string(),
      primary: z.boolean(),
      verificationPending: z.boolean()
    })).optional(),
    preferredLocale: z.string().nullable().optional(),
    serverSideSettings: ServerSideSettings.optional(),
    userClientSettings: UserClientSettings.optional(),
    authenticators: z.array(Authenticator),
    sessions: z.array(Session),
    achievements: z.number().array().optional(),
    localAchievements: z.number().array().optional(),
    authenticatorBlockHash: brandedUint8Array(loadHash).optional(),
    organizations: z.array(PersistableOrganization).optional(),
    relatedProfiles: z.record(RelatedProfile).optional(),
    webauthnCredentials: z.array(WebauthnCredential).default([]),
    // deprecated
    email: z.string().nullable().optional(),
    unverifiedEmail: z.string().nullable().optional(),
    fullName: z.string().nullable().optional()
  });
  const LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS = ["displayMaskedNumber", "displayType"];
  const LOGIN_DIFFERENCE_IGNORED_KEYS = [
    "creationProfileId",
    "editProfileId",
    "editTime",
    "creationTime",
    "creationSource",
    "editSource",
    "linkedFrom",
    "linkedTo",
    "linkedViewSecrets",
    "sender",
    "pendingInboxConfirmation",
    "shareLinks",
    "history",
    "archiveInfo",
    "changeTime",
    "websiteAttributes",
    "baseRevisionId",
    "uiType",
    "leakedPasswordCheck"
  ];
  function makeLoginDifferenceIncludedKeysSchema(keys2) {
    const includedKeys = keys2.filter((k) => !LOGIN_DIFFERENCE_IGNORED_KEYS.includes(k));
    return z.string().refine((s2) => includedKeys.includes(s2));
  }
  function makeLoginDifferenceCreditCardIncludedKeysSchema() {
    const includedKeys = LOGIN_CREDIT_CARD_KEYS.filter((k) => !LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS.includes(k));
    return z.string().refine((s2) => includedKeys.includes(s2));
  }
  function makeGenericLoginDifferenceSchema(keys2) {
    return makeUnknownValuePlaceholderSchema(z.discriminatedUnion("type", [
      z.object({
        type: z.literal("login"),
        key: makeLoginDifferenceIncludedKeysSchema(keys2)
      }),
      z.object({
        type: z.literal("creditCard"),
        key: makeLoginDifferenceCreditCardIncludedKeysSchema()
      }),
      z.object({
        type: z.literal("customField"),
        id: z.string().uuid(),
        name: z.string()
      })
    ]), { type: "unknown" });
  }
  const LoginDifference = makeGenericLoginDifferenceSchema(LOGIN_KEYS);
  makeGenericLoginDifferenceSchema(LOGIN_REVISION_KEYS);
  const schemaEventType = makeProtobufEnumSchema(AuditlogEventType);
  const AuditlogEventTargetProfile = z.object({
    id: z.string().uuid(),
    email: z.string()
  });
  const AuditlogEvent = z.object({
    type: schemaEventType,
    vaultId: z.string().uuid().optional(),
    loginId: z.string().uuid().optional(),
    customFieldId: z.string().uuid().optional(),
    loginRevisionId: z.string().uuid().optional(),
    loginEditTime: z.string().refine((str) => isISO8601(str)).optional(),
    loginDifferences: z.array(LoginDifference).optional(),
    targetProfile: AuditlogEventTargetProfile.optional()
  });
  const AuditlogEventEnvelope = z.object({
    id: z.string().uuid(),
    profileId: z.string().uuid(),
    time: z.string().refine((str) => isISO8601(str)),
    clientIp: z.string().optional(),
    event: AuditlogEvent
  });
  const QueuedAuditlogEvent = z.object({
    organizationId: z.string().uuid(),
    clientTime: z.date(),
    lastKnownServerTime: z.date(),
    event: AuditlogEvent
  });
  const PersistableForeignVaultSyncPredicate = z.object({
    organizationTeamVaults: z.boolean().optional(),
    organizationAllVaults: z.array(z.string().uuid()).optional(),
    organizationPersonalVaultsForUsers: z.record(z.array(z.string().uuid())).optional(),
    organizationPersonalVaultsForProfiles: z.record(z.array(z.string().uuid())).optional(),
    profileAllVaults: z.array(z.string().uuid()).optional()
  });
  const PersistableProfileRepo = z.object({
    profiles: z.array(PersistableProfile),
    orgAdminProfiles: z.array(PersistableProfile).default([]),
    disabledProfiles: z.array(PersistableProfile).default([])
  });
  const LinkedLoginUpdateMessageV1 = z.array(z.union([
    z.object({
      type: z.literal("originUpdated"),
      loginId: z.string().uuid(),
      content: UnprotectedLoginListElement
    }),
    z.object({
      type: z.literal("targetDeleted"),
      loginId: z.string().uuid(),
      removeTime: z.string().refine((str) => isISO8601(str))
    })
  ]));
  var __rest$G = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const schemaLockDtoNewKeyNames = z.object({
    authenticatorId: z.string().uuid(),
    encryptedStorableVaultKey: z.instanceof(Uint8Array),
    encryptedHighSecurityVaultKey: z.instanceof(Uint8Array),
    encryptedVaultMessagePrivateKey: z.instanceof(Uint8Array).nullable().default(null)
  });
  const schemaLockDtoOldKeyNames = z.object({
    authenticatorId: z.string().uuid(),
    vaultKek: z.instanceof(Uint8Array),
    protectedKek: z.instanceof(Uint8Array)
  }).transform((_a2) => {
    var { vaultKek, protectedKek } = _a2, rest = __rest$G(_a2, ["vaultKek", "protectedKek"]);
    return Object.assign({ encryptedStorableVaultKey: vaultKek, encryptedHighSecurityVaultKey: protectedKek, encryptedVaultMessagePrivateKey: null }, rest);
  });
  const schemaVaultAuthenticatorLockDto = z.union([
    schemaLockDtoOldKeyNames,
    schemaLockDtoNewKeyNames
  ]);
  const schemaVaultProfileLockDtoOldKeyNames = z.object({
    profileId: z.string().uuid(),
    profileKeyGenerationId: z.string().uuid(),
    encryptedStorableVaultKey: z.instanceof(Uint8Array),
    encryptedHighSecurityVaultKey: z.instanceof(Uint8Array),
    encryptedVaultMessagePrivateKey: z.instanceof(Uint8Array).nullable().default(null)
  }).transform((_a2) => {
    var { profileId, profileKeyGenerationId } = _a2, rest = __rest$G(_a2, ["profileId", "profileKeyGenerationId"]);
    return Object.assign({ lockingProfileId: profileId, lockingProfileKeyGenerationId: profileKeyGenerationId }, rest);
  });
  const schemaVaultProfileLockDtoNewKeyNames = z.object({
    lockingProfileId: z.string().uuid(),
    lockingProfileKeyGenerationId: z.string().uuid(),
    encryptedStorableVaultKey: z.instanceof(Uint8Array),
    encryptedHighSecurityVaultKey: z.instanceof(Uint8Array),
    encryptedVaultMessagePrivateKey: z.instanceof(Uint8Array).nullable().default(null)
  });
  const schemaVaultProfileLockDto = z.union([
    schemaVaultProfileLockDtoOldKeyNames,
    schemaVaultProfileLockDtoNewKeyNames
  ]);
  const schemaLinkedUpdateMessage = z.object({
    vaultId: z.string().uuid(),
    type: z.literal(VaultMessageType.LINKED_LOGIN_UPDATE_V1),
    message: LinkedLoginUpdateMessageV1
  });
  const PersistableVault = z.object({
    id: z.string().uuid(),
    type: makeProtobufEnumSchema(VaultType),
    associatedVaultId: z.string().uuid().optional().nullable(),
    generationId: z.string().uuid(),
    firstCommitId: z.string().uuid().optional(),
    commitId: z.string().uuid(),
    userIds: z.array(z.string().uuid()),
    profileIds: z.array(z.string().uuid()).optional(),
    organizationId: z.string().uuid().optional().nullable(),
    locks: z.array(schemaVaultAuthenticatorLockDto),
    profileLock: schemaVaultProfileLockDto.optional(),
    adminProfileLock: schemaVaultProfileLockDto.optional(),
    dirty: z.boolean().optional(),
    vaultState: z.instanceof(Uint8Array),
    stagedDiff: z.union([z.instanceof(Uint8Array), z.null()]).optional(),
    messagePublicKey: z.instanceof(Uint8Array).nullable().default(null),
    inboxSlug: z.string().nullable().default(null),
    linkedUpdateMessages: z.array(schemaLinkedUpdateMessage).default([])
  });
  const PersistableVaultRepo = z.object({
    vaults: z.array(PersistableVault)
  });
  const PersistableClientCore = z.object({
    accountState: PersistableAccountState,
    profileRepo: PersistableProfileRepo.default({ profiles: [] }),
    vaultRepo: PersistableVaultRepo,
    lastKnownSyncVersion: z.number().optional(),
    superUserUnlockedAuthenticators: z.record(UnlockedAuthenticator$1).optional(),
    foreignVaultSyncPredicate: PersistableForeignVaultSyncPredicate.optional(),
    ignoredUnlock: z.date().optional(),
    auditlogEventQueue: z.array(QueuedAuditlogEvent).default([])
  });
  z.object({
    streetAndNumber: z.string().optional(),
    streetAdditional: z.string().optional(),
    postalCode: z.string().optional(),
    city: z.string().optional(),
    region: z.string().optional(),
    country: z.string().optional()
  });
  const PersistableAuthenticatorBlockContent = objectType({
    parent: stringType().refine(isBase64, "could not parse base64 parent hash"),
    keys: arrayType(stringType().refine(isBase64, "could not parse base64 key"))
  });
  const VaultStateInternalStructure = objectPassthrough({
    type: z.string(),
    version: z.number(),
    content: z.unknown()
  });
  const AutosnatchUndoCreate = z.object({
    id: z.string().uuid(),
    type: z.literal("create"),
    editTime: z.string().refine((str) => isISO8601(str)),
    loginId: z.string().uuid(),
    vaultId: z.string().uuid().optional(),
    applied: z.boolean().optional(),
    seen: z.boolean().optional()
  });
  const AutosnatchUndoUpdate = z.object({
    id: z.string().uuid(),
    type: z.literal("update"),
    editTime: z.string().refine((str) => isISO8601(str)),
    loginId: z.string().uuid(),
    vaultId: z.string().uuid().optional(),
    applied: z.boolean().optional(),
    seen: z.boolean().optional(),
    oldEditTime: z.string().refine((str) => isISO8601(str)),
    oldPassword: UnprotectedValue.optional(),
    oldUsername: z.string().optional(),
    oldEditProfile: z.string().uuid().optional(),
    newRevisionId: z.string().uuid().optional(),
    oldEditSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional()
  });
  const AutosnatchUndo = z.union([AutosnatchUndoCreate, AutosnatchUndoUpdate]);
  const ContentScriptAddress = z.object({
    tabId: z.number(),
    frameId: z.number().optional()
  });
  const AutosnatchSource = z.union([
    z.literal(LoginSource.addTotpFromOverlay),
    z.literal(LoginSource.updateLoginFromOverlay),
    z.literal(LoginSource.autosave),
    z.literal(LoginSource.registrationPasswordGeneration)
  ]);
  const EnqueuedAutosnatch = z.object({
    id: z.string().uuid(),
    date: z.string().refine((str) => isISO8601(str)),
    url: z.string(),
    username: z.string(),
    password: z.string(),
    seen: z.boolean().optional(),
    forceCreate: z.boolean().optional(),
    targetLoginId: z.string().uuid().optional(),
    targetVaultId: z.string().uuid().optional(),
    waitForContentScript: ContentScriptAddress.optional(),
    hideUntilCompletion: z.boolean().optional(),
    addTldPlus1: z.boolean().optional(),
    source: AutosnatchSource.optional().catch(void 0)
  });
  const PersistableAutosnatchCache = z.object({
    userId: z.string().uuid(),
    undos: z.array(AutosnatchUndo),
    queue: z.array(EnqueuedAutosnatch)
  });
  z.object({
    contact: ContactInfo.optional()
  });
  const LoginInboxMessageV1 = z.object({
    sender: z.object({
      name: z.string(),
      company: z.string().optional()
    }),
    website: z.string(),
    username: z.string(),
    password: z.string(),
    creationTime: z.string().refine((str) => isISO8601(str))
  });
  const CsvIntegrationDataUser = z.object({
    email: z.string(),
    filterColumnData: z.record(z.array(z.string()).optional())
  });
  const CsvFilterColumn = z.object({
    name: z.string(),
    multiValue: z.boolean(),
    values: z.array(z.string())
  });
  const CsvIntegrationData = z.object({
    users: z.array(CsvIntegrationDataUser),
    filterColumns: z.array(CsvFilterColumn),
    originalCsv: z.string()
  });
  const ShareLinkOpenedBackendMessageV1 = z.object({
    shareLinkId: z.string(),
    openedAt: z.string().refine((str) => isISO8601(str))
  });
  const LoginFormElementSelectors = z.object({
    passwordElement: z.string().nullable(),
    usernameElement: z.string().nullable(),
    totpElements: z.string().or(z.array(z.string())).nullable(),
    submitElement: z.string().nullable(),
    stayLoggedInElement: z.string().nullable(),
    formElement: z.string().nullable()
  }).nullable();
  const AndPredicate = z.object({
    type: z.literal("all"),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    predicates: z.array(z.lazy(() => OverridePredicate))
  });
  const OrPredicate = z.object({
    type: z.literal("atLeastOne"),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    predicates: z.array(z.lazy(() => OverridePredicate))
  });
  const ElementExistsPredicate = z.object({
    type: z.literal("elementExists"),
    selector: z.string(),
    requireVisible: z.boolean().optional()
  });
  const OverridePredicate = z.intersection(z.discriminatedUnion("type", [AndPredicate, OrPredicate, ElementExistsPredicate]), z.object({ negated: z.boolean().optional() }));
  const RegistrationFormElementSelectors = z.object({
    formElement: z.string().nullable(),
    passwordElement: z.string().nullable(),
    repeatPasswordElement: z.string().nullable(),
    usernameElement: z.string().nullable(),
    submitElement: z.string().nullable()
  }).nullable();
  const LoginOverrideRule = z.object({
    type: z.literal("loginForm"),
    selectors: LoginFormElementSelectors
  });
  const RegistrationOverrideRule = z.object({
    type: z.literal("registrationForm"),
    selectors: RegistrationFormElementSelectors
  });
  const NoFormOverrideRule = z.object({
    type: z.literal("noForm")
  });
  const FormKindHintOverrideRule = z.object({
    type: z.literal("formKindHint"),
    kind: z.union([z.literal("login"), z.literal("registration")])
  });
  const OverrideRule = z.intersection(z.discriminatedUnion("type", [
    LoginOverrideRule,
    RegistrationOverrideRule,
    NoFormOverrideRule,
    FormKindHintOverrideRule
  ]), z.object({ predicate: OverridePredicate.optional() }));
  var WebpageOverrideStatus;
  (function(WebpageOverrideStatus2) {
    WebpageOverrideStatus2["hotfix"] = "hotfix";
  })(WebpageOverrideStatus || (WebpageOverrideStatus = {}));
  const WebpageOverride = z.intersection(z.object({
    id: z.string().uuid(),
    status: makeTypescriptEnumSchema(WebpageOverrideStatus).optional(),
    comment: z.string().optional(),
    rules: z.array(OverrideRule)
  }), z.union([
    z.object({ hostnameContains: z.string(), predicate: OverridePredicate.optional() }),
    z.object({ predicate: OverridePredicate })
  ]));
  const OverrideLibrary = z.array(WebpageOverride);
  const ExtensionAvailableInfoMessage = objectPassthrough({
    type: z.literal("extensionAvailableInfo"),
    globalSearch: z.object({ shortcut: z.string().optional() }).optional(),
    isSimulated: z.boolean().optional()
  });
  const GetClientCoreParametersRequestMessage = objectPassthrough({
    type: z.literal("getClientCoreParametersRequest")
  });
  const SetClientCoreParametersMessage = objectPassthrough({
    type: z.literal("setClientCoreParameters"),
    clientCoreParametersJSON: z.string()
  });
  z.union([
    ExtensionAvailableInfoMessage,
    GetClientCoreParametersRequestMessage,
    SetClientCoreParametersMessage
  ]);
  const IsExtensionAvailableMessage = objectPassthrough({
    type: z.literal("isExtensionAvailable")
  });
  const ClientCoreParametersChangeMessage = objectPassthrough({
    type: z.literal("clientCoreParametersChange")
  });
  const OpenShortcutSettingsMessage = objectPassthrough({
    type: z.literal("openShortcutSettings")
  });
  const GetClientCoreParametersResponseMessage = objectPassthrough({
    type: z.literal("getClientCoreParametersResponse"),
    clientCoreParametersJSON: z.string().optional()
  });
  const SetClearValueFromClipboardAfterTimeoutMessage = objectPassthrough({
    type: z.literal("setClearValueFromClipboardAfterTimeout"),
    clearAfterTimeout: z.boolean(),
    value: z.string()
  });
  z.union([
    IsExtensionAvailableMessage,
    ClientCoreParametersChangeMessage,
    OpenShortcutSettingsMessage,
    GetClientCoreParametersResponseMessage,
    SetClearValueFromClipboardAfterTimeoutMessage
  ]);
  function isActiveWebauthnAuthenticator(a2) {
    return a2.authenticatorType === AuthenticatorType.WEBAUTHN && a2.webauthn !== void 0;
  }
  const SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY = "salt-authenticator-login-signing-key-";
  const SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY = "salt-authenticator-signing-key-";
  const SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY = "salt-authenticator-encryption-key-";
  const SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY = "salt-authenticator-signing-key-";
  const SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY = "salt-authenticator-encryption-key-";
  const SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-authenticator-encryption-key-signature-";
  const SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE = "salt-authenticator-signing-key-signature-";
  const SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-authenticator-encryption-key-signature-";
  const SALT_AUTHENTICATOR_WEBAUTHN_SEED = "salt-authenticator-webauthn-seed-";
  function verifyAuthenticator(a2) {
    if (!verifySignedEncryptionPublicKey(a2.highSecurityIdentitySigPubKey, a2.highSecurityVaultKeyEncPubKey, a2.highSecurityVaultKeyEncPubKeySignature, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE)) {
      return false;
    }
    if (!verifySignedEncryptionPublicKey(a2.highSecurityIdentitySigPubKey, a2.storableVaultKeyEncPubKey, a2.storableVaultKeyEncPubKeySignature, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE)) {
      return false;
    }
    if (!verifySignedSigningPublicKey(a2.highSecurityIdentitySigPubKey, a2.storableSigPubKey, a2.storableSigPubKeySignature, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE)) {
      return false;
    }
    return true;
  }
  var ClientCoreErrorGroup;
  (function(ClientCoreErrorGroup2) {
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Generic"] = 1e4] = "Generic";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Vault"] = 2e4] = "Vault";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Authenticator"] = 3e4] = "Authenticator";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Syncing"] = 4e4] = "Syncing";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Core"] = 5e4] = "Core";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Login"] = 6e4] = "Login";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Protected"] = 7e4] = "Protected";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Organization"] = 8e4] = "Organization";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Profile"] = 9e4] = "Profile";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["Webauthn"] = 1e5] = "Webauthn";
    ClientCoreErrorGroup2[ClientCoreErrorGroup2["ShareLink"] = 11e4] = "ShareLink";
  })(ClientCoreErrorGroup || (ClientCoreErrorGroup = {}));
  var ClientCoreErrorCode;
  (function(ClientCoreErrorCode2) {
    ClientCoreErrorCode2[ClientCoreErrorCode2["NotImplemented"] = 2010500] = "NotImplemented";
    ClientCoreErrorCode2[ClientCoreErrorCode2["Internal"] = 2010501] = "Internal";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ParentIdDoesntMatch"] = 2020401] = "ParentIdDoesntMatch";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CannotOverrideCommitId"] = 2020402] = "CannotOverrideCommitId";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidSessionModification"] = 2020410] = "InvalidSessionModification";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidVaultContentDescriptorName"] = 2020411] = "InvalidVaultContentDescriptorName";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginNotFound"] = 2020412] = "LoginNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CannotRegenerateLockedVault"] = 2020420] = "CannotRegenerateLockedVault";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UserAuthenticatorsMissingForRegenerate"] = 2020421] = "UserAuthenticatorsMissingForRegenerate";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileMissingForRegenerate"] = 2020422] = "ProfileMissingForRegenerate";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoCommits"] = 2020430] = "NoCommits";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NeedLocks"] = 2020431] = "NeedLocks";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NeedFullHistory"] = 2020432] = "NeedFullHistory";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultIsLocked"] = 2020440] = "VaultIsLocked";
    ClientCoreErrorCode2[ClientCoreErrorCode2["MetaVaultIdDoesntMatch"] = 2020450] = "MetaVaultIdDoesntMatch";
    ClientCoreErrorCode2[ClientCoreErrorCode2["MetaVaultNotFound"] = 2020451] = "MetaVaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultNotFound"] = 2020452] = "VaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PrivateLoginVaultNotFound"] = 2020456] = "PrivateLoginVaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["IncorrectVaultTypeError"] = 2020459] = "IncorrectVaultTypeError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidCommitStructure"] = 2020460] = "InvalidCommitStructure";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultContentTooNew"] = 2020461] = "VaultContentTooNew";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidCommitContent"] = 2020462] = "InvalidCommitContent";
    ClientCoreErrorCode2[ClientCoreErrorCode2["MergeConflict"] = 2020463] = "MergeConflict";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedCompression"] = 2020464] = "UnsupportedCompression";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedVaultVersion"] = 2020465] = "UnsupportedVaultVersion";
    ClientCoreErrorCode2[ClientCoreErrorCode2["TeamVaultMissingAssociatedMetaVault"] = 2020470] = "TeamVaultMissingAssociatedMetaVault";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultPermissionDenied"] = 2020471] = "VaultPermissionDenied";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedLoginVaultType"] = 2020472] = "UnsupportedLoginVaultType";
    ClientCoreErrorCode2[ClientCoreErrorCode2["OrganizationPersonalVaultNotFound"] = 2020473] = "OrganizationPersonalVaultNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultLinkingNotSupported"] = 2020480] = "VaultLinkingNotSupported";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultMessageEncryptedDataNotFound"] = 2020490] = "VaultMessageEncryptedDataNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LockAuthenticatorNotFound"] = 2030400] = "LockAuthenticatorNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnlockedAuthenticatorNotFound"] = 2030420] = "UnlockedAuthenticatorNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginWithRecovery"] = 2030430] = "LoginWithRecovery";
    ClientCoreErrorCode2[ClientCoreErrorCode2["RemoveLocalAuthenticator"] = 2030440] = "RemoveLocalAuthenticator";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LazyWithoutGetter"] = 2030450] = "LazyWithoutGetter";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LazyWithSetter"] = 2030451] = "LazyWithSetter";
    ClientCoreErrorCode2[ClientCoreErrorCode2["WrongAuthenticatorSecret"] = 2030452] = "WrongAuthenticatorSecret";
    ClientCoreErrorCode2[ClientCoreErrorCode2["SecretReuse"] = 2030460] = "SecretReuse";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidRecoveryCode"] = 2030461] = "InvalidRecoveryCode";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidAuthenticatorSeedLength"] = 2030462] = "InvalidAuthenticatorSeedLength";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorSecreMissingId"] = 2030470] = "AuthenticatorSecreMissingId";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorNotFound"] = 2030471] = "AuthenticatorNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockNotInitial"] = 2030480] = "AuthenticatorBlockNotInitial";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockNotChild"] = 2030481] = "AuthenticatorBlockNotChild";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockInvalidSigningKey"] = 2030482] = "AuthenticatorBlockInvalidSigningKey";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoMatchingSigningKeyFound"] = 2030490] = "NoMatchingSigningKeyFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoAuthenticatorIdReceived"] = 2030500] = "NoAuthenticatorIdReceived";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnlockRejected"] = 2040401] = "UnlockRejected";
    ClientCoreErrorCode2[ClientCoreErrorCode2["FailedPushingCommit"] = 2040410] = "FailedPushingCommit";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginDataMissing"] = 2050400] = "LoginDataMissing";
    ClientCoreErrorCode2[ClientCoreErrorCode2["OwnSessionMissing"] = 2050401] = "OwnSessionMissing";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ClientCoreIsLocked"] = 2050440] = "ClientCoreIsLocked";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PersistableMismatchError"] = 2050500] = "PersistableMismatchError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginNotInitiated"] = 2060400] = "LoginNotInitiated";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PushFlowRunning"] = 2060410] = "PushFlowRunning";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ChannelIdMissing"] = 2060411] = "ChannelIdMissing";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidHashCommitment"] = 2060420] = "InvalidHashCommitment";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LoginCancelled"] = 2060421] = "LoginCancelled";
    ClientCoreErrorCode2[ClientCoreErrorCode2["UnknownAuthenticatorReply"] = 2060430] = "UnknownAuthenticatorReply";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProtectInternalError"] = 2070500] = "ProtectInternalError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantProtect"] = 2070401] = "CantProtect";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantUnprotect"] = 2070402] = "CantUnprotect";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantCreateLock"] = 2070403] = "CantCreateLock";
    ClientCoreErrorCode2[ClientCoreErrorCode2["CantDecryptVaultMessage"] = 2070404] = "CantDecryptVaultMessage";
    ClientCoreErrorCode2[ClientCoreErrorCode2["VaultProtectedSecretNotFound"] = 2070405] = "VaultProtectedSecretNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["OrganizationNotFoundError"] = 2080400] = "OrganizationNotFoundError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoOrganizationMemberError"] = 2080401] = "NoOrganizationMemberError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoOrganizationAdminError"] = 2080402] = "NoOrganizationAdminError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["AdminVaultNotFoundError"] = 2080403] = "AdminVaultNotFoundError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["LockProfileNotFound"] = 2090400] = "LockProfileNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileKeyGenerationMismatch"] = 2090401] = "ProfileKeyGenerationMismatch";
    ClientCoreErrorCode2[ClientCoreErrorCode2["NoMatchingProfileFound"] = 2090402] = "NoMatchingProfileFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileNotFoundError"] = 2090404] = "ProfileNotFoundError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PrfNotSupportedError"] = 2100501] = "PrfNotSupportedError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["PrfInitError"] = 2100502] = "PrfInitError";
    ClientCoreErrorCode2[ClientCoreErrorCode2["ShareLinkNotFound"] = 2110400] = "ShareLinkNotFound";
    ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidShareLink"] = 2110401] = "InvalidShareLink";
  })(ClientCoreErrorCode || (ClientCoreErrorCode = {}));
  const pleaseUpdate$1 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  class ClientCoreDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$1);
    }
  }
  class NotImplementedError extends ClientCoreDomainError {
    constructor(featureName) {
      super(ClientCoreErrorCode.NotImplemented, `The feature "${featureName}" is not implemented yet`);
    }
  }
  class ClientCoreInternalError extends ClientCoreDomainError {
    constructor(message) {
      super(ClientCoreErrorCode.Internal, `Internal error: ${message}`);
    }
  }
  class PersistableMismatchError extends ClientCoreDomainError {
    constructor(persistableUserId, ccpUserId) {
      super(ClientCoreErrorCode.PersistableMismatchError, `Persisted user did not match login parameters! (persistable: ${persistableUserId}, ccp: ${ccpUserId})`);
    }
  }
  class ParentIdDoesntMatchError extends ClientCoreDomainError {
    constructor(want, got) {
      super(ClientCoreErrorCode.ParentIdDoesntMatch, `Commit parentId doesn't match: expected ${want}, got ${got}`, `Commit parentId doesn't match: expected ${want}, got ${got}`, `The vault data loaded seems to be inconsistent. Try to re-login. ${pleaseUpdate$1}`);
    }
  }
  class CannotOverrideCommitIdError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CannotOverrideCommitId, "Cannot override commitId if not in staging state!", "", "");
    }
  }
  class CannotProtectError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CantProtect, "Can't protect while locked!", "Can't protect while locked!", `Tried to access a protected value while not logged in. Log in using the app, then try again. ${pleaseUpdate$1}`);
    }
  }
  class CannotUnprotectError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CantUnprotect, "Can't unprotect while locked!", "Can't unprotect while locked!", `Tried to access a protected value while not logged in. Log in using the app, then try again. ${pleaseUpdate$1}`);
    }
  }
  class CannotCreateLockError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.CantCreateLock, "Can't create lock while locked!");
    }
  }
  class ProtectInternalError extends ClientCoreDomainError {
    constructor(detail) {
      super(ClientCoreErrorCode.ProtectInternalError, detail, detail, `The client produced an internal error while trying to access a protected value. ${pleaseUpdate$1}`);
    }
  }
  class CannotDecryptVaultMessageError extends ClientCoreDomainError {
    constructor(detail = "Cannot decrypt vault message") {
      super(ClientCoreErrorCode.CantDecryptVaultMessage, detail);
    }
  }
  class VaultProtectedSecretNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultProtectedSecretNotFound, "Vault secret not found", "Vault secret not found", `The client is trying to access protected values of a vault with no present protected secret. ${pleaseUpdate$1}`);
    }
  }
  class InvalidSessionModificationError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidSessionModification, "Session modification led to invalid vault content!");
    }
  }
  class InvalidVaultContentDescriptorNameError extends ClientCoreDomainError {
    constructor(typeName) {
      super(ClientCoreErrorCode.InvalidVaultContentDescriptorName, `Unknown type descriptor ${typeName}`);
    }
  }
  class LoginNotFoundError extends ClientCoreDomainError {
    constructor(id) {
      super(ClientCoreErrorCode.LoginNotFound, `No login with id "${id}"!`);
    }
  }
  class UserAuthenticatorsMissingForRegenerateError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UserAuthenticatorsMissingForRegenerate, "Can't regenerate, authenticators are not presents for all users of the vault!");
    }
  }
  class ProfileMissingForRegenerateError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.ProfileMissingForRegenerate, "Can't regenerate, not all profiles present for the vault!");
    }
  }
  class LockAuthenticatorNotFoundError extends ClientCoreDomainError {
    constructor(authId, locks) {
      super(ClientCoreErrorCode.LockAuthenticatorNotFound, `Found no matching lock for available authenticator! Locally available authenticator id ${authId}, lock authenticator ids: ${locks.map((l) => l.authenticatorId)}`);
    }
  }
  class LockProfileNotFoundError extends ClientCoreDomainError {
    constructor(profileId) {
      super(ClientCoreErrorCode.LockProfileNotFound, `Got no matching lock for available profiles! Lock profile id: ${profileId}`);
    }
  }
  class ProfileKeyGenerationMismatchError extends ClientCoreDomainError {
    constructor(profileId, profileGenId, lockGenId) {
      super(ClientCoreErrorCode.ProfileKeyGenerationMismatch, `Mismatched keyGenerationId, profileId: ${profileId}, profile keyGenId: ${profileGenId}, lock keyGenId: ${lockGenId}
        (p) => p.profile.id,
      )}`);
    }
  }
  class ProfileNotFoundError extends ClientCoreDomainError {
    constructor(profileId) {
      super(ClientCoreErrorCode.ProfileNotFoundError, `Profile ${profileId} unexpectedly not loaded`);
    }
  }
  class NeedLocksError extends ClientCoreDomainError {
    constructor(vaultId, oldGenId, newGenId) {
      super(ClientCoreErrorCode.NeedLocks, `Unexpectedly didn't receive locks (vault ${vaultId}, local gen ${oldGenId}, new gen ${newGenId})`);
    }
  }
  class NeedFullHistoryError extends ClientCoreDomainError {
    constructor(vaultId, oldGenId, newGenId) {
      super(ClientCoreErrorCode.NeedFullHistory, `Unexpectedly didn't receive full history (vault ${vaultId}, local gen ${oldGenId}, new gen ${newGenId})`);
    }
  }
  class UnlockedAuthenticatorNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnlockedAuthenticatorNotFound, "Provided unlock does not match any known authenticator");
    }
  }
  class UnlockRejectedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnlockRejected, "Unlock request rejected");
    }
  }
  class LoginWithRecoveryError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LoginWithRecovery, "Can't perform a regular login with recovery authenticator!");
    }
  }
  class LoginDataMissingError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LoginDataMissing, "Login Data is missing!");
    }
  }
  class OwnSessionMissingError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.OwnSessionMissing, "Missing our own session. This should never happen, expected DomainError!");
    }
  }
  class ClientCoreIsLockedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.ClientCoreIsLocked, "Tried to modify a locked ClientCore");
    }
  }
  class VaultIsLockedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultIsLocked, "StagedDiff can't be re-encrypted while vault is locked");
    }
  }
  class RemoveLocalAuthenticatorError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.RemoveLocalAuthenticator, "Cannot remove local unlocked authenticator!");
    }
  }
  class LazyWithoutGetterError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LazyWithoutGetter, "Lazy is only applicable for getters!");
    }
  }
  class LazyWithSetterError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LazyWithSetter, "Lazy is only applicable if no setter is specified!");
    }
  }
  class WrongAuthenticatorSecretError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.WrongAuthenticatorSecret, "Tried to unlock authenticator with wrong authenticator secret!");
    }
  }
  class SecretReuseError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.SecretReuse, "Can't reuse secret that is already associated with an authenticator");
    }
  }
  class InvalidAuthenticatorSeedLengthError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidAuthenticatorSeedLength, "Authenticator seed length must be 32 bytes!");
    }
  }
  class MetaVaultNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.MetaVaultNotFound, "No initialized meta vault!");
    }
  }
  class VaultNotFoundError extends ClientCoreDomainError {
    constructor(vaultId) {
      super(ClientCoreErrorCode.VaultNotFound, `No Vault with id ${vaultId} in VaultRepo`);
    }
  }
  class VaultLinkingNotSupportedError extends ClientCoreDomainError {
    constructor(vaultId) {
      super(ClientCoreErrorCode.VaultLinkingNotSupported, `Linking logins not supported for vault ${vaultId}`);
    }
  }
  class VaultMessageEncryptedDataNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultMessageEncryptedDataNotFound, "Encrypted vault message not found");
    }
  }
  class IncorrectVaultTypeError extends ClientCoreDomainError {
    constructor(vaultId, expected, actual) {
      super(ClientCoreErrorCode.IncorrectVaultTypeError, `Expected vault of type ${expected} for id ${vaultId}, got ${actual} instead.`);
    }
  }
  class TeamVaultMissingAssociatedMetaVaultError extends ClientCoreDomainError {
    constructor(vaultId) {
      super(ClientCoreErrorCode.TeamVaultMissingAssociatedMetaVault, `Team vault with id ${vaultId} is missing its associated meta vault.`);
    }
  }
  class VaultPermissionDeniedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultPermissionDenied, `Account is missing permissions to perform vault operation.`);
    }
  }
  class UnsupportedLoginVaultTypeError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnsupportedLoginVaultType, `Client encountered a login vault with an unsupported type.`);
    }
  }
  class InvalidCommitStructureError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidCommitStructure, "Structure of commit to apply is not valid");
    }
  }
  class VaultContentTooNewError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.VaultContentTooNew, "VaultContent too new, update client!");
    }
  }
  class InvalidCommitContentError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidCommitContent, "Content of commit to apply is not valid");
    }
  }
  class UnsupportedCompressionError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnsupportedCompression, "Commit uses unsupported compression algorithm!");
    }
  }
  class UnsupportedVaultVersionError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.UnsupportedVaultVersion, "Vault version is not supported!");
    }
  }
  class AuthenticatorNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.AuthenticatorNotFound, "Authenticator not found");
    }
  }
  class AuthenticatorBlockNotInitialError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.AuthenticatorBlockNotInitial, "cannot verify a child AuthenticatorBlock as initial");
    }
  }
  class AuthenticatorBlockNotChildError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.AuthenticatorBlockNotChild, "cannot verify initial AuthenticatorBlock against a parent");
    }
  }
  class NoMatchingSigningKeyFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.NoMatchingSigningKeyFound, "No key matching the signature");
    }
  }
  class NoAuthenticatorIdReceivedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.NoAuthenticatorIdReceived, "no authenticator id received");
    }
  }
  class InvalidHashCommitmentError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.InvalidHashCommitment, "Client public key does not match the hash commitment");
    }
  }
  class LoginCancelledError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.LoginCancelled, "Operation was cancelled!");
    }
  }
  class OrganizationNotFoundError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.OrganizationNotFoundError, "organization not found", "Organization not found!", `Tried to perform an operation on an unknown organization. ${pleaseUpdate$1}`);
    }
  }
  class NoOrganizationAdminError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.NoOrganizationAdminError, "no organization admin", "No organization admin!", `Tried to manipulate an organization without admin rights. ${pleaseUpdate$1}`);
    }
  }
  class PrfNotSupportedError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.PrfNotSupportedError, "prf not supported", "Webauthn PRF extension not supported", `Your browser does not support the required PRF extension to perform this operation.`);
    }
  }
  class PrfInitError extends ClientCoreDomainError {
    constructor() {
      super(ClientCoreErrorCode.PrfInitError, "prf init error", "PRF initialization failed", `Enabling session pairing for this login device failed.`);
    }
  }
  class ShareLinkNotFoundError extends ClientCoreDomainError {
    constructor(shareLinkId) {
      super(ClientCoreErrorCode.ShareLinkNotFound, `No ShareLink with id ${shareLinkId} found`);
    }
  }
  const initialParentHash = hashData(naclUtilExports.decodeUTF8("INITIAL_AUTHENTICATOR_BLOCK"));
  const initialParentHashB64 = naclUtilExports.encodeBase64(initialParentHash);
  class AuthenticatorBlock {
    constructor(parentHash, keys2, signature) {
      this.parentHash = parentHash;
      this.keys = keys2;
      this.signature = signature;
      this.blob = AuthenticatorBlock.serialize(parentHash, keys2);
      this.hash = hashData(this.blob);
    }
    static serialize(parentHash, keys2) {
      const obj = {
        parent: naclUtilExports.encodeBase64(parentHash !== null && parentHash !== void 0 ? parentHash : initialParentHash),
        keys: keys2.map(naclUtilExports.encodeBase64).sort()
      };
      const serializedObj = canonicalize(obj);
      return naclUtilExports.decodeUTF8(serializedObj);
    }
    static parse(serialized, signature) {
      const jsonString = naclUtilExports.encodeUTF8(serialized);
      const { parent: parentB64, keys: b64keys } = PersistableAuthenticatorBlockContent.parse(JSON.parse(jsonString));
      const parent = parentB64 === initialParentHashB64 ? null : naclUtilExports.decodeBase64(parentB64);
      const keys2 = b64keys.map(loadSigningPublicKey);
      return new AuthenticatorBlock(parent, keys2, signature);
    }
    static signBlock(signingKey, previousHash, keys2) {
      const serialized = AuthenticatorBlock.serialize(previousHash, keys2);
      return hashAndSign(signingKey, serialized);
    }
    verifyInitial(fingerPrint) {
      if (this.parentHash) {
        throw new AuthenticatorBlockNotInitialError();
      }
      const hashValid = hashEqual(this.hash, fingerPrint);
      const signatureValid = this.keys.some((key) => verifyHashSignature(key, this.signature, this.hash));
      return hashValid && signatureValid;
    }
    verify(parentBlock) {
      if (!this.parentHash) {
        throw new AuthenticatorBlockNotChildError();
      }
      const signatureValid = parentBlock.keys.some((key) => verifyHashSignature(key, this.signature, this.hash));
      const parentHashValid = hashEqual(parentBlock.hash, this.parentHash);
      return signatureValid && parentHashValid;
    }
    static verifyChain(fingerPrint, [initialBlock, ...childBlocks]) {
      if (!initialBlock.verifyInitial(fingerPrint)) {
        return false;
      }
      return AuthenticatorBlock.verifyChainPart(initialBlock, childBlocks);
    }
    static verifyChainPart(validBlocks, childBlocks) {
      let parentBlock = validBlocks;
      for (const childBlock of childBlocks) {
        if (!childBlock.verify(parentBlock)) {
          return false;
        }
        parentBlock = childBlock;
      }
      return true;
    }
    containsKey(key) {
      return this.keys.some((tmpKey) => signingPublicKeyEqual(tmpKey, key));
    }
    static create(privateKey, publicKeys, parent) {
      const signature = AuthenticatorBlock.signBlock(privateKey, parent !== null && parent !== void 0 ? parent : null, publicKeys);
      return new AuthenticatorBlock(parent !== null && parent !== void 0 ? parent : null, publicKeys, signature);
    }
    static fromUnsyncedAuthenticators(mainUa, extraUas) {
      const allAuthenticators = [mainUa, ...extraUas];
      const keys2 = allAuthenticators.map((ua) => ua.highSecurityIdentitySigPubKey);
      const signature = AuthenticatorBlock.signBlock(mainUa.highSecurityIdentitySigPrivKey, null, keys2);
      return new AuthenticatorBlock(null, keys2, signature);
    }
    static load(parentHash, keys2, signature) {
      return new AuthenticatorBlock(parentHash, keys2, signature);
    }
  }
  function loadAuthenticator(dto) {
    const { id, authenticatorType, secretInfo, secretSalt, webauthn } = dto;
    const highSecurityLoginSigPubKey = loadSigningPublicKey(dto.highSecurityLoginSigPubKey);
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadSigningPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    return {
      id,
      authenticatorType,
      highSecurityLoginSigPubKey,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature,
      secretInfo,
      secretSalt,
      webauthn
    };
  }
  function loadForeignAuthenticator(dto) {
    const { id } = dto;
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadSigningPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    return {
      id,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature
    };
  }
  function Lazy(_target, _propertyKey, descriptor) {
    if (!descriptor.get) {
      throw new LazyWithoutGetterError();
    }
    if (descriptor.set) {
      throw new LazyWithSetterError();
    }
    const originalGetter = descriptor.get;
    const { enumerable, configurable } = descriptor;
    const cache2 = /* @__PURE__ */ new WeakMap();
    return {
      enumerable,
      configurable,
      get: function get() {
        const cached = cache2.get(this);
        if (cached !== void 0) {
          return cached;
        }
        const originalResult = originalGetter.call(this);
        cache2.set(this, originalResult);
        return originalResult;
      }
    };
  }
  const SALT_PROFILE_STORABLE_SEED = "salt-profile-storable-seed-";
  const SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY = "salt-profile-high-security-identity-signing-key-";
  const SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY = "salt-profile-high-security-vault-key-encryption-key-";
  const SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY = "salt-profile-high-security-profile-key-encryption-key-";
  const SALT_PROFILE_STORABLE_SIGNING_KEY = "salt-profile-storable-signing-key-";
  const SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY = "salt-profile-storable-vault-key-encryption-key-";
  const SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY = "salt-profile-storable-profile-key-encryption-key-";
  const SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-high-security-vault-key-encryption-key-signature-";
  const SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-high-security-profile-key-encryption-key-signature-";
  const SALT_PROFILE_STORABLE_SIGNING_KEY_SIGNATURE = "salt-profile-storable-signing-key-signature-";
  const SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-storable-vault-key-encryption-key-signature-";
  const SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-storable-profile-key-encryption-key-signature-";
  var __decorate$5 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  class UnlockedProfile {
    constructor(profile, storableSeed) {
      this.profile = profile;
      this.storableSeed = storableSeed;
    }
    static fromSeed(profile, storableSeed) {
      return new UnlockedProfile(profile, storableSeed);
    }
    static load(dto, unlockedAuthenticator, unlockedUpstreamProfile) {
      const profile = loadProfile(dto);
      if ("localEncryptedStorableSeed" in dto && dto.localEncryptedStorableSeed) {
        const storableSeed2 = asymDecrypt(unlockedAuthenticator.storableVaultKeyEncPrivKey, dto.localEncryptedStorableSeed);
        return new UnlockedProfile(profile, storableSeed2);
      }
      if (unlockedUpstreamProfile && profile.profileLock) {
        const storableSeed2 = asymDecrypt(unlockedUpstreamProfile.storableProfileSeedEncPrivKey, profile.profileLock.encryptedStorableProfileSeed);
        return new UnlockedProfile(profile, storableSeed2);
      }
      const candidateLock = profile.authenticatorLocks.find((lock) => lock.authenticatorId === unlockedAuthenticator.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(unlockedAuthenticator.authenticator.id, profile.authenticatorLocks);
      }
      const storableSeed = asymDecrypt(unlockedAuthenticator.storableVaultKeyEncPrivKey, candidateLock.encryptedStorableProfileSeed);
      return new UnlockedProfile(profile, storableSeed);
    }
    getPersistable(ua) {
      if (ua) {
        const localEncryptedStorableSeed = asymEncrypt(ua.authenticator.storableVaultKeyEncPubKey, this.storableSeed);
        return Object.assign(Object.assign({}, this.profile), { localEncryptedStorableSeed });
      }
      return this.profile;
    }
    get storableSigPrivKey() {
      return deriveSigningKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_SIGNING_KEY).sigPrivKey;
    }
    get storableVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    get storableProfileSeedEncPrivKey() {
      return deriveEncryptionKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY).encPrivKey;
    }
  }
  __decorate$5([
    Lazy
  ], UnlockedProfile.prototype, "storableSigPrivKey", null);
  __decorate$5([
    Lazy
  ], UnlockedProfile.prototype, "storableVaultKeyEncPrivKey", null);
  __decorate$5([
    Lazy
  ], UnlockedProfile.prototype, "storableProfileSeedEncPrivKey", null);
  function requireOrgAdminProfile(up) {
    if (up.profile.profileType !== ProfileType.ORGANIZATION_ADMIN) {
      throw new Error(`required org admin profile (${ProfileType.ORGANIZATION_ADMIN}), got ${up.profile.profileType}`);
    }
    if (!up.profile.organizationId) {
      throw new Error("required organizationId in org admin profile, got null");
    }
    return up;
  }
  class UnlockedAuthenticator {
    constructor(authenticator, storableSigPrivKey, storableVaultKeyEncPrivKey) {
      this.authenticator = authenticator;
      this.storableSigPrivKey = storableSigPrivKey;
      this.storableVaultKeyEncPrivKey = storableVaultKeyEncPrivKey;
    }
  }
  var __decorate$4 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  class HighSecurityUnlockedAuthenticator {
    constructor(authenticator, secret) {
      this.authenticator = authenticator;
      this.secret = secret;
    }
    static fromAuthenticatorSecret(a2, secret) {
      if (a2.id !== secret.authenticatorId) {
        throw new WrongAuthenticatorSecretError();
      }
      return new HighSecurityUnlockedAuthenticator(a2, secret);
    }
    createEncryptedSecret(encPubKey) {
      return asymEncrypt(encPubKey, this.secret.seed);
    }
    get highSecurityLoginSigPrivKey() {
      const { sigPrivKey: loginSigPrivKey } = deriveSigningKeyPair(this.secret.seed, null, SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY);
      return loginSigPrivKey;
    }
    get highSecurityIdentitySigPrivKey() {
      return deriveSigningKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
    }
    get highSecurityVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    get storableSigPrivKey() {
      return deriveSigningKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY).sigPrivKey;
    }
    get storableVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    getUnlockedAuthenticator() {
      return new UnlockedAuthenticator(this.authenticator, this.storableSigPrivKey, this.storableVaultKeyEncPrivKey);
    }
  }
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "highSecurityLoginSigPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "highSecurityIdentitySigPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "highSecurityVaultKeyEncPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "storableSigPrivKey", null);
  __decorate$4([
    Lazy
  ], HighSecurityUnlockedAuthenticator.prototype, "storableVaultKeyEncPrivKey", null);
  class UnsyncedAuthenticator {
    constructor(authenticatorType, highSecurityLoginSigPubKey, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, secretInfo, secretSalt, webauthnCreationData, secret) {
      this.authenticatorType = authenticatorType;
      this.highSecurityLoginSigPubKey = highSecurityLoginSigPubKey;
      this.highSecurityIdentitySigPubKey = highSecurityIdentitySigPubKey;
      this.highSecurityIdentitySigPrivKey = highSecurityIdentitySigPrivKey;
      this.highSecurityVaultKeyEncPubKey = highSecurityVaultKeyEncPubKey;
      this.highSecurityVaultKeyEncPubKeySignature = highSecurityVaultKeyEncPubKeySignature;
      this.storableSigPubKey = storableSigPubKey;
      this.storableSigPubKeySignature = storableSigPubKeySignature;
      this.storableVaultKeyEncPubKey = storableVaultKeyEncPubKey;
      this.storableVaultKeyEncPubKeySignature = storableVaultKeyEncPubKeySignature;
      this.secretInfo = secretInfo;
      this.secretSalt = secretSalt;
      this.webauthnCreationData = webauthnCreationData;
      this.secret = secret;
    }
    static create(authenticatorType, secretInfo, secret) {
      const secretSalt = randomSeed();
      return this.createWithSalt(authenticatorType, secretInfo, secret, secretSalt);
    }
    static createWebauthn(secret, webauthnData) {
      const secretSalt = randomSeed();
      return this.createWithSalt(AuthenticatorType.WEBAUTHN, "", secret, secretSalt, webauthnData);
    }
    static createWithSalt(authenticatorType, secretInfo, secret, secretSalt, webauthnData) {
      if (secret.authenticatorId != null) {
        throw new SecretReuseError();
      }
      const { sigPubKey: highSecurityLoginSigPubKey } = deriveSigningKeyPair(secret.seed, null, SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY);
      const { sigPubKey: storableSigPubKey } = deriveSigningKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY);
      const { encPubKey: storableVaultKeyEncPubKey } = deriveEncryptionKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY);
      const { sigPubKey: highSecurityIdentitySigPubKey, sigPrivKey: highSecurityIdentitySigPrivKey } = deriveSigningKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY);
      const { encPubKey: highSecurityVaultKeyEncPubKey } = deriveEncryptionKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY);
      const highSecurityVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableVaultKeyEncPubKey, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableSigPubKeySignature = signSigningPublicKey(highSecurityIdentitySigPrivKey, storableSigPubKey, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE);
      return new UnsyncedAuthenticator(authenticatorType, highSecurityLoginSigPubKey, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, secretInfo, secretSalt, webauthnData, secret);
    }
    serializeForCreation(profileRepo, hsc) {
      const data = Object.assign(Object.assign({}, this), { id: nullUuid });
      const profileLocks = profileRepo.profiles.map((p2) => {
        const hsup = hsc.getHighSecurityUnlockedProfile(p2, profileRepo);
        if (!hsup) {
          throw new ClientCoreInternalError("Failed to unlock one of our profiles, can't regenerate!");
        }
        return hsup.createAuthenticatorLock(data);
      });
      if (profileRepo.disabledProfiles.length) {
        const hsua = hsc.getHighSecurityUnlockedAuthenticator();
        const ua = hsua.getUnlockedAuthenticator();
        profileRepo.disabledProfiles.forEach((p2) => {
          const up = UnlockedProfile.load(p2, ua);
          const hsup = hsc.getHighSecurityUnlockedProfile(up, profileRepo);
          const profileLock = hsup.createAuthenticatorLock(this);
          profileLocks.push(profileLock);
        });
      }
      return { data, profileLocks, webauthn: this.webauthnCreationData };
    }
    serializeForRegistration() {
      return this.serializeWithLocks([]);
    }
    serializeWithLocks(profileLocks) {
      const data = Object.assign(Object.assign({}, this), { id: nullUuid });
      return { data, profileLocks, webauthn: this.webauthnCreationData };
    }
    withId(id) {
      const auth = {
        id,
        authenticatorType: this.authenticatorType,
        highSecurityLoginSigPubKey: this.highSecurityLoginSigPubKey,
        highSecurityIdentitySigPubKey: this.highSecurityIdentitySigPubKey,
        highSecurityVaultKeyEncPubKey: this.highSecurityVaultKeyEncPubKey,
        highSecurityVaultKeyEncPubKeySignature: this.highSecurityVaultKeyEncPubKeySignature,
        storableSigPubKey: this.storableSigPubKey,
        storableSigPubKeySignature: this.storableSigPubKeySignature,
        storableVaultKeyEncPubKey: this.storableVaultKeyEncPubKey,
        storableVaultKeyEncPubKeySignature: this.storableVaultKeyEncPubKeySignature,
        secretInfo: this.secretInfo,
        secretSalt: this.secretSalt,
        webauthn: this.webauthnCreationData
      };
      const secret = Object.assign(Object.assign({}, this.secret), { authenticatorId: id });
      return HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(auth, secret);
    }
  }
  class ProfileAuthenticatorLock {
    constructor(authenticatorId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed) {
      this.authenticatorId = authenticatorId;
      this.encryptedHighSecurityProfileSeed = encryptedHighSecurityProfileSeed;
      this.encryptedStorableProfileSeed = encryptedStorableProfileSeed;
    }
    static create(authenticator, highSecuritySeed, storableSeed) {
      const authenticatorId = authenticator instanceof UnsyncedAuthenticator ? nullUuid : authenticator.id;
      const encryptedHighSecurityProfileSeed = asymEncrypt(authenticator.highSecurityVaultKeyEncPubKey, highSecuritySeed);
      const encryptedStorableProfileSeed = asymEncrypt(authenticator.storableVaultKeyEncPubKey, storableSeed);
      return new ProfileAuthenticatorLock(authenticatorId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed);
    }
    static load({ authenticatorId, encryptedHighSecurityProfileSeed: encryptedHighSecurityProfileKeyData, encryptedStorableProfileSeed: encryptedStorableProfileKeyData }) {
      const encryptedHighSecurityProfileKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityProfileKeyData);
      const encryptedStorableProfileKey = loadAsymEncryptedSymmetricKey(encryptedStorableProfileKeyData);
      return new ProfileAuthenticatorLock(authenticatorId, encryptedHighSecurityProfileKey, encryptedStorableProfileKey);
    }
  }
  class UnsyncedProfile {
    constructor(profileType, organizationId, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, highSecurityProfileSeedEncPubKey, highSecurityProfileSeedEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, storableProfileSeedEncPubKey, storableProfileSeedEncPubKeySignature, authenticatorLocks, upstreamProfileLocks, highSecuritySeed, storableSeed) {
      this.profileType = profileType;
      this.organizationId = organizationId;
      this.highSecurityIdentitySigPubKey = highSecurityIdentitySigPubKey;
      this.highSecurityIdentitySigPrivKey = highSecurityIdentitySigPrivKey;
      this.highSecurityVaultKeyEncPubKey = highSecurityVaultKeyEncPubKey;
      this.highSecurityVaultKeyEncPubKeySignature = highSecurityVaultKeyEncPubKeySignature;
      this.highSecurityProfileSeedEncPubKey = highSecurityProfileSeedEncPubKey;
      this.highSecurityProfileSeedEncPubKeySignature = highSecurityProfileSeedEncPubKeySignature;
      this.storableSigPubKey = storableSigPubKey;
      this.storableSigPubKeySignature = storableSigPubKeySignature;
      this.storableVaultKeyEncPubKey = storableVaultKeyEncPubKey;
      this.storableVaultKeyEncPubKeySignature = storableVaultKeyEncPubKeySignature;
      this.storableProfileSeedEncPubKey = storableProfileSeedEncPubKey;
      this.storableProfileSeedEncPubKeySignature = storableProfileSeedEncPubKeySignature;
      this.authenticatorLocks = authenticatorLocks;
      this.upstreamProfileLocks = upstreamProfileLocks;
      this.highSecuritySeed = highSecuritySeed;
      this.storableSeed = storableSeed;
    }
    static getStorableSeedFromHighSecuritySeed(highSecuritySeed) {
      return deriveSecretFromSeed(highSecuritySeed, null, SALT_PROFILE_STORABLE_SEED);
    }
    static getHighSecurityIdentitySigPrivKey(highSecuritySeed) {
      return deriveSigningKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
    }
    static create(profileType, organizationId, authenticators) {
      return UnsyncedProfile.createWithSeed(profileType, organizationId, authenticators, []).unsyncedProfile;
    }
    static createWithSeed(profileType, organizationId, lockingAuthenticators, lockingProfiles) {
      if (profileType === ProfileType.ORGANIZATION_ADMIN && lockingProfiles.length === 0) {
        throw new Error("org admin profile must have lockingProfiles");
      }
      if (profileType === ProfileType.ORGANIZATION_ADMIN && lockingAuthenticators.length !== 0) {
        throw new Error("org admin profile must not have lockingAuthenticators");
      }
      const highSecuritySeed = randomSeed();
      const storableSeed = UnsyncedProfile.getStorableSeedFromHighSecuritySeed(highSecuritySeed);
      const { sigPubKey: storableSigPubKey } = deriveSigningKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_SIGNING_KEY);
      const { encPubKey: storableVaultKeyEncPubKey } = deriveEncryptionKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY);
      const { encPubKey: storableProfileSeedEncPubKey } = deriveEncryptionKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY);
      const { sigPubKey: highSecurityIdentitySigPubKey, sigPrivKey: highSecurityIdentitySigPrivKey } = deriveSigningKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY);
      const { encPubKey: highSecurityVaultKeyEncPubKey } = deriveEncryptionKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY);
      const { encPubKey: highSecurityProfileSeedEncPubKey } = deriveEncryptionKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY);
      const highSecurityVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const highSecurityProfileSeedEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityProfileSeedEncPubKey, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableVaultKeyEncPubKey, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableProfileSeedEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableProfileSeedEncPubKey, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE);
      const storableSigPubKeySignature = signSigningPublicKey(highSecurityIdentitySigPrivKey, storableSigPubKey, SALT_PROFILE_STORABLE_SIGNING_KEY_SIGNATURE);
      const authenticatorLocks = lockingAuthenticators.map((a2) => ProfileAuthenticatorLock.create(a2, highSecuritySeed, storableSeed));
      const profileLocks = lockingProfiles.map((p2) => ProfileProfileLock.create(p2, highSecuritySeed, storableSeed));
      const unsyncedProfile = new UnsyncedProfile(profileType, organizationId, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, highSecurityProfileSeedEncPubKey, highSecurityProfileSeedEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, storableProfileSeedEncPubKey, storableProfileSeedEncPubKeySignature, authenticatorLocks, profileLocks, highSecuritySeed, storableSeed);
      return { unsyncedProfile, highSecuritySeed, storableSeed };
    }
    intoUnlockedProfile(id, keyGenerationId, email) {
      const profile = {
        id,
        keyGenerationId,
        email,
        unverifiedEmail: null,
        profileType: this.profileType,
        organizationId: this.organizationId,
        highSecurityIdentitySigPubKey: this.highSecurityIdentitySigPubKey,
        highSecurityVaultKeyEncPubKey: this.highSecurityVaultKeyEncPubKey,
        highSecurityVaultKeyEncPubKeySignature: this.highSecurityVaultKeyEncPubKeySignature,
        highSecurityProfileSeedEncPubKey: this.highSecurityProfileSeedEncPubKey,
        highSecurityProfileSeedEncPubKeySignature: this.highSecurityProfileSeedEncPubKeySignature,
        storableSigPubKey: this.storableSigPubKey,
        storableSigPubKeySignature: this.storableSigPubKeySignature,
        storableVaultKeyEncPubKey: this.storableVaultKeyEncPubKey,
        storableVaultKeyEncPubKeySignature: this.storableVaultKeyEncPubKeySignature,
        storableProfileSeedEncPubKey: this.storableProfileSeedEncPubKey,
        storableProfileSeedEncPubKeySignature: this.storableProfileSeedEncPubKeySignature,
        authenticatorLocks: this.authenticatorLocks,
        profileLock: null
      };
      return new UnlockedProfile(profile, this.storableSeed);
    }
    createExtraLock(unsyncedAuthenticator) {
      return ProfileAuthenticatorLock.create(unsyncedAuthenticator, this.highSecuritySeed, this.storableSeed);
    }
    serialize(id = nullUuid, keyGenerationId = nullUuid) {
      return Object.assign(Object.assign({}, this), { id, keyGenerationId });
    }
  }
  class ProfileProfileLock {
    constructor(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed) {
      this.lockingProfileId = lockingProfileId;
      this.lockingProfileKeyGenerationId = lockingProfileKeyGenerationId;
      this.encryptedHighSecurityProfileSeed = encryptedHighSecurityProfileSeed;
      this.encryptedStorableProfileSeed = encryptedStorableProfileSeed;
    }
    static create(lockingProfile, highSecuritySeed, storableSeed) {
      const lockingProfileId = lockingProfile instanceof UnsyncedProfile ? nullUuid : lockingProfile.id;
      const lockingProfileKeyGenerationId = lockingProfile instanceof UnsyncedProfile ? nullUuid : lockingProfile.keyGenerationId;
      const encryptedHighSecurityProfileSeed = asymEncrypt(lockingProfile.highSecurityProfileSeedEncPubKey, highSecuritySeed);
      const encryptedStorableProfileSeed = asymEncrypt(lockingProfile.storableProfileSeedEncPubKey, storableSeed);
      return new ProfileProfileLock(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed);
    }
    static load({ lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed: encryptedHighSecurityProfileKeyData, encryptedStorableProfileSeed: encryptedStorableProfileKeyData }) {
      const encryptedHighSecurityProfileKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityProfileKeyData);
      const encryptedStorableProfileKey = loadAsymEncryptedSymmetricKey(encryptedStorableProfileKeyData);
      return new ProfileProfileLock(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileKey, encryptedStorableProfileKey);
    }
  }
  function loadProfile(dto) {
    const { id, profileType, keyGenerationId, organizationId, email, unverifiedEmail } = dto;
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const highSecurityProfileSeedEncPubKey = loadEncryptionPublicKey(dto.highSecurityProfileSeedEncPubKey);
    const highSecurityProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityProfileSeedEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    const storableProfileSeedEncPubKey = loadEncryptionPublicKey(dto.storableProfileSeedEncPubKey);
    const storableProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableProfileSeedEncPubKeySignature);
    const authenticatorLocks = dto.authenticatorLocks.map(ProfileAuthenticatorLock.load);
    const profileLock = dto.profileLock ? ProfileProfileLock.load(dto.profileLock) : null;
    return {
      id,
      profileType,
      keyGenerationId,
      email,
      unverifiedEmail,
      organizationId,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      highSecurityProfileSeedEncPubKey,
      highSecurityProfileSeedEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature,
      storableProfileSeedEncPubKey,
      storableProfileSeedEncPubKeySignature,
      authenticatorLocks,
      profileLock
    };
  }
  class AccountState {
    constructor(state) {
      this.userId = state.userId;
      this.preferredLocale = state.preferredLocale;
      this.emails = state.emails;
      this.preliminaryEmail = state.preliminaryEmail;
      this.serverSideSettings = state.serverSideSettings;
      this.userClientSettings = state.userClientSettings;
      this.authenticators = state.authenticators;
      this.sessions = state.sessions;
      this.channels = state.channels;
      this.achievements = state.achievements;
      this.localAchievements = state.localAchievements;
      this.authenticatorBlockHash = state.authenticatorBlockHash;
      this.organizations = state.organizations;
      this.relatedProfiles = state.relatedProfiles;
      this.preliminaryProfiles = state.preliminaryProfiles;
      this.webauthnCredentials = state.webauthnCredentials;
      this.openUserConfirmationIds = state.openUserConfirmationIds;
    }
    static fromSyncUpdate(userId, update) {
      return new AccountState({
        userId,
        preferredLocale: null,
        emails: [],
        preliminaryEmail: null,
        serverSideSettings: {},
        userClientSettings: {},
        authenticators: [],
        sessions: [],
        channels: [],
        achievements: /* @__PURE__ */ new Set(),
        localAchievements: /* @__PURE__ */ new Set(),
        authenticatorBlockHash: null,
        organizations: [],
        relatedProfiles: {},
        preliminaryProfiles: [],
        webauthnCredentials: [],
        openUserConfirmationIds: []
      }).withSyncUpdate(update);
    }
    static fromPersistable(persistable) {
      var _a2, _b2, _c2, _d2, _e2, _f2;
      const authenticators = persistable.authenticators.map((a2) => loadAuthenticator(a2));
      const achievements = persistable.achievements ? new Set(persistable.achievements) : /* @__PURE__ */ new Set();
      const localAchievements = persistable.localAchievements ? new Set(persistable.localAchievements) : /* @__PURE__ */ new Set();
      const serverSideSettings = (_a2 = persistable.serverSideSettings) !== null && _a2 !== void 0 ? _a2 : {};
      const userClientSettings = (_b2 = persistable.userClientSettings) !== null && _b2 !== void 0 ? _b2 : {};
      const organizations = (_c2 = persistable.organizations) !== null && _c2 !== void 0 ? _c2 : [];
      const relatedProfiles = (_d2 = persistable.relatedProfiles) !== null && _d2 !== void 0 ? _d2 : {};
      const preliminaryEmail = null;
      const preliminaryProfiles = [];
      let emails;
      if (persistable.emails) {
        emails = persistable.emails;
      } else {
        emails = [];
        if (persistable.email) {
          emails.push({
            email: persistable.email,
            verificationPending: false,
            primary: true
          });
        }
        if (persistable.unverifiedEmail) {
          emails.push({
            email: persistable.unverifiedEmail,
            verificationPending: true,
            primary: false
          });
        }
      }
      for (const s2 of persistable.sessions) {
        if (s2.enabledProfileIds.length === 0 && !s2.clientSettings.enableAllProfiles) {
          s2.enabledProfileIds = Object.entries(s2.clientSettings.profileSettings).flatMap(([k, v2]) => {
            return v2.enabled ? k : [];
          });
        }
      }
      return new AccountState({
        userId: persistable.userId,
        preferredLocale: (_e2 = persistable.preferredLocale) !== null && _e2 !== void 0 ? _e2 : null,
        emails,
        preliminaryEmail,
        serverSideSettings,
        userClientSettings,
        authenticators,
        sessions: persistable.sessions,
        channels: [],
        achievements,
        localAchievements,
        authenticatorBlockHash: (_f2 = persistable.authenticatorBlockHash) !== null && _f2 !== void 0 ? _f2 : null,
        organizations,
        relatedProfiles,
        preliminaryProfiles,
        webauthnCredentials: persistable.webauthnCredentials,
        openUserConfirmationIds: []
      });
    }
    getPersistable() {
      var _a2;
      const sessions = this.sessions.map((s2) => Object.assign(Object.assign({}, s2), { unlockRequestedAt: void 0 }));
      return {
        userId: this.userId,
        preferredLocale: this.preferredLocale,
        serverSideSettings: this.serverSideSettings,
        userClientSettings: this.userClientSettings,
        authenticators: this.authenticators,
        sessions,
        achievements: [...this.achievements],
        localAchievements: [...this.localAchievements],
        authenticatorBlockHash: (_a2 = this.authenticatorBlockHash) !== null && _a2 !== void 0 ? _a2 : void 0,
        organizations: this.organizations,
        relatedProfiles: this.relatedProfiles,
        webauthnCredentials: this.webauthnCredentials,
        emails: [...this.emails]
      };
    }
    hasLocalAchievements() {
      return this.localAchievements.size > 0;
    }
    getLocalAchievements() {
      return [...this.localAchievements];
    }
    hasAchievement(a2) {
      return this.achievements.has(a2) || this.localAchievements.has(a2);
    }
    withLocalAchievements(achievements) {
      const localAchievements = new Set(this.localAchievements);
      for (const a2 of achievements) {
        if (!this.achievements.has(a2)) {
          localAchievements.add(a2);
        }
      }
      return new AccountState(Object.assign(Object.assign({}, this), { localAchievements }));
    }
    getProfileEmail(profileId) {
      var _a2, _b2;
      return (_b2 = (_a2 = this.relatedProfiles[profileId]) === null || _a2 === void 0 ? void 0 : _a2.email) !== null && _b2 !== void 0 ? _b2 : null;
    }
    getPrimaryEmail() {
      var _a2, _b2, _c2, _d2;
      return (_d2 = (_b2 = (_a2 = this.emails.find((e) => e.primary)) === null || _a2 === void 0 ? void 0 : _a2.email) !== null && _b2 !== void 0 ? _b2 : (_c2 = this.emails[0]) === null || _c2 === void 0 ? void 0 : _c2.email) !== null && _d2 !== void 0 ? _d2 : null;
    }
    getUnverifiedEmail() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.emails.find((e) => e.verificationPending)) === null || _a2 === void 0 ? void 0 : _a2.email) !== null && _b2 !== void 0 ? _b2 : null;
    }
    getOrganization(orgId) {
      return this.organizations.find((o) => o.id === orgId);
    }
    isWebauthnPossibleForSession(sessionId) {
      return this.webauthnCredentials.some((c2) => !c2.sessionId || c2.sessionId === sessionId) || this.authenticators.some((auth) => isActiveWebauthnAuthenticator(auth) && this.webauthnCredentials.some((wc) => wc.webauthnId === auth.webauthn.webauthnId));
    }
    hasPushAuthenticator() {
      return this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.PUSH);
    }
    getPrimaryLoginDevice() {
      if (this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.PUSH || a2.authenticatorType === AuthenticatorType.DUMMY)) {
        return PrimaryLoginDevice.PHONE;
      }
      if (this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.SESSION_UNLOCK)) {
        return PrimaryLoginDevice.SECURITY_KEY;
      }
      if (this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.ORGANIZATION_SERVICE)) {
        return PrimaryLoginDevice.SERVICE;
      }
      return PrimaryLoginDevice.NONE;
    }
    withSyncUpdate(update) {
      let { sessions, channels, achievements, localAchievements, emails, preliminaryEmail, preferredLocale, serverSideSettings, userClientSettings, organizations, relatedProfiles, preliminaryProfiles, webauthnCredentials, openUserConfirmationIds } = this;
      if (update.user !== void 0) {
        emails = update.user.emails;
        preliminaryEmail = update.user.preliminaryEmail;
        preferredLocale = update.user.preferredLocale;
        serverSideSettings = parseFromJsonIgnoringError(ServerSideSettings, update.user.serverSideSettings, {});
        userClientSettings = parseFromJsonIgnoringError(UserClientSettings, update.user.userClientSettings, {});
        webauthnCredentials = update.user.webauthnCredentials;
        openUserConfirmationIds = update.user.openUserConfirmationIds;
      }
      if (update.sessions !== void 0) {
        sessions = update.sessions.map((sus) => {
          const clientSettings = parseFromJsonIgnoringError(SessionClientSettings, sus.clientSettings, {
            enableAllProfiles: true,
            profileSettings: {}
          });
          return Object.assign(Object.assign({}, sus), { clientSettings });
        });
      }
      if (update.channels !== void 0) {
        channels = update.channels;
      }
      if (update.achievementIds !== void 0) {
        achievements = new Set(update.achievementIds);
        localAchievements = new Set(localAchievements);
        for (const a2 of localAchievements) {
          if (achievements.has(a2)) {
            localAchievements.delete(a2);
          }
        }
      }
      if (update.organizations !== void 0) {
        organizations = update.organizations.flatMap((o) => {
          var _a2;
          try {
            const persistableOrganization = Object.assign(Object.assign({}, o), { adminInfo: o.adminInfo ? Object.assign(Object.assign({}, o.adminInfo), { authenticator: o.adminInfo.authenticator ? loadAuthenticator(o.adminInfo.authenticator) : o.adminInfo.authenticator, adminProfile: o.adminInfo.adminProfile ? loadProfile(o.adminInfo.adminProfile) : o.adminInfo.adminProfile, legacyAdminVaultId: (_a2 = o.adminInfo.legacyAdminVaultId) !== null && _a2 !== void 0 ? _a2 : null }) : o.adminInfo, clientSettings: parseFromJsonIgnoringError(OrganizationClientSettings, o.clientSettings, null), parentOrganizationInfo: o.parentOrganizationInfo ? Object.assign(Object.assign({}, o.parentOrganizationInfo), { metadata: parseFromJsonIgnoringError(ParentOrganizationMetadata, o.parentOrganizationInfo.metadata, void 0) }) : void 0, passwordPolicy: parseFromJsonIgnoringError(PasswordPolicy, o.passwordPolicy, void 0) });
            return PersistableOrganization.parse(persistableOrganization);
          } catch (e) {
            trackError(e);
            return [];
          }
        });
      }
      if (update.relatedProfiles !== void 0) {
        relatedProfiles = {};
        for (const p2 of update.relatedProfiles) {
          relatedProfiles[p2.id] = p2;
        }
      }
      if (update.preliminaryProfiles !== void 0) {
        preliminaryProfiles = update.preliminaryProfiles;
      }
      return new AccountState(Object.assign(Object.assign({}, this), {
        preferredLocale,
        emails,
        preliminaryEmail,
        serverSideSettings,
        userClientSettings,
        sessions,
        channels,
        achievements,
        localAchievements,
        organizations,
        relatedProfiles,
        preliminaryProfiles,
        webauthnCredentials,
        openUserConfirmationIds
      }));
    }
    withAuthenticatorList(list) {
      const authenticators = list.authenticators.map(loadAuthenticator);
      if (!authenticators.every((a2) => verifyAuthenticator(a2))) {
        trackError(new Error(`an authenticator key had no proper signature`));
      }
      const blocks = list.blocks.map((ab) => AuthenticatorBlock.parse(ab.blob, ab.signature));
      if (!blocks.length) {
        if (this.authenticatorBlockHash) {
          trackError(new Error("missing authenticator block"));
        }
        return new AccountState(Object.assign(Object.assign({}, this), { authenticators, authenticatorBlockHash: null }));
      }
      const latestBlock = blocks[blocks.length - 1];
      try {
        if (this.authenticatorBlockHash) {
          const [knownBlock, ...newBlocks] = blocks;
          if (!hashEqual(knownBlock.hash, this.authenticatorBlockHash)) {
            throw new Error("first authenticator block hash does not match");
          }
          if (!AuthenticatorBlock.verifyChainPart(knownBlock, newBlocks)) {
            throw new Error("invalid authenticator block detected");
          }
        } else if (!AuthenticatorBlock.verifyChain(blocks[0].hash, blocks)) {
          throw new Error("invalid init authenticator block detected");
        }
        if (authenticators.some((a2) => latestBlock.keys.every((k) => !signingPublicKeyEqual(k, a2.highSecurityIdentitySigPubKey)))) {
          throw new Error("authenticator is not in the authenticator block");
        }
      } catch (e) {
        trackError(e);
      }
      return new AccountState(Object.assign(Object.assign({}, this), { authenticators, authenticatorBlockHash: latestBlock.hash }));
    }
  }
  function parseFromJsonIgnoringError(type, inputJson, fallback2) {
    if (inputJson === void 0 || inputJson === null) {
      return fallback2;
    }
    try {
      const input = jsonParseThaw(inputJson);
      const parsed = type.safeParse(input);
      if (parsed.success) {
        return parsed.data;
      }
    } catch (e) {
      trackError(e);
      return fallback2;
    }
  }
  var __awaiter$R = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let Semaphore$1 = class Semaphore {
    constructor(_value) {
      this._value = _value;
      this._queue = [];
      if (_value <= 0) {
        throw new Error("semaphore must be initialized to a positive value");
      }
    }
    acquire() {
      const locked = this.isLocked();
      const ticket = new Promise((r2) => this._queue.push(r2));
      if (!locked)
        this._dispatch();
      return ticket;
    }
    runExclusive(callback) {
      return __awaiter$R(this, void 0, void 0, function* () {
        const [value, release] = yield this.acquire();
        try {
          return yield callback(value);
        } finally {
          release();
        }
      });
    }
    isLocked() {
      return this._value <= 0;
    }
    release() {
      if (this._currentReleaser) {
        this._currentReleaser();
        this._currentReleaser = void 0;
      }
    }
    _dispatch() {
      const nextConsumer = this._queue.shift();
      if (!nextConsumer)
        return;
      let released = false;
      this._currentReleaser = () => {
        if (released)
          return;
        released = true;
        this._value++;
        this._dispatch();
      };
      nextConsumer([this._value--, this._currentReleaser]);
    }
  };
  var __awaiter$1$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  let Mutex$1 = class Mutex {
    constructor() {
      this._semaphore = new Semaphore$1(1);
    }
    acquire() {
      return __awaiter$1$1(this, void 0, void 0, function* () {
        const [, releaser] = yield this._semaphore.acquire();
        return releaser;
      });
    }
    runExclusive(callback) {
      return this._semaphore.runExclusive(() => callback());
    }
    isLocked() {
      return this._semaphore.isLocked();
    }
    release() {
      this._semaphore.release();
    }
  };
  var toStr$a = Object.prototype.toString;
  var isArguments$3 = function isArguments2(value) {
    var str = toStr$a.call(value);
    var isArgs2 = str === "[object Arguments]";
    if (!isArgs2) {
      isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$a.call(value.callee) === "[object Function]";
    }
    return isArgs2;
  };
  var implementation$b;
  var hasRequiredImplementation;
  function requireImplementation() {
    if (hasRequiredImplementation)
      return implementation$b;
    hasRequiredImplementation = 1;
    var keysShim2;
    if (!Object.keys) {
      var has2 = Object.prototype.hasOwnProperty;
      var toStr2 = Object.prototype.toString;
      var isArgs2 = isArguments$3;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      var hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      var dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      var equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      var excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      var hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has2.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      var equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim2 = function keys2(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction2 = toStr2.call(object) === "[object Function]";
        var isArguments2 = isArgs2(object);
        var isString2 = isObject && toStr2.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction2 && !isArguments2) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction2;
        if (isString2 && object.length > 0 && !has2.call(object, 0)) {
          for (var i2 = 0; i2 < object.length; ++i2) {
            theKeys.push(String(i2));
          }
        }
        if (isArguments2 && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has2.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has2.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    implementation$b = keysShim2;
    return implementation$b;
  }
  var slice$1 = Array.prototype.slice;
  var isArgs = isArguments$3;
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys2(o) {
    return origKeys(o);
  } : requireImplementation();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys2(object) {
          if (isArgs(object)) {
            return originalKeys(slice$1.call(object));
          }
          return originalKeys(object);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  var objectKeys$1 = keysShim;
  var hasToStringTag$6 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var toStr$9 = Object.prototype.toString;
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag$6 && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return toStr$9.call(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$9.call(value) !== "[object Array]" && toStr$9.call(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  var isArguments$2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  var keys$1 = objectKeys$1;
  var hasSymbols$7 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr$8 = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr$8.call(fn) === "[object Function]";
  };
  var arePropertyDescriptorsSupported = function() {
    var obj = {};
    try {
      origDefineProperty(obj, "x", { enumerable: false, value: obj });
      for (var _ in obj) {
        return false;
      }
      return obj.x === obj;
    } catch (e) {
      return false;
    }
  };
  var supportsDescriptors$2 = origDefineProperty && arePropertyDescriptorsSupported();
  var defineProperty$1 = function(object, name, value, predicate) {
    if (name in object && (!isFunction(predicate) || !predicate())) {
      return;
    }
    if (supportsDescriptors$2) {
      origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value,
        writable: true
      });
    } else {
      object[name] = value;
    }
  };
  var defineProperties$1 = function(object, map2) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys$1(map2);
    if (hasSymbols$7) {
      props = concat.call(props, Object.getOwnPropertySymbols(map2));
    }
    for (var i2 = 0; i2 < props.length; i2 += 1) {
      defineProperty$1(object, props[i2], map2[props[i2]], predicates[props[i2]]);
    }
  };
  defineProperties$1.supportsDescriptors = !!supportsDescriptors$2;
  var defineProperties_1 = defineProperties$1;
  var callBind$8 = { exports: {} };
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr$7 = Object.prototype.toString;
  var funcType = "[object Function]";
  var implementation$a = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr$7.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound2;
    var binder = function() {
      if (this instanceof bound2) {
        var result2 = target.apply(
          this,
          args.concat(slice.call(arguments))
        );
        if (Object(result2) === result2) {
          return result2;
        }
        return this;
      } else {
        return target.apply(
          that,
          args.concat(slice.call(arguments))
        );
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs.push("$" + i2);
    }
    bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound2.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound2;
  };
  var implementation$9 = implementation$a;
  var functionBind = Function.prototype.bind || implementation$9;
  var shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  var origSymbol = commonjsGlobal.Symbol;
  var hasSymbolSham = shams;
  var hasSymbols$6 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  var undefined$2;
  var $TypeError$4 = TypeError;
  var $gOPD$2 = Object.getOwnPropertyDescriptor;
  if ($gOPD$2) {
    try {
      $gOPD$2({}, "");
    } catch (e) {
      $gOPD$2 = null;
    }
  }
  var throwTypeError$1 = function() {
    throw new $TypeError$4();
  };
  var ThrowTypeError$1 = $gOPD$2 ? function() {
    try {
      arguments.callee;
      return throwTypeError$1;
    } catch (calleeThrows) {
      try {
        return $gOPD$2(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError$1;
      }
    }
  }() : throwTypeError$1;
  var hasSymbols$5 = hasSymbols$6();
  var getProto$2 = Object.getPrototypeOf || function(x2) {
    return x2.__proto__;
  };
  var generatorFunction = undefined$2;
  var asyncFunction = undefined$2;
  var asyncGenFunction$1 = undefined$2;
  var TypedArray$1 = typeof Uint8Array === "undefined" ? undefined$2 : getProto$2(Uint8Array);
  var INTRINSICS$1 = {
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$2 : ArrayBuffer,
    "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$2 : ArrayBuffer.prototype,
    "%ArrayIteratorPrototype%": hasSymbols$5 ? getProto$2([][Symbol.iterator]()) : undefined$2,
    "%ArrayPrototype%": Array.prototype,
    "%ArrayProto_entries%": Array.prototype.entries,
    "%ArrayProto_forEach%": Array.prototype.forEach,
    "%ArrayProto_keys%": Array.prototype.keys,
    "%ArrayProto_values%": Array.prototype.values,
    "%AsyncFromSyncIteratorPrototype%": undefined$2,
    "%AsyncFunction%": asyncFunction,
    "%AsyncFunctionPrototype%": undefined$2,
    "%AsyncGenerator%": undefined$2,
    "%AsyncGeneratorFunction%": asyncGenFunction$1,
    "%AsyncGeneratorPrototype%": undefined$2,
    "%AsyncIteratorPrototype%": undefined$2,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$2 : Atomics,
    "%Boolean%": Boolean,
    "%BooleanPrototype%": Boolean.prototype,
    "%DataView%": typeof DataView === "undefined" ? undefined$2 : DataView,
    "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$2 : DataView.prototype,
    "%Date%": Date,
    "%DatePrototype%": Date.prototype,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%ErrorPrototype%": Error.prototype,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%EvalErrorPrototype%": EvalError.prototype,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$2 : Float32Array,
    "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$2 : Float32Array.prototype,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$2 : Float64Array,
    "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$2 : Float64Array.prototype,
    "%Function%": Function,
    "%FunctionPrototype%": Function.prototype,
    "%Generator%": undefined$2,
    "%GeneratorFunction%": generatorFunction,
    "%GeneratorPrototype%": undefined$2,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$2 : Int8Array,
    "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$2 : Int8Array.prototype,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$2 : Int16Array,
    "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$2 : Int8Array.prototype,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$2 : Int32Array,
    "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$2 : Int32Array.prototype,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols$5 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$2,
    "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$2,
    "%Map%": typeof Map === "undefined" ? undefined$2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$5 ? undefined$2 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%MapPrototype%": typeof Map === "undefined" ? undefined$2 : Map.prototype,
    "%Math%": Math,
    "%Number%": Number,
    "%NumberPrototype%": Number.prototype,
    "%Object%": Object,
    "%ObjectPrototype%": Object.prototype,
    "%ObjProto_toString%": Object.prototype.toString,
    "%ObjProto_valueOf%": Object.prototype.valueOf,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$2 : Promise,
    "%PromisePrototype%": typeof Promise === "undefined" ? undefined$2 : Promise.prototype,
    "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$2 : Promise.prototype.then,
    "%Promise_all%": typeof Promise === "undefined" ? undefined$2 : Promise.all,
    "%Promise_reject%": typeof Promise === "undefined" ? undefined$2 : Promise.reject,
    "%Promise_resolve%": typeof Promise === "undefined" ? undefined$2 : Promise.resolve,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$2 : Proxy,
    "%RangeError%": RangeError,
    "%RangeErrorPrototype%": RangeError.prototype,
    "%ReferenceError%": ReferenceError,
    "%ReferenceErrorPrototype%": ReferenceError.prototype,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$2 : Reflect,
    "%RegExp%": RegExp,
    "%RegExpPrototype%": RegExp.prototype,
    "%Set%": typeof Set === "undefined" ? undefined$2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$5 ? undefined$2 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SetPrototype%": typeof Set === "undefined" ? undefined$2 : Set.prototype,
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$2 : SharedArrayBuffer,
    "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$2 : SharedArrayBuffer.prototype,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols$5 ? getProto$2(""[Symbol.iterator]()) : undefined$2,
    "%StringPrototype%": String.prototype,
    "%Symbol%": hasSymbols$5 ? Symbol : undefined$2,
    "%SymbolPrototype%": hasSymbols$5 ? Symbol.prototype : undefined$2,
    "%SyntaxError%": SyntaxError,
    "%SyntaxErrorPrototype%": SyntaxError.prototype,
    "%ThrowTypeError%": ThrowTypeError$1,
    "%TypedArray%": TypedArray$1,
    "%TypedArrayPrototype%": TypedArray$1 ? TypedArray$1.prototype : undefined$2,
    "%TypeError%": $TypeError$4,
    "%TypeErrorPrototype%": $TypeError$4.prototype,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$2 : Uint8Array,
    "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$2 : Uint8Array.prototype,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$2 : Uint8ClampedArray,
    "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$2 : Uint8ClampedArray.prototype,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$2 : Uint16Array,
    "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$2 : Uint16Array.prototype,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$2 : Uint32Array,
    "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$2 : Uint32Array.prototype,
    "%URIError%": URIError,
    "%URIErrorPrototype%": URIError.prototype,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$2 : WeakMap,
    "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$2 : WeakMap.prototype,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$2 : WeakSet,
    "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$2 : WeakSet.prototype
  };
  var bind$2 = functionBind;
  var $replace$1 = bind$2.call(Function.call, String.prototype.replace);
  var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar$1 = /\\(\\)?/g;
  var stringToPath$1 = function stringToPath2(string) {
    var result2 = [];
    $replace$1(string, rePropName$1, function(match2, number2, quote2, subString) {
      result2[result2.length] = quote2 ? $replace$1(subString, reEscapeChar$1, "$1") : number2 || match2;
    });
    return result2;
  };
  var getBaseIntrinsic$1 = function getBaseIntrinsic2(name, allowMissing) {
    if (!(name in INTRINSICS$1)) {
      throw new SyntaxError("intrinsic " + name + " does not exist!");
    }
    if (typeof INTRINSICS$1[name] === "undefined" && !allowMissing) {
      throw new $TypeError$4("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return INTRINSICS$1[name];
  };
  var GetIntrinsic$7 = function GetIntrinsic2(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new TypeError('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath$1(name);
    var value = getBaseIntrinsic$1("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
    for (var i2 = 1; i2 < parts.length; i2 += 1) {
      if (value != null) {
        if ($gOPD$2 && i2 + 1 >= parts.length) {
          var desc = $gOPD$2(value, parts[i2]);
          if (!allowMissing && !(parts[i2] in value)) {
            throw new $TypeError$4("base intrinsic for " + name + " exists, but the property is not available.");
          }
          value = desc && "get" in desc && !("originalValue" in desc.get) ? desc.get : value[parts[i2]];
        } else {
          value = value[parts[i2]];
        }
      }
    }
    return value;
  };
  (function(module2) {
    var bind2 = functionBind;
    var GetIntrinsic2 = GetIntrinsic$7;
    var $apply = GetIntrinsic2("%Function.prototype.apply%");
    var $call = GetIntrinsic2("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind2() {
      return $reflectApply(bind2, $call, arguments);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind$8);
  var callBindExports$1 = callBind$8.exports;
  var numberIsNaN = function(value) {
    return value !== value;
  };
  var implementation$8 = function is2(a2, b) {
    if (a2 === 0 && b === 0) {
      return 1 / a2 === 1 / b;
    }
    if (a2 === b) {
      return true;
    }
    if (numberIsNaN(a2) && numberIsNaN(b)) {
      return true;
    }
    return false;
  };
  var implementation$7 = implementation$8;
  var polyfill$4 = function getPolyfill2() {
    return typeof Object.is === "function" ? Object.is : implementation$7;
  };
  var getPolyfill$5 = polyfill$4;
  var define$3 = defineProperties_1;
  var shim$5 = function shimObjectIs() {
    var polyfill2 = getPolyfill$5();
    define$3(Object, { is: polyfill2 }, {
      is: function testObjectIs() {
        return Object.is !== polyfill2;
      }
    });
    return polyfill2;
  };
  var define$2 = defineProperties_1;
  var callBind$7 = callBindExports$1;
  var implementation$6 = implementation$8;
  var getPolyfill$4 = polyfill$4;
  var shim$4 = shim$5;
  var polyfill$3 = callBind$7(getPolyfill$4(), Object);
  define$2(polyfill$3, {
    getPolyfill: getPolyfill$4,
    implementation: implementation$6,
    shim: shim$4
  });
  var objectIs = polyfill$3;
  var hasSymbols$4 = hasSymbols$6();
  var hasToStringTag$5 = hasSymbols$4 && typeof Symbol.toStringTag === "symbol";
  var hasOwnProperty;
  var regexExec;
  var isRegexMarker;
  var badStringifier;
  if (hasToStringTag$5) {
    hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
    regexExec = Function.call.bind(RegExp.prototype.exec);
    isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
  }
  var toStr$6 = Object.prototype.toString;
  var gOPD$2 = Object.getOwnPropertyDescriptor;
  var regexClass = "[object RegExp]";
  var isRegex$1 = hasToStringTag$5 ? function isRegex2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    var descriptor = gOPD$2(value, "lastIndex");
    var hasLastIndexDataProperty = descriptor && hasOwnProperty(descriptor, "value");
    if (!hasLastIndexDataProperty) {
      return false;
    }
    try {
      regexExec(value, badStringifier);
    } catch (e) {
      return e === isRegexMarker;
    }
  } : function isRegex2(value) {
    if (!value || typeof value !== "object" && typeof value !== "function") {
      return false;
    }
    return toStr$6.call(value) === regexClass;
  };
  var $Object = Object;
  var $TypeError$3 = TypeError;
  var implementation$5 = function flags2() {
    if (this != null && this !== $Object(this)) {
      throw new $TypeError$3("RegExp.prototype.flags getter called on non-object");
    }
    var result2 = "";
    if (this.global) {
      result2 += "g";
    }
    if (this.ignoreCase) {
      result2 += "i";
    }
    if (this.multiline) {
      result2 += "m";
    }
    if (this.dotAll) {
      result2 += "s";
    }
    if (this.unicode) {
      result2 += "u";
    }
    if (this.sticky) {
      result2 += "y";
    }
    return result2;
  };
  var implementation$4 = implementation$5;
  var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
  var $gOPD$1 = Object.getOwnPropertyDescriptor;
  var $TypeError$2 = TypeError;
  var polyfill$2 = function getPolyfill2() {
    if (!supportsDescriptors$1) {
      throw new $TypeError$2("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    }
    if (/a/mig.flags === "gim") {
      var descriptor = $gOPD$1(RegExp.prototype, "flags");
      if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
        return descriptor.get;
      }
    }
    return implementation$4;
  };
  var supportsDescriptors = defineProperties_1.supportsDescriptors;
  var getPolyfill$3 = polyfill$2;
  var gOPD$1 = Object.getOwnPropertyDescriptor;
  var defineProperty = Object.defineProperty;
  var TypeErr = TypeError;
  var getProto$1 = Object.getPrototypeOf;
  var regex = /a/;
  var shim$3 = function shimFlags() {
    if (!supportsDescriptors || !getProto$1) {
      throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    }
    var polyfill2 = getPolyfill$3();
    var proto = getProto$1(regex);
    var descriptor = gOPD$1(proto, "flags");
    if (!descriptor || descriptor.get !== polyfill2) {
      defineProperty(proto, "flags", {
        configurable: true,
        enumerable: false,
        get: polyfill2
      });
    }
    return polyfill2;
  };
  var define$1 = defineProperties_1;
  var callBind$6 = callBindExports$1;
  var implementation$3 = implementation$5;
  var getPolyfill$2 = polyfill$2;
  var shim$2 = shim$3;
  var flagsBound = callBind$6(implementation$3);
  define$1(flagsBound, {
    getPolyfill: getPolyfill$2,
    implementation: implementation$3,
    shim: shim$2
  });
  var regexp_prototype_flags = flagsBound;
  var toString$1 = {}.toString;
  var isarray = Array.isArray || function(arr) {
    return toString$1.call(arr) == "[object Array]";
  };
  var getDay = Date.prototype.getDay;
  var tryDateObject = function tryDateGetDayCall(value) {
    try {
      getDay.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$5 = Object.prototype.toString;
  var dateClass = "[object Date]";
  var hasToStringTag$4 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isDateObject = function isDateObject2(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    return hasToStringTag$4 ? tryDateObject(value) : toStr$5.call(value) === dateClass;
  };
  var strValue = String.prototype.valueOf;
  var tryStringObject = function tryStringObject2(value) {
    try {
      strValue.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$4 = Object.prototype.toString;
  var strClass = "[object String]";
  var hasToStringTag$3 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isString$3 = function isString2(value) {
    if (typeof value === "string") {
      return true;
    }
    if (typeof value !== "object") {
      return false;
    }
    return hasToStringTag$3 ? tryStringObject(value) : toStr$4.call(value) === strClass;
  };
  var numToStr = Number.prototype.toString;
  var tryNumberObject = function tryNumberObject2(value) {
    try {
      numToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$3 = Object.prototype.toString;
  var numClass = "[object Number]";
  var hasToStringTag$2 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isNumberObject = function isNumberObject2(value) {
    if (typeof value === "number") {
      return true;
    }
    if (typeof value !== "object") {
      return false;
    }
    return hasToStringTag$2 ? tryNumberObject(value) : toStr$3.call(value) === numClass;
  };
  var boolToStr = Boolean.prototype.toString;
  var tryBooleanObject = function booleanBrandCheck(value) {
    try {
      boolToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$2 = Object.prototype.toString;
  var boolClass = "[object Boolean]";
  var hasToStringTag$1 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var isBooleanObject = function isBoolean2(value) {
    if (typeof value === "boolean") {
      return true;
    }
    if (value === null || typeof value !== "object") {
      return false;
    }
    return hasToStringTag$1 && Symbol.toStringTag in value ? tryBooleanObject(value) : toStr$2.call(value) === boolClass;
  };
  var isSymbol$2 = { exports: {} };
  var toStr$1 = Object.prototype.toString;
  var hasSymbols$3 = hasSymbols$6();
  if (hasSymbols$3) {
    var symToStr = Symbol.prototype.toString;
    var symStringRegex = /^Symbol\(.*\)$/;
    var isSymbolObject = function isRealSymbolObject(value) {
      if (typeof value.valueOf() !== "symbol") {
        return false;
      }
      return symStringRegex.test(symToStr.call(value));
    };
    isSymbol$2.exports = function isSymbol2(value) {
      if (typeof value === "symbol") {
        return true;
      }
      if (toStr$1.call(value) !== "[object Symbol]") {
        return false;
      }
      try {
        return isSymbolObject(value);
      } catch (e) {
        return false;
      }
    };
  } else {
    isSymbol$2.exports = function isSymbol2(value) {
      return false;
    };
  }
  var isSymbolExports = isSymbol$2.exports;
  var isBigint = { exports: {} };
  if (typeof BigInt === "function") {
    var bigIntValueOf$1 = BigInt.prototype.valueOf;
    var tryBigInt = function tryBigIntObject(value) {
      try {
        bigIntValueOf$1.call(value);
        return true;
      } catch (e) {
      }
      return false;
    };
    isBigint.exports = function isBigInt2(value) {
      if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
        return false;
      }
      if (typeof value === "bigint") {
        return true;
      }
      return tryBigInt(value);
    };
  } else {
    isBigint.exports = function isBigInt2(value) {
      return false;
    };
  }
  var isBigintExports = isBigint.exports;
  var isString$2 = isString$3;
  var isNumber$1 = isNumberObject;
  var isBoolean$1 = isBooleanObject;
  var isSymbol$1 = isSymbolExports;
  var isBigInt$1 = isBigintExports;
  var whichBoxedPrimitive$1 = function whichBoxedPrimitive2(value) {
    if (value == null || typeof value !== "object" && typeof value !== "function") {
      return null;
    }
    if (isString$2(value)) {
      return "String";
    }
    if (isNumber$1(value)) {
      return "Number";
    }
    if (isBoolean$1(value)) {
      return "Boolean";
    }
    if (isSymbol$1(value)) {
      return "Symbol";
    }
    if (isBigInt$1(value)) {
      return "BigInt";
    }
  };
  var GetIntrinsic$6 = GetIntrinsic$7;
  var callBind$5 = callBindExports$1;
  var $indexOf$1 = callBind$5(GetIntrinsic$6("String.prototype.indexOf"));
  var callBound$8 = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic$6(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.")) {
      return callBind$5(intrinsic);
    }
    return intrinsic;
  };
  var $Map$3 = typeof Map === "function" && Map.prototype ? Map : null;
  var $Set$3 = typeof Set === "function" && Set.prototype ? Set : null;
  var exported$3;
  if (!$Map$3) {
    exported$3 = function isMap2(x2) {
      return false;
    };
  }
  var $mapHas$5 = $Map$3 ? Map.prototype.has : null;
  var $setHas$4 = $Set$3 ? Set.prototype.has : null;
  if (!exported$3 && !$mapHas$5) {
    exported$3 = function isMap2(x2) {
      return false;
    };
  }
  var isMap$3 = exported$3 || function isMap2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $mapHas$5.call(x2);
      if ($setHas$4) {
        try {
          $setHas$4.call(x2);
        } catch (e) {
          return true;
        }
      }
      return x2 instanceof $Map$3;
    } catch (e) {
    }
    return false;
  };
  var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
  var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
  var exported$2;
  if (!$Set$2) {
    exported$2 = function isSet2(x2) {
      return false;
    };
  }
  var $mapHas$4 = $Map$2 ? Map.prototype.has : null;
  var $setHas$3 = $Set$2 ? Set.prototype.has : null;
  if (!exported$2 && !$setHas$3) {
    exported$2 = function isSet2(x2) {
      return false;
    };
  }
  var isSet$3 = exported$2 || function isSet2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $setHas$3.call(x2);
      if ($mapHas$4) {
        try {
          $mapHas$4.call(x2);
        } catch (e) {
          return true;
        }
      }
      return x2 instanceof $Set$2;
    } catch (e) {
    }
    return false;
  };
  var $WeakMap$2 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
  var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
  var exported$1;
  if (!$WeakMap$2) {
    exported$1 = function isWeakMap2(x2) {
      return false;
    };
  }
  var $mapHas$3 = $WeakMap$2 ? $WeakMap$2.prototype.has : null;
  var $setHas$2 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
  if (!exported$1 && !$mapHas$3) {
    exported$1 = function isWeakMap2(x2) {
      return false;
    };
  }
  var isWeakmap = exported$1 || function isWeakMap2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $mapHas$3.call(x2, $mapHas$3);
      if ($setHas$2) {
        try {
          $setHas$2.call(x2, $setHas$2);
        } catch (e) {
          return true;
        }
      }
      return x2 instanceof $WeakMap$2;
    } catch (e) {
    }
    return false;
  };
  var $WeakMap$1 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
  var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
  var exported;
  if (!$WeakMap$1) {
    exported = function isWeakSet2(x2) {
      return false;
    };
  }
  var $mapHas$2 = $WeakMap$1 ? $WeakMap$1.prototype.has : null;
  var $setHas$1 = $WeakSet ? $WeakSet.prototype.has : null;
  if (!exported && !$setHas$1) {
    isWeakset = function isWeakSet2(x2) {
      return false;
    };
  }
  var isWeakset = exported || function isWeakSet2(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      $setHas$1.call(x2, $setHas$1);
      if ($mapHas$2) {
        try {
          $mapHas$2.call(x2, $mapHas$2);
        } catch (e) {
          return true;
        }
      }
      return x2 instanceof $WeakSet;
    } catch (e) {
    }
    return false;
  };
  var isMap$2 = isMap$3;
  var isSet$2 = isSet$3;
  var isWeakMap$1 = isWeakmap;
  var isWeakSet$1 = isWeakset;
  var whichCollection$1 = function whichCollection2(value) {
    if (value && typeof value === "object") {
      if (isMap$2(value)) {
        return "Map";
      }
      if (isSet$2(value)) {
        return "Set";
      }
      if (isWeakMap$1(value)) {
        return "WeakMap";
      }
      if (isWeakSet$1(value)) {
        return "WeakSet";
      }
    }
    return false;
  };
  var esGetIterator = { exports: {} };
  var GetIntrinsic$5;
  var hasRequiredGetIntrinsic$1;
  function requireGetIntrinsic$1() {
    if (hasRequiredGetIntrinsic$1)
      return GetIntrinsic$5;
    hasRequiredGetIntrinsic$1 = 1;
    var undefined$12;
    var $TypeError2 = TypeError;
    var $gOPD2 = Object.getOwnPropertyDescriptor;
    if ($gOPD2) {
      try {
        $gOPD2({}, "");
      } catch (e) {
        $gOPD2 = null;
      }
    }
    var throwTypeError2 = function() {
      throw new $TypeError2();
    };
    var ThrowTypeError2 = $gOPD2 ? function() {
      try {
        arguments.callee;
        return throwTypeError2;
      } catch (calleeThrows) {
        try {
          return $gOPD2(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError2;
        }
      }
    }() : throwTypeError2;
    var hasSymbols2 = hasSymbols$6();
    var getProto2 = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var generatorFunction2 = undefined$12;
    var asyncFunction2 = undefined$12;
    var asyncGenFunction2 = undefined$12;
    var TypedArray2 = typeof Uint8Array === "undefined" ? undefined$12 : getProto2(Uint8Array);
    var INTRINSICS2 = {
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer,
      "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer.prototype,
      "%ArrayIteratorPrototype%": hasSymbols2 ? getProto2([][Symbol.iterator]()) : undefined$12,
      "%ArrayPrototype%": Array.prototype,
      "%ArrayProto_entries%": Array.prototype.entries,
      "%ArrayProto_forEach%": Array.prototype.forEach,
      "%ArrayProto_keys%": Array.prototype.keys,
      "%ArrayProto_values%": Array.prototype.values,
      "%AsyncFromSyncIteratorPrototype%": undefined$12,
      "%AsyncFunction%": asyncFunction2,
      "%AsyncFunctionPrototype%": undefined$12,
      "%AsyncGenerator%": undefined$12,
      "%AsyncGeneratorFunction%": asyncGenFunction2,
      "%AsyncGeneratorPrototype%": undefined$12,
      "%AsyncIteratorPrototype%": undefined$12,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$12 : Atomics,
      "%Boolean%": Boolean,
      "%BooleanPrototype%": Boolean.prototype,
      "%DataView%": typeof DataView === "undefined" ? undefined$12 : DataView,
      "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$12 : DataView.prototype,
      "%Date%": Date,
      "%DatePrototype%": Date.prototype,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%ErrorPrototype%": Error.prototype,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%EvalErrorPrototype%": EvalError.prototype,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array,
      "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array.prototype,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array,
      "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array.prototype,
      "%Function%": Function,
      "%FunctionPrototype%": Function.prototype,
      "%Generator%": undefined$12,
      "%GeneratorFunction%": generatorFunction2,
      "%GeneratorPrototype%": undefined$12,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array,
      "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$12 : Int16Array,
      "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array,
      "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array.prototype,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$12,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$12,
      "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$12,
      "%Map%": typeof Map === "undefined" ? undefined$12 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%MapPrototype%": typeof Map === "undefined" ? undefined$12 : Map.prototype,
      "%Math%": Math,
      "%Number%": Number,
      "%NumberPrototype%": Number.prototype,
      "%Object%": Object,
      "%ObjectPrototype%": Object.prototype,
      "%ObjProto_toString%": Object.prototype.toString,
      "%ObjProto_valueOf%": Object.prototype.valueOf,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$12 : Promise,
      "%PromisePrototype%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype,
      "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype.then,
      "%Promise_all%": typeof Promise === "undefined" ? undefined$12 : Promise.all,
      "%Promise_reject%": typeof Promise === "undefined" ? undefined$12 : Promise.reject,
      "%Promise_resolve%": typeof Promise === "undefined" ? undefined$12 : Promise.resolve,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$12 : Proxy,
      "%RangeError%": RangeError,
      "%RangeErrorPrototype%": RangeError.prototype,
      "%ReferenceError%": ReferenceError,
      "%ReferenceErrorPrototype%": ReferenceError.prototype,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$12 : Reflect,
      "%RegExp%": RegExp,
      "%RegExpPrototype%": RegExp.prototype,
      "%Set%": typeof Set === "undefined" ? undefined$12 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SetPrototype%": typeof Set === "undefined" ? undefined$12 : Set.prototype,
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer,
      "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer.prototype,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols2 ? getProto2(""[Symbol.iterator]()) : undefined$12,
      "%StringPrototype%": String.prototype,
      "%Symbol%": hasSymbols2 ? Symbol : undefined$12,
      "%SymbolPrototype%": hasSymbols2 ? Symbol.prototype : undefined$12,
      "%SyntaxError%": SyntaxError,
      "%SyntaxErrorPrototype%": SyntaxError.prototype,
      "%ThrowTypeError%": ThrowTypeError2,
      "%TypedArray%": TypedArray2,
      "%TypedArrayPrototype%": TypedArray2 ? TypedArray2.prototype : undefined$12,
      "%TypeError%": $TypeError2,
      "%TypeErrorPrototype%": $TypeError2.prototype,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array,
      "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array.prototype,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray,
      "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray.prototype,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array,
      "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array.prototype,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array,
      "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array.prototype,
      "%URIError%": URIError,
      "%URIErrorPrototype%": URIError.prototype,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap,
      "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap.prototype,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet,
      "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet.prototype
    };
    var bind2 = functionBind;
    var $replace2 = bind2.call(Function.call, String.prototype.replace);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
      var result2 = [];
      $replace2(string, rePropName2, function(match2, number2, quote2, subString) {
        result2[result2.length] = quote2 ? $replace2(subString, reEscapeChar2, "$1") : number2 || match2;
      });
      return result2;
    };
    var getBaseIntrinsic2 = function getBaseIntrinsic3(name, allowMissing) {
      if (!(name in INTRINSICS2)) {
        throw new SyntaxError("intrinsic " + name + " does not exist!");
      }
      if (typeof INTRINSICS2[name] === "undefined" && !allowMissing) {
        throw new $TypeError2("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return INTRINSICS2[name];
    };
    GetIntrinsic$5 = function GetIntrinsic2(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath2(name);
      var value = getBaseIntrinsic2("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
      for (var i2 = 1; i2 < parts.length; i2 += 1) {
        if (value != null) {
          if ($gOPD2 && i2 + 1 >= parts.length) {
            var desc = $gOPD2(value, parts[i2]);
            if (!allowMissing && !(parts[i2] in value)) {
              throw new $TypeError2("base intrinsic for " + name + " exists, but the property is not available.");
            }
            value = desc ? desc.get || desc.value : value[parts[i2]];
          } else {
            value = value[parts[i2]];
          }
        }
      }
      return value;
    };
    return GetIntrinsic$5;
  }
  var callBind$4 = { exports: {} };
  var hasRequiredCallBind$1;
  function requireCallBind$1() {
    if (hasRequiredCallBind$1)
      return callBind$4.exports;
    hasRequiredCallBind$1 = 1;
    var bind2 = functionBind;
    var GetIntrinsic2 = requireGetIntrinsic$1();
    var $Function2 = GetIntrinsic2("%Function%");
    var $apply = $Function2.apply;
    var $call = $Function2.call;
    callBind$4.exports = function callBind2() {
      return bind2.apply($call, arguments);
    };
    callBind$4.exports.apply = function applyBind() {
      return bind2.apply($apply, arguments);
    };
    return callBind$4.exports;
  }
  var callBound$7;
  var hasRequiredCallBound$1;
  function requireCallBound$1() {
    if (hasRequiredCallBound$1)
      return callBound$7;
    hasRequiredCallBound$1 = 1;
    var GetIntrinsic2 = requireGetIntrinsic$1();
    var callBind2 = requireCallBind$1();
    var $indexOf2 = callBind2(GetIntrinsic2("String.prototype.indexOf"));
    callBound$7 = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic2(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf2(name, ".prototype.")) {
        return callBind2(intrinsic);
      }
      return intrinsic;
    };
    return callBound$7;
  }
  var isArguments$1 = isArguments$2;
  if (hasSymbols$6() || shams()) {
    var $iterator = Symbol.iterator;
    esGetIterator.exports = function getIterator2(iterable) {
      if (iterable != null && typeof iterable[$iterator] !== "undefined") {
        return iterable[$iterator]();
      }
      if (isArguments$1(iterable)) {
        return Array.prototype[$iterator].call(iterable);
      }
    };
  } else {
    var isArray$3 = isarray;
    var isString$1 = isString$3;
    var GetIntrinsic$4 = requireGetIntrinsic$1();
    var $Map$1 = GetIntrinsic$4("%Map%", true);
    var $Set$1 = GetIntrinsic$4("%Set%", true);
    var callBound$6 = requireCallBound$1();
    var $arrayPush = callBound$6("Array.prototype.push");
    var $charCodeAt = callBound$6("String.prototype.charCodeAt");
    var $stringSlice = callBound$6("String.prototype.slice");
    var advanceStringIndex = function advanceStringIndex2(S2, index) {
      var length = S2.length;
      if (index + 1 >= length) {
        return index + 1;
      }
      var first = $charCodeAt(S2, index);
      if (first < 55296 || first > 56319) {
        return index + 1;
      }
      var second = $charCodeAt(S2, index + 1);
      if (second < 56320 || second > 57343) {
        return index + 1;
      }
      return index + 2;
    };
    var getArrayIterator = function getArrayIterator2(arraylike) {
      var i2 = 0;
      return {
        next: function next() {
          var done = i2 >= arraylike.length;
          var value;
          if (!done) {
            value = arraylike[i2];
            i2 += 1;
          }
          return {
            done,
            value
          };
        }
      };
    };
    var getNonCollectionIterator = function getNonCollectionIterator2(iterable) {
      if (isArray$3(iterable) || isArguments$1(iterable)) {
        return getArrayIterator(iterable);
      }
      if (isString$1(iterable)) {
        var i2 = 0;
        return {
          next: function next() {
            var nextIndex = advanceStringIndex(iterable, i2);
            var value = $stringSlice(iterable, i2, nextIndex);
            i2 = nextIndex;
            return {
              done: nextIndex > iterable.length,
              value
            };
          }
        };
      }
    };
    if (!$Map$1 && !$Set$1) {
      esGetIterator.exports = getNonCollectionIterator;
    } else {
      var isMap$1 = isMap$3;
      var isSet$1 = isSet$3;
      var $mapForEach = callBound$6("Map.prototype.forEach", true);
      var $setForEach = callBound$6("Set.prototype.forEach", true);
      if (typeof process === "undefined" || !process.versions || !process.versions.node) {
        var $mapIterator = callBound$6("Map.prototype.iterator", true);
        var $setIterator = callBound$6("Set.prototype.iterator", true);
        var getStopIterationIterator = function(iterator2) {
          var done = false;
          return {
            next: function next() {
              try {
                return {
                  done,
                  value: done ? void 0 : iterator2.next()
                };
              } catch (e) {
                done = true;
                return {
                  done: true,
                  value: void 0
                };
              }
            }
          };
        };
      }
      var $mapAtAtIterator = callBound$6("Map.prototype.@@iterator", true) || callBound$6("Map.prototype._es6-shim iterator_", true);
      var $setAtAtIterator = callBound$6("Set.prototype.@@iterator", true) || callBound$6("Set.prototype._es6-shim iterator_", true);
      var getCollectionIterator = function getCollectionIterator2(iterable) {
        if (isMap$1(iterable)) {
          if ($mapIterator) {
            return getStopIterationIterator($mapIterator(iterable));
          }
          if ($mapAtAtIterator) {
            return $mapAtAtIterator(iterable);
          }
          if ($mapForEach) {
            var entries = [];
            $mapForEach(iterable, function(v2, k) {
              $arrayPush(entries, [k, v2]);
            });
            return getArrayIterator(entries);
          }
        }
        if (isSet$1(iterable)) {
          if ($setIterator) {
            return getStopIterationIterator($setIterator(iterable));
          }
          if ($setAtAtIterator) {
            return $setAtAtIterator(iterable);
          }
          if ($setForEach) {
            var values = [];
            $setForEach(iterable, function(v2) {
              $arrayPush(values, v2);
            });
            return getArrayIterator(values);
          }
        }
      };
      esGetIterator.exports = function getIterator2(iterable) {
        return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
      };
    }
  }
  var esGetIteratorExports = esGetIterator.exports;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var match = String.prototype.match;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var inspectCustom = require$$0$1.custom;
  var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
  var objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean") {
      throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      return String(obj);
    }
    if (typeof obj === "bigint") {
      return String(obj) + "n";
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray$2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect2(value, from, noIndent) {
      if (from) {
        seen = seen.slice();
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function") {
      var name = nameOf(obj);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]";
    }
    if (isSymbol(obj)) {
      var symString = Symbol.prototype.toString.call(obj);
      return typeof obj === "object" ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s2 = "<" + String(obj.nodeName).toLowerCase();
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s2 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s2 += "...";
      }
      s2 += "</" + String(obj.nodeName).toLowerCase() + ">";
      return s2;
    }
    if (isArray$2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect2);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + xs.join(", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect2);
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + parts.join(", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
        return obj[inspectSymbol]();
      } else if (typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
      });
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      setForEach.call(obj, function(value) {
        setParts.push(inspect2(value, obj));
      });
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isNumber(obj)) {
      return markBoxed(inspect2(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect2(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
      return markBoxed(inspect2(String(obj)));
    }
    if (!isDate$1(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect2);
      if (ys.length === 0) {
        return "{}";
      }
      if (indent) {
        return "{" + indentedJoin(ys, indent) + "}";
      }
      return "{ " + ys.join(", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s2, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s2 + quoteChar;
  }
  function quote(s2) {
    return String(s2).replace(/"/g, "&quot;");
  }
  function isArray$2(obj) {
    return toStr(obj) === "[object Array]";
  }
  function isDate$1(obj) {
    return toStr(obj) === "[object Date]";
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]";
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]";
  }
  function isSymbol(obj) {
    return toStr(obj) === "[object Symbol]";
  }
  function isString(obj) {
    return toStr(obj) === "[object String]";
  }
  function isNumber(obj) {
    return toStr(obj) === "[object Number]";
  }
  function isBigInt(obj) {
    return toStr(obj) === "[object BigInt]";
  }
  function isBoolean(obj) {
    return toStr(obj) === "[object Boolean]";
  }
  var hasOwn$3 = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn$3.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f2) {
    if (f2.name) {
      return f2.name;
    }
    var m2 = match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf(xs, x2) {
    if (xs.indexOf) {
      return xs.indexOf(x2);
    }
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x2) {
        return i2;
      }
    }
    return -1;
  }
  function isMap(x2) {
    if (!mapSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      mapSize.call(x2);
      try {
        setSize.call(x2);
      } catch (s2) {
        return true;
      }
      return x2 instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x2) {
    if (!weakMapHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x2, weakMapHas);
      try {
        weakSetHas.call(x2, weakSetHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isSet(x2) {
    if (!setSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      setSize.call(x2);
      try {
        mapSize.call(x2);
      } catch (m2) {
        return true;
      }
      return x2 instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x2) {
    if (!weakSetHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x2, weakSetHas);
      try {
        weakMapHas.call(x2, weakMapHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
      return true;
    }
    return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    var s2 = str.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s2, "single", opts);
  }
  function lowbyte(c2) {
    var n = c2.charCodeAt(0);
    var x2 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x2) {
      return "\\" + x2;
    }
    return "\\x" + (n < 16 ? "0" : "") + n.toString(16);
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (indexOf(xs[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = Array(opts.indent + 1).join(" ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: Array(depth + 1).join(baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + xs.join("," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect2) {
    var isArr = isArray$2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs[i2] = has(obj, i2) ? inspect2(obj[i2], obj) : "";
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (/[^\w$]/.test(key)) {
        xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect2(obj[key], obj));
      }
    }
    return xs;
  }
  var GetIntrinsic$3 = GetIntrinsic$7;
  var callBound$5 = callBound$8;
  var inspect = objectInspect;
  var $TypeError$1 = GetIntrinsic$3("%TypeError%");
  var $WeakMap = GetIntrinsic$3("%WeakMap%", true);
  var $Map = GetIntrinsic$3("%Map%", true);
  var $push$1 = callBound$5("Array.prototype.push");
  var $weakMapGet = callBound$5("WeakMap.prototype.get", true);
  var $weakMapSet = callBound$5("WeakMap.prototype.set", true);
  var $weakMapHas = callBound$5("WeakMap.prototype.has", true);
  var $mapGet$1 = callBound$5("Map.prototype.get", true);
  var $mapSet = callBound$5("Map.prototype.set", true);
  var $mapHas$1 = callBound$5("Map.prototype.has", true);
  var objectGet = function(objects, key) {
    for (var i2 = 0; i2 < objects.length; i2 += 1) {
      if (objects[i2].key === key) {
        return objects[i2].value;
      }
    }
  };
  var objectSet = function(objects, key, value) {
    for (var i2 = 0; i2 < objects.length; i2 += 1) {
      if (objects[i2].key === key) {
        objects[i2].value = value;
        return;
      }
    }
    $push$1(objects, {
      key,
      value
    });
  };
  var objectHas = function(objects, key) {
    for (var i2 = 0; i2 < objects.length; i2 += 1) {
      if (objects[i2].key === key) {
        return true;
      }
    }
    return false;
  };
  var sideChannel = function getSideChannel2() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError$1("Side channel does not contain " + inspect(key));
        }
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet$1($m, key);
          }
        } else {
          if ($o) {
            return objectGet($o, key);
          }
        }
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas$1($m, key);
          }
        } else {
          if ($o) {
            return objectHas($o, key);
          }
        }
        return false;
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        } else {
          if (!$o) {
            $o = [];
          }
          objectSet($o, key, value);
        }
      }
    };
    return channel;
  };
  var hasOwn$2 = Object.prototype.hasOwnProperty;
  var toString = Object.prototype.toString;
  var foreach = function forEach2(obj, fn, ctx) {
    if (toString.call(fn) !== "[object Function]") {
      throw new TypeError("iterator must be a function");
    }
    var l = obj.length;
    if (l === +l) {
      for (var i2 = 0; i2 < l; i2++) {
        fn.call(ctx, obj[i2], i2, obj);
      }
    } else {
      for (var k in obj) {
        if (hasOwn$2.call(obj, k)) {
          fn.call(ctx, obj[k], k, obj);
        }
      }
    }
  };
  var arrayFilter = function(arr, fn, self2) {
    if (arr.filter)
      return arr.filter(fn, self2);
    if (void 0 === arr || null === arr)
      throw new TypeError();
    if ("function" != typeof fn)
      throw new TypeError();
    var ret = [];
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (!hasOwn$1.call(arr, i2))
        continue;
      var val = arr[i2];
      if (fn.call(self2, val, i2, arr))
        ret.push(val);
    }
    return ret;
  };
  var hasOwn$1 = Object.prototype.hasOwnProperty;
  var filter = arrayFilter;
  var availableTypedArrays$1 = function availableTypedArrays2() {
    return filter([
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ], function(typedArray) {
      return typeof commonjsGlobal[typedArray] === "function";
    });
  };
  var getOwnPropertyDescriptor$1;
  var hasRequiredGetOwnPropertyDescriptor$1;
  function requireGetOwnPropertyDescriptor$1() {
    if (hasRequiredGetOwnPropertyDescriptor$1)
      return getOwnPropertyDescriptor$1;
    hasRequiredGetOwnPropertyDescriptor$1 = 1;
    var GetIntrinsic2 = GetIntrinsic$7;
    var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%");
    if ($gOPD2) {
      try {
        $gOPD2([], "length");
      } catch (e) {
        $gOPD2 = null;
      }
    }
    getOwnPropertyDescriptor$1 = $gOPD2;
    return getOwnPropertyDescriptor$1;
  }
  var GetIntrinsic$2;
  var hasRequiredGetIntrinsic;
  function requireGetIntrinsic() {
    if (hasRequiredGetIntrinsic)
      return GetIntrinsic$2;
    hasRequiredGetIntrinsic = 1;
    var undefined$12;
    var $TypeError2 = TypeError;
    var $gOPD2 = Object.getOwnPropertyDescriptor;
    if ($gOPD2) {
      try {
        $gOPD2({}, "");
      } catch (e) {
        $gOPD2 = null;
      }
    }
    var throwTypeError2 = function() {
      throw new $TypeError2();
    };
    var ThrowTypeError2 = $gOPD2 ? function() {
      try {
        arguments.callee;
        return throwTypeError2;
      } catch (calleeThrows) {
        try {
          return $gOPD2(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError2;
        }
      }
    }() : throwTypeError2;
    var hasSymbols2 = hasSymbols$6();
    var getProto2 = Object.getPrototypeOf || function(x2) {
      return x2.__proto__;
    };
    var generatorFunction2 = undefined$12;
    var asyncFunction2 = undefined$12;
    var asyncGenFunction2 = undefined$12;
    var TypedArray2 = typeof Uint8Array === "undefined" ? undefined$12 : getProto2(Uint8Array);
    var INTRINSICS2 = {
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer,
      "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer.prototype,
      "%ArrayIteratorPrototype%": hasSymbols2 ? getProto2([][Symbol.iterator]()) : undefined$12,
      "%ArrayPrototype%": Array.prototype,
      "%ArrayProto_entries%": Array.prototype.entries,
      "%ArrayProto_forEach%": Array.prototype.forEach,
      "%ArrayProto_keys%": Array.prototype.keys,
      "%ArrayProto_values%": Array.prototype.values,
      "%AsyncFromSyncIteratorPrototype%": undefined$12,
      "%AsyncFunction%": asyncFunction2,
      "%AsyncFunctionPrototype%": undefined$12,
      "%AsyncGenerator%": undefined$12,
      "%AsyncGeneratorFunction%": asyncGenFunction2,
      "%AsyncGeneratorPrototype%": undefined$12,
      "%AsyncIteratorPrototype%": undefined$12,
      "%Atomics%": typeof Atomics === "undefined" ? undefined$12 : Atomics,
      "%Boolean%": Boolean,
      "%BooleanPrototype%": Boolean.prototype,
      "%DataView%": typeof DataView === "undefined" ? undefined$12 : DataView,
      "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$12 : DataView.prototype,
      "%Date%": Date,
      "%DatePrototype%": Date.prototype,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%ErrorPrototype%": Error.prototype,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%EvalErrorPrototype%": EvalError.prototype,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array,
      "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array.prototype,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array,
      "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array.prototype,
      "%Function%": Function,
      "%FunctionPrototype%": Function.prototype,
      "%Generator%": undefined$12,
      "%GeneratorFunction%": generatorFunction2,
      "%GeneratorPrototype%": undefined$12,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array,
      "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined$12 : Int16Array,
      "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$12 : Int8Array.prototype,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array,
      "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array.prototype,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$12,
      "%JSON%": typeof JSON === "object" ? JSON : undefined$12,
      "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$12,
      "%Map%": typeof Map === "undefined" ? undefined$12 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%MapPrototype%": typeof Map === "undefined" ? undefined$12 : Map.prototype,
      "%Math%": Math,
      "%Number%": Number,
      "%NumberPrototype%": Number.prototype,
      "%Object%": Object,
      "%ObjectPrototype%": Object.prototype,
      "%ObjProto_toString%": Object.prototype.toString,
      "%ObjProto_valueOf%": Object.prototype.valueOf,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined$12 : Promise,
      "%PromisePrototype%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype,
      "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype.then,
      "%Promise_all%": typeof Promise === "undefined" ? undefined$12 : Promise.all,
      "%Promise_reject%": typeof Promise === "undefined" ? undefined$12 : Promise.reject,
      "%Promise_resolve%": typeof Promise === "undefined" ? undefined$12 : Promise.resolve,
      "%Proxy%": typeof Proxy === "undefined" ? undefined$12 : Proxy,
      "%RangeError%": RangeError,
      "%RangeErrorPrototype%": RangeError.prototype,
      "%ReferenceError%": ReferenceError,
      "%ReferenceErrorPrototype%": ReferenceError.prototype,
      "%Reflect%": typeof Reflect === "undefined" ? undefined$12 : Reflect,
      "%RegExp%": RegExp,
      "%RegExpPrototype%": RegExp.prototype,
      "%Set%": typeof Set === "undefined" ? undefined$12 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$12 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SetPrototype%": typeof Set === "undefined" ? undefined$12 : Set.prototype,
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer,
      "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer.prototype,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols2 ? getProto2(""[Symbol.iterator]()) : undefined$12,
      "%StringPrototype%": String.prototype,
      "%Symbol%": hasSymbols2 ? Symbol : undefined$12,
      "%SymbolPrototype%": hasSymbols2 ? Symbol.prototype : undefined$12,
      "%SyntaxError%": SyntaxError,
      "%SyntaxErrorPrototype%": SyntaxError.prototype,
      "%ThrowTypeError%": ThrowTypeError2,
      "%TypedArray%": TypedArray2,
      "%TypedArrayPrototype%": TypedArray2 ? TypedArray2.prototype : undefined$12,
      "%TypeError%": $TypeError2,
      "%TypeErrorPrototype%": $TypeError2.prototype,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array,
      "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array.prototype,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray,
      "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray.prototype,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array,
      "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array.prototype,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array,
      "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array.prototype,
      "%URIError%": URIError,
      "%URIErrorPrototype%": URIError.prototype,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap,
      "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap.prototype,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet,
      "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet.prototype
    };
    var bind2 = functionBind;
    var $replace2 = bind2.call(Function.call, String.prototype.replace);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
      var result2 = [];
      $replace2(string, rePropName2, function(match2, number2, quote2, subString) {
        result2[result2.length] = quote2 ? $replace2(subString, reEscapeChar2, "$1") : number2 || match2;
      });
      return result2;
    };
    var getBaseIntrinsic2 = function getBaseIntrinsic3(name, allowMissing) {
      if (!(name in INTRINSICS2)) {
        throw new SyntaxError("intrinsic " + name + " does not exist!");
      }
      if (typeof INTRINSICS2[name] === "undefined" && !allowMissing) {
        throw new $TypeError2("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return INTRINSICS2[name];
    };
    GetIntrinsic$2 = function GetIntrinsic2(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath2(name);
      var value = getBaseIntrinsic2("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
      for (var i2 = 1; i2 < parts.length; i2 += 1) {
        if (value != null) {
          if ($gOPD2 && i2 + 1 >= parts.length) {
            var desc = $gOPD2(value, parts[i2]);
            if (!allowMissing && !(parts[i2] in value)) {
              throw new $TypeError2("base intrinsic for " + name + " exists, but the property is not available.");
            }
            value = desc ? desc.get || desc.value : value[parts[i2]];
          } else {
            value = value[parts[i2]];
          }
        }
      }
      return value;
    };
    return GetIntrinsic$2;
  }
  var callBind$3 = { exports: {} };
  var hasRequiredCallBind;
  function requireCallBind() {
    if (hasRequiredCallBind)
      return callBind$3.exports;
    hasRequiredCallBind = 1;
    var bind2 = functionBind;
    var GetIntrinsic2 = requireGetIntrinsic();
    var $Function2 = GetIntrinsic2("%Function%");
    var $apply = $Function2.apply;
    var $call = $Function2.call;
    callBind$3.exports = function callBind2() {
      return bind2.apply($call, arguments);
    };
    callBind$3.exports.apply = function applyBind() {
      return bind2.apply($apply, arguments);
    };
    return callBind$3.exports;
  }
  var callBound$4;
  var hasRequiredCallBound;
  function requireCallBound() {
    if (hasRequiredCallBound)
      return callBound$4;
    hasRequiredCallBound = 1;
    var GetIntrinsic2 = requireGetIntrinsic();
    var callBind2 = requireCallBind();
    var $indexOf2 = callBind2(GetIntrinsic2("String.prototype.indexOf"));
    callBound$4 = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic2(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf2(name, ".prototype.")) {
        return callBind2(intrinsic);
      }
      return intrinsic;
    };
    return callBound$4;
  }
  var getOwnPropertyDescriptor;
  var hasRequiredGetOwnPropertyDescriptor;
  function requireGetOwnPropertyDescriptor() {
    if (hasRequiredGetOwnPropertyDescriptor)
      return getOwnPropertyDescriptor;
    hasRequiredGetOwnPropertyDescriptor = 1;
    var GetIntrinsic2 = requireGetIntrinsic();
    var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%");
    if ($gOPD2) {
      try {
        $gOPD2([], "length");
      } catch (e) {
        $gOPD2 = null;
      }
    }
    getOwnPropertyDescriptor = $gOPD2;
    return getOwnPropertyDescriptor;
  }
  var isTypedArray$1;
  var hasRequiredIsTypedArray;
  function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
      return isTypedArray$1;
    hasRequiredIsTypedArray = 1;
    var forEach2 = foreach;
    var availableTypedArrays2 = availableTypedArrays$1;
    var callBound2 = requireCallBound();
    var $toString2 = callBound2("Object.prototype.toString");
    var hasSymbols2 = hasSymbols$6();
    var hasToStringTag2 = hasSymbols2 && typeof Symbol.toStringTag === "symbol";
    var typedArrays2 = availableTypedArrays2();
    var $indexOf2 = callBound2("Array.prototype.indexOf", true) || function indexOf2(array, value) {
      for (var i2 = 0; i2 < array.length; i2 += 1) {
        if (array[i2] === value) {
          return i2;
        }
      }
      return -1;
    };
    var $slice2 = callBound2("String.prototype.slice");
    var toStrTags2 = {};
    var gOPD2 = requireGetOwnPropertyDescriptor();
    var getPrototypeOf2 = Object.getPrototypeOf;
    if (hasToStringTag2 && gOPD2 && getPrototypeOf2) {
      forEach2(typedArrays2, function(typedArray) {
        var arr = new commonjsGlobal[typedArray]();
        if (!(Symbol.toStringTag in arr)) {
          throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
        }
        var proto = getPrototypeOf2(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf2(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        toStrTags2[typedArray] = descriptor.get;
      });
    }
    var tryTypedArrays2 = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach2(toStrTags2, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    isTypedArray$1 = function isTypedArray2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag2) {
        var tag = $slice2($toString2(value), 8, -1);
        return $indexOf2(typedArrays2, tag) > -1;
      }
      if (!gOPD2) {
        return false;
      }
      return tryTypedArrays2(value);
    };
    return isTypedArray$1;
  }
  var forEach = foreach;
  var availableTypedArrays = availableTypedArrays$1;
  var callBound$3 = callBound$8;
  var $toString = callBound$3("Object.prototype.toString");
  var hasSymbols$2 = hasSymbols$6();
  var hasToStringTag = hasSymbols$2 && typeof Symbol.toStringTag === "symbol";
  var typedArrays = availableTypedArrays();
  var $slice = callBound$3("String.prototype.slice");
  var toStrTags = {};
  var gOPD = requireGetOwnPropertyDescriptor$1();
  var getPrototypeOf = Object.getPrototypeOf;
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      if (typeof commonjsGlobal[typedArray] === "function") {
        var arr = new commonjsGlobal[typedArray]();
        if (!(Symbol.toStringTag in arr)) {
          throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
        }
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach(toStrTags, function(getter, typedArray) {
      if (!foundName) {
        try {
          var name = getter.call(value);
          if (name === typedArray) {
            foundName = name;
          }
        } catch (e) {
        }
      }
    });
    return foundName;
  };
  var isTypedArray = requireIsTypedArray();
  var whichTypedArray$1 = function whichTypedArray2(value) {
    if (!isTypedArray(value)) {
      return false;
    }
    if (!hasToStringTag) {
      return $slice($toString(value), 8, -1);
    }
    return tryTypedArrays(value);
  };
  var callBind$2 = { exports: {} };
  var bind$1 = functionBind;
  var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return window["notthere"];
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols$1 = hasSymbols$6();
  var getProto = Object.getPrototypeOf || function(x2) {
    return x2.__proto__;
  };
  var asyncGenFunction = getEvalledConstructor();
  var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined$1;
  var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined$1;
  var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": getEvalledConstructor(),
    "%AsyncGenerator%": asyncGenFunctionPrototype,
    "%AsyncGeneratorFunction%": asyncGenFunction,
    "%AsyncIteratorPrototype%": asyncGenPrototype ? getProto(asyncGenPrototype) : undefined$1,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": getEvalledConstructor(),
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols$1 ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = functionBind;
  var hasOwn = src;
  var $concat = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var result2 = [];
    $replace(string, rePropName, function(match2, number2, quote2, subString) {
      result2[result2.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number2 || match2;
    });
    return result2;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (!allowMissing && !(part in value)) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  (function(module2) {
    var bind2 = functionBind;
    var GetIntrinsic2 = getIntrinsic;
    var $apply = GetIntrinsic2("%Function.prototype.apply%");
    var $call = GetIntrinsic2("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind2() {
      return $reflectApply(bind2, $call, arguments);
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind$2);
  var callBindExports = callBind$2.exports;
  var GetIntrinsic$1 = getIntrinsic;
  var callBind$1 = callBindExports;
  var $indexOf = callBind$1(GetIntrinsic$1("String.prototype.indexOf"));
  var callBound$2 = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic$1(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind$1(intrinsic);
    }
    return intrinsic;
  };
  var keys = objectKeys$1;
  var canBeObject = function(obj) {
    return typeof obj !== "undefined" && obj !== null;
  };
  var hasSymbols = shams();
  var callBound$1 = callBound$2;
  var toObject = Object;
  var $push = callBound$1("Array.prototype.push");
  var $propIsEnumerable = callBound$1("Object.prototype.propertyIsEnumerable");
  var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
  var implementation$2 = function assign2(target, source1) {
    if (!canBeObject(target)) {
      throw new TypeError("target must be an object");
    }
    var objTarget = toObject(target);
    var s2, source, i2, props, syms, value, key;
    for (s2 = 1; s2 < arguments.length; ++s2) {
      source = toObject(arguments[s2]);
      props = keys(source);
      var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
      if (getSymbols) {
        syms = getSymbols(source);
        for (i2 = 0; i2 < syms.length; ++i2) {
          key = syms[i2];
          if ($propIsEnumerable(source, key)) {
            $push(props, key);
          }
        }
      }
      for (i2 = 0; i2 < props.length; ++i2) {
        key = props[i2];
        value = source[key];
        if ($propIsEnumerable(source, key)) {
          objTarget[key] = value;
        }
      }
    }
    return objTarget;
  };
  var implementation$1 = implementation$2;
  var lacksProperEnumerationOrder = function() {
    if (!Object.assign) {
      return false;
    }
    var str = "abcdefghijklmnopqrst";
    var letters = str.split("");
    var map2 = {};
    for (var i2 = 0; i2 < letters.length; ++i2) {
      map2[letters[i2]] = letters[i2];
    }
    var obj = Object.assign({}, map2);
    var actual = "";
    for (var k in obj) {
      actual += k;
    }
    return str !== actual;
  };
  var assignHasPendingExceptions = function() {
    if (!Object.assign || !Object.preventExtensions) {
      return false;
    }
    var thrower = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(thrower, "xy");
    } catch (e) {
      return thrower[1] === "y";
    }
    return false;
  };
  var polyfill$1 = function getPolyfill2() {
    if (!Object.assign) {
      return implementation$1;
    }
    if (lacksProperEnumerationOrder()) {
      return implementation$1;
    }
    if (assignHasPendingExceptions()) {
      return implementation$1;
    }
    return Object.assign;
  };
  var define = defineProperties_1;
  var getPolyfill$1 = polyfill$1;
  var shim$1 = function shimAssign() {
    var polyfill2 = getPolyfill$1();
    define(
      Object,
      { assign: polyfill2 },
      { assign: function() {
        return Object.assign !== polyfill2;
      } }
    );
    return polyfill2;
  };
  var defineProperties = defineProperties_1;
  var callBind = callBindExports;
  var implementation = implementation$2;
  var getPolyfill = polyfill$1;
  var shim = shim$1;
  var polyfill = callBind.apply(getPolyfill());
  var bound = function assign2(target, source1) {
    return polyfill(Object, arguments);
  };
  defineProperties(bound, {
    getPolyfill,
    implementation,
    shim
  });
  var object_assign = bound;
  var objectKeys = objectKeys$1;
  var isArguments = isArguments$2;
  var is = objectIs;
  var isRegex = isRegex$1;
  var flags = regexp_prototype_flags;
  var isArray$1 = isarray;
  var isDate = isDateObject;
  var whichBoxedPrimitive = whichBoxedPrimitive$1;
  var GetIntrinsic = GetIntrinsic$7;
  var callBound = callBound$8;
  var whichCollection = whichCollection$1;
  var getIterator = esGetIteratorExports;
  var getSideChannel = sideChannel;
  var whichTypedArray = whichTypedArray$1;
  var assign = object_assign;
  var $getTime = callBound("Date.prototype.getTime");
  var gPO = Object.getPrototypeOf;
  var $objToString = callBound("Object.prototype.toString");
  var $Set = GetIntrinsic("%Set%", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSize = callBound("Map.prototype.size", true);
  var $setAdd = callBound("Set.prototype.add", true);
  var $setDelete = callBound("Set.prototype.delete", true);
  var $setHas = callBound("Set.prototype.has", true);
  var $setSize = callBound("Set.prototype.size", true);
  function setHasEqualElement(set, val1, opts, channel) {
    var i2 = getIterator(set);
    var result2;
    while ((result2 = i2.next()) && !result2.done) {
      if (internalDeepEqual(val1, result2.value, opts, channel)) {
        $setDelete(set, result2.value);
        return true;
      }
    }
    return false;
  }
  function findLooseMatchingPrimitives(prim) {
    if (typeof prim === "undefined") {
      return null;
    }
    if (typeof prim === "object") {
      return void 0;
    }
    if (typeof prim === "symbol") {
      return false;
    }
    if (typeof prim === "string" || typeof prim === "number") {
      return +prim === +prim;
    }
    return true;
  }
  function mapMightHaveLoosePrim(a2, b, prim, item, opts, channel) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    var curB = $mapGet(b, altValue);
    var looseOpts = assign({}, opts, { strict: false });
    if (typeof curB === "undefined" && !$mapHas(b, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
      return false;
    }
    return !$mapHas(a2, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
  }
  function setMightHaveLoosePrim(a2, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    return $setHas(b, altValue) && !$setHas(a2, altValue);
  }
  function mapHasEqualEntry(set, map2, key1, item1, opts, channel) {
    var i2 = getIterator(set);
    var result2;
    var key2;
    while ((result2 = i2.next()) && !result2.done) {
      key2 = result2.value;
      if (
        // eslint-disable-next-line no-use-before-define
        internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map2, key2), opts, channel)
      ) {
        $setDelete(set, key2);
        return true;
      }
    }
    return false;
  }
  function internalDeepEqual(actual, expected, options, channel) {
    var opts = options || {};
    if (opts.strict ? is(actual, expected) : actual === expected) {
      return true;
    }
    var actualBoxed = whichBoxedPrimitive(actual);
    var expectedBoxed = whichBoxedPrimitive(expected);
    if (actualBoxed !== expectedBoxed) {
      return false;
    }
    if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
      return opts.strict ? is(actual, expected) : actual == expected;
    }
    var hasActual = channel.has(actual);
    var hasExpected = channel.has(expected);
    var sentinel;
    if (hasActual && hasExpected) {
      if (channel.get(actual) === channel.get(expected)) {
        return true;
      }
    } else {
      sentinel = {};
    }
    if (!hasActual) {
      channel.set(actual, sentinel);
    }
    if (!hasExpected) {
      channel.set(expected, sentinel);
    }
    return objEquiv(actual, expected, opts, channel);
  }
  function isBuffer$1(x2) {
    if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
      return false;
    }
    if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
      return false;
    }
    if (x2.length > 0 && typeof x2[0] !== "number") {
      return false;
    }
    return !!(x2.constructor && x2.constructor.isBuffer && x2.constructor.isBuffer(x2));
  }
  function setEquiv(a2, b, opts, channel) {
    if ($setSize(a2) !== $setSize(b)) {
      return false;
    }
    var iA = getIterator(a2);
    var iB = getIterator(b);
    var resultA;
    var resultB;
    var set;
    while ((resultA = iA.next()) && !resultA.done) {
      if (resultA.value && typeof resultA.value === "object") {
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, resultA.value);
      } else if (!$setHas(b, resultA.value)) {
        if (opts.strict) {
          return false;
        }
        if (!setMightHaveLoosePrim(a2, b, resultA.value)) {
          return false;
        }
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, resultA.value);
      }
    }
    if (set) {
      while ((resultB = iB.next()) && !resultB.done) {
        if (resultB.value && typeof resultB.value === "object") {
          if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
            return false;
          }
        } else if (!opts.strict && !$setHas(a2, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
          return false;
        }
      }
      return $setSize(set) === 0;
    }
    return true;
  }
  function mapEquiv(a2, b, opts, channel) {
    if ($mapSize(a2) !== $mapSize(b)) {
      return false;
    }
    var iA = getIterator(a2);
    var iB = getIterator(b);
    var resultA;
    var resultB;
    var set;
    var key;
    var item1;
    var item2;
    while ((resultA = iA.next()) && !resultA.done) {
      key = resultA.value[0];
      item1 = resultA.value[1];
      if (key && typeof key === "object") {
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, key);
      } else {
        item2 = $mapGet(b, key);
        if (typeof item2 === "undefined" && !$mapHas(b, key) || !internalDeepEqual(item1, item2, opts, channel)) {
          if (opts.strict) {
            return false;
          }
          if (!mapMightHaveLoosePrim(a2, b, key, item1, opts, channel)) {
            return false;
          }
          if (!set) {
            set = new $Set();
          }
          $setAdd(set, key);
        }
      }
    }
    if (set) {
      while ((resultB = iB.next()) && !resultB.done) {
        key = resultB.value[0];
        item2 = resultB.value[1];
        if (key && typeof key === "object") {
          if (!mapHasEqualEntry(set, a2, key, item2, opts, channel)) {
            return false;
          }
        } else if (!opts.strict && (!a2.has(key) || !internalDeepEqual($mapGet(a2, key), item2, opts, channel)) && !mapHasEqualEntry(set, a2, key, item2, assign({}, opts, { strict: false }), channel)) {
          return false;
        }
      }
      return $setSize(set) === 0;
    }
    return true;
  }
  function objEquiv(a2, b, opts, channel) {
    var i2, key;
    if (typeof a2 !== typeof b) {
      return false;
    }
    if (a2 == null || b == null) {
      return false;
    }
    if ($objToString(a2) !== $objToString(b)) {
      return false;
    }
    if (isArguments(a2) !== isArguments(b)) {
      return false;
    }
    var aIsArray = isArray$1(a2);
    var bIsArray = isArray$1(b);
    if (aIsArray !== bIsArray) {
      return false;
    }
    var aIsError = a2 instanceof Error;
    var bIsError = b instanceof Error;
    if (aIsError !== bIsError) {
      return false;
    }
    if (aIsError || bIsError) {
      if (a2.name !== b.name || a2.message !== b.message) {
        return false;
      }
    }
    var aIsRegex = isRegex(a2);
    var bIsRegex = isRegex(b);
    if (aIsRegex !== bIsRegex) {
      return false;
    }
    if ((aIsRegex || bIsRegex) && (a2.source !== b.source || flags(a2) !== flags(b))) {
      return false;
    }
    var aIsDate = isDate(a2);
    var bIsDate = isDate(b);
    if (aIsDate !== bIsDate) {
      return false;
    }
    if (aIsDate || bIsDate) {
      if ($getTime(a2) !== $getTime(b)) {
        return false;
      }
    }
    if (opts.strict && gPO && gPO(a2) !== gPO(b)) {
      return false;
    }
    if (whichTypedArray(a2) !== whichTypedArray(b)) {
      return false;
    }
    var aIsBuffer = isBuffer$1(a2);
    var bIsBuffer = isBuffer$1(b);
    if (aIsBuffer !== bIsBuffer) {
      return false;
    }
    if (aIsBuffer || bIsBuffer) {
      if (a2.length !== b.length) {
        return false;
      }
      for (i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    if (typeof a2 !== typeof b) {
      return false;
    }
    var ka = objectKeys(a2);
    var kb = objectKeys(b);
    if (ka.length !== kb.length) {
      return false;
    }
    ka.sort();
    kb.sort();
    for (i2 = ka.length - 1; i2 >= 0; i2--) {
      if (ka[i2] != kb[i2]) {
        return false;
      }
    }
    for (i2 = ka.length - 1; i2 >= 0; i2--) {
      key = ka[i2];
      if (!internalDeepEqual(a2[key], b[key], opts, channel)) {
        return false;
      }
    }
    var aCollection = whichCollection(a2);
    var bCollection = whichCollection(b);
    if (aCollection !== bCollection) {
      return false;
    }
    if (aCollection === "Set" || bCollection === "Set") {
      return setEquiv(a2, b, opts, channel);
    }
    if (aCollection === "Map") {
      return mapEquiv(a2, b, opts, channel);
    }
    return true;
  }
  var deepEqual = function deepEqual2(a2, b, opts) {
    return internalDeepEqual(a2, b, opts, getSideChannel());
  };
  const deepEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(deepEqual);
  const anyMap = /* @__PURE__ */ new WeakMap();
  const eventsMap = /* @__PURE__ */ new WeakMap();
  const producersMap = /* @__PURE__ */ new WeakMap();
  const anyProducer = Symbol("anyProducer");
  const resolvedPromise = Promise.resolve();
  const listenerAdded = Symbol("listenerAdded");
  const listenerRemoved = Symbol("listenerRemoved");
  function assertEventName(eventName) {
    if (typeof eventName !== "string" && typeof eventName !== "symbol") {
      throw new TypeError("eventName must be a string or a symbol");
    }
  }
  function assertListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError("listener must be a function");
    }
  }
  function getListeners(instance, eventName) {
    const events = eventsMap.get(instance);
    if (!events.has(eventName)) {
      events.set(eventName, /* @__PURE__ */ new Set());
    }
    return events.get(eventName);
  }
  function getEventProducers(instance, eventName) {
    const key = typeof eventName === "string" ? eventName : anyProducer;
    const producers = producersMap.get(instance);
    if (!producers.has(key)) {
      producers.set(key, /* @__PURE__ */ new Set());
    }
    return producers.get(key);
  }
  function enqueueProducers(instance, eventName, eventData) {
    const producers = producersMap.get(instance);
    if (producers.has(eventName)) {
      for (const producer of producers.get(eventName)) {
        producer.enqueue(eventData);
      }
    }
    if (producers.has(anyProducer)) {
      const item = Promise.all([eventName, eventData]);
      for (const producer of producers.get(anyProducer)) {
        producer.enqueue(item);
      }
    }
  }
  function iterator(instance, eventName) {
    let isFinished = false;
    let flush = () => {
    };
    let queue = [];
    const producer = {
      enqueue(item) {
        queue.push(item);
        flush();
      },
      finish() {
        isFinished = true;
        flush();
      }
    };
    getEventProducers(instance, eventName).add(producer);
    return {
      async next() {
        if (!queue) {
          return { done: true };
        }
        if (queue.length === 0) {
          if (isFinished) {
            queue = void 0;
            return this.next();
          }
          await new Promise((resolve) => {
            flush = resolve;
          });
          return this.next();
        }
        return {
          done: false,
          value: await queue.shift()
        };
      },
      async return(value) {
        queue = void 0;
        getEventProducers(instance, eventName).delete(producer);
        flush();
        return arguments.length > 0 ? { done: true, value: await value } : { done: true };
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  function defaultMethodNamesOrAssert(methodNames) {
    if (methodNames === void 0) {
      return allEmitteryMethods;
    }
    if (!Array.isArray(methodNames)) {
      throw new TypeError("`methodNames` must be an array of strings");
    }
    for (const methodName of methodNames) {
      if (!allEmitteryMethods.includes(methodName)) {
        if (typeof methodName !== "string") {
          throw new TypeError("`methodNames` element must be a string");
        }
        throw new Error(`${methodName} is not Emittery method`);
      }
    }
    return methodNames;
  }
  const isListenerSymbol = (symbol) => symbol === listenerAdded || symbol === listenerRemoved;
  class Emittery {
    static mixin(emitteryPropertyName, methodNames) {
      methodNames = defaultMethodNamesOrAssert(methodNames);
      return (target) => {
        if (typeof target !== "function") {
          throw new TypeError("`target` must be function");
        }
        for (const methodName of methodNames) {
          if (target.prototype[methodName] !== void 0) {
            throw new Error(`The property \`${methodName}\` already exists on \`target\``);
          }
        }
        function getEmitteryProperty() {
          Object.defineProperty(this, emitteryPropertyName, {
            enumerable: false,
            value: new Emittery()
          });
          return this[emitteryPropertyName];
        }
        Object.defineProperty(target.prototype, emitteryPropertyName, {
          enumerable: false,
          get: getEmitteryProperty
        });
        const emitteryMethodCaller = (methodName) => function(...args) {
          return this[emitteryPropertyName][methodName](...args);
        };
        for (const methodName of methodNames) {
          Object.defineProperty(target.prototype, methodName, {
            enumerable: false,
            value: emitteryMethodCaller(methodName)
          });
        }
        return target;
      };
    }
    constructor() {
      anyMap.set(this, /* @__PURE__ */ new Set());
      eventsMap.set(this, /* @__PURE__ */ new Map());
      producersMap.set(this, /* @__PURE__ */ new Map());
    }
    on(eventName, listener) {
      assertEventName(eventName);
      assertListener(listener);
      getListeners(this, eventName).add(listener);
      if (!isListenerSymbol(eventName)) {
        this.emit(listenerAdded, { eventName, listener });
      }
      return this.off.bind(this, eventName, listener);
    }
    off(eventName, listener) {
      assertEventName(eventName);
      assertListener(listener);
      if (!isListenerSymbol(eventName)) {
        this.emit(listenerRemoved, { eventName, listener });
      }
      getListeners(this, eventName).delete(listener);
    }
    once(eventName) {
      return new Promise((resolve) => {
        assertEventName(eventName);
        const off = this.on(eventName, (data) => {
          off();
          resolve(data);
        });
      });
    }
    events(eventName) {
      assertEventName(eventName);
      return iterator(this, eventName);
    }
    async emit(eventName, eventData) {
      assertEventName(eventName);
      enqueueProducers(this, eventName, eventData);
      const listeners = getListeners(this, eventName);
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];
      await resolvedPromise;
      return Promise.all([
        ...staticListeners.map(async (listener) => {
          if (listeners.has(listener)) {
            return listener(eventData);
          }
        }),
        ...staticAnyListeners.map(async (listener) => {
          if (anyListeners.has(listener)) {
            return listener(eventName, eventData);
          }
        })
      ]);
    }
    async emitSerial(eventName, eventData) {
      assertEventName(eventName);
      const listeners = getListeners(this, eventName);
      const anyListeners = anyMap.get(this);
      const staticListeners = [...listeners];
      const staticAnyListeners = [...anyListeners];
      await resolvedPromise;
      for (const listener of staticListeners) {
        if (listeners.has(listener)) {
          await listener(eventData);
        }
      }
      for (const listener of staticAnyListeners) {
        if (anyListeners.has(listener)) {
          await listener(eventName, eventData);
        }
      }
    }
    onAny(listener) {
      assertListener(listener);
      anyMap.get(this).add(listener);
      this.emit(listenerAdded, { listener });
      return this.offAny.bind(this, listener);
    }
    anyEvent() {
      return iterator(this);
    }
    offAny(listener) {
      assertListener(listener);
      this.emit(listenerRemoved, { listener });
      anyMap.get(this).delete(listener);
    }
    clearListeners(eventName) {
      if (typeof eventName === "string") {
        getListeners(this, eventName).clear();
        const producers = getEventProducers(this, eventName);
        for (const producer of producers) {
          producer.finish();
        }
        producers.clear();
      } else {
        anyMap.get(this).clear();
        for (const listeners of eventsMap.get(this).values()) {
          listeners.clear();
        }
        for (const producers of producersMap.get(this).values()) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        }
      }
    }
    listenerCount(eventName) {
      if (typeof eventName === "string") {
        return anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;
      }
      if (typeof eventName !== "undefined") {
        assertEventName(eventName);
      }
      let count = anyMap.get(this).size;
      for (const value of eventsMap.get(this).values()) {
        count += value.size;
      }
      for (const value of producersMap.get(this).values()) {
        count += value.size;
      }
      return count;
    }
    bindMethods(target, methodNames) {
      if (typeof target !== "object" || target === null) {
        throw new TypeError("`target` must be an object");
      }
      methodNames = defaultMethodNamesOrAssert(methodNames);
      for (const methodName of methodNames) {
        if (target[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
        Object.defineProperty(target, methodName, {
          enumerable: false,
          value: this[methodName].bind(this)
        });
      }
    }
  }
  const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v2) => v2 !== "constructor");
  Emittery.Typed = class extends Emittery {
  };
  Object.defineProperty(Emittery.Typed, "Typed", {
    enumerable: false,
    value: void 0
  });
  Object.defineProperty(Emittery, "listenerAdded", {
    value: listenerAdded,
    writable: false,
    enumerable: true,
    configurable: false
  });
  Object.defineProperty(Emittery, "listenerRemoved", {
    value: listenerRemoved,
    writable: false,
    enumerable: true,
    configurable: false
  });
  var emittery = Emittery;
  const Emittery$1 = /* @__PURE__ */ getDefaultExportFromCjs(emittery);
  function getRecentRevisionIds(history, cutoffDate) {
    const recentRevisionIds = /* @__PURE__ */ new Set();
    for (const [id, revision] of Object.entries(history.revisions)) {
      if (new Date(revision.editTime).getTime() < cutoffDate.getTime()) {
        continue;
      }
      recentRevisionIds.add(id);
    }
    while (true) {
      let changed = false;
      for (const [id, revision] of Object.entries(history.revisions)) {
        if (!recentRevisionIds.has(id) && revision.baseRevisionId && recentRevisionIds.has(revision.baseRevisionId)) {
          recentRevisionIds.add(id);
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    const baseRevisionIds = [];
    for (const id of recentRevisionIds) {
      const baseRevisionId = history.revisions[id].baseRevisionId;
      if (baseRevisionId && !recentRevisionIds.has(baseRevisionId)) {
        baseRevisionIds.push(baseRevisionId);
      }
    }
    for (const id of baseRevisionIds) {
      recentRevisionIds.add(id);
    }
    recentRevisionIds.add(history.currentRevisionId);
    return recentRevisionIds;
  }
  function modifyProtectedValues(content, timestamp, transform) {
    let modifiedContent = content;
    for (const [listKey, list] of Object.entries(content)) {
      for (const [elementKey, current] of Object.entries(list)) {
        const modifiedElement = Object.assign(Object.assign({}, recursivelyTransformProtectedValues(current, transform)), { updateTime: timestamp });
        modifiedContent = Object.assign(Object.assign({}, modifiedContent), { [listKey]: Object.assign(Object.assign({}, modifiedContent[listKey]), { [elementKey]: modifiedElement }) });
      }
    }
    return modifiedContent;
  }
  function recursivelyTransformProtectedValues(element, transform) {
    return recursivelyTransformValues(element, isProtectedValue$1, transform);
  }
  function recursivelyTransformUnprotectedValues(element, transform) {
    return recursivelyTransformValues(element, isUnprotectedValue, transform);
  }
  function recursivelyTransformValues(element, predicate, transform) {
    if (Array.isArray(element)) {
      return element.map((el) => recursivelyTransformValues(el, predicate, transform));
    }
    if (typeof element === "object" && element !== null) {
      if (predicate(element)) {
        return transform(element);
      }
      const transformedElement = {};
      for (const [key, value] of Object.entries(element)) {
        transformedElement[key] = recursivelyTransformValues(value, predicate, transform);
      }
      return transformedElement;
    }
    return element;
  }
  function isProtectedValue$1(obj) {
    return ProtectedValue.safeParse(obj).success;
  }
  function isUnprotectedValue(obj) {
    return UnprotectedValue.safeParse(obj).success;
  }
  var __rest$F = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function extractLinkedUpdateMessages(vaultId, originPersonalProfileId, preChangeContent, protectedSecretFunctions, vaultContentDiff) {
    var _a2;
    const result2 = [];
    for (const [loginId, modifiedLogin] of Object.entries(vaultContentDiff.logins)) {
      const preChangeLogin = preChangeContent.logins[loginId];
      if (!modifiedLogin.isDeleted && ((_a2 = modifiedLogin.linkedTo) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        const redactedLogin = __rest$F(modifiedLogin, ["history", "shareLinks"]);
        const newValues = recursivelyTransformProtectedValues(redactedLogin, (pv) => protectedSecretFunctions.unprotectWithContentId(pv));
        for (const { targetVaultId, removeTime, linkedByProfileId } of modifiedLogin.linkedTo) {
          if (targetVaultId === vaultId) {
            continue;
          }
          const removedInThisChange = removeTime === modifiedLogin.updateTime;
          let update = null;
          if (removedInThisChange) {
            update = {
              type: "originUpdated",
              loginId,
              content: { isDeleted: true, isArchived: false, updateTime: modifiedLogin.updateTime }
            };
          } else if (!removeTime) {
            update = {
              type: "originUpdated",
              loginId,
              content: Object.assign(Object.assign({}, newValues), { linkedTo: void 0, linkedFrom: { originVaultId: vaultId, originPersonalProfileId, linkedByProfileId }, isDeleted: false, updateTime: modifiedLogin.updateTime })
            };
          }
          if (update) {
            result2.push({
              vaultId: targetVaultId,
              type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
              message: [update]
            });
          }
        }
      } else if (modifiedLogin.isDeleted && !!preChangeLogin) {
        if (preChangeLogin.linkedTo) {
          const update = {
            type: "originUpdated",
            loginId,
            content: { isDeleted: true, isArchived: false, updateTime: modifiedLogin.updateTime }
          };
          for (const { targetVaultId } of preChangeLogin.linkedTo) {
            if (targetVaultId === vaultId) {
              continue;
            }
            result2.push({
              vaultId: targetVaultId,
              type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
              message: [update]
            });
          }
        } else if (preChangeLogin.linkedFrom) {
          if (preChangeLogin.linkedFrom.originVaultId !== vaultId) {
            const update = {
              type: "targetDeleted",
              loginId,
              removeTime: modifiedLogin.updateTime
            };
            result2.push({
              vaultId: preChangeLogin.linkedFrom.originVaultId,
              type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
              message: [update]
            });
          }
        }
      }
    }
    return result2;
  }
  var HeymergeErrorCode;
  (function(HeymergeErrorCode2) {
    HeymergeErrorCode2[HeymergeErrorCode2["NotImplemented"] = 6000500] = "NotImplemented";
    HeymergeErrorCode2[HeymergeErrorCode2["ElementNotFound"] = 6000401] = "ElementNotFound";
    HeymergeErrorCode2[HeymergeErrorCode2["InvalidHeymergeList"] = 6000402] = "InvalidHeymergeList";
    HeymergeErrorCode2[HeymergeErrorCode2["InvalidHeymergeVaultContent"] = 6000403] = "InvalidHeymergeVaultContent";
    HeymergeErrorCode2[HeymergeErrorCode2["ElementDeleted"] = 6000404] = "ElementDeleted";
    HeymergeErrorCode2[HeymergeErrorCode2["ElementArchived"] = 6000405] = "ElementArchived";
  })(HeymergeErrorCode || (HeymergeErrorCode = {}));
  const pleaseUpdate = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
  class HeymergeDomainError extends DomainError$1 {
    constructor(code, short, userTitle, userDetail) {
      super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate);
    }
  }
  class ElementNotFoundError extends HeymergeDomainError {
    constructor(id) {
      super(HeymergeErrorCode.ElementNotFound, `No element with id "${id}"!`);
    }
  }
  class InvalidHeymergeListError extends HeymergeDomainError {
    constructor(description) {
      super(HeymergeErrorCode.InvalidHeymergeList, `Invalid HeymergeList: "${description}"!`);
    }
  }
  class InvalidHeymergeVaultContentError extends HeymergeDomainError {
    constructor(description) {
      super(HeymergeErrorCode.InvalidHeymergeVaultContent, `Invalid HeymergeVaultContent: "${description}"!`);
    }
  }
  class ElementDeletedError extends HeymergeDomainError {
    constructor(id) {
      super(HeymergeErrorCode.ElementDeleted, `Element with id "${id}" has been deleted and cannot be archived or restored!`);
    }
  }
  class ElementArchivedError extends HeymergeDomainError {
    constructor(id) {
      super(HeymergeErrorCode.ElementArchived, `Element with id "${id}" has been archived and cannot be modified!`);
    }
  }
  var object_hash = { exports: {} };
  (function(module2, exports) {
    !function(e) {
      module2.exports = e();
    }(function() {
      return function o(i2, u2, a2) {
        function s2(n, e2) {
          if (!u2[n]) {
            if (!i2[n]) {
              var t = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e2 && t)
                return t(n, true);
              if (f2)
                return f2(n, true);
              throw new Error("Cannot find module '" + n + "'");
            }
            var r2 = u2[n] = { exports: {} };
            i2[n][0].call(r2.exports, function(e3) {
              var t2 = i2[n][1][e3];
              return s2(t2 || e3);
            }, r2, r2.exports, o, i2, u2, a2);
          }
          return u2[n].exports;
        }
        for (var f2 = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < a2.length; e++)
          s2(a2[e]);
        return s2;
      }({ 1: [function(w2, b, m2) {
        (function(e, t, f2, n, r2, o, i2, u2, a2) {
          var s2 = w2("crypto");
          function l(e2, t2) {
            return function(e3, t3) {
              var n2;
              n2 = "passthrough" !== t3.algorithm ? s2.createHash(t3.algorithm) : new y2();
              void 0 === n2.write && (n2.write = n2.update, n2.end = n2.update);
              g2(t3, n2).dispatch(e3), n2.update || n2.end("");
              if (n2.digest)
                return n2.digest("buffer" === t3.encoding ? void 0 : t3.encoding);
              var r3 = n2.read();
              return "buffer" !== t3.encoding ? r3.toString(t3.encoding) : r3;
            }(e2, t2 = h2(e2, t2));
          }
          (m2 = b.exports = l).sha1 = function(e2) {
            return l(e2);
          }, m2.keys = function(e2) {
            return l(e2, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m2.MD5 = function(e2) {
            return l(e2, { algorithm: "md5", encoding: "hex" });
          }, m2.keysMD5 = function(e2) {
            return l(e2, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var c2 = s2.getHashes ? s2.getHashes().slice() : ["sha1", "md5"];
          c2.push("passthrough");
          var d = ["buffer", "hex", "binary", "base64"];
          function h2(e2, t2) {
            t2 = t2 || {};
            var n2 = {};
            if (n2.algorithm = t2.algorithm || "sha1", n2.encoding = t2.encoding || "hex", n2.excludeValues = !!t2.excludeValues, n2.algorithm = n2.algorithm.toLowerCase(), n2.encoding = n2.encoding.toLowerCase(), n2.ignoreUnknown = true === t2.ignoreUnknown, n2.respectType = false !== t2.respectType, n2.respectFunctionNames = false !== t2.respectFunctionNames, n2.respectFunctionProperties = false !== t2.respectFunctionProperties, n2.unorderedArrays = true === t2.unorderedArrays, n2.unorderedSets = false !== t2.unorderedSets, n2.unorderedObjects = false !== t2.unorderedObjects, n2.replacer = t2.replacer || void 0, n2.excludeKeys = t2.excludeKeys || void 0, void 0 === e2)
              throw new Error("Object argument required.");
            for (var r3 = 0; r3 < c2.length; ++r3)
              c2[r3].toLowerCase() === n2.algorithm.toLowerCase() && (n2.algorithm = c2[r3]);
            if (-1 === c2.indexOf(n2.algorithm))
              throw new Error('Algorithm "' + n2.algorithm + '"  not supported. supported values: ' + c2.join(", "));
            if (-1 === d.indexOf(n2.encoding) && "passthrough" !== n2.algorithm)
              throw new Error('Encoding "' + n2.encoding + '"  not supported. supported values: ' + d.join(", "));
            return n2;
          }
          function p2(e2) {
            if ("function" == typeof e2) {
              return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e2));
            }
          }
          function g2(u3, t2, a3) {
            a3 = a3 || [];
            function s3(e2) {
              return t2.update ? t2.update(e2, "utf8") : t2.write(e2, "utf8");
            }
            return { dispatch: function(e2) {
              return u3.replacer && (e2 = u3.replacer(e2)), this["_" + (null === e2 ? "null" : typeof e2)](e2);
            }, _object: function(t3) {
              var e2 = Object.prototype.toString.call(t3), n2 = /\[object (.*)\]/i.exec(e2);
              n2 = (n2 = n2 ? n2[1] : "unknown:[" + e2 + "]").toLowerCase();
              var r3;
              if (0 <= (r3 = a3.indexOf(t3)))
                return this.dispatch("[CIRCULAR:" + r3 + "]");
              if (a3.push(t3), void 0 !== f2 && f2.isBuffer && f2.isBuffer(t3))
                return s3("buffer:"), s3(t3);
              if ("object" === n2 || "function" === n2 || "asyncfunction" === n2) {
                var o2 = Object.keys(t3);
                u3.unorderedObjects && (o2 = o2.sort()), false === u3.respectType || p2(t3) || o2.splice(0, 0, "prototype", "__proto__", "constructor"), u3.excludeKeys && (o2 = o2.filter(function(e3) {
                  return !u3.excludeKeys(e3);
                })), s3("object:" + o2.length + ":");
                var i3 = this;
                return o2.forEach(function(e3) {
                  i3.dispatch(e3), s3(":"), u3.excludeValues || i3.dispatch(t3[e3]), s3(",");
                });
              }
              if (!this["_" + n2]) {
                if (u3.ignoreUnknown)
                  return s3("[" + n2 + "]");
                throw new Error('Unknown object type "' + n2 + '"');
              }
              this["_" + n2](t3);
            }, _array: function(e2, t3) {
              t3 = void 0 !== t3 ? t3 : false !== u3.unorderedArrays;
              var n2 = this;
              if (s3("array:" + e2.length + ":"), !t3 || e2.length <= 1)
                return e2.forEach(function(e3) {
                  return n2.dispatch(e3);
                });
              var r3 = [], o2 = e2.map(function(e3) {
                var t4 = new y2(), n3 = a3.slice();
                return g2(u3, t4, n3).dispatch(e3), r3 = r3.concat(n3.slice(a3.length)), t4.read().toString();
              });
              return a3 = a3.concat(r3), o2.sort(), this._array(o2, false);
            }, _date: function(e2) {
              return s3("date:" + e2.toJSON());
            }, _symbol: function(e2) {
              return s3("symbol:" + e2.toString());
            }, _error: function(e2) {
              return s3("error:" + e2.toString());
            }, _boolean: function(e2) {
              return s3("bool:" + e2.toString());
            }, _string: function(e2) {
              s3("string:" + e2.length + ":"), s3(e2.toString());
            }, _function: function(e2) {
              s3("fn:"), p2(e2) ? this.dispatch("[native]") : this.dispatch(e2.toString()), false !== u3.respectFunctionNames && this.dispatch("function-name:" + String(e2.name)), u3.respectFunctionProperties && this._object(e2);
            }, _number: function(e2) {
              return s3("number:" + e2.toString());
            }, _xml: function(e2) {
              return s3("xml:" + e2.toString());
            }, _null: function() {
              return s3("Null");
            }, _undefined: function() {
              return s3("Undefined");
            }, _regexp: function(e2) {
              return s3("regex:" + e2.toString());
            }, _uint8array: function(e2) {
              return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint8clampedarray: function(e2) {
              return s3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int8array: function(e2) {
              return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint16array: function(e2) {
              return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int16array: function(e2) {
              return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint32array: function(e2) {
              return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int32array: function(e2) {
              return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float32array: function(e2) {
              return s3("float32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float64array: function(e2) {
              return s3("float64array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _arraybuffer: function(e2) {
              return s3("arraybuffer:"), this.dispatch(new Uint8Array(e2));
            }, _url: function(e2) {
              return s3("url:" + e2.toString());
            }, _map: function(e2) {
              s3("map:");
              var t3 = Array.from(e2);
              return this._array(t3, false !== u3.unorderedSets);
            }, _set: function(e2) {
              s3("set:");
              var t3 = Array.from(e2);
              return this._array(t3, false !== u3.unorderedSets);
            }, _file: function(e2) {
              return s3("file:"), this.dispatch([e2.name, e2.size, e2.type, e2.lastModfied]);
            }, _blob: function() {
              if (u3.ignoreUnknown)
                return s3("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return s3("domwindow");
            }, _process: function() {
              return s3("process");
            }, _timer: function() {
              return s3("timer");
            }, _pipe: function() {
              return s3("pipe");
            }, _tcp: function() {
              return s3("tcp");
            }, _udp: function() {
              return s3("udp");
            }, _tty: function() {
              return s3("tty");
            }, _statwatcher: function() {
              return s3("statwatcher");
            }, _securecontext: function() {
              return s3("securecontext");
            }, _connection: function() {
              return s3("connection");
            }, _zlib: function() {
              return s3("zlib");
            }, _context: function() {
              return s3("context");
            }, _nodescript: function() {
              return s3("nodescript");
            }, _httpparser: function() {
              return s3("httpparser");
            }, _dataview: function() {
              return s3("dataview");
            }, _signal: function() {
              return s3("signal");
            }, _fsevent: function() {
              return s3("fsevent");
            }, _tlswrap: function() {
              return s3("tlswrap");
            } };
          }
          function y2() {
            return { buf: "", write: function(e2) {
              this.buf += e2;
            }, end: function(e2) {
              this.buf += e2;
            }, read: function() {
              return this.buf;
            } };
          }
          m2.writeToStream = function(e2, t2, n2) {
            return void 0 === n2 && (n2 = t2, t2 = {}), g2(t2 = h2(e2, t2), n2).dispatch(e2);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_5812b7fb.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 10 }], 2: [function(e, t, f2) {
        (function(e2, t2, n, r2, o, i2, u2, a2, s2) {
          !function(e3) {
            var f3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, n2 = "+".charCodeAt(0), r3 = "/".charCodeAt(0), o2 = "0".charCodeAt(0), i3 = "a".charCodeAt(0), u3 = "A".charCodeAt(0), a3 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
            function l(e4) {
              var t3 = e4.charCodeAt(0);
              return t3 === n2 || t3 === a3 ? 62 : t3 === r3 || t3 === s3 ? 63 : t3 < o2 ? -1 : t3 < o2 + 10 ? t3 - o2 + 26 + 26 : t3 < u3 + 26 ? t3 - u3 : t3 < i3 + 26 ? t3 - i3 + 26 : void 0;
            }
            e3.toByteArray = function(e4) {
              var t3, n3;
              if (0 < e4.length % 4)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r4 = e4.length, o3 = "=" === e4.charAt(r4 - 2) ? 2 : "=" === e4.charAt(r4 - 1) ? 1 : 0, i4 = new f3(3 * e4.length / 4 - o3), u4 = 0 < o3 ? e4.length - 4 : e4.length, a4 = 0;
              function s4(e5) {
                i4[a4++] = e5;
              }
              for (t3 = 0; t3 < u4; t3 += 4, 0)
                s4((16711680 & (n3 = l(e4.charAt(t3)) << 18 | l(e4.charAt(t3 + 1)) << 12 | l(e4.charAt(t3 + 2)) << 6 | l(e4.charAt(t3 + 3)))) >> 16), s4((65280 & n3) >> 8), s4(255 & n3);
              return 2 == o3 ? s4(255 & (n3 = l(e4.charAt(t3)) << 2 | l(e4.charAt(t3 + 1)) >> 4)) : 1 == o3 && (s4((n3 = l(e4.charAt(t3)) << 10 | l(e4.charAt(t3 + 1)) << 4 | l(e4.charAt(t3 + 2)) >> 2) >> 8 & 255), s4(255 & n3)), i4;
            }, e3.fromByteArray = function(e4) {
              var t3, n3, r4, o3, i4 = e4.length % 3, u4 = "";
              function a4(e5) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e5);
              }
              for (t3 = 0, r4 = e4.length - i4; t3 < r4; t3 += 3)
                n3 = (e4[t3] << 16) + (e4[t3 + 1] << 8) + e4[t3 + 2], u4 += a4((o3 = n3) >> 18 & 63) + a4(o3 >> 12 & 63) + a4(o3 >> 6 & 63) + a4(63 & o3);
              switch (i4) {
                case 1:
                  u4 += a4((n3 = e4[e4.length - 1]) >> 2), u4 += a4(n3 << 4 & 63), u4 += "==";
                  break;
                case 2:
                  u4 += a4((n3 = (e4[e4.length - 2] << 8) + e4[e4.length - 1]) >> 10), u4 += a4(n3 >> 4 & 63), u4 += a4(n3 << 2 & 63), u4 += "=";
              }
              return u4;
            };
          }(void 0 === f2 ? this.base64js = {} : f2);
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 10 }], 3: [function(O, e, H) {
        (function(e2, t, g2, n, r2, o, i2, u2, a2) {
          var s2 = O("base64-js"), f2 = O("ieee754");
          function g2(e3, t2, n2) {
            if (!(this instanceof g2))
              return new g2(e3, t2, n2);
            var r3, o2, i3, u3, a3, s3 = typeof e3;
            if ("base64" === t2 && "string" == s3)
              for (e3 = (r3 = e3).trim ? r3.trim() : r3.replace(/^\s+|\s+$/g, ""); e3.length % 4 != 0; )
                e3 += "=";
            if ("number" == s3)
              o2 = x2(e3);
            else if ("string" == s3)
              o2 = g2.byteLength(e3, t2);
            else {
              if ("object" != s3)
                throw new Error("First argument needs to be a number, array or string.");
              o2 = x2(e3.length);
            }
            if (g2._useTypedArrays ? i3 = g2._augment(new Uint8Array(o2)) : ((i3 = this).length = o2, i3._isBuffer = true), g2._useTypedArrays && "number" == typeof e3.byteLength)
              i3._set(e3);
            else if (S2(a3 = e3) || g2.isBuffer(a3) || a3 && "object" == typeof a3 && "number" == typeof a3.length)
              for (u3 = 0; u3 < o2; u3++)
                g2.isBuffer(e3) ? i3[u3] = e3.readUInt8(u3) : i3[u3] = e3[u3];
            else if ("string" == s3)
              i3.write(e3, 0, t2);
            else if ("number" == s3 && !g2._useTypedArrays && !n2)
              for (u3 = 0; u3 < o2; u3++)
                i3[u3] = 0;
            return i3;
          }
          function y2(e3, t2, n2, r3) {
            return g2._charsWritten = T(function(e4) {
              for (var t3 = [], n3 = 0; n3 < e4.length; n3++)
                t3.push(255 & e4.charCodeAt(n3));
              return t3;
            }(t2), e3, n2, r3);
          }
          function w2(e3, t2, n2, r3) {
            return g2._charsWritten = T(function(e4) {
              for (var t3, n3, r4, o2 = [], i3 = 0; i3 < e4.length; i3++)
                t3 = e4.charCodeAt(i3), n3 = t3 >> 8, r4 = t3 % 256, o2.push(r4), o2.push(n3);
              return o2;
            }(t2), e3, n2, r3);
          }
          function l(e3, t2, n2) {
            var r3 = "";
            n2 = Math.min(e3.length, n2);
            for (var o2 = t2; o2 < n2; o2++)
              r3 += String.fromCharCode(e3[o2]);
            return r3;
          }
          function c2(e3, t2, n2, r3) {
            r3 || (D("boolean" == typeof n2, "missing or invalid endian"), D(null != t2, "missing offset"), D(t2 + 1 < e3.length, "Trying to read beyond buffer length"));
            var o2, i3 = e3.length;
            if (!(i3 <= t2))
              return n2 ? (o2 = e3[t2], t2 + 1 < i3 && (o2 |= e3[t2 + 1] << 8)) : (o2 = e3[t2] << 8, t2 + 1 < i3 && (o2 |= e3[t2 + 1])), o2;
          }
          function d(e3, t2, n2, r3) {
            r3 || (D("boolean" == typeof n2, "missing or invalid endian"), D(null != t2, "missing offset"), D(t2 + 3 < e3.length, "Trying to read beyond buffer length"));
            var o2, i3 = e3.length;
            if (!(i3 <= t2))
              return n2 ? (t2 + 2 < i3 && (o2 = e3[t2 + 2] << 16), t2 + 1 < i3 && (o2 |= e3[t2 + 1] << 8), o2 |= e3[t2], t2 + 3 < i3 && (o2 += e3[t2 + 3] << 24 >>> 0)) : (t2 + 1 < i3 && (o2 = e3[t2 + 1] << 16), t2 + 2 < i3 && (o2 |= e3[t2 + 2] << 8), t2 + 3 < i3 && (o2 |= e3[t2 + 3]), o2 += e3[t2] << 24 >>> 0), o2;
          }
          function h2(e3, t2, n2, r3) {
            if (r3 || (D("boolean" == typeof n2, "missing or invalid endian"), D(null != t2, "missing offset"), D(t2 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) {
              var o2 = c2(e3, t2, n2, true);
              return 32768 & o2 ? -1 * (65535 - o2 + 1) : o2;
            }
          }
          function p2(e3, t2, n2, r3) {
            if (r3 || (D("boolean" == typeof n2, "missing or invalid endian"), D(null != t2, "missing offset"), D(t2 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) {
              var o2 = d(e3, t2, n2, true);
              return 2147483648 & o2 ? -1 * (4294967295 - o2 + 1) : o2;
            }
          }
          function b(e3, t2, n2, r3) {
            return r3 || (D("boolean" == typeof n2, "missing or invalid endian"), D(t2 + 3 < e3.length, "Trying to read beyond buffer length")), f2.read(e3, t2, n2, 23, 4);
          }
          function m2(e3, t2, n2, r3) {
            return r3 || (D("boolean" == typeof n2, "missing or invalid endian"), D(t2 + 7 < e3.length, "Trying to read beyond buffer length")), f2.read(e3, t2, n2, 52, 8);
          }
          function v2(e3, t2, n2, r3, o2) {
            o2 || (D(null != t2, "missing value"), D("boolean" == typeof r3, "missing or invalid endian"), D(null != n2, "missing offset"), D(n2 + 1 < e3.length, "trying to write beyond buffer length"), N(t2, 65535));
            var i3 = e3.length;
            if (!(i3 <= n2))
              for (var u3 = 0, a3 = Math.min(i3 - n2, 2); u3 < a3; u3++)
                e3[n2 + u3] = (t2 & 255 << 8 * (r3 ? u3 : 1 - u3)) >>> 8 * (r3 ? u3 : 1 - u3);
          }
          function _(e3, t2, n2, r3, o2) {
            o2 || (D(null != t2, "missing value"), D("boolean" == typeof r3, "missing or invalid endian"), D(null != n2, "missing offset"), D(n2 + 3 < e3.length, "trying to write beyond buffer length"), N(t2, 4294967295));
            var i3 = e3.length;
            if (!(i3 <= n2))
              for (var u3 = 0, a3 = Math.min(i3 - n2, 4); u3 < a3; u3++)
                e3[n2 + u3] = t2 >>> 8 * (r3 ? u3 : 3 - u3) & 255;
          }
          function E(e3, t2, n2, r3, o2) {
            o2 || (D(null != t2, "missing value"), D("boolean" == typeof r3, "missing or invalid endian"), D(null != n2, "missing offset"), D(n2 + 1 < e3.length, "Trying to write beyond buffer length"), Y(t2, 32767, -32768)), e3.length <= n2 || v2(e3, 0 <= t2 ? t2 : 65535 + t2 + 1, n2, r3, o2);
          }
          function I(e3, t2, n2, r3, o2) {
            o2 || (D(null != t2, "missing value"), D("boolean" == typeof r3, "missing or invalid endian"), D(null != n2, "missing offset"), D(n2 + 3 < e3.length, "Trying to write beyond buffer length"), Y(t2, 2147483647, -2147483648)), e3.length <= n2 || _(e3, 0 <= t2 ? t2 : 4294967295 + t2 + 1, n2, r3, o2);
          }
          function A(e3, t2, n2, r3, o2) {
            o2 || (D(null != t2, "missing value"), D("boolean" == typeof r3, "missing or invalid endian"), D(null != n2, "missing offset"), D(n2 + 3 < e3.length, "Trying to write beyond buffer length"), F(t2, 34028234663852886e22, -34028234663852886e22)), e3.length <= n2 || f2.write(e3, t2, n2, r3, 23, 4);
          }
          function B(e3, t2, n2, r3, o2) {
            o2 || (D(null != t2, "missing value"), D("boolean" == typeof r3, "missing or invalid endian"), D(null != n2, "missing offset"), D(n2 + 7 < e3.length, "Trying to write beyond buffer length"), F(t2, 17976931348623157e292, -17976931348623157e292)), e3.length <= n2 || f2.write(e3, t2, n2, r3, 52, 8);
          }
          H.Buffer = g2, H.SlowBuffer = g2, H.INSPECT_MAX_BYTES = 50, g2.poolSize = 8192, g2._useTypedArrays = function() {
            try {
              var e3 = new ArrayBuffer(0), t2 = new Uint8Array(e3);
              return t2.foo = function() {
                return 42;
              }, 42 === t2.foo() && "function" == typeof t2.subarray;
            } catch (e4) {
              return false;
            }
          }(), g2.isEncoding = function(e3) {
            switch (String(e3).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, g2.isBuffer = function(e3) {
            return !(null == e3 || !e3._isBuffer);
          }, g2.byteLength = function(e3, t2) {
            var n2;
            switch (e3 += "", t2 || "utf8") {
              case "hex":
                n2 = e3.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n2 = C2(e3).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n2 = e3.length;
                break;
              case "base64":
                n2 = k(e3).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n2 = 2 * e3.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n2;
          }, g2.concat = function(e3, t2) {
            if (D(S2(e3), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e3.length)
              return new g2(0);
            if (1 === e3.length)
              return e3[0];
            if ("number" != typeof t2)
              for (o2 = t2 = 0; o2 < e3.length; o2++)
                t2 += e3[o2].length;
            for (var n2 = new g2(t2), r3 = 0, o2 = 0; o2 < e3.length; o2++) {
              var i3 = e3[o2];
              i3.copy(n2, r3), r3 += i3.length;
            }
            return n2;
          }, g2.prototype.write = function(e3, t2, n2, r3) {
            var o2;
            isFinite(t2) ? isFinite(n2) || (r3 = n2, n2 = void 0) : (o2 = r3, r3 = t2, t2 = n2, n2 = o2), t2 = Number(t2) || 0;
            var i3, u3, a3, s3, f3, l2, c3, d2, h3, p3 = this.length - t2;
            switch ((!n2 || p3 < (n2 = Number(n2))) && (n2 = p3), r3 = String(r3 || "utf8").toLowerCase()) {
              case "hex":
                i3 = function(e4, t3, n3, r4) {
                  n3 = Number(n3) || 0;
                  var o3 = e4.length - n3;
                  (!r4 || o3 < (r4 = Number(r4))) && (r4 = o3);
                  var i4 = t3.length;
                  D(i4 % 2 == 0, "Invalid hex string"), i4 / 2 < r4 && (r4 = i4 / 2);
                  for (var u4 = 0; u4 < r4; u4++) {
                    var a4 = parseInt(t3.substr(2 * u4, 2), 16);
                    D(!isNaN(a4), "Invalid hex string"), e4[n3 + u4] = a4;
                  }
                  return g2._charsWritten = 2 * u4, u4;
                }(this, e3, t2, n2);
                break;
              case "utf8":
              case "utf-8":
                l2 = this, c3 = e3, d2 = t2, h3 = n2, i3 = g2._charsWritten = T(C2(c3), l2, d2, h3);
                break;
              case "ascii":
              case "binary":
                i3 = y2(this, e3, t2, n2);
                break;
              case "base64":
                u3 = this, a3 = e3, s3 = t2, f3 = n2, i3 = g2._charsWritten = T(k(a3), u3, s3, f3);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                i3 = w2(this, e3, t2, n2);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return i3;
          }, g2.prototype.toString = function(e3, t2, n2) {
            var r3, o2, i3, u3, a3 = this;
            if (e3 = String(e3 || "utf8").toLowerCase(), t2 = Number(t2) || 0, (n2 = void 0 !== n2 ? Number(n2) : n2 = a3.length) === t2)
              return "";
            switch (e3) {
              case "hex":
                r3 = function(e4, t3, n3) {
                  var r4 = e4.length;
                  (!t3 || t3 < 0) && (t3 = 0);
                  (!n3 || n3 < 0 || r4 < n3) && (n3 = r4);
                  for (var o3 = "", i4 = t3; i4 < n3; i4++)
                    o3 += j(e4[i4]);
                  return o3;
                }(a3, t2, n2);
                break;
              case "utf8":
              case "utf-8":
                r3 = function(e4, t3, n3) {
                  var r4 = "", o3 = "";
                  n3 = Math.min(e4.length, n3);
                  for (var i4 = t3; i4 < n3; i4++)
                    e4[i4] <= 127 ? (r4 += M2(o3) + String.fromCharCode(e4[i4]), o3 = "") : o3 += "%" + e4[i4].toString(16);
                  return r4 + M2(o3);
                }(a3, t2, n2);
                break;
              case "ascii":
              case "binary":
                r3 = l(a3, t2, n2);
                break;
              case "base64":
                o2 = a3, u3 = n2, r3 = 0 === (i3 = t2) && u3 === o2.length ? s2.fromByteArray(o2) : s2.fromByteArray(o2.slice(i3, u3));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r3 = function(e4, t3, n3) {
                  for (var r4 = e4.slice(t3, n3), o3 = "", i4 = 0; i4 < r4.length; i4 += 2)
                    o3 += String.fromCharCode(r4[i4] + 256 * r4[i4 + 1]);
                  return o3;
                }(a3, t2, n2);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r3;
          }, g2.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, g2.prototype.copy = function(e3, t2, n2, r3) {
            if (n2 = n2 || 0, r3 || 0 === r3 || (r3 = this.length), t2 = t2 || 0, r3 !== n2 && 0 !== e3.length && 0 !== this.length) {
              D(n2 <= r3, "sourceEnd < sourceStart"), D(0 <= t2 && t2 < e3.length, "targetStart out of bounds"), D(0 <= n2 && n2 < this.length, "sourceStart out of bounds"), D(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length), e3.length - t2 < r3 - n2 && (r3 = e3.length - t2 + n2);
              var o2 = r3 - n2;
              if (o2 < 100 || !g2._useTypedArrays)
                for (var i3 = 0; i3 < o2; i3++)
                  e3[i3 + t2] = this[i3 + n2];
              else
                e3._set(this.subarray(n2, n2 + o2), t2);
            }
          }, g2.prototype.slice = function(e3, t2) {
            var n2 = this.length;
            if (e3 = U(e3, n2, 0), t2 = U(t2, n2, n2), g2._useTypedArrays)
              return g2._augment(this.subarray(e3, t2));
            for (var r3 = t2 - e3, o2 = new g2(r3, void 0, true), i3 = 0; i3 < r3; i3++)
              o2[i3] = this[i3 + e3];
            return o2;
          }, g2.prototype.get = function(e3) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
          }, g2.prototype.set = function(e3, t2) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t2);
          }, g2.prototype.readUInt8 = function(e3, t2) {
            if (t2 || (D(null != e3, "missing offset"), D(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
              return this[e3];
          }, g2.prototype.readUInt16LE = function(e3, t2) {
            return c2(this, e3, true, t2);
          }, g2.prototype.readUInt16BE = function(e3, t2) {
            return c2(this, e3, false, t2);
          }, g2.prototype.readUInt32LE = function(e3, t2) {
            return d(this, e3, true, t2);
          }, g2.prototype.readUInt32BE = function(e3, t2) {
            return d(this, e3, false, t2);
          }, g2.prototype.readInt8 = function(e3, t2) {
            if (t2 || (D(null != e3, "missing offset"), D(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
              return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
          }, g2.prototype.readInt16LE = function(e3, t2) {
            return h2(this, e3, true, t2);
          }, g2.prototype.readInt16BE = function(e3, t2) {
            return h2(this, e3, false, t2);
          }, g2.prototype.readInt32LE = function(e3, t2) {
            return p2(this, e3, true, t2);
          }, g2.prototype.readInt32BE = function(e3, t2) {
            return p2(this, e3, false, t2);
          }, g2.prototype.readFloatLE = function(e3, t2) {
            return b(this, e3, true, t2);
          }, g2.prototype.readFloatBE = function(e3, t2) {
            return b(this, e3, false, t2);
          }, g2.prototype.readDoubleLE = function(e3, t2) {
            return m2(this, e3, true, t2);
          }, g2.prototype.readDoubleBE = function(e3, t2) {
            return m2(this, e3, false, t2);
          }, g2.prototype.writeUInt8 = function(e3, t2, n2) {
            n2 || (D(null != e3, "missing value"), D(null != t2, "missing offset"), D(t2 < this.length, "trying to write beyond buffer length"), N(e3, 255)), t2 >= this.length || (this[t2] = e3);
          }, g2.prototype.writeUInt16LE = function(e3, t2, n2) {
            v2(this, e3, t2, true, n2);
          }, g2.prototype.writeUInt16BE = function(e3, t2, n2) {
            v2(this, e3, t2, false, n2);
          }, g2.prototype.writeUInt32LE = function(e3, t2, n2) {
            _(this, e3, t2, true, n2);
          }, g2.prototype.writeUInt32BE = function(e3, t2, n2) {
            _(this, e3, t2, false, n2);
          }, g2.prototype.writeInt8 = function(e3, t2, n2) {
            n2 || (D(null != e3, "missing value"), D(null != t2, "missing offset"), D(t2 < this.length, "Trying to write beyond buffer length"), Y(e3, 127, -128)), t2 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t2, n2) : this.writeUInt8(255 + e3 + 1, t2, n2));
          }, g2.prototype.writeInt16LE = function(e3, t2, n2) {
            E(this, e3, t2, true, n2);
          }, g2.prototype.writeInt16BE = function(e3, t2, n2) {
            E(this, e3, t2, false, n2);
          }, g2.prototype.writeInt32LE = function(e3, t2, n2) {
            I(this, e3, t2, true, n2);
          }, g2.prototype.writeInt32BE = function(e3, t2, n2) {
            I(this, e3, t2, false, n2);
          }, g2.prototype.writeFloatLE = function(e3, t2, n2) {
            A(this, e3, t2, true, n2);
          }, g2.prototype.writeFloatBE = function(e3, t2, n2) {
            A(this, e3, t2, false, n2);
          }, g2.prototype.writeDoubleLE = function(e3, t2, n2) {
            B(this, e3, t2, true, n2);
          }, g2.prototype.writeDoubleBE = function(e3, t2, n2) {
            B(this, e3, t2, false, n2);
          }, g2.prototype.fill = function(e3, t2, n2) {
            if (e3 = e3 || 0, t2 = t2 || 0, n2 = n2 || this.length, "string" == typeof e3 && (e3 = e3.charCodeAt(0)), D("number" == typeof e3 && !isNaN(e3), "value is not a number"), D(t2 <= n2, "end < start"), n2 !== t2 && 0 !== this.length) {
              D(0 <= t2 && t2 < this.length, "start out of bounds"), D(0 <= n2 && n2 <= this.length, "end out of bounds");
              for (var r3 = t2; r3 < n2; r3++)
                this[r3] = e3;
            }
          }, g2.prototype.inspect = function() {
            for (var e3 = [], t2 = this.length, n2 = 0; n2 < t2; n2++)
              if (e3[n2] = j(this[n2]), n2 === H.INSPECT_MAX_BYTES) {
                e3[n2 + 1] = "...";
                break;
              }
            return "<Buffer " + e3.join(" ") + ">";
          }, g2.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array)
              throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (g2._useTypedArrays)
              return new g2(this).buffer;
            for (var e3 = new Uint8Array(this.length), t2 = 0, n2 = e3.length; t2 < n2; t2 += 1)
              e3[t2] = this[t2];
            return e3.buffer;
          };
          var L2 = g2.prototype;
          function U(e3, t2, n2) {
            return "number" != typeof e3 ? n2 : t2 <= (e3 = ~~e3) ? t2 : 0 <= e3 || 0 <= (e3 += t2) ? e3 : 0;
          }
          function x2(e3) {
            return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
          }
          function S2(e3) {
            return (Array.isArray || function(e4) {
              return "[object Array]" === Object.prototype.toString.call(e4);
            })(e3);
          }
          function j(e3) {
            return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
          }
          function C2(e3) {
            for (var t2 = [], n2 = 0; n2 < e3.length; n2++) {
              var r3 = e3.charCodeAt(n2);
              if (r3 <= 127)
                t2.push(e3.charCodeAt(n2));
              else {
                var o2 = n2;
                55296 <= r3 && r3 <= 57343 && n2++;
                for (var i3 = encodeURIComponent(e3.slice(o2, n2 + 1)).substr(1).split("%"), u3 = 0; u3 < i3.length; u3++)
                  t2.push(parseInt(i3[u3], 16));
              }
            }
            return t2;
          }
          function k(e3) {
            return s2.toByteArray(e3);
          }
          function T(e3, t2, n2, r3) {
            for (var o2 = 0; o2 < r3 && !(o2 + n2 >= t2.length || o2 >= e3.length); o2++)
              t2[o2 + n2] = e3[o2];
            return o2;
          }
          function M2(e3) {
            try {
              return decodeURIComponent(e3);
            } catch (e4) {
              return String.fromCharCode(65533);
            }
          }
          function N(e3, t2) {
            D("number" == typeof e3, "cannot write a non-number as a number"), D(0 <= e3, "specified a negative value for writing an unsigned value"), D(e3 <= t2, "value is larger than maximum value for type"), D(Math.floor(e3) === e3, "value has a fractional component");
          }
          function Y(e3, t2, n2) {
            D("number" == typeof e3, "cannot write a non-number as a number"), D(e3 <= t2, "value larger than maximum allowed value"), D(n2 <= e3, "value smaller than minimum allowed value"), D(Math.floor(e3) === e3, "value has a fractional component");
          }
          function F(e3, t2, n2) {
            D("number" == typeof e3, "cannot write a non-number as a number"), D(e3 <= t2, "value larger than maximum allowed value"), D(n2 <= e3, "value smaller than minimum allowed value");
          }
          function D(e3, t2) {
            if (!e3)
              throw new Error(t2 || "Failed assertion");
          }
          g2._augment = function(e3) {
            return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = L2.get, e3.set = L2.set, e3.write = L2.write, e3.toString = L2.toString, e3.toLocaleString = L2.toString, e3.toJSON = L2.toJSON, e3.copy = L2.copy, e3.slice = L2.slice, e3.readUInt8 = L2.readUInt8, e3.readUInt16LE = L2.readUInt16LE, e3.readUInt16BE = L2.readUInt16BE, e3.readUInt32LE = L2.readUInt32LE, e3.readUInt32BE = L2.readUInt32BE, e3.readInt8 = L2.readInt8, e3.readInt16LE = L2.readInt16LE, e3.readInt16BE = L2.readInt16BE, e3.readInt32LE = L2.readInt32LE, e3.readInt32BE = L2.readInt32BE, e3.readFloatLE = L2.readFloatLE, e3.readFloatBE = L2.readFloatBE, e3.readDoubleLE = L2.readDoubleLE, e3.readDoubleBE = L2.readDoubleBE, e3.writeUInt8 = L2.writeUInt8, e3.writeUInt16LE = L2.writeUInt16LE, e3.writeUInt16BE = L2.writeUInt16BE, e3.writeUInt32LE = L2.writeUInt32LE, e3.writeUInt32BE = L2.writeUInt32BE, e3.writeInt8 = L2.writeInt8, e3.writeInt16LE = L2.writeInt16LE, e3.writeInt16BE = L2.writeInt16BE, e3.writeInt32LE = L2.writeInt32LE, e3.writeInt32BE = L2.writeInt32BE, e3.writeFloatLE = L2.writeFloatLE, e3.writeFloatBE = L2.writeFloatBE, e3.writeDoubleLE = L2.writeDoubleLE, e3.writeDoubleBE = L2.writeDoubleBE, e3.fill = L2.fill, e3.inspect = L2.inspect, e3.toArrayBuffer = L2.toArrayBuffer, e3;
          };
        }).call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 11, lYpoI2: 10 }], 4: [function(c2, d, e) {
        (function(e2, t, u2, n, r2, o, i2, a2, s2) {
          var u2 = c2("buffer").Buffer, f2 = 4, l = new u2(f2);
          l.fill(0);
          d.exports = { hash: function(e3, t2, n2, r3) {
            return u2.isBuffer(e3) || (e3 = new u2(e3)), function(e4, t3, n3) {
              for (var r4 = new u2(t3), o2 = n3 ? r4.writeInt32BE : r4.writeInt32LE, i3 = 0; i3 < e4.length; i3++)
                o2.call(r4, e4[i3], 4 * i3, true);
              return r4;
            }(t2(function(e4, t3) {
              var n3;
              e4.length % f2 != 0 && (n3 = e4.length + (f2 - e4.length % f2), e4 = u2.concat([e4, l], n3));
              for (var r4 = [], o2 = t3 ? e4.readInt32BE : e4.readInt32LE, i3 = 0; i3 < e4.length; i3 += f2)
                r4.push(o2.call(e4, i3));
              return r4;
            }(e3, r3), 8 * e3.length), n2, r3);
          } };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 10 }], 5: [function(w2, e, b) {
        (function(e2, t, a2, n, r2, o, i2, u2, s2) {
          var a2 = w2("buffer").Buffer, f2 = w2("./sha"), l = w2("./sha256"), c2 = w2("./rng"), d = { sha1: f2, sha256: l, md5: w2("./md5") }, h2 = 64, p2 = new a2(h2);
          function g2(e3, r3) {
            var o2 = d[e3 = e3 || "sha1"], i3 = [];
            return o2 || y2("algorithm:", e3, "is not yet supported"), { update: function(e4) {
              return a2.isBuffer(e4) || (e4 = new a2(e4)), i3.push(e4), e4.length, this;
            }, digest: function(e4) {
              var t2 = a2.concat(i3), n2 = r3 ? function(e5, t3, n3) {
                a2.isBuffer(t3) || (t3 = new a2(t3)), a2.isBuffer(n3) || (n3 = new a2(n3)), t3.length > h2 ? t3 = e5(t3) : t3.length < h2 && (t3 = a2.concat([t3, p2], h2));
                for (var r4 = new a2(h2), o3 = new a2(h2), i4 = 0; i4 < h2; i4++)
                  r4[i4] = 54 ^ t3[i4], o3[i4] = 92 ^ t3[i4];
                var u3 = e5(a2.concat([r4, n3]));
                return e5(a2.concat([o3, u3]));
              }(o2, r3, t2) : o2(t2);
              return i3 = null, e4 ? n2.toString(e4) : n2;
            } };
          }
          function y2() {
            var e3 = [].slice.call(arguments).join(" ");
            throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          p2.fill(0), b.createHash = function(e3) {
            return g2(e3);
          }, b.createHmac = g2, b.randomBytes = function(e3, t2) {
            if (!t2 || !t2.call)
              return new a2(c2(e3));
            try {
              t2.call(this, void 0, new a2(c2(e3)));
            } catch (e4) {
              t2(e4);
            }
          }, function(e3, t2) {
            for (var n2 in e3)
              t2(e3[n2], n2);
          }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function(e3) {
            b[e3] = function() {
              y2("sorry,", e3, "is not implemented yet");
            };
          });
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 10 }], 6: [function(w2, b, e) {
        (function(e2, t, n, r2, o, i2, u2, a2, s2) {
          var f2 = w2("./helpers");
          function l(e3, t2) {
            e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
            for (var n2 = 1732584193, r3 = -271733879, o2 = -1732584194, i3 = 271733878, u3 = 0; u3 < e3.length; u3 += 16) {
              var a3 = n2, s3 = r3, f3 = o2, l2 = i3, n2 = d(n2, r3, o2, i3, e3[u3 + 0], 7, -680876936), i3 = d(i3, n2, r3, o2, e3[u3 + 1], 12, -389564586), o2 = d(o2, i3, n2, r3, e3[u3 + 2], 17, 606105819), r3 = d(r3, o2, i3, n2, e3[u3 + 3], 22, -1044525330);
              n2 = d(n2, r3, o2, i3, e3[u3 + 4], 7, -176418897), i3 = d(i3, n2, r3, o2, e3[u3 + 5], 12, 1200080426), o2 = d(o2, i3, n2, r3, e3[u3 + 6], 17, -1473231341), r3 = d(r3, o2, i3, n2, e3[u3 + 7], 22, -45705983), n2 = d(n2, r3, o2, i3, e3[u3 + 8], 7, 1770035416), i3 = d(i3, n2, r3, o2, e3[u3 + 9], 12, -1958414417), o2 = d(o2, i3, n2, r3, e3[u3 + 10], 17, -42063), r3 = d(r3, o2, i3, n2, e3[u3 + 11], 22, -1990404162), n2 = d(n2, r3, o2, i3, e3[u3 + 12], 7, 1804603682), i3 = d(i3, n2, r3, o2, e3[u3 + 13], 12, -40341101), o2 = d(o2, i3, n2, r3, e3[u3 + 14], 17, -1502002290), n2 = h2(n2, r3 = d(r3, o2, i3, n2, e3[u3 + 15], 22, 1236535329), o2, i3, e3[u3 + 1], 5, -165796510), i3 = h2(i3, n2, r3, o2, e3[u3 + 6], 9, -1069501632), o2 = h2(o2, i3, n2, r3, e3[u3 + 11], 14, 643717713), r3 = h2(r3, o2, i3, n2, e3[u3 + 0], 20, -373897302), n2 = h2(n2, r3, o2, i3, e3[u3 + 5], 5, -701558691), i3 = h2(i3, n2, r3, o2, e3[u3 + 10], 9, 38016083), o2 = h2(o2, i3, n2, r3, e3[u3 + 15], 14, -660478335), r3 = h2(r3, o2, i3, n2, e3[u3 + 4], 20, -405537848), n2 = h2(n2, r3, o2, i3, e3[u3 + 9], 5, 568446438), i3 = h2(i3, n2, r3, o2, e3[u3 + 14], 9, -1019803690), o2 = h2(o2, i3, n2, r3, e3[u3 + 3], 14, -187363961), r3 = h2(r3, o2, i3, n2, e3[u3 + 8], 20, 1163531501), n2 = h2(n2, r3, o2, i3, e3[u3 + 13], 5, -1444681467), i3 = h2(i3, n2, r3, o2, e3[u3 + 2], 9, -51403784), o2 = h2(o2, i3, n2, r3, e3[u3 + 7], 14, 1735328473), n2 = p2(n2, r3 = h2(r3, o2, i3, n2, e3[u3 + 12], 20, -1926607734), o2, i3, e3[u3 + 5], 4, -378558), i3 = p2(i3, n2, r3, o2, e3[u3 + 8], 11, -2022574463), o2 = p2(o2, i3, n2, r3, e3[u3 + 11], 16, 1839030562), r3 = p2(r3, o2, i3, n2, e3[u3 + 14], 23, -35309556), n2 = p2(n2, r3, o2, i3, e3[u3 + 1], 4, -1530992060), i3 = p2(i3, n2, r3, o2, e3[u3 + 4], 11, 1272893353), o2 = p2(o2, i3, n2, r3, e3[u3 + 7], 16, -155497632), r3 = p2(r3, o2, i3, n2, e3[u3 + 10], 23, -1094730640), n2 = p2(n2, r3, o2, i3, e3[u3 + 13], 4, 681279174), i3 = p2(i3, n2, r3, o2, e3[u3 + 0], 11, -358537222), o2 = p2(o2, i3, n2, r3, e3[u3 + 3], 16, -722521979), r3 = p2(r3, o2, i3, n2, e3[u3 + 6], 23, 76029189), n2 = p2(n2, r3, o2, i3, e3[u3 + 9], 4, -640364487), i3 = p2(i3, n2, r3, o2, e3[u3 + 12], 11, -421815835), o2 = p2(o2, i3, n2, r3, e3[u3 + 15], 16, 530742520), n2 = g2(n2, r3 = p2(r3, o2, i3, n2, e3[u3 + 2], 23, -995338651), o2, i3, e3[u3 + 0], 6, -198630844), i3 = g2(i3, n2, r3, o2, e3[u3 + 7], 10, 1126891415), o2 = g2(o2, i3, n2, r3, e3[u3 + 14], 15, -1416354905), r3 = g2(r3, o2, i3, n2, e3[u3 + 5], 21, -57434055), n2 = g2(n2, r3, o2, i3, e3[u3 + 12], 6, 1700485571), i3 = g2(i3, n2, r3, o2, e3[u3 + 3], 10, -1894986606), o2 = g2(o2, i3, n2, r3, e3[u3 + 10], 15, -1051523), r3 = g2(r3, o2, i3, n2, e3[u3 + 1], 21, -2054922799), n2 = g2(n2, r3, o2, i3, e3[u3 + 8], 6, 1873313359), i3 = g2(i3, n2, r3, o2, e3[u3 + 15], 10, -30611744), o2 = g2(o2, i3, n2, r3, e3[u3 + 6], 15, -1560198380), r3 = g2(r3, o2, i3, n2, e3[u3 + 13], 21, 1309151649), n2 = g2(n2, r3, o2, i3, e3[u3 + 4], 6, -145523070), i3 = g2(i3, n2, r3, o2, e3[u3 + 11], 10, -1120210379), o2 = g2(o2, i3, n2, r3, e3[u3 + 2], 15, 718787259), r3 = g2(r3, o2, i3, n2, e3[u3 + 9], 21, -343485551), n2 = y2(n2, a3), r3 = y2(r3, s3), o2 = y2(o2, f3), i3 = y2(i3, l2);
            }
            return Array(n2, r3, o2, i3);
          }
          function c2(e3, t2, n2, r3, o2, i3) {
            return y2((u3 = y2(y2(t2, e3), y2(r3, i3))) << (a3 = o2) | u3 >>> 32 - a3, n2);
            var u3, a3;
          }
          function d(e3, t2, n2, r3, o2, i3, u3) {
            return c2(t2 & n2 | ~t2 & r3, e3, t2, o2, i3, u3);
          }
          function h2(e3, t2, n2, r3, o2, i3, u3) {
            return c2(t2 & r3 | n2 & ~r3, e3, t2, o2, i3, u3);
          }
          function p2(e3, t2, n2, r3, o2, i3, u3) {
            return c2(t2 ^ n2 ^ r3, e3, t2, o2, i3, u3);
          }
          function g2(e3, t2, n2, r3, o2, i3, u3) {
            return c2(n2 ^ (t2 | ~r3), e3, t2, o2, i3, u3);
          }
          function y2(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          b.exports = function(e3) {
            return f2.hash(e3, l, 16);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 7: [function(e, c2, t) {
        (function(e2, t2, n, r2, o, i2, u2, a2, s2) {
          var l;
          l = function(e3) {
            for (var t3, n2 = new Array(e3), r3 = 0; r3 < e3; r3++)
              0 == (3 & r3) && (t3 = 4294967296 * Math.random()), n2[r3] = t3 >>> ((3 & r3) << 3) & 255;
            return n2;
          }, c2.exports = l;
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 10 }], 8: [function(c2, d, e) {
        (function(e2, t, n, r2, o, i2, u2, a2, s2) {
          var f2 = c2("./helpers");
          function l(e3, t2) {
            e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
            for (var n2, r3, o2, i3, u3, a3 = Array(80), s3 = 1732584193, f3 = -271733879, l2 = -1732584194, c3 = 271733878, d2 = -1009589776, h2 = 0; h2 < e3.length; h2 += 16) {
              for (var p2 = s3, g2 = f3, y2 = l2, w2 = c3, b = d2, m2 = 0; m2 < 80; m2++) {
                a3[m2] = m2 < 16 ? e3[h2 + m2] : E(a3[m2 - 3] ^ a3[m2 - 8] ^ a3[m2 - 14] ^ a3[m2 - 16], 1);
                var v2 = _(_(E(s3, 5), (o2 = f3, i3 = l2, u3 = c3, (r3 = m2) < 20 ? o2 & i3 | ~o2 & u3 : !(r3 < 40) && r3 < 60 ? o2 & i3 | o2 & u3 | i3 & u3 : o2 ^ i3 ^ u3)), _(_(d2, a3[m2]), (n2 = m2) < 20 ? 1518500249 : n2 < 40 ? 1859775393 : n2 < 60 ? -1894007588 : -899497514)), d2 = c3, c3 = l2, l2 = E(f3, 30), f3 = s3, s3 = v2;
              }
              s3 = _(s3, p2), f3 = _(f3, g2), l2 = _(l2, y2), c3 = _(c3, w2), d2 = _(d2, b);
            }
            return Array(s3, f3, l2, c3, d2);
          }
          function _(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          function E(e3, t2) {
            return e3 << t2 | e3 >>> 32 - t2;
          }
          d.exports = function(e3) {
            return f2.hash(e3, l, 20, true);
          };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 9: [function(c2, d, e) {
        (function(e2, t, n, r2, o, i2, u2, a2, s2) {
          function B(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          function L2(e3, t2) {
            return e3 >>> t2 | e3 << 32 - t2;
          }
          function f2(e3, t2) {
            var n2, r3, o2, i3, u3, a3, s3, f3, l2, c3, d2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), h2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), p2 = new Array(64);
            e3[t2 >> 5] |= 128 << 24 - t2 % 32, e3[15 + (t2 + 64 >> 9 << 4)] = t2;
            for (var g2, y2, w2, b, m2, v2, _, E, I = 0; I < e3.length; I += 16) {
              n2 = h2[0], r3 = h2[1], o2 = h2[2], i3 = h2[3], u3 = h2[4], a3 = h2[5], s3 = h2[6], f3 = h2[7];
              for (var A = 0; A < 64; A++)
                p2[A] = A < 16 ? e3[A + I] : B(B(B((E = p2[A - 2], L2(E, 17) ^ L2(E, 19) ^ E >>> 10), p2[A - 7]), (_ = p2[A - 15], L2(_, 7) ^ L2(_, 18) ^ _ >>> 3)), p2[A - 16]), l2 = B(B(B(B(f3, L2(v2 = u3, 6) ^ L2(v2, 11) ^ L2(v2, 25)), (m2 = u3) & a3 ^ ~m2 & s3), d2[A]), p2[A]), c3 = B(L2(b = n2, 2) ^ L2(b, 13) ^ L2(b, 22), (g2 = n2) & (y2 = r3) ^ g2 & (w2 = o2) ^ y2 & w2), f3 = s3, s3 = a3, a3 = u3, u3 = B(i3, l2), i3 = o2, o2 = r3, r3 = n2, n2 = B(l2, c3);
              h2[0] = B(n2, h2[0]), h2[1] = B(r3, h2[1]), h2[2] = B(o2, h2[2]), h2[3] = B(i3, h2[3]), h2[4] = B(u3, h2[4]), h2[5] = B(a3, h2[5]), h2[6] = B(s3, h2[6]), h2[7] = B(f3, h2[7]);
            }
            return h2;
          }
          var l = c2("./helpers");
          d.exports = function(e3) {
            return l.hash(e3, f2, 32, true);
          };
        }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 10: [function(e, l, t) {
        (function(e2, t2, n, r2, o, i2, u2, a2, s2) {
          function f2() {
          }
          (e2 = l.exports = {}).nextTick = function() {
            var e3 = "undefined" != typeof window && window.setImmediate, t3 = "undefined" != typeof window && window.postMessage && window.addEventListener;
            if (e3)
              return function(e4) {
                return window.setImmediate(e4);
              };
            if (t3) {
              var n2 = [];
              return window.addEventListener("message", function(e4) {
                var t4 = e4.source;
                t4 !== window && null !== t4 || "process-tick" !== e4.data || (e4.stopPropagation(), 0 < n2.length && n2.shift()());
              }, true), function(e4) {
                n2.push(e4), window.postMessage("process-tick", "*");
              };
            }
            return function(e4) {
              setTimeout(e4, 0);
            };
          }(), e2.title = "browser", e2.browser = true, e2.env = {}, e2.argv = [], e2.on = f2, e2.addListener = f2, e2.once = f2, e2.off = f2, e2.removeListener = f2, e2.removeAllListeners = f2, e2.emit = f2, e2.binding = function(e3) {
            throw new Error("process.binding is not supported");
          }, e2.cwd = function() {
            return "/";
          }, e2.chdir = function(e3) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 10 }], 11: [function(e, t, f2) {
        (function(e2, t2, n, r2, o, i2, u2, a2, s2) {
          f2.read = function(e3, t3, n2, r3, o2) {
            var i3, u3, a3 = 8 * o2 - r3 - 1, s3 = (1 << a3) - 1, f3 = s3 >> 1, l = -7, c2 = n2 ? o2 - 1 : 0, d = n2 ? -1 : 1, h2 = e3[t3 + c2];
            for (c2 += d, i3 = h2 & (1 << -l) - 1, h2 >>= -l, l += a3; 0 < l; i3 = 256 * i3 + e3[t3 + c2], c2 += d, l -= 8)
              ;
            for (u3 = i3 & (1 << -l) - 1, i3 >>= -l, l += r3; 0 < l; u3 = 256 * u3 + e3[t3 + c2], c2 += d, l -= 8)
              ;
            if (0 === i3)
              i3 = 1 - f3;
            else {
              if (i3 === s3)
                return u3 ? NaN : 1 / 0 * (h2 ? -1 : 1);
              u3 += Math.pow(2, r3), i3 -= f3;
            }
            return (h2 ? -1 : 1) * u3 * Math.pow(2, i3 - r3);
          }, f2.write = function(e3, t3, n2, r3, o2, i3) {
            var u3, a3, s3, f3 = 8 * i3 - o2 - 1, l = (1 << f3) - 1, c2 = l >> 1, d = 23 === o2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h2 = r3 ? 0 : i3 - 1, p2 = r3 ? 1 : -1, g2 = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
            for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a3 = isNaN(t3) ? 1 : 0, u3 = l) : (u3 = Math.floor(Math.log(t3) / Math.LN2), t3 * (s3 = Math.pow(2, -u3)) < 1 && (u3--, s3 *= 2), 2 <= (t3 += 1 <= u3 + c2 ? d / s3 : d * Math.pow(2, 1 - c2)) * s3 && (u3++, s3 /= 2), l <= u3 + c2 ? (a3 = 0, u3 = l) : 1 <= u3 + c2 ? (a3 = (t3 * s3 - 1) * Math.pow(2, o2), u3 += c2) : (a3 = t3 * Math.pow(2, c2 - 1) * Math.pow(2, o2), u3 = 0)); 8 <= o2; e3[n2 + h2] = 255 & a3, h2 += p2, a3 /= 256, o2 -= 8)
              ;
            for (u3 = u3 << o2 | a3, f3 += o2; 0 < f3; e3[n2 + h2] = 255 & u3, h2 += p2, u3 /= 256, f3 -= 8)
              ;
            e3[n2 + h2 - p2] |= 128 * g2;
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 10 }] }, {}, [1])(1);
    });
  })(object_hash);
  var object_hashExports = object_hash.exports;
  const hash = /* @__PURE__ */ getDefaultExportFromCjs(object_hashExports);
  function chooseByUpdateTime(left, right, leftUpdateTime, rightUpdateTime) {
    if (leftUpdateTime === rightUpdateTime) {
      return hash(left) < hash(right) ? left : right;
    }
    return leftUpdateTime > rightUpdateTime ? left : right;
  }
  function newUuid() {
    return v4();
  }
  var __rest$E = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function isTombstone(element) {
    return element.isDeleted && !element.isArchived;
  }
  function isHeymergeArchivedListValue(element) {
    return element.isDeleted && !!element.isArchived;
  }
  function isHeymergeListValue(element) {
    return !element.isDeleted;
  }
  function unpackHeymergeList(list) {
    const output = {};
    for (const index of Object.keys(list)) {
      const item = Object.assign({}, list[index]);
      const unpacked = unpackHeymergeListElement(item);
      if (unpacked !== void 0) {
        output[index] = unpacked;
      }
    }
    return output;
  }
  function unpackHeymergeListElement(el) {
    if (!isHeymergeListValue(el)) {
      return void 0;
    }
    return unpackHeymergeListValue(el);
  }
  function unpackHeymergeListValue(val) {
    const stripped = __rest$E(val, ["isDeleted", "updateTime"]);
    return stripped;
  }
  function unpackHeymergeListArchive(list) {
    const output = {};
    for (const index of Object.keys(list)) {
      const item = Object.assign({}, list[index]);
      const unpacked = unpackHeymergeArchivedListElement(item);
      if (unpacked !== void 0) {
        output[index] = unpacked;
      }
    }
    return output;
  }
  function unpackHeymergeArchivedListElement(el) {
    if (!isHeymergeArchivedListValue(el)) {
      return void 0;
    }
    return unpackHeymergeArchivedListValue(el);
  }
  function unpackHeymergeArchivedListValue(val) {
    const stripped = __rest$E(val, ["isDeleted", "isArchived", "updateTime"]);
    return stripped;
  }
  function unpackHeymergeListElementContent(el) {
    return isHeymergeArchivedListValue(el) ? unpackHeymergeArchivedListValue(el) : unpackHeymergeListValue(el);
  }
  function addElement(list, timestamp, element) {
    const uuid = newUuid();
    const newElement = Object.assign(Object.assign({}, element), { isDeleted: false, updateTime: timestamp });
    return {
      newList: Object.assign(Object.assign({}, list), { [uuid]: newElement }),
      result: uuid
    };
  }
  function removeElement(list, timestamp, id) {
    if (!list[id]) {
      throw new ElementNotFoundError(id);
    }
    const tombstone = {
      isDeleted: true,
      isArchived: false,
      updateTime: guardMinUpdateTime(list[id].updateTime, timestamp)
    };
    return {
      newList: Object.assign(Object.assign({}, list), { [id]: tombstone }),
      result: void 0
    };
  }
  function archiveElement(list, timestamp, id) {
    const el = list[id];
    if (!el) {
      throw new ElementNotFoundError(id);
    }
    if (isTombstone(el)) {
      throw new ElementDeletedError(id);
    }
    const archivedElement = Object.assign(Object.assign({}, unpackHeymergeListElementContent(el)), { isDeleted: true, isArchived: true, updateTime: guardMinUpdateTime(el.updateTime, timestamp) });
    return {
      newList: Object.assign(Object.assign({}, list), { [id]: archivedElement }),
      result: void 0
    };
  }
  function restoreArchivedElement(list, timestamp, id) {
    const el = list[id];
    if (!el) {
      throw new ElementNotFoundError(id);
    }
    if (isTombstone(el)) {
      throw new ElementDeletedError(id);
    }
    const restoredElement = Object.assign(Object.assign({}, unpackHeymergeListElementContent(el)), { isDeleted: false, updateTime: guardMinUpdateTime(el.updateTime, timestamp) });
    return {
      newList: Object.assign(Object.assign({}, list), { [id]: restoredElement }),
      result: void 0
    };
  }
  function modifyElement(list, timestamp, id, listElement) {
    const oldElement = list[id];
    if (!oldElement || isTombstone(oldElement)) {
      throw new ElementNotFoundError(id);
    }
    if (isHeymergeArchivedListValue(oldElement)) {
      throw new ElementArchivedError(id);
    }
    const modifiedElement = Object.assign(Object.assign(Object.assign({}, oldElement), listElement), { updateTime: guardMinUpdateTime(list[id].updateTime, timestamp), isDeleted: false });
    return {
      newList: Object.assign(Object.assign({}, list), { [id]: modifiedElement }),
      result: void 0
    };
  }
  function addOrModifyElement(list, timestamp, id, listElement) {
    var _a2;
    const oldElement = list[id];
    if (oldElement !== void 0 && isHeymergeArchivedListValue(oldElement)) {
      throw new ElementArchivedError(id);
    }
    const oldContent = oldElement === void 0 || isTombstone(oldElement) ? {} : unpackHeymergeListValue(oldElement);
    return {
      newList: Object.assign(Object.assign({}, list), { [id]: Object.assign(Object.assign(Object.assign({}, oldContent), listElement), { updateTime: guardMinUpdateTime((_a2 = oldElement === null || oldElement === void 0 ? void 0 : oldElement.updateTime) !== null && _a2 !== void 0 ? _a2 : "", timestamp), isDeleted: false }) }),
      result: void 0
    };
  }
  function mergeListsByTimestamp(left, right, postMergeHook) {
    const indices = /* @__PURE__ */ new Set([...Object.keys(left), ...Object.keys(right)]);
    const outputList = {};
    for (const index of indices) {
      if (index in left && index in right) {
        outputList[index] = chooseByUpdateTimeWithHook(left[index], right[index], postMergeHook);
      } else if (index in left) {
        outputList[index] = left[index];
      } else {
        outputList[index] = right[index];
      }
    }
    return {
      newList: outputList,
      result: void 0
    };
  }
  function diffListsByTimestamp(base2, changed, postMergeHook) {
    const outputList = {};
    const indices = /* @__PURE__ */ new Set([...Object.keys(base2), ...Object.keys(changed)]);
    for (const index of indices) {
      if (index in base2 && index in changed) {
        const chosen = chooseByUpdateTimeWithHook(base2[index], changed[index], postMergeHook);
        if (chosen !== base2[index]) {
          outputList[index] = chosen;
        }
      } else if (index in changed) {
        outputList[index] = changed[index];
      } else {
        throw new InvalidHeymergeListError("Base contains Element not existing in changed List");
      }
    }
    return {
      newList: outputList,
      result: void 0
    };
  }
  function setMaxUpdateTime(list, timestamp) {
    const outputList = {};
    for (const index of Object.keys(list)) {
      const time = timestamp < list[index].updateTime ? timestamp : list[index].updateTime;
      outputList[index] = Object.assign(Object.assign({}, list[index]), { updateTime: time });
    }
    return { newList: outputList, result: true };
  }
  function getMaxUpdateTime(list) {
    let timestamp = (/* @__PURE__ */ new Date(0)).toISOString();
    for (const index of Object.keys(list)) {
      if (list[index].updateTime > timestamp) {
        timestamp = list[index].updateTime;
      }
    }
    return timestamp;
  }
  function guardMinUpdateTime(oldTime, newTime) {
    if (newTime > oldTime) {
      return newTime;
    }
    const shiftedTime = new Date(oldTime).getTime() + 1e3;
    return new Date(shiftedTime).toISOString();
  }
  function chooseByUpdateTimeWithHook(leftElement, rightElement, postMergeHook) {
    const chosenElement = chooseByUpdateTime(leftElement, rightElement, leftElement.updateTime, rightElement.updateTime);
    if (postMergeHook) {
      return postMergeHook(leftElement, rightElement, chosenElement);
    }
    return chosenElement;
  }
  function unpackHeymergeVaultContent(vaultContent) {
    let external = {};
    for (const [k, v2] of Object.entries(vaultContent)) {
      external = Object.assign(Object.assign({}, external), { [k]: unpackHeymergeList(v2) });
    }
    return external;
  }
  function unpackHeymergeVaultContentArchive(vaultContent) {
    let external = {};
    for (const [k, v2] of Object.entries(vaultContent)) {
      external = Object.assign(Object.assign({}, external), { [k]: unpackHeymergeListArchive(v2) });
    }
    return external;
  }
  function modifyVault$1(vaultContent, listKey, modification) {
    var _a2;
    const list = (_a2 = vaultContent[listKey]) !== null && _a2 !== void 0 ? _a2 : {};
    const { newList, result: result2 } = modification(list);
    return { newVaultContent: Object.assign(Object.assign({}, vaultContent), { [listKey]: newList }), result: result2 };
  }
  function diffVaults(base2, changed, postMergeHooks) {
    const keys2 = /* @__PURE__ */ new Set([...getObjectKeys$1(base2), ...getObjectKeys$1(changed)]);
    const outputContent = Object.assign({}, changed);
    for (const key of keys2) {
      if (key in base2 && key in changed) {
        const postMergeHook = postMergeHooks === null || postMergeHooks === void 0 ? void 0 : postMergeHooks[key];
        const { newList: diffList } = diffListsByTimestamp(base2[key], changed[key], postMergeHook);
        outputContent[key] = diffList;
      } else if (!(key in changed)) {
        throw new InvalidHeymergeVaultContentError("Key not present in changed Object");
      }
    }
    const newVaultContent = outputContent;
    return { newVaultContent, result: void 0 };
  }
  function mergeVaults(left, right, postMergeHooks) {
    const keys2 = /* @__PURE__ */ new Set([...getObjectKeys$1(left), ...getObjectKeys$1(right)]);
    const outputContent = Object.assign(Object.assign({}, left), right);
    for (const key of keys2) {
      if (key in left && key in right) {
        const postMergeHook = postMergeHooks === null || postMergeHooks === void 0 ? void 0 : postMergeHooks[key];
        const { newList: mergedList } = mergeListsByTimestamp(left[key], right[key], postMergeHook);
        outputContent[key] = mergedList;
      }
    }
    const newVaultContent = outputContent;
    return { newVaultContent, result: void 0 };
  }
  function getObjectKeys$1(obj) {
    return Object.keys(obj);
  }
  function getMaxVaultUpdateTime(vault) {
    let timestamp = (/* @__PURE__ */ new Date(0)).toISOString();
    for (const index of getObjectKeys$1(vault)) {
      const listMaxUpdateTime = getMaxUpdateTime(vault[index]);
      if (listMaxUpdateTime > timestamp) {
        timestamp = listMaxUpdateTime;
      }
    }
    return timestamp;
  }
  const DESCRIPTOR_VERSION_HEYMERGE = 2;
  const TEAM_META_VAULT_INFO_ID = nullUuid;
  const ORGANIZATION_ADMIN_VAULT_INFO_ID = nullUuid;
  const META_VAULT_ACCOUNT_SETTINGS_ID = nullUuid;
  const TeamMetaVaultContent = TeamMetaVaultContentV2;
  const { PermissionLevel } = GV2;
  const TEAM_USER_DEFAULT_PERMISSION_LEVEL = PermissionLevel.restricted;
  function getTeamMetaVaultInfo(content) {
    var _a2;
    return (_a2 = content.info) === null || _a2 === void 0 ? void 0 : _a2[TEAM_META_VAULT_INFO_ID];
  }
  const NEWLY_JOINED_RECENT_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
  function getNewlyJoinedInfo(content, profileId) {
    const user = content.users[profileId];
    if (!(user === null || user === void 0 ? void 0 : user.newlyJoined)) {
      return void 0;
    }
    const recent = Date.now() - new Date(user.joinedAt).getTime() < NEWLY_JOINED_RECENT_AGE_MS;
    return Object.assign(Object.assign({}, user.newlyJoined), { recent });
  }
  function getPermissionLevel(content, profileId) {
    var _a2;
    const user = content.users[profileId];
    return (_a2 = getValueWithPlaceholder(user === null || user === void 0 ? void 0 : user.permissionLevel)) !== null && _a2 !== void 0 ? _a2 : PermissionLevel.admin;
  }
  function createInitialVaultContent$3() {
    return { users: {}, info: {} };
  }
  const teamMetaVaultContentDescriptor = {
    version: 2,
    // "groupMeta" for compatibility, renamed to team later
    contentTypeName: "groupMeta",
    vaultTypes: [VaultType.TEAM_META, VaultType.INBOX_META],
    parseVaultContent: TeamMetaVaultContent.parse.bind(TeamMetaVaultContent),
    createInitialVaultContent: createInitialVaultContent$3
  };
  function modifyTeamVaultInfo(content, timestamp, info) {
    return modifyVault$1(content, "info", (list) => {
      if (!list[TEAM_META_VAULT_INFO_ID]) {
        return addOrModifyElement(list, timestamp, TEAM_META_VAULT_INFO_ID, Object.assign({
          // Default values
          name: ""
        }, info));
      }
      return modifyElement(list, timestamp, TEAM_META_VAULT_INFO_ID, info);
    });
  }
  function addOrModifyTeamVaultUser(content, timestamp, profileId, user) {
    return modifyVault$1(content, "users", (list) => {
      return addOrModifyElement(list, timestamp, profileId, Object.assign(Object.assign({ email: null, joinedAt: timestamp }, list[profileId]), user));
    });
  }
  function deleteTeamVaultUser(content, timestamp, profileId) {
    return modifyVault$1(content, "users", (list) => {
      try {
        return removeElement(list, timestamp, profileId);
      } catch (e) {
        if (e instanceof ElementNotFoundError) {
          return { newList: list, result: void 0 };
        }
        throw e;
      }
    });
  }
  function getLoggedInUserTeamPermissionLevel(accountState, meta) {
    var _a2;
    const isTeamOrgAdmin = meta.organizationId && ((_a2 = accountState.getOrganization(meta.organizationId)) === null || _a2 === void 0 ? void 0 : _a2.isAdmin);
    if (isTeamOrgAdmin) {
      return PermissionLevel.admin;
    }
    const profileId = meta.getProfileId();
    if (!profileId) {
      throw new Error("called getLoggedInUserTeamPermissionLevel on a foreign vault");
    }
    return getPermissionLevel(meta.getContent(), profileId);
  }
  class VaultAuthenticatorLock {
    constructor(authenticatorId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey) {
      this.authenticatorId = authenticatorId;
      this.encryptedStorableVaultKey = encryptedStorableVaultKey;
      this.encryptedHighSecurityVaultKey = encryptedHighSecurityVaultKey;
      this.encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKey;
    }
    static create(authenticator, vaultSecret, protectedSecret, messagePrivateKey) {
      const encryptedStorableVaultKey = asymCreateKek(authenticator.storableVaultKeyEncPubKey, vaultSecret);
      const encryptedHighSecurityVaultKey = asymCreateKek(authenticator.highSecurityVaultKeyEncPubKey, protectedSecret);
      const encryptedVaultMessagePrivateKey = messagePrivateKey === null ? null : asymEncryptEncryptionPrivateKey(authenticator.highSecurityVaultKeyEncPubKey, messagePrivateKey);
      return new VaultAuthenticatorLock(authenticator.id, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
    }
    static load({ authenticatorId, encryptedStorableVaultKey: encryptedStorableVaultKeyData, encryptedHighSecurityVaultKey: encryptedHighSecurityVaultKeyData, encryptedVaultMessagePrivateKey: encryptedVaultMessagePrivateKeyData }) {
      const encryptedStorableVaultKey = loadAsymEncryptedSymmetricKey(encryptedStorableVaultKeyData);
      const encryptedHighSecurityVaultKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityVaultKeyData);
      const encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKeyData === null ? null : loadAsymEncryptedEncryptionPrivateKey(encryptedVaultMessagePrivateKeyData);
      return new VaultAuthenticatorLock(authenticatorId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
    }
  }
  class VaultProfileLock {
    constructor(lockingProfileId, lockingProfileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey) {
      this.lockingProfileId = lockingProfileId;
      this.lockingProfileKeyGenerationId = lockingProfileKeyGenerationId;
      this.encryptedStorableVaultKey = encryptedStorableVaultKey;
      this.encryptedHighSecurityVaultKey = encryptedHighSecurityVaultKey;
      this.encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKey;
    }
    static create(profile, vaultSecret, protectedSecret, messagePrivateKey) {
      const encryptedStorableVaultKey = asymCreateKek(profile.storableVaultKeyEncPubKey, vaultSecret);
      const encryptedHighSecurityVaultKey = asymCreateKek(profile.highSecurityVaultKeyEncPubKey, protectedSecret);
      const encryptedVaultMessagePrivateKey = messagePrivateKey === null ? null : asymEncryptEncryptionPrivateKey(profile.highSecurityVaultKeyEncPubKey, messagePrivateKey);
      const profileId = profile instanceof UnsyncedProfile ? nullUuid : profile.id;
      const profileKeyGenerationId = profile instanceof UnsyncedProfile ? nullUuid : profile.keyGenerationId;
      return new VaultProfileLock(profileId, profileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
    }
    static load({ lockingProfileId, lockingProfileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey }) {
      return new VaultProfileLock(lockingProfileId, lockingProfileKeyGenerationId, loadAsymEncryptedSymmetricKey(encryptedStorableVaultKey), loadAsymEncryptedSymmetricKey(encryptedHighSecurityVaultKey), encryptedVaultMessagePrivateKey !== null ? loadAsymEncryptedEncryptionPrivateKey(encryptedVaultMessagePrivateKey) : null);
    }
  }
  function protect(protectedSecret, value) {
    const encoder2 = new TextEncoder();
    const encrypted = encode$1(symEncrypt(protectedSecret, encoder2.encode(value.unencrypted)));
    return {
      contentId: value.contentId,
      encrypted,
      isEmpty: value.unencrypted === ""
    };
  }
  function unlockLockProtectedSecret(vaultAccess, locks, profileLock, adminProfileLock, profileRepo, hsc) {
    if (vaultAccess.type === "profile") {
      const { unlockedProfile: up, hsup: vaultHsup } = vaultAccess;
      if (!profileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
      }
      const hsup = vaultHsup !== null && vaultHsup !== void 0 ? vaultHsup : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(up, profileRepo);
      if (!hsup) {
        throw new LockProfileNotFoundError(profileLock.lockingProfileId);
      }
      const messagePrivateKey = profileLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsup.highSecurityVaultKeyEncPrivKey, profileLock.encryptedVaultMessagePrivateKey) : null;
      return {
        protectedSecret: asymDecryptKek(hsup.highSecurityVaultKeyEncPrivKey, profileLock.encryptedHighSecurityVaultKey),
        messagePrivateKey
      };
    } else if (vaultAccess.type === "admin-profile") {
      const { unlockedProfile: up, hsup: vaultHsup } = vaultAccess;
      if (!adminProfileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
      }
      const hsup = vaultHsup !== null && vaultHsup !== void 0 ? vaultHsup : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(up, profileRepo);
      if (!hsup) {
        throw new LockProfileNotFoundError(adminProfileLock.lockingProfileId);
      }
      const messagePrivateKey = adminProfileLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsup.highSecurityVaultKeyEncPrivKey, adminProfileLock.encryptedVaultMessagePrivateKey) : null;
      return {
        protectedSecret: asymDecryptKek(hsup.highSecurityVaultKeyEncPrivKey, adminProfileLock.encryptedHighSecurityVaultKey),
        messagePrivateKey
      };
    } else {
      const { unlockedAuthenticator, hsua: vaultHsua } = vaultAccess;
      const hsua = vaultHsua !== null && vaultHsua !== void 0 ? vaultHsua : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedAuthenticator();
      if (!hsua) {
        throw new LockAuthenticatorNotFoundError(unlockedAuthenticator.authenticator.id, locks);
      }
      const candidateLock = locks.find((lock) => lock.authenticatorId === hsua.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(hsua.authenticator.id, locks);
      }
      const messagePrivateKey = candidateLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedVaultMessagePrivateKey) : null;
      return {
        protectedSecret: asymDecryptKek(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedHighSecurityVaultKey),
        messagePrivateKey
      };
    }
  }
  function unprotect(protectedSecret, value) {
    const decoder2 = new TextDecoder();
    return decoder2.decode(symDecrypt(protectedSecret, loadSymEncryptedBlob(value.encrypted)));
  }
  function unprotectWithContentId(protectedSecret, value) {
    var _a2;
    return {
      contentId: (_a2 = value.contentId) !== null && _a2 !== void 0 ? _a2 : null,
      unencrypted: unprotect(protectedSecret, value)
    };
  }
  var __awaiter$Q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function getProfileInVault(profileRepo, v2) {
    var _a2, _b2, _c2, _d2;
    if ("profiles" in v2) {
      return (_b2 = (_a2 = v2.profiles.find(({ id }) => profileRepo.hasProfile(id))) === null || _a2 === void 0 ? void 0 : _a2.id) !== null && _b2 !== void 0 ? _b2 : null;
    } else {
      return (_d2 = (_c2 = v2.profileIds) === null || _c2 === void 0 ? void 0 : _c2.find((id) => profileRepo.hasProfile(id))) !== null && _d2 !== void 0 ? _d2 : null;
    }
  }
  function findPersonalVaultId(accountState, vaultRepo, orgId, profileId) {
    const org = accountState.getOrganization(orgId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    const personalVault = vaultRepo.getOrganizationPersonalLoginVault(orgId);
    if ((personalVault === null || personalVault === void 0 ? void 0 : personalVault.getPersonalProfileId()) === profileId) {
      return personalVault.id;
    }
    const toOrgProfile = org.profiles.find((op) => op.profileId === profileId);
    if (!toOrgProfile) {
      throw new Error("tried to link to non-existing org profile");
    }
    if (!toOrgProfile.personalVaultId) {
      throw new Error("tried to link to profile with no known personal vault");
    }
    return toOrgProfile.personalVaultId;
  }
  function onlineCheckCanLinkToVault(backendClient, orgId, vaultId) {
    return __awaiter$Q(this, void 0, void 0, function* () {
      const { messagePublicKeys } = yield backendClient.vault.listMessagePublicKeys(orgId, [vaultId]);
      if (messagePublicKeys[0].key.length === 0) {
        throw new VaultLinkingNotSupportedError(vaultId);
      }
    });
  }
  const { LegacyOrganizationAdminVaultContent } = LOAV;
  function getLegacyOrganizationAdminVaultInfo(content) {
    var _a2;
    return (_a2 = content.info) === null || _a2 === void 0 ? void 0 : _a2[ORGANIZATION_ADMIN_VAULT_INFO_ID];
  }
  function createInitialVaultContent$2() {
    return { info: {} };
  }
  const legacyOrganizationAdminVaultContentDescriptor = {
    version: 2,
    // 'organizationAdmin' for compatibility, this vault type will be removed later
    contentTypeName: "organizationAdmin",
    vaultTypes: [VaultType.LEGACY_ORGANIZATION_ADMIN],
    parseVaultContent: LegacyOrganizationAdminVaultContent.parse.bind(LegacyOrganizationAdminVaultContent),
    createInitialVaultContent: createInitialVaultContent$2
  };
  function replaceLegacyOrganizationAdminVaultInfo(content, timestamp, info) {
    return modifyVault$1(content, "info", (list) => {
      return addOrModifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function modifyLegacyOrganizationAdminVaultInfo(content, timestamp, info) {
    return modifyVault$1(content, "info", (list) => {
      return modifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function getBackendClientForVault(ccs, v2) {
    if (getProfileInVault(ccs.profileRepo, v2)) {
      return ccs.backendClient;
    }
    const org = v2.organizationId ? ccs.accountState.getOrganization(v2.organizationId) : void 0;
    if (org === null || org === void 0 ? void 0 : org.adminInfo) {
      if (org.adminProfileId) {
        return ccs.backendClient;
      }
      return ccs.backendClient.withPermissionUserId(org.superUserId);
    }
    throw new NoOrganizationAdminError();
  }
  function getSuperUserHighSecurityUnlockedAuthenticator(protectedSecretRepo, adminVault, authenticator) {
    const info = getLegacyOrganizationAdminVaultInfo(adminVault.getContent());
    if (!info.authenticatorSecret) {
      return null;
    }
    const seed = protectedSecretRepo.unprotect(adminVault, info.authenticatorSecret.seed);
    const pinnedSecret = {
      authenticatorId: authenticator.id,
      seed: naclUtilExports.decodeBase64(seed)
    };
    const auth = loadAuthenticator(authenticator);
    const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(auth, pinnedSecret);
    return hsua;
  }
  var __decorate$3 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  class HighSecurityUnlockedProfile {
    constructor(up, highSecuritySeed) {
      this.up = up;
      this.highSecuritySeed = highSecuritySeed;
    }
    static fromSeed(up, highSecuritySeed) {
      return new HighSecurityUnlockedProfile(up, highSecuritySeed);
    }
    static fromAuthenticatorLocks(up, hsua) {
      const locks = up.profile.authenticatorLocks;
      const candidateLock = locks.find((lock) => lock.authenticatorId === hsua.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(hsua.authenticator.id, locks);
      }
      const highSecuritySeed = asymDecrypt(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedHighSecurityProfileSeed);
      return new HighSecurityUnlockedProfile(up, highSecuritySeed);
    }
    static fromProfileLock(up, parentHsup) {
      var _a2;
      if (((_a2 = up.profile.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) !== parentHsup.up.profile.id) {
        throw new LockProfileNotFoundError(up.profile.profileLock.lockingProfileId);
      }
      const highSecuritySeed = asymDecrypt(parentHsup.highSecurityProfileSeedEncPrivKey, up.profile.profileLock.encryptedHighSecurityProfileSeed);
      return new HighSecurityUnlockedProfile(up, highSecuritySeed);
    }
    createAuthenticatorLock(authenticator) {
      return Object.assign(Object.assign({}, ProfileAuthenticatorLock.create(authenticator, this.highSecuritySeed, this.up.storableSeed)), { profileId: this.up.profile.id, profileKeyGenerationId: this.up.profile.keyGenerationId });
    }
    createProfileLock(profile) {
      return Object.assign(Object.assign({}, ProfileProfileLock.create(profile, this.highSecuritySeed, this.up.storableSeed)), { profileId: this.up.profile.id, profileKeyGenerationId: this.up.profile.keyGenerationId });
    }
    get highSecurityIdentitySigPrivKey() {
      return deriveSigningKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
    }
    get highSecurityVaultKeyEncPrivKey() {
      return deriveEncryptionKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
    }
    get highSecurityProfileSeedEncPrivKey() {
      return deriveEncryptionKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY).encPrivKey;
    }
  }
  __decorate$3([
    Lazy
  ], HighSecurityUnlockedProfile.prototype, "highSecurityIdentitySigPrivKey", null);
  __decorate$3([
    Lazy
  ], HighSecurityUnlockedProfile.prototype, "highSecurityVaultKeyEncPrivKey", null);
  __decorate$3([
    Lazy
  ], HighSecurityUnlockedProfile.prototype, "highSecurityProfileSeedEncPrivKey", null);
  function isHighSecurityOrgAdminProfile(hsup) {
    const { up } = hsup;
    return up.profile.profileType === ProfileType.ORGANIZATION_ADMIN && !!up.profile.organizationId;
  }
  function getDirectVaultAccess(profileRepo, hsc, v2) {
    var _a2;
    const vaultProfileId = getProfileInVault(profileRepo, v2);
    if (vaultProfileId) {
      const unlockedProfile = profileRepo.getUnlocked(vaultProfileId);
      if (!unlockedProfile) {
        throw new ProfileNotFoundError(vaultProfileId);
      }
      return {
        type: "profile",
        unlockedProfile,
        hsup: (_a2 = hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(unlockedProfile, profileRepo)) !== null && _a2 !== void 0 ? _a2 : null
      };
    }
    return null;
  }
  function getVaultAccess(ccs, hsc, v2) {
    const directVaultAccess = getDirectVaultAccess(ccs.profileRepo, hsc, v2);
    if (directVaultAccess) {
      return directVaultAccess;
    }
    const org = v2.organizationId ? ccs.accountState.getOrganization(v2.organizationId) : void 0;
    if (!(org === null || org === void 0 ? void 0 : org.adminInfo)) {
      throw new NoOrganizationAdminError();
    }
    if (!ccs.protectedSecretRepo) {
      const unlockedProfile = ccs.profileRepo.getOrgAdminProfile(org.id);
      if (unlockedProfile) {
        return {
          type: "admin-profile",
          unlockedProfile,
          hsup: null,
          orgId: org.id
        };
      }
      const unlockedAuthenticator = ccs.superUserUnlockedAuthenticators[org.id];
      if (unlockedAuthenticator) {
        return {
          type: "admin-authenticator",
          unlockedAuthenticator,
          hsua: null,
          orgId: org.id
        };
      }
      throw new NoOrganizationAdminError();
    }
    const orgVaultAccess = getOrgAdminVaultAccess(ccs.protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, hsc, org);
    if (orgVaultAccess) {
      return orgVaultAccess;
    }
    throw new NoOrganizationAdminError();
  }
  function getOrgAdminVaultAccess(protectedSecretRepo, vaultRepo, profileRepo, hsc, org) {
    var _a2, _b2;
    if (!org.adminInfo) {
      return null;
    }
    if ((_a2 = org.adminInfo) === null || _a2 === void 0 ? void 0 : _a2.authenticator) {
      if (!org.adminInfo.legacyAdminVaultId) {
        throw new Error("no admin vault for legacy org, this should never happen!");
      }
      const adminVault = vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
      if (!adminVault) {
        return null;
      }
      const orgHsua = getSuperUserHighSecurityUnlockedAuthenticator(protectedSecretRepo, adminVault, org.adminInfo.authenticator);
      if (!orgHsua) {
        return null;
      }
      return {
        type: "admin-authenticator",
        unlockedAuthenticator: orgHsua.getUnlockedAuthenticator(),
        hsua: orgHsua,
        orgId: org.id
      };
    } else if ((_b2 = org.adminInfo) === null || _b2 === void 0 ? void 0 : _b2.adminProfile) {
      if (!hsc) {
        return null;
      }
      const up = profileRepo.getOrgAdminProfile(org.id);
      if (!up) {
        return null;
      }
      const orgHsup = hsc.getHighSecurityUnlockedProfile(up, profileRepo);
      if (!isHighSecurityOrgAdminProfile(orgHsup)) {
        throw new Error(`expected org admin profile (${ProfileType.ORGANIZATION_ADMIN}), got ${up.profile.profileType}`);
      }
      return {
        type: "admin-profile",
        unlockedProfile: up,
        hsup: orgHsup,
        orgId: org.id
      };
    }
    return null;
  }
  class ProtectedSecretRepo {
    constructor(protectedSecrets, unlockedUntil, cachedOrganizations) {
      this.protectedSecrets = protectedSecrets;
      this.unlockedUntil = unlockedUntil;
      this.cachedOrganizations = cachedOrganizations;
    }
    static create(ccs, hsc, unlockedUntil) {
      const protectedSecrets = {};
      ccs.vaultRepo.getAllVaults().forEach((vault) => {
        if (vault.isUserJoined) {
          try {
            const vaultAccess = getVaultAccess(ccs, hsc, vault);
            const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(vaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo);
            protectedSecrets[vault.id] = {
              generationId: vault.generationId,
              protectedSecret,
              messagePrivateKey
            };
          } catch (e) {
            if (e instanceof DomainError$1 && e.code === ClientCoreErrorCode.ProfileKeyGenerationMismatch) {
              return;
            }
            throw e;
          }
        }
      });
      return new ProtectedSecretRepo(protectedSecrets, unlockedUntil, /* @__PURE__ */ new Set());
    }
    withOrganization(orgId, orgProtectedSecrets) {
      const protectedSecrets = Object.assign(Object.assign({}, this.protectedSecrets), orgProtectedSecrets);
      const cachedOrganizations = /* @__PURE__ */ new Set([...this.cachedOrganizations, orgId]);
      return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, cachedOrganizations);
    }
    withUnlockedUntil(unlockedUntil) {
      return new ProtectedSecretRepo(this.protectedSecrets, unlockedUntil, this.cachedOrganizations);
    }
    withProtectedSecret({ id: vaultId, generationId }, protectedSecret, messagePrivateKey) {
      const protectedSecrets = Object.assign({}, this.protectedSecrets);
      protectedSecrets[vaultId] = { generationId, protectedSecret, messagePrivateKey };
      return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, this.cachedOrganizations);
    }
    withDeleteProtectedSecret(vaultId) {
      const protectedSecrets = Object.assign({}, this.protectedSecrets);
      delete protectedSecrets[vaultId];
      return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, this.cachedOrganizations);
    }
    isUnlocked() {
      if (this.unlockedUntil === null) {
        return true;
      }
      const now = /* @__PURE__ */ new Date();
      return this.unlockedUntil.getTime() >= now.getTime();
    }
    protect(vault, value) {
      const secret = this.getSecret(vault, CannotProtectError);
      return protect(secret, value);
    }
    unprotect(vault, value) {
      const secret = this.getSecret(vault, CannotUnprotectError);
      return unprotect(secret, value);
    }
    unprotectWithContentId(vault, value) {
      const secret = this.getSecret(vault, CannotUnprotectError);
      return unprotectWithContentId(secret, value);
    }
    decryptVaultMessage(vault, message) {
      var _a2;
      if (!((_a2 = message.encryptedData) === null || _a2 === void 0 ? void 0 : _a2.length)) {
        return void 0;
      }
      const privateKey = this.getVaultMessagePrivateKey(vault, CannotDecryptVaultMessageError);
      if (!privateKey) {
        throw new CannotDecryptVaultMessageError("no vault message private key");
      }
      return asymDecrypt(privateKey, loadAsymEncryptedBlob(message.encryptedData));
    }
    createLock(vault, authenticator) {
      const protectedSecret = this.getSecret(vault, CannotCreateLockError);
      const messagePrivateKey = this.getVaultMessagePrivateKey(vault, CannotCreateLockError);
      return VaultAuthenticatorLock.create(authenticator, vault.vaultSecret, protectedSecret, messagePrivateKey);
    }
    createProfileLock(vault, profile) {
      const protectedSecret = this.getSecret(vault, CannotCreateLockError);
      const messagePrivateKey = this.getVaultMessagePrivateKey(vault, CannotCreateLockError);
      return VaultProfileLock.create(profile, vault.vaultSecret, protectedSecret, messagePrivateKey);
    }
    getProtectedSecretFunctions(vault) {
      this.getSecret(vault, VaultProtectedSecretNotFoundError);
      const decryptVaultMessage = vault.messagePublicKey ? (msg) => this.decryptVaultMessage(vault, msg) : null;
      return {
        protect: (v2) => this.protect(vault, v2),
        unprotect: (v2) => this.unprotect(vault, v2),
        unprotectWithContentId: (v2) => this.unprotectWithContentId(vault, v2),
        decryptVaultMessage
      };
    }
    hasVault(vaultId) {
      return !!this.protectedSecrets[vaultId];
    }
    getSecret(vault, ErrorConstructor) {
      this.checkProtectedSecretPrecondition(ErrorConstructor);
      const entry = this.protectedSecrets[vault.id];
      if (!entry) {
        throw new ProtectInternalError(`No protected secret for vault: ${vault.id}}!`);
      }
      if (entry.generationId !== vault.generationId) {
        throw new ProtectInternalError(`Incorrect vault generation: got ${vault.generationId}, expected ${entry.generationId}`);
      }
      return entry.protectedSecret;
    }
    getVaultMessagePrivateKey(vault, ErrorConstructor) {
      this.checkProtectedSecretPrecondition(ErrorConstructor);
      const entry = this.protectedSecrets[vault.id];
      if (!entry) {
        throw new ProtectInternalError(`No protected secret for vault: ${vault.id}}!`);
      }
      if (entry.generationId !== vault.generationId) {
        throw new ProtectInternalError(`Incorrect vault generation: got ${vault.generationId}, expected ${entry.generationId}`);
      }
      return entry.messagePrivateKey;
    }
    checkProtectedSecretPrecondition(ErrorConstructor) {
      if (!this.isUnlocked()) {
        const msg = `Vault protectedSecret expired at ${this.unlockedUntil} but was still present at ${/* @__PURE__ */ new Date()}.`;
        trackError(new Error(msg));
        throw new ErrorConstructor();
      }
    }
  }
  var __rest$D = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function internalCheckLoginAchievements(_a2) {
    var ccs = __rest$D(_a2, []);
    const achievements = [];
    const privateLoginVault = ccs.vaultRepo.getPrivateLoginVault();
    if (privateLoginVault) {
      const numLogins = Object.keys(privateLoginVault.getContent().logins).length;
      if (numLogins >= 1024)
        achievements.push(Achievement.COR_LOGINS_TOTAL_1024);
      if (numLogins >= 512)
        achievements.push(Achievement.COR_LOGINS_TOTAL_512);
      if (numLogins >= 256)
        achievements.push(Achievement.COR_LOGINS_TOTAL_256);
      if (numLogins >= 128)
        achievements.push(Achievement.COR_LOGINS_TOTAL_128);
      if (numLogins >= 64)
        achievements.push(Achievement.COR_LOGINS_TOTAL_64);
      if (numLogins >= 32)
        achievements.push(Achievement.COR_LOGINS_TOTAL_32);
      if (numLogins >= 16)
        achievements.push(Achievement.COR_LOGINS_TOTAL_16);
      if (numLogins >= 8)
        achievements.push(Achievement.COR_LOGINS_TOTAL_8);
      if (numLogins >= 4)
        achievements.push(Achievement.COR_LOGINS_TOTAL_4);
      if (numLogins >= 2)
        achievements.push(Achievement.COR_LOGINS_TOTAL_2);
      if (numLogins >= 1)
        achievements.push(Achievement.COR_LOGINS_TOTAL_1);
      ccs.accountState = ccs.accountState.withLocalAchievements(achievements);
    }
    return ccs;
  }
  function internalWriteAuditlogEvent(ccs, organizationId, ...events) {
    if (!organizationId) {
      return ccs;
    }
    const queuedEvents = events.map((event) => {
      var _a2;
      return {
        clientTime: /* @__PURE__ */ new Date(),
        organizationId,
        lastKnownServerTime: (_a2 = ccs.lastKnownServerTime) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Date(0),
        event
      };
    });
    return Object.assign(Object.assign({}, ccs), { auditlogEventQueue: [...ccs.auditlogEventQueue, ...queuedEvents] });
  }
  var __rest$C = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function modifyVault(_a2, vault, mod, requireUnlock, hsc) {
    var ccs = __rest$C(_a2, []);
    let modifiedVault;
    let returnResult;
    if (requireUnlock) {
      const protectedSecretFunctions = getProtectedSecretFunctions(ccs, vault, hsc);
      ({ vault: modifiedVault, result: returnResult } = vault.withModification((c2, t, operation) => mod(c2, t, Object.assign(Object.assign({}, operation), protectedSecretFunctions))));
    } else {
      ({ vault: modifiedVault, result: returnResult } = vault.withModification((c2, t, operation) => mod(c2, t, operation)));
    }
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
    return Object.assign(Object.assign({}, ccs), { returnResult, modifiedVault });
  }
  function modifyLoginVault(_a2, vault, mod, hsc) {
    var ccs = __rest$C(_a2, []);
    if (vault.type === VaultType.TEAM) {
      const pair = ccs.vaultRepo.getTeamVaultPairById(vault.id);
      if (!pair) {
        throw new VaultNotFoundError(vault.id);
      }
      const permissionLevel = getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta);
      if (permissionLevel !== PermissionLevel.admin && permissionLevel !== PermissionLevel.member) {
        throw new VaultPermissionDeniedError();
      }
    }
    const protectedSecretFunctions = getProtectedSecretFunctions(ccs, vault, hsc);
    let auditlogEvents;
    const { vault: postChangeVault, result: returnResult, vaultContentDiff } = vault.withModification((c2, t, operation) => {
      const result2 = mod(c2, t, Object.assign(Object.assign({}, operation), protectedSecretFunctions));
      auditlogEvents = result2.auditlogEvents;
      return result2;
    });
    let modifiedVault = postChangeVault;
    const messages2 = extractLinkedUpdateMessages(vault.id, vault.getPersonalProfileId(), vault.getContent(), protectedSecretFunctions, vaultContentDiff);
    if (messages2.length) {
      modifiedVault = modifiedVault.withAddLinkedUpdateMessage(...messages2);
    }
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
    if (vault.type === VaultType.PRIVATE) {
      ccs = internalCheckLoginAchievements(ccs);
    }
    if (auditlogEvents) {
      ccs = internalWriteAuditlogEvent(ccs, vault.organizationId, ...auditlogEvents);
    }
    return Object.assign(Object.assign({}, ccs), { returnResult, modifiedVault });
  }
  function getProtectedSecretFunctions(ccs, vault, hsc) {
    var _a2;
    if ((_a2 = ccs.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.isUnlocked()) {
      return ccs.protectedSecretRepo.getProtectedSecretFunctions(vault);
    }
    if (hsc) {
      return ProtectedSecretRepo.create(ccs, hsc, null).getProtectedSecretFunctions(vault);
    }
    throw new ClientCoreIsLockedError();
  }
  var __awaiter$P = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$B = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const MAX_REVISION_AGE_MS = 90 * 24 * 60 * 60 * 1e3;
  function internalDeleteOutdatedLoginHistory(_a2, vaultId, loginId) {
    var ccs = __rest$B(_a2, []);
    return __awaiter$P(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const lastKnownServerTime = ccs.lastKnownServerTime;
      if (!lastKnownServerTime) {
        return ccs;
      }
      const cutoffDate = new Date(lastKnownServerTime.getTime() - MAX_REVISION_AGE_MS);
      const previousLogin = vault.getContent().logins[loginId];
      if (!previousLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (!hasHistory(previousLogin)) {
        return ccs;
      }
      const recentRevisionIds = getRecentRevisionIds(previousLogin.history, cutoffDate);
      const baseRevisionIds = /* @__PURE__ */ new Set();
      for (const id of recentRevisionIds) {
        const baseRevisionId = previousLogin.history.revisions[id].baseRevisionId;
        if (baseRevisionId && !recentRevisionIds.has(baseRevisionId)) {
          baseRevisionIds.add(baseRevisionId);
        }
      }
      const keptRevisionCount = recentRevisionIds.size + baseRevisionIds.size;
      if (keptRevisionCount === Object.keys(previousLogin.history.revisions).length) {
        return ccs;
      }
      const revisions = {};
      for (const [id, revision] of Object.entries(previousLogin.history.revisions)) {
        if (recentRevisionIds.has(id) || baseRevisionIds.has(id)) {
          revisions[id] = revision;
        }
      }
      return modifyLoginVault(ccs, vault, (c2, t, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const result2 = modifyLoginInternal2(c2, t, loginId, {
          history: Object.assign(Object.assign({}, previousLogin.history), { revisions })
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
    });
  }
  function hasHistory(login) {
    return !!login.history;
  }
  var __awaiter$O = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$A = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const MAX_OPENED_SHARE_LINK_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
  function internalDeleteOutdatedShareLinks(_a2, vaultId, loginId) {
    var ccs = __rest$A(_a2, []);
    return __awaiter$O(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const lastKnownServerTime = ccs.lastKnownServerTime;
      if (!lastKnownServerTime) {
        return ccs;
      }
      const previousLogin = vault.getContent().logins[loginId];
      if (!previousLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (!previousLogin.shareLinks) {
        return ccs;
      }
      const cutoffDate = new Date(lastKnownServerTime.getTime() - MAX_OPENED_SHARE_LINK_AGE_MS);
      const newShareLinks = previousLogin.shareLinks.filter((sl) => {
        if (!sl.openedAt) {
          return true;
        }
        const openedAtDate = new Date(sl.openedAt);
        return openedAtDate.getTime() > cutoffDate.getTime();
      });
      if (newShareLinks.length === previousLogin.shareLinks.length) {
        return ccs;
      }
      return modifyLoginVault(ccs, vault, (c2, t, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const result2 = modifyLoginInternal2(c2, t, loginId, {
          shareLinks: newShareLinks
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
    });
  }
  var __rest$z = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function internalLoginSetConfirmed(_a2, vaultId, loginId) {
    var ccs = __rest$z(_a2, []);
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    const { vault: updatedVault } = vault.withModification((c2, t, { modifyLoginInternal: modifyLoginInternal2 }) => modifyLoginInternal2(c2, t, loginId, { pendingInboxConfirmation: false }));
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(updatedVault);
    return ccs;
  }
  var __rest$y = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function internalTeamClearNewlyJoined(_a2, teamId) {
    var ccs = __rest$y(_a2, []);
    const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
    if (!pair) {
      throw new VaultNotFoundError(teamId);
    }
    const profileId = pair.meta.getProfileId();
    if (!profileId) {
      throw new Error("tried to call internalTeamClearNewlyJoined on a foreign vault");
    }
    const { vault } = pair.meta.withModification((c2, t, { addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => addOrModifyTeamVaultUser2(c2, t, profileId, { newlyJoined: void 0 }));
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
    return ccs;
  }
  var __rest$x = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function internalTeamSetUserPermissionLevels(_a2, teamId, ...profiles) {
    var ccs = __rest$x(_a2, []);
    const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
    if (!pair) {
      throw new VaultNotFoundError(teamId);
    }
    if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== "admin") {
      throw new VaultPermissionDeniedError();
    }
    const updatesMetaVault = pair.meta.withModification((c2, t, { addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => {
      let newVaultContent = c2;
      for (const { profileId, permissionLevel } of profiles) {
        newVaultContent = addOrModifyTeamVaultUser2(newVaultContent, t, profileId, {
          permissionLevel
        }).newVaultContent;
      }
      return { newVaultContent, result: void 0 };
    }).vault;
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(updatesMetaVault);
    return ccs;
  }
  var __rest$w = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function internalUpdateMetaSession(_a2, sessionId, session) {
    var ccs = __rest$w(_a2, []);
    const vault = ccs.vaultRepo.getMetaVault();
    if (!vault) {
      throw new MetaVaultNotFoundError();
    }
    const { vault: modifiedVault } = vault.withModification((contents, t, { replaceSession: replaceSession2 }) => {
      return replaceSession2(contents, t, sessionId, session);
    });
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
    return ccs;
  }
  function groupBy(list, key) {
    if (list.length === 0) {
      return {};
    }
    list.sort((a2, b) => {
      const k1 = key(a2);
      const k2 = key(b);
      if (k1 === k2) {
        return 0;
      }
      return k1 < k2 ? -1 : 1;
    });
    const result2 = {};
    let currentStart = 0;
    let currentKey = key(list[0]);
    for (let i2 = 0; i2 < list.length; i2++) {
      const k = key(list[i2]);
      result2[currentKey] = list.slice(currentStart, i2);
      if (k !== currentKey) {
        result2[currentKey] = list.slice(currentStart, i2);
        currentKey = k;
        currentStart = i2;
      }
    }
    result2[currentKey] = list.slice(currentStart, list.length);
    return result2;
  }
  function getLoginDifferences(left, right) {
    return genericGetLoginDifferences(left, right, LOGIN_KEYS);
  }
  function genericGetLoginDifferences(left, right, keys2) {
    const result2 = [];
    for (const key of keys2) {
      if (!isLoginDifferenceIncludedKey(key)) {
        continue;
      }
      if (key === "creditCard") {
        result2.push(...getCreditCardDifference(left.creditCard, right.creditCard));
      } else if (key === "customFields") {
        result2.push(...getCustomFieldDifference(left.customFields, right.customFields));
      } else if (!isEqual(left[key], right[key])) {
        result2.push({ type: "login", key });
      }
    }
    return result2;
  }
  function getCreditCardDifference(left, right) {
    const result2 = [];
    for (const key of LOGIN_CREDIT_CARD_KEYS) {
      if (!isLoginDifferenceCreditCardIncludedKey(key)) {
        continue;
      }
      if (!isEqual(left === null || left === void 0 ? void 0 : left[key], right === null || right === void 0 ? void 0 : right[key]) || // Always report all fields as changed if CreditCard switches from set to unset or vice versa.
      left === void 0 && right !== void 0 || left !== void 0 && right === void 0) {
        result2.push({ type: "creditCard", key });
      }
    }
    return result2;
  }
  function getCustomFieldDifference(left, right) {
    var _a2;
    const leftFieldsById = groupBy(left, (cf) => cf.id);
    const rightFieldsById = groupBy(right, (cf) => cf.id);
    const ids = /* @__PURE__ */ new Set([...Object.keys(leftFieldsById), ...Object.keys(rightFieldsById)]);
    const result2 = [];
    for (const id of ids) {
      const leftValues = leftFieldsById[id];
      const rightValues = rightFieldsById[id];
      const leftValue = leftValues === null || leftValues === void 0 ? void 0 : leftValues[0];
      const rightValue = rightValues === null || rightValues === void 0 ? void 0 : rightValues[0];
      if (!isEqual(leftValue === null || leftValue === void 0 ? void 0 : leftValue.value, rightValue === null || rightValue === void 0 ? void 0 : rightValue.value)) {
        const name = (_a2 = leftValue === null || leftValue === void 0 ? void 0 : leftValue.name) !== null && _a2 !== void 0 ? _a2 : rightValue === null || rightValue === void 0 ? void 0 : rightValue.name;
        if (name !== void 0) {
          result2.push({ type: "customField", id, name });
        }
      }
    }
    return result2;
  }
  function isLoginDifferenceIncludedKey(k) {
    return typeof k === "string" && !LOGIN_DIFFERENCE_IGNORED_KEYS.includes(k);
  }
  function isLoginDifferenceCreditCardIncludedKey(k) {
    return typeof k === "string" && !LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS.includes(k);
  }
  function isEqual(leftValue, rightValue) {
    if (isProtectedValue(leftValue) && isProtectedValue(rightValue)) {
      return leftValue.contentId === rightValue.contentId;
    }
    if (leftValue === void 0 && isEmptyValue(rightValue) || isEmptyValue(leftValue) && rightValue === void 0) {
      return true;
    }
    return deepEqual$1(leftValue, rightValue, { strict: true });
  }
  function isProtectedValue(obj) {
    return typeof obj === "object" && obj !== null && Object.keys(obj).length === 2 && "contentId" in obj && typeof obj.contentId === "string" && "encrypted" in obj && typeof obj.encrypted === "string";
  }
  function isEmptyValue(value) {
    return (Array.isArray(value) || typeof value === "string") && value.length === 0;
  }
  function getWebsiteAttributesEntry(unnormalizedWebsite) {
    const websiteAttributesEntry = {};
    const protocol = getProtocol(unnormalizedWebsite);
    if (protocol) {
      websiteAttributesEntry.protocol = protocol;
    }
    return websiteAttributesEntry;
  }
  function getProtocol(website) {
    let url;
    try {
      url = new URL(website);
    } catch (_a2) {
      return null;
    }
    switch (url.protocol) {
      case "http:":
        return LoginWebsiteProtocol.http;
      case "https:":
        return LoginWebsiteProtocol.https;
      default:
        return null;
    }
  }
  var cardTypes$1 = {
    visa: {
      niceType: "Visa",
      type: "visa",
      patterns: [4],
      gaps: [4, 8, 12],
      lengths: [16, 18, 19],
      code: {
        name: "CVV",
        size: 3
      }
    },
    mastercard: {
      niceType: "Mastercard",
      type: "mastercard",
      patterns: [[51, 55], [2221, 2229], [223, 229], [23, 26], [270, 271], 2720],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVC",
        size: 3
      }
    },
    "american-express": {
      niceType: "American Express",
      type: "american-express",
      patterns: [34, 37],
      gaps: [4, 10],
      lengths: [15],
      code: {
        name: "CID",
        size: 4
      }
    },
    "diners-club": {
      niceType: "Diners Club",
      type: "diners-club",
      patterns: [[300, 305], 36, 38, 39],
      gaps: [4, 10],
      lengths: [14, 16, 19],
      code: {
        name: "CVV",
        size: 3
      }
    },
    discover: {
      niceType: "Discover",
      type: "discover",
      patterns: [6011, [644, 649], 65],
      gaps: [4, 8, 12],
      lengths: [16, 19],
      code: {
        name: "CID",
        size: 3
      }
    },
    jcb: {
      niceType: "JCB",
      type: "jcb",
      patterns: [2131, 1800, [3528, 3589]],
      gaps: [4, 8, 12],
      lengths: [16, 17, 18, 19],
      code: {
        name: "CVV",
        size: 3
      }
    },
    unionpay: {
      niceType: "UnionPay",
      type: "unionpay",
      patterns: [
        620,
        [624, 626],
        [62100, 62182],
        [62184, 62187],
        [62185, 62197],
        [62200, 62205],
        [622010, 622999],
        622018,
        [622019, 622999],
        [62207, 62209],
        [622126, 622925],
        [623, 626],
        6270,
        6272,
        6276,
        [627700, 627779],
        [627781, 627799],
        [6282, 6289],
        6291,
        6292,
        810,
        [8110, 8131],
        [8132, 8151],
        [8152, 8163],
        [8164, 8171]
      ],
      gaps: [4, 8, 12],
      lengths: [14, 15, 16, 17, 18, 19],
      code: {
        name: "CVN",
        size: 3
      }
    },
    maestro: {
      niceType: "Maestro",
      type: "maestro",
      patterns: [
        493698,
        [5e5, 504174],
        [504176, 506698],
        [506779, 508999],
        [56, 59],
        63,
        67,
        6
      ],
      gaps: [4, 8, 12],
      lengths: [12, 13, 14, 15, 16, 17, 18, 19],
      code: {
        name: "CVC",
        size: 3
      }
    },
    elo: {
      niceType: "Elo",
      type: "elo",
      patterns: [
        401178,
        401179,
        438935,
        457631,
        457632,
        431274,
        451416,
        457393,
        504175,
        [506699, 506778],
        [509e3, 509999],
        627780,
        636297,
        636368,
        [650031, 650033],
        [650035, 650051],
        [650405, 650439],
        [650485, 650538],
        [650541, 650598],
        [650700, 650718],
        [650720, 650727],
        [650901, 650978],
        [651652, 651679],
        [655e3, 655019],
        [655021, 655058]
      ],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVE",
        size: 3
      }
    },
    mir: {
      niceType: "Mir",
      type: "mir",
      patterns: [[2200, 2204]],
      gaps: [4, 8, 12],
      lengths: [16, 17, 18, 19],
      code: {
        name: "CVP2",
        size: 3
      }
    },
    hiper: {
      niceType: "Hiper",
      type: "hiper",
      patterns: [637095, 63737423, 63743358, 637568, 637599, 637609, 637612],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVC",
        size: 3
      }
    },
    hipercard: {
      niceType: "Hipercard",
      type: "hipercard",
      patterns: [606282],
      gaps: [4, 8, 12],
      lengths: [16],
      code: {
        name: "CVC",
        size: 3
      }
    }
  };
  var cardTypes_1 = cardTypes$1;
  var addMatchingCardsToResults$1 = {};
  var clone$1 = {};
  Object.defineProperty(clone$1, "__esModule", { value: true });
  clone$1.clone = void 0;
  function clone(originalObject) {
    if (!originalObject) {
      return null;
    }
    return JSON.parse(JSON.stringify(originalObject));
  }
  clone$1.clone = clone;
  var matches$1 = {};
  Object.defineProperty(matches$1, "__esModule", { value: true });
  matches$1.matches = void 0;
  function matchesRange(cardNumber2, min, max2) {
    var maxLengthToCheck = String(min).length;
    var substr = cardNumber2.substr(0, maxLengthToCheck);
    var integerRepresentationOfCardNumber = parseInt(substr, 10);
    min = parseInt(String(min).substr(0, substr.length), 10);
    max2 = parseInt(String(max2).substr(0, substr.length), 10);
    return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max2;
  }
  function matchesPattern(cardNumber2, pattern) {
    pattern = String(pattern);
    return pattern.substring(0, cardNumber2.length) === cardNumber2.substring(0, pattern.length);
  }
  function matches(cardNumber2, pattern) {
    if (Array.isArray(pattern)) {
      return matchesRange(cardNumber2, pattern[0], pattern[1]);
    }
    return matchesPattern(cardNumber2, pattern);
  }
  matches$1.matches = matches;
  Object.defineProperty(addMatchingCardsToResults$1, "__esModule", { value: true });
  addMatchingCardsToResults$1.addMatchingCardsToResults = void 0;
  var clone_1$1 = clone$1;
  var matches_1 = matches$1;
  function addMatchingCardsToResults(cardNumber2, cardConfiguration, results) {
    var i2, patternLength;
    for (i2 = 0; i2 < cardConfiguration.patterns.length; i2++) {
      var pattern = cardConfiguration.patterns[i2];
      if (!matches_1.matches(cardNumber2, pattern)) {
        continue;
      }
      var clonedCardConfiguration = clone_1$1.clone(cardConfiguration);
      if (Array.isArray(pattern)) {
        patternLength = String(pattern[0]).length;
      } else {
        patternLength = String(pattern).length;
      }
      if (cardNumber2.length >= patternLength) {
        clonedCardConfiguration.matchStrength = patternLength;
      }
      results.push(clonedCardConfiguration);
      break;
    }
  }
  addMatchingCardsToResults$1.addMatchingCardsToResults = addMatchingCardsToResults;
  var isValidInputType$1 = {};
  Object.defineProperty(isValidInputType$1, "__esModule", { value: true });
  isValidInputType$1.isValidInputType = void 0;
  function isValidInputType(cardNumber2) {
    return typeof cardNumber2 === "string" || cardNumber2 instanceof String;
  }
  isValidInputType$1.isValidInputType = isValidInputType;
  var findBestMatch$1 = {};
  Object.defineProperty(findBestMatch$1, "__esModule", { value: true });
  findBestMatch$1.findBestMatch = void 0;
  function hasEnoughResultsToDetermineBestMatch(results) {
    var numberOfResultsWithMaxStrengthProperty = results.filter(function(result2) {
      return result2.matchStrength;
    }).length;
    return numberOfResultsWithMaxStrengthProperty > 0 && numberOfResultsWithMaxStrengthProperty === results.length;
  }
  function findBestMatch(results) {
    if (!hasEnoughResultsToDetermineBestMatch(results)) {
      return null;
    }
    return results.reduce(function(bestMatch, result2) {
      if (!bestMatch) {
        return result2;
      }
      if (Number(bestMatch.matchStrength) < Number(result2.matchStrength)) {
        return result2;
      }
      return bestMatch;
    });
  }
  findBestMatch$1.findBestMatch = findBestMatch;
  var __assign$1 = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign$1 = Object.assign || function(t) {
      for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t[p2] = s2[p2];
      }
      return t;
    };
    return __assign$1.apply(this, arguments);
  };
  var cardTypes = cardTypes_1;
  var add_matching_cards_to_results_1 = addMatchingCardsToResults$1;
  var is_valid_input_type_1 = isValidInputType$1;
  var find_best_match_1 = findBestMatch$1;
  var clone_1 = clone$1;
  var customCards = {};
  var cardNames = {
    VISA: "visa",
    MASTERCARD: "mastercard",
    AMERICAN_EXPRESS: "american-express",
    DINERS_CLUB: "diners-club",
    DISCOVER: "discover",
    JCB: "jcb",
    UNIONPAY: "unionpay",
    MAESTRO: "maestro",
    ELO: "elo",
    MIR: "mir",
    HIPER: "hiper",
    HIPERCARD: "hipercard"
  };
  var ORIGINAL_TEST_ORDER = [
    cardNames.VISA,
    cardNames.MASTERCARD,
    cardNames.AMERICAN_EXPRESS,
    cardNames.DINERS_CLUB,
    cardNames.DISCOVER,
    cardNames.JCB,
    cardNames.UNIONPAY,
    cardNames.MAESTRO,
    cardNames.ELO,
    cardNames.MIR,
    cardNames.HIPER,
    cardNames.HIPERCARD
  ];
  var testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
  function findType(cardType) {
    return customCards[cardType] || cardTypes[cardType];
  }
  function getAllCardTypes() {
    return testOrder.map(function(cardType) {
      return clone_1.clone(findType(cardType));
    });
  }
  function getCardPosition(name, ignoreErrorForNotExisting) {
    if (ignoreErrorForNotExisting === void 0) {
      ignoreErrorForNotExisting = false;
    }
    var position = testOrder.indexOf(name);
    if (!ignoreErrorForNotExisting && position === -1) {
      throw new Error('"' + name + '" is not a supported card type.');
    }
    return position;
  }
  function creditCardType$1(cardNumber2) {
    var results = [];
    if (!is_valid_input_type_1.isValidInputType(cardNumber2)) {
      return results;
    }
    if (cardNumber2.length === 0) {
      return getAllCardTypes();
    }
    testOrder.forEach(function(cardType) {
      var cardConfiguration = findType(cardType);
      add_matching_cards_to_results_1.addMatchingCardsToResults(cardNumber2, cardConfiguration, results);
    });
    var bestMatch = find_best_match_1.findBestMatch(results);
    if (bestMatch) {
      return [bestMatch];
    }
    return results;
  }
  creditCardType$1.getTypeInfo = function(cardType) {
    return clone_1.clone(findType(cardType));
  };
  creditCardType$1.removeCard = function(name) {
    var position = getCardPosition(name);
    testOrder.splice(position, 1);
  };
  creditCardType$1.addCard = function(config) {
    var existingCardPosition = getCardPosition(config.type, true);
    customCards[config.type] = config;
    if (existingCardPosition === -1) {
      testOrder.push(config.type);
    }
  };
  creditCardType$1.updateCard = function(cardType, updates) {
    var originalObject = customCards[cardType] || cardTypes[cardType];
    if (!originalObject) {
      throw new Error('"' + cardType + "\" is not a recognized type. Use `addCard` instead.'");
    }
    if (updates.type && originalObject.type !== updates.type) {
      throw new Error("Cannot overwrite type parameter.");
    }
    var clonedCard = clone_1.clone(originalObject);
    clonedCard = __assign$1(__assign$1({}, clonedCard), updates);
    customCards[clonedCard.type] = clonedCard;
  };
  creditCardType$1.changeOrder = function(name, position) {
    var currentPosition = getCardPosition(name);
    testOrder.splice(currentPosition, 1);
    testOrder.splice(position, 0, name);
  };
  creditCardType$1.resetModifications = function() {
    testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
    customCards = {};
  };
  creditCardType$1.types = cardNames;
  var dist$1 = creditCardType$1;
  var cardholderName$1 = {};
  Object.defineProperty(cardholderName$1, "__esModule", { value: true });
  cardholderName$1.cardholderName = void 0;
  var CARD_NUMBER_REGEX = /^[\d\s-]*$/;
  var MAX_LENGTH = 255;
  function verification$6(isValid2, isPotentiallyValid) {
    return { isValid: isValid2, isPotentiallyValid };
  }
  function cardholderName(value) {
    if (typeof value !== "string") {
      return verification$6(false, false);
    }
    if (value.length === 0) {
      return verification$6(false, true);
    }
    if (value.length > MAX_LENGTH) {
      return verification$6(false, false);
    }
    if (CARD_NUMBER_REGEX.test(value)) {
      return verification$6(false, true);
    }
    return verification$6(true, true);
  }
  cardholderName$1.cardholderName = cardholderName;
  var cardNumber$1 = {};
  function luhn10$1(identifier) {
    var sum = 0;
    var alt = false;
    var i2 = identifier.length - 1;
    var num;
    while (i2 >= 0) {
      num = parseInt(identifier.charAt(i2), 10);
      if (alt) {
        num *= 2;
        if (num > 9) {
          num = num % 10 + 1;
        }
      }
      alt = !alt;
      sum += num;
      i2--;
    }
    return sum % 10 === 0;
  }
  var luhn10_1 = luhn10$1;
  Object.defineProperty(cardNumber$1, "__esModule", { value: true });
  cardNumber$1.cardNumber = void 0;
  var luhn10 = luhn10_1;
  var getCardTypes = dist$1;
  function verification$5(card, isPotentiallyValid, isValid2) {
    return {
      card,
      isPotentiallyValid,
      isValid: isValid2
    };
  }
  function cardNumber(value, options) {
    if (options === void 0) {
      options = {};
    }
    var isPotentiallyValid, isValid2, maxLength;
    if (typeof value !== "string" && typeof value !== "number") {
      return verification$5(null, false, false);
    }
    var testCardValue = String(value).replace(/-|\s/g, "");
    if (!/^\d*$/.test(testCardValue)) {
      return verification$5(null, false, false);
    }
    var potentialTypes = getCardTypes(testCardValue);
    if (potentialTypes.length === 0) {
      return verification$5(null, false, false);
    } else if (potentialTypes.length !== 1) {
      return verification$5(null, true, false);
    }
    var cardType = potentialTypes[0];
    if (options.maxLength && testCardValue.length > options.maxLength) {
      return verification$5(cardType, false, false);
    }
    if (cardType.type === getCardTypes.types.UNIONPAY && options.luhnValidateUnionPay !== true) {
      isValid2 = true;
    } else {
      isValid2 = luhn10(testCardValue);
    }
    maxLength = Math.max.apply(null, cardType.lengths);
    if (options.maxLength) {
      maxLength = Math.min(options.maxLength, maxLength);
    }
    for (var i2 = 0; i2 < cardType.lengths.length; i2++) {
      if (cardType.lengths[i2] === testCardValue.length) {
        isPotentiallyValid = testCardValue.length < maxLength || isValid2;
        return verification$5(cardType, isPotentiallyValid, isValid2);
      }
    }
    return verification$5(cardType, testCardValue.length < maxLength, false);
  }
  cardNumber$1.cardNumber = cardNumber;
  var expirationDate$1 = {};
  var parseDate$1 = {};
  var expirationYear$1 = {};
  Object.defineProperty(expirationYear$1, "__esModule", { value: true });
  expirationYear$1.expirationYear = void 0;
  var DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE = 19;
  function verification$4(isValid2, isPotentiallyValid, isCurrentYear) {
    return {
      isValid: isValid2,
      isPotentiallyValid,
      isCurrentYear: isCurrentYear || false
    };
  }
  function expirationYear(value, maxElapsedYear) {
    if (maxElapsedYear === void 0) {
      maxElapsedYear = DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE;
    }
    var isCurrentYear;
    if (typeof value !== "string") {
      return verification$4(false, false);
    }
    if (value.replace(/\s/g, "") === "") {
      return verification$4(false, true);
    }
    if (!/^\d*$/.test(value)) {
      return verification$4(false, false);
    }
    var len = value.length;
    if (len < 2) {
      return verification$4(false, true);
    }
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    if (len === 3) {
      var firstTwo = value.slice(0, 2);
      var currentFirstTwo = String(currentYear).slice(0, 2);
      return verification$4(false, firstTwo === currentFirstTwo);
    }
    if (len > 4) {
      return verification$4(false, false);
    }
    var numericValue = parseInt(value, 10);
    var twoDigitYear = Number(String(currentYear).substr(2, 2));
    var valid = false;
    if (len === 2) {
      if (String(currentYear).substr(0, 2) === value) {
        return verification$4(false, true);
      }
      isCurrentYear = twoDigitYear === numericValue;
      valid = numericValue >= twoDigitYear && numericValue <= twoDigitYear + maxElapsedYear;
    } else if (len === 4) {
      isCurrentYear = currentYear === numericValue;
      valid = numericValue >= currentYear && numericValue <= currentYear + maxElapsedYear;
    }
    return verification$4(valid, valid, isCurrentYear);
  }
  expirationYear$1.expirationYear = expirationYear;
  var isArray = {};
  Object.defineProperty(isArray, "__esModule", { value: true });
  isArray.isArray = void 0;
  isArray.isArray = Array.isArray || function(arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };
  Object.defineProperty(parseDate$1, "__esModule", { value: true });
  parseDate$1.parseDate = void 0;
  var expiration_year_1$2 = expirationYear$1;
  var is_array_1 = isArray;
  function getNumberOfMonthDigitsInDateString(dateString) {
    var firstCharacter = Number(dateString[0]);
    var assumedYear;
    if (firstCharacter === 0) {
      return 2;
    }
    if (firstCharacter > 1) {
      return 1;
    }
    if (firstCharacter === 1 && Number(dateString[1]) > 2) {
      return 1;
    }
    if (firstCharacter === 1) {
      assumedYear = dateString.substr(1);
      return expiration_year_1$2.expirationYear(assumedYear).isPotentiallyValid ? 1 : 2;
    }
    if (dateString.length === 5) {
      return 1;
    }
    if (dateString.length > 5) {
      return 2;
    }
    return 1;
  }
  function parseDate(datestring) {
    var date2;
    if (/^\d{4}-\d{1,2}$/.test(datestring)) {
      date2 = datestring.split("-").reverse();
    } else if (/\//.test(datestring)) {
      date2 = datestring.split(/\s*\/\s*/g);
    } else if (/\s/.test(datestring)) {
      date2 = datestring.split(/ +/g);
    }
    if (is_array_1.isArray(date2)) {
      return {
        month: date2[0] || "",
        year: date2.slice(1).join()
      };
    }
    var numberOfDigitsInMonth = getNumberOfMonthDigitsInDateString(datestring);
    var month = datestring.substr(0, numberOfDigitsInMonth);
    return {
      month,
      year: datestring.substr(month.length)
    };
  }
  parseDate$1.parseDate = parseDate;
  var expirationMonth$1 = {};
  Object.defineProperty(expirationMonth$1, "__esModule", { value: true });
  expirationMonth$1.expirationMonth = void 0;
  function verification$3(isValid2, isPotentiallyValid, isValidForThisYear) {
    return {
      isValid: isValid2,
      isPotentiallyValid,
      isValidForThisYear: isValidForThisYear || false
    };
  }
  function expirationMonth(value) {
    var currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
    if (typeof value !== "string") {
      return verification$3(false, false);
    }
    if (value.replace(/\s/g, "") === "" || value === "0") {
      return verification$3(false, true);
    }
    if (!/^\d*$/.test(value)) {
      return verification$3(false, false);
    }
    var month = parseInt(value, 10);
    if (isNaN(Number(value))) {
      return verification$3(false, false);
    }
    var result2 = month > 0 && month < 13;
    return verification$3(result2, result2, result2 && month >= currentMonth);
  }
  expirationMonth$1.expirationMonth = expirationMonth;
  var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t[p2] = s2[p2];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(expirationDate$1, "__esModule", { value: true });
  expirationDate$1.expirationDate = void 0;
  var parse_date_1 = parseDate$1;
  var expiration_month_1$1 = expirationMonth$1;
  var expiration_year_1$1 = expirationYear$1;
  function verification$2(isValid2, isPotentiallyValid, month, year) {
    return {
      isValid: isValid2,
      isPotentiallyValid,
      month,
      year
    };
  }
  function expirationDate(value, maxElapsedYear) {
    var date2;
    if (typeof value === "string") {
      value = value.replace(/^(\d\d) (\d\d(\d\d)?)$/, "$1/$2");
      date2 = parse_date_1.parseDate(String(value));
    } else if (value !== null && typeof value === "object") {
      var fullDate = __assign({}, value);
      date2 = {
        month: String(fullDate.month),
        year: String(fullDate.year)
      };
    } else {
      return verification$2(false, false, null, null);
    }
    var monthValid = expiration_month_1$1.expirationMonth(date2.month);
    var yearValid = expiration_year_1$1.expirationYear(date2.year, maxElapsedYear);
    if (monthValid.isValid) {
      if (yearValid.isCurrentYear) {
        var isValidForThisYear = monthValid.isValidForThisYear;
        return verification$2(isValidForThisYear, isValidForThisYear, date2.month, date2.year);
      }
      if (yearValid.isValid) {
        return verification$2(true, true, date2.month, date2.year);
      }
    }
    if (monthValid.isPotentiallyValid && yearValid.isPotentiallyValid) {
      return verification$2(false, true, null, null);
    }
    return verification$2(false, false, null, null);
  }
  expirationDate$1.expirationDate = expirationDate;
  var cvv$1 = {};
  Object.defineProperty(cvv$1, "__esModule", { value: true });
  cvv$1.cvv = void 0;
  var DEFAULT_LENGTH = 3;
  function includes(array, thing) {
    for (var i2 = 0; i2 < array.length; i2++) {
      if (thing === array[i2]) {
        return true;
      }
    }
    return false;
  }
  function max(array) {
    var maximum = DEFAULT_LENGTH;
    var i2 = 0;
    for (; i2 < array.length; i2++) {
      maximum = array[i2] > maximum ? array[i2] : maximum;
    }
    return maximum;
  }
  function verification$1(isValid2, isPotentiallyValid) {
    return { isValid: isValid2, isPotentiallyValid };
  }
  function cvv(value, maxLength) {
    if (maxLength === void 0) {
      maxLength = DEFAULT_LENGTH;
    }
    maxLength = maxLength instanceof Array ? maxLength : [maxLength];
    if (typeof value !== "string") {
      return verification$1(false, false);
    }
    if (!/^\d*$/.test(value)) {
      return verification$1(false, false);
    }
    if (includes(maxLength, value.length)) {
      return verification$1(true, true);
    }
    if (value.length < Math.min.apply(null, maxLength)) {
      return verification$1(false, true);
    }
    if (value.length > max(maxLength)) {
      return verification$1(false, false);
    }
    return verification$1(true, true);
  }
  cvv$1.cvv = cvv;
  var postalCode$1 = {};
  Object.defineProperty(postalCode$1, "__esModule", { value: true });
  postalCode$1.postalCode = void 0;
  var DEFAULT_MIN_POSTAL_CODE_LENGTH = 3;
  function verification(isValid2, isPotentiallyValid) {
    return { isValid: isValid2, isPotentiallyValid };
  }
  function postalCode(value, options) {
    if (options === void 0) {
      options = {};
    }
    var minLength = options.minLength || DEFAULT_MIN_POSTAL_CODE_LENGTH;
    if (typeof value !== "string") {
      return verification(false, false);
    } else if (value.length < minLength) {
      return verification(false, true);
    }
    return verification(true, true);
  }
  postalCode$1.postalCode = postalCode;
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m2[k];
    } });
  } : function(o, m2, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
    Object.defineProperty(o, "default", { enumerable: true, value: v2 });
  } : function(o, v2) {
    o["default"] = v2;
  });
  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result2 = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result2, mod, k);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
  var creditCardType = __importStar(dist$1);
  var cardholder_name_1 = cardholderName$1;
  var card_number_1 = cardNumber$1;
  var expiration_date_1 = expirationDate$1;
  var expiration_month_1 = expirationMonth$1;
  var expiration_year_1 = expirationYear$1;
  var cvv_1 = cvv$1;
  var postal_code_1 = postalCode$1;
  var cardValidator = {
    creditCardType,
    cardholderName: cardholder_name_1.cardholderName,
    number: card_number_1.cardNumber,
    expirationDate: expiration_date_1.expirationDate,
    expirationMonth: expiration_month_1.expirationMonth,
    expirationYear: expiration_year_1.expirationYear,
    cvv: cvv_1.cvv,
    postalCode: postal_code_1.postalCode
  };
  var dist = cardValidator;
  const cardValidator$1 = /* @__PURE__ */ getDefaultExportFromCjs(dist);
  function normalizeCreditCard(creditCard) {
    var _a2, _b2, _c2, _d2;
    const normalizedNumber = creditCard.number ? normalizeCreditCardNumber(creditCard.number) : { number: "", displayMaskedNumber: "", displayType: "" };
    const normalizedCreditCard = Object.assign(Object.assign({ pin: (_a2 = creditCard.pin) !== null && _a2 !== void 0 ? _a2 : "", securityCode: (_b2 = creditCard.securityCode) !== null && _b2 !== void 0 ? _b2 : "" }, normalizedNumber), { cardHolder: (_d2 = (_c2 = creditCard.cardHolder) === null || _c2 === void 0 ? void 0 : _c2.trim()) !== null && _d2 !== void 0 ? _d2 : "", expiration: creditCard.expiration ? normalizeCreditCardExpiration(creditCard.expiration) : "" });
    if (Object.values(normalizedCreditCard).every((v2) => v2 === "")) {
      return void 0;
    }
    return normalizedCreditCard;
  }
  function normalizeCreditCardNumber(inputNumber) {
    var _a2, _b2;
    const cardNumberValidation = cardValidator$1.number(inputNumber);
    if (!cardNumberValidation.card || !cardNumberValidation.isValid) {
      const number3 = inputNumber.trim();
      const displayMaskedNumber2 = number3.replace(/\d/g, "*");
      return { number: number3, displayMaskedNumber: displayMaskedNumber2, displayType: (_b2 = (_a2 = cardNumberValidation.card) === null || _a2 === void 0 ? void 0 : _a2.niceType) !== null && _b2 !== void 0 ? _b2 : "" };
    }
    const { card } = cardNumberValidation;
    const cardNumberDigits = inputNumber.replace(/\D/g, "");
    const offsets = [0, ...card.gaps, cardNumberDigits.length];
    const components = [];
    for (let i2 = 0; offsets[i2] < cardNumberDigits.length; i2++) {
      const start = offsets[i2];
      const end = Math.min(offsets[i2 + 1], cardNumberDigits.length);
      components.push(cardNumberDigits.substring(start, end));
    }
    const number2 = components.join(" ");
    const displayMaskedNumber = components.map((c2, i2) => i2 === components.length - 1 ? c2 : c2.replace(/\d/g, "*")).join(" ");
    return { number: number2, displayMaskedNumber, displayType: cardNumberValidation.card.niceType };
  }
  function normalizeCreditCardExpiration(expiration) {
    var _a2, _b2;
    const expirationValidation = cardValidator$1.expirationDate(expiration, Infinity);
    if (!expirationValidation.isValid || !expirationValidation.month || !expirationValidation.year) {
      const match2 = /^\s*(?<month>\d?\d)\s*\/\s*(?<year>(\d\d\d|\d)?\d)\s*$/.exec(expiration);
      if (match2) {
        return `${(_a2 = match2.groups) === null || _a2 === void 0 ? void 0 : _a2.month.padStart(2, "0")} / ${(_b2 = match2.groups) === null || _b2 === void 0 ? void 0 : _b2.year.substring(match2.groups.year.length - 2).padStart(2, "0")}`;
      }
      return expiration.trim();
    }
    const twoDigitYear = expirationValidation.year.substring(expirationValidation.year.length - 2);
    return `${expirationValidation.month} / ${twoDigitYear}`;
  }
  function normalizeTag(tag) {
    return tag.replace(/^[\s/]*/, "").replace(/[\s/]*$/, "").replace(/\/+/g, "/");
  }
  function normalizeTotpSecret(value) {
    let result2 = value;
    const parameters = getTotpParametersFromOtpauthUrl(value);
    if (parameters) {
      result2 = parameters.secret;
    }
    const normalizedSecret = getNormalizedPlainTotpSecret(result2);
    if (normalizedSecret) {
      result2 = normalizedSecret;
    }
    return result2;
  }
  function getTotpParametersFromOtpauthUrl(value) {
    const parts = /otpauth:\/\/([A-Za-z]+)\/([^?]*)\??(.*)?/i.exec(value);
    if (parts === null || parts.length < 3) {
      return null;
    }
    const type = parts[1];
    if (type.toLowerCase() !== "totp") {
      return null;
    }
    const urlParams = new URLSearchParams(parts[3]);
    const secret = urlParams.get("secret");
    if (secret === null) {
      return null;
    }
    const params = {
      secret,
      algorithm: normalizeTotpAlgorithm(urlParams.get("algorithm")),
      digits: normalizeTotpDigits(urlParams.get("digits")),
      period: normalizeTotpPeriod(urlParams.get("period"))
    };
    return params;
  }
  function normalizeTotpAlgorithm(algorithm) {
    if (algorithm === null) {
      return void 0;
    }
    const algo = algorithm.toLowerCase().trim();
    switch (algo) {
      case "sha1":
        return TotpAlgorithm.sha1;
      case "sha256":
        return TotpAlgorithm.sha256;
      case "sha512":
        return TotpAlgorithm.sha512;
      default:
        return TotpAlgorithm.sha1;
    }
  }
  function normalizeTotpDigits(digitsString) {
    if (digitsString === null) {
      return void 0;
    }
    const digits = Number.parseInt(digitsString);
    if (Number.isNaN(digits) || !Number.isInteger(digits)) {
      return void 0;
    }
    if (digits <= 0) {
      return DEFAULT_TOTP_DIGITS;
    }
    return Math.min(8, digits);
  }
  function normalizeTotpPeriod(periodString) {
    if (periodString === null) {
      return void 0;
    }
    const period = Number.parseInt(periodString);
    if (Number.isNaN(period) || !Number.isInteger(period)) {
      return void 0;
    }
    if (period <= 0) {
      return DEFAULT_TOTP_PERIOD;
    }
    return period;
  }
  function getNormalizedPlainTotpSecret(value) {
    if (value === null) {
      return void 0;
    }
    const secret = value.toUpperCase().replace(/\s/g, "");
    try {
      base32tohex(secret);
      return secret;
    } catch (e) {
      if (e instanceof InvalidTotpSecretError) {
        return void 0;
      }
    }
    return void 0;
  }
  const maxInt = 2147483647;
  const base = 36;
  const tMin = 1;
  const tMax = 26;
  const skew = 38;
  const damp = 700;
  const initialBias = 72;
  const initialN = 128;
  const delimiter = "-";
  const regexPunycode = /^xn--/;
  const regexNonASCII = /[^\0-\x7E]/;
  const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  const baseMinusTMin = base - tMin;
  const floor = Math.floor;
  const stringFromCharCode = String.fromCharCode;
  function error(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, fn) {
    const result2 = [];
    let length = array.length;
    while (length--) {
      result2[length] = fn(array[length]);
    }
    return result2;
  }
  function mapDomain(string, fn) {
    const parts = string.split("@");
    let result2 = "";
    if (parts.length > 1) {
      result2 = parts[0] + "@";
      string = parts[1];
    }
    string = string.replace(regexSeparators, ".");
    const labels = string.split(".");
    const encoded = map(labels, fn).join(".");
    return result2 + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  const ucs2encode = (array) => String.fromCodePoint(...array);
  const basicToDigit = function(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }
    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }
    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }
    return base;
  };
  const digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  const adapt = function(delta, numPoints, firstTime) {
    let k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  const decode = function(input) {
    const output = [];
    const inputLength = input.length;
    let i2 = 0;
    let n = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0; j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
      let oldi = i2;
      for (let w2 = 1, k = base; ; k += base) {
        if (index >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base || digit > floor((maxInt - i2) / w2)) {
          error("overflow");
        }
        i2 += digit * w2;
        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        const baseMinusT = base - t;
        if (w2 > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w2 *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i2 - oldi, out, oldi == 0);
      if (floor(i2 / out) > maxInt - n) {
        error("overflow");
      }
      n += floor(i2 / out);
      i2 %= out;
      output.splice(i2++, 0, n);
    }
    return String.fromCodePoint(...output);
  };
  const encode = function(input) {
    const output = [];
    input = ucs2decode(input);
    let inputLength = input.length;
    let n = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    let basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m2 = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n && currentValue < m2) {
          m2 = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m2 - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m2 - n) * handledCPCountPlusOne;
      n = m2;
      for (const currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue == n) {
          let q = delta;
          for (let k = base; ; k += base) {
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            const qMinusT = q - t;
            const baseMinusT = base - t;
            output.push(
              stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
            );
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  const toUnicode = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  const toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    "version": "2.1.0",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    "ucs2": {
      "decode": ucs2decode,
      "encode": ucs2encode
    },
    "decode": decode,
    "encode": encode,
    "toASCII": toASCII,
    "toUnicode": toUnicode
  };
  const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    decode,
    default: punycode,
    encode,
    toASCII,
    toUnicode,
    ucs2decode,
    ucs2encode
  }, Symbol.toStringTag, { value: "Module" }));
  function normalizeWebsitePattern(websitePatternString, options = {}) {
    const { hostname: host, port, pathname: path } = getNormalizedPatternParts(websitePatternString.trim(), options);
    return `${host}${port ? ":" : ""}${port}${path}`;
  }
  function getNormalizedPatternParts(inputWebsitePatternString, { usePunycode = false } = {}) {
    if (/^\d+$/.test(inputWebsitePatternString)) {
      return {
        hostname: inputWebsitePatternString.trim(),
        pathname: "",
        port: ""
      };
    }
    try {
      let websitePatternString = inputWebsitePatternString;
      const hasProtocol = /^([a-z]+:)?\/\//.exec(websitePatternString);
      if (!hasProtocol) {
        websitePatternString = `https://${websitePatternString}`;
      }
      const url = new URL(websitePatternString);
      const hostname = normalizePatternHostname(url.hostname, usePunycode);
      const pathname = normalizePatternPathname(url);
      const { port } = url;
      return {
        hostname,
        pathname,
        port
      };
    } catch (e) {
      return {
        hostname: inputWebsitePatternString.trim(),
        pathname: "",
        port: ""
      };
    }
  }
  function normalizePatternHostname(hostname, usePunycode) {
    const hostnamePunycodedIfNeeded = usePunycode ? hostname : punycode.toUnicode(hostname);
    return hostnamePunycodedIfNeeded.toLowerCase();
  }
  function normalizePatternPathname(url) {
    const pathname = url.pathname.trim();
    if (pathname.match(/^\/+$/)) {
      return "";
    }
    return pathname;
  }
  var __rest$v = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function sanitizeLoginFromImport(login, profileId, now, emptyNameCustomFieldDefaultName) {
    var _a2, _b2;
    const { creationTime, editTime, changeTime, websites, websiteAttributes, tags, creditCard, totp, customFields } = login, restLogin = __rest$v(login, ["creationTime", "editTime", "changeTime", "websites", "websiteAttributes", "tags", "creditCard", "totp", "customFields"]);
    const { normalizedWebsites, normalizedWebsiteAttributes } = getNormalizedWebsites(websites !== null && websites !== void 0 ? websites : [], websiteAttributes !== null && websiteAttributes !== void 0 ? websiteAttributes : {});
    const sanitizedLogin = Object.assign({
      // static defaults
      title: "",
      username: "",
      password: "",
      icon: "",
      note: "",
      creationSource: LoginSource.import,
      editSource: LoginSource.import,
      creationProfileId: profileId,
      editProfileId: profileId,
      // Default times to each other if not all are set
      creationTime: (_a2 = creationTime !== null && creationTime !== void 0 ? creationTime : editTime) !== null && _a2 !== void 0 ? _a2 : now,
      changeTime: (_b2 = changeTime !== null && changeTime !== void 0 ? changeTime : editTime) !== null && _b2 !== void 0 ? _b2 : now,
      editTime: editTime !== null && editTime !== void 0 ? editTime : now,
      // Normalize fields where possible
      websites: normalizedWebsites,
      websiteAttributes: normalizedWebsiteAttributes,
      tags: tags ? removeDuplicates(tags.map(normalizeTag)) : void 0,
      creditCard: creditCard ? normalizeCreditCard(creditCard) : void 0,
      totp: totp ? normalizeTotpSecret(totp) : void 0,
      customFields: customFields ? getNormalizedCustomFields(customFields, emptyNameCustomFieldDefaultName) : []
    }, deleteUndefinedKeys(restLogin));
    return deleteUndefinedKeys(Object.assign({
      // Guess uiType if not set
      uiType: guessUiType(sanitizedLogin)
    }, sanitizedLogin));
  }
  function deleteUndefinedKeys(obj) {
    const keys2 = Object.keys(obj);
    for (const k of keys2) {
      if (k in obj && obj[k] === void 0) {
        delete obj[k];
      }
    }
    return obj;
  }
  function guessUiType(login) {
    var _a2;
    if (login.creditCard) {
      return LoginUiType.creditCard;
    }
    if (((_a2 = login.websites) === null || _a2 === void 0 ? void 0 : _a2.length) || login.username || login.password || login.totp) {
      return LoginUiType.login;
    }
    if (login.note) {
      return LoginUiType.note;
    }
    return LoginUiType.login;
  }
  function removeDuplicates(arr) {
    return [...new Set(arr)];
  }
  function getNormalizedWebsites(websites, websiteAttributes) {
    const normalizedWebsitesSet = /* @__PURE__ */ new Set();
    const normalizedWebsiteAttributes = Object.assign({}, websiteAttributes);
    for (const unnormalizedWebsite of websites) {
      if (!unnormalizedWebsite) {
        continue;
      }
      const normalizedWebsite = normalizeWebsitePattern(unnormalizedWebsite);
      if (!normalizedWebsite || normalizedWebsitesSet.has(normalizedWebsite)) {
        continue;
      }
      normalizedWebsitesSet.add(normalizedWebsite);
      normalizedWebsiteAttributes[normalizedWebsite] = Object.assign(Object.assign({}, websiteAttributes[normalizedWebsite]), getWebsiteAttributesEntry(unnormalizedWebsite));
    }
    for (const key of Object.keys(normalizedWebsiteAttributes)) {
      if (!normalizedWebsitesSet.has(key)) {
        delete normalizedWebsiteAttributes[key];
      }
    }
    return { normalizedWebsites: [...normalizedWebsitesSet], normalizedWebsiteAttributes };
  }
  function getNormalizedCustomFields(customFields, emptyNameCustomFieldDefaultName) {
    const result2 = [];
    let index = 1;
    for (const cf of customFields) {
      if (cf.name) {
        result2.push(cf);
      } else {
        while (
          // eslint-disable-next-line @typescript-eslint/no-loop-func
          customFields.find(({ name }) => name === `${emptyNameCustomFieldDefaultName} ${index}`) || // eslint-disable-next-line @typescript-eslint/no-loop-func
          result2.find(({ name }) => name === `${emptyNameCustomFieldDefaultName} ${index}`)
        ) {
          index++;
        }
        result2.push(Object.assign(Object.assign({}, cf), { name: `${emptyNameCustomFieldDefaultName} ${index}` }));
      }
    }
    return result2;
  }
  var __rest$u = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const LoginVaultContent = LoginVaultContentV2;
  function transformLoginProtectedValues(l, transform) {
    const { password, customFields, shareLinks, history, totp, creditCard } = l, rest = __rest$u(l, ["password", "customFields", "shareLinks", "history", "totp", "creditCard"]);
    let copy = Object.assign({}, rest);
    if ("password" in l && password !== void 0) {
      copy = Object.assign(Object.assign({}, copy), { password: transform(password) });
    }
    if ("totp" in l) {
      copy = Object.assign(Object.assign({}, copy), { totp: totp ? transform(totp) : void 0 });
    }
    if ("customFields" in l && customFields !== void 0) {
      copy = Object.assign(Object.assign({}, copy), { customFields: customFields.map((cf) => !cf.protected ? cf : Object.assign(Object.assign({}, cf), { value: transform(cf.value) })) });
    }
    if ("creditCard" in l) {
      copy = Object.assign(Object.assign({}, copy), { creditCard: creditCard ? Object.assign(Object.assign({}, creditCard), { securityCode: transform(creditCard.securityCode), pin: transform(creditCard.pin) }) : void 0 });
    }
    if ("history" in l) {
      if (history == void 0) {
        copy = Object.assign(Object.assign({}, copy), { history: void 0 });
      } else {
        const revisions = {};
        for (const [id, revision] of Object.entries(history.revisions)) {
          revisions[id] = transformLoginProtectedValues(revision, transform);
        }
        copy = Object.assign(Object.assign({}, copy), { history: Object.assign(Object.assign({}, history), { revisions }) });
      }
    }
    if ("shareLinks" in l) {
      copy = Object.assign(Object.assign({}, copy), { shareLinks: shareLinks ? shareLinks.map((sl) => Object.assign(Object.assign({}, sl), { secret: transform(sl.secret) })) : void 0 });
    }
    return copy;
  }
  function createInitialVaultContent$1() {
    return { logins: {} };
  }
  function getActiveShareLinkIds(c2) {
    return Object.values(c2.logins).flatMap((l) => {
      var _a2, _b2;
      if (l.isDeleted) {
        return [];
      }
      return (_b2 = (_a2 = l.shareLinks) === null || _a2 === void 0 ? void 0 : _a2.flatMap((sl) => sl.openedAt ? [] : [sl.id])) !== null && _b2 !== void 0 ? _b2 : [];
    });
  }
  const loginVaultContentDescriptor = {
    version: 2,
    contentTypeName: "login",
    vaultTypes: [VaultType.PRIVATE, VaultType.TEAM, VaultType.INBOX],
    parseVaultContent: LoginVaultContent.parse.bind(LoginVaultContent),
    createInitialVaultContent: createInitialVaultContent$1,
    postMergeHooks: {
      logins(left, right, chosen) {
        return loginMergeHistory(left, right, chosen);
      }
    },
    getActiveShareLinkIds
  };
  const organizationPersonalVaultContentDescriptor = {
    version: 2,
    contentTypeName: "organizationPersonal",
    vaultTypes: [VaultType.ORGANIZATION_PERSONAL],
    parseVaultContent: LoginVaultContent.parse.bind(LoginVaultContent),
    createInitialVaultContent: createInitialVaultContent$1,
    postMergeHooks: {
      logins(left, right, chosen) {
        return loginMergeHistory(left, right, chosen);
      }
    },
    getActiveShareLinkIds
  };
  function addLoginInternal(content, timestamp, login) {
    return modifyVault$1(content, "logins", (list) => {
      return addElement(list, timestamp, login);
    });
  }
  function addLoginInternalWithHistory(content, timestamp, login) {
    return modifyVault$1(content, "logins", (list) => {
      return addElement(list, timestamp, updateHistory(list, void 0, login));
    });
  }
  function modifyLoginInternal(content, timestamp, id, login) {
    return modifyVault$1(content, "logins", (list) => {
      return modifyElement(list, timestamp, id, login);
    });
  }
  function modifyLoginInternalWithHistory(content, timestamp, id, login) {
    return modifyVault$1(content, "logins", (list) => {
      const fullLogin = unpackHeymergeListElement(modifyElement(list, timestamp, id, login).newList[id]);
      return modifyElement(list, timestamp, id, updateHistory(list, id, fullLogin));
    });
  }
  function addOrModifyLoginInternal(content, timestamp, id, login) {
    return modifyVault$1(content, "logins", (list) => {
      return addOrModifyElement(list, timestamp, id, login);
    });
  }
  function addOrModifyLoginInternalWithHistory(content, timestamp, id, login) {
    return modifyVault$1(content, "logins", (list) => {
      return addOrModifyElement(list, timestamp, id, updateHistory(list, id, login));
    });
  }
  function deleteLoginInternal(content, timestamp, id) {
    return modifyVault$1(content, "logins", (list) => {
      return removeElement(list, timestamp, id);
    });
  }
  function archiveLoginInternal(content, timestamp, id) {
    return modifyVault$1(content, "logins", (list) => {
      return archiveElement(list, timestamp, id);
    });
  }
  function restoreArchivedLoginInternal(content, timestamp, id) {
    return modifyVault$1(content, "logins", (list) => {
      return restoreArchivedElement(list, timestamp, id);
    });
  }
  function updateHistory(previousList, id, login) {
    let baseRevisionId;
    let previousRevisions;
    const previousElement = id ? previousList[id] : void 0;
    const previousLogin = previousElement ? unpackHeymergeListElement(previousElement) : void 0;
    if (previousLogin) {
      if (previousLogin.history) {
        baseRevisionId = previousLogin.history.currentRevisionId;
        previousRevisions = previousLogin.history.revisions;
      } else {
        const backfillRevisionId = newUuid$1();
        previousRevisions = {
          [backfillRevisionId]: getLoginWithoutHistory(previousLogin)
        };
        baseRevisionId = backfillRevisionId;
      }
    } else {
      previousRevisions = void 0;
      baseRevisionId = void 0;
    }
    const currentRevisionId = newUuid$1();
    const loginWithoutHistory = getLoginWithoutHistory(login);
    const newRevision = Object.assign(Object.assign({}, loginWithoutHistory), { baseRevisionId });
    const loginWithHistory = Object.assign(Object.assign({}, login), {
      // History is merged from both sides with a post merge hook when a login is chosen on the
      // heymerge layer.
      history: {
        revisions: Object.assign(Object.assign({}, previousRevisions), { [currentRevisionId]: newRevision }),
        currentRevisionId
      }
    });
    return loginWithHistory;
  }
  function getLoginWithoutHistory(login) {
    const loginWithoutHistory = __rest$u(login, ["history"]);
    return loginWithoutHistory;
  }
  function loginMergeHistory(leftValue, rightValue, chosenValue) {
    var _a2, _b2;
    const leftHistoryRevisions = leftValue.isDeleted ? void 0 : (_a2 = leftValue.history) === null || _a2 === void 0 ? void 0 : _a2.revisions;
    const rightHistoryRevisions = rightValue.isDeleted ? void 0 : (_b2 = rightValue.history) === null || _b2 === void 0 ? void 0 : _b2.revisions;
    if (!chosenValue.isDeleted && chosenValue.history && (leftHistoryRevisions || rightHistoryRevisions) && !deepEqual$1(leftHistoryRevisions, rightHistoryRevisions)) {
      return Object.assign(Object.assign({}, chosenValue), { history: Object.assign(Object.assign({}, chosenValue.history), { revisions: Object.assign(Object.assign({}, leftHistoryRevisions), rightHistoryRevisions) }) });
    } else {
      return chosenValue;
    }
  }
  var __awaiter$N = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$t = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function addLogin(_a2, _b2) {
    var ccs = __rest$t(_a2, []);
    var vaultId = _b2.vaultId, login = _b2.login, highSecurityCache = _b2.highSecurityCache, source = _b2.source, timesOverride = _b2.timesOverride;
    return __awaiter$N(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return modifyLoginVault(ccs, vault, (vaultContent, t, { addLoginInternalWithHistory: addLoginInternalWithHistory2, protect: protect2 }) => {
        var _a3;
        const completedLogin = completeFullEditLogin(vault, ccs.profileRepo, t, source, login, timesOverride);
        const { newVaultContent, result: loginId } = addLoginInternalWithHistory2(vaultContent, t, recursivelyTransformUnprotectedValues(completedLogin, protect2));
        const modifiedLogin = newVaultContent.logins[loginId];
        return {
          newVaultContent,
          auditlogEvents: [
            {
              type: AuditlogEventType.LOGIN_W_CREATE,
              loginId,
              vaultId,
              loginEditTime: modifiedLogin.editTime,
              loginRevisionId: (_a3 = modifiedLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
              loginDifferences: getLoginDifferencesForChange(modifiedLogin, void 0, completedLogin)
            }
          ],
          result: loginId
        };
      }, highSecurityCache);
    });
  }
  function modifyLogin(_a2, _b2) {
    var ccs = __rest$t(_a2, []);
    var vaultId = _b2.vaultId, loginId = _b2.loginId, login = _b2.login, highSecurityCache = _b2.highSecurityCache, timesOverride = _b2.timesOverride, source = _b2.source;
    return __awaiter$N(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return modifyLoginVault(ccs, vault, (vaultContent, t, { modifyLoginInternalWithHistory: modifyLoginInternalWithHistory2, protect: protect2 }) => {
        var _a3;
        const previousLogin = vaultContent.logins[loginId];
        const { newVaultContent } = modifyLoginInternalWithHistory2(vaultContent, t, loginId, recursivelyTransformUnprotectedValues(completePartialEditLogin(vault, ccs.profileRepo, t, source, login, timesOverride), protect2));
        const modifiedLogin = newVaultContent.logins[loginId];
        return {
          newVaultContent,
          auditlogEvents: [
            {
              type: AuditlogEventType.LOGIN_W_CHANGE,
              loginId,
              vaultId,
              loginEditTime: modifiedLogin.editTime,
              loginRevisionId: (_a3 = modifiedLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
              loginDifferences: getLoginDifferencesForChange(modifiedLogin, previousLogin)
            }
          ],
          result: void 0
        };
      }, highSecurityCache);
    });
  }
  function addOrModifyLogin(_a2, _b2) {
    var ccs = __rest$t(_a2, []);
    var vaultId = _b2.vaultId, loginId = _b2.loginId, login = _b2.login, highSecurityCache = _b2.highSecurityCache, source = _b2.source, timesOverride = _b2.timesOverride;
    return __awaiter$N(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const newCcs = modifyLoginVault(ccs, vault, (vaultContent, t, { addOrModifyLoginInternalWithHistory: addOrModifyLoginInternalWithHistory2, protect: protect2 }) => {
        var _a3;
        const previousLogin = vaultContent.logins[loginId];
        const completedLogin = completeFullEditLogin(vault, ccs.profileRepo, t, source, login, timesOverride, previousLogin);
        const { newVaultContent } = addOrModifyLoginInternalWithHistory2(vaultContent, t, loginId, recursivelyTransformUnprotectedValues(completedLogin, protect2));
        const modifiedLogin = newVaultContent.logins[loginId];
        return {
          newVaultContent,
          auditlogEvents: [
            {
              type: previousLogin ? AuditlogEventType.LOGIN_W_CHANGE : AuditlogEventType.LOGIN_W_CREATE,
              loginId,
              vaultId,
              loginEditTime: modifiedLogin.editTime,
              loginRevisionId: (_a3 = modifiedLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
              loginDifferences: getLoginDifferencesForChange(modifiedLogin, previousLogin, completedLogin)
            }
          ],
          result: void 0
        };
      }, highSecurityCache);
      return Object.assign(Object.assign({}, newCcs), { returnResult: void 0 });
    });
  }
  function createInitialLoginHistoryEntryIfNecessary(_a2, _b2) {
    var ccs = __rest$t(_a2, []);
    var vaultId = _b2.vaultId, loginId = _b2.loginId;
    return __awaiter$N(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const previousLogin = vault.getContent().logins[loginId];
      if (!previousLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (previousLogin.history) {
        return Object.assign(Object.assign({}, ccs), { returnResult: previousLogin.history.currentRevisionId });
      }
      const newCcs = modifyLoginVault(ccs, vault, (vaultContent, t, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const initialRevisionId = newUuid$1();
        const loginWithoutHistory = __rest$t(previousLogin, ["history"]);
        const { newVaultContent } = modifyLoginInternal2(vaultContent, t, loginId, {
          history: {
            currentRevisionId: initialRevisionId,
            revisions: {
              [initialRevisionId]: loginWithoutHistory
            }
          }
        });
        return { newVaultContent, auditlogEvents: [], result: initialRevisionId };
      });
      return newCcs;
    });
  }
  function copyLogins(_a2, toId, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      const logins = [];
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        const fromContent = fromVault.getContent();
        for (const loginId of loginIds) {
          const l = fromContent.logins[loginId];
          if (!l) {
            throw new LoginNotFoundError(loginId);
          }
          if (l.linkedFrom) {
            continue;
          }
          const redactedLogin = __rest$t(l, ["shareLinks"]);
          const login = recursivelyTransformProtectedValues(redactedLogin, (pv) => protectedSecretRepo.unprotectWithContentId(fromVault, pv));
          logins.push(login);
        }
      }
      if (logins.length === 0) {
        return Object.assign(Object.assign({}, ccs), { returnResult: [] });
      }
      const toVault = ccs.vaultRepo.getLoginVaultById(toId);
      if (!toVault) {
        throw new VaultNotFoundError(toId);
      }
      return modifyLoginVault(ccs, toVault, (vaultContent, t, { addLoginInternal: addLoginInternal2, protect: protect2 }) => {
        var _a3;
        const copiedLoginIds = [];
        const auditlogEvents = [];
        for (let _b2 of logins) {
          const login = __rest$t(_b2, ["linkedTo"]);
          const { newVaultContent, result: result2 } = addLoginInternal2(vaultContent, t, Object.assign(Object.assign({}, recursivelyTransformUnprotectedValues(login, protect2)), { editTime: t, changeTime: t }));
          copiedLoginIds.push(result2);
          auditlogEvents.push({
            type: AuditlogEventType.LOGIN_W_CREATE,
            vaultId: toId,
            loginId: result2,
            loginEditTime: login.editTime,
            loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
            loginDifferences: getLoginDifferences(emptyUnprotectedLogin, recursivelyTransformUnprotectedValues(login, (upv) => upv.unencrypted))
          });
          vaultContent = newVaultContent;
        }
        return { newVaultContent: vaultContent, auditlogEvents, result: copiedLoginIds };
      });
    });
  }
  function deleteLogins(_a2, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t, { deleteLoginInternal: deleteLoginInternal2 }) => {
          var _a3;
          const auditlogEvents = [];
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (login === void 0) {
              throw new LoginNotFoundError(loginId);
            }
            if (login.isDeleted) {
              continue;
            }
            ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t, loginId));
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_DELETE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
            });
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function isLoginTrashable(login) {
    return !login.linkedFrom;
  }
  function deleteOrArchiveLogins(_a2, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        const { profileRepo } = ccs;
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t, { deleteLoginInternal: deleteLoginInternal2, archiveLoginInternal: archiveLoginInternal2, modifyLoginInternal: modifyLoginInternal2 }) => {
          var _a3, _b2;
          const auditlogEvents = [];
          const archivedByProfileId = getVaultEditProfileId(fromVault, profileRepo);
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (!login) {
              throw new LoginNotFoundError(loginId);
            }
            if (login.isDeleted) {
              return { newVaultContent, auditlogEvents: [], result: void 0 };
            }
            if (!isLoginTrashable(login)) {
              ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t, loginId));
              auditlogEvents.push({
                type: AuditlogEventType.LOGIN_W_DELETE,
                loginId,
                vaultId: fromId,
                loginEditTime: login.editTime,
                loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
              });
            } else {
              ({ newVaultContent } = modifyLoginInternal2(newVaultContent, t, loginId, {
                shareLinks: void 0,
                linkedTo: void 0,
                archiveInfo: {
                  archiveTime: t,
                  archivedByProfileId
                }
              }));
              ({ newVaultContent } = archiveLoginInternal2(newVaultContent, t, loginId));
              auditlogEvents.push({
                type: AuditlogEventType.LOGIN_W_ARCHIVE,
                loginId,
                vaultId: fromId,
                loginEditTime: login.editTime,
                loginRevisionId: (_b2 = login.history) === null || _b2 === void 0 ? void 0 : _b2.currentRevisionId
              });
            }
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function restoreArchivedLogins(_a2, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t, { restoreArchivedLoginInternal: restoreArchivedLoginInternal2, modifyLoginInternal: modifyLoginInternal2 }) => {
          var _a3;
          const auditlogEvents = [];
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (!login) {
              throw new LoginNotFoundError(loginId);
            }
            if (!login.isDeleted) {
              return { newVaultContent, auditlogEvents: [], result: void 0 };
            }
            if (!login.isArchived) {
              throw new LoginNotFoundError(loginId);
            }
            ({ newVaultContent } = restoreArchivedLoginInternal2(newVaultContent, t, loginId));
            ({ newVaultContent } = modifyLoginInternal2(newVaultContent, t, loginId, {
              archiveInfo: void 0,
              changeTime: t
            }));
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_RESTORE_FROM_ARCHIVE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
            });
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function deleteArchivedLogins(_a2, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t, { deleteLoginInternal: deleteLoginInternal2 }) => {
          var _a3;
          const auditlogEvents = [];
          let newVaultContent = vaultContent;
          for (const loginId of loginIds) {
            const login = newVaultContent.logins[loginId];
            if (!login || !login.isDeleted || !login.isArchived) {
              throw new LoginNotFoundError(loginId);
            }
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_DELETE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
            });
            ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t, loginId));
          }
          return { newVaultContent, auditlogEvents, result: void 0 };
        });
      }
      return ccs;
    });
  }
  function moveLogins(_a2, toId, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      const copyResult = yield copyLogins(ccs, toId, from);
      ccs = yield deleteLogins(copyResult, from);
      return Object.assign(Object.assign({}, ccs), { returnResult: copyResult.returnResult });
    });
  }
  function modifyTagsForLogin(_a2, _b2) {
    var ccs = __rest$t(_a2, []);
    var vaultId = _b2.vaultId, loginIds = _b2.loginIds, addTags = _b2.addTags, removeTags = _b2.removeTags, source = _b2.source, highSecurityCache = _b2.highSecurityCache;
    return __awaiter$N(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return modifyLoginVault(ccs, vault, (content, t, { modifyLoginInternalWithHistory: modifyLoginInternalWithHistory2 }) => {
        return loginIds.reduce((accumulator, loginId) => {
          var _a3;
          const login = accumulator.newVaultContent.logins[loginId];
          if (!login || !isHeymergeListValue(login)) {
            return accumulator;
          }
          const newTagsSet = new Set(login.tags);
          if (removeTags === null || removeTags === void 0 ? void 0 : removeTags.length) {
            removeTags.forEach((tag) => newTagsSet.delete(tag));
          }
          if (addTags === null || addTags === void 0 ? void 0 : addTags.length) {
            addTags.forEach((tag) => newTagsSet.add(tag));
          }
          const oldTags = (_a3 = login.tags) !== null && _a3 !== void 0 ? _a3 : [];
          if (newTagsSet.size == oldTags.length && oldTags.every((tag) => newTagsSet.has(tag))) {
            return accumulator;
          }
          return {
            newVaultContent: modifyLoginInternalWithHistory2(accumulator.newVaultContent, t, loginId, completePartialEditLogin(vault, ccs.profileRepo, t, source, {
              tags: [...newTagsSet]
            })).newVaultContent,
            auditlogEvents: [],
            result: accumulator.result + 1
          };
        }, { newVaultContent: content, auditlogEvents: [], result: 0 });
      }, highSecurityCache);
    });
  }
  function modifyLinkedViewSecretsForLogin(_a2, targetVaultId, loginId, linkedViewSecrets) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(targetVaultId);
      if (!vault) {
        throw new VaultNotFoundError(targetVaultId);
      }
      return modifyLoginVault(ccs, vault, (content, t, { modifyLoginInternal: modifyLoginInternal2 }) => {
        const result2 = modifyLoginInternal2(content, t, loginId, { linkedViewSecrets });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
    });
  }
  function importLogins(_a2, targetVaultId, logins, emptyNameCustomFieldDefaultName) {
    var _b2, _c2;
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      const targetVault = ccs.vaultRepo.getLoginVaultById(targetVaultId);
      if (!targetVault) {
        throw new VaultNotFoundError(targetVaultId);
      }
      const targetVaultOrgProfile = targetVault.organizationId ? ccs.profileRepo.getOrganizationProfile(targetVault.organizationId) : void 0;
      const profileId = (_c2 = (_b2 = targetVaultOrgProfile === null || targetVaultOrgProfile === void 0 ? void 0 : targetVaultOrgProfile.profile.id) !== null && _b2 !== void 0 ? _b2 : targetVault.getProfileId()) !== null && _c2 !== void 0 ? _c2 : void 0;
      return modifyLoginVault(ccs, targetVault, (c2, t, { addLoginInternalWithHistory: addLoginInternalWithHistory2, protect: protect2 }) => {
        var _a3;
        const auditlogEvents = [];
        const existingLoginHashes = new Set(Object.values(c2.logins).filter((l) => !l.isDeleted).flatMap(getLoginHashes));
        let added = 0;
        let skippedDuplicate = 0;
        let skippedUnnamed = 0;
        let newVaultContent = c2;
        for (const unprotectedLogin of logins) {
          const fullUnprotectedLogin = sanitizeLoginFromImport(unprotectedLogin, profileId, t, emptyNameCustomFieldDefaultName);
          const isLoginAndUnnamed = fullUnprotectedLogin.uiType === LoginUiType.login && fullUnprotectedLogin.username === "" && fullUnprotectedLogin.title === "" && fullUnprotectedLogin.websites.every((ws) => ws === "");
          if (isLoginAndUnnamed) {
            skippedUnnamed++;
            continue;
          }
          const hashes = getLoginHashes(fullUnprotectedLogin);
          const loginIsNew = hashes.some((h2) => !existingLoginHashes.has(h2));
          if (!loginIsNew) {
            skippedDuplicate++;
            continue;
          }
          let loginId;
          ({ newVaultContent, result: loginId } = addLoginInternalWithHistory2(newVaultContent, t, transformLoginProtectedValues(fullUnprotectedLogin, (unencrypted) => protect2({ contentId: newUuid$1(), unencrypted }))));
          const newLogin = newVaultContent.logins[loginId];
          auditlogEvents.push({
            type: AuditlogEventType.LOGIN_W_CREATE,
            vaultId: targetVaultId,
            loginId,
            loginEditTime: newLogin.editTime,
            loginRevisionId: (_a3 = newLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
            loginDifferences: getLoginDifferences(emptyUnprotectedLogin, fullUnprotectedLogin)
          });
          added++;
        }
        return {
          newVaultContent,
          auditlogEvents,
          result: { added, skippedDuplicate, skippedUnnamed }
        };
      });
    });
  }
  function linkLoginsToTeam(_a2, orgId, toVaultId, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      const toVault = ccs.vaultRepo.getLoginVaultById(toVaultId);
      if (!toVault) {
        throw new VaultNotFoundError(toVaultId);
      }
      if ((toVault === null || toVault === void 0 ? void 0 : toVault.type) !== VaultType.TEAM) {
        throw new Error("tried to link to non-team vault in linkLoginsToTeam");
      }
      if (toVault.organizationId !== orgId) {
        throw new Error("orgId mismatch for linking");
      }
      const org = ccs.accountState.getOrganization(toVault.organizationId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      ccs.accountState = ccs.accountState.withLocalAchievements([
        Achievement.COR_LINKED_LOGIN_CREATE_TEAM
      ]);
      return linkLoginsInternal(ccs, org.id, toVaultId, null, from);
    });
  }
  function linkLoginsToPersonalVault(_a2, orgId, toProfileId, from) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      ccs.accountState = ccs.accountState.withLocalAchievements([
        Achievement.COR_LINKED_LOGIN_CREATE_PERSONAL
      ]);
      const personalVaultId = findPersonalVaultId(ccs.accountState, ccs.vaultRepo, orgId, toProfileId);
      return linkLoginsInternal(ccs, orgId, personalVaultId, toProfileId, from);
    });
  }
  function linkLoginsInternal(ccs, orgId, targetVaultId, targetPersonalProfileId, from) {
    return __awaiter$N(this, void 0, void 0, function* () {
      const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
      if (!orgProfile) {
        throw new OrganizationNotFoundError();
      }
      const linkedByProfileId = orgProfile.profile.id;
      for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
        const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
        if (!fromVault) {
          throw new VaultNotFoundError(fromId);
        }
        if (fromId === targetVaultId) {
          throw new Error("internal: can't link login to identical vault");
        }
        return modifyLoginVault(ccs, fromVault, (c2, t, { modifyLoginInternal: modifyLoginInternal2 }) => {
          let newVaultContent = c2;
          for (const loginId of loginIds) {
            const existingElement = newVaultContent.logins[loginId];
            if (!existingElement || existingElement.isDeleted) {
              throw new LoginNotFoundError(loginId);
            }
            const originalLinkedTo = existingElement === null || existingElement === void 0 ? void 0 : existingElement.linkedTo;
            const linkedTo = originalLinkedTo ? [...originalLinkedTo] : [];
            const existing = linkedTo.find((lt) => lt.targetVaultId === targetVaultId);
            if (existing) {
              existing.addTime = t;
              existing.removeTime = null;
            } else {
              linkedTo.push({
                targetVaultId,
                // NOTE: this value is not checked here, it is up to the caller to make sure it is
                // correct!
                targetPersonalProfileId,
                addTime: t,
                linkedByProfileId,
                removeTime: null
              });
            }
            newVaultContent = modifyLoginInternal2(newVaultContent, t, loginId, {
              linkedTo
            }).newVaultContent;
          }
          return { newVaultContent, auditlogEvents: [], result: void 0 };
        });
      }
      return ccs;
    });
  }
  function unlinkLogins(_a2, fromId, toIds, loginIds) {
    var ccs = __rest$t(_a2, []);
    return __awaiter$N(this, void 0, void 0, function* () {
      const originalVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!originalVault) {
        throw new VaultNotFoundError(fromId);
      }
      const fromContent = originalVault.getContent();
      return modifyLoginVault(ccs, originalVault, (c2, t, { modifyLoginInternal: modifyLoginInternal2 }) => {
        var _a3;
        let newVaultContent = c2;
        for (const loginId of loginIds) {
          const originalLinkedTo = (_a3 = fromContent.logins[loginId]) === null || _a3 === void 0 ? void 0 : _a3.linkedTo;
          if (!originalLinkedTo) {
            continue;
          }
          const linkedTo = originalLinkedTo.map((lt) => {
            const shouldBeDeleted = toIds.some((id2) => lt.targetVaultId === id2);
            return shouldBeDeleted ? Object.assign(Object.assign({}, lt), { removeTime: t }) : lt;
          });
          newVaultContent = modifyLoginInternal2(newVaultContent, t, loginId, {
            linkedTo
          }).newVaultContent;
        }
        return { newVaultContent, auditlogEvents: [], result: void 0 };
      });
    });
  }
  function groupByVaultId(from) {
    const loginIdsByVault = /* @__PURE__ */ new Map();
    for (const { vaultId, loginId } of from) {
      if (!loginIdsByVault.has(vaultId)) {
        loginIdsByVault.set(vaultId, []);
      }
      loginIdsByVault.get(vaultId).push(loginId);
    }
    return loginIdsByVault;
  }
  function getLoginHashes(l) {
    var _a2;
    if (l.uiType === LoginUiType.creditCard) {
      return [canonicalize({ creditCardNumber: (_a2 = l.creditCard) === null || _a2 === void 0 ? void 0 : _a2.number, title: l.title })];
    }
    if (l.uiType === LoginUiType.note) {
      return [canonicalize({ secureNote: l.note, title: l.title })];
    }
    if (l.uiType === LoginUiType.wifi) {
      if (l.username) {
        return [canonicalize({ wifiSsid: l.wifiSsid, username: l.username })];
      }
      return [canonicalize({ wifiSsid: l.wifiSsid, title: l.title })];
    }
    if (l.websites.length) {
      return l.websites.map((ws) => canonicalize(l.username ? { username: l.username, ws } : { title: l.title, ws }));
    }
    return [canonicalize(l.username ? { username: l.username } : { title: l.title })];
  }
  function completePartialEditLogin(vault, profileRepo, t, source, editLogin, timesOverride) {
    const profileId = getVaultEditProfileId(vault, profileRepo);
    return Object.assign(Object.assign(Object.assign({}, editLogin), { editTime: t, editProfileId: profileId, editSource: source, changeTime: t }), timesOverride);
  }
  function completeFullEditLogin(vault, profileRepo, t, source, editLogin, timesOverride, previousLogin) {
    const profileId = getVaultEditProfileId(vault, profileRepo);
    return Object.assign(Object.assign(Object.assign({ creationTime: previousLogin ? previousLogin.creationTime : t, creationProfileId: previousLogin ? previousLogin.creationProfileId : profileId, creationSource: previousLogin ? previousLogin.creationSource : source }, editLogin), { editTime: t, editProfileId: profileId, editSource: source, changeTime: t }), timesOverride);
  }
  function getVaultEditProfileId(vault, profileRepo) {
    var _a2, _b2;
    const organizationProfileId = vault.organizationId ? (_a2 = profileRepo.getOrganizationProfile(vault.organizationId)) === null || _a2 === void 0 ? void 0 : _a2.profile.id : void 0;
    const profileId = (_b2 = organizationProfileId !== null && organizationProfileId !== void 0 ? organizationProfileId : vault.getProfileId()) !== null && _b2 !== void 0 ? _b2 : void 0;
    return profileId;
  }
  function getLoginDifferencesForChange(modifiedLogin, previousLogin, completedLogin) {
    return previousLogin ? getLoginDifferences(previousLogin, modifiedLogin) : getLoginDifferences(emptyUnprotectedLogin, recursivelyTransformUnprotectedValues(completedLogin, (upv) => upv.unencrypted));
  }
  var __awaiter$M = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var AuditlogWriteResult;
  (function(AuditlogWriteResult2) {
    AuditlogWriteResult2["Ok"] = "ok";
    AuditlogWriteResult2["Failure"] = "failure";
    AuditlogWriteResult2["Retry"] = "retry";
  })(AuditlogWriteResult || (AuditlogWriteResult = {}));
  function onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, events) {
    return __awaiter$M(this, void 0, void 0, function* () {
      try {
        let auditlogWriteClient;
        ({ ccs, auditlogWriteClient } = yield onlineGetAuditlogWriteClient(ccs, orgId));
        yield auditlogWriteClient.writeEvents(events);
        return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Ok });
      } catch (e) {
        if (e instanceof DomainError$1) {
          if (e.code === BackendClientErrorCode.NoResponse) {
            return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Retry });
          }
          if (e.code === BackendErrorCode.ORGANIZATION_NOT_FOUND) {
            return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Failure });
          }
          if (e.code === BackendErrorCode.INTERNAL || e.code === BackendClientErrorCode.InvalidGrpcResponse) {
            trackError(e);
            return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Retry });
          }
        }
        trackError(e);
        return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Failure });
      }
    });
  }
  function onlineGetAuditlogWriteClient(ccs, orgId) {
    return __awaiter$M(this, void 0, void 0, function* () {
      const cachedToken = ccs.auditlogWriteTokenCache.getToken(orgId);
      if (cachedToken) {
        const auditlogWriteClient2 = ccs.backendClient.getAuditlogWriteClient(cachedToken);
        return { ccs, auditlogWriteClient: auditlogWriteClient2 };
      }
      const token = yield ccs.backendClient.credential.createAuditlogWriteToken(orgId);
      ccs.auditlogWriteTokenCache = ccs.auditlogWriteTokenCache.withToken(orgId, token, token.expiresAt);
      const auditlogWriteClient = ccs.backendClient.getAuditlogWriteClient(token);
      return { ccs, auditlogWriteClient };
    });
  }
  function loadForeignProfile(dto) {
    const { id, keyGenerationId } = dto;
    const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
    const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
    const highSecurityVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
    const highSecurityProfileSeedEncPubKey = loadEncryptionPublicKey(dto.highSecurityProfileSeedEncPubKey);
    const highSecurityProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityProfileSeedEncPubKeySignature);
    const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
    const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
    const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
    const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
    const storableProfileSeedEncPubKey = loadEncryptionPublicKey(dto.storableProfileSeedEncPubKey);
    const storableProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableProfileSeedEncPubKeySignature);
    return {
      id,
      keyGenerationId,
      highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature,
      highSecurityProfileSeedEncPubKey,
      highSecurityProfileSeedEncPubKeySignature,
      storableSigPubKey,
      storableSigPubKeySignature,
      storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature,
      storableProfileSeedEncPubKey,
      storableProfileSeedEncPubKeySignature
    };
  }
  function serializeVaultProfileLock(lock) {
    return {
      lockingProfileId: lock.lockingProfileId,
      lockingProfileKeyGenerationId: lock.lockingProfileKeyGenerationId,
      encryptedStorableVaultKey: lock.encryptedStorableVaultKey,
      encryptedHighSecurityVaultKey: lock.encryptedHighSecurityVaultKey,
      encryptedVaultMessagePrivateKey: lock.encryptedVaultMessagePrivateKey
    };
  }
  class Commit {
    constructor(id, parentId, blob) {
      this.id = id;
      this.parentId = parentId;
      this.blob = blob;
    }
    static create(parentId, secret, state) {
      const blob = symEncrypt(secret, state);
      return new Commit(nullUuid, parentId, blob);
    }
    static load({ id, parentId, blob }) {
      return new Commit(id, parentId, loadSymEncryptedBlob(blob));
    }
    getContent(secret) {
      return symDecrypt(secret, this.blob);
    }
  }
  function serializeVaultAuthenticatorLock(lock) {
    return {
      authenticatorId: lock.authenticatorId,
      encryptedStorableVaultKey: lock.encryptedStorableVaultKey,
      encryptedHighSecurityVaultKey: lock.encryptedHighSecurityVaultKey,
      encryptedVaultMessagePrivateKey: lock.encryptedVaultMessagePrivateKey
    };
  }
  function unlockLockVaultSecret(vaultAccess, locks, profileLock, adminProfileLock) {
    if (vaultAccess.type === "admin-profile") {
      const { unlockedProfile: up } = vaultAccess;
      if (!adminProfileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
      }
      return asymDecryptKek(up.storableVaultKeyEncPrivKey, adminProfileLock.encryptedStorableVaultKey);
    } else if (vaultAccess.type === "profile") {
      const { unlockedProfile: up } = vaultAccess;
      if (!profileLock) {
        throw new LockProfileNotFoundError(up.profile.id);
      }
      if (up.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
      }
      return asymDecryptKek(up.storableVaultKeyEncPrivKey, profileLock.encryptedStorableVaultKey);
    } else {
      const { unlockedAuthenticator: ua } = vaultAccess;
      const candidateLock = locks.find((lock) => lock.authenticatorId === ua.authenticator.id);
      if (!candidateLock) {
        throw new LockAuthenticatorNotFoundError(ua.authenticator.id, locks);
      }
      return asymDecryptKek(ua.storableVaultKeyEncPrivKey, candidateLock.encryptedStorableVaultKey);
    }
  }
  var snappyjs = {};
  var snappy_decompressor = {};
  var WORD_MASK = [0, 255, 65535, 16777215, 4294967295];
  function copyBytes$1(fromArray, fromPos, toArray2, toPos, length) {
    var i2;
    for (i2 = 0; i2 < length; i2++) {
      toArray2[toPos + i2] = fromArray[fromPos + i2];
    }
  }
  function selfCopyBytes(array, pos, offset, length) {
    var i2;
    for (i2 = 0; i2 < length; i2++) {
      array[pos + i2] = array[pos - offset + i2];
    }
  }
  function SnappyDecompressor$1(compressed) {
    this.array = compressed;
    this.pos = 0;
  }
  SnappyDecompressor$1.prototype.readUncompressedLength = function() {
    var result2 = 0;
    var shift = 0;
    var c2, val;
    while (shift < 32 && this.pos < this.array.length) {
      c2 = this.array[this.pos];
      this.pos += 1;
      val = c2 & 127;
      if (val << shift >>> shift !== val) {
        return -1;
      }
      result2 |= val << shift;
      if (c2 < 128) {
        return result2;
      }
      shift += 7;
    }
    return -1;
  };
  SnappyDecompressor$1.prototype.uncompressToBuffer = function(outBuffer) {
    var array = this.array;
    var arrayLength = array.length;
    var pos = this.pos;
    var outPos = 0;
    var c2, len, smallLen;
    var offset;
    while (pos < array.length) {
      c2 = array[pos];
      pos += 1;
      if ((c2 & 3) === 0) {
        len = (c2 >>> 2) + 1;
        if (len > 60) {
          if (pos + 3 >= arrayLength) {
            return false;
          }
          smallLen = len - 60;
          len = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
          len = (len & WORD_MASK[smallLen]) + 1;
          pos += smallLen;
        }
        if (pos + len > arrayLength) {
          return false;
        }
        copyBytes$1(array, pos, outBuffer, outPos, len);
        pos += len;
        outPos += len;
      } else {
        switch (c2 & 3) {
          case 1:
            len = (c2 >>> 2 & 7) + 4;
            offset = array[pos] + (c2 >>> 5 << 8);
            pos += 1;
            break;
          case 2:
            if (pos + 1 >= arrayLength) {
              return false;
            }
            len = (c2 >>> 2) + 1;
            offset = array[pos] + (array[pos + 1] << 8);
            pos += 2;
            break;
          case 3:
            if (pos + 3 >= arrayLength) {
              return false;
            }
            len = (c2 >>> 2) + 1;
            offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
            pos += 4;
            break;
        }
        if (offset === 0 || offset > outPos) {
          return false;
        }
        selfCopyBytes(outBuffer, outPos, offset, len);
        outPos += len;
      }
    }
    return true;
  };
  snappy_decompressor.SnappyDecompressor = SnappyDecompressor$1;
  var snappy_compressor = {};
  var BLOCK_LOG = 16;
  var BLOCK_SIZE = 1 << BLOCK_LOG;
  var MAX_HASH_TABLE_BITS = 14;
  var globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);
  function hashFunc(key, hashFuncShift) {
    return key * 506832829 >>> hashFuncShift;
  }
  function load32(array, pos) {
    return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
  }
  function equals32(array, pos1, pos2) {
    return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];
  }
  function copyBytes(fromArray, fromPos, toArray2, toPos, length) {
    var i2;
    for (i2 = 0; i2 < length; i2++) {
      toArray2[toPos + i2] = fromArray[fromPos + i2];
    }
  }
  function emitLiteral(input, ip, len, output, op) {
    if (len <= 60) {
      output[op] = len - 1 << 2;
      op += 1;
    } else if (len < 256) {
      output[op] = 60 << 2;
      output[op + 1] = len - 1;
      op += 2;
    } else {
      output[op] = 61 << 2;
      output[op + 1] = len - 1 & 255;
      output[op + 2] = len - 1 >>> 8;
      op += 3;
    }
    copyBytes(input, ip, output, op, len);
    return op + len;
  }
  function emitCopyLessThan64(output, op, offset, len) {
    if (len < 12 && offset < 2048) {
      output[op] = 1 + (len - 4 << 2) + (offset >>> 8 << 5);
      output[op + 1] = offset & 255;
      return op + 2;
    } else {
      output[op] = 2 + (len - 1 << 2);
      output[op + 1] = offset & 255;
      output[op + 2] = offset >>> 8;
      return op + 3;
    }
  }
  function emitCopy(output, op, offset, len) {
    while (len >= 68) {
      op = emitCopyLessThan64(output, op, offset, 64);
      len -= 64;
    }
    if (len > 64) {
      op = emitCopyLessThan64(output, op, offset, 60);
      len -= 60;
    }
    return emitCopyLessThan64(output, op, offset, len);
  }
  function compressFragment(input, ip, inputSize, output, op) {
    var hashTableBits = 1;
    while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {
      hashTableBits += 1;
    }
    hashTableBits -= 1;
    var hashFuncShift = 32 - hashTableBits;
    if (typeof globalHashTables[hashTableBits] === "undefined") {
      globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);
    }
    var hashTable = globalHashTables[hashTableBits];
    var i2;
    for (i2 = 0; i2 < hashTable.length; i2++) {
      hashTable[i2] = 0;
    }
    var ipEnd = ip + inputSize;
    var ipLimit;
    var baseIp = ip;
    var nextEmit = ip;
    var hash2, nextHash;
    var nextIp, candidate, skip;
    var bytesBetweenHashLookups;
    var base2, matched, offset;
    var prevHash, curHash;
    var flag = true;
    var INPUT_MARGIN = 15;
    if (inputSize >= INPUT_MARGIN) {
      ipLimit = ipEnd - INPUT_MARGIN;
      ip += 1;
      nextHash = hashFunc(load32(input, ip), hashFuncShift);
      while (flag) {
        skip = 32;
        nextIp = ip;
        do {
          ip = nextIp;
          hash2 = nextHash;
          bytesBetweenHashLookups = skip >>> 5;
          skip += 1;
          nextIp = ip + bytesBetweenHashLookups;
          if (ip > ipLimit) {
            flag = false;
            break;
          }
          nextHash = hashFunc(load32(input, nextIp), hashFuncShift);
          candidate = baseIp + hashTable[hash2];
          hashTable[hash2] = ip - baseIp;
        } while (!equals32(input, ip, candidate));
        if (!flag) {
          break;
        }
        op = emitLiteral(input, nextEmit, ip - nextEmit, output, op);
        do {
          base2 = ip;
          matched = 4;
          while (ip + matched < ipEnd && input[ip + matched] === input[candidate + matched]) {
            matched += 1;
          }
          ip += matched;
          offset = base2 - candidate;
          op = emitCopy(output, op, offset, matched);
          nextEmit = ip;
          if (ip >= ipLimit) {
            flag = false;
            break;
          }
          prevHash = hashFunc(load32(input, ip - 1), hashFuncShift);
          hashTable[prevHash] = ip - 1 - baseIp;
          curHash = hashFunc(load32(input, ip), hashFuncShift);
          candidate = baseIp + hashTable[curHash];
          hashTable[curHash] = ip - baseIp;
        } while (equals32(input, ip, candidate));
        if (!flag) {
          break;
        }
        ip += 1;
        nextHash = hashFunc(load32(input, ip), hashFuncShift);
      }
    }
    if (nextEmit < ipEnd) {
      op = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op);
    }
    return op;
  }
  function putVarint(value, output, op) {
    do {
      output[op] = value & 127;
      value = value >>> 7;
      if (value > 0) {
        output[op] += 128;
      }
      op += 1;
    } while (value > 0);
    return op;
  }
  function SnappyCompressor$1(uncompressed) {
    this.array = uncompressed;
  }
  SnappyCompressor$1.prototype.maxCompressedLength = function() {
    var sourceLen = this.array.length;
    return 32 + sourceLen + Math.floor(sourceLen / 6);
  };
  SnappyCompressor$1.prototype.compressToBuffer = function(outBuffer) {
    var array = this.array;
    var length = array.length;
    var pos = 0;
    var outPos = 0;
    var fragmentSize;
    outPos = putVarint(length, outBuffer, outPos);
    while (pos < length) {
      fragmentSize = Math.min(length - pos, BLOCK_SIZE);
      outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);
      pos += fragmentSize;
    }
    return outPos;
  };
  snappy_compressor.SnappyCompressor = SnappyCompressor$1;
  function isNode() {
    if (typeof process === "object") {
      if (typeof process.versions === "object") {
        if (typeof process.versions.node !== "undefined") {
          return true;
        }
      }
    }
    return false;
  }
  function isUint8Array(object) {
    return object instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object));
  }
  function isArrayBuffer(object) {
    return object instanceof ArrayBuffer;
  }
  function isBuffer(object) {
    if (!isNode()) {
      return false;
    }
    return Buffer.isBuffer(object);
  }
  var SnappyDecompressor = snappy_decompressor.SnappyDecompressor;
  var SnappyCompressor = snappy_compressor.SnappyCompressor;
  var TYPE_ERROR_MSG = "Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array";
  function uncompress(compressed) {
    if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer(compressed)) {
      throw new TypeError(TYPE_ERROR_MSG);
    }
    var uint8Mode = false;
    var arrayBufferMode = false;
    if (isUint8Array(compressed)) {
      uint8Mode = true;
    } else if (isArrayBuffer(compressed)) {
      arrayBufferMode = true;
      compressed = new Uint8Array(compressed);
    }
    var decompressor = new SnappyDecompressor(compressed);
    var length = decompressor.readUncompressedLength();
    if (length === -1) {
      throw new Error("Invalid Snappy bitstream");
    }
    var uncompressed, uncompressedView;
    if (uint8Mode) {
      uncompressed = new Uint8Array(length);
      if (!decompressor.uncompressToBuffer(uncompressed)) {
        throw new Error("Invalid Snappy bitstream");
      }
    } else if (arrayBufferMode) {
      uncompressed = new ArrayBuffer(length);
      uncompressedView = new Uint8Array(uncompressed);
      if (!decompressor.uncompressToBuffer(uncompressedView)) {
        throw new Error("Invalid Snappy bitstream");
      }
    } else {
      uncompressed = Buffer.alloc(length);
      if (!decompressor.uncompressToBuffer(uncompressed)) {
        throw new Error("Invalid Snappy bitstream");
      }
    }
    return uncompressed;
  }
  function compress(uncompressed) {
    if (!isUint8Array(uncompressed) && !isArrayBuffer(uncompressed) && !isBuffer(uncompressed)) {
      throw new TypeError(TYPE_ERROR_MSG);
    }
    var uint8Mode = false;
    var arrayBufferMode = false;
    if (isUint8Array(uncompressed)) {
      uint8Mode = true;
    } else if (isArrayBuffer(uncompressed)) {
      arrayBufferMode = true;
      uncompressed = new Uint8Array(uncompressed);
    }
    var compressor = new SnappyCompressor(uncompressed);
    var maxLength = compressor.maxCompressedLength();
    var compressed, compressedView;
    var length;
    if (uint8Mode) {
      compressed = new Uint8Array(maxLength);
      length = compressor.compressToBuffer(compressed);
    } else if (arrayBufferMode) {
      compressed = new ArrayBuffer(maxLength);
      compressedView = new Uint8Array(compressed);
      length = compressor.compressToBuffer(compressedView);
    } else {
      compressed = Buffer.alloc(maxLength);
      length = compressor.compressToBuffer(compressed);
    }
    return compressed.slice(0, length);
  }
  snappyjs.uncompress = uncompress;
  snappyjs.compress = compress;
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  const FORMAT_UNCOMPRESSED_AUTOMERGE = 91;
  const FORMAT_UNCOMPRESSED_HEYMERGE = 123;
  const FORMAT_SNAPPY = 1;
  function prependByte(data, byte) {
    const result2 = new Uint8Array(data.byteLength + 1);
    result2[0] = byte;
    result2.set(data, 1);
    return result2;
  }
  function serializeData(obj) {
    const str = JSON.stringify(obj);
    const bin = encoder.encode(str);
    const compressed = snappyjs.compress(bin);
    return prependByte(compressed, FORMAT_SNAPPY);
  }
  function deserializeData(data) {
    let decompressed;
    if (data[0] === FORMAT_UNCOMPRESSED_AUTOMERGE || data[0] === FORMAT_UNCOMPRESSED_HEYMERGE) {
      decompressed = data;
    } else if (data[0] === FORMAT_SNAPPY) {
      decompressed = snappyjs.uncompress(data.slice(1));
    } else {
      throw new UnsupportedCompressionError();
    }
    const str = decoder.decode(decompressed);
    const obj = JSON.parse(str);
    return obj;
  }
  const MetaVaultContent = MetaVaultContentV2;
  function createInitialMetaVaultContent() {
    return { sessions: {} };
  }
  const metaVaultContentDescriptor = {
    version: 2,
    contentTypeName: "meta",
    vaultTypes: [VaultType.META],
    parseVaultContent: MetaVaultContent.parse.bind(MetaVaultContent),
    createInitialVaultContent: createInitialMetaVaultContent
  };
  function replaceSession(content, timestamp, id, session) {
    const newVault = modifyVault$1(content, "sessions", (list) => {
      var _a2;
      const oldSessionMeta = list[id];
      const newElement = Object.assign(Object.assign(Object.assign({ creationTime: timestamp }, oldSessionMeta), session), { editTime: (_a2 = session === null || session === void 0 ? void 0 : session.editTime) !== null && _a2 !== void 0 ? _a2 : timestamp, isDeleted: false, updateTime: timestamp });
      return {
        newList: Object.assign(Object.assign({}, list), { [id]: newElement }),
        result: void 0
      };
    });
    if (!MetaVaultContent.safeParse(newVault.newVaultContent).success) {
      throw new InvalidSessionModificationError();
    }
    return newVault;
  }
  function deleteSession(content, timestamp, id) {
    return modifyVault$1(content, "sessions", (list) => {
      return removeElement(list, timestamp, id);
    });
  }
  function addOrModifySiteSettings(content, timestamp, host, siteSettings) {
    return modifyVault$1(content, "siteSettings", (list) => {
      return addOrModifyElement(list, timestamp, host, siteSettings);
    });
  }
  function getAccountSettings(content) {
    var _a2;
    return (_a2 = content.accountSettings) === null || _a2 === void 0 ? void 0 : _a2[META_VAULT_ACCOUNT_SETTINGS_ID];
  }
  function modifyAccountSettings(content, timestamp, settings) {
    return modifyVault$1(content, "accountSettings", (list) => {
      if (!list[META_VAULT_ACCOUNT_SETTINGS_ID]) {
        return addOrModifyElement(list, timestamp, META_VAULT_ACCOUNT_SETTINGS_ID, Object.assign({}, settings));
      }
      return modifyElement(list, timestamp, META_VAULT_ACCOUNT_SETTINGS_ID, settings);
    });
  }
  const { OrganizationAdminVaultContent } = OAV;
  function getOrganizationAdminVaultInfo(content) {
    var _a2;
    return (_a2 = content.info) === null || _a2 === void 0 ? void 0 : _a2[ORGANIZATION_ADMIN_VAULT_INFO_ID];
  }
  function createInitialVaultContent() {
    return { info: {} };
  }
  const organizationAdminVaultContentDescriptor = {
    version: 2,
    contentTypeName: "organizationAdminV2",
    vaultTypes: [VaultType.ORGANIZATION_ADMIN],
    parseVaultContent: OrganizationAdminVaultContent.parse.bind(OrganizationAdminVaultContent),
    createInitialVaultContent
  };
  function replaceOrganizationAdminVaultInfo(content, timestamp, info) {
    return modifyVault$1(content, "info", (list) => {
      return addOrModifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function modifyOrganizationAdminVaultInfo(content, timestamp, info) {
    return modifyVault$1(content, "info", (list) => {
      return modifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
    });
  }
  function getVaultContentDescriptorByName(vaultType, contentTypeName, version) {
    const descriptor = getVaultContentDescriptor(contentTypeName, version);
    if (!descriptor.vaultTypes.includes(vaultType)) {
      throw new InvalidVaultContentDescriptorNameError(contentTypeName);
    }
    return descriptor;
  }
  function getVaultContentDescriptor(contentTypeName, version) {
    if (version !== DESCRIPTOR_VERSION_HEYMERGE) {
      throw new UnsupportedVaultVersionError();
    }
    switch (contentTypeName) {
      case loginVaultContentDescriptor.contentTypeName:
        return loginVaultContentDescriptor;
      case organizationPersonalVaultContentDescriptor.contentTypeName:
        return organizationPersonalVaultContentDescriptor;
      case metaVaultContentDescriptor.contentTypeName:
        return metaVaultContentDescriptor;
      case teamMetaVaultContentDescriptor.contentTypeName:
        return teamMetaVaultContentDescriptor;
      case legacyOrganizationAdminVaultContentDescriptor.contentTypeName:
        return legacyOrganizationAdminVaultContentDescriptor;
      case organizationAdminVaultContentDescriptor.contentTypeName:
        return organizationAdminVaultContentDescriptor;
      default:
        throw new InvalidVaultContentDescriptorNameError(contentTypeName);
    }
  }
  const validModificationFunctions = {
    addLoginInternal,
    modifyLoginInternal,
    addOrModifyLoginInternal,
    addLoginInternalWithHistory,
    modifyLoginInternalWithHistory,
    addOrModifyLoginInternalWithHistory,
    deleteLoginInternal,
    archiveLoginInternal,
    restoreArchivedLoginInternal,
    replaceSession,
    deleteSession,
    addOrModifySiteSettings,
    modifyTeamVaultInfo,
    addOrModifyTeamVaultUser,
    deleteTeamVaultUser,
    replaceLegacyOrganizationAdminVaultInfo,
    modifyLegacyOrganizationAdminVaultInfo,
    replaceOrganizationAdminVaultInfo,
    modifyOrganizationAdminVaultInfo,
    modifyAccountSettings
  };
  class VaultState {
    constructor(descriptor, state, stagedState) {
      this.descriptor = descriptor;
      this.state = state;
      this.stagedState = stagedState;
    }
    static createEmpty(descriptor) {
      return new VaultState(descriptor, descriptor.createInitialVaultContent(), {
        diff: descriptor.createInitialVaultContent(),
        updateTime: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    static initializeFromCommits(vaultType, commits) {
      const lastCommit = commits[commits.length - 1];
      const lastCommitState = deserializeData(lastCommit);
      if (Array.isArray(lastCommitState)) {
        throw new UnsupportedVaultVersionError();
      }
      const lastCommitStateParsed = VaultStateInternalStructure.safeParse(lastCommitState);
      if (!lastCommitStateParsed.success) {
        throw new InvalidCommitStructureError();
      }
      const descriptor = getVaultContentDescriptorByName(vaultType, lastCommitStateParsed.data.type, lastCommitStateParsed.data.version);
      let content = {};
      for (const commit of commits) {
        const commitState = deserializeData(commit);
        if (Array.isArray(commitState)) {
          throw new UnsupportedVaultVersionError();
        }
        const commitContent = VaultState.parseStateFromCommit(descriptor, commitState);
        content = mergeVaults(content, commitContent, descriptor.postMergeHooks).newVaultContent;
      }
      return new VaultState(descriptor, content, null);
    }
    static parseCommit(descriptor, inputCommit) {
      const parsed = VaultStateInternalStructure.safeParse(inputCommit);
      if (!parsed.success) {
        throw new InvalidCommitStructureError();
      }
      const state = parsed.data;
      if (state.version > descriptor.version) {
        throw new VaultContentTooNewError();
      }
      if (state.version < descriptor.version) {
        throw new NotImplementedError("vault content migration");
      }
      let content;
      try {
        content = descriptor.parseVaultContent(state.content);
      } catch (e) {
        trackError(e);
        throw new InvalidCommitContentError();
      }
      return Object.assign(Object.assign({}, parsed.data), { content });
    }
    static parseStateFromCommit(descriptor, inputCommit) {
      return VaultState.parseCommit(descriptor, inputCommit).content;
    }
    withModification(modification) {
      var _a2, _b2;
      const updateTime = (/* @__PURE__ */ new Date()).toISOString();
      const { newVaultContent: modifiedContent, result: modificationReturnValue } = modification(this.state, updateTime, validModificationFunctions);
      this.descriptor.parseVaultContent(modifiedContent);
      const { newVaultContent: newDiff } = diffVaults(this.state, modifiedContent, this.descriptor.postMergeHooks);
      const { newVaultContent } = mergeVaults((_b2 = (_a2 = this.stagedState) === null || _a2 === void 0 ? void 0 : _a2.diff) !== null && _b2 !== void 0 ? _b2 : this.descriptor.createInitialVaultContent(), newDiff, this.descriptor.postMergeHooks);
      const stagedState = {
        diff: newVaultContent,
        updateTime
      };
      return {
        state: new VaultState(this.descriptor, modifiedContent, stagedState),
        vaultContentDiff: newDiff,
        result: modificationReturnValue
      };
    }
    getContent() {
      return unpackHeymergeVaultContent(this.state);
    }
    getArchivedContent() {
      return unpackHeymergeVaultContentArchive(this.state);
    }
    getContentInternal() {
      return this.state;
    }
    applyCommit(commitData) {
      const deserialized = deserializeData(commitData);
      const commit = VaultState.parseCommit(this.descriptor, deserialized);
      const newState = this.loadAndValidateState(commit);
      return new VaultState(this.descriptor, newState, this.stagedState);
    }
    applyStagedDiff(diff) {
      var _a2, _b2;
      const commit = deserializeData(diff);
      const newState = this.loadAndValidateState(commit);
      const { newVaultContent } = mergeVaults((_b2 = (_a2 = this.stagedState) === null || _a2 === void 0 ? void 0 : _a2.diff) !== null && _b2 !== void 0 ? _b2 : this.descriptor.createInitialVaultContent(), commit.content, this.descriptor.postMergeHooks);
      const stagedState = {
        diff: newVaultContent,
        updateTime: getMaxVaultUpdateTime(newVaultContent)
      };
      return new VaultState(this.descriptor, newState, stagedState);
    }
    loadAndValidateState(diff) {
      const { newVaultContent: content } = mergeVaults(
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        this.state,
        diff.content,
        this.descriptor.postMergeHooks
      );
      const state = {
        type: diff.type,
        version: diff.version,
        content
      };
      VaultState.parseCommit(this.descriptor, state);
      return state.content;
    }
    getSquashedState() {
      const diff = diffVaults(this.descriptor.createInitialVaultContent(), this.state, this.descriptor.postMergeHooks);
      const commitWrap = {
        type: this.descriptor.contentTypeName,
        version: this.descriptor.version,
        content: diff.newVaultContent
      };
      return serializeData(commitWrap);
    }
    getStagedDiff(cappedUpdateTime) {
      if (this.stagedState === null) {
        return null;
      }
      let { state } = this;
      let { diff } = this.stagedState;
      if (cappedUpdateTime && cappedUpdateTime < this.stagedState.updateTime) {
        for (const k of getObjectKeys(diff)) {
          const { newVaultContent } = modifyVault$1(diff, k, (list) => {
            return setMaxUpdateTime(list, cappedUpdateTime);
          });
          diff = newVaultContent;
        }
        for (const k of getObjectKeys(state)) {
          const { newVaultContent } = modifyVault$1(state, k, (list) => {
            return setMaxUpdateTime(list, cappedUpdateTime);
          });
          state = newVaultContent;
        }
      }
      const commitWrap = {
        type: this.descriptor.contentTypeName,
        version: this.descriptor.version,
        content: diff
      };
      return {
        diff: serializeData(commitWrap),
        vaultState: new VaultState(this.descriptor, state, null),
        latestUpdateTime: cappedUpdateTime ? cappedUpdateTime : this.stagedState.updateTime
      };
    }
    hasStagedDiff() {
      return this.stagedState !== null;
    }
    getLatestUpdateTime() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.stagedState) === null || _a2 === void 0 ? void 0 : _a2.updateTime) !== null && _b2 !== void 0 ? _b2 : null;
    }
  }
  function getObjectKeys(obj) {
    return Object.keys(obj);
  }
  class Vault {
    constructor(id, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, linkedUpdateMessages, shareLinkUpdates) {
      this.id = id;
      this.type = type;
      this.associatedVaultId = associatedVaultId;
      this.generationId = generationId;
      this.firstCommitId = firstCommitId;
      this.commitId = commitId;
      this.userIds = userIds;
      this.profileIds = profileIds;
      this.organizationId = organizationId;
      this.authenticatorLocks = authenticatorLocks;
      this.profileLock = profileLock;
      this.adminProfileLock = adminProfileLock;
      this.dirty = dirty;
      this.isUserJoined = isUserJoined;
      this.vaultState = vaultState;
      this.vaultSecret = vaultSecret;
      this.messagePublicKey = messagePublicKey;
      this.messageQueue = messageQueue;
      this.inboxSlug = inboxSlug;
      this.linkedUpdateMessages = linkedUpdateMessages;
      this.shareLinkUpdates = shareLinkUpdates;
    }
    static createFromCommits(id, type, associatedVaultId, generationId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, vaultSecret, commits, stagedDiff, profileRepo, messagePublicKey, messageQueue, inboxSlug) {
      const firstCommitId = commits[0].id;
      const commitId = commits.slice(-1)[0].id;
      const rawCommits = commits.map((c2) => c2.getContent(vaultSecret));
      let vaultState = VaultState.initializeFromCommits(type, rawCommits);
      if (stagedDiff) {
        vaultState = vaultState.applyStagedDiff(stagedDiff);
      }
      const isUserJoined = profileRepo.profiles.some((p2) => profileIds.includes(p2.profile.id));
      if (profileLock) {
        const profile = profileRepo.getUnlocked(profileLock.lockingProfileId);
        if (!profile) {
          throw new LockProfileNotFoundError(profileLock.lockingProfileId);
        }
        if (profile.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(profile.profile.id, profile.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
        }
      } else if (adminProfileLock && organizationId) {
        const profile = profileRepo.getOrgAdminProfile(organizationId);
        if (!profile) {
          throw new LockProfileNotFoundError(adminProfileLock.lockingProfileId);
        }
        if (profile.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(profile.profile.id, profile.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
        }
      }
      return new Vault(id, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, [], []);
    }
    static createFromPersistable(pv, vaultAccess) {
      var _a2, _b2, _c2, _d2;
      const authenticatorLocks = pv.locks.map((al) => VaultAuthenticatorLock.load(al));
      const profileLock = pv.profileLock ? VaultProfileLock.load(pv.profileLock) : null;
      const adminProfileLock = pv.adminProfileLock ? VaultProfileLock.load(pv.adminProfileLock) : null;
      const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
      const vaultType = pv.type;
      let vaultState = VaultState.initializeFromCommits(vaultType, [pv.vaultState]);
      if (pv.stagedDiff) {
        vaultState = vaultState.applyStagedDiff(pv.stagedDiff);
      }
      const isUserJoined = vaultAccess.type === "profile";
      const messagePublicKey = pv.messagePublicKey ? loadEncryptionPublicKey(pv.messagePublicKey) : null;
      return new Vault(pv.id, vaultType, (_a2 = pv.associatedVaultId) !== null && _a2 !== void 0 ? _a2 : null, pv.generationId, (_b2 = pv.firstCommitId) !== null && _b2 !== void 0 ? _b2 : null, pv.commitId, pv.userIds, (_c2 = pv.profileIds) !== null && _c2 !== void 0 ? _c2 : [], (_d2 = pv.organizationId) !== null && _d2 !== void 0 ? _d2 : null, authenticatorLocks, profileLock, adminProfileLock, !!pv.dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, [], pv.inboxSlug, pv.linkedUpdateMessages, []);
    }
    getPersistable() {
      var _a2, _b2, _c2;
      const vaultState = this.vaultState.getSquashedState();
      const stagedDiff = (_b2 = (_a2 = this.vaultState.getStagedDiff()) === null || _a2 === void 0 ? void 0 : _a2.diff) !== null && _b2 !== void 0 ? _b2 : null;
      return {
        id: this.id,
        type: this.type,
        associatedVaultId: this.associatedVaultId,
        generationId: this.generationId,
        firstCommitId: (_c2 = this.firstCommitId) !== null && _c2 !== void 0 ? _c2 : void 0,
        commitId: this.commitId,
        userIds: this.userIds,
        profileIds: this.profileIds,
        organizationId: this.organizationId,
        locks: this.authenticatorLocks.map((l) => serializeVaultAuthenticatorLock(l)),
        profileLock: this.profileLock ? serializeVaultProfileLock(this.profileLock) : void 0,
        adminProfileLock: this.adminProfileLock ? serializeVaultProfileLock(this.adminProfileLock) : void 0,
        dirty: this.dirty,
        vaultState,
        stagedDiff,
        messagePublicKey: this.messagePublicKey,
        inboxSlug: this.inboxSlug,
        linkedUpdateMessages: this.linkedUpdateMessages
      };
    }
    getProfileId() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) !== null && _b2 !== void 0 ? _b2 : null;
    }
    getPersonalProfileId() {
      var _a2, _b2;
      if (this.type !== VaultType.ORGANIZATION_PERSONAL) {
        return null;
      }
      if (this.profileLock) {
        return (_a2 = this.profileIds.find((id) => {
          var _a3;
          return id === ((_a3 = this.profileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId);
        })) !== null && _a2 !== void 0 ? _a2 : null;
      } else if (this.adminProfileLock) {
        return (_b2 = this.profileIds.find((id) => {
          var _a3;
          return id !== ((_a3 = this.adminProfileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId);
        })) !== null && _b2 !== void 0 ? _b2 : null;
      }
      return null;
    }
    with({ type = this.type, id = this.id, associatedVaultId = this.associatedVaultId, generationId = this.generationId, firstCommitId = this.firstCommitId, commitId = this.commitId, userIds = this.userIds, profileIds = this.profileIds, organizationId = this.organizationId, authenticatorLocks = this.authenticatorLocks, profileLock = this.profileLock, adminProfileLock = this.adminProfileLock, dirty = this.dirty, isUserJoined = this.isUserJoined, vaultState = this.vaultState, vaultSecret = this.vaultSecret, messageQueue = this.messageQueue, messagePublicKey = this.messagePublicKey, inboxSlug = this.inboxSlug, linkedUpdateMessages = this.linkedUpdateMessages, shareLinkUpdates = this.shareLinkUpdates }) {
      return new Vault(id, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, linkedUpdateMessages, shareLinkUpdates);
    }
    withSyncUpdate(su, profileRepo) {
      let { userIds, profileIds, dirty, organizationId, profileLock, adminProfileLock, isUserJoined, messagePublicKey, inboxSlug } = this;
      let changed = false;
      const newUserIds = su.users.map((u2) => u2.id);
      if (!deepEqual$1(userIds, newUserIds)) {
        changed = true;
        userIds = newUserIds;
      }
      const newProfileIds = su.profiles.map((p2) => p2.id);
      if (!deepEqual$1(profileIds, newProfileIds)) {
        changed = true;
        profileIds = newProfileIds;
      }
      const newIsUserJoined = profileRepo.profiles.some((p2) => profileIds.includes(p2.profile.id));
      if (isUserJoined !== newIsUserJoined) {
        changed = true;
        isUserJoined = newIsUserJoined;
      }
      if (this.profileLock && (su.profileKeyGenerationId !== this.profileLock.lockingProfileKeyGenerationId || !isUserJoined)) {
        changed = true;
        profileLock = null;
      }
      if (this.adminProfileLock && (su.adminProfileKeyGenerationId !== this.adminProfileLock.lockingProfileKeyGenerationId || isUserJoined)) {
        changed = true;
        adminProfileLock = null;
      }
      if (su.dirty !== dirty) {
        changed = true;
        dirty = su.dirty;
      }
      if (su.organizationId !== organizationId) {
        changed = true;
        organizationId = su.organizationId;
      }
      if (su.inboxSlug !== inboxSlug) {
        changed = true;
        inboxSlug = su.inboxSlug;
      }
      const newMessagePublicKey = su.messagePublicKey ? loadEncryptionPublicKey(su.messagePublicKey) : null;
      if (!deepEqual$1(newMessagePublicKey, messagePublicKey)) {
        changed = true;
        messagePublicKey = newMessagePublicKey;
      }
      if (!changed) {
        return this;
      }
      return this.with({
        userIds,
        profileIds,
        dirty,
        organizationId,
        profileLock,
        adminProfileLock,
        isUserJoined,
        inboxSlug,
        messagePublicKey
      });
    }
    withDirty(dirty = true) {
      return this.dirty === dirty ? this : this.with({ dirty });
    }
    withLoadCommits(...commits) {
      let { commitId, vaultState } = this;
      for (const commit of commits) {
        if (commitId !== commit.parentId) {
          throw new ParentIdDoesntMatchError(this.commitId, commit.parentId);
        }
        try {
          const commitData = commit.getContent(this.vaultSecret);
          commitId = commit.id;
          vaultState = vaultState.applyCommit(commitData);
        } catch (e) {
          commitId = commit.id;
          trackError(e);
        }
      }
      return this.with({ commitId, vaultState });
    }
    withMessageQueue(messageQueue) {
      return this.with({ messageQueue });
    }
    withAddMessageQueue(...messageQueue) {
      const knownMessageIds = this.messageQueue.map((m2) => m2.id);
      const newMessages = messageQueue.filter((m2) => !knownMessageIds.includes(m2.id));
      return this.with({ messageQueue: [...this.messageQueue, ...newMessages] });
    }
    withLocks(vaultAccess, authenticatorLocks, profileLock, adminProfileLock) {
      if (vaultAccess.type === "admin-profile") {
        const { unlockedProfile: up } = vaultAccess;
        if (!adminProfileLock) {
          throw new LockProfileNotFoundError(up.profile.id);
        }
        if (up.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
        }
        return this.with({ authenticatorLocks: [], profileLock, adminProfileLock });
      } else if (vaultAccess.type === "profile") {
        const { unlockedProfile: up } = vaultAccess;
        if (!profileLock) {
          throw new LockProfileNotFoundError(up.profile.id);
        }
        if (up.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
          throw new ProfileKeyGenerationMismatchError(up.profile.id, up.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
        }
        return this.with({ authenticatorLocks: [], profileLock });
      } else {
        const { unlockedAuthenticator: ua } = vaultAccess;
        const isAuthenticatorLockAvailable = authenticatorLocks.some((l) => l.authenticatorId === ua.authenticator.id);
        if (!isAuthenticatorLockAvailable) {
          throw new LockAuthenticatorNotFoundError(ua.authenticator.id, authenticatorLocks);
        }
        return this.with({ authenticatorLocks, profileLock, adminProfileLock });
      }
    }
    withFirstCommitId(firstCommitId) {
      if (this.firstCommitId !== null) {
        throw new Error("Cannot change firstCommitId once set!");
      }
      return this.with({ firstCommitId });
    }
    getContentType() {
      return this.vaultState.descriptor.contentTypeName;
    }
    getVersion() {
      return this.vaultState.descriptor.version;
    }
    getStagedDiff(cappedUpdateTime) {
      const stagedData = this.vaultState.getStagedDiff(cappedUpdateTime === null || cappedUpdateTime === void 0 ? void 0 : cappedUpdateTime.toISOString());
      if (stagedData === null) {
        return null;
      }
      const { diff, vaultState, latestUpdateTime } = stagedData;
      const stagingVault = this.with({
        commitId: nullUuid,
        vaultState,
        linkedUpdateMessages: [],
        shareLinkUpdates: []
      });
      const { linkedUpdateMessages, shareLinkUpdates } = this;
      return { stagingVault, diff, latestUpdateTime, linkedUpdateMessages, shareLinkUpdates };
    }
    hasStagedDiff() {
      return this.vaultState.hasStagedDiff();
    }
    withCommitId(commitId) {
      if (this.id === nullUuid || this.commitId !== nullUuid) {
        throw new CannotOverrideCommitIdError();
      }
      return this.with({ commitId });
    }
    withModification(mod) {
      const { state: vaultState, vaultContentDiff, result: result2 } = this.vaultState.withModification(
        // @ts-ignore -- ts doesn't understand that HeymergeVaultContent<VaultContentSpec<T>> = T
        mod
      );
      return {
        vault: this.with({ vaultState }),
        // @ts-ignore -- ts doesn't understand that HeymergeVaultContent<VaultContentSpec<T>> = T
        vaultContentDiff,
        result: result2
      };
    }
    withAddLinkedUpdateMessage(...linkedUpdateMessages) {
      return this.with({
        linkedUpdateMessages: [...this.linkedUpdateMessages, ...linkedUpdateMessages]
      });
    }
    withAddShareLinkUpdate(...shareLinkUpdates) {
      return this.with({
        shareLinkUpdates: [...this.shareLinkUpdates, ...shareLinkUpdates]
      });
    }
    getContent() {
      return this.vaultState.getContent();
    }
    getArchivedContent() {
      return this.vaultState.getArchivedContent();
    }
    getContentInternal() {
      return this.vaultState.getContentInternal();
    }
  }
  class UnsyncedVault {
    constructor(type, userIds, profileIds, authenticatorLocks, profileLock, adminProfileLock, vaultState, commitBlob, organizationId, vaultSecret, protectedSecret, messageKeyPair, inbox) {
      this.type = type;
      this.userIds = userIds;
      this.profileIds = profileIds;
      this.authenticatorLocks = authenticatorLocks;
      this.profileLock = profileLock;
      this.adminProfileLock = adminProfileLock;
      this.vaultState = vaultState;
      this.commitBlob = commitBlob;
      this.organizationId = organizationId;
      this.vaultSecret = vaultSecret;
      this.protectedSecret = protectedSecret;
      this.messageKeyPair = messageKeyPair;
      this.inbox = inbox;
    }
    getCreationDto() {
      var _a2, _b2;
      return {
        blob: this.getCommitBlob(),
        locks: this.getAuthenticatorLockDtos(),
        profileLock: this.getProfileLockDto(),
        adminProfileLock: this.getAdminProfileLockDto(),
        messagePublicKey: (_a2 = this.messageKeyPair) === null || _a2 === void 0 ? void 0 : _a2.encPubKey,
        organizationId: (_b2 = this.organizationId) !== null && _b2 !== void 0 ? _b2 : void 0
      };
    }
    getAuthenticatorLockDtos() {
      return this.authenticatorLocks.map(serializeVaultAuthenticatorLock);
    }
    getProfileLockDto() {
      var _a2;
      return (_a2 = this.profileLock) !== null && _a2 !== void 0 ? _a2 : void 0;
    }
    getAdminProfileLockDto() {
      var _a2;
      return (_a2 = this.adminProfileLock) !== null && _a2 !== void 0 ? _a2 : void 0;
    }
    getExtraProfileLockDto(up) {
      var _a2, _b2;
      return VaultProfileLock.create(up, this.vaultSecret, this.protectedSecret, (_b2 = (_a2 = this.messageKeyPair) === null || _a2 === void 0 ? void 0 : _a2.encPrivKey) !== null && _b2 !== void 0 ? _b2 : null);
    }
    getExtraLockDto(ua) {
      const encryptedStorableVaultKey = asymCreateKek(ua.storableVaultKeyEncPubKey, this.vaultSecret);
      const encryptedHighSecurityVaultKey = asymCreateKek(ua.highSecurityVaultKeyEncPubKey, this.protectedSecret);
      const encryptedVaultMessagePrivateKey = this.messageKeyPair ? asymEncryptEncryptionPrivateKey(ua.highSecurityVaultKeyEncPubKey, this.messageKeyPair.encPrivKey) : null;
      return {
        encryptedStorableVaultKey,
        encryptedHighSecurityVaultKey,
        encryptedVaultMessagePrivateKey
      };
    }
    getCommitBlob() {
      return this.commitBlob;
    }
    static create(type, userIds, profileIds, authenticators, profile, adminProfile, organizationId, descriptor, inbox, mod) {
      const vaultSecret = newSymmetricSecret();
      const protectedSecret = newSymmetricSecret();
      const messageKeyPair = newEncryptionKeyPair();
      const authenticatorLocks = authenticators.map((a2) => VaultAuthenticatorLock.create(a2, vaultSecret, protectedSecret, messageKeyPair.encPrivKey));
      const profileLock = profile ? VaultProfileLock.create(profile, vaultSecret, protectedSecret, messageKeyPair.encPrivKey) : null;
      const adminProfileLock = adminProfile ? VaultProfileLock.create(adminProfile, vaultSecret, protectedSecret, messageKeyPair.encPrivKey) : null;
      const initialVaultState = UnsyncedVault.createInitialVaultState(descriptor, protectedSecret, mod);
      const { diff, vaultState } = initialVaultState.getStagedDiff();
      const { blob } = Commit.create(null, vaultSecret, diff);
      return new UnsyncedVault(type, userIds, profileIds, authenticatorLocks, profileLock, adminProfileLock, vaultState, blob, organizationId, vaultSecret, protectedSecret, messageKeyPair, inbox);
    }
    static createInitialVaultState(descriptor, protectedSecret, mod) {
      if (descriptor.version !== DESCRIPTOR_VERSION_HEYMERGE) {
        throw new UnsupportedVaultVersionError();
      }
      let initialVaultState = VaultState.createEmpty(descriptor);
      if (mod) {
        ({ state: initialVaultState } = initialVaultState.withModification(UnsyncedVault.wrapMod(mod, protectedSecret)));
      }
      return initialVaultState;
    }
    static wrapMod(mod, protectedSecret) {
      return (c2, t, fns) => {
        return mod(c2, t, Object.assign(Object.assign({}, fns), {
          protect: protect.bind(null, protectedSecret),
          unprotect: unprotect.bind(null, protectedSecret),
          unprotectWithContentId: unprotectWithContentId.bind(null, protectedSecret),
          // NOTE: there are no vault messages in unsynced vaults, so decryptVaultMessage is not needed
          decryptVaultMessage: null
        }));
      };
    }
    withIds(vaultId, generationId, commitId, associatedVaultId, organizationId) {
      var _a2, _b2, _c2, _d2;
      const firstCommitId = commitId;
      return new Vault(vaultId, this.type, associatedVaultId !== null && associatedVaultId !== void 0 ? associatedVaultId : null, generationId, firstCommitId, commitId, this.userIds, this.profileIds, organizationId, this.authenticatorLocks, this.profileLock, this.adminProfileLock, false, true, this.vaultState, this.vaultSecret, (_b2 = (_a2 = this.messageKeyPair) === null || _a2 === void 0 ? void 0 : _a2.encPubKey) !== null && _b2 !== void 0 ? _b2 : null, [], (_d2 = (_c2 = this.inbox) === null || _c2 === void 0 ? void 0 : _c2.slug) !== null && _d2 !== void 0 ? _d2 : null, [], []);
    }
  }
  class HighSecurityCache {
    constructor(userHsua) {
      this.userHsua = userHsua;
      this.cachedHighSecurityUnlockedProfiles = {};
    }
    static fromExisting(userHsua) {
      return new HighSecurityCache(userHsua);
    }
    static fromSecret(secret, authenticator) {
      const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(authenticator, secret);
      return new HighSecurityCache(hsua);
    }
    static fromSessionUnlock(unlockData, sessionEncPrivKey, authenticators) {
      const authenticator = authenticators.find((a2) => unlockData.authenticatorId === a2.id);
      if (authenticator === void 0) {
        throw new UnlockedAuthenticatorNotFoundError();
      }
      const { encryptedSecret } = unlockData;
      const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(authenticator, {
        authenticatorId: authenticator.id,
        seed: asymDecrypt(sessionEncPrivKey, loadAsymEncryptedBlob(encryptedSecret))
      });
      return new HighSecurityCache(hsua);
    }
    getAuthenticator() {
      return this.userHsua.authenticator;
    }
    getHighSecurityUnlockedAuthenticator() {
      return this.userHsua;
    }
    getHighSecurityUnlockedProfile(unlockedProfile, profileRepo) {
      if (this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId]) {
        return this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId];
      }
      if (unlockedProfile.profile.profileLock) {
        const parentUp = profileRepo.getUnlocked(unlockedProfile.profile.profileLock.lockingProfileId);
        if (!parentUp) {
          throw new LockProfileNotFoundError(unlockedProfile.profile.profileLock.lockingProfileId);
        }
        const parentHsup = this.getHighSecurityUnlockedProfile(parentUp, profileRepo);
        if (!parentHsup) {
          throw new LockProfileNotFoundError(unlockedProfile.profile.profileLock.lockingProfileId);
        }
        const hsup = HighSecurityUnlockedProfile.fromProfileLock(unlockedProfile, parentHsup);
        this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId] = hsup;
        return hsup;
      } else {
        const hsup = HighSecurityUnlockedProfile.fromAuthenticatorLocks(unlockedProfile, this.userHsua);
        this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId] = hsup;
        return hsup;
      }
    }
  }
  const KNOWN_USER_PROFILE_TYPES = [
    ProfileType.PREFERENCES,
    ProfileType.INBOX,
    ProfileType.PRIVATE,
    ProfileType.ORGANIZATION,
    ProfileType.ORGANIZATION_SERVICE
  ];
  const LOGIN_PROFILE_TYPES = [
    ProfileType.PRIVATE,
    ProfileType.ORGANIZATION,
    ProfileType.ORGANIZATION_SERVICE
  ];
  const ORGANIZATION_PROFILE_TYPES = [
    ProfileType.ORGANIZATION,
    ProfileType.ORGANIZATION_SERVICE
  ];
  class ProfileRepo {
    constructor(profiles, disabledProfiles, orgAdminProfiles) {
      this.profiles = profiles;
      this.disabledProfiles = disabledProfiles;
      this.orgAdminProfiles = orgAdminProfiles;
    }
    static create(profiles, disabledProfiles) {
      profiles.sort((a2, b) => {
        if (a2.profile.profileType !== b.profile.profileType) {
          return a2.profile.profileType - b.profile.profileType;
        }
        return a2.profile.id.localeCompare(b.profile.id);
      });
      return new ProfileRepo(profiles, disabledProfiles, []);
    }
    static createFromPersistable(persistable, ua) {
      const profiles = persistable.profiles.map((p2) => UnlockedProfile.load(p2, ua));
      const orgAdminProfiles = persistable.orgAdminProfiles.map((p2) => UnlockedProfile.load(p2, ua));
      return new ProfileRepo(profiles, persistable.disabledProfiles, orgAdminProfiles);
    }
    getPersistable(ua) {
      const orgAdminProfiles = this.orgAdminProfiles.map((p2) => p2.getPersistable(ua));
      return {
        profiles: this.profiles.map((p2) => p2.getPersistable()),
        disabledProfiles: this.disabledProfiles,
        orgAdminProfiles
      };
    }
    withSyncUpdate(suProfiles, unlockedAuthenticator, profileEnabledPredicate) {
      const profiles = [];
      const disabledProfiles = [];
      const orgAdminProfiles = [];
      for (const p2 of suProfiles) {
        if (!KNOWN_USER_PROFILE_TYPES.includes(p2.profileType)) {
          continue;
        }
        if (p2.profileLock) {
          continue;
        }
        if (profileEnabledPredicate(p2)) {
          profiles.push(UnlockedProfile.load(p2, unlockedAuthenticator));
        } else {
          disabledProfiles.push(loadProfile(p2));
        }
      }
      for (const p2 of suProfiles) {
        if (p2.profileType !== ProfileType.ORGANIZATION_ADMIN || !p2.profileLock) {
          continue;
        }
        const lockingProfile = profiles.find((lp) => {
          var _a2;
          return ((_a2 = p2.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) === lp.profile.id;
        });
        if (!lockingProfile) {
          continue;
        }
        const up = UnlockedProfile.load(p2, unlockedAuthenticator, lockingProfile);
        orgAdminProfiles.push(requireOrgAdminProfile(up));
      }
      return new ProfileRepo(profiles, disabledProfiles, orgAdminProfiles);
    }
    getUnlocked(profileId) {
      var _a2;
      return (_a2 = this.profiles.find((p2) => p2.profile.id === profileId)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    hasProfile(profileId) {
      return this.profiles.some((p2) => p2.profile.id === profileId);
    }
    hasAtLeastOneLoginsProfile() {
      return this.profiles.some((p2) => LOGIN_PROFILE_TYPES.includes(p2.profile.profileType));
    }
    getPrivateProfile() {
      var _a2;
      return (_a2 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.PRIVATE)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    getInboxProfile() {
      var _a2;
      return (_a2 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.INBOX)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    getPreferencesProfile() {
      var _a2;
      return (_a2 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.PREFERENCES)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    getAllOrganizationProfiles() {
      return this.profiles.filter((p2) => ORGANIZATION_PROFILE_TYPES.includes(p2.profile.profileType));
    }
    getAllProfilesByLockingProfileId(lockingProfileId) {
      return this.orgAdminProfiles.filter((p2) => {
        var _a2;
        return ((_a2 = p2.profile.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) === lockingProfileId;
      });
    }
    getOrganizationProfile(organizationId) {
      var _a2;
      return (_a2 = this.profiles.find((p2) => ORGANIZATION_PROFILE_TYPES.includes(p2.profile.profileType) && p2.profile.organizationId === organizationId)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    getOrgAdminProfile(organizationId) {
      var _a2;
      return (_a2 = this.orgAdminProfiles.find((p2) => p2.profile.profileType === ProfileType.ORGANIZATION_ADMIN && p2.profile.organizationId === organizationId)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    withOrgAdminProfile(unlockedProfile) {
      const existingProfile = this.getOrgAdminProfile(unlockedProfile.profile.organizationId);
      if ((existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.profile.keyGenerationId) === unlockedProfile.profile.keyGenerationId) {
        return this;
      }
      const otherOrgProfiles = this.orgAdminProfiles.filter((oap) => oap.profile.organizationId !== unlockedProfile.profile.organizationId);
      const adminProfiles = [...otherOrgProfiles, unlockedProfile];
      return new ProfileRepo(this.profiles, this.disabledProfiles, adminProfiles);
    }
    withRetainOrgAdminProfiles(keyGenerationIds) {
      const adminProfiles = this.orgAdminProfiles.filter((op) => keyGenerationIds.includes(op.profile.keyGenerationId));
      if (adminProfiles.length === this.orgAdminProfiles.length) {
        return this;
      }
      return new ProfileRepo(this.profiles, this.disabledProfiles, adminProfiles);
    }
    getAllLoginProfileIds() {
      return [
        ...this.profiles.flatMap((p2) => LOGIN_PROFILE_TYPES.includes(p2.profile.profileType) ? p2.profile.id : []),
        ...this.disabledProfiles.flatMap((p2) => LOGIN_PROFILE_TYPES.includes(p2.profileType) ? p2.id : [])
      ];
    }
  }
  function checkForeignVaultSyncPredicate(info, foreignVaultSyncPredicate) {
    var _a2, _b2, _c2;
    const profileIds = info.type === "syncUpdate" ? info.vault.profiles.map((p2) => p2.id) : info.vault.profileIds;
    if (foreignVaultSyncPredicate.profileAllVaults && profileIds.some((pId) => {
      var _a3;
      return (_a3 = foreignVaultSyncPredicate.profileAllVaults) === null || _a3 === void 0 ? void 0 : _a3.includes(pId);
    })) {
      return true;
    }
    if (info.vault.organizationId && ((_a2 = foreignVaultSyncPredicate.organizationAllVaults) === null || _a2 === void 0 ? void 0 : _a2.includes(info.vault.organizationId))) {
      return true;
    }
    const type = info.type === "syncUpdate" ? info.vault.vaultType : info.vault.type;
    if (foreignVaultSyncPredicate.organizationTeamVaults && (type === VaultType.TEAM || type === VaultType.TEAM_META)) {
      return true;
    }
    if (info.vault.organizationId && type === VaultType.ORGANIZATION_PERSONAL) {
      const userIdsToSync = (_b2 = foreignVaultSyncPredicate.organizationPersonalVaultsForUsers) === null || _b2 === void 0 ? void 0 : _b2[info.vault.organizationId];
      const userIds = info.type === "syncUpdate" ? info.vault.users.map((u2) => u2.id) : info.vault.userIds;
      const shouldSyncViaUser = !!userIdsToSync && userIds.some((uId) => userIdsToSync.includes(uId));
      if (shouldSyncViaUser) {
        return true;
      }
      const profileIdsToSync = (_c2 = foreignVaultSyncPredicate.organizationPersonalVaultsForProfiles) === null || _c2 === void 0 ? void 0 : _c2[info.vault.organizationId];
      const shouldSyncViaProfile = !!profileIdsToSync && profileIds.some((pId) => profileIdsToSync.includes(pId));
      if (shouldSyncViaProfile) {
        return true;
      }
    }
    return false;
  }
  function exponentialSlottedBackoff(attempt) {
    if (attempt === 0) {
      return Promise.resolve();
    }
    const maxDelaySlot = Math.pow(2, attempt);
    const delaySlot = Math.floor(Math.random() * maxDelaySlot);
    const delayMs = delaySlot * 100;
    return sleep(delayMs);
  }
  function getSessionUnlockedUntil(sessions, ccp) {
    var _a2, _b2;
    return (_b2 = (_a2 = sessions.find((s2) => s2.id === ccp.loginData.sessionId)) === null || _a2 === void 0 ? void 0 : _a2.unlockedUntil) !== null && _b2 !== void 0 ? _b2 : null;
  }
  const KNOWN_VAULT_MESSAGE_TYPES = [
    VaultMessageType.LOGIN_INBOX_V1,
    VaultMessageType.LINKED_LOGIN_UPDATE_V1,
    VaultMessageType.LINKED_VAULT_DELETED_V1,
    VaultMessageType.SHARE_LINK_OPENED_V1
  ];
  function processVaultMessages(vault, decryptVaultMessage, protect2) {
    if (vault.dirty) {
      return { vault, processedMessageIds: [] };
    }
    const messages2 = vault.messageQueue;
    const remainingMessages = [];
    const processedMessageIds = [];
    let updatedVault = vault;
    for (const m2 of messages2) {
      if (!KNOWN_VAULT_MESSAGE_TYPES.includes(m2.type)) {
        remainingMessages.push(m2);
        continue;
      }
      let decrypted;
      try {
        decrypted = decryptVaultMessage(m2);
      } catch (e) {
        trackError(new Error(`could not decrypt vault message: ${e}`));
        processedMessageIds.push(m2.id);
        continue;
      }
      try {
        if (m2.type === VaultMessageType.LOGIN_INBOX_V1) {
          updatedVault = processLoginInboxMessage(updatedVault, protect2, decrypted);
          processedMessageIds.push(m2.id);
        } else if (m2.type === VaultMessageType.LINKED_LOGIN_UPDATE_V1) {
          if (!m2.senderVaultId) {
            trackError(new Error(`dropping message with missing senderVaultId (vault ${vault.id})`));
            processedMessageIds.push(m2.id);
            continue;
          }
          updatedVault = processLinkedLoginUpdateMessage(m2.senderVaultId, updatedVault, protect2, decrypted);
          processedMessageIds.push(m2.id);
        } else if (m2.type === VaultMessageType.LINKED_VAULT_DELETED_V1) {
          if (!m2.senderVaultId) {
            trackError(new Error(`dropping message with missing senderVaultId (vault ${vault.id})`));
            processedMessageIds.push(m2.id);
            continue;
          }
          updatedVault = processLinkedVaultDeletedMessage(m2.senderVaultId, updatedVault);
          processedMessageIds.push(m2.id);
        } else if (m2.type === VaultMessageType.SHARE_LINK_OPENED_V1) {
          updatedVault = processShareLinkOpenedMessage(updatedVault, m2);
          processedMessageIds.push(m2.id);
        } else {
          remainingMessages.push(m2);
        }
      } catch (e) {
        trackError(new Error(`error processing message for vault ${vault.id}, dropping: ${e}`));
        processedMessageIds.push(m2.id);
      }
    }
    if (!processedMessageIds.length) {
      return { vault, processedMessageIds };
    }
    if (vault === updatedVault) {
      updatedVault = updatedVault.withModification((c2) => {
        return { newVaultContent: c2, result: void 0 };
      }).vault;
    }
    return {
      vault: updatedVault.withMessageQueue(remainingMessages),
      processedMessageIds
    };
  }
  function processLoginInboxMessage(vault, protect2, decrypted) {
    if (!decrypted) {
      throw new VaultMessageEncryptedDataNotFoundError();
    }
    if (vault.type !== VaultType.INBOX) {
      trackError(new Error(`found login inbox message V1 in non-inbox vault`));
      return vault;
    }
    const parsedMessage = LoginInboxMessageV1.parse(deserializeData(decrypted));
    const login = {
      uiType: LoginUiType.login,
      username: parsedMessage.username,
      websites: parsedMessage.website ? [parsedMessage.website] : [],
      password: protect2({ contentId: newUuid$1(), unencrypted: parsedMessage.password }),
      sender: parsedMessage.sender,
      creationTime: parsedMessage.creationTime,
      editTime: parsedMessage.creationTime,
      customFields: [],
      title: "",
      note: "",
      pendingInboxConfirmation: true,
      changeTime: parsedMessage.creationTime
    };
    return vault.withModification((c2, t, { addLoginInternal: addLoginInternal2 }) => {
      return addLoginInternal2(c2, t, login);
    }).vault;
  }
  function processLinkedLoginUpdateMessage(senderVaultId, vault, protect2, decrypted) {
    if (!decrypted) {
      throw new VaultMessageEncryptedDataNotFoundError();
    }
    if (vault.type !== VaultType.TEAM && vault.type !== VaultType.ORGANIZATION_PERSONAL) {
      trackError(new Error(`found linked login update message V1 in non-team non-personal vault`));
      return vault;
    }
    const parsedMessage = LinkedLoginUpdateMessageV1.parse(deserializeData(decrypted));
    return vault.withModification((c2, t, { addOrModifyLoginInternal: addOrModifyLoginInternal2, modifyLoginInternal: modifyLoginInternal2, deleteLoginInternal: deleteLoginInternal2 }) => {
      var _a2;
      for (const update of parsedMessage) {
        const existingLogin = c2.logins[update.loginId];
        if (update.type === "originUpdated") {
          if (existingLogin && !existingLogin.isDeleted && !existingLogin.linkedFrom) {
            throw new Error("tried to manipulate non-linked login via linked login!");
          }
          const { loginId, content } = update;
          if (existingLogin && existingLogin.updateTime >= content.updateTime) {
            continue;
          }
          if (content.isDeleted) {
            if (!existingLogin.isDeleted) {
              c2 = deleteLoginInternal2(c2, content.updateTime, loginId).newVaultContent;
            }
          } else {
            const protectedLogin = recursivelyTransformUnprotectedValues(content, protect2);
            c2 = addOrModifyLoginInternal2(c2, content.updateTime, loginId, protectedLogin).newVaultContent;
          }
        } else if (update.type === "targetDeleted") {
          if (!existingLogin.isDeleted) {
            const linkedTo = (_a2 = existingLogin.linkedTo) === null || _a2 === void 0 ? void 0 : _a2.flatMap((lt) => {
              if (lt.targetVaultId !== senderVaultId) {
                return lt;
              }
              return Object.assign(Object.assign({}, lt), { removeTime: update.removeTime });
            });
            c2 = modifyLoginInternal2(c2, t, update.loginId, { linkedTo }).newVaultContent;
          }
        }
      }
      return { newVaultContent: c2, result: void 0 };
    }).vault;
  }
  function processLinkedVaultDeletedMessage(senderVaultId, vault) {
    if (vault.type !== VaultType.TEAM && vault.type !== VaultType.ORGANIZATION_PERSONAL) {
      trackError(new Error(`found linked vault deleted message V1 in non-team non-personal vault`));
      return vault;
    }
    return vault.withModification((c2, t, { modifyLoginInternal: modifyLoginInternal2, deleteLoginInternal: deleteLoginInternal2 }) => {
      var _a2, _b2, _c2;
      const linkedLogins = Object.entries(c2.logins).filter((e) => !e[1].isDeleted && !!(e[1].linkedTo || e[1].linkedFrom));
      for (const [loginId, login] of linkedLogins) {
        if (((_a2 = login.linkedFrom) === null || _a2 === void 0 ? void 0 : _a2.originVaultId) === senderVaultId) {
          c2 = deleteLoginInternal2(c2, t, loginId).newVaultContent;
        } else if ((_b2 = login.linkedTo) === null || _b2 === void 0 ? void 0 : _b2.some((lt) => lt.targetVaultId === senderVaultId)) {
          const linkedTo = (_c2 = login.linkedTo) === null || _c2 === void 0 ? void 0 : _c2.flatMap((lt) => {
            if (lt.targetVaultId !== senderVaultId) {
              return lt;
            }
            return Object.assign(Object.assign({}, lt), { removeTime: t });
          });
          c2 = modifyLoginInternal2(c2, t, loginId, { linkedTo }).newVaultContent;
        }
      }
      return { newVaultContent: c2, result: void 0 };
    }).vault;
  }
  function processShareLinkOpenedMessage(vault, msg) {
    let parsedBackendMessage;
    try {
      if (!msg.backendMessage) {
        throw new Error("got share link opened message without backend message");
      }
      parsedBackendMessage = ShareLinkOpenedBackendMessageV1.parse(JSON.parse(naclUtilExports.encodeUTF8(msg.backendMessage)));
    } catch (e) {
      trackError(e);
      return vault;
    }
    const [shareLinkModificationInfo] = Object.entries(vault.getContent().logins).flatMap(([lId, login]) => {
      var _a2;
      if (!((_a2 = login.shareLinks) === null || _a2 === void 0 ? void 0 : _a2.some((sl) => sl.id === parsedBackendMessage.shareLinkId))) {
        return [];
      }
      const newShareLinks = login.shareLinks.map((sl) => {
        if (sl.id !== parsedBackendMessage.shareLinkId) {
          return sl;
        }
        if (sl.openedAt) {
          trackError("got share link opened message for previously opened share link");
        }
        return Object.assign(Object.assign({}, sl), { openedAt: parsedBackendMessage.openedAt });
      });
      return [{ loginId: lId, login, newShareLinks }];
    });
    if (!shareLinkModificationInfo) {
      return vault;
    }
    return vault.withModification((c2, t, { modifyLoginInternal: modifyLoginInternal2 }) => modifyLoginInternal2(c2, t, shareLinkModificationInfo.loginId, {
      shareLinks: shareLinkModificationInfo.newShareLinks
    })).vault;
  }
  var __rest$s = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function regenerateVault(vault, authenticatorsByUser, profilesById, newAuths, newProfiles, oldProtectedSecret, oldVaultMessagePrivateKey) {
    return regenerateVaultForUsers(vault, authenticatorsByUser, profilesById, vault.userIds, vault.profileIds, newAuths, newProfiles, oldProtectedSecret, oldVaultMessagePrivateKey).regeneratedVaultDto;
  }
  function regenerateVaultForUsers(vault, authenticatorsByUser, profilesById, userIds, profileIds, newAuths, newProfiles, oldProtectedSecret, oldMessagePrivateKey) {
    const newVaultSecret = newSymmetricSecret();
    const newProtectedSecret = newSymmetricSecret();
    const newVaultMessageKeyPair = newEncryptionKeyPair();
    let { vault: updatedVault } = vault.withModification((c2, t) => {
      return {
        newVaultContent: modifyProtectedValues(c2, t, (pv) => {
          const unprotected = unprotectWithContentId(oldProtectedSecret, pv);
          const reprotected = protect(newProtectedSecret, unprotected);
          return reprotected;
        }),
        result: void 0
      };
    });
    let processedMessageIds = [];
    let regeneratedMessages = [];
    if (oldMessagePrivateKey) {
      const decryptVaultMessage = (msg) => {
        return msg.encryptedData ? asymDecrypt(oldMessagePrivateKey, loadAsymEncryptedBlob(msg.encryptedData)) : void 0;
      };
      const protectInVault = (uv) => protect(newProtectedSecret, uv);
      const result2 = processVaultMessages(updatedVault, decryptVaultMessage, protectInVault);
      updatedVault = result2.vault;
      processedMessageIds = result2.processedMessageIds;
      regeneratedMessages = updatedVault.messageQueue.map((_a2) => {
        var { encryptedData } = _a2, rest = __rest$s(_a2, ["encryptedData"]);
        let newEncryptedData;
        if (encryptedData) {
          const decryptedData = asymDecrypt(oldMessagePrivateKey, loadAsymEncryptedBlob(encryptedData));
          newEncryptedData = asymEncrypt(newVaultMessageKeyPair.encPubKey, decryptedData);
        }
        return Object.assign(Object.assign({}, rest), { encryptedData: newEncryptedData });
      });
      updatedVault = updatedVault.withMessageQueue(regeneratedMessages);
    }
    const squashedVaultState = updatedVault.vaultState.getSquashedState();
    const authenticatorLocks = [];
    for (const userId of userIds) {
      const authenticators = authenticatorsByUser[userId];
      if (!authenticators) {
        throw new UserAuthenticatorsMissingForRegenerateError();
      }
      for (const a2 of authenticators) {
        const lock = VaultAuthenticatorLock.create(a2, newVaultSecret, newProtectedSecret, newVaultMessageKeyPair.encPrivKey);
        authenticatorLocks.push(serializeVaultAuthenticatorLock(lock));
      }
    }
    const profileLocks = [];
    for (const profileId of profileIds) {
      const profile = profilesById[profileId];
      if (!profile) {
        throw new ProfileMissingForRegenerateError();
      }
      const lock = VaultProfileLock.create(profile, newVaultSecret, newProtectedSecret, newVaultMessageKeyPair.encPrivKey);
      profileLocks.push(serializeVaultProfileLock(lock));
    }
    const newAuthenticatorEncryptedStorableVaultKeys = newAuths.map((a2) => asymCreateKek(a2.storableVaultKeyEncPubKey, newVaultSecret));
    const newAuthenticatorEncryptedHighSecurityVaultKeys = newAuths.map((a2) => asymCreateKek(a2.highSecurityVaultKeyEncPubKey, newProtectedSecret));
    const newAuthenticatorEncryptedVaultMessagePrivateKeys = newAuths.map((a2) => asymEncryptEncryptionPrivateKey(a2.highSecurityVaultKeyEncPubKey, newVaultMessageKeyPair.encPrivKey));
    const newProfileLockDtos = newProfiles.map((p2) => ({
      lockingProfileId: nullUuid,
      lockingProfileKeyGenerationId: nullUuid,
      encryptedStorableVaultKey: asymCreateKek(p2.storableVaultKeyEncPubKey, newVaultSecret),
      encryptedHighSecurityVaultKey: asymCreateKek(p2.highSecurityVaultKeyEncPubKey, newProtectedSecret),
      encryptedVaultMessagePrivateKey: newVaultMessageKeyPair !== null ? asymEncryptEncryptionPrivateKey(p2.highSecurityVaultKeyEncPubKey, newVaultMessageKeyPair.encPrivKey) : null
    }));
    const { blob } = Commit.create(null, newVaultSecret, squashedVaultState);
    return {
      regeneratedVaultDto: {
        id: updatedVault.id,
        latestCommitId: updatedVault.commitId,
        locks: authenticatorLocks,
        profileLocks,
        blob,
        newAuthenticatorEncryptedStorableVaultKeys,
        newAuthenticatorEncryptedHighSecurityVaultKeys,
        newAuthenticatorEncryptedVaultMessagePrivateKeys,
        messagePublicKey: newVaultMessageKeyPair === null || newVaultMessageKeyPair === void 0 ? void 0 : newVaultMessageKeyPair.encPubKey,
        deleteMessageIds: processedMessageIds,
        regeneratedMessages
      },
      newProfileLockDtos
    };
  }
  var __awaiter$L = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalGetUsers(backendClient, [...userIds], [...profileIds], userEmails, organizationId) {
    return __awaiter$L(this, void 0, void 0, function* () {
      const emailsByUserId = {};
      if (userEmails.length) {
        const resolvedEmails = yield backendClient.account.resolveEmails(userEmails, true);
        for (const re of resolvedEmails) {
          if (re.emailInvalid) {
            debugConsole.error("unexpected invalid email", re.email);
            continue;
          }
          if (!userEmails.includes(re.email)) {
            debugConsole.error("unexpected extra email", re.email);
            continue;
          }
          const orgProfile = re.profiles.find((p2) => p2.profileType === ProfileType.ORGANIZATION && p2.organizationId === organizationId);
          if (orgProfile) {
            profileIds.push(orgProfile.profileId);
            continue;
          }
          const privateProfile = re.profiles.find((p2) => p2.profileType === ProfileType.PRIVATE);
          if (privateProfile) {
            profileIds.push(privateProfile.profileId);
            continue;
          }
          if (re.userId) {
            userIds.push(re.userId);
            emailsByUserId[re.userId] = re.email;
            continue;
          }
        }
      }
      const index = [];
      const authenticatorsByUser = {};
      if (userIds.length) {
        const knownUserIds = [...userIds].map((id) => ({ id }));
        const { users } = yield backendClient.account.list(knownUserIds, [], []);
        for (const { id, authenticators, isProfilesEnabled } of users) {
          authenticatorsByUser[id] = authenticators.map((a2) => loadForeignAuthenticator(a2));
          index.push({ email: emailsByUserId[id], userId: id, isProfilesEnabled });
        }
      }
      const profilesById = {};
      if (profileIds.length) {
        const profiles = yield backendClient.profile.list(profileIds);
        for (const profile of profiles) {
          profilesById[profile.id] = loadForeignProfile(profile);
          index.push({ email: profile.email, profileId: profile.id, isProfilesEnabled: true });
        }
      }
      return { authenticatorsByUser, profilesById, index };
    });
  }
  var __awaiter$K = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalGetUsersForVaults({ backendClient, accountState, profileRepo }, vaults) {
    return __awaiter$K(this, void 0, void 0, function* () {
      const allUserIds = /* @__PURE__ */ new Set([
        ...vaults.map((v2) => v2.userIds).reduce((acc, val) => acc.concat(val), [])
      ]);
      const allProfileIds = new Set(vaults.map((v2) => v2.profileIds).reduce((acc, val) => acc.concat(val), []));
      allUserIds.delete(accountState.userId);
      profileRepo.profiles.forEach((p2) => allProfileIds.delete(p2.profile.id));
      const { authenticatorsByUser, profilesById, index } = yield onlineInternalGetUsers(backendClient, [...allUserIds], [...allProfileIds], []);
      profileRepo.profiles.forEach((p2) => profilesById[p2.profile.id] = p2.profile);
      return { authenticatorsByUser, profilesById, index };
    });
  }
  var __awaiter$J = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess, hsc) {
    return __awaiter$J(this, void 0, void 0, function* () {
      const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(vaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo, hsc);
      const { authenticatorsByUser, profilesById } = yield onlineInternalGetUsersForVaults(ccs, [
        vault
      ]);
      return regenerateVault(vault, authenticatorsByUser, profilesById, [], [], protectedSecret, messagePrivateKey);
    });
  }
  var __awaiter$I = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$r = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  var __asyncValues$1 = globalThis && globalThis.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  };
  function onlineInternalSync(_a2, syncUpdateArg, fcmMessageId, hsc) {
    var ccs = __rest$r(_a2, []);
    if (syncUpdateArg === void 0) {
      syncUpdateArg = null;
    }
    if (hsc === void 0) {
      hsc = null;
    }
    return __awaiter$I(this, void 0, void 0, function* () {
      const result2 = yield onlineInternalSyncReturningHighSecurityCache(ccs, syncUpdateArg, fcmMessageId, hsc);
      return result2.ccs;
    });
  }
  function onlineInternalSyncReturningHighSecurityCache(_a2, syncUpdateArg, fcmMessageId, hsc) {
    var ccs = __rest$r(_a2, []);
    if (syncUpdateArg === void 0) {
      syncUpdateArg = null;
    }
    if (hsc === void 0) {
      hsc = null;
    }
    return __awaiter$I(this, void 0, void 0, function* () {
      let su = syncUpdateArg;
      if (!su || su.syncVersion && ccs.syncVersion && su.syncVersion < ccs.syncVersion) {
        su = yield ccs.backendClient.sync.poll(fcmMessageId);
      }
      let shouldUpdateSyncVersion = true;
      ccs.lastKnownServerTime = su.serverTime;
      ccs.clientOutdated = su.clientOutdated;
      ccs.clientServerTimeOffsetMs = Date.now() - su.serverTime.getTime();
      ccs.tokenRefreshNeeded = su.tokenRefreshNeeded;
      ccs.accountState = ccs.accountState.withSyncUpdate(su);
      ccs = yield onlineInternalSyncAuthenticatorChain(ccs, su);
      ccs = onlineInternalSyncProfileRepo(ccs, su);
      if (!hsc) {
        ({ ccs, hsc } = yield onlineInternalSyncSessionUnlock(ccs, su));
      }
      try {
        ({ ccs, shouldUpdateSyncVersion } = yield onlineInternalSyncVaultRepo(ccs, su, hsc));
      } catch (e) {
        shouldUpdateSyncVersion = false;
        trackError(e);
      }
      try {
        ccs = yield onlineInternalSyncAchievements(ccs, su);
      } catch (e) {
        trackError(e);
      }
      try {
        ccs = yield onlineInternalSyncAuditlogEventQueue(ccs);
      } catch (e) {
        trackError(e);
      }
      if (su.maintenanceSettings) {
        ccs.maintenanceSettings = su.maintenanceSettings;
      }
      if (shouldUpdateSyncVersion) {
        ccs.syncVersion = su.syncVersion;
        ccs.backendClient = ccs.backendClient.withSyncVersion(su.syncVersion);
      }
      return { ccs, hsc: hsc !== null && hsc !== void 0 ? hsc : void 0 };
    });
  }
  function onlineInternalSyncProfileRepo(_a2, su) {
    var ccs = __rest$r(_a2, []);
    if (su.profiles) {
      const sessionId = ccs.backendClient.getSessionId();
      const session = ccs.accountState.sessions.find((s2) => s2.id === sessionId);
      const profileEnabledPredicate = (p2) => {
        var _a3;
        return isProfileEnabled(session, p2, (_a3 = ccs.ephemeralOperationState) === null || _a3 === void 0 ? void 0 : _a3.additionalEnabledProfileIds);
      };
      ccs.profileRepo = ccs.profileRepo.withSyncUpdate(su.profiles, ccs.params.unlockedAuthenticator, profileEnabledPredicate);
      const availableProfileIds = ccs.profileRepo.profiles.map((p2) => p2.profile.id);
      ccs.vaultRepo = ccs.vaultRepo.withDeleteWithoutMatchingProfileLocks(availableProfileIds);
    }
    return ccs;
  }
  function isProfileEnabled(session, profile, ephemeralEnabledProfileIds) {
    if (!LOGIN_PROFILE_TYPES.includes(profile.profileType)) {
      return true;
    }
    if (!session) {
      return true;
    }
    if (session.enabledProfileIds.length === 0) {
      return true;
    }
    return session.enabledProfileIds.includes(profile.id) || !!(ephemeralEnabledProfileIds === null || ephemeralEnabledProfileIds === void 0 ? void 0 : ephemeralEnabledProfileIds.includes(profile.id));
  }
  function onlineInternalSyncAuthenticatorChain(_a2, su) {
    var _b2;
    var ccs = __rest$r(_a2, []);
    return __awaiter$I(this, void 0, void 0, function* () {
      if (su.user) {
        if (su.user.authenticatorBlockHash) {
          if (!ccs.accountState.authenticatorBlockHash || !hashEqual(loadHash(su.user.authenticatorBlockHash), ccs.accountState.authenticatorBlockHash)) {
            const authListDto = yield ccs.backendClient.authenticator.list((_b2 = ccs.accountState.authenticatorBlockHash) !== null && _b2 !== void 0 ? _b2 : void 0);
            ccs.accountState = ccs.accountState.withAuthenticatorList(authListDto);
          }
        } else if (ccs.accountState.authenticatorBlockHash) {
          trackError(new Error("missing authenticator block hash"));
        } else {
          const authListDto = yield ccs.backendClient.authenticator.list();
          ccs.accountState = ccs.accountState.withAuthenticatorList(authListDto);
        }
      }
      return ccs;
    });
  }
  function onlineInternalSyncSessionUnlock(_a2, su) {
    var _b2, _c2;
    var ccs = __rest$r(_a2, []);
    return __awaiter$I(this, void 0, void 0, function* () {
      const { sessionUnlock } = su;
      const ownSession = ccs.accountState.sessions.find((s2) => uuidEqual(s2.id, ccs.params.loginData.sessionId));
      if (ccs.ignoredUnlock && ownSession && ((_b2 = ownSession.unlockedAt) === null || _b2 === void 0 ? void 0 : _b2.getTime()) === ((_c2 = ccs.ignoredUnlock) === null || _c2 === void 0 ? void 0 : _c2.getTime())) {
        ccs.protectedSecretRepo = null;
        return { ccs, hsc: null };
      }
      let hsc;
      const unlockedUntil = getSessionUnlockedUntil(ccs.accountState.sessions, ccs.params);
      if (ccs.pinnedAuthenticatorSecret) {
        const pinnedSecret = ccs.pinnedAuthenticatorSecret;
        const authenticator = ccs.accountState.authenticators.find((a2) => pinnedSecret.authenticatorId === a2.id);
        if (authenticator === void 0) {
          throw new UnlockedAuthenticatorNotFoundError();
        }
        hsc = HighSecurityCache.fromSecret(pinnedSecret, authenticator);
        if (!ccs.protectedSecretRepo) {
          ccs.protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, null);
        }
      } else if (sessionUnlock) {
        hsc = HighSecurityCache.fromSessionUnlock(sessionUnlock, ccs.params.sessionKeys.encPrivKey, ccs.accountState.authenticators);
        if (!ccs.protectedSecretRepo) {
          ccs.protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, unlockedUntil);
        } else if (unlockedUntil) {
          ccs.protectedSecretRepo = ccs.protectedSecretRepo.withUnlockedUntil(unlockedUntil);
        }
      } else {
        hsc = null;
        ccs.protectedSecretRepo = null;
      }
      ccs = refreshOrgAdminCaches(ccs, hsc);
      return { ccs, hsc };
    });
  }
  function refreshOrgAdminCaches(_a2, hsc) {
    var ccs = __rest$r(_a2, []);
    if (!ccs.backendClient.config.syncSuperUsers || !hsc || !ccs.protectedSecretRepo) {
      return ccs;
    }
    for (const org of ccs.accountState.organizations) {
      if (!org.adminInfo) {
        continue;
      }
      const orgVaultAccess = getOrgAdminVaultAccess(ccs.protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, hsc, org);
      if (!orgVaultAccess) {
        continue;
      }
      const secrets = {};
      for (const vault of ccs.vaultRepo.getForeignVaultsByOrganizationId(orgVaultAccess.orgId)) {
        if (ccs.protectedSecretRepo.hasVault(vault.id)) {
          continue;
        }
        try {
          const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(orgVaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo, hsc);
          secrets[vault.id] = {
            generationId: vault.generationId,
            protectedSecret,
            messagePrivateKey
          };
        } catch (e) {
          trackError(new Error(`Dropping vault ${vault.id} due to failed unlockLockProtectedSecret: ${e}`));
          ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
        }
        ccs.protectedSecretRepo = ccs.protectedSecretRepo.withOrganization(org.id, secrets);
      }
    }
    return ccs;
  }
  function onlineInternalSyncVaultRepo(ccs, su, hsc) {
    var _a2, e_1, _b2, _c2;
    var _d2, _e2, _f2, _g2;
    return __awaiter$I(this, void 0, void 0, function* () {
      let { vaults: suVaultList } = su;
      let shouldUpdateSyncVersion = true;
      const syncPromises = [];
      if (suVaultList === void 0) {
        for (const vault of ccs.vaultRepo.getAllVaults()) {
          if (shouldSyncVault(vault.type)) {
            syncPromises.push(onlineInternalSyncVault(ccs, vault, null, hsc, su.serverTime));
          }
        }
      } else {
        suVaultList = suVaultList.filter((suv) => shouldUseSyncUpdateVault(ccs, suv));
        for (const vault of ccs.vaultRepo.getLegacyOrganizationAdminVaults()) {
          if (suVaultList.some((suv) => suv.id === vault.id)) {
            continue;
          }
          ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
          ccs.protectedSecretRepo = (_e2 = (_d2 = ccs.protectedSecretRepo) === null || _d2 === void 0 ? void 0 : _d2.withDeleteProtectedSecret(vault.id)) !== null && _e2 !== void 0 ? _e2 : null;
        }
        const adminVaultSyncs = suVaultList.filter((v2) => v2.vaultType === VaultType.LEGACY_ORGANIZATION_ADMIN).map((v2) => {
          const localVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(v2.id);
          if (localVault) {
            return onlineInternalSyncVault(ccs, localVault, v2, hsc, su.serverTime);
          } else {
            return onlineInternalInitializeVault(ccs, v2, hsc);
          }
        });
        try {
          for (var _h2 = true, adminVaultSyncs_1 = __asyncValues$1(adminVaultSyncs), adminVaultSyncs_1_1; adminVaultSyncs_1_1 = yield adminVaultSyncs_1.next(), _a2 = adminVaultSyncs_1_1.done, !_a2; _h2 = true) {
            _c2 = adminVaultSyncs_1_1.value;
            _h2 = false;
            const vaultSyncResult = _c2;
            if (vaultSyncResult.vault) {
              ccs = applyVaultSyncResult(ccs, vaultSyncResult);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_h2 && !_a2 && (_b2 = adminVaultSyncs_1.return))
              yield _b2.call(adminVaultSyncs_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        ccs = refreshOrgAdminCaches(ccs, hsc);
        const localVaultIds = new Set(ccs.vaultRepo.getAllVaults().map((v2) => v2.id));
        for (const vault of ccs.vaultRepo.getAllVaults()) {
          if (vault.type === VaultType.LEGACY_ORGANIZATION_ADMIN) {
            continue;
          }
          const syncUpdateVault = suVaultList.find((suv) => suv.id === vault.id);
          if (!syncUpdateVault) {
            ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
            ccs.protectedSecretRepo = (_g2 = (_f2 = ccs.protectedSecretRepo) === null || _f2 === void 0 ? void 0 : _f2.withDeleteProtectedSecret(vault.id)) !== null && _g2 !== void 0 ? _g2 : null;
          } else {
            syncPromises.push(onlineInternalSyncVault(ccs, vault, syncUpdateVault, hsc, su.serverTime));
          }
        }
        const newVaults = suVaultList.filter((v2) => !localVaultIds.has(v2.id));
        for (const syncUpdateVault of newVaults) {
          syncPromises.push(onlineInternalInitializeVault(ccs, syncUpdateVault, hsc));
        }
      }
      const syncPromiseResults = yield Promise.allSettled(syncPromises);
      for (const syncPromiseResult of syncPromiseResults) {
        if (syncPromiseResult.status === "fulfilled") {
          ccs = applyVaultSyncResult(ccs, syncPromiseResult.value);
        } else {
          shouldUpdateSyncVersion = false;
          if (syncPromiseResult.reason instanceof DomainError$1 && syncPromiseResult.reason.code === ClientCoreErrorCode.VaultIsLocked)
            ;
          else {
            trackError(syncPromiseResult.reason);
          }
        }
      }
      for (const syncPromiseResult of syncPromiseResults) {
        if (syncPromiseResult.status === "fulfilled") {
          ccs = applyVaultSyncResultVaultMessages(ccs, syncPromiseResult.value);
        }
      }
      ccs = ensureVaultRepoConsistency(ccs);
      const adminOrgIds = ccs.accountState.organizations.filter((o) => !!o.adminInfo).map((o) => o.id);
      for (const orgId of Object.keys(ccs.superUserUnlockedAuthenticators)) {
        const isAdmin = adminOrgIds.some((id) => id === orgId);
        if (!isAdmin) {
          const newSuperUserUnlockedAuthenticators = Object.assign({}, ccs.superUserUnlockedAuthenticators);
          delete newSuperUserUnlockedAuthenticators[orgId];
          ccs.superUserUnlockedAuthenticators = newSuperUserUnlockedAuthenticators;
        }
      }
      return { ccs, shouldUpdateSyncVersion };
    });
  }
  function shouldUseSyncUpdateVault({ profileRepo, foreignVaultSyncPredicate, ephemeralForeignVaultSyncPredicate }, suv) {
    if (!shouldSyncVault(suv.vaultType)) {
      return false;
    }
    const isOwnVault = suv.profiles.some(({ id }) => profileRepo.hasProfile(id));
    const isAdminVault = suv.vaultType === VaultType.ORGANIZATION_ADMIN;
    const isForeignOrgVault = suv.organizationId && profileRepo.getOrganizationProfile(suv.organizationId);
    return isOwnVault || isAdminVault || isForeignOrgVault && (checkForeignVaultSyncPredicate({ type: "syncUpdate", vault: suv }, foreignVaultSyncPredicate) || checkForeignVaultSyncPredicate({ type: "syncUpdate", vault: suv }, ephemeralForeignVaultSyncPredicate));
  }
  function shouldSyncVault(vaultType) {
    if (vaultType === VaultType.UNKNOWN) {
      return false;
    }
    return true;
  }
  function applyVaultSyncResult(_a2, _b2) {
    var _c2, _d2;
    var ccs = __rest$r(_a2, []);
    var vault = _b2.vault, newSecrets = _b2.newSecrets, vaultAccess = _b2.vaultAccess;
    if (vault) {
      ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
      if (newSecrets) {
        ccs.protectedSecretRepo = (_d2 = (_c2 = ccs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.withProtectedSecret(vault, newSecrets.protectedSecret, newSecrets.messagePrivateKey)) !== null && _d2 !== void 0 ? _d2 : null;
      }
      if ((vaultAccess === null || vaultAccess === void 0 ? void 0 : vaultAccess.type) === "admin-authenticator") {
        ccs.superUserUnlockedAuthenticators = Object.assign(Object.assign({}, ccs.superUserUnlockedAuthenticators), { [vaultAccess.orgId]: vaultAccess.unlockedAuthenticator });
      }
    }
    return ccs;
  }
  function applyVaultSyncResultVaultMessages(_a2, _b2) {
    var ccs = __rest$r(_a2, []);
    var synthesizedVaultMessages = _b2.synthesizedVaultMessages;
    if (synthesizedVaultMessages) {
      for (const { vaultId, message } of synthesizedVaultMessages) {
        if (ccs.vaultRepo.vaultExits(vaultId)) {
          let v2 = ccs.vaultRepo.getVaultById(vaultId);
          v2 = v2.withAddMessageQueue(message);
          ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(v2);
        }
      }
    }
    return ccs;
  }
  function onlineInternalSyncVault(ccs, initialVault, syncUpdate, hsc, syncUpdateServerTime) {
    var _a2, _b2;
    return __awaiter$I(this, void 0, void 0, function* () {
      let vault = initialVault;
      let shouldPerformUpdate = false;
      let forceRegenerate = false;
      if (syncUpdate) {
        vault = vault.withSyncUpdate(syncUpdate, ccs.profileRepo);
        shouldPerformUpdate = vault.commitId !== syncUpdate.commitId || syncUpdate.hasMessagesQueued;
        if (!shouldPerformUpdate && vault.isUserJoined) {
          const hasProfileWithoutLock = !vault.profileLock && vault.profileIds.some((id) => ccs.profileRepo.hasProfile(id));
          if (hasProfileWithoutLock) {
            shouldPerformUpdate = true;
          }
        }
        if (!shouldPerformUpdate && !vault.isUserJoined && vault.organizationId) {
          const orgAdminProfile = ccs.profileRepo.getOrgAdminProfile(vault.organizationId);
          const hasAdminProfileWithoutLock = orgAdminProfile && !vault.adminProfileLock && vault.profileIds.includes(orgAdminProfile.profile.id);
          if (hasAdminProfileWithoutLock) {
            shouldPerformUpdate = true;
          }
        }
        if ((vault.type === VaultType.ORGANIZATION_PERSONAL || vault.type === VaultType.PRIVATE) && vault.isUserJoined && vault.messagePublicKey === null) {
          forceRegenerate = true;
        }
        if (vault.isUserJoined && vault.messagePublicKey === null && vault.linkedUpdateMessages.length > 0) {
          forceRegenerate = true;
        }
        if (vault.messagePublicKey === null && vault.hasStagedDiff()) {
          forceRegenerate = true;
        }
      }
      const vaultBackendClient = getBackendClientForVault(ccs, vault);
      const vaultAccess = getVaultAccess(ccs, hsc, vault);
      if (!vaultAccess) {
        return {};
      }
      let newSecrets;
      let synthesizedVaultMessages;
      try {
        let forceFullReload = false;
        for (let attempt = 0; ; attempt += 1) {
          yield exponentialSlottedBackoff(attempt);
          let cappedUpdateTime = syncUpdateServerTime;
          try {
            if (shouldPerformUpdate) {
              const hasAuthenticatorLock = vaultAccess.type === "admin-authenticator" && vault.authenticatorLocks.some((l) => l.authenticatorId === vaultAccess.unlockedAuthenticator.authenticator.id);
              const hasProfile = vault.profileIds.some((id) => ccs.profileRepo.hasProfile(id));
              const isLockRequired = !vault.profileLock && !vault.adminProfileLock && (!hasAuthenticatorLock || hasProfile);
              const vaultUpdate = forceFullReload ? yield vaultBackendClient.vault.listCommits(vault.id, null, null, false) : yield vaultBackendClient.vault.listCommits(vault.id, vault.commitId, vault.firstCommitId, isLockRequired);
              cappedUpdateTime = vaultUpdate.serverTime;
              const updatedVault2 = internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate, vaultAccess);
              vault = updatedVault2.vault;
              newSecrets = (_a2 = updatedVault2.newSecrets) !== null && _a2 !== void 0 ? _a2 : newSecrets;
            }
            const updatedVault = yield onlineInternalPushOrRegenerateVaultIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate);
            vault = updatedVault.vault;
            newSecrets = (_b2 = updatedVault.newSecrets) !== null && _b2 !== void 0 ? _b2 : newSecrets;
            synthesizedVaultMessages = updatedVault.synthesizedVaultMessages;
            forceRegenerate = false;
            break;
          } catch (e) {
            if (e instanceof DomainError$1 && e.code === BackendErrorCode.VAULT_OUT_OF_SYNC) {
              shouldPerformUpdate = true;
            } else if (e instanceof DomainError$1 && e.code === BackendErrorCode.INVALID_UPDATE_TIME) {
              shouldPerformUpdate = true;
              trackError(new Error(`Invalid update time, retrying sync #${attempt} for vault ${vault.id}`));
            } else if (e instanceof DomainError$1 && e.code === BackendErrorCode.VAULT_DIRTY) {
              vault = vault.withDirty();
            } else if (e instanceof DomainError$1 && (e.code === ClientCoreErrorCode.NeedLocks || e.code === ClientCoreErrorCode.NeedFullHistory)) {
              if (!forceFullReload) {
                shouldPerformUpdate = true;
                forceFullReload = true;
                trackError(e);
              } else {
                throw e;
              }
            } else {
              throw e;
            }
          }
          if (attempt === 4) {
            trackError(new Error(`Bailing out of syncVault for vault ${vault.id} due to excessive retries`));
            break;
          }
        }
        const vaultChanged = vault !== initialVault;
        if (!vaultChanged) {
          return {};
        }
        return { vault, newSecrets, synthesizedVaultMessages, vaultAccess };
      } catch (e) {
        throw e;
      }
    });
  }
  function onlineInternalPushOrRegenerateVaultIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate) {
    return __awaiter$I(this, void 0, void 0, function* () {
      if (vault.dirty || forceRegenerate) {
        return onlineInternalCreateRegeneratedVaultDuringSyncIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate);
      }
      return onlineInternalSyncPushCommitIfNecessary(vaultBackendClient, vault, cappedUpdateTime);
    });
  }
  function onlineInternalSyncPushCommitIfNecessary(vaultBackendClient, vault, serverTime) {
    var _a2, _b2;
    return __awaiter$I(this, void 0, void 0, function* () {
      const stagedData = vault.getStagedDiff(serverTime);
      if (!stagedData) {
        return { vault };
      }
      const { stagingVault, diff, latestUpdateTime, linkedUpdateMessages, shareLinkUpdates } = stagedData;
      const protoCommit = Commit.create(null, vault.vaultSecret, diff);
      const messages2 = linkedUpdateMessages.length ? yield prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) : [];
      const activeShareLinkIds = (_b2 = (_a2 = vault.vaultState.descriptor).getActiveShareLinkIds) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, vault.getContentInternal());
      const { commitId, updateMessageIds } = yield vaultBackendClient.vault.createCommit(vault.id, vault.commitId, protoCommit.blob, new Date(latestUpdateTime), [], messages2, shareLinkUpdates, { keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : [] });
      const synthesizedVaultMessages = messages2.map((m2) => ({
        vaultId: m2.vaultId,
        message: {
          id: updateMessageIds.shift(),
          type: m2.type,
          encryptedData: m2.encryptedData,
          senderVaultId: vault.id
        }
      }));
      return {
        vault: stagingVault.withCommitId(commitId),
        synthesizedVaultMessages
      };
    });
  }
  function onlineInternalCreateRegeneratedVaultDuringSyncIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate) {
    var _a2, _b2;
    return __awaiter$I(this, void 0, void 0, function* () {
      const stagedData = vault.getStagedDiff(cappedUpdateTime);
      if (!stagedData && !forceRegenerate) {
        return { vault };
      }
      if (!hsc) {
        throw new VaultIsLockedError();
      }
      const regeneratedVaultDto = yield onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess, hsc);
      const activeShareLinkIds = (_b2 = (_a2 = vault.vaultState.descriptor).getActiveShareLinkIds) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, vault.getContentInternal());
      if (!stagedData) {
        yield vaultBackendClient.vault.createGeneration(regeneratedVaultDto, [], {
          keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : []
        });
        const vaultUpdate2 = yield vaultBackendClient.vault.listCommits(vault.id, null, null, false);
        return internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate2, vaultAccess);
      }
      const { stagingVault, linkedUpdateMessages, shareLinkUpdates } = stagedData;
      const messages2 = linkedUpdateMessages.length ? yield prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) : [];
      const { updateMessageIds } = yield vaultBackendClient.vault.createGeneration(regeneratedVaultDto, messages2, { keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : [] }, shareLinkUpdates);
      const synthesizedVaultMessages = messages2.map((m2) => ({
        vaultId: m2.vaultId,
        message: {
          id: updateMessageIds.shift(),
          type: m2.type,
          encryptedData: m2.encryptedData,
          senderVaultId: vault.id
        }
      }));
      const vaultUpdate = yield vaultBackendClient.vault.listCommits(vault.id, null, null, false);
      let updatedVault = internalUpdateVaultFromDto(ccs, hsc, stagingVault, vaultUpdate, vaultAccess);
      updatedVault = Object.assign(Object.assign({}, updatedVault), { vault: updatedVault.vault.withDirty(false) });
      return Object.assign(Object.assign({}, updatedVault), { synthesizedVaultMessages });
    });
  }
  function prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) {
    return __awaiter$I(this, void 0, void 0, function* () {
      if (linkedUpdateMessages.length === 0) {
        return [];
      }
      if (!vault.organizationId) {
        throw new Error("vault with linked logins must be in organization");
      }
      const vaultIds = new Set(linkedUpdateMessages.map(({ vaultId }) => vaultId));
      const { messagePublicKeys } = yield vaultBackendClient.vault.listMessagePublicKeys(vault.organizationId, [...vaultIds]);
      const mpksByVault = {};
      for (const { vaultId, generationId, key } of messagePublicKeys) {
        if (key.length > 0) {
          mpksByVault[vaultId] = {
            generationId,
            messagePublicKey: loadEncryptionPublicKey(key)
          };
        }
      }
      return linkedUpdateMessages.flatMap(({ vaultId, message, type }) => {
        if (!mpksByVault[vaultId]) {
          trackError(new Error("linked vault is missing public key, no longer exists? (skipping)"));
          return [];
        }
        const { generationId, messagePublicKey } = mpksByVault[vaultId];
        return {
          vaultId,
          generationId,
          encryptedData: asymEncrypt(messagePublicKey, serializeData(message)),
          type
        };
      });
    });
  }
  function internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate, vaultAccess) {
    var _a2, _b2;
    const { generationId, commitDtos, lockDtos, profileLockDto, adminProfileLockDto, firstCommitId, messages: messages2 } = vaultUpdate;
    const commits = commitDtos.map((c2) => Commit.load(c2));
    const isSameGeneration = generationId === vault.generationId;
    const isReceivedFullHistory = commits.length && commits[0].id === firstCommitId;
    const isLocalCommitsMissing = isSameGeneration && isReceivedFullHistory && !commits.some(({ id }) => id === vault.commitId);
    if (isLocalCommitsMissing) {
      trackError(new Error(`One or more commits (latest local: ${vault.commitId}) were lost serverside in vault ${vault.id}`));
      const stagedDiff2 = vault.vaultState.getSquashedState();
      const updatedVault2 = Vault.createFromCommits(vault.id, vault.type, vault.associatedVaultId, generationId, vault.userIds, vault.profileIds, vault.organizationId, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, vault.dirty, vault.vaultSecret, commits, stagedDiff2, ccs.profileRepo, vault.messagePublicKey, messages2, vault.inboxSlug);
      return { vault: updatedVault2 };
    }
    if (isSameGeneration) {
      let newCommits;
      if (isReceivedFullHistory) {
        const lastKnownCommitIndex = commits.findIndex(({ id }) => id === vault.commitId);
        newCommits = commits.slice(lastKnownCommitIndex + 1);
        trackError(new Error(`Unexpectedly received full history for vault ${vault.id} (${lastKnownCommitIndex + 1} old commits)`));
      } else {
        newCommits = commits;
      }
      let updatedVault2 = vault.withLoadCommits(...newCommits).withMessageQueue(messages2);
      if (vault.firstCommitId === null) {
        updatedVault2 = updatedVault2.withFirstCommitId(firstCommitId);
      }
      let newSecrets2;
      if (lockDtos.length || profileLockDto || adminProfileLockDto) {
        const authenticatorLocks2 = (_a2 = lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.map((dto) => VaultAuthenticatorLock.load(dto))) !== null && _a2 !== void 0 ? _a2 : [];
        const profileLock2 = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
        const adminProfileLock2 = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
        updatedVault2 = updatedVault2.withLocks(vaultAccess, authenticatorLocks2, profileLock2, adminProfileLock2);
      }
      if (hsc && (lockDtos.length || profileLockDto || adminProfileLockDto)) {
        newSecrets2 = unlockLockProtectedSecret(vaultAccess, updatedVault2.authenticatorLocks, updatedVault2.profileLock, updatedVault2.adminProfileLock, ccs.profileRepo, hsc);
      }
      return { vault: updatedVault2, newSecrets: newSecrets2 };
    }
    if (!isReceivedFullHistory) {
      throw new NeedFullHistoryError(vault.id, vault.generationId, generationId);
    }
    if (!(lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.length) && !profileLockDto && !adminProfileLockDto) {
      throw new NeedLocksError(vault.id, vault.generationId, generationId);
    }
    const authenticatorLocks = lockDtos.map((dto) => VaultAuthenticatorLock.load(dto));
    const profileLock = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
    const adminProfileLock = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
    const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
    const newSecrets = hsc ? unlockLockProtectedSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock, ccs.profileRepo, hsc) : void 0;
    const stagedDiff = getStagedDiff(vault, vaultAccess, hsc, ccs.profileRepo, (_b2 = newSecrets === null || newSecrets === void 0 ? void 0 : newSecrets.protectedSecret) !== null && _b2 !== void 0 ? _b2 : null);
    const updatedVault = Vault.createFromCommits(vault.id, vault.type, vault.associatedVaultId, generationId, vault.userIds, vault.profileIds, vault.organizationId, authenticatorLocks, profileLock, adminProfileLock, vault.dirty, vaultSecret, commits, stagedDiff, ccs.profileRepo, vault.messagePublicKey, messages2, vault.inboxSlug);
    return { vault: updatedVault, newSecrets };
  }
  function getStagedDiff(currentVault, vaultAccess, hsc, profileRepo, newProtectedSecret) {
    var _a2, _b2, _c2;
    const stagedDiff = (_a2 = currentVault.getStagedDiff(null)) === null || _a2 === void 0 ? void 0 : _a2.diff;
    if (!stagedDiff) {
      return null;
    }
    if (!hsc || !newProtectedSecret) {
      throw new VaultIsLockedError();
    }
    const { protectedSecret: currentProtectedSecret } = unlockLockProtectedSecret(vaultAccess, currentVault.authenticatorLocks, currentVault.profileLock, currentVault.adminProfileLock, profileRepo, hsc);
    const { vault: reprotectedVault } = currentVault.withModification((c2, t) => {
      return {
        newVaultContent: modifyProtectedValues(c2, t, (pv) => {
          const unprotected = unprotectWithContentId(currentProtectedSecret, pv);
          const reprotected = protect(newProtectedSecret, unprotected);
          return reprotected;
        }),
        result: void 0
      };
    });
    return (_c2 = (_b2 = reprotectedVault.getStagedDiff(null)) === null || _b2 === void 0 ? void 0 : _b2.diff) !== null && _c2 !== void 0 ? _c2 : null;
  }
  function onlineInternalInitializeVault(ccs, syncUpdateVault, hsc) {
    var _a2;
    return __awaiter$I(this, void 0, void 0, function* () {
      const backendClient = getBackendClientForVault(ccs, syncUpdateVault);
      const vaultAccess = getVaultAccess(ccs, hsc, syncUpdateVault);
      if (!vaultAccess) {
        return {};
      }
      const { id: vaultId, vaultType, associatedVaultId, users, profiles, organizationId, dirty, messagePublicKey, inboxSlug } = syncUpdateVault;
      const { generationId, commitDtos, lockDtos, profileLockDto, adminProfileLockDto, messages: messages2 } = yield backendClient.vault.listCommits(vaultId, null, null, false);
      const commits = commitDtos.map((c2) => Commit.load(c2));
      const authenticatorLocks = (_a2 = lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.map((dto) => VaultAuthenticatorLock.load(dto))) !== null && _a2 !== void 0 ? _a2 : [];
      const profileLock = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
      const adminProfileLock = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
      const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
      const newSecrets = hsc && vaultAccess ? unlockLockProtectedSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock, ccs.profileRepo, hsc) : void 0;
      const userIds = users.map((u2) => u2.id);
      const profileIds = profiles.map((p2) => p2.id);
      const vault = Vault.createFromCommits(vaultId, vaultType, associatedVaultId, generationId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, vaultSecret, commits, null, ccs.profileRepo, messagePublicKey ? loadEncryptionPublicKey(messagePublicKey) : null, messages2, inboxSlug);
      return { vault, newSecrets, vaultAccess };
    });
  }
  function ensureVaultRepoConsistency(_a2) {
    var ccs = __rest$r(_a2, []);
    if (ccs.protectedSecretRepo && ccs.protectedSecretRepo.isUnlocked()) {
      for (const vault of ccs.vaultRepo.getAllVaults()) {
        if (!ccs.protectedSecretRepo.hasVault(vault.id)) {
          trackError({ message: "Vault was missing from protectedSecretRepo", vaultId: vault.id });
          ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
        }
      }
    }
    for (const vault of ccs.vaultRepo.getAllVaults()) {
      if (vault.type === VaultType.TEAM && (!vault.associatedVaultId || ccs.vaultRepo.getTeamMetaVaultById(vault.associatedVaultId) === null)) {
        trackError({ messsage: "Team vault is missing assosciated vault", vaultId: vault.id });
        ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
      }
    }
    return ccs;
  }
  function onlineInternalSyncAchievements(_a2, su) {
    var ccs = __rest$r(_a2, []);
    return __awaiter$I(this, void 0, void 0, function* () {
      const localAchievements = ccs.accountState.getLocalAchievements();
      if (localAchievements.length) {
        su = yield ccs.backendClient.account.addAchievements(localAchievements);
        ccs.accountState = ccs.accountState.withSyncUpdate(su);
      }
      return ccs;
    });
  }
  function onlineInternalSyncAuditlogEventQueue(_a2) {
    var _b2;
    var ccs = __rest$r(_a2, []);
    return __awaiter$I(this, void 0, void 0, function* () {
      const groupedEvents = groupBy(ccs.auditlogEventQueue, (e) => e.organizationId);
      ccs.auditlogEventQueue = [];
      let returnResult;
      for (const events of Object.values(groupedEvents)) {
        if (!events) {
          continue;
        }
        const orgId = events[0].organizationId;
        _b2 = yield onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, events), { returnResult } = _b2, ccs = __rest$r(_b2, ["returnResult"]);
        if (returnResult === AuditlogWriteResult.Retry) {
          ccs.auditlogEventQueue.push(...events);
        }
      }
      return ccs;
    });
  }
  var __awaiter$H = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$q = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalChildOrganizationAddManager(_a2, orgId, parentOrgProfileId) {
    var ccs = __rest$q(_a2, []);
    return __awaiter$H(this, void 0, void 0, function* () {
      const disabledOrgProfile = ccs.profileRepo.disabledProfiles.find((p2) => p2.organizationId === orgId);
      const fullSyncRequired = !!disabledOrgProfile;
      if (disabledOrgProfile) {
        ccs.ephemeralOperationState = {
          additionalEnabledProfileIds: [disabledOrgProfile.id]
        };
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc || !ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.organizations.find((o) => o.id === orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      const { adminInfo } = org;
      if (!adminInfo || !adminInfo.authenticator && !adminInfo.adminProfile) {
        throw new NoOrganizationAdminError();
      }
      const adminAuthenticator = adminInfo.authenticator ? [loadForeignAuthenticator(adminInfo.authenticator)] : [];
      const superUserVaultMemberIds = adminInfo.authenticator ? [org.superUserId] : [];
      const adminProfile = adminInfo.adminProfile ? loadForeignProfile(adminInfo.adminProfile) : null;
      const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
      const adminHsup = adminUp ? hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo) : void 0;
      const { users: [{ authenticators }] } = yield ccs.backendClient.account.list([], [], [parentOrgProfileId]);
      const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, orgId, authenticators.map(loadForeignAuthenticator));
      const personalVaultDto = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, superUserVaultMemberIds, [], adminAuthenticator, unsyncedProfile, adminProfile, orgId, organizationPersonalVaultContentDescriptor, null).getCreationDto();
      const adminProfileLock = adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(unsyncedProfile);
      let legacyAdminVaultLock;
      if (adminInfo.legacyAdminVaultId) {
        const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(adminInfo.legacyAdminVaultId);
        if (!legacyAdminVault) {
          throw new VaultNotFoundError(adminInfo.legacyAdminVaultId);
        }
        legacyAdminVaultLock = {
          generationId: legacyAdminVault.generationId,
          vaultId: legacyAdminVault.id,
          lock: serializeVaultProfileLock(ccs.protectedSecretRepo.createProfileLock(legacyAdminVault, unsyncedProfile))
        };
      }
      const { syncUpdate } = yield ccs.backendClient.childOrganization.addManager(orgId, parentOrgProfileId, {
        profile: unsyncedProfile.serialize(),
        personalVaultData: personalVaultDto,
        adminProfileLock,
        legacyAdminVaultLock
      });
      ccs.ephemeralOperationState = void 0;
      if (fullSyncRequired) {
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __rest$p = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function addUnsyncedVaultAfterCreate(_a2, syncUpdate, vaultId, associatedVaultId, organizationId, unsyncedVault) {
    var _b2, _c2, _d2, _e2, _f2;
    var ccs = __rest$p(_a2, []);
    const { generationId, commitId } = (_b2 = syncUpdate.vaults) === null || _b2 === void 0 ? void 0 : _b2.find((v2) => v2.id === vaultId);
    const vault = unsyncedVault.withIds(vaultId, generationId, commitId, associatedVaultId, organizationId);
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
    ccs.protectedSecretRepo = (_f2 = (_c2 = ccs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.withProtectedSecret(vault, unsyncedVault.protectedSecret, (_e2 = (_d2 = unsyncedVault.messageKeyPair) === null || _d2 === void 0 ? void 0 : _d2.encPrivKey) !== null && _e2 !== void 0 ? _e2 : null)) !== null && _f2 !== void 0 ? _f2 : null;
    return ccs;
  }
  var __awaiter$G = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalMakeUnsyncedTeamVaults(ccs, name, organizationId, profile, isSyncOrganizationMembers, inbox, vaultType = VaultType.TEAM, metaVaultType = VaultType.TEAM_META) {
    return __awaiter$G(this, void 0, void 0, function* () {
      const profileIds = !(profile instanceof UnsyncedProfile) ? [profile.id] : [];
      let userIds;
      let adminProfile;
      let authenticators;
      if (organizationId) {
        const org = ccs.accountState.organizations.find((o) => o.id === organizationId);
        if (!org) {
          throw new OrganizationNotFoundError();
        }
        if (org.adminProfileId) {
          const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], [org.adminProfileId], []);
          adminProfile = profilesById[org.adminProfileId];
          authenticators = [];
          userIds = [];
        } else {
          const { authenticatorsByUser } = yield onlineInternalGetUsers(ccs.backendClient, [org.superUserId], [], []);
          adminProfile = null;
          authenticators = authenticatorsByUser[org.superUserId];
          userIds = [org.superUserId];
        }
      } else {
        adminProfile = null;
        authenticators = [];
        userIds = [];
      }
      const unsyncedTeamVault = UnsyncedVault.create(vaultType, userIds, profileIds, authenticators, profile, adminProfile, organizationId !== null && organizationId !== void 0 ? organizationId : null, loginVaultContentDescriptor, inbox !== null && inbox !== void 0 ? inbox : null);
      const unsyncedTeamMetaVault = UnsyncedVault.create(metaVaultType, userIds, profileIds, authenticators, profile, adminProfile, organizationId !== null && organizationId !== void 0 ? organizationId : null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification(profileIds, name, isSyncOrganizationMembers));
      return { unsyncedTeamVault, unsyncedTeamMetaVault };
    });
  }
  function getInitialMetaContentModification(adminIds, name, isSyncOrganizationMembers) {
    return (c2, t, { modifyTeamVaultInfo: modifyTeamVaultInfo2, addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => {
      let newVaultContent = c2;
      ({ newVaultContent } = modifyTeamVaultInfo2(newVaultContent, t, {
        name,
        // Note: There's currently no exposed api for changing this setting. We used to force it to
        // true via the web app, but will probably implement a UI for it in the future.
        hideSecretsForRestrictedUsers: true,
        isSyncOrganizationMembers
      }));
      for (const adminId of adminIds) {
        ({ newVaultContent } = addOrModifyTeamVaultUser2(newVaultContent, t, adminId, {
          permissionLevel: PermissionLevel.admin
        }));
      }
      return { newVaultContent, result: void 0 };
    };
  }
  var __awaiter$F = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$o = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalInboxVaultCreate(_a2, slug, metadata, organizationId) {
    var _b2, _c2;
    var ccs = __rest$o(_a2, []);
    return __awaiter$F(this, void 0, void 0, function* () {
      const metadataJson = jsonStringifyFreeze(metadata);
      const profile = (_b2 = ccs.profileRepo.getOrganizationProfile(organizationId)) === null || _b2 === void 0 ? void 0 : _b2.profile;
      if (!profile) {
        throw new OrganizationNotFoundError();
      }
      const { unsyncedTeamVault: unsyncedInboxVault, unsyncedTeamMetaVault } = yield onlineInternalMakeUnsyncedTeamVaults(ccs, "Inbox", organizationId, profile, false, { slug, metadata }, VaultType.INBOX, VaultType.INBOX_META);
      const { vaultId: inboxVaultId, associatedVaultId: teamMetaVaultId, syncUpdate } = yield ccs.backendClient.vault.createInboxVault({
        blob: unsyncedInboxVault.getCommitBlob(),
        locks: unsyncedInboxVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedInboxVault.getProfileLockDto(),
        adminProfileLock: unsyncedInboxVault.getAdminProfileLockDto(),
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto(),
        organizationId,
        messagePublicKey: (_c2 = unsyncedInboxVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey
      }, slug, metadataJson);
      ccs = addUnsyncedVaultAfterCreate(ccs, syncUpdate, inboxVaultId, teamMetaVaultId, organizationId !== null && organizationId !== void 0 ? organizationId : null, unsyncedInboxVault);
      ccs = addUnsyncedVaultAfterCreate(
        ccs,
        syncUpdate,
        // if we pass in an unsynced associated vault, we're also going to get back an id for it
        teamMetaVaultId,
        null,
        organizationId !== null && organizationId !== void 0 ? organizationId : null,
        unsyncedTeamMetaVault
      );
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      return Object.assign(Object.assign({}, ccs), { returnResult: inboxVaultId });
    });
  }
  var __awaiter$E = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$n = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalInboxVaultDelete(_a2, vaultId) {
    var ccs = __rest$n(_a2, []);
    return __awaiter$E(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getInboxVaultPairById(vaultId);
      if (!pair) {
        throw new VaultNotFoundError(vaultId);
      }
      if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== PermissionLevel.admin) {
        throw new VaultPermissionDeniedError();
      }
      const syncUpdate = yield ccs.backendClient.vault.deleteInboxVault(vaultId);
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      return Object.assign({}, ccs);
    });
  }
  const ALL_LOGIN_VAULT_PERMISSIONS = {
    viewSecrets: true,
    createLogins: true,
    deleteLogins: true,
    editLogins: true,
    useLogins: true,
    viewHistory: true
  };
  function getLoginVaultMetadata({ accountState, profileRepo }, vaultPair) {
    switch (vaultPair.type) {
      case VaultType.PRIVATE:
        return getPrivateVaultMetadata(vaultPair.login);
      case VaultType.ORGANIZATION_PERSONAL:
        return getPersonalVaultMetadata({ accountState, profileRepo }, vaultPair.login);
      case VaultType.TEAM:
        return getTeamVaultPairMetadata({ accountState, profileRepo }, vaultPair);
      case VaultType.INBOX:
        return getInboxVaultPairMetadata(vaultPair);
      default:
        throw new UnsupportedLoginVaultTypeError();
    }
  }
  function assertVaultType(vault, type) {
    if (vault.type != type) {
      throw new IncorrectVaultTypeError(vault.id, type, vault.type);
    }
  }
  function getPrivateVaultMetadata(vault) {
    var _a2;
    assertVaultType(vault, VaultType.PRIVATE);
    return {
      id: vault.id,
      profileId: (_a2 = vault.getProfileId()) !== null && _a2 !== void 0 ? _a2 : void 0,
      type: VaultType.PRIVATE,
      permissions: ALL_LOGIN_VAULT_PERMISSIONS,
      path: "/logins"
    };
  }
  function getPersonalVaultMetadata({ accountState, profileRepo }, vault) {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    assertVaultType(vault, VaultType.ORGANIZATION_PERSONAL);
    const org = vault.organizationId && accountState.getOrganization(vault.organizationId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    const orgProfile = (_a2 = profileRepo.getOrganizationProfile(vault.organizationId)) === null || _a2 === void 0 ? void 0 : _a2.profile;
    if (orgProfile && vault.profileIds.includes(orgProfile.id)) {
      return {
        id: vault.id,
        profileId: (_b2 = vault.getProfileId()) !== null && _b2 !== void 0 ? _b2 : void 0,
        permissions: ALL_LOGIN_VAULT_PERMISSIONS,
        type: VaultType.ORGANIZATION_PERSONAL,
        owner: {
          profileId: orgProfile.id,
          isLoggedInUser: true,
          email: (_c2 = orgProfile.email) !== null && _c2 !== void 0 ? _c2 : void 0
        },
        organizationId: vault.organizationId,
        path: `/organizations/${vault.organizationId}/logins`
      };
    }
    if (vault.profileIds.length) {
      const ownerProfileId = vault.profileIds.find((pId) => {
        var _a3;
        return pId !== ((_a3 = vault.adminProfileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId);
      });
      if (!ownerProfileId) {
        throw new Error("organization personal vault without an owner, this should never happen");
      }
      const ownerProfile = (_d2 = accountState.getOrganization(vault.organizationId)) === null || _d2 === void 0 ? void 0 : _d2.profiles.find((p2) => p2.profileId === ownerProfileId);
      if (!ownerProfile) {
        throw new Error("owner profile not found in organization");
      }
      const ownerEmail = (_f2 = (_e2 = accountState.relatedProfiles[ownerProfileId]) === null || _e2 === void 0 ? void 0 : _e2.email) !== null && _f2 !== void 0 ? _f2 : void 0;
      return {
        id: vault.id,
        profileId: (_g2 = vault.getProfileId()) !== null && _g2 !== void 0 ? _g2 : void 0,
        name: (_h2 = accountState.getProfileEmail(ownerProfileId)) !== null && _h2 !== void 0 ? _h2 : void 0,
        permissions: {
          viewSecrets: false,
          createLogins: true,
          editLogins: false,
          deleteLogins: false,
          useLogins: false,
          viewHistory: false
        },
        type: VaultType.ORGANIZATION_PERSONAL,
        owner: {
          profileId: ownerProfileId,
          isLoggedInUser: false,
          email: ownerEmail
        },
        organizationId: vault.organizationId,
        path: `/organizations/${vault.organizationId}/members/profiles/${ownerProfileId}/logins`
      };
    }
    throw new Error("organization personal vault without an owner, this should never happen");
  }
  function getTeamVaultPairMetadata({ accountState, profileRepo }, { login, meta }) {
    var _a2;
    const org = login.organizationId && accountState.getOrganization(login.organizationId);
    assertVaultType(login, VaultType.TEAM);
    const loggedInProfile = org ? profileRepo.getOrganizationProfile(org.id) : profileRepo.getPrivateProfile();
    if (!loggedInProfile) {
      throw new Error("getTeamVaultPairMetadata on a vault outside a known org or private profile");
    }
    const metaContent = meta.getContent();
    const metaInfo = getTeamMetaVaultInfo(metaContent);
    const permissionLevel = getPermissionLevel(metaContent, loggedInProfile.profile.id);
    const newlyJoinedInfo = getNewlyJoinedInfo(metaContent, loggedInProfile.profile.id);
    const hideSecretsForRestrictedUsers = !!metaInfo.hideSecretsForRestrictedUsers;
    return {
      id: login.id,
      profileId: (_a2 = login.getProfileId()) !== null && _a2 !== void 0 ? _a2 : void 0,
      type: VaultType.TEAM,
      name: metaInfo.name,
      isSyncOrganizationMembers: !!metaInfo.isSyncOrganizationMembers,
      isUserJoined: login.isUserJoined,
      newlyJoinedInfo,
      permissions: {
        viewSecrets: !(permissionLevel === PermissionLevel.restricted && hideSecretsForRestrictedUsers),
        createLogins: permissionLevel !== PermissionLevel.restricted,
        editLogins: permissionLevel !== PermissionLevel.restricted,
        deleteLogins: permissionLevel !== PermissionLevel.restricted,
        useLogins: login.isUserJoined,
        viewHistory: permissionLevel === PermissionLevel.admin
      },
      organizationId: login.organizationId,
      path: org ? `/organizations/${org.id}/teams/${login.id}` : `/teams/${login.id}`,
      icon: metaInfo.icon,
      hideSecretsForRestrictedUsers
    };
  }
  function getInboxVaultPairMetadata({ login }) {
    var _a2;
    assertVaultType(login, VaultType.INBOX);
    const path = login.organizationId ? `/organizations/${login.organizationId}/inboxes/${login.id}` : `/inboxes/${login.id}`;
    return {
      type: VaultType.INBOX,
      permissions: {
        viewSecrets: true,
        createLogins: false,
        editLogins: true,
        deleteLogins: true,
        useLogins: true,
        viewHistory: true
      },
      id: login.id,
      profileId: (_a2 = login.getProfileId()) !== null && _a2 !== void 0 ? _a2 : void 0,
      path,
      slug: login.inboxSlug,
      organizationId: login.organizationId
    };
  }
  function encodeBase64Urlsafe(data) {
    return naclUtilExports.encodeBase64(data instanceof Uint8Array ? data : new Uint8Array(data)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  function decodeBase64Urlsafe(data) {
    const substituted = data.replace(/_/g, "/").replace(/-/g, "+");
    const padLength = (4 - substituted.length % 4) % 4;
    const padded = substituted.padEnd(substituted.length + padLength, "=");
    return naclUtilExports.decodeBase64(padded);
  }
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function encryptShareLinkLogin(login) {
    const strippedLogin = {
      customFields: login.customFields,
      note: login.note,
      password: login.password,
      title: login.title,
      uiType: login.uiType,
      username: login.username,
      websites: login.websites,
      androidApps: login.androidApps,
      creditCard: login.creditCard,
      totp: login.totp,
      websiteAttributes: login.websiteAttributes,
      // NOTE: the following fields are explicitly redacted
      creationTime: "1970-01-01T00:00:00.000Z",
      editTime: "1970-01-01T00:00:00.000Z",
      changeTime: "1970-01-01T00:00:00.000Z"
    };
    const protectedSecret = newSymmetricSecret();
    const protectedLogin = recursivelyTransformUnprotectedValues(strippedLogin, (pv) => protect(protectedSecret, pv));
    const loginJson = jsonStringifyFreeze(protectedLogin);
    const secret = newSymmetricSecret();
    const encryptedPayload = symEncrypt(secret, naclUtilExports.decodeUTF8(loginJson));
    const encryptedProtectedSecret = symEncryptSymmetricEncryptionKey(secret, protectedSecret);
    const secretBase64 = encodeBase64Urlsafe(secret);
    return { encryptedPayload, secretBase64, encryptedProtectedSecret };
  }
  const UNIURI_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  function newUniURI() {
    const seed = [...randomSeed().subarray(0, 16)];
    return seed.map((b) => UNIURI_ALPHABET.charAt(b % UNIURI_ALPHABET.length)).join("");
  }
  var __awaiter$D = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$m = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalLoginShareLinkCreate$1(_a2, vaultId, loginId) {
    var ccs = __rest$m(_a2, []);
    return __awaiter$D(this, void 0, void 0, function* () {
      if (!ccs.protectedSecretRepo) {
        throw new VaultIsLockedError();
      }
      const vaultPair = ccs.vaultRepo.getLoginVaultPairById(vaultId);
      if (!vaultPair) {
        throw new VaultNotFoundError(vaultId);
      }
      const { permissions } = getLoginVaultMetadata(ccs, vaultPair);
      if (!permissions.editLogins || !permissions.viewSecrets) {
        throw new VaultPermissionDeniedError();
      }
      let modifiedVault = vaultPair.login;
      const protectedLogin = modifiedVault.getContent().logins[loginId];
      if (!protectedLogin) {
        throw new LoginNotFoundError(loginId);
      }
      const { unprotectWithContentId: unprotectWithContentId2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(modifiedVault);
      const login = recursivelyTransformProtectedValues(protectedLogin, unprotectWithContentId2);
      const { encryptedPayload, secretBase64, encryptedProtectedSecret } = encryptShareLinkLogin(login);
      const shareLinkId = newUniURI();
      modifiedVault = modifiedVault.withAddShareLinkUpdate({
        id: shareLinkId,
        encryptedPayload,
        encryptedProtectedSecret
      });
      ccs = modifyLoginVault(ccs, modifiedVault, (c2, t, { modifyLoginInternal: modifyLoginInternal2, protect: protect2 }) => {
        var _a3;
        const result2 = modifyLoginInternal2(c2, t, loginId, {
          shareLinks: [
            ...(_a3 = protectedLogin.shareLinks) !== null && _a3 !== void 0 ? _a3 : [],
            {
              id: shareLinkId,
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              secret: protect2({ contentId: newUuid$1(), unencrypted: secretBase64 })
            }
          ]
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [
          {
            type: AuditlogEventType.LOGIN_SHARE_LINK_CREATE,
            loginId,
            vaultId
          }
        ] });
      });
      ccs = Object.assign(Object.assign({}, ccs), { accountState: ccs.accountState.withLocalAchievements([Achievement.WEB_LOGIN_CREATE_SHARE_LINK]) });
      ccs = yield onlineInternalSync(ccs);
      return Object.assign(Object.assign({}, ccs), { returnResult: { shareLinkId, secretBase64 } });
    });
  }
  var __awaiter$C = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$l = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalLoginShareLinkCreate(_a2, vaultId, loginId, shareLinkId) {
    var _b2;
    var ccs = __rest$l(_a2, []);
    return __awaiter$C(this, void 0, void 0, function* () {
      const vaultPair = ccs.vaultRepo.getLoginVaultPairById(vaultId);
      if (!vaultPair) {
        throw new VaultNotFoundError(vaultId);
      }
      const { permissions } = getLoginVaultMetadata(ccs, vaultPair);
      if (!permissions.editLogins || !permissions.viewSecrets) {
        throw new VaultPermissionDeniedError();
      }
      const vault = vaultPair.login;
      const protectedLogin = vault.getContent().logins[loginId];
      if (!protectedLogin) {
        throw new LoginNotFoundError(loginId);
      }
      if (!ccs.protectedSecretRepo) {
        throw new VaultIsLockedError();
      }
      if (!((_b2 = protectedLogin.shareLinks) === null || _b2 === void 0 ? void 0 : _b2.some((sl) => sl.id === shareLinkId))) {
        throw new ShareLinkNotFoundError(shareLinkId);
      }
      ccs = modifyLoginVault(ccs, vault, (c2, t, { modifyLoginInternal: modifyLoginInternal2 }) => {
        var _a3;
        const result2 = modifyLoginInternal2(c2, t, loginId, {
          shareLinks: (_a3 = protectedLogin.shareLinks) === null || _a3 === void 0 ? void 0 : _a3.filter((sl) => sl.id !== shareLinkId)
        });
        return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
      });
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$B = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$k = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalOrganizationRegenerateProfiles(inputCcs, orgId, profiles) {
    return __awaiter$B(this, void 0, void 0, function* () {
      const profileIds = profiles.map((p2) => p2.profileId);
      return performWithPersonalVaultsSyncPredicate(inputCcs, profileIds, (_a2, hsc) => __awaiter$B(this, void 0, void 0, function* () {
        var ccs = __rest$k(_a2, []);
        const org = ccs.accountState.getOrganization(orgId);
        if (!org) {
          throw new OrganizationNotFoundError();
        }
        if (!org.isAdmin) {
          throw new NoOrganizationAdminError();
        }
        const { vaultRepo, protectedSecretRepo } = ccs;
        if (!protectedSecretRepo) {
          throw new ClientCoreIsLockedError();
        }
        const userIds = profiles.flatMap((p2) => p2.userId ? p2.userId : []);
        const { authenticatorsByUser } = yield onlineInternalGetUsers(ccs.backendClient, userIds, [], []);
        const orgAdminProfile = ccs.profileRepo.getOrgAdminProfile(orgId);
        const returnResult = {};
        for (const { profileId, userId } of profiles) {
          const orgProfile = org === null || org === void 0 ? void 0 : org.profiles.find((p2) => p2.profileId === profileId);
          if (!org || !orgProfile) {
            throw new Error("Profile organization not found");
          }
          const unsynced = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION, org.id, userId ? authenticatorsByUser[userId] : [], []);
          const vaultLocks = vaultRepo.getAllVaultsByProfileId(profileId).map((v2) => ({
            vaultId: v2.id,
            generationId: v2.generationId,
            lock: protectedSecretRepo.createProfileLock(v2, unsynced.unsyncedProfile)
          }));
          const downstreamProfileLocks = orgProfile.isAdmin && orgAdminProfile ? [
            hsc.getHighSecurityUnlockedProfile(orgAdminProfile, ccs.profileRepo).createProfileLock(unsynced.unsyncedProfile)
          ] : [];
          const regProfile = {
            profile: unsynced.unsyncedProfile.serialize(profileId),
            vaultLocks,
            downstreamProfileLocks
          };
          yield ccs.backendClient.organization.regenerateUser(orgId, userId, regProfile);
          returnResult[profileId] = unsynced;
        }
        return Object.assign(Object.assign({}, ccs), { returnResult });
      }));
    });
  }
  function performWithPersonalVaultsSyncPredicate(ccs, profileIds, operation) {
    var _a2;
    return __awaiter$B(this, void 0, void 0, function* () {
      const originalForeignVaultSyncPredicate = ccs.ephemeralForeignVaultSyncPredicate;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { profileAllVaults: [
        ...(_a2 = ccs.ephemeralForeignVaultSyncPredicate.profileAllVaults) !== null && _a2 !== void 0 ? _a2 : [],
        ...profileIds
      ] });
      const originalBackendClient = ccs.backendClient;
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc) {
        throw new ClientCoreIsLockedError();
      }
      const _b2 = yield operation(ccs, hsc), { returnResult } = _b2, newCcs = __rest$k(_b2, ["returnResult"]);
      ccs = newCcs;
      ccs.syncVersion = null;
      ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
      ccs.ephemeralForeignVaultSyncPredicate = originalForeignVaultSyncPredicate;
      ccs = yield onlineInternalSync(ccs);
      return Object.assign(Object.assign({}, ccs), { returnResult });
    });
  }
  var __awaiter$A = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$j = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineMaintainOrganizationPreliminaryProfiles(_a2) {
    var _b2;
    var ccs = __rest$j(_a2, []);
    return __awaiter$A(this, void 0, void 0, function* () {
      const task = MaintenanceTask.ORGANIZATION_PRELIMINARY_PROFILES_V3;
      if (!((_b2 = ccs.maintenanceSettings) === null || _b2 === void 0 ? void 0 : _b2.allowedTasks.includes(task))) {
        return ccs;
      }
      const registeredFreeProfiles = getOrganizationsProfilesWithPreliminaryUserId(ccs.accountState.organizations, ccs.profileRepo);
      for (const { organization, profiles } of registeredFreeProfiles) {
        ccs = yield onlineInternalOrganizationRegenerateProfiles(ccs, organization.id, profiles.map(({ profileId, preliminaryUserId }) => ({
          profileId,
          userId: preliminaryUserId
        })));
      }
      return ccs;
    });
  }
  function getOrganizationsProfilesWithPreliminaryUserId(organizations, profileRepo) {
    return organizations.filter((org) => org.isAdmin && !!org.adminInfo).filter((org) => !!profileRepo.getOrganizationProfile(org.id)).flatMap((organization) => {
      const profiles = organization.profiles.filter((p2) => !!p2.preliminaryUserId);
      return profiles.length ? { organization, profiles } : [];
    });
  }
  function normalizeEmailAddress(email) {
    return email.trim().toLowerCase();
  }
  var __awaiter$z = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalTeamModifyUsers(ccs, teamId, { profileIdsToRemove, usersToAdd, skipInvite }) {
    return __awaiter$z(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
      if (!pair) {
        throw new VaultNotFoundError(teamId);
      }
      let { login: loginVault, meta: metaVault } = pair;
      const backendClient = getBackendClientForVault(ccs, loginVault);
      const normalizedUsersToAdd = usersToAdd === null || usersToAdd === void 0 ? void 0 : usersToAdd.map((u2) => u2.by === "email" ? Object.assign(Object.assign({}, u2), { email: normalizeEmailAddress(u2.email) }) : u2);
      if (
        // only admins can perform user operations
        getLoggedInUserTeamPermissionLevel(ccs.accountState, metaVault) !== PermissionLevel.admin
      ) {
        throw new VaultPermissionDeniedError();
      }
      const { addProfileOps } = normalizedUsersToAdd ? yield onlineCreateAddUserOps(ccs, loginVault, metaVault, normalizedUsersToAdd) : { addProfileOps: [] };
      const commitData = getUpdatedMetaVault$1(ccs, metaVault, addProfileOps, profileIdsToRemove, skipInvite);
      const { syncUpdate } = yield backendClient.vault.modifyTeamUsers(teamId, loginVault.generationId, addProfileOps, profileIdsToRemove !== null && profileIdsToRemove !== void 0 ? profileIdsToRemove : [], metaVault.generationId, commitData === null || commitData === void 0 ? void 0 : commitData.metaVaultCommitId, commitData === null || commitData === void 0 ? void 0 : commitData.blob, commitData === null || commitData === void 0 ? void 0 : commitData.latestUpdateTime);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function onlineCreateAddUserOps({ backendClient, protectedSecretRepo }, loginVault, metaVault, normalizedUsersToAdd) {
    var _a2, _b2;
    return __awaiter$z(this, void 0, void 0, function* () {
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const { index, profilesById } = yield onlineInternalGetUsers(backendClient, [], normalizedUsersToAdd.flatMap((u2) => u2.by === "profile" ? u2.profileId : []), normalizedUsersToAdd.flatMap((u2) => u2.by === "email" ? u2.email : []), (_a2 = loginVault.organizationId) !== null && _a2 !== void 0 ? _a2 : void 0);
      const addProfileOps = [];
      for (const { profileId, email } of index) {
        const userToAdd = (_b2 = normalizedUsersToAdd.find((u2) => u2.by === "profile" && u2.profileId === profileId)) !== null && _b2 !== void 0 ? _b2 : normalizedUsersToAdd.find((u2) => u2.by === "email" && u2.email === email);
        if (!userToAdd) {
          continue;
        }
        const { permissionLevel } = userToAdd;
        if (profileId) {
          const p2 = profilesById[profileId];
          const lock = serializeVaultProfileLock(protectedSecretRepo.createProfileLock(loginVault, p2));
          const associatedLock = serializeVaultProfileLock(protectedSecretRepo.createProfileLock(metaVault, p2));
          addProfileOps.push({
            id: profileId,
            email: email !== null && email !== void 0 ? email : void 0,
            lock,
            associatedLock,
            permissionLevel
          });
        }
      }
      return { addProfileOps };
    });
  }
  function getUpdatedMetaVault$1(ccs, metaVault, addedProfiles, removeProfileIds, skipMarkNewlyJoined) {
    var _a2;
    const relevantProfileId = metaVault.getProfileId();
    const relevantEmail = relevantProfileId ? (_a2 = ccs.profileRepo.getUnlocked(relevantProfileId)) === null || _a2 === void 0 ? void 0 : _a2.profile.email : ccs.accountState.getPrimaryEmail();
    ({ vault: metaVault } = metaVault.withModification((initialVaultContent, t, ops) => {
      let newVaultContent = initialVaultContent;
      const org = metaVault.organizationId ? ccs.accountState.getOrganization(metaVault.organizationId) : void 0;
      if (addedProfiles) {
        newVaultContent = addedProfiles.reduce((c2, addedProfile) => {
          var _a3, _b2, _c2;
          const isNotConnected = (_b2 = (_a3 = org === null || org === void 0 ? void 0 : org.profiles.find((p2) => p2.profileId === addedProfile.id)) === null || _a3 === void 0 ? void 0 : _a3.isNotConnected) !== null && _b2 !== void 0 ? _b2 : false;
          return ops.addOrModifyTeamVaultUser(c2, t, addedProfile.id, {
            newlyJoined: skipMarkNewlyJoined || isNotConnected ? void 0 : {
              // Only filled in for compatibility with older clients that require this field to be
              // set
              addedByUserId: nullUuid,
              addedByEmail: relevantEmail !== null && relevantEmail !== void 0 ? relevantEmail : ""
            },
            permissionLevel: (_c2 = addedProfile.permissionLevel) !== null && _c2 !== void 0 ? _c2 : TEAM_USER_DEFAULT_PERMISSION_LEVEL
          }).newVaultContent;
        }, newVaultContent);
      }
      if (removeProfileIds) {
        newVaultContent = removeProfileIds.reduce((c2, userId) => {
          return ops.deleteTeamVaultUser(c2, t, userId).newVaultContent;
        }, newVaultContent);
      }
      return { newVaultContent, result: void 0 };
    }));
    const stagedData = metaVault.getStagedDiff(null);
    if (!stagedData) {
      return null;
    }
    const { stagingVault, diff, latestUpdateTime } = stagedData;
    const protoCommit = Commit.create(null, stagingVault.vaultSecret, diff);
    return {
      metaVaultCommitId: metaVault.commitId,
      blob: protoCommit.blob,
      latestUpdateTime: new Date(latestUpdateTime)
    };
  }
  var __awaiter$y = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$i = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalMaintainTeamSyncOrganizationMembers(_a2, skipInvite) {
    var _b2;
    var ccs = __rest$i(_a2, []);
    return __awaiter$y(this, void 0, void 0, function* () {
      const task = MaintenanceTask.TEAM_SYNC_ORGANIZATION_MEMBERS_V2;
      if (!((_b2 = ccs.maintenanceSettings) === null || _b2 === void 0 ? void 0 : _b2.allowedTasks.includes(task))) {
        return ccs;
      }
      const teamsToChange = getTeamsWithSyncOrganizationMembersAndMismatchedUsers(ccs.vaultRepo, ccs.accountState);
      if (!teamsToChange.length) {
        return ccs;
      }
      for (const { teamId, details } of teamsToChange) {
        const { profileIdsToAdd, profileIdsToRemove, profilesToUpdate } = details;
        if (profileIdsToAdd.length || profileIdsToRemove.length) {
          ccs = yield onlineInternalTeamModifyUsers(ccs, teamId, {
            usersToAdd: profileIdsToAdd.map((profileId) => {
              return {
                by: "profile",
                profileId,
                permissionLevel: void 0
              };
            }),
            profileIdsToRemove,
            skipInvite
          });
        }
        if (profilesToUpdate.length) {
          ccs = internalTeamSetUserPermissionLevels(ccs, teamId, ...profilesToUpdate.map(({ profileId, isAdmin }) => ({
            profileId,
            permissionLevel: deriveTeamPermissionLevelFromOrgIsAdmin(isAdmin)
          })));
          ccs = yield onlineInternalSync(ccs);
        }
      }
      return ccs;
    });
  }
  function getTeamsWithSyncOrganizationMembersAndMismatchedUsers(vaultRepo, accountState) {
    return vaultRepo.getTeamVaultPairs().map(({ login, meta }) => {
      if (!login.organizationId || getLoggedInUserTeamPermissionLevel(accountState, meta) !== PermissionLevel.admin || !getTeamMetaVaultInfo(meta.getContent()).isSyncOrganizationMembers) {
        return null;
      }
      const organization = accountState.getOrganization(login.organizationId);
      if (!organization) {
        return null;
      }
      const adminProfileIds = organization.adminProfileId ? [organization.adminProfileId] : [];
      const organizationProfileIds = /* @__PURE__ */ new Set([
        ...adminProfileIds,
        ...organization.profiles.flatMap(({ profileId, isService }) => isService ? [] : profileId)
      ]);
      const currentUserProfileId = login.getProfileId();
      if (currentUserProfileId) {
        organizationProfileIds.add(currentUserProfileId);
      }
      const teamProfileIds = new Set(login.profileIds);
      const profileIdsToAdd = setDifference(organizationProfileIds, teamProfileIds);
      const profileIdsToRemove = setDifference(teamProfileIds, organizationProfileIds);
      const profilesToUpdate = organization.profiles.filter(({ profileId, isAdmin }) => teamProfileIds.has(profileId) && !orgIsAdminMatchesTeamPermissionLevel(isAdmin, getPermissionLevel(meta.getContent(), profileId)));
      return {
        teamId: login.id,
        details: {
          profileIdsToAdd,
          profileIdsToRemove,
          profilesToUpdate
        }
      };
    }).filter((teamResult) => !!teamResult && Object.values(teamResult.details).some((val) => val.length));
  }
  function orgIsAdminMatchesTeamPermissionLevel(isAdmin, permissionLevel) {
    if (isAdmin) {
      return permissionLevel === PermissionLevel.admin;
    }
    return permissionLevel !== PermissionLevel.admin;
  }
  function deriveTeamPermissionLevelFromOrgIsAdmin(isAdmin) {
    return isAdmin ? PermissionLevel.admin : TEAM_USER_DEFAULT_PERMISSION_LEVEL;
  }
  function setDifference(a2, b) {
    return [...a2].filter((x2) => !b.has(x2));
  }
  var __awaiter$x = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$h = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalMaintainVaultMessages(_a2) {
    var ccs = __rest$h(_a2, []);
    return __awaiter$x(this, void 0, void 0, function* () {
      if (!ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const protectedSecretRepo = ccs.protectedSecretRepo;
      const vaultsWithMessages = ccs.vaultRepo.getAllVaults().filter((v2) => !!v2.messageQueue.length);
      const updates = vaultsWithMessages.map((vault) => {
        const { protect: protect2, decryptVaultMessage } = protectedSecretRepo.getProtectedSecretFunctions(vault);
        if (!decryptVaultMessage) {
          throw new Error("cannot decrypt inbox vault");
        }
        return processVaultMessages(vault, decryptVaultMessage, protect2);
      });
      const updatedVaultPromises = updates.map(({ vault, processedMessageIds }) => __awaiter$x(this, void 0, void 0, function* () {
        const stagedDiff = vault.getStagedDiff(null);
        if (!stagedDiff) {
          return;
        }
        const { diff, latestUpdateTime, stagingVault } = stagedDiff;
        const protoCommit = Commit.create(null, vault.vaultSecret, diff);
        const backendClient = getBackendClientForVault(ccs, vault);
        const { commitId } = yield backendClient.vault.createCommit(vault.id, vault.commitId, protoCommit.blob, new Date(latestUpdateTime), processedMessageIds);
        const filteredMessages = stagingVault.messageQueue.filter((m2) => !processedMessageIds.includes(m2.id));
        return stagingVault.withCommitId(commitId).withMessageQueue(filteredMessages);
      }));
      const updateResults = yield Promise.allSettled(updatedVaultPromises);
      const updatedVaults = updateResults.flatMap((result2) => {
        if (result2.status == "rejected") {
          if (result2.reason instanceof DomainError$1) {
            if (result2.reason.code === BackendErrorCode.VAULT_OUT_OF_SYNC) {
              return [];
            }
            if (result2.reason.code === BackendErrorCode.VAULT_DIRTY) {
              return [];
            }
          }
          trackError(result2.reason);
          return [];
        }
        if (result2.value) {
          return [result2.value];
        }
        return [];
      });
      const updatedVaultRepo = updatedVaults.length ? ccs.vaultRepo.withUpdateVaults(...updatedVaults) : ccs.vaultRepo;
      return Object.assign(Object.assign({}, ccs), { vaultRepo: updatedVaultRepo });
    });
  }
  function hasProcessableVaultMessages(vaultRepo) {
    return vaultRepo.getAllVaults().flatMap((v2) => v2.messageQueue).some((m2) => KNOWN_VAULT_MESSAGE_TYPES.includes(m2.type));
  }
  var __awaiter$w = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$g = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalMigrateToAuthenticatorChain(_a2, hsc) {
    var ccs = __rest$g(_a2, []);
    return __awaiter$w(this, void 0, void 0, function* () {
      const authenticatorKeys = ccs.accountState.authenticators.map((a2) => a2.highSecurityIdentitySigPubKey);
      const authenticatorBlock = AuthenticatorBlock.create(hsc.getHighSecurityUnlockedAuthenticator().highSecurityIdentitySigPrivKey, authenticatorKeys);
      try {
        const syncUpdate = yield ccs.backendClient.authenticator.createInitialAuthenticatorBlock(authenticatorBlock);
        return yield onlineInternalSync(ccs, syncUpdate);
      } catch (e) {
        if (e instanceof BackendDomainError && e.code === BackendErrorCode.AUTHENTICATOR_BLOCK_EXISTS) {
          return ccs;
        }
        throw e;
      }
    });
  }
  function regenerateProfiles(hsc, protectedSecretRepo, vaultRepo, profileRepo, authenticators, newAuthenticators) {
    const unsyncedProfiles = profileRepo.profiles.map(({ profile }) => ({
      profile,
      unsynced: UnsyncedProfile.create(profile.profileType, profile.organizationId, authenticators)
    }));
    const regeneratedProfiles = unsyncedProfiles.map(({ profile, unsynced }) => {
      const vaultLocks = vaultRepo.getAllVaults().filter((v2) => v2.profileIds.includes(profile.id)).map((v2) => ({
        vaultId: v2.id,
        generationId: v2.generationId,
        lock: protectedSecretRepo.createProfileLock(v2, unsynced)
      }));
      const downstreamProfileLocks = profileRepo.getAllProfilesByLockingProfileId(profile.id).map((p2) => {
        const hsup = hsc.getHighSecurityUnlockedProfile(p2, profileRepo);
        return hsup.createProfileLock(unsynced);
      });
      return {
        profile: unsynced.serialize(profile.id, profile.keyGenerationId),
        vaultLocks,
        downstreamProfileLocks
      };
    });
    const authenticatorCreationDtos = newAuthenticators.map((ua) => ua.serializeWithLocks(unsyncedProfiles.map(({ profile, unsynced }) => Object.assign(Object.assign({}, unsynced.createExtraLock(ua)), { profileId: profile.id, profileKeyGenerationId: nullUuid }))));
    return { regeneratedProfiles, authenticatorCreationDtos };
  }
  var __awaiter$v = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$f = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalModifyAuthenticators(inputCcs, hsc, deleteAuthenticatorIds, newAuthenticators = []) {
    return __awaiter$v(this, void 0, void 0, function* () {
      return performWithSyncSuperUsers(inputCcs, hsc, (_a2) => __awaiter$v(this, void 0, void 0, function* () {
        var ccs = __rest$f(_a2, []);
        let { protectedSecretRepo } = ccs;
        if (!protectedSecretRepo) {
          protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, null);
        }
        const isRemovingLocalAuthenticator = deleteAuthenticatorIds.some((id) => id === ccs.params.unlockedAuthenticator.authenticator.id);
        if (isRemovingLocalAuthenticator) {
          throw new RemoveLocalAuthenticatorError();
        }
        const remainingAuths = ccs.accountState.authenticators.filter((a2) => deleteAuthenticatorIds.every((delId) => a2.id !== delId));
        const authenticatorKeys = remainingAuths.map((a2) => a2.highSecurityIdentitySigPubKey);
        const newAuthenticatorKeys = newAuthenticators.map((a2) => a2.highSecurityIdentitySigPubKey);
        const newAuthenticatorBlock = AuthenticatorBlock.create(hsc.getHighSecurityUnlockedAuthenticator().highSecurityIdentitySigPrivKey, [...authenticatorKeys, ...newAuthenticatorKeys], ccs.accountState.authenticatorBlockHash);
        let regeneratedProfiles;
        let authenticatorCreationDtos;
        if (deleteAuthenticatorIds.length) {
          ({ regeneratedProfiles, authenticatorCreationDtos } = regenerateProfiles(hsc, protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, remainingAuths, newAuthenticators));
        } else {
          regeneratedProfiles = [];
          authenticatorCreationDtos = newAuthenticators.map((a2) => a2.serializeForCreation(ccs.profileRepo, hsc));
        }
        const { syncUpdate, authenticatorIds } = yield ccs.backendClient.authenticator.modify(authenticatorCreationDtos, deleteAuthenticatorIds, newAuthenticatorBlock, regeneratedProfiles);
        ccs = yield onlineInternalSync(ccs, syncUpdate, void 0, hsc);
        return Object.assign(Object.assign({}, ccs), { returnResult: authenticatorIds });
      }));
    });
  }
  function performWithSyncSuperUsers(ccs, hsc, operation) {
    return __awaiter$v(this, void 0, void 0, function* () {
      const originalBackendClient = ccs.backendClient;
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs, void 0, void 0, hsc);
      const _a2 = yield operation(ccs), { returnResult } = _a2, newCcs = __rest$f(_a2, ["returnResult"]);
      ccs = newCcs;
      ccs.syncVersion = null;
      ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
      ccs = yield onlineInternalSync(ccs, void 0, void 0, hsc);
      return Object.assign(Object.assign({}, ccs), { returnResult });
    });
  }
  var __awaiter$u = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalSessionSetProfileEnabled(ccs, profileId, enabled) {
    return __awaiter$u(this, void 0, void 0, function* () {
      const sessionId = ccs.params.loginData.sessionId;
      const session = ccs.accountState.sessions.find((s2) => s2.id == sessionId);
      if (!session) {
        throw new OwnSessionMissingError();
      }
      const allProfilesEnabled = session.enabledProfileIds.length === 0;
      const allProfileIds = ccs.profileRepo.getAllLoginProfileIds();
      const previouslyEnabled = allProfilesEnabled || session.enabledProfileIds.some((pId) => pId === profileId);
      if (enabled === previouslyEnabled) {
        return ccs;
      }
      const oldEnabledProfileIds = allProfilesEnabled ? allProfileIds : session.enabledProfileIds.filter((pId) => allProfileIds.includes(pId));
      const enabledProfileIds = enabled ? [...oldEnabledProfileIds, profileId] : oldEnabledProfileIds.filter((pId) => pId !== profileId);
      return onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds);
    });
  }
  function onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds) {
    return __awaiter$u(this, void 0, void 0, function* () {
      const sessionId = ccs.params.loginData.sessionId;
      const su = yield ccs.backendClient.session.update(sessionId, [], { enabledProfileIds });
      return onlineInternalSync(ccs, su);
    });
  }
  var __awaiter$t = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$e = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalOrganizationCreate(_a2, email, name, syncOrganizationMembersVaultName, options) {
    var _b2, _c2;
    var ccs = __rest$e(_a2, []);
    return __awaiter$t(this, void 0, void 0, function* () {
      const unsyncedUserProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, null, ccs.accountState.authenticators);
      const { unsyncedProfile: unsyncedAdminProfile } = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION_ADMIN, null, [], [unsyncedUserProfile]);
      const unsyncedPersonalVault = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, organizationPersonalVaultContentDescriptor, null);
      const unsyncedTeamVault = UnsyncedVault.create(VaultType.TEAM, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, loginVaultContentDescriptor, null);
      const unsyncedTeamMetaVault = UnsyncedVault.create(VaultType.TEAM_META, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification([], syncOrganizationMembersVaultName, true));
      const teamVaultDto = {
        blob: unsyncedTeamVault.getCommitBlob(),
        locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedTeamVault.getProfileLockDto(),
        adminProfileLock: unsyncedTeamVault.getAdminProfileLockDto(),
        messagePublicKey: (_b2 = unsyncedTeamVault.messageKeyPair) === null || _b2 === void 0 ? void 0 : _b2.encPubKey,
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedMessagePublicKey: (_c2 = unsyncedTeamMetaVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey,
        associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto()
      };
      const unsyncedAdminVault = UnsyncedVault.create(VaultType.ORGANIZATION_ADMIN, [], [], [], null, unsyncedAdminProfile, null, organizationAdminVaultContentDescriptor, null, (c2, t, { replaceOrganizationAdminVaultInfo: replaceOrganizationAdminVaultInfo2 }) => replaceOrganizationAdminVaultInfo2(c2, t, {}));
      const result2 = yield ccs.backendClient.organization.create({
        name,
        email,
        userProfile: unsyncedUserProfile.serialize(),
        adminProfile: unsyncedAdminProfile.serialize(),
        personalVaultDto: unsyncedPersonalVault.getCreationDto(),
        teamVaultDto,
        contactJson: options === null || options === void 0 ? void 0 : options.contactJson,
        parentOrganizationInfo: (options === null || options === void 0 ? void 0 : options.parentOrganizationId) ? { id: options.parentOrganizationId } : void 0,
        adminVaultDto: unsyncedAdminVault.getCreationDto()
      });
      ccs = yield onlineInternalSync(ccs, result2.syncUpdate);
      ccs = yield onlineInternalSessionSetProfileEnabled(ccs, result2.profileId, true);
      return Object.assign(Object.assign({}, ccs), { returnResult: result2.organizationId });
    });
  }
  function createOrganizationAuthenticator() {
    const secret = { seed: randomSeed() };
    const unsyncedAuthenticator = UnsyncedAuthenticator.create(AuthenticatorType.ORGANIZATION_ADMIN, "", secret);
    return { secret, unsyncedAuthenticator };
  }
  function serializeAuthenticator(a2) {
    const id = "id" in a2 ? a2.id : nullUuid;
    return Object.assign(Object.assign({}, a2), { id });
  }
  var __awaiter$s = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$d = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalOrganizationCreateLegacy(_a2, email, name, syncOrganizationMembersVaultName, options) {
    var _b2, _c2;
    var ccs = __rest$d(_a2, []);
    return __awaiter$s(this, void 0, void 0, function* () {
      const { secret, unsyncedAuthenticator: orgAuth } = createOrganizationAuthenticator();
      const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, null, ccs.accountState.authenticators);
      const unsyncedAdminVault = UnsyncedVault.create(VaultType.LEGACY_ORGANIZATION_ADMIN, [], [], [], unsyncedProfile, null, null, legacyOrganizationAdminVaultContentDescriptor, null, (c2, t, { protect: prot, replaceLegacyOrganizationAdminVaultInfo: replaceLegacyOrganizationAdminVaultInfo2 }) => replaceLegacyOrganizationAdminVaultInfo2(c2, t, {
        authenticatorSecret: {
          seed: prot({ unencrypted: naclUtilExports.encodeBase64(secret.seed), contentId: newUuid$1() })
        }
      }));
      const authBlock = AuthenticatorBlock.fromUnsyncedAuthenticators(orgAuth, []);
      const unsyncedPersonalVault = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, [], [], [], unsyncedProfile, null, null, organizationPersonalVaultContentDescriptor, null);
      const unsyncedTeamVault = UnsyncedVault.create(VaultType.TEAM, [], [], [], unsyncedProfile, null, null, loginVaultContentDescriptor, null);
      const unsyncedTeamMetaVault = UnsyncedVault.create(VaultType.TEAM_META, [], [], [], unsyncedProfile, null, null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification([], syncOrganizationMembersVaultName, true));
      const teamVaultDto = {
        blob: unsyncedTeamVault.getCommitBlob(),
        locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedTeamVault.getProfileLockDto(),
        messagePublicKey: (_b2 = unsyncedTeamVault.messageKeyPair) === null || _b2 === void 0 ? void 0 : _b2.encPubKey,
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedMessagePublicKey: (_c2 = unsyncedTeamMetaVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey
      };
      const result2 = yield ccs.backendClient.organization.create({
        name,
        email,
        userProfile: unsyncedProfile.serialize(),
        orgAuth: serializeAuthenticator(orgAuth),
        legacyAdminVaultDto: unsyncedAdminVault.getCreationDto(),
        authenticatorBlock: { blob: authBlock.blob, signature: authBlock.signature },
        personalVaultDto: unsyncedPersonalVault.getCreationDto(),
        personalVaultSuperuserLock: unsyncedPersonalVault.getExtraLockDto(orgAuth),
        teamVaultDto,
        teamVaultSuperuserLock: unsyncedTeamVault.getExtraLockDto(orgAuth),
        teamAssociatedVaultSuperuserLock: unsyncedTeamMetaVault.getExtraLockDto(orgAuth),
        contactJson: options === null || options === void 0 ? void 0 : options.contactJson,
        parentOrganizationInfo: (options === null || options === void 0 ? void 0 : options.parentOrganizationId) ? { id: options.parentOrganizationId } : void 0
      });
      ccs = yield onlineInternalSync(ccs, result2.syncUpdate);
      ccs = yield onlineInternalSessionSetProfileEnabled(ccs, result2.profileId, true);
      return Object.assign(Object.assign({}, ccs), { returnResult: result2.organizationId });
    });
  }
  var __awaiter$r = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalOrganizationCreateServiceProfile(ccs, orgId) {
    return __awaiter$r(this, void 0, void 0, function* () {
      const org = ccs.accountState.organizations.find((o) => o.id === orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc) {
        throw new ClientCoreIsLockedError();
      }
      const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
      if (!adminUp) {
        throw new NoOrganizationAdminError();
      }
      const adminHsup = hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo);
      const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION_SERVICE, orgId, []);
      const adminProfileLock = adminHsup.createProfileLock(unsyncedProfile);
      const syncUpdate = yield ccs.backendClient.organization.createServiceProfile(orgId, unsyncedProfile.serialize(), adminProfileLock);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$c = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalOrganizationDelete(_a2, orgId) {
    var ccs = __rest$c(_a2, []);
    return __awaiter$q(this, void 0, void 0, function* () {
      ccs = yield onlineInternalSync(ccs);
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.getOrganization(orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      const syncUpdate = yield ccs.backendClient.organization.delete(orgId);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$p = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalOrganizationModifyMembers(ccs, orgId, { createFreeProfiles, updateProfiles, removeProfileIds }) {
    var _a2;
    return __awaiter$p(this, void 0, void 0, function* () {
      const disabledOrgProfile = ccs.profileRepo.disabledProfiles.find((p2) => p2.organizationId === orgId);
      const fullSyncRequired = !!disabledOrgProfile;
      if (disabledOrgProfile) {
        ccs.ephemeralOperationState = {
          additionalEnabledProfileIds: [disabledOrgProfile.id]
        };
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      let hsc;
      ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
      if (!hsc) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.organizations.find((o) => o.id === orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
      if (!orgProfile) {
        throw new OrganizationNotFoundError();
      }
      const profiles = org.profiles;
      profiles.push({
        profileId: orgProfile.profile.id,
        isAdmin: org.isAdmin,
        isManager: org.isManager,
        isService: false,
        isNotConnected: false
      });
      const { adminInfo } = org;
      if (!adminInfo || !adminInfo.authenticator && !adminInfo.adminProfile) {
        throw new NoOrganizationAdminError();
      }
      const adminAuthenticator = adminInfo.authenticator ? [loadForeignAuthenticator(adminInfo.authenticator)] : [];
      const superUserVaultMemberIds = adminInfo.authenticator ? [org.superUserId] : [];
      const adminProfile = adminInfo.adminProfile ? loadForeignProfile(adminInfo.adminProfile) : null;
      const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
      const adminHsup = adminUp ? hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo) : void 0;
      const addedAdminProfileIds = [];
      const removedAdminProfileIds = [];
      let addedAdminUnsyncedProfiles = [];
      removeProfileIds === null || removeProfileIds === void 0 ? void 0 : removeProfileIds.forEach((pId) => {
        const existingMember = profiles.find((p2) => uuidEqual(pId, p2.profileId));
        if (existingMember === null || existingMember === void 0 ? void 0 : existingMember.isAdmin) {
          removedAdminProfileIds.push(pId);
        }
      });
      let createProfileDtos = [];
      if (createFreeProfiles === null || createFreeProfiles === void 0 ? void 0 : createFreeProfiles.length) {
        createProfileDtos = createFreeProfiles.flatMap((p2) => {
          const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, orgId, []);
          const personalVaultDto = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, superUserVaultMemberIds, [], adminAuthenticator, unsyncedProfile, adminProfile, orgId, organizationPersonalVaultContentDescriptor, null).getCreationDto();
          const legacyAdminVaultLock = void 0;
          const adminProfileLock = p2.isAdmin ? adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(unsyncedProfile) : void 0;
          return {
            userId: null,
            email: p2.email,
            isAdmin: p2.isAdmin,
            createStartCodeAndSendMail: p2.createStartCodeAndSendMail,
            profileDto: unsyncedProfile.serialize(),
            unsyncedProfile,
            personalVaultDto,
            legacyAdminVaultLock,
            adminProfileLock
          };
        });
        addedAdminUnsyncedProfiles = createProfileDtos ? createProfileDtos.filter(({ isAdmin }) => isAdmin).map((dto) => dto.unsyncedProfile) : [];
      }
      let selfDemotion = false;
      let updateProfileDtos;
      if (updateProfiles) {
        const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], updateProfiles.map(({ id }) => id), []);
        updateProfileDtos = updateProfiles.map(({ id: profileId, isAdmin }) => {
          let adminProfileLock;
          const existingProfile = profiles.find((m2) => uuidEqual(profileId, m2.profileId));
          if (isAdmin !== void 0 && isAdmin !== (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.isAdmin)) {
            if (isAdmin) {
              addedAdminProfileIds.push(profileId);
              adminProfileLock = adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(profilesById[profileId]);
            } else if (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.isAdmin) {
              if (profileId === orgProfile.profile.id) {
                selfDemotion = true;
              }
              removedAdminProfileIds.push(profileId);
            }
          }
          return { profileId, isAdmin, adminProfileLock };
        });
      }
      if (selfDemotion) {
        const tvps = ccs.vaultRepo.getOrganizationTeamVaultPairs(orgId);
        for (const tvp of tvps) {
          if (getTeamMetaVaultInfo(tvp.meta.getContent()).isSyncOrganizationMembers) {
            ccs = internalTeamSetUserPermissionLevels(ccs, tvp.login.id, {
              profileId: orgProfile.profile.id,
              permissionLevel: TEAM_USER_DEFAULT_PERMISSION_LEVEL
            });
          }
        }
      }
      let regeneratedVaultDto;
      if (removedAdminProfileIds.length || addedAdminProfileIds.length || addedAdminUnsyncedProfiles.length) {
        if (!org.adminInfo) {
          throw new NoOrganizationAdminError();
        }
        if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId !== nullUuid) {
          const adminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
          if (!adminVault) {
            throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
          }
          const adminProfileIdSet = /* @__PURE__ */ new Set([...adminVault.profileIds, ...addedAdminProfileIds]);
          for (const pId of removedAdminProfileIds) {
            adminProfileIdSet.delete(pId);
          }
          const adminProfileIds = [...adminProfileIdSet];
          const { authenticatorsByUser, profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], adminProfileIds, []);
          const oldProtectedSecret = (_a2 = ccs.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.protectedSecrets[adminVault.id];
          if (!oldProtectedSecret) {
            throw new CannotUnprotectError();
          }
          const regenerateData = regenerateVaultForUsers(adminVault, authenticatorsByUser, profilesById, [], adminProfileIds, [], addedAdminUnsyncedProfiles, oldProtectedSecret.protectedSecret, oldProtectedSecret.messagePrivateKey);
          regeneratedVaultDto = regenerateData.regeneratedVaultDto;
          createProfileDtos === null || createProfileDtos === void 0 ? void 0 : createProfileDtos.filter(({ isAdmin }) => isAdmin).forEach((dto, i2) => {
            dto.legacyAdminVaultLock = regenerateData.newProfileLockDtos[i2];
          });
        }
      }
      const syncUpdate = yield ccs.backendClient.organization.modifyMembers(orgId, createProfileDtos !== null && createProfileDtos !== void 0 ? createProfileDtos : [], updateProfileDtos !== null && updateProfileDtos !== void 0 ? updateProfileDtos : [], removeProfileIds !== null && removeProfileIds !== void 0 ? removeProfileIds : [], regeneratedVaultDto);
      ccs.ephemeralOperationState = void 0;
      if (fullSyncRequired) {
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
      }
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      ccs = yield onlineInternalMaintainTeamSyncOrganizationMembers(ccs, true);
      return ccs;
    });
  }
  var __awaiter$o = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$b = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalOrganizationRegenerateAdminProfile(inputCcs, orgId) {
    return __awaiter$o(this, void 0, void 0, function* () {
      return performWithOrgAllVaultsSyncPredicate(inputCcs, orgId, (_a2) => __awaiter$o(this, void 0, void 0, function* () {
        var ccs = __rest$b(_a2, []);
        const org = ccs.accountState.getOrganization(orgId);
        const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
        const { vaultRepo, protectedSecretRepo } = ccs;
        if (!org || !org.adminInfo || !orgProfile || !protectedSecretRepo) {
          return ccs;
        }
        const adminProfileIds = org.profiles.flatMap((p2) => p2.isAdmin ? p2.profileId : []);
        const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], adminProfileIds, [], org.id);
        const lockingProfiles = adminProfileIds.map((adminProfileId) => profilesById[adminProfileId]);
        lockingProfiles.push(orgProfile.profile);
        const { unsyncedProfile: adminProfile } = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION_ADMIN, orgId, [], lockingProfiles);
        const vaultLocks = vaultRepo.getAllVaultsByOrganizationId(orgId).map((v2) => ({
          vaultId: v2.id,
          generationId: v2.generationId,
          lock: protectedSecretRepo.createProfileLock(v2, adminProfile)
        }));
        let adminVaultCreationData;
        if (!ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id)) {
          const adminVault = UnsyncedVault.create(VaultType.ORGANIZATION_ADMIN, [], [], [], null, adminProfile, org.id, organizationAdminVaultContentDescriptor, null);
          adminVaultCreationData = adminVault.getCreationDto();
        }
        const previousAdminProfile = ccs.profileRepo.getOrgAdminProfile(org.id);
        const syncUpdate = yield ccs.backendClient.organization.regenerateAdmin(orgId, {
          profile: adminProfile.serialize(previousAdminProfile === null || previousAdminProfile === void 0 ? void 0 : previousAdminProfile.profile.id, previousAdminProfile === null || previousAdminProfile === void 0 ? void 0 : previousAdminProfile.profile.keyGenerationId),
          vaultLocks,
          // Organization admin profiles currently never lock any downstream profiles
          downstreamProfileLocks: []
        }, adminVaultCreationData);
        return onlineInternalSync(ccs, syncUpdate);
      }));
    });
  }
  function performWithOrgAllVaultsSyncPredicate(ccs, orgId, operation) {
    var _a2;
    return __awaiter$o(this, void 0, void 0, function* () {
      const originalForeignVaultSyncPredicate = ccs.ephemeralForeignVaultSyncPredicate;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [
        orgId,
        ...(_a2 = ccs.ephemeralForeignVaultSyncPredicate.organizationAllVaults) !== null && _a2 !== void 0 ? _a2 : []
      ] });
      const originalBackendClient = ccs.backendClient;
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs);
      ccs = yield operation(ccs);
      ccs.syncVersion = null;
      ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
      ccs.ephemeralForeignVaultSyncPredicate = originalForeignVaultSyncPredicate;
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$n = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$a = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalOrganizationRestoreUnsafeVaultContents(_a2, organizationId) {
    var ccs = __rest$a(_a2, []);
    return __awaiter$n(this, void 0, void 0, function* () {
      const oldEFVSP = ccs.ephemeralForeignVaultSyncPredicate;
      const oldBackendClient = ccs.backendClient;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [organizationId] });
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs);
      if (!ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.getOrganization(organizationId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      if (!org.isAdmin || !org.adminInfo) {
        throw new NoOrganizationAdminError();
      }
      if (org.adminInfo.licenseType !== LicenseType.EXAMPLE) {
        throw new Error("Tried to restore organization vault contents for non-example organization. This feature may only be used for demo purposes.");
      }
      let storedVaultContents;
      if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId != nullUuid) {
        const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
        if (!legacyAdminVault) {
          throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
        }
        storedVaultContents = getLegacyOrganizationAdminVaultInfo(legacyAdminVault.getContent()).unsafeStoredVaultContents;
      } else {
        const adminVault = ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id);
        if (!adminVault) {
          throw new Error("Organization has no admin vault! This should never happen.");
        }
        storedVaultContents = getOrganizationAdminVaultInfo(adminVault.getContent()).unsafeStoredVaultContents;
      }
      for (const [vaultId, storedContent] of Object.entries(storedVaultContents !== null && storedVaultContents !== void 0 ? storedVaultContents : {})) {
        const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
        if (!vault) {
          continue;
        }
        const { protect: protect2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(vault);
        const storedActiveLoginIds = Object.keys(storedContent.logins);
        const storedArchivedLoginIds = Object.keys(storedContent.archivedLogins);
        const allStoredLoginIds = [...storedActiveLoginIds, ...storedArchivedLoginIds];
        const activeLoginIds = Object.keys(vault.getContent().logins);
        const archivedLoginIds = Object.keys(vault.getArchivedContent().logins);
        const deleteLoginIds = activeLoginIds.filter((lid) => !allStoredLoginIds.includes(lid));
        const deleteArchivedLoginIds = archivedLoginIds.filter((lid) => !allStoredLoginIds.includes(lid));
        const keptArchivedLoginIds = archivedLoginIds.filter((lid) => allStoredLoginIds.includes(lid));
        ccs = modifyLoginVault(ccs, vault, (c2, t, { deleteLoginInternal: deleteLoginInternal2, restoreArchivedLoginInternal: restoreArchivedLoginInternal2, addOrModifyLoginInternal: addOrModifyLoginInternal2, archiveLoginInternal: archiveLoginInternal2 }) => {
          let newVaultContent = c2;
          for (const lid of [...deleteLoginIds, ...deleteArchivedLoginIds]) {
            ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t, lid));
          }
          for (const lid of keptArchivedLoginIds) {
            ({ newVaultContent } = restoreArchivedLoginInternal2(newVaultContent, t, lid));
          }
          for (const [id, login] of Object.entries(storedContent.logins)) {
            ({ newVaultContent } = addOrModifyLoginInternal2(newVaultContent, t, id, recursivelyTransformUnprotectedValues(login, protect2)));
          }
          for (const [id, login] of Object.entries(storedContent.archivedLogins)) {
            ({ newVaultContent } = addOrModifyLoginInternal2(newVaultContent, t, id, recursivelyTransformUnprotectedValues(login, protect2)));
            ({ newVaultContent } = archiveLoginInternal2(newVaultContent, t, id));
          }
          return { result: void 0, auditlogEvents: [], newVaultContent };
        });
      }
      ccs = yield onlineInternalSync(ccs);
      ccs.ephemeralForeignVaultSyncPredicate = oldEFVSP;
      ccs.syncVersion = null;
      ccs.backendClient = oldBackendClient.withSyncVersion(void 0);
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$m = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$9 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalOrganizationStoreUnsafeVaultContents(_a2, organizationId) {
    var ccs = __rest$9(_a2, []);
    return __awaiter$m(this, void 0, void 0, function* () {
      const oldEFVSP = ccs.ephemeralForeignVaultSyncPredicate;
      const oldBackendClient = ccs.backendClient;
      ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [organizationId] });
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
      ccs = yield onlineInternalSync(ccs);
      if (!ccs.protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const org = ccs.accountState.getOrganization(organizationId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      if (!(org === null || org === void 0 ? void 0 : org.isAdmin) || !org.adminInfo) {
        throw new NoOrganizationAdminError();
      }
      if (org.adminInfo.licenseType !== LicenseType.EXAMPLE) {
        throw new Error("Tried to unsafely store organization vault contents for non-example organization. This feature may only be used for demo purposes.");
      }
      const orgLoginVaultPairs = ccs.vaultRepo.getOrganizationLoginVaultPairs(organizationId, {
        includeForeignOrganizationPersonalVaults: true,
        includeForeignTeamVaults: true
      });
      const vaultContents = {};
      for (const { login: loginVault } of orgLoginVaultPairs) {
        const { unprotectWithContentId: unprotectWithContentId2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(loginVault);
        const logins = {};
        for (const [id, login] of Object.entries(loginVault.getContent().logins)) {
          logins[id] = recursivelyTransformProtectedValues(login, unprotectWithContentId2);
        }
        const archivedLogins = {};
        for (const [id, login] of Object.entries(loginVault.getArchivedContent().logins)) {
          archivedLogins[id] = recursivelyTransformProtectedValues(login, unprotectWithContentId2);
        }
        vaultContents[loginVault.id] = { logins, archivedLogins };
      }
      if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId != nullUuid) {
        const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
        if (!legacyAdminVault) {
          throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
        }
        ccs = modifyVault(ccs, legacyAdminVault, (c2, t, { modifyLegacyOrganizationAdminVaultInfo: modifyLegacyOrganizationAdminVaultInfo2 }) => modifyLegacyOrganizationAdminVaultInfo2(c2, t, {
          unsafeStoredVaultContents: vaultContents
        }));
      } else {
        const adminVault = ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id);
        if (!adminVault) {
          throw new Error("Organization has no admin vault! This should never happen.");
        }
        ccs = modifyVault(ccs, adminVault, (c2, t, { modifyOrganizationAdminVaultInfo: modifyOrganizationAdminVaultInfo2 }) => modifyOrganizationAdminVaultInfo2(c2, t, { unsafeStoredVaultContents: vaultContents }));
      }
      ccs = yield onlineInternalSync(ccs);
      ccs.ephemeralForeignVaultSyncPredicate = oldEFVSP;
      ccs.syncVersion = null;
      ccs.backendClient = oldBackendClient.withSyncVersion(void 0);
      return onlineInternalSync(ccs);
    });
  }
  var __awaiter$l = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$8 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalProfileCreatePrivate(_a2, email) {
    var ccs = __rest$8(_a2, []);
    return __awaiter$l(this, void 0, void 0, function* () {
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const privateProfile = UnsyncedProfile.create(ProfileType.PRIVATE, null, ccs.accountState.authenticators);
      const privateVault = UnsyncedVault.create(VaultType.PRIVATE, [], [], [], privateProfile, null, null, loginVaultContentDescriptor, null);
      const { privateProfileId, syncUpdate } = yield ccs.backendClient.profile.createPrivate(email, privateProfile.serialize(), privateVault.getCreationDto());
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      ccs = yield onlineInternalSessionSetProfileEnabled(ccs, privateProfileId, true);
      return ccs;
    });
  }
  var __awaiter$k = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$7 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalProfileDeletePrivate(_a2, privateProfileId) {
    var ccs = __rest$7(_a2, []);
    return __awaiter$k(this, void 0, void 0, function* () {
      const syncUpdate = yield ccs.backendClient.profile.deletePrivate(privateProfileId);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$j = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$6 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalProfileRegenerate(_a2, hsc) {
    var ccs = __rest$6(_a2, []);
    return __awaiter$j(this, void 0, void 0, function* () {
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const { regeneratedProfiles } = regenerateProfiles(hsc, protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, ccs.accountState.authenticators, []);
      const syncUpdate = yield ccs.backendClient.profile.regenerate(regeneratedProfiles);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function createUnsyncedRecoveryAuthenticator(seed, recoveryParameters) {
    if (seed.byteLength !== 32) {
      throw new InvalidAuthenticatorSeedLengthError();
    }
    const checksum = naclUtilExports.encodeBase64(hashData(seed));
    const secretInfo = { checksum, recoveryParameters };
    return UnsyncedAuthenticator.create(AuthenticatorType.BACKUP_CODE, JSON.stringify(secretInfo), {
      seed
    });
  }
  function createUnsyncedBackupAuthenticator(seed) {
    if (seed.byteLength !== 32) {
      throw new InvalidAuthenticatorSeedLengthError();
    }
    return UnsyncedAuthenticator.create(AuthenticatorType.BACKUP_OS, "", { seed });
  }
  var __awaiter$i = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$5 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalRegenerateBackup(_a2, backupAuthSeed, hsc) {
    var ccs = __rest$5(_a2, []);
    return __awaiter$i(this, void 0, void 0, function* () {
      ccs = yield onlineInternalSync(ccs);
      const unsyncedAuthenticator = createUnsyncedBackupAuthenticator(backupAuthSeed);
      const previousAuth = ccs.accountState.authenticators.find((a2) => a2.authenticatorType === AuthenticatorType.BACKUP_OS);
      const result2 = yield onlineInternalModifyAuthenticators(ccs, hsc, previousAuth ? [previousAuth.id] : [], [unsyncedAuthenticator]);
      if (!result2.returnResult.length) {
        throw new NoAuthenticatorIdReceivedError();
      }
      return Object.assign(Object.assign({}, result2), { returnResult: result2.returnResult[0] });
    });
  }
  var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$4 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  const BACKUP_CODE_PATTERN = /\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d/;
  function onlineInternalRegenerateRecovery(_a2, backupCode, recoverySeed, recoveryParameters, hsc) {
    var ccs = __rest$4(_a2, []);
    return __awaiter$h(this, void 0, void 0, function* () {
      if (!BACKUP_CODE_PATTERN.test(backupCode)) {
        throw new Error("received incorrectly formatted backup code");
      }
      ccs = yield onlineInternalSync(ccs);
      const metaVault = ccs.vaultRepo.getMetaVault();
      if (!metaVault) {
        throw new MetaVaultNotFoundError();
      }
      ccs = modifyVault(ccs, metaVault, (c2, t, { protect: protect2, modifyAccountSettings: modifyAccountSettings2 }) => modifyAccountSettings2(c2, t, {
        backupCode: protect2({ contentId: newUuid$1(), unencrypted: backupCode })
      }), true, hsc);
      ccs.accountState = ccs.accountState.withLocalAchievements([
        Achievement.COR_STORE_BACKUP_CODE_META_VAULT
      ]);
      const unsyncedAuthenticator = createUnsyncedRecoveryAuthenticator(recoverySeed, recoveryParameters);
      const previousAuth = ccs.accountState.authenticators.find((a2) => a2.authenticatorType === AuthenticatorType.BACKUP_CODE);
      const result2 = yield onlineInternalModifyAuthenticators(ccs, hsc, previousAuth ? [previousAuth.id] : [], [unsyncedAuthenticator]);
      if (!result2.returnResult.length) {
        throw new NoAuthenticatorIdReceivedError();
      }
      return Object.assign(Object.assign({}, result2), { returnResult: result2.returnResult[0] });
    });
  }
  var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalRegenerateVault(ccs, hsc, vaultId) {
    return __awaiter$g(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getVaultById(vaultId);
      const vaultAccess = getVaultAccess(ccs, hsc, vault);
      if (!vaultAccess) {
        throw new ClientCoreIsLockedError();
      }
      const regeneratedVault = yield onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess);
      const backendClient = getBackendClientForVault(ccs, vault);
      const { syncUpdate } = yield backendClient.vault.createGeneration(regeneratedVault);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$3 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalTeamCreate(_a2, name, organizationId) {
    var _b2, _c2, _d2, _e2;
    var ccs = __rest$3(_a2, []);
    return __awaiter$f(this, void 0, void 0, function* () {
      const profile = organizationId ? (_b2 = ccs.profileRepo.getOrganizationProfile(organizationId)) === null || _b2 === void 0 ? void 0 : _b2.profile : (_c2 = ccs.profileRepo.getPrivateProfile()) === null || _c2 === void 0 ? void 0 : _c2.profile;
      if (!profile) {
        throw new ClientCoreInternalError("no organization or private profile found to create team");
      }
      const { unsyncedTeamVault, unsyncedTeamMetaVault } = yield onlineInternalMakeUnsyncedTeamVaults(ccs, name, organizationId, profile, false);
      const { vaultId: teamVaultId, associatedVaultId: teamMetaVaultId, syncUpdate } = yield ccs.backendClient.vault.createTeam({
        blob: unsyncedTeamVault.getCommitBlob(),
        locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
        profileLock: unsyncedTeamVault.getProfileLockDto(),
        adminProfileLock: unsyncedTeamVault.getAdminProfileLockDto(),
        messagePublicKey: (_d2 = unsyncedTeamVault.messageKeyPair) === null || _d2 === void 0 ? void 0 : _d2.encPubKey,
        associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
        associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
        associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
        associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto(),
        associatedMessagePublicKey: (_e2 = unsyncedTeamMetaVault.messageKeyPair) === null || _e2 === void 0 ? void 0 : _e2.encPubKey,
        organizationId
      });
      ccs = addUnsyncedVaultAfterCreate(ccs, syncUpdate, teamVaultId, teamMetaVaultId, organizationId !== null && organizationId !== void 0 ? organizationId : null, unsyncedTeamVault);
      ccs = addUnsyncedVaultAfterCreate(
        ccs,
        syncUpdate,
        // if we pass in an unsynced associated vault, we're also going to get back an id for it
        teamMetaVaultId,
        null,
        organizationId !== null && organizationId !== void 0 ? organizationId : null,
        unsyncedTeamMetaVault
      );
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      return Object.assign(Object.assign({}, ccs), { returnResult: teamVaultId });
    });
  }
  var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$2 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function onlineInternalTeamDelete(_a2, vaultId) {
    var ccs = __rest$2(_a2, []);
    return __awaiter$e(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getTeamVaultPairById(vaultId);
      if (!pair) {
        throw new VaultNotFoundError(vaultId);
      }
      if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== PermissionLevel.admin) {
        throw new VaultPermissionDeniedError();
      }
      const { syncUpdate } = yield ccs.backendClient.vault.deleteTeam(vaultId);
      ccs = yield onlineInternalSync(ccs, syncUpdate);
      ccs = yield onlineInternalMaintainVaultMessages(ccs);
      return Object.assign({}, ccs);
    });
  }
  var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalTeamLeave(ccs, teamId) {
    return __awaiter$d(this, void 0, void 0, function* () {
      const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
      if (!pair) {
        throw new VaultNotFoundError(teamId);
      }
      const { login, meta } = pair;
      const joinedProfileId = login.getProfileId();
      if (!joinedProfileId) {
        throw new VaultNotFoundError(teamId);
      }
      const commitData = getUpdatedMetaVault(meta, joinedProfileId);
      const { syncUpdate } = yield ccs.backendClient.vault.modifyTeamUsers(teamId, login.generationId, [], joinedProfileId ? [joinedProfileId] : [], meta.generationId, commitData === null || commitData === void 0 ? void 0 : commitData.metaVaultCommitId, commitData === null || commitData === void 0 ? void 0 : commitData.blob, commitData === null || commitData === void 0 ? void 0 : commitData.latestUpdateTime);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function getUpdatedMetaVault(metaVault, removeProfileId) {
    ({ vault: metaVault } = metaVault.withModification((c2, t, { deleteTeamVaultUser: deleteTeamVaultUser2 }) => deleteTeamVaultUser2(c2, t, removeProfileId)));
    const stagedData = metaVault.getStagedDiff(null);
    if (!stagedData) {
      return null;
    }
    const { stagingVault, diff, latestUpdateTime } = stagedData;
    const protoCommit = Commit.create(null, stagingVault.vaultSecret, diff);
    return {
      metaVaultCommitId: metaVault.commitId,
      blob: protoCommit.blob,
      latestUpdateTime: new Date(latestUpdateTime)
    };
  }
  var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnDeleteCredentials(ccs, ids) {
    return __awaiter$c(this, void 0, void 0, function* () {
      const syncUpdate = yield ccs.backendClient.webauthn.deleteCredentials(ids);
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnEnablePrf(ccs, { options }, cred) {
    var _a2, _b2, _c2, _d2;
    return __awaiter$b(this, void 0, void 0, function* () {
      if (!cred.prfExtensionResult) {
        throw new PrfNotSupportedError();
      }
      const syncUpdate = yield ccs.backendClient.sync.poll();
      if (!syncUpdate.sessionUnlock) {
        throw new ClientCoreIsLockedError();
      }
      const seed = deriveSecretFromSeed(new Uint8Array(cred.prfExtensionResult.first), null, SALT_AUTHENTICATOR_WEBAUTHN_SEED);
      const webauthnCred = ccs.accountState.webauthnCredentials.find((wc) => cred.id === wc.webauthnId);
      if (!webauthnCred) {
        throw new PrfInitError();
      }
      const prfInputs = (_b2 = (_a2 = options.publicKey) === null || _a2 === void 0 ? void 0 : _a2.extensions) === null || _b2 === void 0 ? void 0 : _b2.prf;
      const prfSalt = (_d2 = (_c2 = prfInputs === null || prfInputs === void 0 ? void 0 : prfInputs.evalByCredential) === null || _c2 === void 0 ? void 0 : _c2[cred.id]) === null || _d2 === void 0 ? void 0 : _d2.first;
      if (!prfSalt) {
        throw new PrfInitError();
      }
      const ua = UnsyncedAuthenticator.createWebauthn({ seed }, { webauthnId: webauthnCred.webauthnId, prfSalt: new Uint8Array(prfSalt) });
      const hsc = HighSecurityCache.fromSessionUnlock(syncUpdate.sessionUnlock, ccs.params.sessionKeys.encPrivKey, ccs.accountState.authenticators);
      return onlineInternalModifyAuthenticators(ccs, hsc, [], [ua]);
    });
  }
  function unmarshalCredentialCreationOptions(optionsJson) {
    const options = JSON.parse(optionsJson);
    options.publicKey.challenge = decodeBase64Urlsafe(options.publicKey.challenge);
    options.publicKey.user.id = decodeBase64Urlsafe(options.publicKey.user.id);
    if (options.publicKey.excludeCredentials) {
      options.publicKey.excludeCredentials.forEach((cred) => {
        cred.id = decodeBase64Urlsafe(cred.id);
      });
    }
    return options;
  }
  function unmarshalCredentialRequestOptions(optionsJson) {
    const options = JSON.parse(optionsJson);
    options.publicKey.challenge = decodeBase64Urlsafe(options.publicKey.challenge);
    options.publicKey.allowCredentials.forEach((cred) => {
      cred.id = decodeBase64Urlsafe(cred.id);
    });
    return options;
  }
  function marshalAssertionPublicKeyCredential(cred) {
    return JSON.stringify({
      id: cred.id,
      rawId: encodeBase64Urlsafe(cred.rawId),
      type: "public-key",
      response: {
        authenticatorData: encodeBase64Urlsafe(cred.response.authenticatorData),
        clientDataJSON: encodeBase64Urlsafe(cred.response.clientDataJSON),
        signature: encodeBase64Urlsafe(cred.response.signature),
        userHandle: cred.response.userHandle ? encodeBase64Urlsafe(cred.response.userHandle) : void 0
      }
    });
  }
  var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnRegisterCredentialInit(ccs, type) {
    return __awaiter$a(this, void 0, void 0, function* () {
      const { requestId, optionsJson } = yield ccs.backendClient.webauthn.registerCredentialInit(type);
      const options = unmarshalCredentialCreationOptions(optionsJson);
      const prfSalt = { first: randomSeed() };
      options.publicKey.extensions = Object.assign(Object.assign({}, options.publicKey.extensions), { prf: { eval: prfSalt } });
      debugConsole.info("webauthn.create options", options);
      return Object.assign(Object.assign({}, ccs), { returnResult: { requestId, options, prfSalt } });
    });
  }
  function onlineInternalWebauthnRegisterCredentialFinish(ccs, requestId, cred) {
    return __awaiter$a(this, void 0, void 0, function* () {
      const credJson = marshalAttestationPublicKeyCredential(cred);
      const su = yield ccs.backendClient.webauthn.registerCredentialFinish(requestId, credJson, cred.prfSupportStatus);
      return onlineInternalSync(ccs, su);
    });
  }
  function marshalAttestationPublicKeyCredential(cred) {
    return JSON.stringify({
      id: cred.id,
      rawId: encodeBase64Urlsafe(cred.rawId),
      type: "public-key",
      response: {
        attestationObject: encodeBase64Urlsafe(cred.response.attestationObject),
        clientDataJSON: encodeBase64Urlsafe(cred.response.clientDataJSON),
        transports: cred.response.transports
      }
    });
  }
  function getUnlockTime() {
    const date2 = new Date((/* @__PURE__ */ new Date()).getTime() + 864e5);
    date2.setHours(2, 0, 0, 0);
    return date2;
  }
  var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function onlineInternalWebauthnUnlockSessionInit(ccs) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const { requestId, optionsJson } = yield ccs.backendClient.webauthn.unlockSessionInit();
      const options = unmarshalCredentialRequestOptions(optionsJson);
      const evalByCredential = {};
      for (const a2 of options.publicKey.allowCredentials) {
        evalByCredential[encodeBase64Urlsafe(a2.id)] = {
          first: randomSeed()
        };
      }
      options.publicKey.extensions = Object.assign(Object.assign({}, options.publicKey.extensions), { prf: { evalByCredential } });
      debugConsole.info("webauthn.get options", options);
      return Object.assign(Object.assign({}, ccs), { returnResult: { requestId, options } });
    });
  }
  function onlineInternalWebauthnUnlockSessionFinish(ccs, requestId, cred) {
    return __awaiter$9(this, void 0, void 0, function* () {
      const responseJson = marshalAssertionPublicKeyCredential(cred);
      const syncUpdate = yield ccs.backendClient.webauthn.unlockSessionFinish(requestId, responseJson, getUnlockTime());
      return onlineInternalSync(ccs, syncUpdate);
    });
  }
  function completeLongPollChannelReply(publicKeyB64, authenticatorSeed, registration) {
    const publicKey = loadEncryptionPublicKey(publicKeyB64);
    const publicKeyHash = naclUtilExports.encodeBase64(hashData(publicKey));
    const authReply = createEncryptedSecretAuthenticatorReply({
      encryptedSecret: asymEncrypt(publicKey, authenticatorSeed),
      registration
    });
    return { publicKeyHash, authReply };
  }
  const SALT_SESSION_ENCRYPTION_KEY = "salt-session-encryption-key-";
  const SALT_SESSION_ENCRYPTION_KEY_SIGNATURE$1 = "salt-session-encryption-key-signature-";
  function createUnsignedSessionKeys() {
    const secret = randomSeed();
    return deriveEncryptionKeyPair(secret, null, SALT_SESSION_ENCRYPTION_KEY);
  }
  class SessionKeys {
    constructor(encPrivKey, encPubKey, encPubKeySignature, signingAuthId) {
      this.encPrivKey = encPrivKey;
      this.encPubKey = encPubKey;
      this.encPubKeySignature = encPubKeySignature;
      this.signingAuthId = signingAuthId;
    }
    static createFromUnsigned(usk, ua) {
      const { encPrivKey, encPubKey } = usk;
      const encPubKeySignature = signEncryptionPublicKey(ua.highSecurityIdentitySigPrivKey, encPubKey, SALT_SESSION_ENCRYPTION_KEY_SIGNATURE$1);
      return new SessionKeys(encPrivKey, encPubKey, encPubKeySignature, ua.authenticator.id);
    }
    static create(ua) {
      return SessionKeys.createFromUnsigned(createUnsignedSessionKeys(), ua);
    }
  }
  var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function finishChallengeSelfUnlocking({ client, hsua, challenge, userId, sessionType }) {
    return __awaiter$8(this, void 0, void 0, function* () {
      const unsignedSessionKeys = createUnsignedSessionKeys();
      const response = signString(hsua.highSecurityLoginSigPrivKey, challenge, null);
      const { loginData } = yield client.credential.createTokens(userId, hsua.authenticator.id, challenge, response, null, sessionType);
      const { authenticators } = yield client.withLogin(loginData).authenticator.list();
      const authenticatorDto = authenticators.find((a2) => a2.id === hsua.authenticator.id);
      if (!authenticatorDto) {
        throw new AuthenticatorNotFoundError();
      }
      const sessionKeys = SessionKeys.createFromUnsigned(unsignedSessionKeys, hsua);
      const clientCoreParameters = {
        loginData,
        unlockedAuthenticator: hsua.getUnlockedAuthenticator(),
        sessionKeys
      };
      return clientCoreParameters;
    });
  }
  var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class LoginFlowPushAuthenticator {
    constructor(channelId, authenticatorId, backend, sharedSecret, isCancelled = false) {
      this.channelId = channelId;
      this.authenticatorId = authenticatorId;
      this.backend = backend;
      this.sharedSecret = sharedSecret;
      this.isCancelled = isCancelled;
    }
    static create(channelId, authenticatorId, backend) {
      return __awaiter$7(this, void 0, void 0, function* () {
        const keyPair = newSharedSecretKeyPair();
        const hashCommitment = yield backend.channel.loginChannelClaimAndReceiveHashCommitment(channelId, authenticatorId, keyPair.sharedPubKey);
        const clientPubKey = yield backend.channel.loginChannelReceiveClientPubKey(channelId);
        if (!verifyHash(hashCommitment, clientPubKey)) {
          throw new InvalidHashCommitmentError();
        }
        const sharedSecret = combineSharedSecret(keyPair.sharedPrivKey, clientPubKey, "push-login");
        const flow = new LoginFlowPushAuthenticator(channelId, authenticatorId, backend, sharedSecret);
        return flow;
      });
    }
    cancel() {
      return __awaiter$7(this, void 0, void 0, function* () {
        yield this.backend.channel.loginChannelClose(this.channelId);
        this.isCancelled = true;
      });
    }
    getSas() {
      if (this.isCancelled) {
        throw new LoginCancelledError();
      }
      return symKeyToSas(this.sharedSecret);
    }
    sendEncryptedSecret(secret) {
      return __awaiter$7(this, void 0, void 0, function* () {
        if (this.isCancelled) {
          throw new LoginCancelledError();
        }
        const encryptedSecret = symEncrypt(this.sharedSecret, secret);
        yield this.backend.channel.loginChannelSendEncryptedSecret(this.channelId, encryptedSecret, this.authenticatorId);
      });
    }
    waitForClose() {
      return __awaiter$7(this, void 0, void 0, function* () {
        yield this.backend.channel.loginChannelWaitUntilClosed(this.channelId);
      });
    }
  }
  function checkEncPubKeySignature(trustedSigPubKeys, encPubKey, encPubKeySignature, salt) {
    if (!trustedSigPubKeys.some((sigPubKey) => verifySignedEncryptionPublicKey(sigPubKey, encPubKey, loadEncryptionPublicKeySignature(encPubKeySignature), salt))) {
      throw new NoMatchingSigningKeyFoundError();
    }
  }
  class OrganizationAuthTokenCache {
    constructor(cache2 = {}) {
      this.cache = cache2;
    }
    isEmpty() {
      return Object.values(this.cache).length === 0;
    }
    getToken(orgId) {
      const entry = this.cache[orgId];
      if (!entry || entry.expiresAt < /* @__PURE__ */ new Date()) {
        return null;
      }
      return entry.token;
    }
    withToken(orgId, token, expiresAt) {
      return new OrganizationAuthTokenCache(Object.assign(Object.assign({}, this.cache), { [orgId]: { expiresAt, token } }));
    }
  }
  var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest$1 = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  function mergeLoginWebsites(websites, websiteAttributes, unnormalizedWebsite) {
    const normalizedWebsite = normalizeWebsitePattern(unnormalizedWebsite);
    const websiteHost = new URL(`https://${unnormalizedWebsite}`).host;
    if (websites.find((w2) => new URL(`https://${w2}`).host === websiteHost)) {
      return { websites, websiteAttributes };
    }
    return {
      websites: [...websites, normalizedWebsite],
      websiteAttributes: Object.assign(Object.assign({}, websiteAttributes), { [normalizedWebsite]: Object.assign(Object.assign({}, websiteAttributes === null || websiteAttributes === void 0 ? void 0 : websiteAttributes[normalizedWebsite]), getWebsiteAttributesEntry(unnormalizedWebsite)) })
    };
  }
  function mergeLoginAndroidApps(androidApps, androidApp) {
    const androidAppWithId = Object.assign({ id: newUuid$1() }, androidApp);
    if (!androidApps) {
      return androidApp ? [androidAppWithId] : [];
    }
    const existingAppIndex = androidApps.findIndex((a2) => a2.appId === androidApp.appId);
    if (existingAppIndex === -1) {
      return [...androidApps, androidAppWithId];
    }
    return [
      ...androidApps.slice(0, existingAppIndex),
      Object.assign(Object.assign({}, androidApps[existingAppIndex]), androidAppWithId),
      ...androidApps.slice(existingAppIndex + 1)
    ];
  }
  function ingestLoginUpdate(_a2, _b2) {
    var ccs = __rest$1(_a2, []);
    var loginId = _b2.loginId, vaultId = _b2.vaultId, username = _b2.username, password = _b2.password, unnormalizedWebsite = _b2.unnormalizedWebsite, androidApp = _b2.androidApp;
    return __awaiter$6(this, void 0, void 0, function* () {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      const { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const existing = loginId ? vault.getContent().logins[loginId] : void 0;
      const unprotectedPassword = { contentId: newUuid$1(), unencrypted: password };
      if (loginId && existing) {
        const oldPassword = protectedSecretRepo.unprotectWithContentId(vault, existing.password);
        const newPassword = oldPassword.unencrypted === password ? oldPassword : unprotectedPassword;
        let modifiedLogin = {
          username: username !== null && username !== void 0 ? username : "",
          password: newPassword
        };
        if (unnormalizedWebsite) {
          modifiedLogin = Object.assign(Object.assign({}, modifiedLogin), mergeLoginWebsites(existing.websites, existing.websiteAttributes, unnormalizedWebsite.uri));
        }
        if (androidApp) {
          modifiedLogin = Object.assign(Object.assign({}, modifiedLogin), { androidApps: mergeLoginAndroidApps(existing.androidApps, androidApp) });
        }
        return Object.assign(Object.assign({}, yield modifyLogin(ccs, {
          vaultId,
          loginId,
          login: modifiedLogin,
          source: LoginSource.autosave
        })), { returnResult: loginId });
      }
      let websites = [];
      let websiteAttributes = {};
      if (unnormalizedWebsite === null || unnormalizedWebsite === void 0 ? void 0 : unnormalizedWebsite.uri) {
        const website = normalizeWebsitePattern(unnormalizedWebsite.uri);
        websiteAttributes = { [website]: getWebsiteAttributesEntry(unnormalizedWebsite === null || unnormalizedWebsite === void 0 ? void 0 : unnormalizedWebsite.uri) };
        websites = [website];
      }
      const androidApps = androidApp ? [Object.assign({ id: newUuid$1() }, androidApp)] : [];
      return addLogin(ccs, {
        vaultId,
        login: {
          uiType: LoginUiType.login,
          title: "",
          websites,
          websiteAttributes,
          androidApps,
          username: username !== null && username !== void 0 ? username : "",
          password: unprotectedPassword,
          note: "",
          customFields: []
        },
        source: LoginSource.autosave
      });
    });
  }
  class VaultRepo {
    constructor(vaults = []) {
      this.vaults = vaults;
    }
    static create(vaults = []) {
      return new VaultRepo(vaults);
    }
    static createFromPersistable(p2, profileRepo, superUserUnlockedAuthenticators = {}) {
      const vaults = p2.vaults.flatMap((pv) => {
        let vaultAccess = getDirectVaultAccess(profileRepo, null, pv);
        if (!vaultAccess && pv.organizationId && pv.adminProfileLock) {
          const unlockedProfile = profileRepo.getOrgAdminProfile(pv.organizationId);
          if (unlockedProfile) {
            vaultAccess = {
              type: "admin-profile",
              unlockedProfile,
              hsup: null,
              orgId: pv.organizationId
            };
          }
        }
        if (!vaultAccess && pv.organizationId && superUserUnlockedAuthenticators[pv.organizationId]) {
          vaultAccess = {
            type: "admin-authenticator",
            unlockedAuthenticator: superUserUnlockedAuthenticators[pv.organizationId],
            hsua: null,
            orgId: pv.organizationId
          };
        }
        if (!vaultAccess) {
          trackError(new Error(`Ignoring vault ${pv.id} from persistable. There is no matching unlocked authenticator.`));
          return [];
        }
        return [Vault.createFromPersistable(pv, vaultAccess)];
      });
      return new VaultRepo(vaults);
    }
    isInitialized() {
      const metaVault = this.getVaultByQuery({ descriptor: metaVaultContentDescriptor });
      return !!metaVault;
    }
    getPersistable(foreignVaultSyncPredicate) {
      return {
        vaults: this.vaults.flatMap((vault) => {
          const shouldPersistVault = vault.isUserJoined || checkForeignVaultSyncPredicate({ type: "vault", vault }, foreignVaultSyncPredicate);
          if (!shouldPersistVault) {
            return [];
          }
          return vault.getPersistable();
        })
      };
    }
    getAllVaults() {
      return this.vaults;
    }
    getAllVaultsByOrganizationId(organizationId) {
      return this.filterVaultsByQuery({ organizationId });
    }
    getForeignVaultsByOrganizationId(organizationId) {
      return this.filterVaultsByQuery({ organizationId, isUserJoined: false });
    }
    getAllVaultsByProfileId(profileId) {
      return this.filterVaultsByQuery({ profileId });
    }
    getVaultById(vaultId) {
      const vault = this.vaults.find((v2) => v2.id === vaultId);
      if (!vault) {
        throw new VaultNotFoundError(vaultId);
      }
      return vault;
    }
    vaultExits(vaultId) {
      return this.vaults.some((v2) => v2.id === vaultId);
    }
    getPrivateLoginVault() {
      const privateLoginVault = this.getVaultByQuery({
        descriptor: loginVaultContentDescriptor,
        vaultTypes: [VaultType.PRIVATE],
        isUserJoined: true
      });
      return privateLoginVault !== null && privateLoginVault !== void 0 ? privateLoginVault : null;
    }
    getPrivateLoginVaultPairs(excludeOrganizationIds) {
      return this.filterVaultsByQuery({
        descriptor: loginVaultContentDescriptor,
        isUserJoined: true,
        vaultTypes: [VaultType.PRIVATE, VaultType.TEAM]
      }).flatMap((l) => {
        if (l.organizationId && excludeOrganizationIds.includes(l.organizationId)) {
          return [];
        }
        const pair = this.makeLoginVaultPair(l);
        if (!pair) {
          return [];
        }
        return pair;
      });
    }
    getMetaVault() {
      return this.getVaultByQuery({
        descriptor: metaVaultContentDescriptor,
        isUserJoined: true
      });
    }
    getTeamVaultPairs() {
      return this.getTeamVaultPairsByQuery({
        isUserJoined: true
      });
    }
    getOrganizationTeamVaultPairs(organizationId) {
      return this.getTeamVaultPairsByQuery({ organizationId });
    }
    getOrganizationLoginVaultPairs(organizationId, { includeForeignOrganizationPersonalVaults = false, includeForeignTeamVaults = false } = {}) {
      return this.filterVaultsByQuery({
        descriptor: loginVaultContentDescriptor,
        isUserJoined: includeForeignTeamVaults ? void 0 : true,
        organizationId
      }, {
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: includeForeignOrganizationPersonalVaults ? void 0 : true,
        organizationId
      }).flatMap((l) => {
        const pair = this.makeLoginVaultPair(l);
        if (!pair) {
          return [];
        }
        return pair;
      });
    }
    getLoginVaultPairs({ includeForeignOrganizationPersonalVaults = false, includeForeignTeamVaults = false } = {}) {
      return this.filterVaultsByQuery({
        descriptor: loginVaultContentDescriptor,
        isUserJoined: includeForeignTeamVaults ? void 0 : true
      }, {
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: includeForeignOrganizationPersonalVaults ? void 0 : true
      }).flatMap((l) => {
        const pair = this.makeLoginVaultPair(l);
        if (!pair) {
          return [];
        }
        return pair;
      });
    }
    getTeamVaultPairById(vaultId) {
      const login = this.getLoginVaultById(vaultId);
      if (!login) {
        return null;
      }
      const meta = this.getTeamMetaVaultForTeamVault(login);
      if (!meta) {
        return null;
      }
      return { login, meta, type: VaultType.TEAM };
    }
    getLoginVaultById(vaultId) {
      return this.getVaultByQuery({ vaultId, descriptor: loginVaultContentDescriptor }, { vaultId, descriptor: organizationPersonalVaultContentDescriptor });
    }
    getLoginVaultPairById(vaultId) {
      const loginVault = this.getVaultByQuery({ vaultId, descriptor: loginVaultContentDescriptor }, { vaultId, descriptor: organizationPersonalVaultContentDescriptor });
      if (!loginVault) {
        return null;
      }
      return this.makeLoginVaultPair(loginVault);
    }
    getTeamMetaVaultById(vaultId) {
      return this.getVaultByQuery({
        vaultId,
        descriptor: teamMetaVaultContentDescriptor
      });
    }
    getLegacyOrganizationAdminVaults() {
      return this.filterVaultsByQuery({
        descriptor: legacyOrganizationAdminVaultContentDescriptor
      });
    }
    getLegacyOrganizationAdminVaultById(vaultId) {
      return this.getVaultByQuery({
        vaultId,
        descriptor: legacyOrganizationAdminVaultContentDescriptor
      });
    }
    getOrganizationAdminVaultByOrganizationId(organizationId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationAdminVaultContentDescriptor
      });
    }
    getOrganizationPersonalLoginVault(organizationId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: true
      });
    }
    getOrganizationAllPersonalLoginVaults(organizationId) {
      return this.filterVaultsByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor
      });
    }
    getOrganizationPersonalLoginVaults() {
      return this.filterVaultsByQuery({
        descriptor: organizationPersonalVaultContentDescriptor,
        isUserJoined: true
      });
    }
    getOrganizationPersonalLoginVaultForUser(organizationId, userId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor,
        userId
      });
    }
    getOrganizationPersonalLoginVaultForProfile(organizationId, profileId) {
      return this.getVaultByQuery({
        organizationId,
        descriptor: organizationPersonalVaultContentDescriptor,
        profileId
      });
    }
    getInboxVaults() {
      return this.filterVaultsByQuery({ vaultTypes: [VaultType.INBOX] });
    }
    getInboxVaultPairById(vaultId) {
      const login = this.getLoginVaultById(vaultId);
      if (!login) {
        return null;
      }
      const meta = this.getTeamMetaVaultForTeamVault(login);
      if (!meta) {
        return null;
      }
      return { login, meta, type: VaultType.INBOX };
    }
    withDeleteVault(vaultId) {
      const modifiedVaults = this.vaults.filter((vault) => !uuidEqual(vault.id, vaultId));
      if (modifiedVaults.length === this.vaults.length) {
        throw new VaultNotFoundError(vaultId);
      }
      return new VaultRepo(modifiedVaults);
    }
    withDeleteWithoutMatchingProfileLocks(profileIds) {
      const modifiedVaults = this.vaults.filter((vault) => {
        return !vault.profileLock || profileIds.includes(vault.profileLock.lockingProfileId);
      });
      if (modifiedVaults.length === this.vaults.length) {
        return this;
      }
      return new VaultRepo(modifiedVaults);
    }
    withUpdateVaults(...updatedVaults) {
      const vaults = [...this.vaults];
      for (const updatedVault of updatedVaults) {
        const i2 = vaults.findIndex((vault) => uuidEqual(vault.id, updatedVault.id));
        if (i2 >= 0) {
          vaults[i2] = updatedVault;
        } else {
          vaults.push(updatedVault);
        }
      }
      return new VaultRepo(vaults);
    }
    getVaultByQuery(...queries) {
      const vault = this.vaults.find(makeVaultPredicate(queries));
      return vault !== null && vault !== void 0 ? vault : null;
    }
    filterVaultsByQuery(...queries) {
      const vaults = this.vaults.filter(makeVaultPredicate(queries));
      return vaults !== null && vaults !== void 0 ? vaults : null;
    }
    getTeamVaultPairsByQuery(query) {
      return this.filterVaultsByQuery(Object.assign({ descriptor: loginVaultContentDescriptor, vaultTypes: [VaultType.TEAM] }, query)).flatMap((vault) => {
        const meta = this.getTeamMetaVaultForTeamVault(vault);
        if (!meta) {
          return [];
        }
        return {
          login: vault,
          meta,
          type: VaultType.TEAM
        };
      });
    }
    makeLoginVaultPair(login) {
      if (login.type === VaultType.TEAM) {
        const meta = this.getTeamMetaVaultForTeamVault(login);
        if (!meta) {
          return null;
        }
        return {
          type: VaultType.TEAM,
          login,
          meta
        };
      }
      if (login.type === VaultType.PRIVATE) {
        return {
          type: login.type,
          login
        };
      }
      if (login.type === VaultType.INBOX) {
        const meta = this.getTeamMetaVaultForTeamVault(login);
        if (!meta) {
          return null;
        }
        return {
          meta,
          type: login.type,
          login
        };
      }
      if (login.type === VaultType.ORGANIZATION_PERSONAL) {
        return {
          type: login.type,
          login
        };
      }
      throw new UnsupportedLoginVaultTypeError();
    }
    getTeamMetaVaultForTeamVault(loginVault) {
      if (![VaultType.TEAM, VaultType.INBOX].some((t) => loginVault.type === t)) {
        throw new IncorrectVaultTypeError(loginVault.id, VaultType.TEAM, loginVault.type);
      }
      if (!loginVault.associatedVaultId) {
        throw new TeamVaultMissingAssociatedMetaVaultError(loginVault.id);
      }
      return this.getTeamMetaVaultById(loginVault.associatedVaultId);
    }
  }
  function makeVaultPredicate(queries) {
    return (v2) => {
      return queries.some(({ descriptor, vaultId, organizationId, vaultTypes, userId, profileId, isUserJoined }) => (!descriptor || descriptor.vaultTypes.includes(v2.type) && descriptor.contentTypeName === v2.getContentType()) && (!vaultId || uuidEqual(v2.id, vaultId)) && (!organizationId || v2.organizationId === organizationId) && (!vaultTypes || vaultTypes.includes(v2.type)) && (!userId || v2.userIds.includes(userId)) && (!profileId || v2.profileIds.includes(profileId)) && (isUserJoined === void 0 || v2.isUserJoined == isUserJoined));
    };
  }
  var __decorate$2 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest = globalThis && globalThis.__rest || function(s2, e) {
    var t = {};
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2) && e.indexOf(p2) < 0)
        t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  };
  var ClientCore_1;
  const SALT_SESSION_ENCRYPTION_KEY_SIGNATURE = "salt-session-encryption-key-signature-";
  let ClientCore = ClientCore_1 = class ClientCore {
    constructor(vaultRepo, profileRepo, backendClient, params, accountState, pinnedAuthenticatorSecret, syncVersion = null, tokenRefreshNeeded = false, superUserUnlockedAuthenticators = {}, foreignVaultSyncPredicate = {}, ephemeralForeignVaultSyncPredicate = {}, ignoredUnlock = null, lastKnownServerTime = null, clientServerTimeOffsetMs = null, auditlogEventQueue = [], auditlogWriteTokenCache = new OrganizationAuthTokenCache(), clientOutdated = false) {
      this.vaultRepo = vaultRepo;
      this.profileRepo = profileRepo;
      this.backendClient = backendClient;
      this.params = params;
      this.accountState = accountState;
      this.pinnedAuthenticatorSecret = pinnedAuthenticatorSecret;
      this.syncVersion = syncVersion;
      this.tokenRefreshNeeded = tokenRefreshNeeded;
      this.superUserUnlockedAuthenticators = superUserUnlockedAuthenticators;
      this.foreignVaultSyncPredicate = foreignVaultSyncPredicate;
      this.ephemeralForeignVaultSyncPredicate = ephemeralForeignVaultSyncPredicate;
      this.ignoredUnlock = ignoredUnlock;
      this.lastKnownServerTime = lastKnownServerTime;
      this.clientServerTimeOffsetMs = clientServerTimeOffsetMs;
      this.auditlogEventQueue = auditlogEventQueue;
      this.auditlogWriteTokenCache = auditlogWriteTokenCache;
      this.clientOutdated = clientOutdated;
      this.mutex = new Mutex$1();
      this.protectedSecretRepo = null;
      this.maintenanceSettings = null;
      if (pinnedAuthenticatorSecret) {
        const hsc = HighSecurityCache.fromSecret(pinnedAuthenticatorSecret, params.unlockedAuthenticator.authenticator);
        this.protectedSecretRepo = ProtectedSecretRepo.create(this.getClientCoreState(), hsc, null);
      }
    }
    static onlineLoad(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (!pcc) {
          return this.onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret);
        }
        try {
          return this.createFromPersistable(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret);
        } catch (e) {
          trackError(e);
          return this.onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret);
        }
      });
    }
    static onlineInitializeFromLogin(clientCoreParameters, backendClient, syncUpdate, authenticatorSecret, customSessionData) {
      return __awaiter$5(this, void 0, void 0, function* () {
        const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
        const { userId } = clientCoreParameters.loginData;
        const authListDto = yield authorizedBackendClient.authenticator.list();
        const accountState = AccountState.fromSyncUpdate(userId, syncUpdate).withAuthenticatorList(authListDto);
        const vaultRepo = VaultRepo.create();
        const profileRepo = ProfileRepo.create([], []);
        const clientCore = new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, authenticatorSecret);
        yield clientCore.onlineEnsureSessionMetaUpToDate((_, others) => customSessionData ? customSessionData(others) : {}, syncUpdate);
        return clientCore;
      });
    }
    static createFromPersistable(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret) {
      var _a2, _b2;
      if (clientCoreParameters.unlockedAuthenticator.authenticator.authenticatorType === AuthenticatorType.BACKUP_CODE) {
        throw new LoginWithRecoveryError();
      }
      const accountState = AccountState.fromPersistable(pcc.accountState);
      if (accountState.userId !== clientCoreParameters.loginData.userId) {
        throw new PersistableMismatchError(accountState.userId, clientCoreParameters.loginData.userId);
      }
      const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
      const profileRepo = ProfileRepo.createFromPersistable(pcc.profileRepo, clientCoreParameters.unlockedAuthenticator);
      const vaultRepo = VaultRepo.createFromPersistable(pcc.vaultRepo, profileRepo, pcc.superUserUnlockedAuthenticators);
      return new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, pinnedAuthenticatorSecret !== null && pinnedAuthenticatorSecret !== void 0 ? pinnedAuthenticatorSecret : null, (_a2 = pcc.lastKnownSyncVersion) !== null && _a2 !== void 0 ? _a2 : null, false, pcc.superUserUnlockedAuthenticators, pcc.foreignVaultSyncPredicate, void 0, (_b2 = pcc.ignoredUnlock) !== null && _b2 !== void 0 ? _b2 : null, null, null, pcc.auditlogEventQueue);
    }
    static onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (clientCoreParameters.unlockedAuthenticator.authenticator.authenticatorType === AuthenticatorType.BACKUP_CODE) {
          throw new LoginWithRecoveryError();
        }
        const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
        const { userId } = clientCoreParameters.loginData;
        const syncUpdate = yield authorizedBackendClient.sync.poll();
        const authListDto = yield authorizedBackendClient.authenticator.list();
        const accountState = AccountState.fromSyncUpdate(userId, syncUpdate).withAuthenticatorList(authListDto);
        const vaultRepo = VaultRepo.create();
        const profileRepo = ProfileRepo.create([], []);
        return new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, pinnedAuthenticatorSecret !== null && pinnedAuthenticatorSecret !== void 0 ? pinnedAuthenticatorSecret : null);
      });
    }
    static onlineRecoverWithNewAuthenticator(clientCoreParameters, backendClient, unsyncedAuthenticator, hsc, extraAuthenticators = []) {
      return __awaiter$5(this, void 0, void 0, function* () {
        const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
        const { userId } = clientCoreParameters.loginData;
        const syncUpdate = yield authorizedBackendClient.sync.poll();
        const accountState = AccountState.fromSyncUpdate(userId, syncUpdate);
        const vaultRepo = VaultRepo.create();
        const profileRepo = ProfileRepo.create([], []);
        const clientCore = new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, null);
        yield clientCore.onlineSyncWithUpdate(syncUpdate, "init");
        const authIds = yield clientCore.onlineAddAuthenticators([unsyncedAuthenticator, ...extraAuthenticators], hsc);
        yield clientCore.onlineLogoutSession(clientCore.getSessionId());
        const hsua = unsyncedAuthenticator.withId(authIds[0]);
        const loginChallenge = yield backendClient.credential.createChallenge(null, null, userId);
        const newClientCoreParameters = yield finishChallengeSelfUnlocking({
          client: backendClient,
          hsua,
          challenge: loginChallenge.challenge,
          userId,
          sessionType: SessionType.SELF_UNLOCKING_PRIMARY
        });
        return {
          clientCoreParameters: Object.assign(Object.assign({}, newClientCoreParameters), { unlockedAuthenticator: hsua.getUnlockedAuthenticator() }),
          extraAuthenticatorIds: authIds.slice(1)
        };
      });
    }
    getPersistable() {
      var _a2;
      let lastKnownSyncVersion;
      if (this.syncVersion && this.accountState.serverSideSettings.persistLastKnownSyncVersion) {
        lastKnownSyncVersion = this.syncVersion;
      }
      return {
        vaultRepo: this.vaultRepo.getPersistable(this.foreignVaultSyncPredicate),
        profileRepo: this.profileRepo.getPersistable(this.params.unlockedAuthenticator),
        accountState: this.accountState.getPersistable(),
        lastKnownSyncVersion,
        superUserUnlockedAuthenticators: this.superUserUnlockedAuthenticators,
        foreignVaultSyncPredicate: this.foreignVaultSyncPredicate,
        ignoredUnlock: (_a2 = this.ignoredUnlock) !== null && _a2 !== void 0 ? _a2 : void 0,
        auditlogEventQueue: this.auditlogEventQueue
      };
    }
    getClientCoreParameters() {
      if (!this.backendClient.config.loginData) {
        throw new LoginDataMissingError();
      }
      return this.params;
    }
    getSessionId() {
      return this.backendClient.getSessionId();
    }
    getLoginVaultById(vaultId) {
      return this.vaultRepo.getLoginVaultById(vaultId);
    }
    getPrivateLoginVault() {
      return this.vaultRepo.getPrivateLoginVault();
    }
    getAchievements() {
      return [...this.accountState.achievements];
    }
    getLoginVaultProtectedSecret(v2, hsc) {
      const vaultAccess = getVaultAccess(this.getClientCoreState(), hsc, v2);
      return unlockLockProtectedSecret(vaultAccess, v2.authenticatorLocks, v2.profileLock, v2.adminProfileLock, this.profileRepo, hsc);
    }
    addLogin(options) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => addLogin(ccs, options));
      });
    }
    modifyLogin(options) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => modifyLogin(ccs, options));
      });
    }
    addOrModifyLogin(options) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => addOrModifyLogin(ccs, options));
      });
    }
    createInitialLoginHistoryEntryIfNecessary(options) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => createInitialLoginHistoryEntryIfNecessary(ccs, options));
      });
    }
    copyLogins(toId, ...fromLogins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => copyLogins(ccs, toId, fromLogins));
      });
    }
    moveLogins(toId, ...fromLogins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => moveLogins(ccs, toId, fromLogins));
      });
    }
    deleteOrArchiveLogins(...fromLogins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => deleteOrArchiveLogins(ccs, fromLogins));
      });
    }
    restoreArchivedLogins(...fromLogins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => restoreArchivedLogins(ccs, fromLogins));
      });
    }
    deleteArchivedLogins(...fromLogins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => deleteArchivedLogins(ccs, fromLogins));
      });
    }
    modifyTagsForLogin(options) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => modifyTagsForLogin(ccs, options));
      });
    }
    modifyLinkedViewSecretsForLogin(targetVaultId, loginId, linkedViewSecrets) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => modifyLinkedViewSecretsForLogin(ccs, targetVaultId, loginId, linkedViewSecrets));
      });
    }
    importLogins({ targetVaultId, emptyNameCustomFieldDefaultName }, ...logins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => importLogins(ccs, targetVaultId, logins, emptyNameCustomFieldDefaultName));
      });
    }
    ingestLoginUpdate(options) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => ingestLoginUpdate(ccs, options));
      });
    }
    deleteOutdatedLoginData(vaultId, loginId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$5(this, void 0, void 0, function* () {
          let newCcs = Object.assign({}, ccs);
          newCcs = yield internalDeleteOutdatedLoginHistory(newCcs, vaultId, loginId);
          newCcs = yield internalDeleteOutdatedShareLinks(newCcs, vaultId, loginId);
          return newCcs;
        }));
      });
    }
    onlineLinkLoginsToTeam(orgId, teamVaultId, ...fromLogins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield onlineCheckCanLinkToVault(this.backendClient, orgId, teamVaultId);
        return this.modifyClientCore((ccs) => linkLoginsToTeam(ccs, orgId, teamVaultId, fromLogins));
      });
    }
    onlineLinkLoginsToPersonalProfile(orgId, profileId, ...fromLogins) {
      return __awaiter$5(this, void 0, void 0, function* () {
        const personalVaultId = findPersonalVaultId(this.accountState, this.vaultRepo, orgId, profileId);
        yield onlineCheckCanLinkToVault(this.backendClient, orgId, personalVaultId);
        return this.modifyClientCore((ccs) => linkLoginsToPersonalVault(ccs, orgId, profileId, fromLogins));
      });
    }
    unlinkLogins(fromId, toId, ...loginIds) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => unlinkLogins(ccs, fromId, toId, loginIds));
      });
    }
    onlineLoginShareLinkCreate(vaultId, loginId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("loginShareLinkCreate", (ccs) => onlineInternalLoginShareLinkCreate$1(ccs, vaultId, loginId), "result");
      });
    }
    onlineLoginShareLinkDelete(vaultId, loginId, shareLinkId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("loginShareLinkDelete", (ccs) => onlineInternalLoginShareLinkCreate(ccs, vaultId, loginId, shareLinkId), "result");
      });
    }
    onlineUserConfirmationCreate(data) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("userConfirmationCreate", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const { id, syncUpdate, webauthnOptionsJson } = yield ccs.backendClient.userConfirmations.create(data);
          const webauthnOptions = webauthnOptionsJson ? unmarshalCredentialRequestOptions(webauthnOptionsJson) : void 0;
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: { id, webauthnOptions } });
        }), "result");
      });
    }
    onlineUserConfirmationGet(id) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.backendClient.userConfirmations.get(id);
      });
    }
    onlineUserConfirmationSendAuthenticatorResult(id, type) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineUserConfirmationSendAuthenticatorResult", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const su = yield ccs.backendClient.userConfirmations.sendResult(id, type, void 0);
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    onlineUserConfirmationSendWebauthnResult(id, type, webauthnResponse) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineUserConfirmationSendWebauthnResult", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const webauthnResponseJson = webauthnResponse ? marshalAssertionPublicKeyCredential(webauthnResponse) : void 0;
          const su = yield ccs.backendClient.userConfirmations.sendResult(id, type, webauthnResponseJson);
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    onlineUserConfirmationRetrieveResult(id) {
      return __awaiter$5(this, void 0, void 0, function* () {
        const { resultType } = yield this.backendClient.userConfirmations.retrieveResult(id);
        return resultType;
      });
    }
    onlineUserConfirmationCancel(id) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("userConfirmationCancel", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const su = yield ccs.backendClient.userConfirmations.cancel(id);
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    modifyLoginVaultForTest(vaultId, mod, hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
          if (!vault) {
            throw new VaultNotFoundError(vaultId);
          }
          const mod2 = (vaultContent, t, modificationFunctions) => {
            const result2 = mod(vaultContent, t, modificationFunctions);
            return Object.assign(Object.assign({}, result2), { auditlogEvents: [] });
          };
          return modifyLoginVault(ccs, vault, mod2, hsc);
        }));
      });
    }
    modifyTeamMetaVault(vaultId, mod) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const vault = ccs.vaultRepo.getTeamMetaVaultById(vaultId);
          if (!vault) {
            throw new VaultNotFoundError(vaultId);
          }
          return modifyVault(ccs, vault, mod);
        }));
      });
    }
    modifyMetaVault(mod) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const vault = ccs.vaultRepo.getMetaVault();
          if (!vault) {
            throw new MetaVaultNotFoundError();
          }
          return modifyVault(ccs, vault, mod);
        }));
      });
    }
    migrateBackupCode(backupCode, hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var _b2;
          var ccs = __rest(_a2, []);
          const vault = ccs.vaultRepo.getMetaVault();
          if (!vault) {
            throw new MetaVaultNotFoundError();
          }
          if ((_b2 = getAccountSettings(vault.getContent())) === null || _b2 === void 0 ? void 0 : _b2.backupCode) {
            trackError("cor: onlineMigrateBackupCode called with backup code already migrated");
            return ccs;
          }
          ccs = modifyVault(ccs, vault, (c2, t, { modifyAccountSettings: modifyAccountSettings2, protect: protect2 }) => modifyAccountSettings2(c2, t, {
            backupCode: protect2({ unencrypted: backupCode, contentId: newUuid$1() })
          }), true, hsc);
          ccs.accountState = ccs.accountState.withLocalAchievements([
            Achievement.COR_STORE_BACKUP_CODE_META_VAULT
          ]);
          return ccs;
        }));
      });
    }
    modifyLegacyOrganizationAdminVault(vaultId, mod, hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const vault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(vaultId);
          if (!vault) {
            throw new VaultNotFoundError(vaultId);
          }
          return modifyVault(ccs, vault, mod, true, hsc);
        }));
      });
    }
    addAchievement(...achievements) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          ccs.accountState = ccs.accountState.withLocalAchievements(achievements);
          return ccs;
        }));
      });
    }
    getMetaContent() {
      var _a2, _b2;
      return (_b2 = (_a2 = this.vaultRepo.getMetaVault()) === null || _a2 === void 0 ? void 0 : _a2.getContent()) !== null && _b2 !== void 0 ? _b2 : null;
    }
    isUnlocked() {
      var _a2;
      return !!((_a2 = this.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.isUnlocked());
    }
    isPinnedUnlocked() {
      return !!this.pinnedAuthenticatorSecret;
    }
    modifyClientCore(modify) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.internalModifyClientCore(modify, null, null);
      });
    }
    onlineModifyClientCore(clientOperationName, modify, eventOrigin) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.internalModifyClientCore(modify, eventOrigin, clientOperationName);
      });
    }
    internalModifyClientCore(modify, eventOrigin, clientOperationName) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.mutex.runExclusive(() => __awaiter$5(this, void 0, void 0, function* () {
          var _a2, _b2, _c2, _d2;
          if (eventOrigin) {
            yield this.emitter.emit("syncStart", { eventOrigin });
          }
          const backendClient = clientOperationName ? this.backendClient.withClientOperation(newUniURI(), clientOperationName, (_a2 = this.syncVersion) !== null && _a2 !== void 0 ? _a2 : void 0) : void 0;
          if (clientOperationName) {
            addBreadcrumb$1({
              type: "info",
              category: "onlineModifyClientCore",
              data: {
                clientOperationName,
                clientOperationId: backendClient === null || backendClient === void 0 ? void 0 : backendClient.config.clientOperationId
              }
            });
          }
          const oldCcs = Object.assign(Object.assign({}, this.getClientCoreState()), { backendClient });
          let newCcs;
          try {
            newCcs = yield modify(oldCcs);
          } catch (e) {
            if (eventOrigin) {
              yield this.emitter.emit("syncEnd", { eventOrigin });
            }
            throw e;
          }
          this.vaultRepo = newCcs.vaultRepo;
          this.profileRepo = newCcs.profileRepo;
          this.accountState = newCcs.accountState;
          this.protectedSecretRepo = newCcs.protectedSecretRepo;
          this.syncVersion = newCcs.syncVersion;
          this.tokenRefreshNeeded = newCcs.tokenRefreshNeeded;
          this.superUserUnlockedAuthenticators = newCcs.superUserUnlockedAuthenticators;
          this.foreignVaultSyncPredicate = newCcs.foreignVaultSyncPredicate;
          this.ephemeralForeignVaultSyncPredicate = newCcs.ephemeralForeignVaultSyncPredicate;
          this.ignoredUnlock = newCcs.ignoredUnlock;
          this.maintenanceSettings = newCcs.maintenanceSettings;
          this.lastKnownServerTime = newCcs.lastKnownServerTime;
          this.clientOutdated = newCcs.clientOutdated;
          this.clientServerTimeOffsetMs = newCcs.clientServerTimeOffsetMs;
          this.auditlogEventQueue = newCcs.auditlogEventQueue;
          this.auditlogWriteTokenCache = newCcs.auditlogWriteTokenCache;
          if (newCcs.ignoredUnlock !== oldCcs.ignoredUnlock) {
            this.emitter.emit("ignoredUnlockChange").catch(trackError);
          }
          if (newCcs.accountState && newCcs.accountState !== oldCcs.accountState) {
            this.emitter.emit("accountStateChange", {
              oldAccountState: oldCcs.accountState,
              newAccountState: newCcs.accountState
            }).catch(trackError);
          }
          if (newCcs.protectedSecretRepo !== oldCcs.protectedSecretRepo && ((_b2 = newCcs.protectedSecretRepo) === null || _b2 === void 0 ? void 0 : _b2.isUnlocked()) !== ((_c2 = oldCcs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.isUnlocked())) {
            const isUnlocked = !!((_d2 = newCcs.protectedSecretRepo) === null || _d2 === void 0 ? void 0 : _d2.isUnlocked());
            this.emitter.emit("unlockedChange", { isUnlocked }).catch(trackError);
            addBreadcrumb$1({
              type: "info",
              category: "unlockedChange",
              data: { isUnlocked }
            });
          }
          if (newCcs.profileRepo !== oldCcs.profileRepo) {
            this.emitter.emit("profileRepoChange", {
              oldProfileRepo: oldCcs.profileRepo,
              newProfileRepo: newCcs.profileRepo
            }).catch(trackError);
          }
          if (newCcs.vaultRepo !== oldCcs.vaultRepo) {
            this.emitter.emit("vaultRepoChange", {
              oldVaultRepo: oldCcs.vaultRepo,
              newVaultRepo: newCcs.vaultRepo
            }).catch(trackError);
          }
          if (eventOrigin) {
            yield this.emitter.emit("syncEnd", { eventOrigin });
          } else if (newCcs.vaultRepo !== oldCcs.vaultRepo) {
            yield this.emitter.emit("localVaultChange");
          }
          if (newCcs.tokenRefreshNeeded) {
            yield this.emitter.emit("clientCoreParametersRefreshNeeded");
          }
          return newCcs.returnResult;
        }));
      });
    }
    batchModify(performBatchModification, pinnedSecret) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.internalBatchModify(performBatchModification, null, pinnedSecret);
      });
    }
    onlineBatchModify(performBatchModification, pinnedSecret) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.internalBatchModify(performBatchModification, "result", pinnedSecret);
      });
    }
    // This method can be called with a pinnedSecret as a temporary unlock. Please note that this way
    // is a relatively expensive operation, and should only be called in ways that don't affect
    // responsiveness.
    internalBatchModify(performBatchModification, eventOrigin, pinnedSecret) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.internalModifyClientCore((_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const batchCC = new ClientCore_1(ccs.vaultRepo, ccs.profileRepo, ccs.backendClient, ccs.params, ccs.accountState, pinnedSecret !== null && pinnedSecret !== void 0 ? pinnedSecret : ccs.pinnedAuthenticatorSecret, ccs.syncVersion, ccs.tokenRefreshNeeded, ccs.superUserUnlockedAuthenticators, ccs.foreignVaultSyncPredicate, ccs.ephemeralForeignVaultSyncPredicate, ccs.ignoredUnlock, ccs.lastKnownServerTime, ccs.clientServerTimeOffsetMs, ccs.auditlogEventQueue, ccs.auditlogWriteTokenCache);
          batchCC.maintenanceSettings = ccs.maintenanceSettings;
          if (!pinnedSecret) {
            batchCC.protectedSecretRepo = ccs.protectedSecretRepo;
          }
          const returnResult = yield performBatchModification(batchCC);
          if (pinnedSecret && !ccs.protectedSecretRepo) {
            batchCC.protectedSecretRepo = null;
          }
          return Object.assign(Object.assign({}, batchCC.getClientCoreState()), { backendClient: batchCC.backendClient, returnResult });
        }), eventOrigin, "batch");
      });
    }
    onlineEnsureSessionMetaUpToDate(customSessionData, syncUpdate = null) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("ensureSessionMetaUpToDate", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var _b2;
          var ccs = __rest(_a2, []);
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          const ownSessionId = ccs.backendClient.getSessionId();
          const otherSessionIds = ccs.accountState.sessions.map((s2) => s2.id).filter((s2) => s2 !== ownSessionId);
          const metaVault = ccs.vaultRepo.getMetaVault();
          if (!metaVault) {
            return ccs;
          }
          const allSessionMeta = metaVault.getContent().sessions;
          const ownSessionMeta = (_b2 = allSessionMeta[ownSessionId]) !== null && _b2 !== void 0 ? _b2 : null;
          const otherSessionMeta = otherSessionIds.map((s2) => allSessionMeta[s2]).filter((m2) => m2);
          let fieldsToUpdate = customSessionData(ownSessionMeta, otherSessionMeta);
          if (ownSessionMeta === null) {
            fieldsToUpdate = Object.assign(Object.assign({}, fieldsToUpdate), { encPubKey: naclUtilExports.encodeBase64(ccs.params.sessionKeys.encPubKey), encPubKeySignature: naclUtilExports.encodeBase64(ccs.params.sessionKeys.encPubKeySignature), signingAuthId: ccs.params.sessionKeys.signingAuthId });
          }
          if (Object.keys(fieldsToUpdate).length) {
            ccs = internalUpdateMetaSession(ccs, ownSessionId, fieldsToUpdate);
            ccs = yield onlineInternalSync(ccs, syncUpdate);
          }
          return ccs;
        }), "result");
      });
    }
    updateMetaSession(sessionId, session) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.modifyClientCore((ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return internalUpdateMetaSession(ccs, sessionId, session);
        }));
      });
    }
    getSessions() {
      return this.accountState.sessions;
    }
    getSession() {
      const sessionId = this.getSessionId();
      const session = this.getSessions().find((s2) => s2.id === sessionId);
      if (!session) {
        throw new OwnSessionMissingError();
      }
      return session;
    }
    getSessionById(sessionId) {
      return this.getSessions().find((s2) => s2.id === sessionId);
    }
    getSessionMetaById(sessionId) {
      var _a2, _b2;
      const sessionMeta = (_a2 = this.getMetaContent()) === null || _a2 === void 0 ? void 0 : _a2.sessions;
      return (_b2 = sessionMeta === null || sessionMeta === void 0 ? void 0 : sessionMeta[sessionId]) !== null && _b2 !== void 0 ? _b2 : null;
    }
    ignoreCurrentUnlock() {
      return __awaiter$5(this, void 0, void 0, function* () {
        const session = this.getSession();
        if (this.pinnedAuthenticatorSecret) {
          throw new Error("cannot ignore unlock with pinned authenticator secret");
        }
        const { unlockedAt } = session;
        if (unlockedAt !== void 0) {
          yield this.modifyClientCore((_a2) => {
            var ccs = __rest(_a2, []);
            ccs.ignoredUnlock = unlockedAt;
            ccs.protectedSecretRepo = null;
            return Promise.resolve(ccs);
          });
        }
      });
    }
    getActiveChannels() {
      return this.accountState.channels;
    }
    getLoginRequests() {
      return this.accountState.channels.map((c2) => c2.id);
    }
    onlineSync(fcmMessageId, hsc = null) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("sync", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalSync(Object.assign({}, ccs), null, fcmMessageId, hsc);
        }), "poll");
      });
    }
    onlineSyncWithUpdate(syncUpdate, eventOrigin) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("syncWithUpdate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalSync(ccs, syncUpdate);
        }), eventOrigin);
      });
    }
    onlineLogoutSession(sessionId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        try {
          const syncUpdate = yield this.backendClient.deleteSession(sessionId);
          if (syncUpdate) {
            yield this.onlineSyncWithUpdate(syncUpdate, "result");
          }
        } catch (e) {
          if (e instanceof DomainError$1 && e.code === BackendErrorCode.SESSION_NOT_FOUND) {
            yield this.onlineSync();
            return;
          }
          throw e;
        }
      });
    }
    lockAllVaults() {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (this.pinnedAuthenticatorSecret) {
          return;
        }
        yield this.modifyClientCore((ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return Object.assign(Object.assign({}, ccs), { protectedSecretRepo: null });
        }));
      });
    }
    onlineRegenerateVault(hsc, vaultId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("regenerateVault", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          ccs = yield onlineInternalSync(ccs);
          return onlineInternalRegenerateVault(ccs, hsc, vaultId);
        }), "result");
      });
    }
    onlineRegenerateRecovery(backupCode, recoverySeed, parameters, hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("regenerateRecovery", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalRegenerateRecovery(ccs, backupCode, recoverySeed, parameters, hsc);
        }), "result");
      });
    }
    getBackupCode(hsc) {
      var _a2, _b2;
      const metaVault = this.vaultRepo.getMetaVault();
      if (!metaVault) {
        throw new MetaVaultNotFoundError();
      }
      let protectedSecretFunctions;
      if (hsc) {
        protectedSecretFunctions = ProtectedSecretRepo.create(this.getClientCoreState(), hsc, null).getProtectedSecretFunctions(metaVault);
      } else if ((_a2 = this.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.isUnlocked()) {
        protectedSecretFunctions = this.protectedSecretRepo.getProtectedSecretFunctions(metaVault);
      } else {
        throw new CannotUnprotectError();
      }
      const protectedBackupCode = (_b2 = getAccountSettings(metaVault.getContent())) === null || _b2 === void 0 ? void 0 : _b2.backupCode;
      if (!protectedBackupCode) {
        return;
      }
      return protectedSecretFunctions.unprotect(protectedBackupCode);
    }
    onlineRegenerateBackup(backupSeed, hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("regenerateBackup", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalRegenerateBackup(ccs, backupSeed, hsc);
        }), "result");
      });
    }
    onlineAddAuthenticators(authsToAdd, hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("addAuthenticators", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const result2 = yield onlineInternalModifyAuthenticators(ccs, hsc, [], authsToAdd);
          if (result2.returnResult.length === 0) {
            throw new NoAuthenticatorIdReceivedError();
          }
          return Object.assign(Object.assign({}, result2), { returnResult: result2.returnResult });
        }), "result");
      });
    }
    onlineRemoveAuthenticator(authenticatorId, hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("removeAuthenticator", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalModifyAuthenticators(ccs, hsc, [authenticatorId]);
        }), "result");
      });
    }
    onlineMigrateToAuthenticatorChain(hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (this.accountState.authenticatorBlockHash !== null) {
          return;
        }
        return this.onlineModifyClientCore("migrateToAuthenticatorChain", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalMigrateToAuthenticatorChain(ccs, hsc);
        }), "result");
      });
    }
    onlineProfilesRegenerate(hsc) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profilesRegenerate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalProfileRegenerate(ccs, hsc);
        }), "result");
      });
    }
    onlineOrganizationRegenerateProfiles(orgId, profiles) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRegenerateProfile", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const newCcs = yield onlineInternalOrganizationRegenerateProfiles(ccs, orgId, profiles);
          return Object.assign(Object.assign({}, newCcs), { returnResult: newCcs.returnResult });
        }), "result");
      });
    }
    onlineTeamCreate(name, organizationId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("teamCreate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalTeamCreate(ccs, name, organizationId);
        }), "result");
      });
    }
    onlineTeamDelete(vaultId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("teamDelete", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalTeamDelete(ccs, vaultId);
        }), "result");
      });
    }
    onlineTeamAddUsers(teamId, usersToAdd, skipInvite = false) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (usersToAdd.length === 0) {
          return;
        }
        return this.onlineModifyClientCore("teamAddUsers", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalTeamModifyUsers(ccs, teamId, { usersToAdd, skipInvite });
        }), "result");
      });
    }
    onlineTeamRemoveUsers(teamId, profileIds) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (profileIds.length === 0) {
          return;
        }
        return this.onlineModifyClientCore("teamRemoveUsers", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalTeamModifyUsers(ccs, teamId, {
            profileIdsToRemove: profileIds
          });
        }), "result");
      });
    }
    onlineTeamLeave(teamId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("teamLeave", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalTeamLeave(ccs, teamId);
        }), "result");
      });
    }
    teamSetUserPermissionLevels(teamId, ...users) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return internalTeamSetUserPermissionLevels(ccs, teamId, ...users);
        }));
      });
    }
    teamClearNewlyJoined(teamId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return internalTeamClearNewlyJoined(ccs, teamId);
        }));
      });
    }
    loginSetConfirmed(vaultId, loginId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.modifyClientCore((ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return internalLoginSetConfirmed(ccs, vaultId, loginId);
        }));
      });
    }
    onlineMaintainTeamSyncOrganizationMembers() {
      var _a2;
      return __awaiter$5(this, void 0, void 0, function* () {
        const task = MaintenanceTask.TEAM_SYNC_ORGANIZATION_MEMBERS_V2;
        if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
          return;
        }
        const teamsToChange = getTeamsWithSyncOrganizationMembersAndMismatchedUsers(this.vaultRepo, this.accountState);
        if (!teamsToChange.length) {
          return;
        }
        yield this.onlineModifyClientCore("maintainTeamSyncOrganizationMembers", (ccs) => {
          return onlineInternalMaintainTeamSyncOrganizationMembers(ccs);
        }, "result");
      });
    }
    onlineHandleLoginChallenge(channelId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return LoginFlowPushAuthenticator.create(
          channelId,
          // TODO: this is implicit, make this explicit
          this.params.unlockedAuthenticator.authenticator.id,
          this.backendClient
        );
      });
    }
    onlineRejectLoginChallenge(channelId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("rejectLoginChallenge", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const { syncUpdate } = yield ccs.backendClient.channel.delete(channelId);
          return syncUpdate ? onlineInternalSync(ccs, syncUpdate) : ccs;
        }), "result");
      });
    }
    onlineLongPollChannelSendSecret(publicKeyB64, authenticatorSeed, registration) {
      return __awaiter$5(this, void 0, void 0, function* () {
        const { publicKeyHash, authReply } = completeLongPollChannelReply(publicKeyB64, authenticatorSeed, registration);
        yield this.backendClient.credential.completeLongPollChannel(publicKeyHash, this.params.unlockedAuthenticator.authenticator.id, authReply);
      });
    }
    onlineCreateSessionUnlock(sessionId, encPubKey, encPubKeySignature, trustedSigPubKeys, hsc, expiresAt) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("createSessionUnlock", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          checkEncPubKeySignature(trustedSigPubKeys, encPubKey, encPubKeySignature, SALT_SESSION_ENCRYPTION_KEY_SIGNATURE);
          const encryptedSecret = hsc.getHighSecurityUnlockedAuthenticator().createEncryptedSecret(encPubKey);
          const syncUpdate = yield ccs.backendClient.session.createSessionUnlock(
            sessionId,
            // TODO: this is implicit, make this explicit
            this.params.unlockedAuthenticator.authenticator.id,
            encryptedSecret,
            expiresAt
          );
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineExtendSessionUnlock(lastUserActivity) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (this.getSession().unlockedAt === void 0) {
          return;
        }
        return this.onlineModifyClientCore("extendSessionUnlock", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.extendSessionUnlock(lastUserActivity);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineSendLoginEventNotification(vaultId, loginId, username, domain) {
      var _a2;
      return __awaiter$5(this, void 0, void 0, function* () {
        if (!((_a2 = this.accountState.serverSideSettings.eventNotifications) === null || _a2 === void 0 ? void 0 : _a2.enable)) {
          return;
        }
        const { description, iconType } = this.getSessionMetaById(this.getSessionId());
        const data = new TextEncoder().encode(JSON.stringify({
          type: "login",
          session: { description, iconType },
          vaultId,
          loginId,
          username,
          domain
        }));
        const messages2 = [];
        for (const s2 of this.getSessions()) {
          const meta = this.getSessionMetaById(s2.id);
          if (meta && (s2.sessionType === SessionType.SELF_UNLOCKING_PRIMARY || s2.sessionType === SessionType.SELF_UNLOCKING_SECONDARY)) {
            const payload = asymEncrypt(loadEncryptionPublicKey(meta.encPubKey), data);
            messages2.push({ sessionId: s2.id, payload });
          }
        }
        yield this.backendClient.session.sendSessionMessage(messages2);
      });
    }
    onlineDeleteSessionUnlock(sessionId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("deleteSessionUnlock", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.deleteSessionUnlock(sessionId);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineCancelRequestSessionUnlock(sessionId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("cancelRequestSessionUnlock", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.deleteSessionUnlock(sessionId, true);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineRequestSessionUnlock() {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("requestSessionUnlock", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.session.requestSessionUnlock();
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineSessionSetUnlockTimeLimit(unlockTimeLimit) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("sessionSetUnlockTimeLimit", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const sessionId = ccs.params.loginData.sessionId;
          const su = yield ccs.backendClient.session.update(sessionId, [], { unlockTimeLimit });
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    onlineSessionSetProfileEnabled(profileId, enabled) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("sessionSetProfileEnabled", (ccs) => onlineInternalSessionSetProfileEnabled(ccs, profileId, enabled), "result");
      });
    }
    onlineSessionSetEnabledProfileIds(enabledProfileIds) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("sessionSetEnabledProfileIds", (ccs) => onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds), "result");
      });
    }
    onlineRequestProfileEmailChange(profileId, email) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("requestProfileEmailChange", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const resp = yield ccs.backendClient.profile.requestEmailChange(profileId, email);
          ccs = yield onlineInternalSync(ccs, resp.syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: { verificationEmailSent: resp.verificationEmailSent } });
        }), "result");
      });
    }
    onlineCancelProfileEmailChange(profileId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("cancelProfileEmailChange", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const syncUpdate = yield ccs.backendClient.profile.cancelEmailChange(profileId);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineSetPreferredLocale(preferredLocale) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("setPreferredLocale", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.account.update({
            preferredLocale
          });
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineProfileCreatePrivate(email) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profileCreatePrivate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalProfileCreatePrivate(ccs, email);
        }), "result");
      });
    }
    onlineProfileDeletePrivate(profileId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profileDeletePrivate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalProfileDeletePrivate(ccs, profileId);
        }), "result");
      });
    }
    onlineProfileClaimWithStartCode(profileId, startCode) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("profileClaimWithStartCode", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const result2 = yield ccs.backendClient.profile.claimWithStartCode(profileId, startCode);
          ccs = yield onlineInternalSync(ccs, result2.syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: result2.organizationId });
        }), "result");
      });
    }
    onlineOrganizationCreate(email, name, syncOrganizationMembersVaultName, options) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationCreate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          if (!(options === null || options === void 0 ? void 0 : options.legacy)) {
            return onlineInternalOrganizationCreate(ccs, email, name, syncOrganizationMembersVaultName, options);
          } else {
            return onlineInternalOrganizationCreateLegacy(ccs, email, name, syncOrganizationMembersVaultName, options);
          }
        }), "result");
      });
    }
    onlineOrganizationUpdate(orgId, fields) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationUpdate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const org = this.accountState.organizations.find((o) => o.id === orgId);
          if (!org) {
            throw new OrganizationNotFoundError();
          }
          const { passwordPolicy, clientSettings } = fields, restFields = __rest(fields, ["passwordPolicy", "clientSettings"]);
          const syncUpdate = yield ccs.backendClient.organization.update(orgId, Object.assign(Object.assign({}, restFields), { passwordPolicy: passwordPolicy === void 0 || passwordPolicy === null ? passwordPolicy : jsonStringifyFreeze(passwordPolicy), clientSettings: clientSettings ? jsonStringifyFreeze(Object.assign(Object.assign({}, org.clientSettings), clientSettings)) : void 0 }));
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationCreateFreeProfiles(orgId, emails, { isAdmin = false, createStartCodeAndSendMail } = {}) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationAddMember", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const resolvedEmails = yield ccs.backendClient.account.resolveEmails(emails, false);
          const createFreeProfiles = resolvedEmails.map(({ email, emailInvalid }) => {
            if (emailInvalid) {
              throw new DomainError$1(BackendErrorCode.INVALID_EMAIL, "invalid email", "Email address is invalid", `${email} is not a valid email address.`);
            }
            return {
              email,
              isAdmin,
              createStartCodeAndSendMail
            };
          });
          return onlineInternalOrganizationModifyMembers(ccs, orgId, { createFreeProfiles });
        }), "result");
      });
    }
    onlineOrganizationCreateServiceProfile(orgId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationCreateServiceProfile", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalOrganizationCreateServiceProfile(ccs, orgId);
        }), "result");
      });
    }
    onlineOrganizationUpdateMembers(orgId, membersToUpdate) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationUpdateMembers", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalOrganizationModifyMembers(ccs, orgId, {
            updateProfiles: membersToUpdate.flatMap((m2) => ({
              id: m2.profileId,
              isAdmin: m2.isAdmin
            }))
          });
        }), "result");
      });
    }
    onlineOrganizationRemoveMembers(orgId, profileIds) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRemoveMembers", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalOrganizationModifyMembers(ccs, orgId, {
            removeProfileIds: profileIds
          });
        }), "result");
      });
    }
    onlineOrganizationLeave(orgId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationLeave", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const su = yield ccs.backendClient.organization.leave(orgId);
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    onlineOrganizationDelete(orgId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationDelete", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalOrganizationDelete(ccs, orgId);
        }), "result");
      });
    }
    onlineOrganizationRedeemCoupon(orgId, coupon) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRedeemCoupon", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const org = ccs.accountState.getOrganization(orgId);
          if (!org) {
            throw new OrganizationNotFoundError();
          }
          if (!org.isAdmin) {
            throw new NoOrganizationAdminError();
          }
          const su = yield ccs.backendClient.withPermissionUserId(org.superUserId).organization.redeemCoupon(orgId, coupon);
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    onlineOrganizationEntraFinishAuthorization(search) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationEntraInitSync", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const response = yield ccs.backendClient.integrations.entraFinishAuthorization(search);
          const { syncUpdate } = response;
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: response });
        }), "result");
      });
    }
    onlineOrganizationEntraClearAuthorization(organizationId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationEntraClearAuthorization", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.integrations.entraClearAuthorization(organizationId);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationGoogleWorkspaceFinishAuthorization(search) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationGoogleWorkspaceFinishAuthorization", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const response = yield ccs.backendClient.integrations.googleWorkspaceFinishAuthorization(search);
          const { syncUpdate } = response;
          ccs = yield onlineInternalSync(ccs, syncUpdate);
          return Object.assign(Object.assign({}, ccs), { returnResult: response });
        }), "result");
      });
    }
    onlineOrganizationGoogleWorkspaceClearAuthorization(orgId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationGoogleWorkspaceFinishAuthorization", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const su = yield ccs.backendClient.integrations.googleWorkspaceClearAuthorization(orgId);
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    onlineOrganizationSetCsvIntegrationData(organizationId, csvIntegrationData, cancelToken) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationSetCsvIntegrationData", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const su = yield ccs.backendClient.integrations.csvSetIntegrationData(organizationId, csvIntegrationData ? JSON.stringify(csvIntegrationData) : null, cancelToken);
          return onlineInternalSync(ccs, su);
        }), "result");
      });
    }
    onlineOrganizationGetCsvIntegrationData(organizationId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return CsvIntegrationData.parse(JSON.parse(yield this.backendClient.integrations.csvGetIntegrationData(organizationId)));
      });
    }
    onlineOrganizationRegenerateAdminProfile(orgId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRegenerateAdminProfile", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalOrganizationRegenerateAdminProfile(ccs, orgId);
        }), "result");
      });
    }
    onlineChildOrganizationAddManager(organizationId, parentOrganizationProfileId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("childOrganizationAddManager", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalChildOrganizationAddManager(ccs, organizationId, parentOrganizationProfileId);
        }), "result");
      });
    }
    onlineChildOrganizationUpdate(childOrgId, fields) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("childOrganizationUpdate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const { parentOrganizationMetadata } = fields, restFields = __rest(fields, ["parentOrganizationMetadata"]);
          const syncUpdate = yield ccs.backendClient.childOrganization.update(childOrgId, Object.assign(Object.assign({}, restFields), { parentOrganizationMetadata: parentOrganizationMetadata === void 0 || parentOrganizationMetadata === null ? parentOrganizationMetadata : jsonStringifyFreeze(parentOrganizationMetadata) }));
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineInboxVaultCreate(slug, metadata, organizationId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("inboxVaultCreate", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalInboxVaultCreate(ccs, slug, metadata, organizationId);
        }), "result");
      });
    }
    onlineInboxVaultUpdate(vaultId, { slug, metadata }) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("inboxVaultModify", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const metadataJson = metadata !== void 0 ? jsonStringifyFreeze(metadata) : void 0;
          const syncUpdate = yield ccs.backendClient.vault.updateInbox(vaultId, {
            slug,
            metadataJson
          });
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineInboxVaultDelete(vaultId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("inboxVaultDelete", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalInboxVaultDelete(ccs, vaultId);
        }), "result");
      });
    }
    onlineMaintainMigrateToAdminProfile() {
      var _a2, _b2;
      return __awaiter$5(this, void 0, void 0, function* () {
        const task = MaintenanceTask.ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2;
        if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
          return;
        }
        const legacyOrgId = (_b2 = this.accountState.organizations.find((o) => o.adminProfileId === null)) === null || _b2 === void 0 ? void 0 : _b2.id;
        if (!legacyOrgId) {
          return;
        }
        yield this.onlineModifyClientCore("maintainMigrateToAdminProfile", (ccs) => {
          return onlineInternalOrganizationRegenerateAdminProfile(ccs, legacyOrgId);
        }, "result");
      });
    }
    onlineMaintainVaultMessages() {
      var _a2;
      return __awaiter$5(this, void 0, void 0, function* () {
        const task = MaintenanceTask.PROCESS_VAULT_MESSAGES_V2;
        if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
          return;
        }
        if (!hasProcessableVaultMessages(this.vaultRepo)) {
          return;
        }
        yield this.onlineModifyClientCore("maintainVaultMessages", (ccs) => {
          return onlineInternalMaintainVaultMessages(ccs);
        }, "result");
      });
    }
    onlineMaintainOrganizationPreliminaryProfiles() {
      var _a2;
      return __awaiter$5(this, void 0, void 0, function* () {
        const task = MaintenanceTask.ORGANIZATION_PRELIMINARY_PROFILES_V3;
        if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
          return;
        }
        const profiles = getOrganizationsProfilesWithPreliminaryUserId(this.accountState.organizations, this.profileRepo);
        if (!profiles.length) {
          return;
        }
        yield this.onlineModifyClientCore("maintainOrganizationPreliminaryProfiles", (ccs) => {
          return onlineMaintainOrganizationPreliminaryProfiles(ccs);
        }, "result");
      });
    }
    onlineSetUserClientSettings(updatedSettings) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("setUserClientSettings", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const userClientSettings = jsonStringifyFreeze(Object.assign(Object.assign({}, ccs.accountState.userClientSettings), updatedSettings));
          const syncUpdate = yield ccs.backendClient.account.update({
            userClientSettings
          });
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlinePerformMaintenance() {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (!this.isUnlocked()) {
          return;
        }
        yield this.onlineMaintainMigrateToAdminProfile().catch(trackError);
        const results = yield Promise.allSettled([
          this.onlineMaintainOrganizationPreliminaryProfiles(),
          this.onlineMaintainTeamSyncOrganizationMembers(),
          this.onlineMaintainVaultMessages()
        ]);
        results.filter((result2) => result2.status === "rejected").forEach(({ reason }) => trackError(reason));
      });
    }
    onlineWebauthnRegisterCredentialInit(type) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("webauthnRegisterCredentialInit", (ccs) => onlineInternalWebauthnRegisterCredentialInit(ccs, type), "result");
      });
    }
    onlineWebauthnRegisterCredentialFinish(requestId, cred) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnRegisterCredentialFinish", (ccs) => onlineInternalWebauthnRegisterCredentialFinish(ccs, requestId, cred), "result");
      });
    }
    onlineWebauthnDeleteCredentials(...ids) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnDeleteCredentials", (ccs) => onlineInternalWebauthnDeleteCredentials(ccs, ids), "result");
      });
    }
    onlineWebauthnUnlockSessionInit() {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("webauthnUnlockSessionInit", onlineInternalWebauthnUnlockSessionInit, "result");
      });
    }
    onlineWebauthnUnlockSessionFinish(requestId, cred) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnUnlockSessionFinish", (ccs) => onlineInternalWebauthnUnlockSessionFinish(ccs, requestId, cred), "result");
      });
    }
    onlineWebauthnEnablePrf(request, cred) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("webauthnEnablePrf", (ccs) => onlineInternalWebauthnEnablePrf(ccs, request, cred), "result");
      });
    }
    onlineWebauthnEnablePrfOpportunistically(request, result2) {
      var _a2;
      return __awaiter$5(this, void 0, void 0, function* () {
        const task = MaintenanceTask.ENABLE_PRF_OPPORTUNISTICALLY_V1;
        if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
          return;
        }
        const isAlreadyEnabled = this.accountState.authenticators.some((a2) => {
          var _a3;
          return ((_a3 = a2.webauthn) === null || _a3 === void 0 ? void 0 : _a3.webauthnId) === result2.id;
        });
        if (isAlreadyEnabled) {
          return;
        }
        const isSessionBound = this.accountState.webauthnCredentials.some((wc) => wc.webauthnId === result2.id && wc.sessionId !== null);
        if (isSessionBound) {
          return;
        }
        yield this.onlineWebauthnEnablePrf(request, result2);
      });
    }
    onlineModifyForeignVaultSyncPredicate(predicateModification) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (!this.backendClient.config.syncSuperUsers) {
          throw new Error("onlineModifyForeignVaultSyncPredicate requires syncSuperUsers!");
        }
        yield this.onlineModifyClientCore("modifyForeignVaultSyncPredicate", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const newPredicate = predicateModification(ccs.foreignVaultSyncPredicate);
          if (deepEqual$1(ccs.foreignVaultSyncPredicate, newPredicate)) {
            return ccs;
          }
          ccs.foreignVaultSyncPredicate = newPredicate;
          ccs.syncVersion = null;
          ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
          ccs = yield onlineInternalSync(ccs);
          return ccs;
        }), "result");
      });
    }
    onlineModifyEphemeralForeignVaultSyncPredicate(predicateModification) {
      return __awaiter$5(this, void 0, void 0, function* () {
        if (!this.backendClient.config.syncSuperUsers) {
          throw new Error("onlineModifyEphemeralForeignVaultSyncPredicate requires syncSuperUsers!");
        }
        yield this.onlineModifyClientCore("modifyEphemeralForeignVaultSyncPredicate", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const newPredicate = predicateModification(ccs.ephemeralForeignVaultSyncPredicate);
          if (deepEqual$1(ccs.ephemeralForeignVaultSyncPredicate, newPredicate)) {
            return ccs;
          }
          ccs.ephemeralForeignVaultSyncPredicate = newPredicate;
          ccs.syncVersion = null;
          ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
          ccs = yield onlineInternalSync(ccs);
          return ccs;
        }), "result");
      });
    }
    auditlogWriteEventsWithRetry(orgId, ...events) {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.onlineModifyClientCore("auditlogWriteEventsWithRetry", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const queuedEvents = events.map((event) => {
            var _a3;
            return {
              organizationId: orgId,
              clientTime: /* @__PURE__ */ new Date(),
              lastKnownServerTime: (_a3 = ccs.lastKnownServerTime) !== null && _a3 !== void 0 ? _a3 : /* @__PURE__ */ new Date(0),
              event
            };
          });
          const newCcs = yield onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, queuedEvents);
          if (newCcs.returnResult === AuditlogWriteResult.Retry) {
            newCcs.auditlogEventQueue = [...newCcs.auditlogEventQueue, ...queuedEvents];
          }
          return newCcs;
        }), "result");
      });
    }
    onlineAuditlogWriteEvents(orgId, ...events) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("auditlogWriteQueuedEvents", (_a2) => __awaiter$5(this, void 0, void 0, function* () {
          var ccs = __rest(_a2, []);
          const queuedEvents = events.map((event) => Object.assign({ organizationId: orgId }, event));
          return onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, queuedEvents);
        }), "result");
      });
    }
    onlineAuditlogGetEvents(orgId, page, filter2, anchor, cancelToken) {
      return __awaiter$5(this, void 0, void 0, function* () {
        const auditlogClient = yield this.onlineGetAuditlogAdminClient(orgId, cancelToken);
        const { events, totalCount, timeAnchor: newTimeAnchor } = yield auditlogClient.listEvents(page, filter2, anchor, cancelToken);
        return {
          events: events.map((e) => AuditlogEventEnvelope.parse(JSON.parse(e))),
          totalCount,
          timeAnchor: newTimeAnchor
        };
      });
    }
    onlineGetAuditlogAdminClient(orgId, cancelToken) {
      return __awaiter$5(this, void 0, void 0, function* () {
        const token = yield this.backendClient.credential.createAuditlogAdminToken(orgId, cancelToken);
        return this.backendClient.getAuditlogAdminClient(token);
      });
    }
    onlineCreateRefreshedClientCoreParameters() {
      return __awaiter$5(this, void 0, void 0, function* () {
        const currentCcp = this.getClientCoreParameters();
        const newToken = yield this.backendClient.credential.refreshToken();
        const newCcp = Object.assign(Object.assign({}, currentCcp), { loginData: Object.assign(Object.assign({}, currentCcp.loginData), { token: newToken }) });
        return newCcp;
      });
    }
    onlineOrganizationRenewStartCodes(orgId, ...profileIds) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRenewStartCodes", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.organization.renewProfileStartCode(orgId, ...profileIds);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationSendStartCodeEmails(orgId, ...profileIds) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationSendStartCodeEmails", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.organization.sendStartCodeEmail(orgId, ...profileIds);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationRevokeStartCodes(orgId, ...profileIds) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("organizationRevokeStartCodes", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          const syncUpdate = yield ccs.backendClient.organization.revokeProfileStartCode(orgId, ...profileIds);
          return onlineInternalSync(ccs, syncUpdate);
        }), "result");
      });
    }
    onlineOrganizationGetBreachData(organizationId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.backendClient.organization.getBreachData(organizationId);
      });
    }
    onlineOrganizationStoreUnsafeVaultContents(organizationId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineOrganizationStoreUnsafeVaultStates", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalOrganizationStoreUnsafeVaultContents(ccs, organizationId);
        }), "result");
      });
    }
    onlineOrganizationRestoreUnsafeVaultContents(organizationId) {
      return __awaiter$5(this, void 0, void 0, function* () {
        return this.onlineModifyClientCore("onlineOrganizationRestoreVaultStates", (ccs) => __awaiter$5(this, void 0, void 0, function* () {
          return onlineInternalOrganizationRestoreUnsafeVaultContents(ccs, organizationId);
        }), "result");
      });
    }
    debugEmitClientCoreParametersRefreshNeeded() {
      return __awaiter$5(this, void 0, void 0, function* () {
        yield this.emitter.emit("clientCoreParametersRefreshNeeded");
      });
    }
    getClientCoreState() {
      return {
        params: this.params,
        pinnedAuthenticatorSecret: this.pinnedAuthenticatorSecret,
        vaultRepo: this.vaultRepo,
        profileRepo: this.profileRepo,
        accountState: this.accountState,
        protectedSecretRepo: this.protectedSecretRepo,
        syncVersion: this.syncVersion,
        tokenRefreshNeeded: this.tokenRefreshNeeded,
        superUserUnlockedAuthenticators: this.superUserUnlockedAuthenticators,
        foreignVaultSyncPredicate: this.foreignVaultSyncPredicate,
        ephemeralForeignVaultSyncPredicate: this.ephemeralForeignVaultSyncPredicate,
        ignoredUnlock: this.ignoredUnlock,
        maintenanceSettings: this.maintenanceSettings,
        lastKnownServerTime: this.lastKnownServerTime,
        clientOutdated: this.clientOutdated,
        clientServerTimeOffsetMs: this.clientServerTimeOffsetMs,
        auditlogEventQueue: this.auditlogEventQueue,
        auditlogWriteTokenCache: this.auditlogWriteTokenCache
      };
    }
  };
  ClientCore = ClientCore_1 = __decorate$2([
    Emittery$1.mixin("emitter")
  ], ClientCore);
  const ClientCore$1 = ClientCore;
  function getDummySecretSeedFromSecretInfo(secretInfo) {
    const { seed } = jsonParseThaw(secretInfo);
    return seed;
  }
  var __decorate$1 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var LongPollUpdateEmitter_1;
  let LongPollUpdateEmitter = LongPollUpdateEmitter_1 = class LongPollUpdateEmitter {
    constructor(backendClient, requestUnlock) {
      this.backendClient = backendClient;
      this.cancelToken = new CancelToken();
      this.longPollLoopUntilCancelled(requestUnlock).catch((error2) => __awaiter$4(this, void 0, void 0, function* () {
        if (this.cancelToken.isCancelled) {
          return;
        }
        if (error2 instanceof Cancel) {
          return this.emitter.emit("cancel");
        } else {
          return this.emitter.emit("error", { error: error2 });
        }
      }));
    }
    longPollLoopUntilCancelled(requestUnlock) {
      return __awaiter$4(this, void 0, void 0, function* () {
        let message = yield this.backendClient.withSyncVersion(0).sync.longPoll(this.cancelToken, requestUnlock);
        let updateSyncVersion = message.syncVersion;
        yield this.emitter.emit("message", { message });
        while (!this.cancelToken.isCancelled) {
          message = yield this.backendClient.withSyncVersion(updateSyncVersion).sync.longPoll(this.cancelToken, false);
          updateSyncVersion = message.syncVersion;
          yield this.emitter.emit("message", { message });
        }
      });
    }
    static fromLoginData(loginData, backendClient) {
      const authorizedBackendClient = backendClient.withLogin(loginData);
      return new LongPollUpdateEmitter_1(authorizedBackendClient, false);
    }
    static fromClientCore(clientCore, requestUnlock) {
      return new LongPollUpdateEmitter_1(clientCore.backendClient, requestUnlock);
    }
    close() {
      this.cancelToken.cancel();
      this.emitter.emit("cancel").catch(trackError);
      this.emitter.clearListeners();
    }
  };
  LongPollUpdateEmitter = LongPollUpdateEmitter_1 = __decorate$1([
    Emittery$1.mixin("emitter")
  ], LongPollUpdateEmitter);
  const LongPollUpdateEmitter$1 = LongPollUpdateEmitter;
  class StreamingUpdateEmitter {
    constructor(backendClient, requestUnlock) {
      this.backendClient = backendClient;
      this.cancelToken = new CancelToken();
      this.emitter = backendClient.sync.streamingSync(this.cancelToken, requestUnlock);
      this.emitter.bindMethods(this);
    }
    static fromLoginData(loginData, backendClient) {
      const authorizedBackendClient = backendClient.withLogin(loginData);
      return new StreamingUpdateEmitter(authorizedBackendClient, false);
    }
    static fromClientCore(clientCore, requestUnlock) {
      var _a2;
      const backendClient = clientCore.backendClient.withSyncVersion((_a2 = clientCore.syncVersion) !== null && _a2 !== void 0 ? _a2 : void 0);
      return new StreamingUpdateEmitter(backendClient, requestUnlock);
    }
    close() {
      this.emitter.clearListeners();
      this.cancelToken.cancel();
    }
  }
  var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function runWithCancel(cb, onCancel, cancelToken) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (cancelToken) {
        try {
          yield Promise.race([cb(), waitForCancel(cancelToken)]);
        } catch (e) {
          if (e instanceof Cancel) {
            yield onCancel();
            return;
          }
          throw e;
        }
      } else {
        yield cb();
      }
    });
  }
  function waitForCancel(cancelToken) {
    return new Promise((_, reject) => cancelToken.onCancel(() => {
      reject(new Cancel());
    }));
  }
  var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
    var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r2 = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i2 = decorators.length - 1; i2 >= 0; i2--)
        if (d = decorators[i2])
          r2 = (c2 < 3 ? d(r2) : c2 > 3 ? d(target, key, r2) : d(target, key)) || r2;
    return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
  };
  var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues = globalThis && globalThis.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v2) {
        return new Promise(function(resolve, reject) {
          v2 = o[n](v2), settle(resolve, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve, reject, d, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve({ value: v3, done: d });
      }, reject);
    }
  };
  let ClientCoreSync = class ClientCoreSync {
    constructor(clientCore, { performMaintenanceAfterSync = true, minReconnectDelayMs = 3e3, stateStore = {} } = {}) {
      this.clientCore = clientCore;
      this.autoSyncLocalChanges = true;
      this.autoSyncRemoteChanges = true;
      this.internalUpdateEmitter = null;
      this.isInitialSyncResponse = false;
      this.isSyncEnabled = false;
      this.isDelayExtendUnlock = false;
      this.syncConnectionMode = "streaming";
      this.handleUpdateEmitterMessage = ({ message }) => {
        this.stateStore.lastConnectAttempt = 0;
        if (!this.autoSyncRemoteChanges) {
          return;
        }
        let eventOrigin;
        if (this.isInitialSyncResponse) {
          this.isInitialSyncResponse = false;
          debugConsole.log("Initial sync successful");
          eventOrigin = "init";
        } else {
          eventOrigin = "push";
        }
        this.onlineSyncNonBlocking(message, eventOrigin);
      };
      this.handleClientCoreLocalVaultChange = () => {
        if (this.autoSyncLocalChanges) {
          this.onlineSyncNonBlocking(null);
        }
      };
      this.handleSyncEnd = () => {
        this.scheduleUnlockTimeouts();
      };
      this.performMaintenanceAfterSync = performMaintenanceAfterSync;
      this.minReconnectDelayMs = minReconnectDelayMs;
      this.stateStore = stateStore;
      const { clientType } = clientCore.backendClient.config;
      const { preferLongPollForProtoClientTypes } = clientCore.accountState.serverSideSettings;
      if (clientType && (preferLongPollForProtoClientTypes === null || preferLongPollForProtoClientTypes === void 0 ? void 0 : preferLongPollForProtoClientTypes.includes(clientType))) {
        this.syncConnectionMode = "longPoll";
      }
    }
    open() {
      this.isSyncEnabled = true;
      this.reconnectWithDelay();
      this.clientCore.on("localVaultChange", this.handleClientCoreLocalVaultChange);
      this.clientCore.on("syncEnd", this.handleSyncEnd);
    }
    close() {
      this.isSyncEnabled = false;
      this.disconnect();
      this.clientCore.off("localVaultChange", this.handleClientCoreLocalVaultChange);
      this.clientCore.off("syncEnd", this.handleSyncEnd);
      if (this.unlockExpirationTimeoutId) {
        clearTimeout(this.unlockExpirationTimeoutId);
        this.unlockExpirationTimeoutId = void 0;
      }
      if (this.unlockExtensionTimeoutId) {
        clearTimeout(this.unlockExtensionTimeoutId);
        this.unlockExtensionTimeoutId = void 0;
      }
      if (this.maintenanceTaskTimeoutId) {
        clearTimeout(this.maintenanceTaskTimeoutId);
        this.maintenanceTaskTimeoutId = void 0;
      }
      if (this.reconnectTimeoutId) {
        clearTimeout(this.reconnectTimeoutId);
        this.reconnectTimeoutId = void 0;
      }
    }
    reconnectIfNecessary(requestUnlock = false) {
      if (this.internalUpdateEmitter) {
        return;
      }
      this.reconnect(requestUnlock);
    }
    disconnect() {
      if (this.internalUpdateEmitter) {
        this.internalUpdateEmitter.close();
        this.internalUpdateEmitter = null;
      }
    }
    setSyncConnectionMode(mode, origin = "explicit") {
      if (this.syncConnectionMode === mode) {
        return;
      }
      const keepConnection = mode === "streaming" && this.syncConnectionMode === "streamingOrFallback";
      this.syncConnectionMode = mode;
      this.emitter.emit("syncConnectionModeChange", { mode, origin }).catch(trackError);
      if (!keepConnection) {
        this.reconnect();
      }
    }
    getSyncConnectionMode() {
      return this.syncConnectionMode;
    }
    setDelayExtendUnlock(delayExtendUnlock) {
      this.isDelayExtendUnlock = delayExtendUnlock;
    }
    reconnectWithDelay(requestUnlock = false) {
      var _a2;
      this.disconnect();
      if (!this.isSyncEnabled) {
        return;
      }
      const now = /* @__PURE__ */ new Date();
      if (this.minReconnectDelayMs === null) {
        return;
      }
      if (!this.stateStore.lastConnectAttemptDate) {
        debugConsole.log("Reconnecting immediately, no last connect attempt date known");
        this.reconnectIfNecessary(requestUnlock);
        return;
      }
      if (this.stateStore.lastConnectAttempt === 0) {
        debugConsole.log(`Reconnecting event stream immediately`);
        this.stateStore.lastConnectAttempt += 1;
        this.reconnectIfNecessary(requestUnlock);
        return;
      }
      let reconnectDelay = this.minReconnectDelayMs;
      const lastConnectAttempt = (_a2 = this.stateStore.lastConnectAttempt) !== null && _a2 !== void 0 ? _a2 : 0;
      reconnectDelay *= Math.pow(2, Math.min(lastConnectAttempt - 1, 5));
      this.stateStore.lastConnectAttempt = lastConnectAttempt + 1;
      const timeSinceLastConnect = now.getTime() - this.stateStore.lastConnectAttemptDate.getTime();
      const effectiveDelay = Math.max(500, reconnectDelay - timeSinceLastConnect);
      debugConsole.log(`Reconnecting event stream in ${effectiveDelay / 1e3} seconds... ${requestUnlock ? "(With unlock)" : ""}`);
      this.reconnectTimeoutId = setTimeout(this.reconnectIfNecessary.bind(this, requestUnlock), effectiveDelay);
    }
    reconnectRequestingUnlock() {
      this.reconnect(true);
    }
    reconnect(requestUnlock = false) {
      this.disconnect();
      if (this.reconnectTimeoutId) {
        clearTimeout(this.reconnectTimeoutId);
        this.reconnectTimeoutId = void 0;
      }
      if (!this.isSyncEnabled) {
        return;
      }
      this.stateStore.lastConnectAttemptDate = /* @__PURE__ */ new Date();
      this.isInitialSyncResponse = true;
      this.internalUpdateEmitter = this.syncConnectionMode === "longPoll" ? LongPollUpdateEmitter$1.fromClientCore(this.clientCore, requestUnlock) : StreamingUpdateEmitter.fromClientCore(this.clientCore, requestUnlock);
      this.internalUpdateEmitter.on("message", this.handleUpdateEmitterMessage);
      this.internalUpdateEmitter.on("error", ({ error: error2 }) => {
        debugConsole.log("Event stream disconnected due to error.", error2);
        if (error2 instanceof NoResponseError) {
          this.emitter.emit("recoverableSyncError", { error: error2 }).catch(trackError);
          this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
          return;
        }
        if (error2 instanceof BackendDomainError && error2.code === BackendErrorCode.CANCELED) {
          if (this.isSyncEnabled) {
            this.emitter.emit("recoverableSyncCancel", {}).catch(trackError);
          }
          this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
          return;
        }
        if (error2 instanceof InvalidGrpcResponseError) {
          this.emitter.emit("recoverableSyncError", { error: error2 }).catch(trackError);
          if (this.stateStore.lastConnectAttempt === 0) {
            trackError(error2);
          }
          this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
          return;
        }
        debugConsole.log("Sync stream error not recoverable, giving up.", error2);
        this.disconnect();
        this.emitter.emit("syncError", { error: error2 }).catch(trackError);
      });
      this.internalUpdateEmitter.on("cancel", () => {
        if (this.isSyncEnabled) {
          this.emitter.emit("recoverableSyncCancel", {}).catch(trackError);
        }
        this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
      });
      if (this.syncConnectionMode === "streamingOrFallback") {
        const initialSyncTimeout = setTimeout(() => {
          debugConsole.log("[clientCoreSync]", "switching to long poll after 5s no response");
          this.setSyncConnectionMode("longPoll", "fallback");
        }, 5e3);
        const clearOnAny = this.internalUpdateEmitter.onAny((...args) => {
          debugConsole.log("[clientCoreSync]", "canceling switch to longpoll", args);
          clearTimeout(initialSyncTimeout);
          clearOnAny();
          this.setSyncConnectionMode("streaming", "fallback");
        });
      }
    }
    /**
     * Triggers a sync that cannot be awaited. Sync errors emit syncError events.
     */
    onlineSyncNonBlocking(syncUpdate, eventOrigin = "poll") {
      this.sync(syncUpdate, eventOrigin).catch(trackError);
    }
    requestUnlock(cancelToken) {
      return __awaiter$2(this, void 0, void 0, function* () {
        yield this.startRequestUnlock(cancelToken);
        yield this.finishRequestUnlock(cancelToken);
      });
    }
    startRequestUnlock(cancelToken) {
      return __awaiter$2(this, void 0, void 0, function* () {
        if (this.clientCore.isUnlocked()) {
          return;
        }
        const syncEvents = this.clientCore.events("syncEnd");
        this.reconnectRequestingUnlock();
        yield runWithCancel(() => __awaiter$2(this, void 0, void 0, function* () {
          var _a2, e_1, _b2, _c2;
          try {
            for (var _d2 = true, syncEvents_1 = __asyncValues(syncEvents), syncEvents_1_1; syncEvents_1_1 = yield syncEvents_1.next(), _a2 = syncEvents_1_1.done, !_a2; _d2 = true) {
              _c2 = syncEvents_1_1.value;
              _d2 = false;
              const _ = _c2;
              if (this.clientCore.isUnlocked()) {
                return;
              }
              if (this.clientCore.getSession().unlockRequestedAt !== void 0) {
                return;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d2 && !_a2 && (_b2 = syncEvents_1.return))
                yield _b2.call(syncEvents_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }), () => __awaiter$2(this, void 0, void 0, function* () {
          yield this.clientCore.onlineCancelRequestSessionUnlock(this.clientCore.getSessionId());
          throw new Cancel();
        }), cancelToken);
      });
    }
    finishRequestUnlock(cancelToken) {
      return __awaiter$2(this, void 0, void 0, function* () {
        if (this.clientCore.isUnlocked()) {
          return;
        }
        if (this.clientCore.getSession().unlockRequestedAt === void 0) {
          throw new UnlockRejectedError();
        }
        const syncEvents = this.clientCore.events("syncEnd");
        yield this.tryUnlockingWithDummyAuth();
        yield runWithCancel(() => __awaiter$2(this, void 0, void 0, function* () {
          var _a2, e_2, _b2, _c2;
          try {
            for (var _d2 = true, syncEvents_2 = __asyncValues(syncEvents), syncEvents_2_1; syncEvents_2_1 = yield syncEvents_2.next(), _a2 = syncEvents_2_1.done, !_a2; _d2 = true) {
              _c2 = syncEvents_2_1.value;
              _d2 = false;
              const _ = _c2;
              if (this.clientCore.isUnlocked()) {
                return;
              }
              if (this.clientCore.getSession().unlockRequestedAt === void 0) {
                throw new UnlockRejectedError();
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_d2 && !_a2 && (_b2 = syncEvents_2.return))
                yield _b2.call(syncEvents_2);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }), () => __awaiter$2(this, void 0, void 0, function* () {
          yield this.clientCore.onlineCancelRequestSessionUnlock(this.clientCore.getSessionId());
          throw new Cancel();
        }), cancelToken);
      });
    }
    tryUnlockingWithDummyAuth() {
      var _a2;
      return __awaiter$2(this, void 0, void 0, function* () {
        const currentAuth = this.clientCore.params.unlockedAuthenticator.authenticator;
        if (currentAuth.authenticatorType !== AuthenticatorType.DUMMY) {
          return;
        }
        if (this.isInitialSyncResponse) {
          yield (_a2 = this.internalUpdateEmitter) === null || _a2 === void 0 ? void 0 : _a2.once("message");
        }
        const hsc = HighSecurityCache.fromSecret({
          authenticatorId: currentAuth.id,
          seed: getDummySecretSeedFromSecretInfo(currentAuth.secretInfo)
        }, currentAuth);
        const meta = this.clientCore.getSessionMetaById(this.clientCore.getSessionId());
        if (!meta || !meta.encPubKey || !meta.encPubKeySignature) {
          return;
        }
        const encPubKey = loadEncryptionPublicKey(meta.encPubKey);
        const encPubKeySignature = loadEncryptionPublicKeySignature(meta.encPubKeySignature);
        const trustedSigPubKeys = [currentAuth.storableSigPubKey];
        const expiresAt = getUnlockTime();
        yield this.clientCore.onlineCreateSessionUnlock(this.clientCore.getSessionId(), encPubKey, encPubKeySignature, trustedSigPubKeys, hsc, expiresAt);
      });
    }
    sync(syncUpdate, eventOrigin) {
      return __awaiter$2(this, void 0, void 0, function* () {
        try {
          if (!syncUpdate) {
            yield this.clientCore.onlineSync();
          } else {
            if (eventOrigin === "push" && syncUpdate.syncVersion === this.clientCore.syncVersion) {
              return;
            }
            this.emitter.emit("syncUpdate", { eventOrigin, syncUpdate }).catch(trackError);
            yield this.clientCore.onlineSyncWithUpdate(syncUpdate, eventOrigin);
          }
          this.checkLongPollSetting();
          this.scheduleMaintenanceTasks();
        } catch (error2) {
          if (error2 instanceof InvalidGrpcResponseError || error2 instanceof NoResponseError) {
            yield this.emitter.emit("recoverableSyncError", { error: error2 });
          } else if (error2 instanceof Error) {
            yield this.emitter.emit("syncError", { error: error2 });
          } else {
            yield this.emitter.emit("syncError", { error: new Error(`${error2}`) });
          }
        }
      });
    }
    checkLongPollSetting() {
      if (this.syncConnectionMode === "longPoll") {
        return;
      }
      const { clientType } = this.clientCore.backendClient.config;
      const { preferLongPollForProtoClientTypes } = this.clientCore.accountState.serverSideSettings;
      if (clientType && (preferLongPollForProtoClientTypes === null || preferLongPollForProtoClientTypes === void 0 ? void 0 : preferLongPollForProtoClientTypes.includes(clientType))) {
        this.setSyncConnectionMode("longPoll", "serverSideSetting");
      }
    }
    scheduleUnlockTimeouts() {
      if (this.unlockExpirationTimeoutId) {
        clearTimeout(this.unlockExpirationTimeoutId);
        this.unlockExpirationTimeoutId = void 0;
      }
      if (this.unlockExtensionTimeoutId) {
        clearTimeout(this.unlockExtensionTimeoutId);
        this.unlockExtensionTimeoutId = void 0;
      }
      if (this.clientCore.vaultRepo.isInitialized() && !this.clientCore.isUnlocked()) {
        return;
      }
      if (this.clientCore.isPinnedUnlocked()) {
        return;
      }
      const { unlockedAt, unlockExtendAt, unlockedUntil } = this.clientCore.getSession();
      if (!unlockedAt) {
        this.clientCore.lockAllVaults().catch(trackError);
        return;
      }
      if (unlockedUntil) {
        const unlockDurationMs = unlockedUntil.getTime() - Date.now();
        this.unlockExpirationTimeoutId = setTimeout(() => {
          this.clientCore.lockAllVaults().catch(trackError);
        }, unlockDurationMs);
        if (unlockExtendAt) {
          const extendSessionTime = unlockExtendAt.getTime() - Date.now() + (this.isDelayExtendUnlock ? 5e3 : 0);
          this.unlockExtensionTimeoutId = setTimeout(() => {
            this.extendSessionIfNecessary();
          }, extendSessionTime);
        }
      }
    }
    pingActivity() {
      const now = /* @__PURE__ */ new Date();
      if (this.lastUserActivityDate && this.lastUserActivityDate.getTime() > now.getTime() - 10 * 1e3) {
        return;
      }
      this.lastUserActivityDate = now;
      this.extendSessionIfNecessary();
    }
    extendSessionIfNecessary() {
      if (!this.lastUserActivityDate) {
        return;
      }
      const session = this.clientCore.getSession();
      const { unlockedAt, unlockExtendAt, unlockedUntil } = session;
      if (!unlockedAt || !unlockExtendAt || unlockExtendAt.getTime() > Date.now() || unlockedUntil && unlockedUntil.getTime() < Date.now()) {
        return;
      }
      const lastUserActivity = this.lastUserActivityDate;
      this.lastUserActivityDate = void 0;
      this.clientCore.onlineExtendSessionUnlock(lastUserActivity).catch((e) => {
        if (e instanceof NoResponseError) {
          return;
        }
        if (e instanceof DomainError$1) {
          switch (e.code) {
            case BackendErrorCode.SESSION_NOT_UNLOCKED:
            case BackendErrorCode.SESSION_NOT_FOUND:
              return;
          }
        }
        throw e;
      }).catch(trackError);
    }
    scheduleMaintenanceTasks() {
      if (!this.performMaintenanceAfterSync) {
        return;
      }
      if (this.maintenanceTaskTimeoutId) {
        clearTimeout(this.maintenanceTaskTimeoutId);
        this.maintenanceTaskTimeoutId = void 0;
      }
      const delay = 1e3 + Math.random() * 2e3;
      this.maintenanceTaskTimeoutId = setTimeout(() => {
        this.clientCore.onlinePerformMaintenance().catch(trackError);
      }, delay);
    }
  };
  ClientCoreSync = __decorate([
    Emittery$1.mixin("emitter")
  ], ClientCoreSync);
  const ClientCoreSync$1 = ClientCoreSync;
  function getOrganizationMetadata(org, profileRepo, accountState) {
    var _a2;
    const orgProfile = (_a2 = profileRepo.getOrganizationProfile(org.id)) === null || _a2 === void 0 ? void 0 : _a2.profile;
    const parentOrg = org.parentOrganizationInfo ? accountState.getOrganization(org.parentOrganizationInfo.id) : void 0;
    const parentOrgIsEnabled = !!org.parentOrganizationInfo && !!profileRepo.getOrganizationProfile(org.parentOrganizationInfo.id);
    const childIds = accountState.organizations.flatMap((otherOrg) => {
      var _a3;
      return ((_a3 = otherOrg.parentOrganizationInfo) === null || _a3 === void 0 ? void 0 : _a3.id) === org.id ? otherOrg.id : [];
    });
    return {
      id: org.id,
      name: org.name,
      icon: org.icon,
      isPreliminary: org.isPreliminary,
      allowTeamCreation: !org.restrictCreateTeam || org.isAdmin,
      isAdmin: org.isAdmin,
      isManager: org.isManager,
      profileId: orgProfile === null || orgProfile === void 0 ? void 0 : orgProfile.id,
      childOrganizationManagementEnable: org.childOrganizationManagementEnable,
      parentOrganizationChildManagementPath: parentOrgIsEnabled && (parentOrg === null || parentOrg === void 0 ? void 0 : parentOrg.childOrganizationManagementEnable) && org.parentOrganizationInfo ? `/organizations/${org.parentOrganizationInfo.id}/childOrganizations` : void 0,
      parentId: parentOrg === null || parentOrg === void 0 ? void 0 : parentOrg.id,
      childIds
    };
  }
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function filterCustomFields(customFields) {
    const totpField = customFields === null || customFields === void 0 ? void 0 : customFields.find((f2) => f2.protected && f2.name.toLowerCase().includes("totp"));
    const remainingFields = customFields.filter((cf) => cf !== totpField);
    return {
      totpField,
      remainingFields
    };
  }
  function getLoginDisplayLabel(login) {
    var _a2, _b2, _c2, _d2, _e2;
    if ((_a2 = login.title) === null || _a2 === void 0 ? void 0 : _a2.trim()) {
      return login.title.trim();
    }
    if (login.uiType === LoginUiType.creditCard && ((_c2 = (_b2 = login.creditCard) === null || _b2 === void 0 ? void 0 : _b2.displayType) === null || _c2 === void 0 ? void 0 : _c2.trim())) {
      return login.creditCard.displayType.trim();
    }
    if (login.uiType === LoginUiType.wifi && ((_d2 = login.wifiSsid) === null || _d2 === void 0 ? void 0 : _d2.trim())) {
      return login.wifiSsid.trim();
    }
    if ((_e2 = login.username) === null || _e2 === void 0 ? void 0 : _e2.trim()) {
      return login.username.trim();
    }
    return void 0;
  }
  function getLoginDisplaySources(login, { noSourceCount } = {}) {
    var _a2, _b2, _c2;
    const androidApps = (_a2 = login.androidApps) !== null && _a2 !== void 0 ? _a2 : [];
    const websites = (_c2 = (_b2 = login.websites) === null || _b2 === void 0 ? void 0 : _b2.filter((w2) => w2.trim())) !== null && _c2 !== void 0 ? _c2 : [];
    let displayWebsite;
    if (androidApps.length) {
      displayWebsite = androidApps[0].displayName;
    } else if (websites.length) {
      displayWebsite = websites[0];
    }
    const length = androidApps.length + websites.length;
    if (!noSourceCount && displayWebsite !== void 0 && length > 1) {
      displayWebsite += ` (+${length - 1})`;
    }
    return displayWebsite;
  }
  function getLoginDisplayInfo(login, { noSourceCount } = {}) {
    var _a2, _b2, _c2, _d2;
    const label = getLoginDisplayLabel(login);
    const cardNumber2 = (_b2 = (_a2 = login.creditCard) === null || _a2 === void 0 ? void 0 : _a2.displayMaskedNumber) === null || _b2 === void 0 ? void 0 : _b2.trim();
    if (login.uiType === LoginUiType.creditCard && cardNumber2) {
      return {
        headline: label,
        subheadline: cardNumber2,
        subheadlineMonospace: true
      };
    }
    if (login.uiType === LoginUiType.wifi) {
      return {
        headline: label,
        subheadline: ((_c2 = login.title) === null || _c2 === void 0 ? void 0 : _c2.trim()) ? (_d2 = login.wifiSsid) === null || _d2 === void 0 ? void 0 : _d2.trim() : void 0
      };
    }
    if (login.uiType === LoginUiType.note && login.note) {
      return {
        headline: label,
        subheadline: login.note.split("\n")[0].substring(0, 100)
      };
    }
    const sources = getLoginDisplaySources(login, { noSourceCount });
    if (sources) {
      return { headline: sources, subheadline: label };
    }
    if (label) {
      return { headline: label };
    }
    return {
      headline: void 0
    };
  }
  const relatedDomainsDictionary = {
    "3docean.net": [
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "audiojungle.net": [
      "3docean.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "codecanyon.net": [
      "3docean.net",
      "audiojungle.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "envato.com": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "graphicriver.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "photodune.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "placeit.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "themeforest.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "themeforest.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "tutsplus.com",
      "videohive.net"
    ],
    "tutsplus.com": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "videohive.net"
    ],
    "videohive.net": [
      "3docean.net",
      "audiojungle.net",
      "codecanyon.net",
      "envato.com",
      "graphicriver.net",
      "photodune.net",
      "placeit.net",
      "themeforest.net",
      "tutsplus.com"
    ],
    "airbnb.com.ar": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.au": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.at": [
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.be": [
      "airbnb.at",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.bz": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.bo": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.br": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.ca": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.cl": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.co": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.cr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.cz": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.dk": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.ec": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.sv": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.fi": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.fr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.de": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.gr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.gt": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.gy": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.hn": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.hk": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.hu": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.is": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.in": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.id": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.ie": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.it": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.jp": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.my": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.mt": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.mx": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.nl": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.nz": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.ni": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.no": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.pa": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.py": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.pe": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.pl": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.pt": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.ru": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.se"
    ],
    "airbnb.com.sg": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.kr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.es": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.se": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru"
    ],
    "airbnb.ch": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.tw": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com.tr": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.uk": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.ve",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.com": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.co.ve",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airbnb.co.ve": [
      "airbnb.at",
      "airbnb.be",
      "airbnb.ca",
      "airbnb.ch",
      "airbnb.cl",
      "airbnb.co.cr",
      "airbnb.co.id",
      "airbnb.co.in",
      "airbnb.co.kr",
      "airbnb.co.nz",
      "airbnb.co.uk",
      "airbnb.com",
      "airbnb.com.ar",
      "airbnb.com.au",
      "airbnb.com.bo",
      "airbnb.com.br",
      "airbnb.com.bz",
      "airbnb.com.co",
      "airbnb.com.ec",
      "airbnb.com.gt",
      "airbnb.com.hk",
      "airbnb.com.hn",
      "airbnb.com.mt",
      "airbnb.com.my",
      "airbnb.com.ni",
      "airbnb.com.pa",
      "airbnb.com.pe",
      "airbnb.com.py",
      "airbnb.com.sg",
      "airbnb.com.sv",
      "airbnb.com.tr",
      "airbnb.com.tw",
      "airbnb.cz",
      "airbnb.de",
      "airbnb.dk",
      "airbnb.es",
      "airbnb.fi",
      "airbnb.fr",
      "airbnb.gr",
      "airbnb.gy",
      "airbnb.hu",
      "airbnb.ie",
      "airbnb.is",
      "airbnb.it",
      "airbnb.jp",
      "airbnb.mx",
      "airbnb.nl",
      "airbnb.no",
      "airbnb.pl",
      "airbnb.pt",
      "airbnb.ru",
      "airbnb.se"
    ],
    "airnewzealand.co.nz": [
      "airnewzealand.com",
      "airnewzealand.com.au"
    ],
    "airnewzealand.com": [
      "airnewzealand.co.nz",
      "airnewzealand.com.au"
    ],
    "airnewzealand.com.au": [
      "airnewzealand.co.nz",
      "airnewzealand.com"
    ],
    "albertsons.com": [
      "acmemarkets.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "acmemarkets.com": [
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "carrsqc.com": [
      "acmemarkets.com",
      "albertsons.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "jewelosco.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "pavilions.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "randalls.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "safeway.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "shaws.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "starmarket.com",
      "tomthumb.com",
      "vons.com"
    ],
    "starmarket.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "tomthumb.com",
      "vons.com"
    ],
    "tomthumb.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "vons.com"
    ],
    "vons.com": [
      "acmemarkets.com",
      "albertsons.com",
      "carrsqc.com",
      "jewelosco.com",
      "pavilions.com",
      "randalls.com",
      "safeway.com",
      "shaws.com",
      "starmarket.com",
      "tomthumb.com"
    ],
    "alelo.com.br": [
      "meualelo.com.br"
    ],
    "meualelo.com.br": [
      "alelo.com.br"
    ],
    "ana.co.jp": [
      "astyle.jp"
    ],
    "astyle.jp": [
      "ana.co.jp"
    ],
    "angel.co": [
      "wellfound.com"
    ],
    "anthem.com": [
      "sydneyhealth.com"
    ],
    "sydneyhealth.com": [
      "anthem.com"
    ],
    "appannie.com": [
      "data.ai"
    ],
    "bgg.cc": [
      "boardgamegeek.com",
      "rpggeek.com",
      "videogamegeek.com"
    ],
    "boardgamegeek.com": [
      "bgg.cc",
      "rpggeek.com",
      "videogamegeek.com"
    ],
    "rpggeek.com": [
      "bgg.cc",
      "boardgamegeek.com",
      "videogamegeek.com"
    ],
    "videogamegeek.com": [
      "bgg.cc",
      "boardgamegeek.com",
      "rpggeek.com"
    ],
    "centralfcu.org": [
      "centralfcu.com"
    ],
    "centralfcu.com": [
      "centralfcu.org"
    ],
    "coolblue.nl": [
      "coolblue.be",
      "coolblue.de"
    ],
    "coolblue.be": [
      "coolblue.de",
      "coolblue.nl"
    ],
    "coolblue.de": [
      "coolblue.be",
      "coolblue.nl"
    ],
    "dan.org": [
      "diversalertnetwork.org"
    ],
    "diversalertnetwork.org": [
      "dan.org"
    ],
    "discordapp.com": [
      "discord.com"
    ],
    "discordmerch.com": [
      "discord.store"
    ],
    "discord.store": [
      "discordmerch.com"
    ],
    "discovercard.com": [
      "discover.com"
    ],
    "disney.com": [
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "disneyplus.com": [
      "disney.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "disneystore.com": [
      "disney.com",
      "disneyplus.com",
      "espn.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "espn.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "go.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "go.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "hulu.com",
      "shopdisney.com"
    ],
    "hulu.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "shopdisney.com"
    ],
    "shopdisney.com": [
      "disney.com",
      "disneyplus.com",
      "disneystore.com",
      "espn.com",
      "go.com",
      "hulu.com"
    ],
    "dnt.abine.com": [
      "ironvest.com"
    ],
    "ironvest.com": [
      "dnt.abine.com"
    ],
    "drivethrucards.com": [
      "dmsguild.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "drivethrucomics.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "drivethrufiction.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "drivethrurpg.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "dmsguild.com": [
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "pathfinderinfinite.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "storytellersvault.com",
      "wargamevault.com"
    ],
    "storytellersvault.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "wargamevault.com"
    ],
    "wargamevault.com": [
      "dmsguild.com",
      "drivethrucards.com",
      "drivethrucomics.com",
      "drivethrufiction.com",
      "drivethrurpg.com",
      "pathfinderinfinite.com",
      "storytellersvault.com"
    ],
    "ebay.at": [
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.be": [
      "ebay.at",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ca": [
      "ebay.at",
      "ebay.be",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ch": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.cn": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.co.th": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.co.uk": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.au": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.hk": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.my": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.sg": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.com.tw": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.de": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.es": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.fr": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ie": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.it": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.nl": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.ph",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.ph": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.pl",
      "ebay.vn"
    ],
    "ebay.pl": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.vn"
    ],
    "ebay.vn": [
      "ebay.at",
      "ebay.be",
      "ebay.ca",
      "ebay.ch",
      "ebay.cn",
      "ebay.co.th",
      "ebay.co.uk",
      "ebay.com",
      "ebay.com.au",
      "ebay.com.hk",
      "ebay.com.my",
      "ebay.com.sg",
      "ebay.com.tw",
      "ebay.de",
      "ebay.es",
      "ebay.fr",
      "ebay.ie",
      "ebay.it",
      "ebay.nl",
      "ebay.ph",
      "ebay.pl"
    ],
    "epicgames.com": [
      "unrealengine.com"
    ],
    "unrealengine.com": [
      "epicgames.com"
    ],
    "eventbrite.at": [
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.be": [
      "eventbrite.at",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ca": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ch": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.cl": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.co": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.com": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.de": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.dk": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.es": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.fi": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.fr": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.hk": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ie": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.in": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.it": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.my": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.nl": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.ph": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.pt",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.pt": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.se",
      "eventbrite.sg"
    ],
    "eventbrite.se": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.sg"
    ],
    "eventbrite.sg": [
      "eventbrite.at",
      "eventbrite.be",
      "eventbrite.ca",
      "eventbrite.ch",
      "eventbrite.cl",
      "eventbrite.co",
      "eventbrite.com",
      "eventbrite.de",
      "eventbrite.dk",
      "eventbrite.es",
      "eventbrite.fi",
      "eventbrite.fr",
      "eventbrite.hk",
      "eventbrite.ie",
      "eventbrite.in",
      "eventbrite.it",
      "eventbrite.my",
      "eventbrite.nl",
      "eventbrite.ph",
      "eventbrite.pt",
      "eventbrite.se"
    ],
    "fancourier.ro": [
      "selfawb.ro"
    ],
    "flyblade.com": [
      "blade.com"
    ],
    "gazduire.com.ro": [
      "admin.ro"
    ],
    "gazduire.net": [
      "admin.ro"
    ],
    "hbo.com": [
      "max.com"
    ],
    "hbomax.com": [
      "max.com"
    ],
    "hbonow.com": [
      "max.com"
    ],
    "heroku.com": [
      "verify.salesforce.com"
    ],
    "ing.de": [
      "ing.com"
    ],
    "instagram.com": [
      "threads.net"
    ],
    "threads.net": [
      "instagram.com"
    ],
    "letsdeel.com": [
      "deel.com"
    ],
    "login.airfrance.com": [
      "login.flyingblue.com",
      "login.klm.com"
    ],
    "login.flyingblue.com": [
      "login.airfrance.com",
      "login.klm.com"
    ],
    "login.klm.com": [
      "login.airfrance.com",
      "login.flyingblue.com"
    ],
    "lrz.de": [
      "mwn.de",
      "mytum.de",
      "tum.de",
      "tum.edu"
    ],
    "mwn.de": [
      "lrz.de",
      "mytum.de",
      "tum.de",
      "tum.edu"
    ],
    "mytum.de": [
      "lrz.de",
      "mwn.de",
      "tum.de",
      "tum.edu"
    ],
    "tum.de": [
      "lrz.de",
      "mwn.de",
      "mytum.de",
      "tum.edu"
    ],
    "tum.edu": [
      "lrz.de",
      "mwn.de",
      "mytum.de",
      "tum.de"
    ],
    "mercadolibre.cl": [
      "mercadolibre.com"
    ],
    "mercadolibre.co.cr": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ar": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.bo": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.co": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.do": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ec": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.gt": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.hn": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.mx": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ni": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.pa": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.pe": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.py": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.sv": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.uy": [
      "mercadolibre.com"
    ],
    "mercadolibre.com.ve": [
      "mercadolibre.com"
    ],
    "mercadopago.cl": [
      "mercadolibre.com"
    ],
    "mercadopago.com.ar": [
      "mercadolibre.com"
    ],
    "mercadopago.com.co": [
      "mercadolibre.com"
    ],
    "mercadopago.com.ec": [
      "mercadolibre.com"
    ],
    "mercadopago.com.mx": [
      "mercadolibre.com"
    ],
    "mercadopago.com.pe": [
      "mercadolibre.com"
    ],
    "mercadopago.com.uy": [
      "mercadolibre.com"
    ],
    "mercadopago.com.ve": [
      "mercadolibre.com"
    ],
    "mercadolivre.com.br": [
      "mercadolivre.com"
    ],
    "mercadopago.com.br": [
      "mercadolivre.com"
    ],
    "moneybird.nl": [
      "moneybird.com"
    ],
    "moneybird.de": [
      "moneybird.com"
    ],
    "nebula.app": [
      "nebula.tv"
    ],
    "watchnebula.com": [
      "nebula.tv"
    ],
    "nextinpact.com": [
      "next.ink"
    ],
    "nordvpn.com": [
      "nordaccount.com"
    ],
    "nordpass.com": [
      "nordaccount.com"
    ],
    "overstock.com": [
      "bedbathandbeyond.com"
    ],
    "parkmobile.us": [
      "parkmobile.io"
    ],
    "pinterest.com": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ca": [
      "pinterest.at",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.co.uk": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.fr": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.de": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.es": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.com.au": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.se": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru"
    ],
    "pinterest.ph": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ch": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.com.mx": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.dk": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.pt": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ru": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.se"
    ],
    "pinterest.it": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.at": [
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.jp": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.cl": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.ie": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.co.kr": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.nz",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "pinterest.nz": [
      "pinterest.at",
      "pinterest.ca",
      "pinterest.ch",
      "pinterest.cl",
      "pinterest.co.kr",
      "pinterest.co.uk",
      "pinterest.com",
      "pinterest.com.au",
      "pinterest.com.mx",
      "pinterest.de",
      "pinterest.dk",
      "pinterest.es",
      "pinterest.fr",
      "pinterest.ie",
      "pinterest.it",
      "pinterest.jp",
      "pinterest.ph",
      "pinterest.pt",
      "pinterest.ru",
      "pinterest.se"
    ],
    "postnl.nl": [
      "postnl.be"
    ],
    "postnl.be": [
      "postnl.nl"
    ],
    "pretendo.network": [
      "pretendo.cc"
    ],
    "pretendo.cc": [
      "pretendo.network"
    ],
    "proton.me": [
      "protonmail.ch",
      "protonmail.com",
      "protonvpn.com"
    ],
    "protonvpn.com": [
      "proton.me",
      "protonmail.ch",
      "protonmail.com"
    ],
    "protonmail.ch": [
      "proton.me",
      "protonmail.com",
      "protonvpn.com"
    ],
    "protonmail.com": [
      "proton.me",
      "protonmail.ch",
      "protonvpn.com"
    ],
    "quicken.com": [
      "simplifimoney.com"
    ],
    "simplifimoney.com": [
      "quicken.com"
    ],
    "raywenderlich.com": [
      "kodeco.com"
    ],
    "redis.com": [
      "redislabs.com"
    ],
    "redislabs.com": [
      "redis.com"
    ],
    "s.activision.com": [
      "profile.callofduty.com"
    ],
    "profile.callofduty.com": [
      "s.activision.com"
    ],
    "scottscheapflights.com": [
      "going.com"
    ],
    "steampowered.com": [
      "steamcommunity.com"
    ],
    "steamcommunity.com": [
      "steampowered.com"
    ],
    "taxhawk.com": [
      "express1040.com",
      "freetaxusa.com"
    ],
    "freetaxusa.com": [
      "express1040.com",
      "taxhawk.com"
    ],
    "express1040.com": [
      "freetaxusa.com",
      "taxhawk.com"
    ],
    "telegram.me": [
      "telegram.org"
    ],
    "ting.com": [
      "tingmobile.com"
    ],
    "tingmobile.com": [
      "ting.com"
    ],
    "transferwise.com": [
      "wise.com"
    ],
    "tvnow.de": [
      "auth.rtl.de",
      "rtlplus.com",
      "rtlplus.de"
    ],
    "tvnow.at": [
      "auth.rtl.de",
      "rtlplus.com",
      "rtlplus.de"
    ],
    "tvnow.ch": [
      "auth.rtl.de",
      "rtlplus.com",
      "rtlplus.de"
    ],
    "twitter.com": [
      "x.com"
    ],
    "uspowerboating.com": [
      "ussailing.org"
    ],
    "ussailing.org": [
      "uspowerboating.com"
    ],
    "wacom.eu": [
      "wacom.com"
    ],
    "wikipedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "mediawiki.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikibooks.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikidata.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikinews.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikiquote.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikisource.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikiversity.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikivoyage.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wiktionary.org"
    ],
    "wiktionary.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org"
    ],
    "commons.wikimedia.org": [
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "meta.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "incubator.wikimedia.org": [
      "commons.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "outreach.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "species.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikimania.wikimedia.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "wikimania.wikimedia.org": [
      "commons.wikimedia.org",
      "incubator.wikimedia.org",
      "mediawiki.org",
      "meta.wikimedia.org",
      "outreach.wikimedia.org",
      "species.wikimedia.org",
      "wikibooks.org",
      "wikidata.org",
      "wikinews.org",
      "wikipedia.org",
      "wikiquote.org",
      "wikisource.org",
      "wikiversity.org",
      "wikivoyage.org",
      "wiktionary.org"
    ],
    "www.seek.com.au": [
      "login.seek.com"
    ],
    "www.seek.co.nz": [
      "login.seek.com"
    ],
    "jobsdb.com": [
      "login.seek.com"
    ],
    "hk.jobsdb.com": [
      "login.seek.com"
    ],
    "sg.jobsdb.com": [
      "login.seek.com"
    ],
    "th.jobsdb.com": [
      "login.seek.com"
    ],
    "jobstreet.com": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.co.id": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.com.my": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.com.ph": [
      "login.seek.com"
    ],
    "myjobstreet.jobstreet.com.sg": [
      "login.seek.com"
    ],
    "www.vistaprint.ca": [
      "account.vistaprint.com"
    ],
    "youneedabudget.com": [
      "ynab.com"
    ],
    "aa.com": [
      "americanairlines.com",
      "americanairlines.jp"
    ],
    "americanairlines.com": [
      "aa.com",
      "americanairlines.jp"
    ],
    "americanairlines.jp": [
      "aa.com",
      "americanairlines.com"
    ],
    "aetna.com": [
      "banneraetna.myplanportal.com"
    ],
    "banneraetna.myplanportal.com": [
      "aetna.com"
    ],
    "alibaba.com": [
      "aliexpress.com"
    ],
    "aliexpress.com": [
      "alibaba.com"
    ],
    "alltrails.com": [
      "alltrails.io"
    ],
    "alltrails.io": [
      "alltrails.com"
    ],
    "amazon.com": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.ae": [
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.au": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.br": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.ca": [
      "amazon.ae",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.fr": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.de": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.in": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.it": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.mx": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.nl": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.es": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.com.tr": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.co.uk": [
      "amazon.ae",
      "amazon.ca",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.sa": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.se",
      "amazon.sg"
    ],
    "amazon.sg": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.se"
    ],
    "amazon.se": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.pl",
      "amazon.sa",
      "amazon.sg"
    ],
    "amazon.pl": [
      "amazon.ae",
      "amazon.ca",
      "amazon.co.uk",
      "amazon.com",
      "amazon.com.au",
      "amazon.com.br",
      "amazon.com.mx",
      "amazon.com.tr",
      "amazon.de",
      "amazon.es",
      "amazon.fr",
      "amazon.in",
      "amazon.it",
      "amazon.nl",
      "amazon.sa",
      "amazon.se",
      "amazon.sg"
    ],
    "amcrestcloud.com": [
      "amcrestview.com"
    ],
    "amcrestview.com": [
      "amcrestcloud.com"
    ],
    "americastestkitchen.com": [
      "cookscountry.com",
      "cooksillustrated.com",
      "onlinecookingschool.com"
    ],
    "cooksillustrated.com": [
      "americastestkitchen.com",
      "cookscountry.com",
      "onlinecookingschool.com"
    ],
    "cookscountry.com": [
      "americastestkitchen.com",
      "cooksillustrated.com",
      "onlinecookingschool.com"
    ],
    "onlinecookingschool.com": [
      "americastestkitchen.com",
      "cookscountry.com",
      "cooksillustrated.com"
    ],
    "ameritrade.com": [
      "tdameritrade.com"
    ],
    "tdameritrade.com": [
      "ameritrade.com"
    ],
    "anylist.com": [
      "anylistapp.com"
    ],
    "anylistapp.com": [
      "anylist.com"
    ],
    "apple.com": [
      "icloud.com"
    ],
    "icloud.com": [
      "apple.com"
    ],
    "atlassian.com": [
      "trello.com"
    ],
    "trello.com": [
      "atlassian.com"
    ],
    "att.com": [
      "att.net"
    ],
    "att.net": [
      "att.com"
    ],
    "audi.com": [
      "audiusa.com"
    ],
    "audiusa.com": [
      "audi.com"
    ],
    "bahn.de": [
      "bahn.com"
    ],
    "bahn.com": [
      "bahn.de"
    ],
    "battle.net": [
      "blizzard.com"
    ],
    "blizzard.com": [
      "battle.net"
    ],
    "beachbodyondemand.com": [
      "teambeachbody.com"
    ],
    "teambeachbody.com": [
      "beachbodyondemand.com"
    ],
    "beavercreek.com": [
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "breckenridge.com": [
      "beavercreek.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "epicpass.com": [
      "beavercreek.com",
      "breckenridge.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "keystoneresort.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "kirkwood.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "mountsunapee.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "northstarcalifornia.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "okemo.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "parkcitymountain.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "skicb.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "skiheavenly.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "snow.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "stevenspass.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stowe.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "stowe.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "vail.com",
      "whistlerblackcomb.com"
    ],
    "vail.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "whistlerblackcomb.com"
    ],
    "whistlerblackcomb.com": [
      "beavercreek.com",
      "breckenridge.com",
      "epicpass.com",
      "keystoneresort.com",
      "kirkwood.com",
      "mountsunapee.com",
      "northstarcalifornia.com",
      "okemo.com",
      "parkcitymountain.com",
      "skicb.com",
      "skiheavenly.com",
      "snow.com",
      "stevenspass.com",
      "stowe.com",
      "vail.com"
    ],
    "boingo.com": [
      "boingohotspot.com"
    ],
    "boingohotspot.com": [
      "boingo.com"
    ],
    "bol.com": [
      "kobo.com"
    ],
    "kobo.com": [
      "bol.com"
    ],
    "boudinbakery.com": [
      "boudincatering.com"
    ],
    "boudincatering.com": [
      "boudinbakery.com"
    ],
    "braze.com": [
      "braze.eu"
    ],
    "braze.eu": [
      "braze.com"
    ],
    "capitalone.com": [
      "capitalone360.com"
    ],
    "capitalone360.com": [
      "capitalone.com"
    ],
    "cathaypacific.com": [
      "asiamiles.com"
    ],
    "asiamiles.com": [
      "cathaypacific.com"
    ],
    "citi.com": [
      "citibank.com",
      "citibankonline.com"
    ],
    "citibank.com": [
      "citi.com",
      "citibankonline.com"
    ],
    "citibankonline.com": [
      "citi.com",
      "citibank.com"
    ],
    "comcast.net": [
      "xfinity.com"
    ],
    "xfinity.com": [
      "comcast.net"
    ],
    "curbed.com": [
      "grubstreet.com",
      "nymag.com",
      "thecut.com",
      "vulture.com"
    ],
    "grubstreet.com": [
      "curbed.com",
      "nymag.com",
      "thecut.com",
      "vulture.com"
    ],
    "nymag.com": [
      "curbed.com",
      "grubstreet.com",
      "thecut.com",
      "vulture.com"
    ],
    "thecut.com": [
      "curbed.com",
      "grubstreet.com",
      "nymag.com",
      "vulture.com"
    ],
    "vulture.com": [
      "curbed.com",
      "grubstreet.com",
      "nymag.com",
      "thecut.com"
    ],
    "dinersclubnorthamerica.com": [
      "dinersclubus.com"
    ],
    "dinersclubus.com": [
      "dinersclubnorthamerica.com"
    ],
    "dish.com": [
      "dishnetwork.com",
      "mydish.com"
    ],
    "mydish.com": [
      "dish.com",
      "dishnetwork.com"
    ],
    "dishnetwork.com": [
      "dish.com",
      "mydish.com"
    ],
    "docusign.com": [
      "docusign.net"
    ],
    "docusign.net": [
      "docusign.com"
    ],
    "dropbox.com": [
      "getdropbox.com"
    ],
    "getdropbox.com": [
      "dropbox.com"
    ],
    "eater.com": [
      "polygon.com",
      "sbnation.com",
      "theverge.com"
    ],
    "polygon.com": [
      "eater.com",
      "sbnation.com",
      "theverge.com"
    ],
    "sbnation.com": [
      "eater.com",
      "polygon.com",
      "theverge.com"
    ],
    "theverge.com": [
      "eater.com",
      "polygon.com",
      "sbnation.com"
    ],
    "eurosport.no": [
      "eurosportplayer.com"
    ],
    "eurosportplayer.com": [
      "eurosport.no"
    ],
    "facebook.com": [
      "messenger.com"
    ],
    "messenger.com": [
      "facebook.com"
    ],
    "fandangonow.com": [
      "fandango.com"
    ],
    "fandango.com": [
      "fandangonow.com"
    ],
    "fidelity.com": [
      "fidelityinvestments.com"
    ],
    "fidelityinvestments.com": [
      "fidelity.com"
    ],
    "flyingblue.com": [
      "klm.com"
    ],
    "klm.com": [
      "flyingblue.com"
    ],
    "fnac.com": [
      "fnacspectacles.com"
    ],
    "fnacspectacles.com": [
      "fnac.com"
    ],
    "fourleaf.net": [
      "fourleaf.cl"
    ],
    "fourleaf.cl": [
      "fourleaf.net"
    ],
    "foursquare.com": [
      "swarmapp.com"
    ],
    "swarmapp.com": [
      "foursquare.com"
    ],
    "glassdoor.ca": [
      "glassdoor.com",
      "glassdoor.com.ar"
    ],
    "glassdoor.com": [
      "glassdoor.ca",
      "glassdoor.com.ar"
    ],
    "glassdoor.com.ar": [
      "glassdoor.ca",
      "glassdoor.com"
    ],
    "gogoair.com": [
      "gogoinflight.com"
    ],
    "gogoinflight.com": [
      "gogoair.com"
    ],
    "igen.fr": [
      "macg.co",
      "watchgeneration.fr"
    ],
    "watchgeneration.fr": [
      "igen.fr",
      "macg.co"
    ],
    "macg.co": [
      "igen.fr",
      "watchgeneration.fr"
    ],
    "ikonpass.com": [
      "skilynx.com"
    ],
    "skilynx.com": [
      "ikonpass.com"
    ],
    "intuit.com": [
      "mint.com"
    ],
    "mint.com": [
      "intuit.com"
    ],
    "kaiserpermanente.org": [
      "kp.org"
    ],
    "kp.org": [
      "kaiserpermanente.org"
    ],
    "kclibrary.overdrive.com": [
      "kclibrary.bibliocommons.com"
    ],
    "kclibrary.bibliocommons.com": [
      "kclibrary.overdrive.com"
    ],
    "kcls.bibliocommons.com": [
      "kcls.org",
      "kcls.overdrive.com"
    ],
    "kcls.overdrive.com": [
      "kcls.bibliocommons.com",
      "kcls.org"
    ],
    "kcls.org": [
      "kcls.bibliocommons.com",
      "kcls.overdrive.com"
    ],
    "liebherr.com": [
      "myliebherr.com"
    ],
    "myliebherr.com": [
      "liebherr.com"
    ],
    "logitech.com": [
      "astrogaming.com",
      "logi.com",
      "logitechg.com",
      "ultimateears.com"
    ],
    "logitechg.com": [
      "astrogaming.com",
      "logi.com",
      "logitech.com",
      "ultimateears.com"
    ],
    "logi.com": [
      "astrogaming.com",
      "logitech.com",
      "logitechg.com",
      "ultimateears.com"
    ],
    "astrogaming.com": [
      "logi.com",
      "logitech.com",
      "logitechg.com",
      "ultimateears.com"
    ],
    "ultimateears.com": [
      "astrogaming.com",
      "logi.com",
      "logitech.com",
      "logitechg.com"
    ],
    "lookmark.io": [
      "lookmark.link"
    ],
    "lookmark.link": [
      "lookmark.io"
    ],
    "lufthansa.com": [
      "miles-and-more.com"
    ],
    "miles-and-more.com": [
      "lufthansa.com"
    ],
    "marriott.com": [
      "marriottrewards.com",
      "ritzcarlton.com",
      "spg.com",
      "starwoodhotels.com"
    ],
    "marriottrewards.com": [
      "marriott.com",
      "ritzcarlton.com",
      "spg.com",
      "starwoodhotels.com"
    ],
    "ritzcarlton.com": [
      "marriott.com",
      "marriottrewards.com",
      "spg.com",
      "starwoodhotels.com"
    ],
    "spg.com": [
      "marriott.com",
      "marriottrewards.com",
      "ritzcarlton.com",
      "starwoodhotels.com"
    ],
    "starwoodhotels.com": [
      "marriott.com",
      "marriottrewards.com",
      "ritzcarlton.com",
      "spg.com"
    ],
    "microsoft.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "live.com": [
      "azure.com",
      "hotmail.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "microsoftonline.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "office.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "onenote.com",
      "skype.com"
    ],
    "skype.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com"
    ],
    "onenote.com": [
      "azure.com",
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "skype.com"
    ],
    "hotmail.com": [
      "azure.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "azure.com": [
      "hotmail.com",
      "live.com",
      "microsoft.com",
      "microsoftonline.com",
      "office.com",
      "onenote.com",
      "skype.com"
    ],
    "minecraft.net": [
      "mojang.com"
    ],
    "mojang.com": [
      "minecraft.net"
    ],
    "mytotalconnectcomfort.com": [
      "tccna.honeywell.com"
    ],
    "tccna.honeywell.com": [
      "mytotalconnectcomfort.com"
    ],
    "myuhc.com": [
      "optum.com",
      "optumrx.com",
      "uhc.com"
    ],
    "uhc.com": [
      "myuhc.com",
      "optum.com",
      "optumrx.com"
    ],
    "optum.com": [
      "myuhc.com",
      "optumrx.com",
      "uhc.com"
    ],
    "optumrx.com": [
      "myuhc.com",
      "optum.com",
      "uhc.com"
    ],
    "neatorama.com": [
      "neatoshop.com"
    ],
    "neatoshop.com": [
      "neatorama.com"
    ],
    "newyorker.com": [
      "vanityfair.com"
    ],
    "vanityfair.com": [
      "newyorker.com"
    ],
    "nintendolife.com": [
      "purexbox.com",
      "pushsquare.com"
    ],
    "purexbox.com": [
      "nintendolife.com",
      "pushsquare.com"
    ],
    "pushsquare.com": [
      "nintendolife.com",
      "purexbox.com"
    ],
    "nokia.com": [
      "alcatel-lucent.com",
      "nsn-rdnet.net",
      "nsn.com"
    ],
    "alcatel-lucent.com": [
      "nokia.com",
      "nsn-rdnet.net",
      "nsn.com"
    ],
    "nsn-rdnet.net": [
      "alcatel-lucent.com",
      "nokia.com",
      "nsn.com"
    ],
    "nsn.com": [
      "alcatel-lucent.com",
      "nokia.com",
      "nsn-rdnet.net"
    ],
    "norwegian.com": [
      "norwegianreward.com"
    ],
    "norwegianreward.com": [
      "norwegian.com"
    ],
    "olo.com": [
      "olo.express"
    ],
    "olo.express": [
      "olo.com"
    ],
    "pocket.com": [
      "getpocket.com"
    ],
    "getpocket.com": [
      "pocket.com"
    ],
    "probikeshop.fr": [
      "bikeshop.es",
      "probikeshop.com",
      "probikeshop.it",
      "probikeshop.pt"
    ],
    "bikeshop.es": [
      "probikeshop.com",
      "probikeshop.fr",
      "probikeshop.it",
      "probikeshop.pt"
    ],
    "probikeshop.it": [
      "bikeshop.es",
      "probikeshop.com",
      "probikeshop.fr",
      "probikeshop.pt"
    ],
    "probikeshop.pt": [
      "bikeshop.es",
      "probikeshop.com",
      "probikeshop.fr",
      "probikeshop.it"
    ],
    "probikeshop.com": [
      "bikeshop.es",
      "probikeshop.fr",
      "probikeshop.it",
      "probikeshop.pt"
    ],
    "qnap.com": [
      "myqnapcloud.com"
    ],
    "myqnapcloud.com": [
      "qnap.com"
    ],
    "questdiagnostics.com": [
      "care360.com"
    ],
    "care360.com": [
      "questdiagnostics.com"
    ],
    "rocketaccount.com": [
      "rocketmortgage.com"
    ],
    "rocketmortgage.com": [
      "rocketaccount.com"
    ],
    "scholarshare529.com": [
      "secureaccountview.com"
    ],
    "secureaccountview.com": [
      "scholarshare529.com"
    ],
    "scoutingevent.com": [
      "campreservation.com"
    ],
    "campreservation.com": [
      "scoutingevent.com"
    ],
    "scribbr.com": [
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.de": [
      "scribbr.com",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.dk": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.es": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.fi": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.fr": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.it": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.nl",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.nl": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.no",
      "scribbr.se"
    ],
    "scribbr.no": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.se"
    ],
    "scribbr.se": [
      "scribbr.com",
      "scribbr.de",
      "scribbr.dk",
      "scribbr.es",
      "scribbr.fi",
      "scribbr.fr",
      "scribbr.it",
      "scribbr.nl",
      "scribbr.no"
    ],
    "seattle.bibliocommons.com": [
      "spl.org",
      "spl.overdrive.com"
    ],
    "spl.overdrive.com": [
      "seattle.bibliocommons.com",
      "spl.org"
    ],
    "spl.org": [
      "seattle.bibliocommons.com",
      "spl.overdrive.com"
    ],
    "sfpl.bibliocommons.com": [
      "sfpl.overdrive.com"
    ],
    "sfpl.overdrive.com": [
      "sfpl.bibliocommons.com"
    ],
    "slcl.overdrive.com": [
      "slcl.org"
    ],
    "slcl.org": [
      "slcl.overdrive.com"
    ],
    "slpl.bibliocommons.com": [
      "slpl.overdrive.com"
    ],
    "slpl.overdrive.com": [
      "slpl.bibliocommons.com"
    ],
    "sonyentertainmentnetwork.com": [
      "sony.com"
    ],
    "sony.com": [
      "sonyentertainmentnetwork.com"
    ],
    "spark.net": [
      "jdate.com"
    ],
    "jdate.com": [
      "spark.net"
    ],
    "spirit.com": [
      "spirit-airlines.com"
    ],
    "spirit-airlines.com": [
      "spirit.com"
    ],
    "springfield.overdrive.com": [
      "coolcat.org"
    ],
    "coolcat.org": [
      "springfield.overdrive.com"
    ],
    "square.com": [
      "squareup.com"
    ],
    "squareup.com": [
      "square.com"
    ],
    "stackoverflow.com": [
      "askubuntu.com",
      "serverfault.com",
      "stackexchange.com",
      "superuser.com"
    ],
    "askubuntu.com": [
      "serverfault.com",
      "stackexchange.com",
      "stackoverflow.com",
      "superuser.com"
    ],
    "serverfault.com": [
      "askubuntu.com",
      "stackexchange.com",
      "stackoverflow.com",
      "superuser.com"
    ],
    "stackexchange.com": [
      "askubuntu.com",
      "serverfault.com",
      "stackoverflow.com",
      "superuser.com"
    ],
    "superuser.com": [
      "askubuntu.com",
      "serverfault.com",
      "stackexchange.com",
      "stackoverflow.com"
    ],
    "telekom-dienste.de": [
      "accounts.login.idm.telekom.com"
    ],
    "accounts.login.idm.telekom.com": [
      "telekom-dienste.de"
    ],
    "tesla.com": [
      "teslamotors.com"
    ],
    "teslamotors.com": [
      "tesla.com"
    ],
    "ticketmaster.com": [
      "livenation.com"
    ],
    "livenation.com": [
      "ticketmaster.com"
    ],
    "tp-link.com": [
      "tplinkcloud.com"
    ],
    "tplinkcloud.com": [
      "tp-link.com"
    ],
    "turkishairlines.com": [
      "thy.com"
    ],
    "thy.com": [
      "turkishairlines.com"
    ],
    "ubi.com": [
      "ubisoft.com"
    ],
    "ubisoft.com": [
      "ubi.com"
    ],
    "umsystem.edu": [
      "missouri.edu",
      "mst.edu",
      "umkc.edu",
      "umsl.edu"
    ],
    "mst.edu": [
      "missouri.edu",
      "umkc.edu",
      "umsl.edu",
      "umsystem.edu"
    ],
    "umkc.edu": [
      "missouri.edu",
      "mst.edu",
      "umsl.edu",
      "umsystem.edu"
    ],
    "umsl.edu": [
      "missouri.edu",
      "mst.edu",
      "umkc.edu",
      "umsystem.edu"
    ],
    "missouri.edu": [
      "mst.edu",
      "umkc.edu",
      "umsl.edu",
      "umsystem.edu"
    ],
    "united.com": [
      "unitedwifi.com"
    ],
    "unitedwifi.com": [
      "united.com"
    ],
    "verizon.com": [
      "verizonwireless.com",
      "vzw.com"
    ],
    "verizonwireless.com": [
      "verizon.com",
      "vzw.com"
    ],
    "vzw.com": [
      "verizon.com",
      "verizonwireless.com"
    ],
    "wayfair.com": [
      "allmodern.com",
      "birchlane.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.ca"
    ],
    "wayfair.ca": [
      "allmodern.com",
      "birchlane.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.com"
    ],
    "jossandmain.com": [
      "allmodern.com",
      "birchlane.com",
      "perigold.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "allmodern.com": [
      "birchlane.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "perigold.com": [
      "allmodern.com",
      "birchlane.com",
      "jossandmain.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "birchlane.com": [
      "allmodern.com",
      "jossandmain.com",
      "perigold.com",
      "wayfair.ca",
      "wayfair.com"
    ],
    "wellsfargo.com": [
      "wellsfargoadvisors.com"
    ],
    "wellsfargoadvisors.com": [
      "wellsfargo.com"
    ],
    "wiimmfi.de": [
      "wii-homebrew.com"
    ],
    "wii-homebrew.com": [
      "wiimmfi.de"
    ],
    "williams-sonoma.com": [
      "markandgraham.com",
      "potterybarn.com",
      "westelm.com"
    ],
    "markandgraham.com": [
      "potterybarn.com",
      "westelm.com",
      "williams-sonoma.com"
    ],
    "potterybarn.com": [
      "markandgraham.com",
      "westelm.com",
      "williams-sonoma.com"
    ],
    "westelm.com": [
      "markandgraham.com",
      "potterybarn.com",
      "williams-sonoma.com"
    ],
    "wilson.com": [
      "atecsports.com",
      "demarini.com",
      "evoshield.com",
      "luxilon.com",
      "slugger.com"
    ],
    "slugger.com": [
      "atecsports.com",
      "demarini.com",
      "evoshield.com",
      "luxilon.com",
      "wilson.com"
    ],
    "atecsports.com": [
      "demarini.com",
      "evoshield.com",
      "luxilon.com",
      "slugger.com",
      "wilson.com"
    ],
    "demarini.com": [
      "atecsports.com",
      "evoshield.com",
      "luxilon.com",
      "slugger.com",
      "wilson.com"
    ],
    "evoshield.com": [
      "atecsports.com",
      "demarini.com",
      "luxilon.com",
      "slugger.com",
      "wilson.com"
    ],
    "luxilon.com": [
      "atecsports.com",
      "demarini.com",
      "evoshield.com",
      "slugger.com",
      "wilson.com"
    ],
    "worldlink.com.np": [
      "nettv.com.np"
    ],
    "nettv.com.np": [
      "worldlink.com.np"
    ],
    "wsj.com": [
      "dowjones.com"
    ],
    "dowjones.com": [
      "wsj.com"
    ],
    "zixmail.net": [
      "zixmessagecenter.com"
    ],
    "zixmessagecenter.com": [
      "zixmail.net"
    ],
    "sackrace.ai": [],
    "poalim.xyz": [
      "poalim.site"
    ],
    "poalim.site": [
      "poalim.xyz"
    ],
    "nacion.com": [
      "elfinancierocr.com",
      "lateja.cr"
    ],
    "lateja.cr": [
      "elfinancierocr.com",
      "nacion.com"
    ],
    "elfinancierocr.com": [
      "lateja.cr",
      "nacion.com"
    ],
    "wp.pl": [
      "abczdrowie.pl",
      "money.pl",
      "o2.pl",
      "pudelek.pl",
      "wpext.pl"
    ],
    "o2.pl": [
      "abczdrowie.pl",
      "money.pl",
      "pudelek.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "pudelek.pl": [
      "abczdrowie.pl",
      "money.pl",
      "o2.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "money.pl": [
      "abczdrowie.pl",
      "o2.pl",
      "pudelek.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "abczdrowie.pl": [
      "money.pl",
      "o2.pl",
      "pudelek.pl",
      "wp.pl",
      "wpext.pl"
    ],
    "wpext.pl": [
      "abczdrowie.pl",
      "money.pl",
      "o2.pl",
      "pudelek.pl",
      "wp.pl"
    ],
    "cafemedia.com": [
      "cardsayings.net",
      "nourishingpursuits.com"
    ],
    "cardsayings.net": [
      "cafemedia.com",
      "nourishingpursuits.com"
    ],
    "nourishingpursuits.com": [
      "cafemedia.com",
      "cardsayings.net"
    ],
    "bild.de": [
      "autobild.de",
      "computerbild.de",
      "welt.de",
      "wieistmeineip.de"
    ],
    "welt.de": [
      "autobild.de",
      "bild.de",
      "computerbild.de",
      "wieistmeineip.de"
    ],
    "autobild.de": [
      "bild.de",
      "computerbild.de",
      "welt.de",
      "wieistmeineip.de"
    ],
    "computerbild.de": [
      "autobild.de",
      "bild.de",
      "welt.de",
      "wieistmeineip.de"
    ],
    "wieistmeineip.de": [
      "autobild.de",
      "bild.de",
      "computerbild.de",
      "welt.de"
    ],
    "gliadomain.com": [
      "salemoveadvisor.com",
      "salemovefinancial.com",
      "salemovetravel.com"
    ],
    "salemoveadvisor.com": [
      "gliadomain.com",
      "salemovefinancial.com",
      "salemovetravel.com"
    ],
    "salemovefinancial.com": [
      "gliadomain.com",
      "salemoveadvisor.com",
      "salemovetravel.com"
    ],
    "salemovetravel.com": [
      "gliadomain.com",
      "salemoveadvisor.com",
      "salemovefinancial.com"
    ],
    "hapara.com": [
      "mystudentdashboard.com",
      "teacherdashboard.com"
    ],
    "teacherdashboard.com": [
      "hapara.com",
      "mystudentdashboard.com"
    ],
    "mystudentdashboard.com": [
      "hapara.com",
      "teacherdashboard.com"
    ],
    "songstats.com": [
      "songshare.com"
    ],
    "songshare.com": [
      "songstats.com"
    ],
    "hindustantimes.com": [
      "desimartini.com",
      "healthshots.com",
      "livehindustan.com",
      "livemint.com",
      "ottplay.com"
    ],
    "livemint.com": [
      "desimartini.com",
      "healthshots.com",
      "hindustantimes.com",
      "livehindustan.com",
      "ottplay.com"
    ],
    "livehindustan.com": [
      "desimartini.com",
      "healthshots.com",
      "hindustantimes.com",
      "livemint.com",
      "ottplay.com"
    ],
    "healthshots.com": [
      "desimartini.com",
      "hindustantimes.com",
      "livehindustan.com",
      "livemint.com",
      "ottplay.com"
    ],
    "ottplay.com": [
      "desimartini.com",
      "healthshots.com",
      "hindustantimes.com",
      "livehindustan.com",
      "livemint.com"
    ],
    "desimartini.com": [
      "healthshots.com",
      "hindustantimes.com",
      "livehindustan.com",
      "livemint.com",
      "ottplay.com"
    ],
    "landyrev.com": [
      "landyrev.ru"
    ],
    "landyrev.ru": [
      "landyrev.com"
    ],
    "jagran.com": [
      "gujaratijagran.com",
      "punjabijagran.com"
    ],
    "gujaratijagran.com": [
      "jagran.com",
      "punjabijagran.com"
    ],
    "punjabijagran.com": [
      "gujaratijagran.com",
      "jagran.com"
    ],
    "mercadolibre.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadolivre.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadopago.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "portalinmobiliario.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "tucarro.com": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.ar": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.br": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.mx": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.cl": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "mercadoshops.com.co": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co",
      "tucarro.com.ve"
    ],
    "tucarro.com.co": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.ve"
    ],
    "tucarro.com.ve": [
      "mercadolibre.cl",
      "mercadolibre.co.cr",
      "mercadolibre.com",
      "mercadolibre.com.ar",
      "mercadolibre.com.bo",
      "mercadolibre.com.co",
      "mercadolibre.com.do",
      "mercadolibre.com.ec",
      "mercadolibre.com.gt",
      "mercadolibre.com.hn",
      "mercadolibre.com.mx",
      "mercadolibre.com.ni",
      "mercadolibre.com.pa",
      "mercadolibre.com.pe",
      "mercadolibre.com.py",
      "mercadolibre.com.sv",
      "mercadolibre.com.uy",
      "mercadolibre.com.ve",
      "mercadolivre.com",
      "mercadolivre.com.br",
      "mercadopago.cl",
      "mercadopago.com",
      "mercadopago.com.ar",
      "mercadopago.com.br",
      "mercadopago.com.co",
      "mercadopago.com.ec",
      "mercadopago.com.mx",
      "mercadopago.com.pe",
      "mercadopago.com.uy",
      "mercadopago.com.ve",
      "mercadoshops.cl",
      "mercadoshops.com",
      "mercadoshops.com.ar",
      "mercadoshops.com.br",
      "mercadoshops.com.co",
      "mercadoshops.com.mx",
      "portalinmobiliario.com",
      "tucarro.com",
      "tucarro.com.co"
    ],
    "joyreactor.cc": [
      "cookreactor.com",
      "joyreactor.com",
      "reactor.cc"
    ],
    "reactor.cc": [
      "cookreactor.com",
      "joyreactor.cc",
      "joyreactor.com"
    ],
    "cookreactor.com": [
      "joyreactor.cc",
      "joyreactor.com",
      "reactor.cc"
    ],
    "joyreactor.com": [
      "cookreactor.com",
      "joyreactor.cc",
      "reactor.cc"
    ],
    "unotv.com": [
      "clarosports.com"
    ],
    "clarosports.com": [
      "unotv.com"
    ],
    "idbs-cloud.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-dev.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "idbs-dev.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "idbs-staging.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-eworkbook.com"
    ],
    "idbs-eworkbook.com": [
      "eworkbookcloud.com",
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-staging.com"
    ],
    "eworkbookcloud.com": [
      "eworkbookrequest.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "eworkbookrequest.com": [
      "eworkbookcloud.com",
      "idbs-cloud.com",
      "idbs-dev.com",
      "idbs-eworkbook.com",
      "idbs-staging.com"
    ],
    "mightytext.net": [],
    "vwo.com": [
      "wingify.com"
    ],
    "wingify.com": [
      "vwo.com"
    ],
    "wildix.com": [
      "wildixin.com"
    ],
    "wildixin.com": [
      "wildix.com"
    ],
    "timesinternet.in": [
      "cricbuzz.com",
      "economictimes.com",
      "indiatimes.com",
      "samayam.com",
      "timesofindia.com"
    ],
    "indiatimes.com": [
      "cricbuzz.com",
      "economictimes.com",
      "samayam.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "timesofindia.com": [
      "cricbuzz.com",
      "economictimes.com",
      "indiatimes.com",
      "samayam.com",
      "timesinternet.in"
    ],
    "economictimes.com": [
      "cricbuzz.com",
      "indiatimes.com",
      "samayam.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "samayam.com": [
      "cricbuzz.com",
      "economictimes.com",
      "indiatimes.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "cricbuzz.com": [
      "economictimes.com",
      "indiatimes.com",
      "samayam.com",
      "timesinternet.in",
      "timesofindia.com"
    ],
    "hc1.com": [
      "hc1.global"
    ],
    "hc1.global": [
      "hc1.com"
    ],
    "kompas.com": [
      "bolasport.com",
      "grid.id",
      "kompas.tv",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "tribunnews.com": [
      "bolasport.com",
      "grid.id",
      "kompas.com",
      "kompas.tv",
      "kompasiana.com"
    ],
    "grid.id": [
      "bolasport.com",
      "kompas.com",
      "kompas.tv",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "bolasport.com": [
      "grid.id",
      "kompas.com",
      "kompas.tv",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "kompasiana.com": [
      "bolasport.com",
      "grid.id",
      "kompas.com",
      "kompas.tv",
      "tribunnews.com"
    ],
    "kompas.tv": [
      "bolasport.com",
      "grid.id",
      "kompas.com",
      "kompasiana.com",
      "tribunnews.com"
    ],
    "journaldesfemmes.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "commentcamarche.net": [
      "commentcamarche.com",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "linternaute.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "journaldunet.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "phonandroid.com": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr"
    ],
    "commentcamarche.com": [
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "journaldesfemmes.fr": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "linternaute.fr": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "journaldunet.fr",
      "linternaute.com",
      "phonandroid.com"
    ],
    "journaldunet.fr": [
      "commentcamarche.com",
      "commentcamarche.net",
      "journaldesfemmes.com",
      "journaldesfemmes.fr",
      "journaldunet.com",
      "linternaute.com",
      "linternaute.fr",
      "phonandroid.com"
    ],
    "johndeere.com": [
      "deere.com"
    ],
    "deere.com": [
      "johndeere.com"
    ],
    "lanacion.com.ar": [
      "bonvivir.com"
    ],
    "bonvivir.com": [
      "lanacion.com.ar"
    ],
    "nien.com": [
      "chennien.com",
      "nien.co",
      "nien.org"
    ],
    "chennien.com": [
      "nien.co",
      "nien.com",
      "nien.org"
    ],
    "nien.org": [
      "chennien.com",
      "nien.co",
      "nien.com"
    ],
    "nien.co": [
      "chennien.com",
      "nien.com",
      "nien.org"
    ],
    "hearty.me": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "hearty.app": [
      "alice.tw",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "hearty.gift": [
      "alice.tw",
      "hearty.app",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "hj.rs": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "jiayi.life",
      "miss.com.tw"
    ],
    "heartymail.com": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "alice.tw": [
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life",
      "miss.com.tw"
    ],
    "jiayi.life": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "miss.com.tw"
    ],
    "miss.com.tw": [
      "alice.tw",
      "hearty.app",
      "hearty.gift",
      "hearty.me",
      "heartymail.com",
      "hj.rs",
      "jiayi.life"
    ],
    "talkdeskqaid.com": [
      "trytalkdesk.com"
    ],
    "trytalkdesk.com": [
      "talkdeskqaid.com"
    ],
    "talkdeskstgid.com": [
      "gettalkdesk.com"
    ],
    "gettalkdesk.com": [
      "talkdeskstgid.com"
    ],
    "onet.pl": [
      "businessinsider.com.pl",
      "fakt.pl",
      "medonet.pl",
      "plejada.pl"
    ],
    "fakt.pl": [
      "businessinsider.com.pl",
      "medonet.pl",
      "onet.pl",
      "plejada.pl"
    ],
    "businessinsider.com.pl": [
      "fakt.pl",
      "medonet.pl",
      "onet.pl",
      "plejada.pl"
    ],
    "medonet.pl": [
      "businessinsider.com.pl",
      "fakt.pl",
      "onet.pl",
      "plejada.pl"
    ],
    "plejada.pl": [
      "businessinsider.com.pl",
      "fakt.pl",
      "medonet.pl",
      "onet.pl"
    ],
    "elpais.com.uy": [
      "clubelpais.com.uy",
      "elpais.uy",
      "gallito.com.uy",
      "paula.com.uy"
    ],
    "clubelpais.com.uy": [
      "elpais.com.uy",
      "elpais.uy",
      "gallito.com.uy",
      "paula.com.uy"
    ],
    "paula.com.uy": [
      "clubelpais.com.uy",
      "elpais.com.uy",
      "elpais.uy",
      "gallito.com.uy"
    ],
    "gallito.com.uy": [
      "clubelpais.com.uy",
      "elpais.com.uy",
      "elpais.uy",
      "paula.com.uy"
    ],
    "elpais.uy": [
      "clubelpais.com.uy",
      "elpais.com.uy",
      "gallito.com.uy",
      "paula.com.uy"
    ],
    "libero.it": [
      "supereva.it"
    ],
    "supereva.it": [
      "libero.it"
    ],
    "rws1nvtvt.com": [
      "rws2nvtvt.com",
      "rws3nvtvt.com"
    ],
    "rws2nvtvt.com": [
      "rws1nvtvt.com",
      "rws3nvtvt.com"
    ],
    "rws3nvtvt.com": [
      "rws1nvtvt.com",
      "rws2nvtvt.com"
    ],
    "stripe.com": [],
    "repid.org": [
      "human-talk.org",
      "reshim.org"
    ],
    "reshim.org": [
      "human-talk.org",
      "repid.org"
    ],
    "human-talk.org": [
      "repid.org",
      "reshim.org"
    ],
    "ya.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.net": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "turbopages.org": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "auto.ru": [
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "kinopoisk.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "clck.ru": [
      "auto.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "edadeal.ru": [
      "auto.ru",
      "clck.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "webvisor.com": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yastatic.net": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz"
    ],
    "ya.cc": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.az": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.by": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.kz": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.md": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.tj": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.tm": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.uz": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yastatic.net"
    ],
    "yandex.st": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.com": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com.am",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.com.am": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.ru",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "yandex.com.ru": [
      "auto.ru",
      "clck.ru",
      "edadeal.ru",
      "kinopoisk.ru",
      "turbopages.org",
      "webvisor.com",
      "ya.cc",
      "ya.ru",
      "yandex.az",
      "yandex.by",
      "yandex.com",
      "yandex.com.am",
      "yandex.kz",
      "yandex.md",
      "yandex.net",
      "yandex.ru",
      "yandex.st",
      "yandex.tj",
      "yandex.tm",
      "yandex.uz",
      "yastatic.net"
    ],
    "victorymedium.com": [
      "standardsandpraiserepurpose.com"
    ],
    "standardsandpraiserepurpose.com": [
      "victorymedium.com"
    ],
    "startupislandtaiwan.com": [
      "startupislandtaiwan.net",
      "startupislandtaiwan.org"
    ],
    "startupislandtaiwan.net": [
      "startupislandtaiwan.com",
      "startupislandtaiwan.org"
    ],
    "startupislandtaiwan.org": [
      "startupislandtaiwan.com",
      "startupislandtaiwan.net"
    ],
    "carcostadvisor.com": [
      "carcostadvisor.be",
      "carcostadvisor.fr"
    ],
    "carcostadvisor.be": [
      "carcostadvisor.com",
      "carcostadvisor.fr"
    ],
    "carcostadvisor.fr": [
      "carcostadvisor.be",
      "carcostadvisor.com"
    ],
    "caracoltv.com": [
      "bluradio.com",
      "bumbox.com",
      "hjck.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "noticiascaracol.com": [
      "bluradio.com",
      "bumbox.com",
      "caracoltv.com",
      "hjck.com",
      "shock.co"
    ],
    "bluradio.com": [
      "bumbox.com",
      "caracoltv.com",
      "hjck.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "shock.co": [
      "bluradio.com",
      "bumbox.com",
      "caracoltv.com",
      "hjck.com",
      "noticiascaracol.com"
    ],
    "bumbox.com": [
      "bluradio.com",
      "caracoltv.com",
      "hjck.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "hjck.com": [
      "bluradio.com",
      "bumbox.com",
      "caracoltv.com",
      "noticiascaracol.com",
      "shock.co"
    ],
    "max.auto": [
      "firstlook.biz"
    ],
    "firstlook.biz": [
      "max.auto"
    ],
    "gridgames.app": [
      "wordle.at"
    ],
    "wordle.at": [
      "gridgames.app"
    ],
    "blackrock.com": [
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "efront.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "blackrockadvisorelite.it": [
      "blackrock.com",
      "cachematrix.com",
      "efront.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "cachematrix.com": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "efront.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "efront.com": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "etfacademy.it",
      "ishares.com"
    ],
    "etfacademy.it": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "efront.com",
      "ishares.com"
    ],
    "ishares.com": [
      "blackrock.com",
      "blackrockadvisorelite.it",
      "cachematrix.com",
      "efront.com",
      "etfacademy.it"
    ],
    "tvn.pl": [
      "player.pl",
      "tvn24.pl",
      "zdrowietvn.pl"
    ],
    "player.pl": [
      "tvn.pl",
      "tvn24.pl",
      "zdrowietvn.pl"
    ],
    "tvn24.pl": [
      "player.pl",
      "tvn.pl",
      "zdrowietvn.pl"
    ],
    "zdrowietvn.pl": [
      "player.pl",
      "tvn.pl",
      "tvn24.pl"
    ],
    "zalo.me": [
      "baomoi.com",
      "smoney.vn",
      "zingmp3.vn"
    ],
    "zingmp3.vn": [
      "baomoi.com",
      "smoney.vn",
      "zalo.me"
    ],
    "baomoi.com": [
      "smoney.vn",
      "zalo.me",
      "zingmp3.vn"
    ],
    "smoney.vn": [
      "baomoi.com",
      "zalo.me",
      "zingmp3.vn"
    ],
    "finn.no": [
      "mittanbud.no",
      "prisjakt.no"
    ],
    "prisjakt.no": [
      "finn.no",
      "mittanbud.no"
    ],
    "mittanbud.no": [
      "finn.no",
      "prisjakt.no"
    ],
    "laprensagrafica.com": [
      "eleconomista.net",
      "elgrafico.com",
      "ella.sv",
      "grupolpg.sv"
    ],
    "elgrafico.com": [
      "eleconomista.net",
      "ella.sv",
      "grupolpg.sv",
      "laprensagrafica.com"
    ],
    "eleconomista.net": [
      "elgrafico.com",
      "ella.sv",
      "grupolpg.sv",
      "laprensagrafica.com"
    ],
    "ella.sv": [
      "eleconomista.net",
      "elgrafico.com",
      "grupolpg.sv",
      "laprensagrafica.com"
    ],
    "grupolpg.sv": [
      "eleconomista.net",
      "elgrafico.com",
      "ella.sv",
      "laprensagrafica.com"
    ],
    "kaksya.in": [
      "nidhiacademyonline.com"
    ],
    "nidhiacademyonline.com": [
      "kaksya.in"
    ],
    "vrt.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio1.be",
      "radio2.be",
      "sporza.be"
    ],
    "dewarmsteweek.be": [
      "een.be",
      "radio1.be",
      "radio2.be",
      "sporza.be",
      "vrt.be"
    ],
    "sporza.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio1.be",
      "radio2.be",
      "vrt.be"
    ],
    "een.be": [
      "dewarmsteweek.be",
      "radio1.be",
      "radio2.be",
      "sporza.be",
      "vrt.be"
    ],
    "radio2.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio1.be",
      "sporza.be",
      "vrt.be"
    ],
    "radio1.be": [
      "dewarmsteweek.be",
      "een.be",
      "radio2.be",
      "sporza.be",
      "vrt.be"
    ],
    "nvidia.com": [
      "geforcenow.com"
    ],
    "geforcenow.com": [
      "nvidia.com"
    ],
    "sapo.pt": [
      "meo.pt",
      "sapo.io"
    ],
    "meo.pt": [
      "sapo.io",
      "sapo.pt"
    ],
    "sapo.io": [
      "meo.pt",
      "sapo.pt"
    ],
    "tolteck.com": [
      "tolteck.app"
    ],
    "tolteck.app": [
      "tolteck.com"
    ],
    "p24.hu": [
      "24.hu",
      "hazipatika.com",
      "nlc.hu",
      "nosalty.hu",
      "startlap.hu"
    ],
    "24.hu": [
      "hazipatika.com",
      "nlc.hu",
      "nosalty.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "startlap.hu": [
      "24.hu",
      "hazipatika.com",
      "nlc.hu",
      "nosalty.hu",
      "p24.hu"
    ],
    "nlc.hu": [
      "24.hu",
      "hazipatika.com",
      "nosalty.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "hazipatika.com": [
      "24.hu",
      "nlc.hu",
      "nosalty.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "nosalty.hu": [
      "24.hu",
      "hazipatika.com",
      "nlc.hu",
      "p24.hu",
      "startlap.hu"
    ],
    "cognitiveai.ru": [
      "cognitive-ai.ru"
    ],
    "cognitive-ai.ru": [
      "cognitiveai.ru"
    ],
    "citybibleforum.org": [
      "thirdspace.org.au"
    ],
    "thirdspace.org.au": [
      "citybibleforum.org"
    ],
    "p106.net": [
      "smpn106jkt.sch.id"
    ],
    "smpn106jkt.sch.id": [
      "p106.net"
    ],
    "indiatoday.in": [
      "aajtak.in",
      "businesstoday.in",
      "gnttv.com",
      "indiatodayne.in",
      "intoday.in"
    ],
    "aajtak.in": [
      "businesstoday.in",
      "gnttv.com",
      "indiatoday.in",
      "indiatodayne.in",
      "intoday.in"
    ],
    "businesstoday.in": [
      "aajtak.in",
      "gnttv.com",
      "indiatoday.in",
      "indiatodayne.in",
      "intoday.in"
    ],
    "intoday.in": [
      "aajtak.in",
      "businesstoday.in",
      "gnttv.com",
      "indiatoday.in",
      "indiatodayne.in"
    ],
    "gnttv.com": [
      "aajtak.in",
      "businesstoday.in",
      "indiatoday.in",
      "indiatodayne.in",
      "intoday.in"
    ],
    "indiatodayne.in": [
      "aajtak.in",
      "businesstoday.in",
      "gnttv.com",
      "indiatoday.in",
      "intoday.in"
    ],
    "naukri.com": [
      "ambitionbox.com",
      "infoedgeindia.com"
    ],
    "ambitionbox.com": [
      "infoedgeindia.com",
      "naukri.com"
    ],
    "infoedgeindia.com": [
      "ambitionbox.com",
      "naukri.com"
    ],
    "text.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com"
    ],
    "livechat.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "helpdesk.com": [
      "chatbot.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "chatbot.com": [
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "livechatinc.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "openwidget.com",
      "text.com"
    ],
    "knowledgebase.com": [
      "chatbot.com",
      "helpdesk.com",
      "livechat.com",
      "livechatinc.com",
      "openwidget.com",
      "text.com"
    ],
    "openwidget.com": [
      "chatbot.com",
      "helpdesk.com",
      "knowledgebase.com",
      "livechat.com",
      "livechatinc.com",
      "text.com"
    ],
    "thejournal.ie": [
      "the42.ie"
    ],
    "the42.ie": [
      "thejournal.ie"
    ],
    "html-load.com": [
      "07c225f3.online",
      "content-loader.com",
      "css-load.com",
      "html-load.cc",
      "img-load.com"
    ],
    "css-load.com": [
      "07c225f3.online",
      "content-loader.com",
      "html-load.cc",
      "html-load.com",
      "img-load.com"
    ],
    "img-load.com": [
      "07c225f3.online",
      "content-loader.com",
      "css-load.com",
      "html-load.cc",
      "html-load.com"
    ],
    "content-loader.com": [
      "07c225f3.online",
      "css-load.com",
      "html-load.cc",
      "html-load.com",
      "img-load.com"
    ],
    "07c225f3.online": [
      "content-loader.com",
      "css-load.com",
      "html-load.cc",
      "html-load.com",
      "img-load.com"
    ],
    "html-load.cc": [
      "07c225f3.online",
      "content-loader.com",
      "css-load.com",
      "html-load.com",
      "img-load.com"
    ],
    "interia.pl": [
      "deccoria.pl",
      "pomponik.pl",
      "smaker.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "pomponik.pl": [
      "deccoria.pl",
      "interia.pl",
      "smaker.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "deccoria.pl": [
      "interia.pl",
      "pomponik.pl",
      "smaker.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "top.pl": [
      "deccoria.pl",
      "interia.pl",
      "pomponik.pl",
      "smaker.pl",
      "terazgotuje.pl"
    ],
    "smaker.pl": [
      "deccoria.pl",
      "interia.pl",
      "pomponik.pl",
      "terazgotuje.pl",
      "top.pl"
    ],
    "terazgotuje.pl": [
      "deccoria.pl",
      "interia.pl",
      "pomponik.pl",
      "smaker.pl",
      "top.pl"
    ],
    "graziadaily.co.uk": [
      "closeronline.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "heatworld.com": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "motherandbaby.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "closeronline.co.uk": [
      "graziadaily.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "yours.co.uk": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "takeabreak.co.uk"
    ],
    "motherandbaby.com": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "heatworld.com",
      "takeabreak.co.uk",
      "yours.co.uk"
    ],
    "takeabreak.co.uk": [
      "closeronline.co.uk",
      "graziadaily.co.uk",
      "heatworld.com",
      "motherandbaby.com",
      "yours.co.uk"
    ],
    "drimer.io": [
      "drimer.travel"
    ],
    "drimer.travel": [
      "drimer.io"
    ],
    "zoom.us": [
      "zoom.com"
    ],
    "zoom.com": [
      "zoom.us"
    ]
  };
  function getRelatedDomains(domain) {
    const relatedDomains = getRelatedDomainsDictionary()[domain];
    return relatedDomains;
  }
  function getRelatedDomainsDictionary() {
    return relatedDomainsDictionary;
  }
  function searchPredicate(login, searchString) {
    return getSearchTerms(searchString).every((part) => searchWordPredicate(login, part));
  }
  function searchWordPredicate(login, searchTerm) {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    return login.title.toLowerCase().includes(searchTerm) || login.username.toLowerCase().includes(searchTerm) || login.note.toLowerCase().includes(searchTerm) || ((_a2 = login.creditCard) === null || _a2 === void 0 ? void 0 : _a2.cardHolder.toLowerCase().includes(searchTerm)) || ((_b2 = login.creditCard) === null || _b2 === void 0 ? void 0 : _b2.displayType.toLowerCase().includes(searchTerm)) || // Number is stored normalized with spaces for grouping. Remove to allow searching without. Note;
    // that searchTerm never contains spaces, so no need to also include number with spaces.
    ((_c2 = login.creditCard) === null || _c2 === void 0 ? void 0 : _c2.number.replace(/ /g, "").toLowerCase().includes(searchTerm)) || ((_d2 = login.wifiSsid) === null || _d2 === void 0 ? void 0 : _d2.toLowerCase().includes(searchTerm)) || login.customFields.filter((cf) => !cf.protected).some((cf) => cf.value.toLowerCase().includes(searchTerm)) || searchWordPredicateWebsite(login, searchTerm) || ((_e2 = login.androidApps) === null || _e2 === void 0 ? void 0 : _e2.some((a2) => a2.displayName.toLowerCase().includes(searchTerm))) || ((_f2 = login.tags) === null || _f2 === void 0 ? void 0 : _f2.some((t) => t.toLowerCase().includes(searchTerm)));
  }
  function searchWordPredicateWebsite({ websites }, searchTerm) {
    const match2 = /^www\.(.+)$/.exec(searchTerm);
    const strippedSearchTerm = match2 ? match2[1] : searchTerm;
    if (websites.some((w2) => w2.toLowerCase().includes(strippedSearchTerm))) {
      return true;
    }
    return getRelatedDomainsForWebsites(websites).some((w2) => w2.includes(strippedSearchTerm));
  }
  function getSearchTerms(searchString) {
    return searchString.toLowerCase().trim().split(/\s+/).map((part) => {
      if (part.startsWith("#")) {
        return part.replace(/^#+/, "");
      } else {
        return part;
      }
    });
  }
  function compareLoginsByChangeTime(l, r2) {
    var _a2, _b2;
    const lTime = (_a2 = l.changeTime) !== null && _a2 !== void 0 ? _a2 : l.editTime;
    const rTime = (_b2 = r2.changeTime) !== null && _b2 !== void 0 ? _b2 : r2.editTime;
    return rTime.localeCompare(lTime);
  }
  function getRelatedDomainsForWebsites(websites) {
    const domains = websites.flatMap((website) => {
      try {
        return new URL(`https://${website}`).hostname;
      } catch (e) {
        return [];
      }
    });
    const domainsWithPslApproximation = domains.flatMap((hostname) => {
      const splitHostname = hostname.split(".").reverse();
      const result2 = [];
      let [current, ...rest] = splitHostname;
      for (const part of rest) {
        current = `${part}.${current}`;
        result2.push(current);
      }
      return result2;
    });
    return domainsWithPslApproximation.flatMap((domain) => {
      var _a2;
      return (_a2 = getRelatedDomains(domain)) !== null && _a2 !== void 0 ? _a2 : [];
    });
  }
  function transformLoginTotpForAutofill(l) {
    if (l.totp) {
      return l;
    }
    const { remainingFields, totpField } = filterCustomFields(l.customFields);
    return Object.assign(Object.assign({}, l), { customFields: remainingFields, totp: totpField === null || totpField === void 0 ? void 0 : totpField.value });
  }
  var assertNever$1 = {};
  Object.defineProperty(assertNever$1, "__esModule", { value: true });
  function assertNever(value, noThrow) {
    if (noThrow) {
      return value;
    }
    throw new Error("Unhandled discriminated union member: " + JSON.stringify(value));
  }
  assertNever$1.assertNever = assertNever;
  assertNever$1.default = assertNever;
  function getLoginPermissions(login, vaultPermissions) {
    return {
      editLogin: canEditLogin(login, vaultPermissions),
      deleteLogin: vaultPermissions.deleteLogins,
      moveLogin: vaultPermissions.deleteLogins && // logins can only be moved if they have the viewSecrets permissions
      // as otherwise the secrets could be seen in the target vault
      vaultPermissions.viewSecrets && // linked child logins can never be moved
      !login.linkedFrom,
      viewSecrets: vaultPermissions.viewSecrets && (!login.linkedFrom || !!login.linkedViewSecrets),
      useLogin: vaultPermissions.useLogins,
      viewHistory: vaultPermissions.viewHistory
    };
  }
  function canEditLogin(login, vaultPermissions) {
    return vaultPermissions.editLogins && !login.linkedFrom;
  }
  globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function compareLoginVaultMetadata(l, r2) {
    if (l.type !== r2.type) {
      return compareVaultTypes(l.type, r2.type);
    }
    if (l.type === VaultType.ORGANIZATION_PERSONAL && r2.type === VaultType.ORGANIZATION_PERSONAL && l.owner.isLoggedInUser !== r2.owner.isLoggedInUser) {
      return l.owner.isLoggedInUser ? -1 : 1;
    }
    if (l.type === VaultType.TEAM && r2.type === VaultType.TEAM && !!l.isSyncOrganizationMembers !== !!r2.isSyncOrganizationMembers) {
      return l.isSyncOrganizationMembers ? -1 : 1;
    }
    if (!!l.name !== !!r2.name) {
      return l.name ? -1 : 1;
    }
    if (l.name && r2.name) {
      return l.name.localeCompare(r2.name);
    }
    return 0;
  }
  function compareVaultTypes(l, r2) {
    if (l !== r2) {
      for (const vt of [
        VaultType.PRIVATE,
        VaultType.ORGANIZATION_PERSONAL,
        VaultType.INBOX,
        VaultType.TEAM
      ]) {
        if (l === vt) {
          return -1;
        }
        if (r2 === vt) {
          return 1;
        }
      }
    }
    return 0;
  }
  function getMenuStructure({ accountState, profileRepo, vaultRepo }) {
    var _a2;
    const orgMenus = accountState.organizations.flatMap((organization) => {
      var _a3;
      let profileId;
      if (!organization.isPreliminary) {
        profileId = (_a3 = profileRepo.getOrganizationProfile(organization.id)) === null || _a3 === void 0 ? void 0 : _a3.profile.id;
        if (!profileId) {
          return [];
        }
      }
      const vaults = vaultRepo.getOrganizationLoginVaultPairs(organization.id, {
        includeForeignOrganizationPersonalVaults: true
      }).map((vp) => getLoginVaultMetadata({ accountState, profileRepo }, vp)).sort(compareLoginVaultMetadata);
      return {
        type: "organization",
        profileId,
        organization: getOrganizationMetadata(organization, profileRepo, accountState),
        vaults
      };
    }).sort((l, r2) => l.organization.name.localeCompare(r2.organization.name));
    const privateProfileId = (_a2 = profileRepo.getPrivateProfile()) === null || _a2 === void 0 ? void 0 : _a2.profile.id;
    if (!privateProfileId) {
      return orgMenus;
    }
    const privateVaults = vaultRepo.getPrivateLoginVaultPairs(accountState.organizations.map((o) => o.id)).map((vp) => getLoginVaultMetadata({ accountState, profileRepo }, vp)).sort(compareLoginVaultMetadata);
    if (!privateVaults.length) {
      return orgMenus;
    }
    return [{ type: "private", vaults: privateVaults, profileId: privateProfileId }, ...orgMenus];
  }
  function showLoginVaultOnMobile(pair, accountState) {
    var _a2;
    if (pair.type === VaultType.TEAM) {
      return !getTeamMetaVaultInfo(pair.meta.getContent()).hideOnMobile;
    }
    if (pair.type === VaultType.ORGANIZATION_PERSONAL) {
      if (!pair.login.organizationId) {
        trackError("Personal vault without organization id detected");
        return false;
      }
      const org = accountState.getOrganization(pair.login.organizationId);
      return !((_a2 = org === null || org === void 0 ? void 0 : org.clientSettings) === null || _a2 === void 0 ? void 0 : _a2.hidePersonalLoginsOnMobile);
    }
    if (pair.type === VaultType.PRIVATE) {
      return true;
    }
    if (pair.type === VaultType.INBOX) {
      return false;
    }
    assertExhaustive();
  }
  function L(e, r2) {
    const n = getLoginDisplayInfo(e, r2);
    return {
      ...n,
      headline: n.headline ?? f$2(getValueWithPlaceholder(e == null ? void 0 : e.uiType))
    };
  }
  function f$2(e) {
    switch (e) {
      case LoginUiType.creditCard:
        return i18n._(
          /*i18n*/
          {
            id: "3dKLN3"
          }
        );
      case LoginUiType.wifi:
        return i18n._(
          /*i18n*/
          {
            id: "+jQjTh"
          }
        );
      case LoginUiType.note:
        return i18n._(
          /*i18n*/
          {
            id: "tF8MKq"
          }
        );
      case LoginUiType.login:
      case void 0:
        return i18n._(
          /*i18n*/
          {
            id: "4QFgr2"
          }
        );
    }
  }
  function g$1(e) {
    if (e.name)
      return e.name;
    switch (e.type) {
      case VaultType.PRIVATE:
        return i18n._(
          /*i18n*/
          {
            id: "12Aozu"
          }
        );
      case VaultType.ORGANIZATION_PERSONAL:
        return i18n._(
          /*i18n*/
          {
            id: "oENbfc"
          }
        );
      case VaultType.TEAM:
        return i18n._(
          /*i18n*/
          {
            id: "57/aFB"
          }
        );
      case VaultType.INBOX:
        return i18n._(
          /*i18n*/
          {
            id: "lh348v"
          }
        );
    }
  }
  function C(e) {
    const r2 = e ?? Bowser.parse(window.navigator.userAgent);
    return r2.os.name === "Android" ? false : r2.browser.name === "Chrome" || r2.browser.name === "Microsoft Edge" || r2.browser.name === "Opera" ? true : r2.browser.name === "Firefox" && r2.browser.version ? Number.parseFloat(r2.browser.version) >= 118 : false;
  }
  function m$1(e) {
    var n;
    const r2 = e ?? Bowser.parse(window.navigator.userAgent);
    return r2.platform.type === "desktop" && r2.browser.name === "Safari" && // iPad Safari likes to pretend it is macOS Safari by cloning its user agent:
    // https://github.com/lancedikson/bowser/issues/455 But it doesn't support our extension, so we
    // need to exclude it here based on somewhat sketchy fingerprinting. Yeah, I don't like it
    // either.
    // eslint-disable-next-line -- compat complains about this, but only on older iOS, where we don't need it anyway
    ((n = window.navigator) == null ? void 0 : n.maxTouchPoints) === 5;
  }
  function detectFromNavigator(navigator2 = globalThis.navigator) {
    const result2 = navigator2.language || navigator2.userLanguage;
    return result2;
  }
  function detect(...args) {
    for (let i2 = 0; i2 < args.length; i2++) {
      const res = typeof args[i2] === "function" ? args[i2]() : args[i2];
      if (res)
        return res;
    }
    return null;
  }
  const g = JSON.parse('{"nYAZ22":["„",["loginLabel"],"” wurde gelöscht."],"BBrYPy":["„",["loginLabel"],"” wurde nach „",["0"],"” verschoben."],"+BllQ/":["„",["loginLabel"],"” wurde in den <0>Papierkorb</0> verschoben."],"d/ZbMk":"(geändert)","Gv57aB":[["fieldName"]," (alt)"],"9XZ3SQ":"#@$","qdmWOt":["0",["nonBreakingHyphen"],"9"],"sbGnrd":["a",["nonBreakingHyphen"],"z"],"umLW9t":["A",["nonBreakingHyphen"],"Z"],"m16xKo":"Hinzufügen","lyqwgn":"Label hinzufügen","iOiHwJ":"Weitere hinzufügen","CgUQh7":"Neues Feld hinzufügen","648VR4":"TOTP-Schlüssel hinzufügen","xkWEmO":"Alle Felder sind Ende-zu-Ende-verschlüsselt.","mac4Aw":"Alt","zVJj0U":"Android-App","DB8zMK":"Übernehmen","NamUYY":["von ",["creationProfileEmail"]],"nmimYO":["von ",["editProfileEmail"]],"dEgA5A":"Abbrechen","bMFXRG":"Karteninhaber","xHIEQ5":"Kreditkartennummer","2SqvU5":"Uhrzeit wird überprüft…","RLe7Vk":"Wird überprüft…","xCJdfg":"Leeren","yz7wBu":"Schließen","yrwl2P":"Konform","aIJHYe":"Zugriff erlauben","MpA0AY":"Bestätige mit einem deiner Login-Geräte","F0GBL0":"Bestätige mit deinem Handy","1yegnp":"Bestätige mit deinem Security Key","6V3Ea3":"Kopiert","he3ygx":"Kopieren","t3sqJR":["Erstellt am ",["0"]],"ooW934":"Kreditkarte","F5QOVM":"Strg","W/50sr":"Entf","cnGeoo":"Löschen","pfa8F0":"Anzeigename","d3ZUIN":"E-Mail oder Nutzername","xDr/ct":"Ende","9Vnjc9":"Enter","nNWuY1":"Eintrags-Typ","dgi+MR":"Fehler beim Überprüfen des Passworts","zO1gmR":"Esc","sZg7s1":"Ablaufdatum","2Pjc5z":"Ablaufdatum (mm / yy)","7Bj3x9":"Fehlgeschlagen","19BWU3":"Passwort generieren","YU1MkM":"PIN generieren","Jf0PuK":"Zum Login gehen","76gPWk":"Okay","+AzmrG":"heylogin wurde aktualisiert","vLyv1R":"Verbergen","g9eOjA":"Inhalt verstecken","i0qMbr":"Pos1","62ft/Z":"https://help.heylogin.com/de/2be545c602c144d6992a50e6301afa18","mSlBXj":"Einfg","/Gcaah":"Unsicher","0FSRiz":"Ungültige Kreditkartennummer","Lyd22+":"Ungültiges Ablaufdatum","7xaBoY":"Ungültiger Sicherheitscode","oYNiCo":"Label bereits hinzugefügt","h8DugX":"Labels","hko/4A":"Labels:","Lr4lJo":["Zuletzt bearbeitet am ",["0"]],"NC2AI2":"Länge","zUDyah":"Du wirst eingeloggt","z0t9bb":"Login","zUtMod":"Login abgebrochen","lh348v":"Login-Posteingang","a7UoOG":"Login-Status","gKfrpZ":["min. ",["0"]," Zeichen"],"2FYpfJ":"Mehr","3Siwmw":"Weitere Optionen","IK+8Ec":"In den Papierkorb verschieben","12Aozu":"Meine Logins","6YtxFj":"Name","1xTnZJ":"Name darf nicht leer sein!","MKYFuo":"Netzwerkname (SSID)","/nT6AE":"Neues Passwort","nr1I0W":"Keine App gefunden","xAAcWG":"Benachrichtigung kommt nicht an?","KiJn9B":"Notiz","CqOvzI":"Altes Passwort","yxTdsJ":"Webseite aufrufen","8ZsakT":"Passwort","kcggoH":"Passwort-Check:","dsVW+d":"Geprüftes Passwort","9QBiCg":"Passwort ist leer","Xjatg3":"Passwort-Policy:","oENbfc":"Persönliche Logins","lojVac":"Bild↓","ycPJXO":"Bild↑","sXULwc":"PIN","XdSz+P":"Bitte gib ein Label ein","QsZjF+":"Bitte lade die Seite neu um die aktuelle Version zu verwenden.","Ysej7j":"Privater Account","3WxAes":"Erneut prüfen","HpK/8d":"Neu laden","/7FPnu":"Label entfernen","Clnbgt":"Geteiltes Login entfernen","yKu/3Y":"Wiederherstellen","I89uD4":"Wiederherstellen…","tfDRzk":"Speichern","mwMktx":[["changeCount","plural",{"one":"Eine Änderung","other":["#"," Änderungen"]}]," speichern"],"u5eWCX":"Neuen Eintrag speichern","idD8Ev":"Gespeichert","OFqAkw":"Erfolgreich gespeichert","uF9ruK":"Wird gespeichert","tF8MKq":"Sichere Notiz","FLkaGY":"Sicheres Passwort","wLmRnI":"Sicherheitscode","rmoyE2":["Sicherheitscode (",["cardCodeName"],", ",["1","plural",{"one":["#"," Ziffer"],"other":["#"," Ziffern"]}],")"],"byfRNP":"Login-Absender","PGetcZ":"Shift","8vETh9":"Anzeigen","h8lzfw":[["0"]," anzeigen"],"7C+Jn5":"Passwort anzeigen","2cIs6V":"PIN anzeigen","BqrHbB":"Sicherheitscode anzeigen","nld5XV":"TOTP-Schlüssel anzeigen","vHxqT2":"Zeige WLAN-QR-Code","pOE8Vh":"Leerstaste","J8XjuC":"Uhrzeit ist jetzt korrekt.","kWroQx":"der Besitzer","QNFK92":"Ungespeicherte Änderungen. <0>Jetzt speichern</0>","2vXxVm":["Diese Kreditkarte wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"HoCMO6":"Diese Kreditkarte wird aus einem Team mit dir geteilt.","RCxO9Q":["Diese Kreditkarte wird aus dem Team ",["link"]," mit dir geteilt."],"xdufSh":["Diese Kreditkarte wird von ",["originEmail"]," mit dir geteilt."],"JWTc8Z":"Diese Kreditkarte wird von einem anderen Nutzer mit dir geteilt.","QAuBJT":["Dieses Login wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"thM6gj":"Dieses Login wird aus einem Team mit dir geteilt.","sQ0SXs":["Dieses Login wird aus dem Team ",["link"]," mit dir geteilt."],"0lXBAq":["Dieses Login wird von ",["originEmail"]," mit dir geteilt."],"OXhtqX":"Dieses Login wird von einem anderen Nutzer mit dir geteilt.","c/nFq0":["Dieses Login wurde am ",["0"]," in deinen Login-Posteingang übermittelt."],"czBEzZ":["Dieses Login wird auch auf ",["0"]," weiteren Webseiten angezeigt."],"y4UGV2":["Dieses Login wird auch auf ",["0"]," und ",["1"]," angezeigt."],"ai680t":["Dieses Login wird auch auf ",["0"]," angezeigt."],"S/ZmvX":["Dieses Notiz wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt"],"lr/OH6":"Diese Notiz wird aus einem Team mit dir geteilt.","a9Vkxt":["Diese Notiz wird aus dem Team ",["link"]," mit dir geteilt."],"RzvhXF":["Dieses Notiz wird von ",["originEmail"]," mit dir geteilt"],"UMBnwA":"Diese Notiz wird von einem anderen Nutzer mit dir geteilt.","2DMQa6":"Dieses Passwort wurde auf einer Liste von geleakten Passwörtern gefunden. Bitte nicht verwenden!","ESK+7k":"Dieser TOTP-Code benutzt von der Voreinstellung abweichende Parameter.","DUExfD":["Dieses WLAN-Netzwerk wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"QGWnC/":"Dieses WLAN-Netzwerk wird aus einem Team mit dir geteilt.","+JycaI":["Dieses WLAN-Netzwerk wird aus dem Team ",["link"]," mit dir geteilt."],"OoKYf3":["Dieses WLAN-Netzwerk wird von ",["originEmail"]," mit dir geteilt."],"oSL3k7":"Dieses WLAN-Netzwerk wird von einem anderen Nutzer mit dir geteilt.","Kvajkr":"TOTP","yoyvgB":"TOTP-Algorithmus","HqgpzW":"TOTP-Code könnte ungültig sein aufgrund abweichender Uhrzeit auf diesem Gerät. Bitte stelle die Systemzeit auf die aktuelle Zeit.","dME5Kz":"TOTP-Code:","16oMiL":"TOTP-Länge","rsWzn3":"TOTP-Periode","g4uCmi":"TOTP-Schlüssel","KDw4GX":"Erneut versuchen","3dKLN3":"Unbekannte Kreditkarte","29VNqC":"Unbekannter Fehler","fEjABR":["Unbekannter Fehler: ",["0"]],"IU3aCs":"Unbekanntes Feld","+jQjTh":"Unbekanntes WLAN-Netzwerk","4QFgr2":"Unbenanntes Login","57/aFB":"Unbenanntes Team","/zWqH6":"Als Standardeinstellung nutzen","7sNhEz":"Nutzername","ZBkKyh":"Verletzt","IVBLxC":"Warte auf Überprüfung","On0aF2":"Website","1J9wMe":"Websites","5VAKau":"WLAN-Netzwerk","2rz/ET":"Du kannst sie nur lesen.","PwJojz":"Du kannst es nur lesen.","mJdpuD":"Du kannst es nur lesen.","7uotGR":"Du kannst sie nur lesen.","KBRW1Z":"Du kannst diese Kreditkarte nur lesen.","ntxE/T":"Du kannst dieses Login nur lesen.","U7HgqM":"Du kannst dieses Notiz nur lesen.","cyzc26":"Du kannst dieses WLAN-Netzwerk nur lesen.","du68I6":"Du kannst es nur zum Einloggen auf Webseiten verwenden.","c8d9tl":"Du kannst dieses Login nur zum Einloggen auf Webseiten verwenden.","T9CzYt":["Du hast ",["remainingMinutes","plural",{"one":"weniger als eine Minute","other":["#"," Minuten"]}]," Zeit, um die Kreditkarte anzupassen, danach kann nur noch ",["ownerEmail"]," editieren."],"KoxsxA":["Du hast ",["remainingMinutes","plural",{"one":"weniger als eine Minute","other":["#"," Minuten"]}]," Zeit, um das Login anzupassen, danach kann nur noch ",["ownerEmail"]," editieren."]}'), u = JSON.parse('{"nYAZ22":["“",["loginLabel"],"” was deleted."],"BBrYPy":["“",["loginLabel"],"” was moved to “",["0"],"”."],"+BllQ/":["“",["loginLabel"],"” was moved to the <0>recycle bin</0>."],"d/ZbMk":"(changed)","Gv57aB":[["fieldName"]," (old)"],"9XZ3SQ":"#@$","qdmWOt":["0",["nonBreakingHyphen"],"9"],"sbGnrd":["a",["nonBreakingHyphen"],"z"],"umLW9t":["A",["nonBreakingHyphen"],"Z"],"m16xKo":"Add","lyqwgn":"Add label","iOiHwJ":"Add more","CgUQh7":"Add new field","648VR4":"Add TOTP secret","xkWEmO":"All fields are end-to-end encrypted.","mac4Aw":"Alt","zVJj0U":"Android app","DB8zMK":"Apply","NamUYY":["by ",["creationProfileEmail"]],"nmimYO":["by ",["editProfileEmail"]],"dEgA5A":"Cancel","bMFXRG":"Card holder","xHIEQ5":"Card number","2SqvU5":"Checking system clock…","RLe7Vk":"Checking…","xCJdfg":"Clear","yz7wBu":"Close","yrwl2P":"Compliant","aIJHYe":"Confirm access","MpA0AY":"Confirm with one of your login devices","F0GBL0":"Confirm with your phone","1yegnp":"Confirm with your security key","6V3Ea3":"Copied","he3ygx":"Copy","t3sqJR":["Created on ",["0"]],"ooW934":"Credit card","F5QOVM":"Ctrl","W/50sr":"Del","cnGeoo":"Delete","pfa8F0":"Display name","d3ZUIN":"E-mail or username","xDr/ct":"End","9Vnjc9":"Enter","nNWuY1":"Entry type","dgi+MR":"Error checking password","zO1gmR":"Esc","sZg7s1":"Expiration date","2Pjc5z":"Expiration date (mm / yy)","7Bj3x9":"Failed","19BWU3":"Generate password","YU1MkM":"Generate PIN","Jf0PuK":"Go to login","76gPWk":"Got it","+AzmrG":"heylogin was updated","vLyv1R":"Hide","g9eOjA":"Hide content","i0qMbr":"Home","62ft/Z":"https://help.heylogin.com/en/4200f43b493c4bb18c8e16bffcd40071","mSlBXj":"Ins","/Gcaah":"Insecure","0FSRiz":"Invalid card number","Lyd22+":"Invalid expiration date","7xaBoY":"Invalid security code","oYNiCo":"Label already added","h8DugX":"Labels","hko/4A":"Labels:","Lr4lJo":["Last edited on ",["0"]],"NC2AI2":"Length","zUDyah":"Logging in","z0t9bb":"Login","zUtMod":"Login cancelled","lh348v":"Login Inbox","a7UoOG":"Login status","gKfrpZ":["min. ",["0"]," characters"],"2FYpfJ":"More","3Siwmw":"More options","IK+8Ec":"Move to recycle bin","12Aozu":"My Logins","6YtxFj":"Name","1xTnZJ":"Name may not be empty!","MKYFuo":"Network name (SSID)","/nT6AE":"New password","nr1I0W":"No app found","xAAcWG":"No notification received?","KiJn9B":"Note","CqOvzI":"Old password","yxTdsJ":"Open website","8ZsakT":"Password","kcggoH":"Password check:","dsVW+d":"Password checked","9QBiCg":"Password is empty","Xjatg3":"Password policy:","oENbfc":"Personal Logins","lojVac":"PgDn","ycPJXO":"PgUp","sXULwc":"PIN","XdSz+P":"Please enter a label","QsZjF+":"Please reload to use the latest version.","Ysej7j":"Private account","3WxAes":"Recheck","HpK/8d":"Reload","/7FPnu":"Remove label","Clnbgt":"Remove shared login","yKu/3Y":"Restore","I89uD4":"Restoring…","tfDRzk":"Save","mwMktx":["Save ",["changeCount","plural",{"one":["#"," change"],"other":["#"," changes"]}]],"u5eWCX":"Save new entry","idD8Ev":"Saved","OFqAkw":"Saved successfully","uF9ruK":"Saving","tF8MKq":"Secure note","FLkaGY":"Secure password","wLmRnI":"Security code","rmoyE2":["Security code (",["cardCodeName"],", ",["0","plural",{"one":["#"," digit"],"other":["#"," digits"]}],")"],"byfRNP":"Sent by","PGetcZ":"Shift","8vETh9":"Show","h8lzfw":["Show ",["0"]],"7C+Jn5":"Show password","2cIs6V":"Show PIN","BqrHbB":"Show security code","nld5XV":"Show TOTP secret","vHxqT2":"Show WiFi QR code","pOE8Vh":"Space","J8XjuC":"System clock is correct now.","kWroQx":"the owner","QNFK92":"There are unsaved changes. <0>Save now</0>","2vXxVm":["This credit card is shared from a team by ",["linkedByEmail"],"."],"HoCMO6":"This credit card is shared from a team.","RCxO9Q":["This credit card is shared from team ",["link"],"."],"xdufSh":["This credit card is shared with you by ",["originEmail"],"."],"JWTc8Z":"This credit card is shared with you by another user.","QAuBJT":["This login is shared from a team by ",["linkedByEmail"],"."],"thM6gj":"This login is shared from a team.","sQ0SXs":["This login is shared from team ",["link"],"."],"0lXBAq":["This login is shared with you by ",["originEmail"],"."],"OXhtqX":"This login is shared with you by another user.","c/nFq0":["This login was submitted to your login inbox on ",["0"],"."],"czBEzZ":["This login will also be shown on ",["0"]," additional websites."],"y4UGV2":["This login will also be shown on ",["0"]," and ",["1"],"."],"ai680t":["This login will also be shown on ",["0"],"."],"S/ZmvX":["This note is shared from a team by ",["linkedByEmail"],"."],"lr/OH6":"This note is shared from a team.","a9Vkxt":["This note is shared from team ",["link"],"."],"RzvhXF":["This note is shared with you by ",["originEmail"],"."],"UMBnwA":"This note is shared with you by another user.","2DMQa6":"This password was found in a list of leaked passwords. Please do not use it!","ESK+7k":"This TOTP code uses parameters that differ from the default.","DUExfD":["This wifi network is shared from a team by ",["linkedByEmail"],"."],"QGWnC/":"This wifi network is shared from a team.","+JycaI":["This wifi network is shared from team ",["link"],"."],"OoKYf3":["This wifi network is shared with you by ",["originEmail"],"."],"oSL3k7":"This wifi network is shared with you by another user.","Kvajkr":"TOTP","yoyvgB":"TOTP algorithm","HqgpzW":"TOTP code might be invalid due to incorrect system clock on this device. Please set your system time to the current time.","dME5Kz":"TOTP code:","16oMiL":"TOTP length","rsWzn3":"TOTP period","g4uCmi":"TOTP secret","KDw4GX":"Try again","3dKLN3":"Unknown credit card","29VNqC":"Unknown error","fEjABR":["Unknown error: ",["0"]],"IU3aCs":"Unknown field","+jQjTh":"Unknown wifi network","4QFgr2":"Unnamed login","57/aFB":"Unnamed team","/zWqH6":"Use as default setting","7sNhEz":"Username","ZBkKyh":"Violated","IVBLxC":"Waiting to check","On0aF2":"Website","1J9wMe":"Websites","5VAKau":"Wifi network","2rz/ET":"You can only read it.","PwJojz":"You can only read it.","mJdpuD":"You can only read it.","7uotGR":"You can only read it.","KBRW1Z":"You can only read this credit card.","ntxE/T":"You can only read this login.","U7HgqM":"You can only read this note.","cyzc26":"You can only read this wifi network.","du68I6":"You can only use it to log in on websites.","c8d9tl":"You can only use this login to log in on websites.","T9CzYt":["You have ",["remainingMinutes","plural",{"one":"less than one minute","other":["#"," minutes"]}]," to edit this credit card. After that, only ",["ownerEmail"]," can edit it."],"KoxsxA":["You have ",["remainingMinutes","plural",{"one":"less than one minute","other":["#"," minutes"]}]," to edit this login. After that, only ",["ownerEmail"]," can edit it."]}'), a$1 = ["de", "en"], s = "en";
  function y(i2, o) {
    h$1(i2);
    let n = (o ?? detect(detectFromNavigator()) ?? s).split("-")[0];
    return a$1.every((t) => t !== n) && (n = s), i18n.on("change", () => {
      var t, r2;
      (r2 = (t = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : t.documentElement) == null || r2.setAttribute("lang", i18n.locale);
    }), i18n.activate(n), {
      supported: a$1,
      active: n
    };
  }
  function h$1(i2) {
    i18n.load("en", {
      ...u,
      ...i2.en
    }), i18n.load("de", {
      ...g,
      ...i2.de
    });
  }
  var psl$1 = {};
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
  const require$$1 = [
    "ac",
    "com.ac",
    "edu.ac",
    "gov.ac",
    "net.ac",
    "mil.ac",
    "org.ac",
    "ad",
    "nom.ad",
    "ae",
    "co.ae",
    "net.ae",
    "org.ae",
    "sch.ae",
    "ac.ae",
    "gov.ae",
    "mil.ae",
    "aero",
    "accident-investigation.aero",
    "accident-prevention.aero",
    "aerobatic.aero",
    "aeroclub.aero",
    "aerodrome.aero",
    "agents.aero",
    "aircraft.aero",
    "airline.aero",
    "airport.aero",
    "air-surveillance.aero",
    "airtraffic.aero",
    "air-traffic-control.aero",
    "ambulance.aero",
    "amusement.aero",
    "association.aero",
    "author.aero",
    "ballooning.aero",
    "broker.aero",
    "caa.aero",
    "cargo.aero",
    "catering.aero",
    "certification.aero",
    "championship.aero",
    "charter.aero",
    "civilaviation.aero",
    "club.aero",
    "conference.aero",
    "consultant.aero",
    "consulting.aero",
    "control.aero",
    "council.aero",
    "crew.aero",
    "design.aero",
    "dgca.aero",
    "educator.aero",
    "emergency.aero",
    "engine.aero",
    "engineer.aero",
    "entertainment.aero",
    "equipment.aero",
    "exchange.aero",
    "express.aero",
    "federation.aero",
    "flight.aero",
    "fuel.aero",
    "gliding.aero",
    "government.aero",
    "groundhandling.aero",
    "group.aero",
    "hanggliding.aero",
    "homebuilt.aero",
    "insurance.aero",
    "journal.aero",
    "journalist.aero",
    "leasing.aero",
    "logistics.aero",
    "magazine.aero",
    "maintenance.aero",
    "media.aero",
    "microlight.aero",
    "modelling.aero",
    "navigation.aero",
    "parachuting.aero",
    "paragliding.aero",
    "passenger-association.aero",
    "pilot.aero",
    "press.aero",
    "production.aero",
    "recreation.aero",
    "repbody.aero",
    "res.aero",
    "research.aero",
    "rotorcraft.aero",
    "safety.aero",
    "scientist.aero",
    "services.aero",
    "show.aero",
    "skydiving.aero",
    "software.aero",
    "student.aero",
    "trader.aero",
    "trading.aero",
    "trainer.aero",
    "union.aero",
    "workinggroup.aero",
    "works.aero",
    "af",
    "gov.af",
    "com.af",
    "org.af",
    "net.af",
    "edu.af",
    "ag",
    "com.ag",
    "org.ag",
    "net.ag",
    "co.ag",
    "nom.ag",
    "ai",
    "off.ai",
    "com.ai",
    "net.ai",
    "org.ai",
    "al",
    "com.al",
    "edu.al",
    "gov.al",
    "mil.al",
    "net.al",
    "org.al",
    "am",
    "co.am",
    "com.am",
    "commune.am",
    "net.am",
    "org.am",
    "ao",
    "ed.ao",
    "gv.ao",
    "og.ao",
    "co.ao",
    "pb.ao",
    "it.ao",
    "aq",
    "ar",
    "bet.ar",
    "com.ar",
    "coop.ar",
    "edu.ar",
    "gob.ar",
    "gov.ar",
    "int.ar",
    "mil.ar",
    "musica.ar",
    "mutual.ar",
    "net.ar",
    "org.ar",
    "senasa.ar",
    "tur.ar",
    "arpa",
    "e164.arpa",
    "in-addr.arpa",
    "ip6.arpa",
    "iris.arpa",
    "uri.arpa",
    "urn.arpa",
    "as",
    "gov.as",
    "asia",
    "at",
    "ac.at",
    "co.at",
    "gv.at",
    "or.at",
    "sth.ac.at",
    "au",
    "com.au",
    "net.au",
    "org.au",
    "edu.au",
    "gov.au",
    "asn.au",
    "id.au",
    "info.au",
    "conf.au",
    "oz.au",
    "act.au",
    "nsw.au",
    "nt.au",
    "qld.au",
    "sa.au",
    "tas.au",
    "vic.au",
    "wa.au",
    "act.edu.au",
    "catholic.edu.au",
    "nsw.edu.au",
    "nt.edu.au",
    "qld.edu.au",
    "sa.edu.au",
    "tas.edu.au",
    "vic.edu.au",
    "wa.edu.au",
    "qld.gov.au",
    "sa.gov.au",
    "tas.gov.au",
    "vic.gov.au",
    "wa.gov.au",
    "schools.nsw.edu.au",
    "aw",
    "com.aw",
    "ax",
    "az",
    "com.az",
    "net.az",
    "int.az",
    "gov.az",
    "org.az",
    "edu.az",
    "info.az",
    "pp.az",
    "mil.az",
    "name.az",
    "pro.az",
    "biz.az",
    "ba",
    "com.ba",
    "edu.ba",
    "gov.ba",
    "mil.ba",
    "net.ba",
    "org.ba",
    "bb",
    "biz.bb",
    "co.bb",
    "com.bb",
    "edu.bb",
    "gov.bb",
    "info.bb",
    "net.bb",
    "org.bb",
    "store.bb",
    "tv.bb",
    "*.bd",
    "be",
    "ac.be",
    "bf",
    "gov.bf",
    "bg",
    "a.bg",
    "b.bg",
    "c.bg",
    "d.bg",
    "e.bg",
    "f.bg",
    "g.bg",
    "h.bg",
    "i.bg",
    "j.bg",
    "k.bg",
    "l.bg",
    "m.bg",
    "n.bg",
    "o.bg",
    "p.bg",
    "q.bg",
    "r.bg",
    "s.bg",
    "t.bg",
    "u.bg",
    "v.bg",
    "w.bg",
    "x.bg",
    "y.bg",
    "z.bg",
    "0.bg",
    "1.bg",
    "2.bg",
    "3.bg",
    "4.bg",
    "5.bg",
    "6.bg",
    "7.bg",
    "8.bg",
    "9.bg",
    "bh",
    "com.bh",
    "edu.bh",
    "net.bh",
    "org.bh",
    "gov.bh",
    "bi",
    "co.bi",
    "com.bi",
    "edu.bi",
    "or.bi",
    "org.bi",
    "biz",
    "bj",
    "asso.bj",
    "barreau.bj",
    "gouv.bj",
    "bm",
    "com.bm",
    "edu.bm",
    "gov.bm",
    "net.bm",
    "org.bm",
    "bn",
    "com.bn",
    "edu.bn",
    "gov.bn",
    "net.bn",
    "org.bn",
    "bo",
    "com.bo",
    "edu.bo",
    "gob.bo",
    "int.bo",
    "org.bo",
    "net.bo",
    "mil.bo",
    "tv.bo",
    "web.bo",
    "academia.bo",
    "agro.bo",
    "arte.bo",
    "blog.bo",
    "bolivia.bo",
    "ciencia.bo",
    "cooperativa.bo",
    "democracia.bo",
    "deporte.bo",
    "ecologia.bo",
    "economia.bo",
    "empresa.bo",
    "indigena.bo",
    "industria.bo",
    "info.bo",
    "medicina.bo",
    "movimiento.bo",
    "musica.bo",
    "natural.bo",
    "nombre.bo",
    "noticias.bo",
    "patria.bo",
    "politica.bo",
    "profesional.bo",
    "plurinacional.bo",
    "pueblo.bo",
    "revista.bo",
    "salud.bo",
    "tecnologia.bo",
    "tksat.bo",
    "transporte.bo",
    "wiki.bo",
    "br",
    "9guacu.br",
    "abc.br",
    "adm.br",
    "adv.br",
    "agr.br",
    "aju.br",
    "am.br",
    "anani.br",
    "aparecida.br",
    "app.br",
    "arq.br",
    "art.br",
    "ato.br",
    "b.br",
    "barueri.br",
    "belem.br",
    "bhz.br",
    "bib.br",
    "bio.br",
    "blog.br",
    "bmd.br",
    "boavista.br",
    "bsb.br",
    "campinagrande.br",
    "campinas.br",
    "caxias.br",
    "cim.br",
    "cng.br",
    "cnt.br",
    "com.br",
    "contagem.br",
    "coop.br",
    "coz.br",
    "cri.br",
    "cuiaba.br",
    "curitiba.br",
    "def.br",
    "des.br",
    "det.br",
    "dev.br",
    "ecn.br",
    "eco.br",
    "edu.br",
    "emp.br",
    "enf.br",
    "eng.br",
    "esp.br",
    "etc.br",
    "eti.br",
    "far.br",
    "feira.br",
    "flog.br",
    "floripa.br",
    "fm.br",
    "fnd.br",
    "fortal.br",
    "fot.br",
    "foz.br",
    "fst.br",
    "g12.br",
    "geo.br",
    "ggf.br",
    "goiania.br",
    "gov.br",
    "ac.gov.br",
    "al.gov.br",
    "am.gov.br",
    "ap.gov.br",
    "ba.gov.br",
    "ce.gov.br",
    "df.gov.br",
    "es.gov.br",
    "go.gov.br",
    "ma.gov.br",
    "mg.gov.br",
    "ms.gov.br",
    "mt.gov.br",
    "pa.gov.br",
    "pb.gov.br",
    "pe.gov.br",
    "pi.gov.br",
    "pr.gov.br",
    "rj.gov.br",
    "rn.gov.br",
    "ro.gov.br",
    "rr.gov.br",
    "rs.gov.br",
    "sc.gov.br",
    "se.gov.br",
    "sp.gov.br",
    "to.gov.br",
    "gru.br",
    "imb.br",
    "ind.br",
    "inf.br",
    "jab.br",
    "jampa.br",
    "jdf.br",
    "joinville.br",
    "jor.br",
    "jus.br",
    "leg.br",
    "lel.br",
    "log.br",
    "londrina.br",
    "macapa.br",
    "maceio.br",
    "manaus.br",
    "maringa.br",
    "mat.br",
    "med.br",
    "mil.br",
    "morena.br",
    "mp.br",
    "mus.br",
    "natal.br",
    "net.br",
    "niteroi.br",
    "*.nom.br",
    "not.br",
    "ntr.br",
    "odo.br",
    "ong.br",
    "org.br",
    "osasco.br",
    "palmas.br",
    "poa.br",
    "ppg.br",
    "pro.br",
    "psc.br",
    "psi.br",
    "pvh.br",
    "qsl.br",
    "radio.br",
    "rec.br",
    "recife.br",
    "rep.br",
    "ribeirao.br",
    "rio.br",
    "riobranco.br",
    "riopreto.br",
    "salvador.br",
    "sampa.br",
    "santamaria.br",
    "santoandre.br",
    "saobernardo.br",
    "saogonca.br",
    "seg.br",
    "sjc.br",
    "slg.br",
    "slz.br",
    "sorocaba.br",
    "srv.br",
    "taxi.br",
    "tc.br",
    "tec.br",
    "teo.br",
    "the.br",
    "tmp.br",
    "trd.br",
    "tur.br",
    "tv.br",
    "udi.br",
    "vet.br",
    "vix.br",
    "vlog.br",
    "wiki.br",
    "zlg.br",
    "bs",
    "com.bs",
    "net.bs",
    "org.bs",
    "edu.bs",
    "gov.bs",
    "bt",
    "com.bt",
    "edu.bt",
    "gov.bt",
    "net.bt",
    "org.bt",
    "bv",
    "bw",
    "co.bw",
    "org.bw",
    "by",
    "gov.by",
    "mil.by",
    "com.by",
    "of.by",
    "bz",
    "com.bz",
    "net.bz",
    "org.bz",
    "edu.bz",
    "gov.bz",
    "ca",
    "ab.ca",
    "bc.ca",
    "mb.ca",
    "nb.ca",
    "nf.ca",
    "nl.ca",
    "ns.ca",
    "nt.ca",
    "nu.ca",
    "on.ca",
    "pe.ca",
    "qc.ca",
    "sk.ca",
    "yk.ca",
    "gc.ca",
    "cat",
    "cc",
    "cd",
    "gov.cd",
    "cf",
    "cg",
    "ch",
    "ci",
    "org.ci",
    "or.ci",
    "com.ci",
    "co.ci",
    "edu.ci",
    "ed.ci",
    "ac.ci",
    "net.ci",
    "go.ci",
    "asso.ci",
    "aéroport.ci",
    "int.ci",
    "presse.ci",
    "md.ci",
    "gouv.ci",
    "*.ck",
    "!www.ck",
    "cl",
    "co.cl",
    "gob.cl",
    "gov.cl",
    "mil.cl",
    "cm",
    "co.cm",
    "com.cm",
    "gov.cm",
    "net.cm",
    "cn",
    "ac.cn",
    "com.cn",
    "edu.cn",
    "gov.cn",
    "net.cn",
    "org.cn",
    "mil.cn",
    "公司.cn",
    "网络.cn",
    "網絡.cn",
    "ah.cn",
    "bj.cn",
    "cq.cn",
    "fj.cn",
    "gd.cn",
    "gs.cn",
    "gz.cn",
    "gx.cn",
    "ha.cn",
    "hb.cn",
    "he.cn",
    "hi.cn",
    "hl.cn",
    "hn.cn",
    "jl.cn",
    "js.cn",
    "jx.cn",
    "ln.cn",
    "nm.cn",
    "nx.cn",
    "qh.cn",
    "sc.cn",
    "sd.cn",
    "sh.cn",
    "sn.cn",
    "sx.cn",
    "tj.cn",
    "xj.cn",
    "xz.cn",
    "yn.cn",
    "zj.cn",
    "hk.cn",
    "mo.cn",
    "tw.cn",
    "co",
    "arts.co",
    "com.co",
    "edu.co",
    "firm.co",
    "gov.co",
    "info.co",
    "int.co",
    "mil.co",
    "net.co",
    "nom.co",
    "org.co",
    "rec.co",
    "web.co",
    "com",
    "coop",
    "cr",
    "ac.cr",
    "co.cr",
    "ed.cr",
    "fi.cr",
    "go.cr",
    "or.cr",
    "sa.cr",
    "cu",
    "com.cu",
    "edu.cu",
    "org.cu",
    "net.cu",
    "gov.cu",
    "inf.cu",
    "cv",
    "com.cv",
    "edu.cv",
    "int.cv",
    "nome.cv",
    "org.cv",
    "cw",
    "com.cw",
    "edu.cw",
    "net.cw",
    "org.cw",
    "cx",
    "gov.cx",
    "cy",
    "ac.cy",
    "biz.cy",
    "com.cy",
    "ekloges.cy",
    "gov.cy",
    "ltd.cy",
    "mil.cy",
    "net.cy",
    "org.cy",
    "press.cy",
    "pro.cy",
    "tm.cy",
    "cz",
    "de",
    "dj",
    "dk",
    "dm",
    "com.dm",
    "net.dm",
    "org.dm",
    "edu.dm",
    "gov.dm",
    "do",
    "art.do",
    "com.do",
    "edu.do",
    "gob.do",
    "gov.do",
    "mil.do",
    "net.do",
    "org.do",
    "sld.do",
    "web.do",
    "dz",
    "art.dz",
    "asso.dz",
    "com.dz",
    "edu.dz",
    "gov.dz",
    "org.dz",
    "net.dz",
    "pol.dz",
    "soc.dz",
    "tm.dz",
    "ec",
    "com.ec",
    "info.ec",
    "net.ec",
    "fin.ec",
    "k12.ec",
    "med.ec",
    "pro.ec",
    "org.ec",
    "edu.ec",
    "gov.ec",
    "gob.ec",
    "mil.ec",
    "edu",
    "ee",
    "edu.ee",
    "gov.ee",
    "riik.ee",
    "lib.ee",
    "med.ee",
    "com.ee",
    "pri.ee",
    "aip.ee",
    "org.ee",
    "fie.ee",
    "eg",
    "com.eg",
    "edu.eg",
    "eun.eg",
    "gov.eg",
    "mil.eg",
    "name.eg",
    "net.eg",
    "org.eg",
    "sci.eg",
    "*.er",
    "es",
    "com.es",
    "nom.es",
    "org.es",
    "gob.es",
    "edu.es",
    "et",
    "com.et",
    "gov.et",
    "org.et",
    "edu.et",
    "biz.et",
    "name.et",
    "info.et",
    "net.et",
    "eu",
    "fi",
    "aland.fi",
    "fj",
    "ac.fj",
    "biz.fj",
    "com.fj",
    "gov.fj",
    "info.fj",
    "mil.fj",
    "name.fj",
    "net.fj",
    "org.fj",
    "pro.fj",
    "*.fk",
    "com.fm",
    "edu.fm",
    "net.fm",
    "org.fm",
    "fm",
    "fo",
    "fr",
    "asso.fr",
    "com.fr",
    "gouv.fr",
    "nom.fr",
    "prd.fr",
    "tm.fr",
    "aeroport.fr",
    "avocat.fr",
    "avoues.fr",
    "cci.fr",
    "chambagri.fr",
    "chirurgiens-dentistes.fr",
    "experts-comptables.fr",
    "geometre-expert.fr",
    "greta.fr",
    "huissier-justice.fr",
    "medecin.fr",
    "notaires.fr",
    "pharmacien.fr",
    "port.fr",
    "veterinaire.fr",
    "ga",
    "gb",
    "edu.gd",
    "gov.gd",
    "gd",
    "ge",
    "com.ge",
    "edu.ge",
    "gov.ge",
    "org.ge",
    "mil.ge",
    "net.ge",
    "pvt.ge",
    "gf",
    "gg",
    "co.gg",
    "net.gg",
    "org.gg",
    "gh",
    "com.gh",
    "edu.gh",
    "gov.gh",
    "org.gh",
    "mil.gh",
    "gi",
    "com.gi",
    "ltd.gi",
    "gov.gi",
    "mod.gi",
    "edu.gi",
    "org.gi",
    "gl",
    "co.gl",
    "com.gl",
    "edu.gl",
    "net.gl",
    "org.gl",
    "gm",
    "gn",
    "ac.gn",
    "com.gn",
    "edu.gn",
    "gov.gn",
    "org.gn",
    "net.gn",
    "gov",
    "gp",
    "com.gp",
    "net.gp",
    "mobi.gp",
    "edu.gp",
    "org.gp",
    "asso.gp",
    "gq",
    "gr",
    "com.gr",
    "edu.gr",
    "net.gr",
    "org.gr",
    "gov.gr",
    "gs",
    "gt",
    "com.gt",
    "edu.gt",
    "gob.gt",
    "ind.gt",
    "mil.gt",
    "net.gt",
    "org.gt",
    "gu",
    "com.gu",
    "edu.gu",
    "gov.gu",
    "guam.gu",
    "info.gu",
    "net.gu",
    "org.gu",
    "web.gu",
    "gw",
    "gy",
    "co.gy",
    "com.gy",
    "edu.gy",
    "gov.gy",
    "net.gy",
    "org.gy",
    "hk",
    "com.hk",
    "edu.hk",
    "gov.hk",
    "idv.hk",
    "net.hk",
    "org.hk",
    "公司.hk",
    "教育.hk",
    "敎育.hk",
    "政府.hk",
    "個人.hk",
    "个��.hk",
    "箇人.hk",
    "網络.hk",
    "网络.hk",
    "组織.hk",
    "網絡.hk",
    "网絡.hk",
    "组织.hk",
    "組織.hk",
    "組织.hk",
    "hm",
    "hn",
    "com.hn",
    "edu.hn",
    "org.hn",
    "net.hn",
    "mil.hn",
    "gob.hn",
    "hr",
    "iz.hr",
    "from.hr",
    "name.hr",
    "com.hr",
    "ht",
    "com.ht",
    "shop.ht",
    "firm.ht",
    "info.ht",
    "adult.ht",
    "net.ht",
    "pro.ht",
    "org.ht",
    "med.ht",
    "art.ht",
    "coop.ht",
    "pol.ht",
    "asso.ht",
    "edu.ht",
    "rel.ht",
    "gouv.ht",
    "perso.ht",
    "hu",
    "co.hu",
    "info.hu",
    "org.hu",
    "priv.hu",
    "sport.hu",
    "tm.hu",
    "2000.hu",
    "agrar.hu",
    "bolt.hu",
    "casino.hu",
    "city.hu",
    "erotica.hu",
    "erotika.hu",
    "film.hu",
    "forum.hu",
    "games.hu",
    "hotel.hu",
    "ingatlan.hu",
    "jogasz.hu",
    "konyvelo.hu",
    "lakas.hu",
    "media.hu",
    "news.hu",
    "reklam.hu",
    "sex.hu",
    "shop.hu",
    "suli.hu",
    "szex.hu",
    "tozsde.hu",
    "utazas.hu",
    "video.hu",
    "id",
    "ac.id",
    "biz.id",
    "co.id",
    "desa.id",
    "go.id",
    "mil.id",
    "my.id",
    "net.id",
    "or.id",
    "ponpes.id",
    "sch.id",
    "web.id",
    "ie",
    "gov.ie",
    "il",
    "ac.il",
    "co.il",
    "gov.il",
    "idf.il",
    "k12.il",
    "muni.il",
    "net.il",
    "org.il",
    "im",
    "ac.im",
    "co.im",
    "com.im",
    "ltd.co.im",
    "net.im",
    "org.im",
    "plc.co.im",
    "tt.im",
    "tv.im",
    "in",
    "co.in",
    "firm.in",
    "net.in",
    "org.in",
    "gen.in",
    "ind.in",
    "nic.in",
    "ac.in",
    "edu.in",
    "res.in",
    "gov.in",
    "mil.in",
    "info",
    "int",
    "eu.int",
    "io",
    "com.io",
    "iq",
    "gov.iq",
    "edu.iq",
    "mil.iq",
    "com.iq",
    "org.iq",
    "net.iq",
    "ir",
    "ac.ir",
    "co.ir",
    "gov.ir",
    "id.ir",
    "net.ir",
    "org.ir",
    "sch.ir",
    "ایران.ir",
    "ايران.ir",
    "is",
    "net.is",
    "com.is",
    "edu.is",
    "gov.is",
    "org.is",
    "int.is",
    "it",
    "gov.it",
    "edu.it",
    "abr.it",
    "abruzzo.it",
    "aosta-valley.it",
    "aostavalley.it",
    "bas.it",
    "basilicata.it",
    "cal.it",
    "calabria.it",
    "cam.it",
    "campania.it",
    "emilia-romagna.it",
    "emiliaromagna.it",
    "emr.it",
    "friuli-v-giulia.it",
    "friuli-ve-giulia.it",
    "friuli-vegiulia.it",
    "friuli-venezia-giulia.it",
    "friuli-veneziagiulia.it",
    "friuli-vgiulia.it",
    "friuliv-giulia.it",
    "friulive-giulia.it",
    "friulivegiulia.it",
    "friulivenezia-giulia.it",
    "friuliveneziagiulia.it",
    "friulivgiulia.it",
    "fvg.it",
    "laz.it",
    "lazio.it",
    "lig.it",
    "liguria.it",
    "lom.it",
    "lombardia.it",
    "lombardy.it",
    "lucania.it",
    "mar.it",
    "marche.it",
    "mol.it",
    "molise.it",
    "piedmont.it",
    "piemonte.it",
    "pmn.it",
    "pug.it",
    "puglia.it",
    "sar.it",
    "sardegna.it",
    "sardinia.it",
    "sic.it",
    "sicilia.it",
    "sicily.it",
    "taa.it",
    "tos.it",
    "toscana.it",
    "trentin-sud-tirol.it",
    "trentin-süd-tirol.it",
    "trentin-sudtirol.it",
    "trentin-südtirol.it",
    "trentin-sued-tirol.it",
    "trentin-suedtirol.it",
    "trentino-a-adige.it",
    "trentino-aadige.it",
    "trentino-alto-adige.it",
    "trentino-altoadige.it",
    "trentino-s-tirol.it",
    "trentino-stirol.it",
    "trentino-sud-tirol.it",
    "trentino-süd-tirol.it",
    "trentino-sudtirol.it",
    "trentino-südtirol.it",
    "trentino-sued-tirol.it",
    "trentino-suedtirol.it",
    "trentino.it",
    "trentinoa-adige.it",
    "trentinoaadige.it",
    "trentinoalto-adige.it",
    "trentinoaltoadige.it",
    "trentinos-tirol.it",
    "trentinostirol.it",
    "trentinosud-tirol.it",
    "trentinosüd-tirol.it",
    "trentinosudtirol.it",
    "trentinosüdtirol.it",
    "trentinosued-tirol.it",
    "trentinosuedtirol.it",
    "trentinsud-tirol.it",
    "trentinsüd-tirol.it",
    "trentinsudtirol.it",
    "trentinsüdtirol.it",
    "trentinsued-tirol.it",
    "trentinsuedtirol.it",
    "tuscany.it",
    "umb.it",
    "umbria.it",
    "val-d-aosta.it",
    "val-daosta.it",
    "vald-aosta.it",
    "valdaosta.it",
    "valle-aosta.it",
    "valle-d-aosta.it",
    "valle-daosta.it",
    "valleaosta.it",
    "valled-aosta.it",
    "valledaosta.it",
    "vallee-aoste.it",
    "vallée-aoste.it",
    "vallee-d-aoste.it",
    "vallée-d-aoste.it",
    "valleeaoste.it",
    "valléeaoste.it",
    "valleedaoste.it",
    "valléedaoste.it",
    "vao.it",
    "vda.it",
    "ven.it",
    "veneto.it",
    "ag.it",
    "agrigento.it",
    "al.it",
    "alessandria.it",
    "alto-adige.it",
    "altoadige.it",
    "an.it",
    "ancona.it",
    "andria-barletta-trani.it",
    "andria-trani-barletta.it",
    "andriabarlettatrani.it",
    "andriatranibarletta.it",
    "ao.it",
    "aosta.it",
    "aoste.it",
    "ap.it",
    "aq.it",
    "aquila.it",
    "ar.it",
    "arezzo.it",
    "ascoli-piceno.it",
    "ascolipiceno.it",
    "asti.it",
    "at.it",
    "av.it",
    "avellino.it",
    "ba.it",
    "balsan-sudtirol.it",
    "balsan-südtirol.it",
    "balsan-suedtirol.it",
    "balsan.it",
    "bari.it",
    "barletta-trani-andria.it",
    "barlettatraniandria.it",
    "belluno.it",
    "benevento.it",
    "bergamo.it",
    "bg.it",
    "bi.it",
    "biella.it",
    "bl.it",
    "bn.it",
    "bo.it",
    "bologna.it",
    "bolzano-altoadige.it",
    "bolzano.it",
    "bozen-sudtirol.it",
    "bozen-südtirol.it",
    "bozen-suedtirol.it",
    "bozen.it",
    "br.it",
    "brescia.it",
    "brindisi.it",
    "bs.it",
    "bt.it",
    "bulsan-sudtirol.it",
    "bulsan-südtirol.it",
    "bulsan-suedtirol.it",
    "bulsan.it",
    "bz.it",
    "ca.it",
    "cagliari.it",
    "caltanissetta.it",
    "campidano-medio.it",
    "campidanomedio.it",
    "campobasso.it",
    "carbonia-iglesias.it",
    "carboniaiglesias.it",
    "carrara-massa.it",
    "carraramassa.it",
    "caserta.it",
    "catania.it",
    "catanzaro.it",
    "cb.it",
    "ce.it",
    "cesena-forli.it",
    "cesena-forlì.it",
    "cesenaforli.it",
    "cesenaforlì.it",
    "ch.it",
    "chieti.it",
    "ci.it",
    "cl.it",
    "cn.it",
    "co.it",
    "como.it",
    "cosenza.it",
    "cr.it",
    "cremona.it",
    "crotone.it",
    "cs.it",
    "ct.it",
    "cuneo.it",
    "cz.it",
    "dell-ogliastra.it",
    "dellogliastra.it",
    "en.it",
    "enna.it",
    "fc.it",
    "fe.it",
    "fermo.it",
    "ferrara.it",
    "fg.it",
    "fi.it",
    "firenze.it",
    "florence.it",
    "fm.it",
    "foggia.it",
    "forli-cesena.it",
    "forlì-cesena.it",
    "forlicesena.it",
    "forlìcesena.it",
    "fr.it",
    "frosinone.it",
    "ge.it",
    "genoa.it",
    "genova.it",
    "go.it",
    "gorizia.it",
    "gr.it",
    "grosseto.it",
    "iglesias-carbonia.it",
    "iglesiascarbonia.it",
    "im.it",
    "imperia.it",
    "is.it",
    "isernia.it",
    "kr.it",
    "la-spezia.it",
    "laquila.it",
    "laspezia.it",
    "latina.it",
    "lc.it",
    "le.it",
    "lecce.it",
    "lecco.it",
    "li.it",
    "livorno.it",
    "lo.it",
    "lodi.it",
    "lt.it",
    "lu.it",
    "lucca.it",
    "macerata.it",
    "mantova.it",
    "massa-carrara.it",
    "massacarrara.it",
    "matera.it",
    "mb.it",
    "mc.it",
    "me.it",
    "medio-campidano.it",
    "mediocampidano.it",
    "messina.it",
    "mi.it",
    "milan.it",
    "milano.it",
    "mn.it",
    "mo.it",
    "modena.it",
    "monza-brianza.it",
    "monza-e-della-brianza.it",
    "monza.it",
    "monzabrianza.it",
    "monzaebrianza.it",
    "monzaedellabrianza.it",
    "ms.it",
    "mt.it",
    "na.it",
    "naples.it",
    "napoli.it",
    "no.it",
    "novara.it",
    "nu.it",
    "nuoro.it",
    "og.it",
    "ogliastra.it",
    "olbia-tempio.it",
    "olbiatempio.it",
    "or.it",
    "oristano.it",
    "ot.it",
    "pa.it",
    "padova.it",
    "padua.it",
    "palermo.it",
    "parma.it",
    "pavia.it",
    "pc.it",
    "pd.it",
    "pe.it",
    "perugia.it",
    "pesaro-urbino.it",
    "pesarourbino.it",
    "pescara.it",
    "pg.it",
    "pi.it",
    "piacenza.it",
    "pisa.it",
    "pistoia.it",
    "pn.it",
    "po.it",
    "pordenone.it",
    "potenza.it",
    "pr.it",
    "prato.it",
    "pt.it",
    "pu.it",
    "pv.it",
    "pz.it",
    "ra.it",
    "ragusa.it",
    "ravenna.it",
    "rc.it",
    "re.it",
    "reggio-calabria.it",
    "reggio-emilia.it",
    "reggiocalabria.it",
    "reggioemilia.it",
    "rg.it",
    "ri.it",
    "rieti.it",
    "rimini.it",
    "rm.it",
    "rn.it",
    "ro.it",
    "roma.it",
    "rome.it",
    "rovigo.it",
    "sa.it",
    "salerno.it",
    "sassari.it",
    "savona.it",
    "si.it",
    "siena.it",
    "siracusa.it",
    "so.it",
    "sondrio.it",
    "sp.it",
    "sr.it",
    "ss.it",
    "suedtirol.it",
    "südtirol.it",
    "sv.it",
    "ta.it",
    "taranto.it",
    "te.it",
    "tempio-olbia.it",
    "tempioolbia.it",
    "teramo.it",
    "terni.it",
    "tn.it",
    "to.it",
    "torino.it",
    "tp.it",
    "tr.it",
    "trani-andria-barletta.it",
    "trani-barletta-andria.it",
    "traniandriabarletta.it",
    "tranibarlettaandria.it",
    "trapani.it",
    "trento.it",
    "treviso.it",
    "trieste.it",
    "ts.it",
    "turin.it",
    "tv.it",
    "ud.it",
    "udine.it",
    "urbino-pesaro.it",
    "urbinopesaro.it",
    "va.it",
    "varese.it",
    "vb.it",
    "vc.it",
    "ve.it",
    "venezia.it",
    "venice.it",
    "verbania.it",
    "vercelli.it",
    "verona.it",
    "vi.it",
    "vibo-valentia.it",
    "vibovalentia.it",
    "vicenza.it",
    "viterbo.it",
    "vr.it",
    "vs.it",
    "vt.it",
    "vv.it",
    "je",
    "co.je",
    "net.je",
    "org.je",
    "*.jm",
    "jo",
    "com.jo",
    "org.jo",
    "net.jo",
    "edu.jo",
    "sch.jo",
    "gov.jo",
    "mil.jo",
    "name.jo",
    "jobs",
    "jp",
    "ac.jp",
    "ad.jp",
    "co.jp",
    "ed.jp",
    "go.jp",
    "gr.jp",
    "lg.jp",
    "ne.jp",
    "or.jp",
    "aichi.jp",
    "akita.jp",
    "aomori.jp",
    "chiba.jp",
    "ehime.jp",
    "fukui.jp",
    "fukuoka.jp",
    "fukushima.jp",
    "gifu.jp",
    "gunma.jp",
    "hiroshima.jp",
    "hokkaido.jp",
    "hyogo.jp",
    "ibaraki.jp",
    "ishikawa.jp",
    "iwate.jp",
    "kagawa.jp",
    "kagoshima.jp",
    "kanagawa.jp",
    "kochi.jp",
    "kumamoto.jp",
    "kyoto.jp",
    "mie.jp",
    "miyagi.jp",
    "miyazaki.jp",
    "nagano.jp",
    "nagasaki.jp",
    "nara.jp",
    "niigata.jp",
    "oita.jp",
    "okayama.jp",
    "okinawa.jp",
    "osaka.jp",
    "saga.jp",
    "saitama.jp",
    "shiga.jp",
    "shimane.jp",
    "shizuoka.jp",
    "tochigi.jp",
    "tokushima.jp",
    "tokyo.jp",
    "tottori.jp",
    "toyama.jp",
    "wakayama.jp",
    "yamagata.jp",
    "yamaguchi.jp",
    "yamanashi.jp",
    "栃木.jp",
    "愛知.jp",
    "愛媛.jp",
    "兵庫.jp",
    "熊本.jp",
    "茨城.jp",
    "北海道.jp",
    "千葉.jp",
    "和歌山.jp",
    "長崎.jp",
    "長野.jp",
    "新潟.jp",
    "青森.jp",
    "静岡.jp",
    "東京.jp",
    "石川.jp",
    "埼玉.jp",
    "三重.jp",
    "京都.jp",
    "佐賀.jp",
    "大分.jp",
    "大阪.jp",
    "奈良.jp",
    "宮城.jp",
    "宮崎.jp",
    "富山.jp",
    "山口.jp",
    "山形.jp",
    "山梨.jp",
    "岩手.jp",
    "岐阜.jp",
    "岡山.jp",
    "島根.jp",
    "広島.jp",
    "徳島.jp",
    "沖縄.jp",
    "滋賀.jp",
    "神奈川.jp",
    "福井.jp",
    "福岡.jp",
    "福島.jp",
    "秋田.jp",
    "群馬.jp",
    "香川.jp",
    "高知.jp",
    "鳥取.jp",
    "鹿児島.jp",
    "*.kawasaki.jp",
    "*.kitakyushu.jp",
    "*.kobe.jp",
    "*.nagoya.jp",
    "*.sapporo.jp",
    "*.sendai.jp",
    "*.yokohama.jp",
    "!city.kawasaki.jp",
    "!city.kitakyushu.jp",
    "!city.kobe.jp",
    "!city.nagoya.jp",
    "!city.sapporo.jp",
    "!city.sendai.jp",
    "!city.yokohama.jp",
    "aisai.aichi.jp",
    "ama.aichi.jp",
    "anjo.aichi.jp",
    "asuke.aichi.jp",
    "chiryu.aichi.jp",
    "chita.aichi.jp",
    "fuso.aichi.jp",
    "gamagori.aichi.jp",
    "handa.aichi.jp",
    "hazu.aichi.jp",
    "hekinan.aichi.jp",
    "higashiura.aichi.jp",
    "ichinomiya.aichi.jp",
    "inazawa.aichi.jp",
    "inuyama.aichi.jp",
    "isshiki.aichi.jp",
    "iwakura.aichi.jp",
    "kanie.aichi.jp",
    "kariya.aichi.jp",
    "kasugai.aichi.jp",
    "kira.aichi.jp",
    "kiyosu.aichi.jp",
    "komaki.aichi.jp",
    "konan.aichi.jp",
    "kota.aichi.jp",
    "mihama.aichi.jp",
    "miyoshi.aichi.jp",
    "nishio.aichi.jp",
    "nisshin.aichi.jp",
    "obu.aichi.jp",
    "oguchi.aichi.jp",
    "oharu.aichi.jp",
    "okazaki.aichi.jp",
    "owariasahi.aichi.jp",
    "seto.aichi.jp",
    "shikatsu.aichi.jp",
    "shinshiro.aichi.jp",
    "shitara.aichi.jp",
    "tahara.aichi.jp",
    "takahama.aichi.jp",
    "tobishima.aichi.jp",
    "toei.aichi.jp",
    "togo.aichi.jp",
    "tokai.aichi.jp",
    "tokoname.aichi.jp",
    "toyoake.aichi.jp",
    "toyohashi.aichi.jp",
    "toyokawa.aichi.jp",
    "toyone.aichi.jp",
    "toyota.aichi.jp",
    "tsushima.aichi.jp",
    "yatomi.aichi.jp",
    "akita.akita.jp",
    "daisen.akita.jp",
    "fujisato.akita.jp",
    "gojome.akita.jp",
    "hachirogata.akita.jp",
    "happou.akita.jp",
    "higashinaruse.akita.jp",
    "honjo.akita.jp",
    "honjyo.akita.jp",
    "ikawa.akita.jp",
    "kamikoani.akita.jp",
    "kamioka.akita.jp",
    "katagami.akita.jp",
    "kazuno.akita.jp",
    "kitaakita.akita.jp",
    "kosaka.akita.jp",
    "kyowa.akita.jp",
    "misato.akita.jp",
    "mitane.akita.jp",
    "moriyoshi.akita.jp",
    "nikaho.akita.jp",
    "noshiro.akita.jp",
    "odate.akita.jp",
    "oga.akita.jp",
    "ogata.akita.jp",
    "semboku.akita.jp",
    "yokote.akita.jp",
    "yurihonjo.akita.jp",
    "aomori.aomori.jp",
    "gonohe.aomori.jp",
    "hachinohe.aomori.jp",
    "hashikami.aomori.jp",
    "hiranai.aomori.jp",
    "hirosaki.aomori.jp",
    "itayanagi.aomori.jp",
    "kuroishi.aomori.jp",
    "misawa.aomori.jp",
    "mutsu.aomori.jp",
    "nakadomari.aomori.jp",
    "noheji.aomori.jp",
    "oirase.aomori.jp",
    "owani.aomori.jp",
    "rokunohe.aomori.jp",
    "sannohe.aomori.jp",
    "shichinohe.aomori.jp",
    "shingo.aomori.jp",
    "takko.aomori.jp",
    "towada.aomori.jp",
    "tsugaru.aomori.jp",
    "tsuruta.aomori.jp",
    "abiko.chiba.jp",
    "asahi.chiba.jp",
    "chonan.chiba.jp",
    "chosei.chiba.jp",
    "choshi.chiba.jp",
    "chuo.chiba.jp",
    "funabashi.chiba.jp",
    "futtsu.chiba.jp",
    "hanamigawa.chiba.jp",
    "ichihara.chiba.jp",
    "ichikawa.chiba.jp",
    "ichinomiya.chiba.jp",
    "inzai.chiba.jp",
    "isumi.chiba.jp",
    "kamagaya.chiba.jp",
    "kamogawa.chiba.jp",
    "kashiwa.chiba.jp",
    "katori.chiba.jp",
    "katsuura.chiba.jp",
    "kimitsu.chiba.jp",
    "kisarazu.chiba.jp",
    "kozaki.chiba.jp",
    "kujukuri.chiba.jp",
    "kyonan.chiba.jp",
    "matsudo.chiba.jp",
    "midori.chiba.jp",
    "mihama.chiba.jp",
    "minamiboso.chiba.jp",
    "mobara.chiba.jp",
    "mutsuzawa.chiba.jp",
    "nagara.chiba.jp",
    "nagareyama.chiba.jp",
    "narashino.chiba.jp",
    "narita.chiba.jp",
    "noda.chiba.jp",
    "oamishirasato.chiba.jp",
    "omigawa.chiba.jp",
    "onjuku.chiba.jp",
    "otaki.chiba.jp",
    "sakae.chiba.jp",
    "sakura.chiba.jp",
    "shimofusa.chiba.jp",
    "shirako.chiba.jp",
    "shiroi.chiba.jp",
    "shisui.chiba.jp",
    "sodegaura.chiba.jp",
    "sosa.chiba.jp",
    "tako.chiba.jp",
    "tateyama.chiba.jp",
    "togane.chiba.jp",
    "tohnosho.chiba.jp",
    "tomisato.chiba.jp",
    "urayasu.chiba.jp",
    "yachimata.chiba.jp",
    "yachiyo.chiba.jp",
    "yokaichiba.chiba.jp",
    "yokoshibahikari.chiba.jp",
    "yotsukaido.chiba.jp",
    "ainan.ehime.jp",
    "honai.ehime.jp",
    "ikata.ehime.jp",
    "imabari.ehime.jp",
    "iyo.ehime.jp",
    "kamijima.ehime.jp",
    "kihoku.ehime.jp",
    "kumakogen.ehime.jp",
    "masaki.ehime.jp",
    "matsuno.ehime.jp",
    "matsuyama.ehime.jp",
    "namikata.ehime.jp",
    "niihama.ehime.jp",
    "ozu.ehime.jp",
    "saijo.ehime.jp",
    "seiyo.ehime.jp",
    "shikokuchuo.ehime.jp",
    "tobe.ehime.jp",
    "toon.ehime.jp",
    "uchiko.ehime.jp",
    "uwajima.ehime.jp",
    "yawatahama.ehime.jp",
    "echizen.fukui.jp",
    "eiheiji.fukui.jp",
    "fukui.fukui.jp",
    "ikeda.fukui.jp",
    "katsuyama.fukui.jp",
    "mihama.fukui.jp",
    "minamiechizen.fukui.jp",
    "obama.fukui.jp",
    "ohi.fukui.jp",
    "ono.fukui.jp",
    "sabae.fukui.jp",
    "sakai.fukui.jp",
    "takahama.fukui.jp",
    "tsuruga.fukui.jp",
    "wakasa.fukui.jp",
    "ashiya.fukuoka.jp",
    "buzen.fukuoka.jp",
    "chikugo.fukuoka.jp",
    "chikuho.fukuoka.jp",
    "chikujo.fukuoka.jp",
    "chikushino.fukuoka.jp",
    "chikuzen.fukuoka.jp",
    "chuo.fukuoka.jp",
    "dazaifu.fukuoka.jp",
    "fukuchi.fukuoka.jp",
    "hakata.fukuoka.jp",
    "higashi.fukuoka.jp",
    "hirokawa.fukuoka.jp",
    "hisayama.fukuoka.jp",
    "iizuka.fukuoka.jp",
    "inatsuki.fukuoka.jp",
    "kaho.fukuoka.jp",
    "kasuga.fukuoka.jp",
    "kasuya.fukuoka.jp",
    "kawara.fukuoka.jp",
    "keisen.fukuoka.jp",
    "koga.fukuoka.jp",
    "kurate.fukuoka.jp",
    "kurogi.fukuoka.jp",
    "kurume.fukuoka.jp",
    "minami.fukuoka.jp",
    "miyako.fukuoka.jp",
    "miyama.fukuoka.jp",
    "miyawaka.fukuoka.jp",
    "mizumaki.fukuoka.jp",
    "munakata.fukuoka.jp",
    "nakagawa.fukuoka.jp",
    "nakama.fukuoka.jp",
    "nishi.fukuoka.jp",
    "nogata.fukuoka.jp",
    "ogori.fukuoka.jp",
    "okagaki.fukuoka.jp",
    "okawa.fukuoka.jp",
    "oki.fukuoka.jp",
    "omuta.fukuoka.jp",
    "onga.fukuoka.jp",
    "onojo.fukuoka.jp",
    "oto.fukuoka.jp",
    "saigawa.fukuoka.jp",
    "sasaguri.fukuoka.jp",
    "shingu.fukuoka.jp",
    "shinyoshitomi.fukuoka.jp",
    "shonai.fukuoka.jp",
    "soeda.fukuoka.jp",
    "sue.fukuoka.jp",
    "tachiarai.fukuoka.jp",
    "tagawa.fukuoka.jp",
    "takata.fukuoka.jp",
    "toho.fukuoka.jp",
    "toyotsu.fukuoka.jp",
    "tsuiki.fukuoka.jp",
    "ukiha.fukuoka.jp",
    "umi.fukuoka.jp",
    "usui.fukuoka.jp",
    "yamada.fukuoka.jp",
    "yame.fukuoka.jp",
    "yanagawa.fukuoka.jp",
    "yukuhashi.fukuoka.jp",
    "aizubange.fukushima.jp",
    "aizumisato.fukushima.jp",
    "aizuwakamatsu.fukushima.jp",
    "asakawa.fukushima.jp",
    "bandai.fukushima.jp",
    "date.fukushima.jp",
    "fukushima.fukushima.jp",
    "furudono.fukushima.jp",
    "futaba.fukushima.jp",
    "hanawa.fukushima.jp",
    "higashi.fukushima.jp",
    "hirata.fukushima.jp",
    "hirono.fukushima.jp",
    "iitate.fukushima.jp",
    "inawashiro.fukushima.jp",
    "ishikawa.fukushima.jp",
    "iwaki.fukushima.jp",
    "izumizaki.fukushima.jp",
    "kagamiishi.fukushima.jp",
    "kaneyama.fukushima.jp",
    "kawamata.fukushima.jp",
    "kitakata.fukushima.jp",
    "kitashiobara.fukushima.jp",
    "koori.fukushima.jp",
    "koriyama.fukushima.jp",
    "kunimi.fukushima.jp",
    "miharu.fukushima.jp",
    "mishima.fukushima.jp",
    "namie.fukushima.jp",
    "nango.fukushima.jp",
    "nishiaizu.fukushima.jp",
    "nishigo.fukushima.jp",
    "okuma.fukushima.jp",
    "omotego.fukushima.jp",
    "ono.fukushima.jp",
    "otama.fukushima.jp",
    "samegawa.fukushima.jp",
    "shimogo.fukushima.jp",
    "shirakawa.fukushima.jp",
    "showa.fukushima.jp",
    "soma.fukushima.jp",
    "sukagawa.fukushima.jp",
    "taishin.fukushima.jp",
    "tamakawa.fukushima.jp",
    "tanagura.fukushima.jp",
    "tenei.fukushima.jp",
    "yabuki.fukushima.jp",
    "yamato.fukushima.jp",
    "yamatsuri.fukushima.jp",
    "yanaizu.fukushima.jp",
    "yugawa.fukushima.jp",
    "anpachi.gifu.jp",
    "ena.gifu.jp",
    "gifu.gifu.jp",
    "ginan.gifu.jp",
    "godo.gifu.jp",
    "gujo.gifu.jp",
    "hashima.gifu.jp",
    "hichiso.gifu.jp",
    "hida.gifu.jp",
    "higashishirakawa.gifu.jp",
    "ibigawa.gifu.jp",
    "ikeda.gifu.jp",
    "kakamigahara.gifu.jp",
    "kani.gifu.jp",
    "kasahara.gifu.jp",
    "kasamatsu.gifu.jp",
    "kawaue.gifu.jp",
    "kitagata.gifu.jp",
    "mino.gifu.jp",
    "minokamo.gifu.jp",
    "mitake.gifu.jp",
    "mizunami.gifu.jp",
    "motosu.gifu.jp",
    "nakatsugawa.gifu.jp",
    "ogaki.gifu.jp",
    "sakahogi.gifu.jp",
    "seki.gifu.jp",
    "sekigahara.gifu.jp",
    "shirakawa.gifu.jp",
    "tajimi.gifu.jp",
    "takayama.gifu.jp",
    "tarui.gifu.jp",
    "toki.gifu.jp",
    "tomika.gifu.jp",
    "wanouchi.gifu.jp",
    "yamagata.gifu.jp",
    "yaotsu.gifu.jp",
    "yoro.gifu.jp",
    "annaka.gunma.jp",
    "chiyoda.gunma.jp",
    "fujioka.gunma.jp",
    "higashiagatsuma.gunma.jp",
    "isesaki.gunma.jp",
    "itakura.gunma.jp",
    "kanna.gunma.jp",
    "kanra.gunma.jp",
    "katashina.gunma.jp",
    "kawaba.gunma.jp",
    "kiryu.gunma.jp",
    "kusatsu.gunma.jp",
    "maebashi.gunma.jp",
    "meiwa.gunma.jp",
    "midori.gunma.jp",
    "minakami.gunma.jp",
    "naganohara.gunma.jp",
    "nakanojo.gunma.jp",
    "nanmoku.gunma.jp",
    "numata.gunma.jp",
    "oizumi.gunma.jp",
    "ora.gunma.jp",
    "ota.gunma.jp",
    "shibukawa.gunma.jp",
    "shimonita.gunma.jp",
    "shinto.gunma.jp",
    "showa.gunma.jp",
    "takasaki.gunma.jp",
    "takayama.gunma.jp",
    "tamamura.gunma.jp",
    "tatebayashi.gunma.jp",
    "tomioka.gunma.jp",
    "tsukiyono.gunma.jp",
    "tsumagoi.gunma.jp",
    "ueno.gunma.jp",
    "yoshioka.gunma.jp",
    "asaminami.hiroshima.jp",
    "daiwa.hiroshima.jp",
    "etajima.hiroshima.jp",
    "fuchu.hiroshima.jp",
    "fukuyama.hiroshima.jp",
    "hatsukaichi.hiroshima.jp",
    "higashihiroshima.hiroshima.jp",
    "hongo.hiroshima.jp",
    "jinsekikogen.hiroshima.jp",
    "kaita.hiroshima.jp",
    "kui.hiroshima.jp",
    "kumano.hiroshima.jp",
    "kure.hiroshima.jp",
    "mihara.hiroshima.jp",
    "miyoshi.hiroshima.jp",
    "naka.hiroshima.jp",
    "onomichi.hiroshima.jp",
    "osakikamijima.hiroshima.jp",
    "otake.hiroshima.jp",
    "saka.hiroshima.jp",
    "sera.hiroshima.jp",
    "seranishi.hiroshima.jp",
    "shinichi.hiroshima.jp",
    "shobara.hiroshima.jp",
    "takehara.hiroshima.jp",
    "abashiri.hokkaido.jp",
    "abira.hokkaido.jp",
    "aibetsu.hokkaido.jp",
    "akabira.hokkaido.jp",
    "akkeshi.hokkaido.jp",
    "asahikawa.hokkaido.jp",
    "ashibetsu.hokkaido.jp",
    "ashoro.hokkaido.jp",
    "assabu.hokkaido.jp",
    "atsuma.hokkaido.jp",
    "bibai.hokkaido.jp",
    "biei.hokkaido.jp",
    "bifuka.hokkaido.jp",
    "bihoro.hokkaido.jp",
    "biratori.hokkaido.jp",
    "chippubetsu.hokkaido.jp",
    "chitose.hokkaido.jp",
    "date.hokkaido.jp",
    "ebetsu.hokkaido.jp",
    "embetsu.hokkaido.jp",
    "eniwa.hokkaido.jp",
    "erimo.hokkaido.jp",
    "esan.hokkaido.jp",
    "esashi.hokkaido.jp",
    "fukagawa.hokkaido.jp",
    "fukushima.hokkaido.jp",
    "furano.hokkaido.jp",
    "furubira.hokkaido.jp",
    "haboro.hokkaido.jp",
    "hakodate.hokkaido.jp",
    "hamatonbetsu.hokkaido.jp",
    "hidaka.hokkaido.jp",
    "higashikagura.hokkaido.jp",
    "higashikawa.hokkaido.jp",
    "hiroo.hokkaido.jp",
    "hokuryu.hokkaido.jp",
    "hokuto.hokkaido.jp",
    "honbetsu.hokkaido.jp",
    "horokanai.hokkaido.jp",
    "horonobe.hokkaido.jp",
    "ikeda.hokkaido.jp",
    "imakane.hokkaido.jp",
    "ishikari.hokkaido.jp",
    "iwamizawa.hokkaido.jp",
    "iwanai.hokkaido.jp",
    "kamifurano.hokkaido.jp",
    "kamikawa.hokkaido.jp",
    "kamishihoro.hokkaido.jp",
    "kamisunagawa.hokkaido.jp",
    "kamoenai.hokkaido.jp",
    "kayabe.hokkaido.jp",
    "kembuchi.hokkaido.jp",
    "kikonai.hokkaido.jp",
    "kimobetsu.hokkaido.jp",
    "kitahiroshima.hokkaido.jp",
    "kitami.hokkaido.jp",
    "kiyosato.hokkaido.jp",
    "koshimizu.hokkaido.jp",
    "kunneppu.hokkaido.jp",
    "kuriyama.hokkaido.jp",
    "kuromatsunai.hokkaido.jp",
    "kushiro.hokkaido.jp",
    "kutchan.hokkaido.jp",
    "kyowa.hokkaido.jp",
    "mashike.hokkaido.jp",
    "matsumae.hokkaido.jp",
    "mikasa.hokkaido.jp",
    "minamifurano.hokkaido.jp",
    "mombetsu.hokkaido.jp",
    "moseushi.hokkaido.jp",
    "mukawa.hokkaido.jp",
    "muroran.hokkaido.jp",
    "naie.hokkaido.jp",
    "nakagawa.hokkaido.jp",
    "nakasatsunai.hokkaido.jp",
    "nakatombetsu.hokkaido.jp",
    "nanae.hokkaido.jp",
    "nanporo.hokkaido.jp",
    "nayoro.hokkaido.jp",
    "nemuro.hokkaido.jp",
    "niikappu.hokkaido.jp",
    "niki.hokkaido.jp",
    "nishiokoppe.hokkaido.jp",
    "noboribetsu.hokkaido.jp",
    "numata.hokkaido.jp",
    "obihiro.hokkaido.jp",
    "obira.hokkaido.jp",
    "oketo.hokkaido.jp",
    "okoppe.hokkaido.jp",
    "otaru.hokkaido.jp",
    "otobe.hokkaido.jp",
    "otofuke.hokkaido.jp",
    "otoineppu.hokkaido.jp",
    "oumu.hokkaido.jp",
    "ozora.hokkaido.jp",
    "pippu.hokkaido.jp",
    "rankoshi.hokkaido.jp",
    "rebun.hokkaido.jp",
    "rikubetsu.hokkaido.jp",
    "rishiri.hokkaido.jp",
    "rishirifuji.hokkaido.jp",
    "saroma.hokkaido.jp",
    "sarufutsu.hokkaido.jp",
    "shakotan.hokkaido.jp",
    "shari.hokkaido.jp",
    "shibecha.hokkaido.jp",
    "shibetsu.hokkaido.jp",
    "shikabe.hokkaido.jp",
    "shikaoi.hokkaido.jp",
    "shimamaki.hokkaido.jp",
    "shimizu.hokkaido.jp",
    "shimokawa.hokkaido.jp",
    "shinshinotsu.hokkaido.jp",
    "shintoku.hokkaido.jp",
    "shiranuka.hokkaido.jp",
    "shiraoi.hokkaido.jp",
    "shiriuchi.hokkaido.jp",
    "sobetsu.hokkaido.jp",
    "sunagawa.hokkaido.jp",
    "taiki.hokkaido.jp",
    "takasu.hokkaido.jp",
    "takikawa.hokkaido.jp",
    "takinoue.hokkaido.jp",
    "teshikaga.hokkaido.jp",
    "tobetsu.hokkaido.jp",
    "tohma.hokkaido.jp",
    "tomakomai.hokkaido.jp",
    "tomari.hokkaido.jp",
    "toya.hokkaido.jp",
    "toyako.hokkaido.jp",
    "toyotomi.hokkaido.jp",
    "toyoura.hokkaido.jp",
    "tsubetsu.hokkaido.jp",
    "tsukigata.hokkaido.jp",
    "urakawa.hokkaido.jp",
    "urausu.hokkaido.jp",
    "uryu.hokkaido.jp",
    "utashinai.hokkaido.jp",
    "wakkanai.hokkaido.jp",
    "wassamu.hokkaido.jp",
    "yakumo.hokkaido.jp",
    "yoichi.hokkaido.jp",
    "aioi.hyogo.jp",
    "akashi.hyogo.jp",
    "ako.hyogo.jp",
    "amagasaki.hyogo.jp",
    "aogaki.hyogo.jp",
    "asago.hyogo.jp",
    "ashiya.hyogo.jp",
    "awaji.hyogo.jp",
    "fukusaki.hyogo.jp",
    "goshiki.hyogo.jp",
    "harima.hyogo.jp",
    "himeji.hyogo.jp",
    "ichikawa.hyogo.jp",
    "inagawa.hyogo.jp",
    "itami.hyogo.jp",
    "kakogawa.hyogo.jp",
    "kamigori.hyogo.jp",
    "kamikawa.hyogo.jp",
    "kasai.hyogo.jp",
    "kasuga.hyogo.jp",
    "kawanishi.hyogo.jp",
    "miki.hyogo.jp",
    "minamiawaji.hyogo.jp",
    "nishinomiya.hyogo.jp",
    "nishiwaki.hyogo.jp",
    "ono.hyogo.jp",
    "sanda.hyogo.jp",
    "sannan.hyogo.jp",
    "sasayama.hyogo.jp",
    "sayo.hyogo.jp",
    "shingu.hyogo.jp",
    "shinonsen.hyogo.jp",
    "shiso.hyogo.jp",
    "sumoto.hyogo.jp",
    "taishi.hyogo.jp",
    "taka.hyogo.jp",
    "takarazuka.hyogo.jp",
    "takasago.hyogo.jp",
    "takino.hyogo.jp",
    "tamba.hyogo.jp",
    "tatsuno.hyogo.jp",
    "toyooka.hyogo.jp",
    "yabu.hyogo.jp",
    "yashiro.hyogo.jp",
    "yoka.hyogo.jp",
    "yokawa.hyogo.jp",
    "ami.ibaraki.jp",
    "asahi.ibaraki.jp",
    "bando.ibaraki.jp",
    "chikusei.ibaraki.jp",
    "daigo.ibaraki.jp",
    "fujishiro.ibaraki.jp",
    "hitachi.ibaraki.jp",
    "hitachinaka.ibaraki.jp",
    "hitachiomiya.ibaraki.jp",
    "hitachiota.ibaraki.jp",
    "ibaraki.ibaraki.jp",
    "ina.ibaraki.jp",
    "inashiki.ibaraki.jp",
    "itako.ibaraki.jp",
    "iwama.ibaraki.jp",
    "joso.ibaraki.jp",
    "kamisu.ibaraki.jp",
    "kasama.ibaraki.jp",
    "kashima.ibaraki.jp",
    "kasumigaura.ibaraki.jp",
    "koga.ibaraki.jp",
    "miho.ibaraki.jp",
    "mito.ibaraki.jp",
    "moriya.ibaraki.jp",
    "naka.ibaraki.jp",
    "namegata.ibaraki.jp",
    "oarai.ibaraki.jp",
    "ogawa.ibaraki.jp",
    "omitama.ibaraki.jp",
    "ryugasaki.ibaraki.jp",
    "sakai.ibaraki.jp",
    "sakuragawa.ibaraki.jp",
    "shimodate.ibaraki.jp",
    "shimotsuma.ibaraki.jp",
    "shirosato.ibaraki.jp",
    "sowa.ibaraki.jp",
    "suifu.ibaraki.jp",
    "takahagi.ibaraki.jp",
    "tamatsukuri.ibaraki.jp",
    "tokai.ibaraki.jp",
    "tomobe.ibaraki.jp",
    "tone.ibaraki.jp",
    "toride.ibaraki.jp",
    "tsuchiura.ibaraki.jp",
    "tsukuba.ibaraki.jp",
    "uchihara.ibaraki.jp",
    "ushiku.ibaraki.jp",
    "yachiyo.ibaraki.jp",
    "yamagata.ibaraki.jp",
    "yawara.ibaraki.jp",
    "yuki.ibaraki.jp",
    "anamizu.ishikawa.jp",
    "hakui.ishikawa.jp",
    "hakusan.ishikawa.jp",
    "kaga.ishikawa.jp",
    "kahoku.ishikawa.jp",
    "kanazawa.ishikawa.jp",
    "kawakita.ishikawa.jp",
    "komatsu.ishikawa.jp",
    "nakanoto.ishikawa.jp",
    "nanao.ishikawa.jp",
    "nomi.ishikawa.jp",
    "nonoichi.ishikawa.jp",
    "noto.ishikawa.jp",
    "shika.ishikawa.jp",
    "suzu.ishikawa.jp",
    "tsubata.ishikawa.jp",
    "tsurugi.ishikawa.jp",
    "uchinada.ishikawa.jp",
    "wajima.ishikawa.jp",
    "fudai.iwate.jp",
    "fujisawa.iwate.jp",
    "hanamaki.iwate.jp",
    "hiraizumi.iwate.jp",
    "hirono.iwate.jp",
    "ichinohe.iwate.jp",
    "ichinoseki.iwate.jp",
    "iwaizumi.iwate.jp",
    "iwate.iwate.jp",
    "joboji.iwate.jp",
    "kamaishi.iwate.jp",
    "kanegasaki.iwate.jp",
    "karumai.iwate.jp",
    "kawai.iwate.jp",
    "kitakami.iwate.jp",
    "kuji.iwate.jp",
    "kunohe.iwate.jp",
    "kuzumaki.iwate.jp",
    "miyako.iwate.jp",
    "mizusawa.iwate.jp",
    "morioka.iwate.jp",
    "ninohe.iwate.jp",
    "noda.iwate.jp",
    "ofunato.iwate.jp",
    "oshu.iwate.jp",
    "otsuchi.iwate.jp",
    "rikuzentakata.iwate.jp",
    "shiwa.iwate.jp",
    "shizukuishi.iwate.jp",
    "sumita.iwate.jp",
    "tanohata.iwate.jp",
    "tono.iwate.jp",
    "yahaba.iwate.jp",
    "yamada.iwate.jp",
    "ayagawa.kagawa.jp",
    "higashikagawa.kagawa.jp",
    "kanonji.kagawa.jp",
    "kotohira.kagawa.jp",
    "manno.kagawa.jp",
    "marugame.kagawa.jp",
    "mitoyo.kagawa.jp",
    "naoshima.kagawa.jp",
    "sanuki.kagawa.jp",
    "tadotsu.kagawa.jp",
    "takamatsu.kagawa.jp",
    "tonosho.kagawa.jp",
    "uchinomi.kagawa.jp",
    "utazu.kagawa.jp",
    "zentsuji.kagawa.jp",
    "akune.kagoshima.jp",
    "amami.kagoshima.jp",
    "hioki.kagoshima.jp",
    "isa.kagoshima.jp",
    "isen.kagoshima.jp",
    "izumi.kagoshima.jp",
    "kagoshima.kagoshima.jp",
    "kanoya.kagoshima.jp",
    "kawanabe.kagoshima.jp",
    "kinko.kagoshima.jp",
    "kouyama.kagoshima.jp",
    "makurazaki.kagoshima.jp",
    "matsumoto.kagoshima.jp",
    "minamitane.kagoshima.jp",
    "nakatane.kagoshima.jp",
    "nishinoomote.kagoshima.jp",
    "satsumasendai.kagoshima.jp",
    "soo.kagoshima.jp",
    "tarumizu.kagoshima.jp",
    "yusui.kagoshima.jp",
    "aikawa.kanagawa.jp",
    "atsugi.kanagawa.jp",
    "ayase.kanagawa.jp",
    "chigasaki.kanagawa.jp",
    "ebina.kanagawa.jp",
    "fujisawa.kanagawa.jp",
    "hadano.kanagawa.jp",
    "hakone.kanagawa.jp",
    "hiratsuka.kanagawa.jp",
    "isehara.kanagawa.jp",
    "kaisei.kanagawa.jp",
    "kamakura.kanagawa.jp",
    "kiyokawa.kanagawa.jp",
    "matsuda.kanagawa.jp",
    "minamiashigara.kanagawa.jp",
    "miura.kanagawa.jp",
    "nakai.kanagawa.jp",
    "ninomiya.kanagawa.jp",
    "odawara.kanagawa.jp",
    "oi.kanagawa.jp",
    "oiso.kanagawa.jp",
    "sagamihara.kanagawa.jp",
    "samukawa.kanagawa.jp",
    "tsukui.kanagawa.jp",
    "yamakita.kanagawa.jp",
    "yamato.kanagawa.jp",
    "yokosuka.kanagawa.jp",
    "yugawara.kanagawa.jp",
    "zama.kanagawa.jp",
    "zushi.kanagawa.jp",
    "aki.kochi.jp",
    "geisei.kochi.jp",
    "hidaka.kochi.jp",
    "higashitsuno.kochi.jp",
    "ino.kochi.jp",
    "kagami.kochi.jp",
    "kami.kochi.jp",
    "kitagawa.kochi.jp",
    "kochi.kochi.jp",
    "mihara.kochi.jp",
    "motoyama.kochi.jp",
    "muroto.kochi.jp",
    "nahari.kochi.jp",
    "nakamura.kochi.jp",
    "nankoku.kochi.jp",
    "nishitosa.kochi.jp",
    "niyodogawa.kochi.jp",
    "ochi.kochi.jp",
    "okawa.kochi.jp",
    "otoyo.kochi.jp",
    "otsuki.kochi.jp",
    "sakawa.kochi.jp",
    "sukumo.kochi.jp",
    "susaki.kochi.jp",
    "tosa.kochi.jp",
    "tosashimizu.kochi.jp",
    "toyo.kochi.jp",
    "tsuno.kochi.jp",
    "umaji.kochi.jp",
    "yasuda.kochi.jp",
    "yusuhara.kochi.jp",
    "amakusa.kumamoto.jp",
    "arao.kumamoto.jp",
    "aso.kumamoto.jp",
    "choyo.kumamoto.jp",
    "gyokuto.kumamoto.jp",
    "kamiamakusa.kumamoto.jp",
    "kikuchi.kumamoto.jp",
    "kumamoto.kumamoto.jp",
    "mashiki.kumamoto.jp",
    "mifune.kumamoto.jp",
    "minamata.kumamoto.jp",
    "minamioguni.kumamoto.jp",
    "nagasu.kumamoto.jp",
    "nishihara.kumamoto.jp",
    "oguni.kumamoto.jp",
    "ozu.kumamoto.jp",
    "sumoto.kumamoto.jp",
    "takamori.kumamoto.jp",
    "uki.kumamoto.jp",
    "uto.kumamoto.jp",
    "yamaga.kumamoto.jp",
    "yamato.kumamoto.jp",
    "yatsushiro.kumamoto.jp",
    "ayabe.kyoto.jp",
    "fukuchiyama.kyoto.jp",
    "higashiyama.kyoto.jp",
    "ide.kyoto.jp",
    "ine.kyoto.jp",
    "joyo.kyoto.jp",
    "kameoka.kyoto.jp",
    "kamo.kyoto.jp",
    "kita.kyoto.jp",
    "kizu.kyoto.jp",
    "kumiyama.kyoto.jp",
    "kyotamba.kyoto.jp",
    "kyotanabe.kyoto.jp",
    "kyotango.kyoto.jp",
    "maizuru.kyoto.jp",
    "minami.kyoto.jp",
    "minamiyamashiro.kyoto.jp",
    "miyazu.kyoto.jp",
    "muko.kyoto.jp",
    "nagaokakyo.kyoto.jp",
    "nakagyo.kyoto.jp",
    "nantan.kyoto.jp",
    "oyamazaki.kyoto.jp",
    "sakyo.kyoto.jp",
    "seika.kyoto.jp",
    "tanabe.kyoto.jp",
    "uji.kyoto.jp",
    "ujitawara.kyoto.jp",
    "wazuka.kyoto.jp",
    "yamashina.kyoto.jp",
    "yawata.kyoto.jp",
    "asahi.mie.jp",
    "inabe.mie.jp",
    "ise.mie.jp",
    "kameyama.mie.jp",
    "kawagoe.mie.jp",
    "kiho.mie.jp",
    "kisosaki.mie.jp",
    "kiwa.mie.jp",
    "komono.mie.jp",
    "kumano.mie.jp",
    "kuwana.mie.jp",
    "matsusaka.mie.jp",
    "meiwa.mie.jp",
    "mihama.mie.jp",
    "minamiise.mie.jp",
    "misugi.mie.jp",
    "miyama.mie.jp",
    "nabari.mie.jp",
    "shima.mie.jp",
    "suzuka.mie.jp",
    "tado.mie.jp",
    "taiki.mie.jp",
    "taki.mie.jp",
    "tamaki.mie.jp",
    "toba.mie.jp",
    "tsu.mie.jp",
    "udono.mie.jp",
    "ureshino.mie.jp",
    "watarai.mie.jp",
    "yokkaichi.mie.jp",
    "furukawa.miyagi.jp",
    "higashimatsushima.miyagi.jp",
    "ishinomaki.miyagi.jp",
    "iwanuma.miyagi.jp",
    "kakuda.miyagi.jp",
    "kami.miyagi.jp",
    "kawasaki.miyagi.jp",
    "marumori.miyagi.jp",
    "matsushima.miyagi.jp",
    "minamisanriku.miyagi.jp",
    "misato.miyagi.jp",
    "murata.miyagi.jp",
    "natori.miyagi.jp",
    "ogawara.miyagi.jp",
    "ohira.miyagi.jp",
    "onagawa.miyagi.jp",
    "osaki.miyagi.jp",
    "rifu.miyagi.jp",
    "semine.miyagi.jp",
    "shibata.miyagi.jp",
    "shichikashuku.miyagi.jp",
    "shikama.miyagi.jp",
    "shiogama.miyagi.jp",
    "shiroishi.miyagi.jp",
    "tagajo.miyagi.jp",
    "taiwa.miyagi.jp",
    "tome.miyagi.jp",
    "tomiya.miyagi.jp",
    "wakuya.miyagi.jp",
    "watari.miyagi.jp",
    "yamamoto.miyagi.jp",
    "zao.miyagi.jp",
    "aya.miyazaki.jp",
    "ebino.miyazaki.jp",
    "gokase.miyazaki.jp",
    "hyuga.miyazaki.jp",
    "kadogawa.miyazaki.jp",
    "kawaminami.miyazaki.jp",
    "kijo.miyazaki.jp",
    "kitagawa.miyazaki.jp",
    "kitakata.miyazaki.jp",
    "kitaura.miyazaki.jp",
    "kobayashi.miyazaki.jp",
    "kunitomi.miyazaki.jp",
    "kushima.miyazaki.jp",
    "mimata.miyazaki.jp",
    "miyakonojo.miyazaki.jp",
    "miyazaki.miyazaki.jp",
    "morotsuka.miyazaki.jp",
    "nichinan.miyazaki.jp",
    "nishimera.miyazaki.jp",
    "nobeoka.miyazaki.jp",
    "saito.miyazaki.jp",
    "shiiba.miyazaki.jp",
    "shintomi.miyazaki.jp",
    "takaharu.miyazaki.jp",
    "takanabe.miyazaki.jp",
    "takazaki.miyazaki.jp",
    "tsuno.miyazaki.jp",
    "achi.nagano.jp",
    "agematsu.nagano.jp",
    "anan.nagano.jp",
    "aoki.nagano.jp",
    "asahi.nagano.jp",
    "azumino.nagano.jp",
    "chikuhoku.nagano.jp",
    "chikuma.nagano.jp",
    "chino.nagano.jp",
    "fujimi.nagano.jp",
    "hakuba.nagano.jp",
    "hara.nagano.jp",
    "hiraya.nagano.jp",
    "iida.nagano.jp",
    "iijima.nagano.jp",
    "iiyama.nagano.jp",
    "iizuna.nagano.jp",
    "ikeda.nagano.jp",
    "ikusaka.nagano.jp",
    "ina.nagano.jp",
    "karuizawa.nagano.jp",
    "kawakami.nagano.jp",
    "kiso.nagano.jp",
    "kisofukushima.nagano.jp",
    "kitaaiki.nagano.jp",
    "komagane.nagano.jp",
    "komoro.nagano.jp",
    "matsukawa.nagano.jp",
    "matsumoto.nagano.jp",
    "miasa.nagano.jp",
    "minamiaiki.nagano.jp",
    "minamimaki.nagano.jp",
    "minamiminowa.nagano.jp",
    "minowa.nagano.jp",
    "miyada.nagano.jp",
    "miyota.nagano.jp",
    "mochizuki.nagano.jp",
    "nagano.nagano.jp",
    "nagawa.nagano.jp",
    "nagiso.nagano.jp",
    "nakagawa.nagano.jp",
    "nakano.nagano.jp",
    "nozawaonsen.nagano.jp",
    "obuse.nagano.jp",
    "ogawa.nagano.jp",
    "okaya.nagano.jp",
    "omachi.nagano.jp",
    "omi.nagano.jp",
    "ookuwa.nagano.jp",
    "ooshika.nagano.jp",
    "otaki.nagano.jp",
    "otari.nagano.jp",
    "sakae.nagano.jp",
    "sakaki.nagano.jp",
    "saku.nagano.jp",
    "sakuho.nagano.jp",
    "shimosuwa.nagano.jp",
    "shinanomachi.nagano.jp",
    "shiojiri.nagano.jp",
    "suwa.nagano.jp",
    "suzaka.nagano.jp",
    "takagi.nagano.jp",
    "takamori.nagano.jp",
    "takayama.nagano.jp",
    "tateshina.nagano.jp",
    "tatsuno.nagano.jp",
    "togakushi.nagano.jp",
    "togura.nagano.jp",
    "tomi.nagano.jp",
    "ueda.nagano.jp",
    "wada.nagano.jp",
    "yamagata.nagano.jp",
    "yamanouchi.nagano.jp",
    "yasaka.nagano.jp",
    "yasuoka.nagano.jp",
    "chijiwa.nagasaki.jp",
    "futsu.nagasaki.jp",
    "goto.nagasaki.jp",
    "hasami.nagasaki.jp",
    "hirado.nagasaki.jp",
    "iki.nagasaki.jp",
    "isahaya.nagasaki.jp",
    "kawatana.nagasaki.jp",
    "kuchinotsu.nagasaki.jp",
    "matsuura.nagasaki.jp",
    "nagasaki.nagasaki.jp",
    "obama.nagasaki.jp",
    "omura.nagasaki.jp",
    "oseto.nagasaki.jp",
    "saikai.nagasaki.jp",
    "sasebo.nagasaki.jp",
    "seihi.nagasaki.jp",
    "shimabara.nagasaki.jp",
    "shinkamigoto.nagasaki.jp",
    "togitsu.nagasaki.jp",
    "tsushima.nagasaki.jp",
    "unzen.nagasaki.jp",
    "ando.nara.jp",
    "gose.nara.jp",
    "heguri.nara.jp",
    "higashiyoshino.nara.jp",
    "ikaruga.nara.jp",
    "ikoma.nara.jp",
    "kamikitayama.nara.jp",
    "kanmaki.nara.jp",
    "kashiba.nara.jp",
    "kashihara.nara.jp",
    "katsuragi.nara.jp",
    "kawai.nara.jp",
    "kawakami.nara.jp",
    "kawanishi.nara.jp",
    "koryo.nara.jp",
    "kurotaki.nara.jp",
    "mitsue.nara.jp",
    "miyake.nara.jp",
    "nara.nara.jp",
    "nosegawa.nara.jp",
    "oji.nara.jp",
    "ouda.nara.jp",
    "oyodo.nara.jp",
    "sakurai.nara.jp",
    "sango.nara.jp",
    "shimoichi.nara.jp",
    "shimokitayama.nara.jp",
    "shinjo.nara.jp",
    "soni.nara.jp",
    "takatori.nara.jp",
    "tawaramoto.nara.jp",
    "tenkawa.nara.jp",
    "tenri.nara.jp",
    "uda.nara.jp",
    "yamatokoriyama.nara.jp",
    "yamatotakada.nara.jp",
    "yamazoe.nara.jp",
    "yoshino.nara.jp",
    "aga.niigata.jp",
    "agano.niigata.jp",
    "gosen.niigata.jp",
    "itoigawa.niigata.jp",
    "izumozaki.niigata.jp",
    "joetsu.niigata.jp",
    "kamo.niigata.jp",
    "kariwa.niigata.jp",
    "kashiwazaki.niigata.jp",
    "minamiuonuma.niigata.jp",
    "mitsuke.niigata.jp",
    "muika.niigata.jp",
    "murakami.niigata.jp",
    "myoko.niigata.jp",
    "nagaoka.niigata.jp",
    "niigata.niigata.jp",
    "ojiya.niigata.jp",
    "omi.niigata.jp",
    "sado.niigata.jp",
    "sanjo.niigata.jp",
    "seiro.niigata.jp",
    "seirou.niigata.jp",
    "sekikawa.niigata.jp",
    "shibata.niigata.jp",
    "tagami.niigata.jp",
    "tainai.niigata.jp",
    "tochio.niigata.jp",
    "tokamachi.niigata.jp",
    "tsubame.niigata.jp",
    "tsunan.niigata.jp",
    "uonuma.niigata.jp",
    "yahiko.niigata.jp",
    "yoita.niigata.jp",
    "yuzawa.niigata.jp",
    "beppu.oita.jp",
    "bungoono.oita.jp",
    "bungotakada.oita.jp",
    "hasama.oita.jp",
    "hiji.oita.jp",
    "himeshima.oita.jp",
    "hita.oita.jp",
    "kamitsue.oita.jp",
    "kokonoe.oita.jp",
    "kuju.oita.jp",
    "kunisaki.oita.jp",
    "kusu.oita.jp",
    "oita.oita.jp",
    "saiki.oita.jp",
    "taketa.oita.jp",
    "tsukumi.oita.jp",
    "usa.oita.jp",
    "usuki.oita.jp",
    "yufu.oita.jp",
    "akaiwa.okayama.jp",
    "asakuchi.okayama.jp",
    "bizen.okayama.jp",
    "hayashima.okayama.jp",
    "ibara.okayama.jp",
    "kagamino.okayama.jp",
    "kasaoka.okayama.jp",
    "kibichuo.okayama.jp",
    "kumenan.okayama.jp",
    "kurashiki.okayama.jp",
    "maniwa.okayama.jp",
    "misaki.okayama.jp",
    "nagi.okayama.jp",
    "niimi.okayama.jp",
    "nishiawakura.okayama.jp",
    "okayama.okayama.jp",
    "satosho.okayama.jp",
    "setouchi.okayama.jp",
    "shinjo.okayama.jp",
    "shoo.okayama.jp",
    "soja.okayama.jp",
    "takahashi.okayama.jp",
    "tamano.okayama.jp",
    "tsuyama.okayama.jp",
    "wake.okayama.jp",
    "yakage.okayama.jp",
    "aguni.okinawa.jp",
    "ginowan.okinawa.jp",
    "ginoza.okinawa.jp",
    "gushikami.okinawa.jp",
    "haebaru.okinawa.jp",
    "higashi.okinawa.jp",
    "hirara.okinawa.jp",
    "iheya.okinawa.jp",
    "ishigaki.okinawa.jp",
    "ishikawa.okinawa.jp",
    "itoman.okinawa.jp",
    "izena.okinawa.jp",
    "kadena.okinawa.jp",
    "kin.okinawa.jp",
    "kitadaito.okinawa.jp",
    "kitanakagusuku.okinawa.jp",
    "kumejima.okinawa.jp",
    "kunigami.okinawa.jp",
    "minamidaito.okinawa.jp",
    "motobu.okinawa.jp",
    "nago.okinawa.jp",
    "naha.okinawa.jp",
    "nakagusuku.okinawa.jp",
    "nakijin.okinawa.jp",
    "nanjo.okinawa.jp",
    "nishihara.okinawa.jp",
    "ogimi.okinawa.jp",
    "okinawa.okinawa.jp",
    "onna.okinawa.jp",
    "shimoji.okinawa.jp",
    "taketomi.okinawa.jp",
    "tarama.okinawa.jp",
    "tokashiki.okinawa.jp",
    "tomigusuku.okinawa.jp",
    "tonaki.okinawa.jp",
    "urasoe.okinawa.jp",
    "uruma.okinawa.jp",
    "yaese.okinawa.jp",
    "yomitan.okinawa.jp",
    "yonabaru.okinawa.jp",
    "yonaguni.okinawa.jp",
    "zamami.okinawa.jp",
    "abeno.osaka.jp",
    "chihayaakasaka.osaka.jp",
    "chuo.osaka.jp",
    "daito.osaka.jp",
    "fujiidera.osaka.jp",
    "habikino.osaka.jp",
    "hannan.osaka.jp",
    "higashiosaka.osaka.jp",
    "higashisumiyoshi.osaka.jp",
    "higashiyodogawa.osaka.jp",
    "hirakata.osaka.jp",
    "ibaraki.osaka.jp",
    "ikeda.osaka.jp",
    "izumi.osaka.jp",
    "izumiotsu.osaka.jp",
    "izumisano.osaka.jp",
    "kadoma.osaka.jp",
    "kaizuka.osaka.jp",
    "kanan.osaka.jp",
    "kashiwara.osaka.jp",
    "katano.osaka.jp",
    "kawachinagano.osaka.jp",
    "kishiwada.osaka.jp",
    "kita.osaka.jp",
    "kumatori.osaka.jp",
    "matsubara.osaka.jp",
    "minato.osaka.jp",
    "minoh.osaka.jp",
    "misaki.osaka.jp",
    "moriguchi.osaka.jp",
    "neyagawa.osaka.jp",
    "nishi.osaka.jp",
    "nose.osaka.jp",
    "osakasayama.osaka.jp",
    "sakai.osaka.jp",
    "sayama.osaka.jp",
    "sennan.osaka.jp",
    "settsu.osaka.jp",
    "shijonawate.osaka.jp",
    "shimamoto.osaka.jp",
    "suita.osaka.jp",
    "tadaoka.osaka.jp",
    "taishi.osaka.jp",
    "tajiri.osaka.jp",
    "takaishi.osaka.jp",
    "takatsuki.osaka.jp",
    "tondabayashi.osaka.jp",
    "toyonaka.osaka.jp",
    "toyono.osaka.jp",
    "yao.osaka.jp",
    "ariake.saga.jp",
    "arita.saga.jp",
    "fukudomi.saga.jp",
    "genkai.saga.jp",
    "hamatama.saga.jp",
    "hizen.saga.jp",
    "imari.saga.jp",
    "kamimine.saga.jp",
    "kanzaki.saga.jp",
    "karatsu.saga.jp",
    "kashima.saga.jp",
    "kitagata.saga.jp",
    "kitahata.saga.jp",
    "kiyama.saga.jp",
    "kouhoku.saga.jp",
    "kyuragi.saga.jp",
    "nishiarita.saga.jp",
    "ogi.saga.jp",
    "omachi.saga.jp",
    "ouchi.saga.jp",
    "saga.saga.jp",
    "shiroishi.saga.jp",
    "taku.saga.jp",
    "tara.saga.jp",
    "tosu.saga.jp",
    "yoshinogari.saga.jp",
    "arakawa.saitama.jp",
    "asaka.saitama.jp",
    "chichibu.saitama.jp",
    "fujimi.saitama.jp",
    "fujimino.saitama.jp",
    "fukaya.saitama.jp",
    "hanno.saitama.jp",
    "hanyu.saitama.jp",
    "hasuda.saitama.jp",
    "hatogaya.saitama.jp",
    "hatoyama.saitama.jp",
    "hidaka.saitama.jp",
    "higashichichibu.saitama.jp",
    "higashimatsuyama.saitama.jp",
    "honjo.saitama.jp",
    "ina.saitama.jp",
    "iruma.saitama.jp",
    "iwatsuki.saitama.jp",
    "kamiizumi.saitama.jp",
    "kamikawa.saitama.jp",
    "kamisato.saitama.jp",
    "kasukabe.saitama.jp",
    "kawagoe.saitama.jp",
    "kawaguchi.saitama.jp",
    "kawajima.saitama.jp",
    "kazo.saitama.jp",
    "kitamoto.saitama.jp",
    "koshigaya.saitama.jp",
    "kounosu.saitama.jp",
    "kuki.saitama.jp",
    "kumagaya.saitama.jp",
    "matsubushi.saitama.jp",
    "minano.saitama.jp",
    "misato.saitama.jp",
    "miyashiro.saitama.jp",
    "miyoshi.saitama.jp",
    "moroyama.saitama.jp",
    "nagatoro.saitama.jp",
    "namegawa.saitama.jp",
    "niiza.saitama.jp",
    "ogano.saitama.jp",
    "ogawa.saitama.jp",
    "ogose.saitama.jp",
    "okegawa.saitama.jp",
    "omiya.saitama.jp",
    "otaki.saitama.jp",
    "ranzan.saitama.jp",
    "ryokami.saitama.jp",
    "saitama.saitama.jp",
    "sakado.saitama.jp",
    "satte.saitama.jp",
    "sayama.saitama.jp",
    "shiki.saitama.jp",
    "shiraoka.saitama.jp",
    "soka.saitama.jp",
    "sugito.saitama.jp",
    "toda.saitama.jp",
    "tokigawa.saitama.jp",
    "tokorozawa.saitama.jp",
    "tsurugashima.saitama.jp",
    "urawa.saitama.jp",
    "warabi.saitama.jp",
    "yashio.saitama.jp",
    "yokoze.saitama.jp",
    "yono.saitama.jp",
    "yorii.saitama.jp",
    "yoshida.saitama.jp",
    "yoshikawa.saitama.jp",
    "yoshimi.saitama.jp",
    "aisho.shiga.jp",
    "gamo.shiga.jp",
    "higashiomi.shiga.jp",
    "hikone.shiga.jp",
    "koka.shiga.jp",
    "konan.shiga.jp",
    "kosei.shiga.jp",
    "koto.shiga.jp",
    "kusatsu.shiga.jp",
    "maibara.shiga.jp",
    "moriyama.shiga.jp",
    "nagahama.shiga.jp",
    "nishiazai.shiga.jp",
    "notogawa.shiga.jp",
    "omihachiman.shiga.jp",
    "otsu.shiga.jp",
    "ritto.shiga.jp",
    "ryuoh.shiga.jp",
    "takashima.shiga.jp",
    "takatsuki.shiga.jp",
    "torahime.shiga.jp",
    "toyosato.shiga.jp",
    "yasu.shiga.jp",
    "akagi.shimane.jp",
    "ama.shimane.jp",
    "gotsu.shimane.jp",
    "hamada.shimane.jp",
    "higashiizumo.shimane.jp",
    "hikawa.shimane.jp",
    "hikimi.shimane.jp",
    "izumo.shimane.jp",
    "kakinoki.shimane.jp",
    "masuda.shimane.jp",
    "matsue.shimane.jp",
    "misato.shimane.jp",
    "nishinoshima.shimane.jp",
    "ohda.shimane.jp",
    "okinoshima.shimane.jp",
    "okuizumo.shimane.jp",
    "shimane.shimane.jp",
    "tamayu.shimane.jp",
    "tsuwano.shimane.jp",
    "unnan.shimane.jp",
    "yakumo.shimane.jp",
    "yasugi.shimane.jp",
    "yatsuka.shimane.jp",
    "arai.shizuoka.jp",
    "atami.shizuoka.jp",
    "fuji.shizuoka.jp",
    "fujieda.shizuoka.jp",
    "fujikawa.shizuoka.jp",
    "fujinomiya.shizuoka.jp",
    "fukuroi.shizuoka.jp",
    "gotemba.shizuoka.jp",
    "haibara.shizuoka.jp",
    "hamamatsu.shizuoka.jp",
    "higashiizu.shizuoka.jp",
    "ito.shizuoka.jp",
    "iwata.shizuoka.jp",
    "izu.shizuoka.jp",
    "izunokuni.shizuoka.jp",
    "kakegawa.shizuoka.jp",
    "kannami.shizuoka.jp",
    "kawanehon.shizuoka.jp",
    "kawazu.shizuoka.jp",
    "kikugawa.shizuoka.jp",
    "kosai.shizuoka.jp",
    "makinohara.shizuoka.jp",
    "matsuzaki.shizuoka.jp",
    "minamiizu.shizuoka.jp",
    "mishima.shizuoka.jp",
    "morimachi.shizuoka.jp",
    "nishiizu.shizuoka.jp",
    "numazu.shizuoka.jp",
    "omaezaki.shizuoka.jp",
    "shimada.shizuoka.jp",
    "shimizu.shizuoka.jp",
    "shimoda.shizuoka.jp",
    "shizuoka.shizuoka.jp",
    "susono.shizuoka.jp",
    "yaizu.shizuoka.jp",
    "yoshida.shizuoka.jp",
    "ashikaga.tochigi.jp",
    "bato.tochigi.jp",
    "haga.tochigi.jp",
    "ichikai.tochigi.jp",
    "iwafune.tochigi.jp",
    "kaminokawa.tochigi.jp",
    "kanuma.tochigi.jp",
    "karasuyama.tochigi.jp",
    "kuroiso.tochigi.jp",
    "mashiko.tochigi.jp",
    "mibu.tochigi.jp",
    "moka.tochigi.jp",
    "motegi.tochigi.jp",
    "nasu.tochigi.jp",
    "nasushiobara.tochigi.jp",
    "nikko.tochigi.jp",
    "nishikata.tochigi.jp",
    "nogi.tochigi.jp",
    "ohira.tochigi.jp",
    "ohtawara.tochigi.jp",
    "oyama.tochigi.jp",
    "sakura.tochigi.jp",
    "sano.tochigi.jp",
    "shimotsuke.tochigi.jp",
    "shioya.tochigi.jp",
    "takanezawa.tochigi.jp",
    "tochigi.tochigi.jp",
    "tsuga.tochigi.jp",
    "ujiie.tochigi.jp",
    "utsunomiya.tochigi.jp",
    "yaita.tochigi.jp",
    "aizumi.tokushima.jp",
    "anan.tokushima.jp",
    "ichiba.tokushima.jp",
    "itano.tokushima.jp",
    "kainan.tokushima.jp",
    "komatsushima.tokushima.jp",
    "matsushige.tokushima.jp",
    "mima.tokushima.jp",
    "minami.tokushima.jp",
    "miyoshi.tokushima.jp",
    "mugi.tokushima.jp",
    "nakagawa.tokushima.jp",
    "naruto.tokushima.jp",
    "sanagochi.tokushima.jp",
    "shishikui.tokushima.jp",
    "tokushima.tokushima.jp",
    "wajiki.tokushima.jp",
    "adachi.tokyo.jp",
    "akiruno.tokyo.jp",
    "akishima.tokyo.jp",
    "aogashima.tokyo.jp",
    "arakawa.tokyo.jp",
    "bunkyo.tokyo.jp",
    "chiyoda.tokyo.jp",
    "chofu.tokyo.jp",
    "chuo.tokyo.jp",
    "edogawa.tokyo.jp",
    "fuchu.tokyo.jp",
    "fussa.tokyo.jp",
    "hachijo.tokyo.jp",
    "hachioji.tokyo.jp",
    "hamura.tokyo.jp",
    "higashikurume.tokyo.jp",
    "higashimurayama.tokyo.jp",
    "higashiyamato.tokyo.jp",
    "hino.tokyo.jp",
    "hinode.tokyo.jp",
    "hinohara.tokyo.jp",
    "inagi.tokyo.jp",
    "itabashi.tokyo.jp",
    "katsushika.tokyo.jp",
    "kita.tokyo.jp",
    "kiyose.tokyo.jp",
    "kodaira.tokyo.jp",
    "koganei.tokyo.jp",
    "kokubunji.tokyo.jp",
    "komae.tokyo.jp",
    "koto.tokyo.jp",
    "kouzushima.tokyo.jp",
    "kunitachi.tokyo.jp",
    "machida.tokyo.jp",
    "meguro.tokyo.jp",
    "minato.tokyo.jp",
    "mitaka.tokyo.jp",
    "mizuho.tokyo.jp",
    "musashimurayama.tokyo.jp",
    "musashino.tokyo.jp",
    "nakano.tokyo.jp",
    "nerima.tokyo.jp",
    "ogasawara.tokyo.jp",
    "okutama.tokyo.jp",
    "ome.tokyo.jp",
    "oshima.tokyo.jp",
    "ota.tokyo.jp",
    "setagaya.tokyo.jp",
    "shibuya.tokyo.jp",
    "shinagawa.tokyo.jp",
    "shinjuku.tokyo.jp",
    "suginami.tokyo.jp",
    "sumida.tokyo.jp",
    "tachikawa.tokyo.jp",
    "taito.tokyo.jp",
    "tama.tokyo.jp",
    "toshima.tokyo.jp",
    "chizu.tottori.jp",
    "hino.tottori.jp",
    "kawahara.tottori.jp",
    "koge.tottori.jp",
    "kotoura.tottori.jp",
    "misasa.tottori.jp",
    "nanbu.tottori.jp",
    "nichinan.tottori.jp",
    "sakaiminato.tottori.jp",
    "tottori.tottori.jp",
    "wakasa.tottori.jp",
    "yazu.tottori.jp",
    "yonago.tottori.jp",
    "asahi.toyama.jp",
    "fuchu.toyama.jp",
    "fukumitsu.toyama.jp",
    "funahashi.toyama.jp",
    "himi.toyama.jp",
    "imizu.toyama.jp",
    "inami.toyama.jp",
    "johana.toyama.jp",
    "kamiichi.toyama.jp",
    "kurobe.toyama.jp",
    "nakaniikawa.toyama.jp",
    "namerikawa.toyama.jp",
    "nanto.toyama.jp",
    "nyuzen.toyama.jp",
    "oyabe.toyama.jp",
    "taira.toyama.jp",
    "takaoka.toyama.jp",
    "tateyama.toyama.jp",
    "toga.toyama.jp",
    "tonami.toyama.jp",
    "toyama.toyama.jp",
    "unazuki.toyama.jp",
    "uozu.toyama.jp",
    "yamada.toyama.jp",
    "arida.wakayama.jp",
    "aridagawa.wakayama.jp",
    "gobo.wakayama.jp",
    "hashimoto.wakayama.jp",
    "hidaka.wakayama.jp",
    "hirogawa.wakayama.jp",
    "inami.wakayama.jp",
    "iwade.wakayama.jp",
    "kainan.wakayama.jp",
    "kamitonda.wakayama.jp",
    "katsuragi.wakayama.jp",
    "kimino.wakayama.jp",
    "kinokawa.wakayama.jp",
    "kitayama.wakayama.jp",
    "koya.wakayama.jp",
    "koza.wakayama.jp",
    "kozagawa.wakayama.jp",
    "kudoyama.wakayama.jp",
    "kushimoto.wakayama.jp",
    "mihama.wakayama.jp",
    "misato.wakayama.jp",
    "nachikatsuura.wakayama.jp",
    "shingu.wakayama.jp",
    "shirahama.wakayama.jp",
    "taiji.wakayama.jp",
    "tanabe.wakayama.jp",
    "wakayama.wakayama.jp",
    "yuasa.wakayama.jp",
    "yura.wakayama.jp",
    "asahi.yamagata.jp",
    "funagata.yamagata.jp",
    "higashine.yamagata.jp",
    "iide.yamagata.jp",
    "kahoku.yamagata.jp",
    "kaminoyama.yamagata.jp",
    "kaneyama.yamagata.jp",
    "kawanishi.yamagata.jp",
    "mamurogawa.yamagata.jp",
    "mikawa.yamagata.jp",
    "murayama.yamagata.jp",
    "nagai.yamagata.jp",
    "nakayama.yamagata.jp",
    "nanyo.yamagata.jp",
    "nishikawa.yamagata.jp",
    "obanazawa.yamagata.jp",
    "oe.yamagata.jp",
    "oguni.yamagata.jp",
    "ohkura.yamagata.jp",
    "oishida.yamagata.jp",
    "sagae.yamagata.jp",
    "sakata.yamagata.jp",
    "sakegawa.yamagata.jp",
    "shinjo.yamagata.jp",
    "shirataka.yamagata.jp",
    "shonai.yamagata.jp",
    "takahata.yamagata.jp",
    "tendo.yamagata.jp",
    "tozawa.yamagata.jp",
    "tsuruoka.yamagata.jp",
    "yamagata.yamagata.jp",
    "yamanobe.yamagata.jp",
    "yonezawa.yamagata.jp",
    "yuza.yamagata.jp",
    "abu.yamaguchi.jp",
    "hagi.yamaguchi.jp",
    "hikari.yamaguchi.jp",
    "hofu.yamaguchi.jp",
    "iwakuni.yamaguchi.jp",
    "kudamatsu.yamaguchi.jp",
    "mitou.yamaguchi.jp",
    "nagato.yamaguchi.jp",
    "oshima.yamaguchi.jp",
    "shimonoseki.yamaguchi.jp",
    "shunan.yamaguchi.jp",
    "tabuse.yamaguchi.jp",
    "tokuyama.yamaguchi.jp",
    "toyota.yamaguchi.jp",
    "ube.yamaguchi.jp",
    "yuu.yamaguchi.jp",
    "chuo.yamanashi.jp",
    "doshi.yamanashi.jp",
    "fuefuki.yamanashi.jp",
    "fujikawa.yamanashi.jp",
    "fujikawaguchiko.yamanashi.jp",
    "fujiyoshida.yamanashi.jp",
    "hayakawa.yamanashi.jp",
    "hokuto.yamanashi.jp",
    "ichikawamisato.yamanashi.jp",
    "kai.yamanashi.jp",
    "kofu.yamanashi.jp",
    "koshu.yamanashi.jp",
    "kosuge.yamanashi.jp",
    "minami-alps.yamanashi.jp",
    "minobu.yamanashi.jp",
    "nakamichi.yamanashi.jp",
    "nanbu.yamanashi.jp",
    "narusawa.yamanashi.jp",
    "nirasaki.yamanashi.jp",
    "nishikatsura.yamanashi.jp",
    "oshino.yamanashi.jp",
    "otsuki.yamanashi.jp",
    "showa.yamanashi.jp",
    "tabayama.yamanashi.jp",
    "tsuru.yamanashi.jp",
    "uenohara.yamanashi.jp",
    "yamanakako.yamanashi.jp",
    "yamanashi.yamanashi.jp",
    "ke",
    "ac.ke",
    "co.ke",
    "go.ke",
    "info.ke",
    "me.ke",
    "mobi.ke",
    "ne.ke",
    "or.ke",
    "sc.ke",
    "kg",
    "org.kg",
    "net.kg",
    "com.kg",
    "edu.kg",
    "gov.kg",
    "mil.kg",
    "*.kh",
    "ki",
    "edu.ki",
    "biz.ki",
    "net.ki",
    "org.ki",
    "gov.ki",
    "info.ki",
    "com.ki",
    "km",
    "org.km",
    "nom.km",
    "gov.km",
    "prd.km",
    "tm.km",
    "edu.km",
    "mil.km",
    "ass.km",
    "com.km",
    "coop.km",
    "asso.km",
    "presse.km",
    "medecin.km",
    "notaires.km",
    "pharmaciens.km",
    "veterinaire.km",
    "gouv.km",
    "kn",
    "net.kn",
    "org.kn",
    "edu.kn",
    "gov.kn",
    "kp",
    "com.kp",
    "edu.kp",
    "gov.kp",
    "org.kp",
    "rep.kp",
    "tra.kp",
    "kr",
    "ac.kr",
    "co.kr",
    "es.kr",
    "go.kr",
    "hs.kr",
    "kg.kr",
    "mil.kr",
    "ms.kr",
    "ne.kr",
    "or.kr",
    "pe.kr",
    "re.kr",
    "sc.kr",
    "busan.kr",
    "chungbuk.kr",
    "chungnam.kr",
    "daegu.kr",
    "daejeon.kr",
    "gangwon.kr",
    "gwangju.kr",
    "gyeongbuk.kr",
    "gyeonggi.kr",
    "gyeongnam.kr",
    "incheon.kr",
    "jeju.kr",
    "jeonbuk.kr",
    "jeonnam.kr",
    "seoul.kr",
    "ulsan.kr",
    "kw",
    "com.kw",
    "edu.kw",
    "emb.kw",
    "gov.kw",
    "ind.kw",
    "net.kw",
    "org.kw",
    "ky",
    "com.ky",
    "edu.ky",
    "net.ky",
    "org.ky",
    "kz",
    "org.kz",
    "edu.kz",
    "net.kz",
    "gov.kz",
    "mil.kz",
    "com.kz",
    "la",
    "int.la",
    "net.la",
    "info.la",
    "edu.la",
    "gov.la",
    "per.la",
    "com.la",
    "org.la",
    "lb",
    "com.lb",
    "edu.lb",
    "gov.lb",
    "net.lb",
    "org.lb",
    "lc",
    "com.lc",
    "net.lc",
    "co.lc",
    "org.lc",
    "edu.lc",
    "gov.lc",
    "li",
    "lk",
    "gov.lk",
    "sch.lk",
    "net.lk",
    "int.lk",
    "com.lk",
    "org.lk",
    "edu.lk",
    "ngo.lk",
    "soc.lk",
    "web.lk",
    "ltd.lk",
    "assn.lk",
    "grp.lk",
    "hotel.lk",
    "ac.lk",
    "lr",
    "com.lr",
    "edu.lr",
    "gov.lr",
    "org.lr",
    "net.lr",
    "ls",
    "ac.ls",
    "biz.ls",
    "co.ls",
    "edu.ls",
    "gov.ls",
    "info.ls",
    "net.ls",
    "org.ls",
    "sc.ls",
    "lt",
    "gov.lt",
    "lu",
    "lv",
    "com.lv",
    "edu.lv",
    "gov.lv",
    "org.lv",
    "mil.lv",
    "id.lv",
    "net.lv",
    "asn.lv",
    "conf.lv",
    "ly",
    "com.ly",
    "net.ly",
    "gov.ly",
    "plc.ly",
    "edu.ly",
    "sch.ly",
    "med.ly",
    "org.ly",
    "id.ly",
    "ma",
    "co.ma",
    "net.ma",
    "gov.ma",
    "org.ma",
    "ac.ma",
    "press.ma",
    "mc",
    "tm.mc",
    "asso.mc",
    "md",
    "me",
    "co.me",
    "net.me",
    "org.me",
    "edu.me",
    "ac.me",
    "gov.me",
    "its.me",
    "priv.me",
    "mg",
    "org.mg",
    "nom.mg",
    "gov.mg",
    "prd.mg",
    "tm.mg",
    "edu.mg",
    "mil.mg",
    "com.mg",
    "co.mg",
    "mh",
    "mil",
    "mk",
    "com.mk",
    "org.mk",
    "net.mk",
    "edu.mk",
    "gov.mk",
    "inf.mk",
    "name.mk",
    "ml",
    "com.ml",
    "edu.ml",
    "gouv.ml",
    "gov.ml",
    "net.ml",
    "org.ml",
    "presse.ml",
    "*.mm",
    "mn",
    "gov.mn",
    "edu.mn",
    "org.mn",
    "mo",
    "com.mo",
    "net.mo",
    "org.mo",
    "edu.mo",
    "gov.mo",
    "mobi",
    "mp",
    "mq",
    "mr",
    "gov.mr",
    "ms",
    "com.ms",
    "edu.ms",
    "gov.ms",
    "net.ms",
    "org.ms",
    "mt",
    "com.mt",
    "edu.mt",
    "net.mt",
    "org.mt",
    "mu",
    "com.mu",
    "net.mu",
    "org.mu",
    "gov.mu",
    "ac.mu",
    "co.mu",
    "or.mu",
    "museum",
    "academy.museum",
    "agriculture.museum",
    "air.museum",
    "airguard.museum",
    "alabama.museum",
    "alaska.museum",
    "amber.museum",
    "ambulance.museum",
    "american.museum",
    "americana.museum",
    "americanantiques.museum",
    "americanart.museum",
    "amsterdam.museum",
    "and.museum",
    "annefrank.museum",
    "anthro.museum",
    "anthropology.museum",
    "antiques.museum",
    "aquarium.museum",
    "arboretum.museum",
    "archaeological.museum",
    "archaeology.museum",
    "architecture.museum",
    "art.museum",
    "artanddesign.museum",
    "artcenter.museum",
    "artdeco.museum",
    "arteducation.museum",
    "artgallery.museum",
    "arts.museum",
    "artsandcrafts.museum",
    "asmatart.museum",
    "assassination.museum",
    "assisi.museum",
    "association.museum",
    "astronomy.museum",
    "atlanta.museum",
    "austin.museum",
    "australia.museum",
    "automotive.museum",
    "aviation.museum",
    "axis.museum",
    "badajoz.museum",
    "baghdad.museum",
    "bahn.museum",
    "bale.museum",
    "baltimore.museum",
    "barcelona.museum",
    "baseball.museum",
    "basel.museum",
    "baths.museum",
    "bauern.museum",
    "beauxarts.museum",
    "beeldengeluid.museum",
    "bellevue.museum",
    "bergbau.museum",
    "berkeley.museum",
    "berlin.museum",
    "bern.museum",
    "bible.museum",
    "bilbao.museum",
    "bill.museum",
    "birdart.museum",
    "birthplace.museum",
    "bonn.museum",
    "boston.museum",
    "botanical.museum",
    "botanicalgarden.museum",
    "botanicgarden.museum",
    "botany.museum",
    "brandywinevalley.museum",
    "brasil.museum",
    "bristol.museum",
    "british.museum",
    "britishcolumbia.museum",
    "broadcast.museum",
    "brunel.museum",
    "brussel.museum",
    "brussels.museum",
    "bruxelles.museum",
    "building.museum",
    "burghof.museum",
    "bus.museum",
    "bushey.museum",
    "cadaques.museum",
    "california.museum",
    "cambridge.museum",
    "can.museum",
    "canada.museum",
    "capebreton.museum",
    "carrier.museum",
    "cartoonart.museum",
    "casadelamoneda.museum",
    "castle.museum",
    "castres.museum",
    "celtic.museum",
    "center.museum",
    "chattanooga.museum",
    "cheltenham.museum",
    "chesapeakebay.museum",
    "chicago.museum",
    "children.museum",
    "childrens.museum",
    "childrensgarden.museum",
    "chiropractic.museum",
    "chocolate.museum",
    "christiansburg.museum",
    "cincinnati.museum",
    "cinema.museum",
    "circus.museum",
    "civilisation.museum",
    "civilization.museum",
    "civilwar.museum",
    "clinton.museum",
    "clock.museum",
    "coal.museum",
    "coastaldefence.museum",
    "cody.museum",
    "coldwar.museum",
    "collection.museum",
    "colonialwilliamsburg.museum",
    "coloradoplateau.museum",
    "columbia.museum",
    "columbus.museum",
    "communication.museum",
    "communications.museum",
    "community.museum",
    "computer.museum",
    "computerhistory.museum",
    "comunicações.museum",
    "contemporary.museum",
    "contemporaryart.museum",
    "convent.museum",
    "copenhagen.museum",
    "corporation.museum",
    "correios-e-telecomunicações.museum",
    "corvette.museum",
    "costume.museum",
    "countryestate.museum",
    "county.museum",
    "crafts.museum",
    "cranbrook.museum",
    "creation.museum",
    "cultural.museum",
    "culturalcenter.museum",
    "culture.museum",
    "cyber.museum",
    "cymru.museum",
    "dali.museum",
    "dallas.museum",
    "database.museum",
    "ddr.museum",
    "decorativearts.museum",
    "delaware.museum",
    "delmenhorst.museum",
    "denmark.museum",
    "depot.museum",
    "design.museum",
    "detroit.museum",
    "dinosaur.museum",
    "discovery.museum",
    "dolls.museum",
    "donostia.museum",
    "durham.museum",
    "eastafrica.museum",
    "eastcoast.museum",
    "education.museum",
    "educational.museum",
    "egyptian.museum",
    "eisenbahn.museum",
    "elburg.museum",
    "elvendrell.museum",
    "embroidery.museum",
    "encyclopedic.museum",
    "england.museum",
    "entomology.museum",
    "environment.museum",
    "environmentalconservation.museum",
    "epilepsy.museum",
    "essex.museum",
    "estate.museum",
    "ethnology.museum",
    "exeter.museum",
    "exhibition.museum",
    "family.museum",
    "farm.museum",
    "farmequipment.museum",
    "farmers.museum",
    "farmstead.museum",
    "field.museum",
    "figueres.museum",
    "filatelia.museum",
    "film.museum",
    "fineart.museum",
    "finearts.museum",
    "finland.museum",
    "flanders.museum",
    "florida.museum",
    "force.museum",
    "fortmissoula.museum",
    "fortworth.museum",
    "foundation.museum",
    "francaise.museum",
    "frankfurt.museum",
    "franziskaner.museum",
    "freemasonry.museum",
    "freiburg.museum",
    "fribourg.museum",
    "frog.museum",
    "fundacio.museum",
    "furniture.museum",
    "gallery.museum",
    "garden.museum",
    "gateway.museum",
    "geelvinck.museum",
    "gemological.museum",
    "geology.museum",
    "georgia.museum",
    "giessen.museum",
    "glas.museum",
    "glass.museum",
    "gorge.museum",
    "grandrapids.museum",
    "graz.museum",
    "guernsey.museum",
    "halloffame.museum",
    "hamburg.museum",
    "handson.museum",
    "harvestcelebration.museum",
    "hawaii.museum",
    "health.museum",
    "heimatunduhren.museum",
    "hellas.museum",
    "helsinki.museum",
    "hembygdsforbund.museum",
    "heritage.museum",
    "histoire.museum",
    "historical.museum",
    "historicalsociety.museum",
    "historichouses.museum",
    "historisch.museum",
    "historisches.museum",
    "history.museum",
    "historyofscience.museum",
    "horology.museum",
    "house.museum",
    "humanities.museum",
    "illustration.museum",
    "imageandsound.museum",
    "indian.museum",
    "indiana.museum",
    "indianapolis.museum",
    "indianmarket.museum",
    "intelligence.museum",
    "interactive.museum",
    "iraq.museum",
    "iron.museum",
    "isleofman.museum",
    "jamison.museum",
    "jefferson.museum",
    "jerusalem.museum",
    "jewelry.museum",
    "jewish.museum",
    "jewishart.museum",
    "jfk.museum",
    "journalism.museum",
    "judaica.museum",
    "judygarland.museum",
    "juedisches.museum",
    "juif.museum",
    "karate.museum",
    "karikatur.museum",
    "kids.museum",
    "koebenhavn.museum",
    "koeln.museum",
    "kunst.museum",
    "kunstsammlung.museum",
    "kunstunddesign.museum",
    "labor.museum",
    "labour.museum",
    "lajolla.museum",
    "lancashire.museum",
    "landes.museum",
    "lans.museum",
    "läns.museum",
    "larsson.museum",
    "lewismiller.museum",
    "lincoln.museum",
    "linz.museum",
    "living.museum",
    "livinghistory.museum",
    "localhistory.museum",
    "london.museum",
    "losangeles.museum",
    "louvre.museum",
    "loyalist.museum",
    "lucerne.museum",
    "luxembourg.museum",
    "luzern.museum",
    "mad.museum",
    "madrid.museum",
    "mallorca.museum",
    "manchester.museum",
    "mansion.museum",
    "mansions.museum",
    "manx.museum",
    "marburg.museum",
    "maritime.museum",
    "maritimo.museum",
    "maryland.museum",
    "marylhurst.museum",
    "media.museum",
    "medical.museum",
    "medizinhistorisches.museum",
    "meeres.museum",
    "memorial.museum",
    "mesaverde.museum",
    "michigan.museum",
    "midatlantic.museum",
    "military.museum",
    "mill.museum",
    "miners.museum",
    "mining.museum",
    "minnesota.museum",
    "missile.museum",
    "missoula.museum",
    "modern.museum",
    "moma.museum",
    "money.museum",
    "monmouth.museum",
    "monticello.museum",
    "montreal.museum",
    "moscow.museum",
    "motorcycle.museum",
    "muenchen.museum",
    "muenster.museum",
    "mulhouse.museum",
    "muncie.museum",
    "museet.museum",
    "museumcenter.museum",
    "museumvereniging.museum",
    "music.museum",
    "national.museum",
    "nationalfirearms.museum",
    "nationalheritage.museum",
    "nativeamerican.museum",
    "naturalhistory.museum",
    "naturalhistorymuseum.museum",
    "naturalsciences.museum",
    "nature.museum",
    "naturhistorisches.museum",
    "natuurwetenschappen.museum",
    "naumburg.museum",
    "naval.museum",
    "nebraska.museum",
    "neues.museum",
    "newhampshire.museum",
    "newjersey.museum",
    "newmexico.museum",
    "newport.museum",
    "newspaper.museum",
    "newyork.museum",
    "niepce.museum",
    "norfolk.museum",
    "north.museum",
    "nrw.museum",
    "nyc.museum",
    "nyny.museum",
    "oceanographic.museum",
    "oceanographique.museum",
    "omaha.museum",
    "online.museum",
    "ontario.museum",
    "openair.museum",
    "oregon.museum",
    "oregontrail.museum",
    "otago.museum",
    "oxford.museum",
    "pacific.museum",
    "paderborn.museum",
    "palace.museum",
    "paleo.museum",
    "palmsprings.museum",
    "panama.museum",
    "paris.museum",
    "pasadena.museum",
    "pharmacy.museum",
    "philadelphia.museum",
    "philadelphiaarea.museum",
    "philately.museum",
    "phoenix.museum",
    "photography.museum",
    "pilots.museum",
    "pittsburgh.museum",
    "planetarium.museum",
    "plantation.museum",
    "plants.museum",
    "plaza.museum",
    "portal.museum",
    "portland.museum",
    "portlligat.museum",
    "posts-and-telecommunications.museum",
    "preservation.museum",
    "presidio.museum",
    "press.museum",
    "project.museum",
    "public.museum",
    "pubol.museum",
    "quebec.museum",
    "railroad.museum",
    "railway.museum",
    "research.museum",
    "resistance.museum",
    "riodejaneiro.museum",
    "rochester.museum",
    "rockart.museum",
    "roma.museum",
    "russia.museum",
    "saintlouis.museum",
    "salem.museum",
    "salvadordali.museum",
    "salzburg.museum",
    "sandiego.museum",
    "sanfrancisco.museum",
    "santabarbara.museum",
    "santacruz.museum",
    "santafe.museum",
    "saskatchewan.museum",
    "satx.museum",
    "savannahga.museum",
    "schlesisches.museum",
    "schoenbrunn.museum",
    "schokoladen.museum",
    "school.museum",
    "schweiz.museum",
    "science.museum",
    "scienceandhistory.museum",
    "scienceandindustry.museum",
    "sciencecenter.museum",
    "sciencecenters.museum",
    "science-fiction.museum",
    "sciencehistory.museum",
    "sciences.museum",
    "sciencesnaturelles.museum",
    "scotland.museum",
    "seaport.museum",
    "settlement.museum",
    "settlers.museum",
    "shell.museum",
    "sherbrooke.museum",
    "sibenik.museum",
    "silk.museum",
    "ski.museum",
    "skole.museum",
    "society.museum",
    "sologne.museum",
    "soundandvision.museum",
    "southcarolina.museum",
    "southwest.museum",
    "space.museum",
    "spy.museum",
    "square.museum",
    "stadt.museum",
    "stalbans.museum",
    "starnberg.museum",
    "state.museum",
    "stateofdelaware.museum",
    "station.museum",
    "steam.museum",
    "steiermark.museum",
    "stjohn.museum",
    "stockholm.museum",
    "stpetersburg.museum",
    "stuttgart.museum",
    "suisse.museum",
    "surgeonshall.museum",
    "surrey.museum",
    "svizzera.museum",
    "sweden.museum",
    "sydney.museum",
    "tank.museum",
    "tcm.museum",
    "technology.museum",
    "telekommunikation.museum",
    "television.museum",
    "texas.museum",
    "textile.museum",
    "theater.museum",
    "time.museum",
    "timekeeping.museum",
    "topology.museum",
    "torino.museum",
    "touch.museum",
    "town.museum",
    "transport.museum",
    "tree.museum",
    "trolley.museum",
    "trust.museum",
    "trustee.museum",
    "uhren.museum",
    "ulm.museum",
    "undersea.museum",
    "university.museum",
    "usa.museum",
    "usantiques.museum",
    "usarts.museum",
    "uscountryestate.museum",
    "usculture.museum",
    "usdecorativearts.museum",
    "usgarden.museum",
    "ushistory.museum",
    "ushuaia.museum",
    "uslivinghistory.museum",
    "utah.museum",
    "uvic.museum",
    "valley.museum",
    "vantaa.museum",
    "versailles.museum",
    "viking.museum",
    "village.museum",
    "virginia.museum",
    "virtual.museum",
    "virtuel.museum",
    "vlaanderen.museum",
    "volkenkunde.museum",
    "wales.museum",
    "wallonie.museum",
    "war.museum",
    "washingtondc.museum",
    "watchandclock.museum",
    "watch-and-clock.museum",
    "western.museum",
    "westfalen.museum",
    "whaling.museum",
    "wildlife.museum",
    "williamsburg.museum",
    "windmill.museum",
    "workshop.museum",
    "york.museum",
    "yorkshire.museum",
    "yosemite.museum",
    "youth.museum",
    "zoological.museum",
    "zoology.museum",
    "ירושלים.museum",
    "иком.museum",
    "mv",
    "aero.mv",
    "biz.mv",
    "com.mv",
    "coop.mv",
    "edu.mv",
    "gov.mv",
    "info.mv",
    "int.mv",
    "mil.mv",
    "museum.mv",
    "name.mv",
    "net.mv",
    "org.mv",
    "pro.mv",
    "mw",
    "ac.mw",
    "biz.mw",
    "co.mw",
    "com.mw",
    "coop.mw",
    "edu.mw",
    "gov.mw",
    "int.mw",
    "museum.mw",
    "net.mw",
    "org.mw",
    "mx",
    "com.mx",
    "org.mx",
    "gob.mx",
    "edu.mx",
    "net.mx",
    "my",
    "biz.my",
    "com.my",
    "edu.my",
    "gov.my",
    "mil.my",
    "name.my",
    "net.my",
    "org.my",
    "mz",
    "ac.mz",
    "adv.mz",
    "co.mz",
    "edu.mz",
    "gov.mz",
    "mil.mz",
    "net.mz",
    "org.mz",
    "na",
    "info.na",
    "pro.na",
    "name.na",
    "school.na",
    "or.na",
    "dr.na",
    "us.na",
    "mx.na",
    "ca.na",
    "in.na",
    "cc.na",
    "tv.na",
    "ws.na",
    "mobi.na",
    "co.na",
    "com.na",
    "org.na",
    "name",
    "nc",
    "asso.nc",
    "nom.nc",
    "ne",
    "net",
    "nf",
    "com.nf",
    "net.nf",
    "per.nf",
    "rec.nf",
    "web.nf",
    "arts.nf",
    "firm.nf",
    "info.nf",
    "other.nf",
    "store.nf",
    "ng",
    "com.ng",
    "edu.ng",
    "gov.ng",
    "i.ng",
    "mil.ng",
    "mobi.ng",
    "name.ng",
    "net.ng",
    "org.ng",
    "sch.ng",
    "ni",
    "ac.ni",
    "biz.ni",
    "co.ni",
    "com.ni",
    "edu.ni",
    "gob.ni",
    "in.ni",
    "info.ni",
    "int.ni",
    "mil.ni",
    "net.ni",
    "nom.ni",
    "org.ni",
    "web.ni",
    "nl",
    "no",
    "fhs.no",
    "vgs.no",
    "fylkesbibl.no",
    "folkebibl.no",
    "museum.no",
    "idrett.no",
    "priv.no",
    "mil.no",
    "stat.no",
    "dep.no",
    "kommune.no",
    "herad.no",
    "aa.no",
    "ah.no",
    "bu.no",
    "fm.no",
    "hl.no",
    "hm.no",
    "jan-mayen.no",
    "mr.no",
    "nl.no",
    "nt.no",
    "of.no",
    "ol.no",
    "oslo.no",
    "rl.no",
    "sf.no",
    "st.no",
    "svalbard.no",
    "tm.no",
    "tr.no",
    "va.no",
    "vf.no",
    "gs.aa.no",
    "gs.ah.no",
    "gs.bu.no",
    "gs.fm.no",
    "gs.hl.no",
    "gs.hm.no",
    "gs.jan-mayen.no",
    "gs.mr.no",
    "gs.nl.no",
    "gs.nt.no",
    "gs.of.no",
    "gs.ol.no",
    "gs.oslo.no",
    "gs.rl.no",
    "gs.sf.no",
    "gs.st.no",
    "gs.svalbard.no",
    "gs.tm.no",
    "gs.tr.no",
    "gs.va.no",
    "gs.vf.no",
    "akrehamn.no",
    "åkrehamn.no",
    "algard.no",
    "ålgård.no",
    "arna.no",
    "brumunddal.no",
    "bryne.no",
    "bronnoysund.no",
    "brønnøysund.no",
    "drobak.no",
    "drøbak.no",
    "egersund.no",
    "fetsund.no",
    "floro.no",
    "florø.no",
    "fredrikstad.no",
    "hokksund.no",
    "honefoss.no",
    "hønefoss.no",
    "jessheim.no",
    "jorpeland.no",
    "jørpeland.no",
    "kirkenes.no",
    "kopervik.no",
    "krokstadelva.no",
    "langevag.no",
    "langevåg.no",
    "leirvik.no",
    "mjondalen.no",
    "mjøndalen.no",
    "mo-i-rana.no",
    "mosjoen.no",
    "mosjøen.no",
    "nesoddtangen.no",
    "orkanger.no",
    "osoyro.no",
    "osøyro.no",
    "raholt.no",
    "råholt.no",
    "sandnessjoen.no",
    "sandnessjøen.no",
    "skedsmokorset.no",
    "slattum.no",
    "spjelkavik.no",
    "stathelle.no",
    "stavern.no",
    "stjordalshalsen.no",
    "stjørdalshalsen.no",
    "tananger.no",
    "tranby.no",
    "vossevangen.no",
    "afjord.no",
    "åfjord.no",
    "agdenes.no",
    "al.no",
    "ål.no",
    "alesund.no",
    "ålesund.no",
    "alstahaug.no",
    "alta.no",
    "áltá.no",
    "alaheadju.no",
    "álaheadju.no",
    "alvdal.no",
    "amli.no",
    "åmli.no",
    "amot.no",
    "åmot.no",
    "andebu.no",
    "andoy.no",
    "andøy.no",
    "andasuolo.no",
    "ardal.no",
    "årdal.no",
    "aremark.no",
    "arendal.no",
    "ås.no",
    "aseral.no",
    "åseral.no",
    "asker.no",
    "askim.no",
    "askvoll.no",
    "askoy.no",
    "askøy.no",
    "asnes.no",
    "åsnes.no",
    "audnedaln.no",
    "aukra.no",
    "aure.no",
    "aurland.no",
    "aurskog-holand.no",
    "aurskog-høland.no",
    "austevoll.no",
    "austrheim.no",
    "averoy.no",
    "averøy.no",
    "balestrand.no",
    "ballangen.no",
    "balat.no",
    "bálát.no",
    "balsfjord.no",
    "bahccavuotna.no",
    "báhccavuotna.no",
    "bamble.no",
    "bardu.no",
    "beardu.no",
    "beiarn.no",
    "bajddar.no",
    "bájddar.no",
    "baidar.no",
    "báidár.no",
    "berg.no",
    "bergen.no",
    "berlevag.no",
    "berlevåg.no",
    "bearalvahki.no",
    "bearalváhki.no",
    "bindal.no",
    "birkenes.no",
    "bjarkoy.no",
    "bjarkøy.no",
    "bjerkreim.no",
    "bjugn.no",
    "bodo.no",
    "bodø.no",
    "badaddja.no",
    "bådåddjå.no",
    "budejju.no",
    "bokn.no",
    "bremanger.no",
    "bronnoy.no",
    "brønnøy.no",
    "bygland.no",
    "bykle.no",
    "barum.no",
    "bærum.no",
    "bo.telemark.no",
    "bø.telemark.no",
    "bo.nordland.no",
    "bø.nordland.no",
    "bievat.no",
    "bievát.no",
    "bomlo.no",
    "bømlo.no",
    "batsfjord.no",
    "båtsfjord.no",
    "bahcavuotna.no",
    "báhcavuotna.no",
    "dovre.no",
    "drammen.no",
    "drangedal.no",
    "dyroy.no",
    "dyrøy.no",
    "donna.no",
    "dønna.no",
    "eid.no",
    "eidfjord.no",
    "eidsberg.no",
    "eidskog.no",
    "eidsvoll.no",
    "eigersund.no",
    "elverum.no",
    "enebakk.no",
    "engerdal.no",
    "etne.no",
    "etnedal.no",
    "evenes.no",
    "evenassi.no",
    "evenášši.no",
    "evje-og-hornnes.no",
    "farsund.no",
    "fauske.no",
    "fuossko.no",
    "fuoisku.no",
    "fedje.no",
    "fet.no",
    "finnoy.no",
    "finnøy.no",
    "fitjar.no",
    "fjaler.no",
    "fjell.no",
    "flakstad.no",
    "flatanger.no",
    "flekkefjord.no",
    "flesberg.no",
    "flora.no",
    "fla.no",
    "flå.no",
    "folldal.no",
    "forsand.no",
    "fosnes.no",
    "frei.no",
    "frogn.no",
    "froland.no",
    "frosta.no",
    "frana.no",
    "fræna.no",
    "froya.no",
    "frøya.no",
    "fusa.no",
    "fyresdal.no",
    "forde.no",
    "førde.no",
    "gamvik.no",
    "gangaviika.no",
    "gáŋgaviika.no",
    "gaular.no",
    "gausdal.no",
    "gildeskal.no",
    "gildeskål.no",
    "giske.no",
    "gjemnes.no",
    "gjerdrum.no",
    "gjerstad.no",
    "gjesdal.no",
    "gjovik.no",
    "gjøvik.no",
    "gloppen.no",
    "gol.no",
    "gran.no",
    "grane.no",
    "granvin.no",
    "gratangen.no",
    "grimstad.no",
    "grong.no",
    "kraanghke.no",
    "kråanghke.no",
    "grue.no",
    "gulen.no",
    "hadsel.no",
    "halden.no",
    "halsa.no",
    "hamar.no",
    "hamaroy.no",
    "habmer.no",
    "hábmer.no",
    "hapmir.no",
    "hápmir.no",
    "hammerfest.no",
    "hammarfeasta.no",
    "hámmárfeasta.no",
    "haram.no",
    "hareid.no",
    "harstad.no",
    "hasvik.no",
    "aknoluokta.no",
    "ákŋoluokta.no",
    "hattfjelldal.no",
    "aarborte.no",
    "haugesund.no",
    "hemne.no",
    "hemnes.no",
    "hemsedal.no",
    "heroy.more-og-romsdal.no",
    "herøy.møre-og-romsdal.no",
    "heroy.nordland.no",
    "herøy.nordland.no",
    "hitra.no",
    "hjartdal.no",
    "hjelmeland.no",
    "hobol.no",
    "hobøl.no",
    "hof.no",
    "hol.no",
    "hole.no",
    "holmestrand.no",
    "holtalen.no",
    "holtålen.no",
    "hornindal.no",
    "horten.no",
    "hurdal.no",
    "hurum.no",
    "hvaler.no",
    "hyllestad.no",
    "hagebostad.no",
    "hægebostad.no",
    "hoyanger.no",
    "høyanger.no",
    "hoylandet.no",
    "høylandet.no",
    "ha.no",
    "hå.no",
    "ibestad.no",
    "inderoy.no",
    "inderøy.no",
    "iveland.no",
    "jevnaker.no",
    "jondal.no",
    "jolster.no",
    "jølster.no",
    "karasjok.no",
    "karasjohka.no",
    "kárášjohka.no",
    "karlsoy.no",
    "galsa.no",
    "gálsá.no",
    "karmoy.no",
    "karmøy.no",
    "kautokeino.no",
    "guovdageaidnu.no",
    "klepp.no",
    "klabu.no",
    "klæbu.no",
    "kongsberg.no",
    "kongsvinger.no",
    "kragero.no",
    "kragerø.no",
    "kristiansand.no",
    "kristiansund.no",
    "krodsherad.no",
    "krødsherad.no",
    "kvalsund.no",
    "rahkkeravju.no",
    "ráhkkerávju.no",
    "kvam.no",
    "kvinesdal.no",
    "kvinnherad.no",
    "kviteseid.no",
    "kvitsoy.no",
    "kvitsøy.no",
    "kvafjord.no",
    "kvæfjord.no",
    "giehtavuoatna.no",
    "kvanangen.no",
    "kvænangen.no",
    "navuotna.no",
    "návuotna.no",
    "kafjord.no",
    "kåfjord.no",
    "gaivuotna.no",
    "gáivuotna.no",
    "larvik.no",
    "lavangen.no",
    "lavagis.no",
    "loabat.no",
    "loabát.no",
    "lebesby.no",
    "davvesiida.no",
    "leikanger.no",
    "leirfjord.no",
    "leka.no",
    "leksvik.no",
    "lenvik.no",
    "leangaviika.no",
    "leaŋgaviika.no",
    "lesja.no",
    "levanger.no",
    "lier.no",
    "lierne.no",
    "lillehammer.no",
    "lillesand.no",
    "lindesnes.no",
    "lindas.no",
    "lindås.no",
    "lom.no",
    "loppa.no",
    "lahppi.no",
    "láhppi.no",
    "lund.no",
    "lunner.no",
    "luroy.no",
    "lurøy.no",
    "luster.no",
    "lyngdal.no",
    "lyngen.no",
    "ivgu.no",
    "lardal.no",
    "lerdal.no",
    "lærdal.no",
    "lodingen.no",
    "lødingen.no",
    "lorenskog.no",
    "lørenskog.no",
    "loten.no",
    "løten.no",
    "malvik.no",
    "masoy.no",
    "måsøy.no",
    "muosat.no",
    "muosát.no",
    "mandal.no",
    "marker.no",
    "marnardal.no",
    "masfjorden.no",
    "meland.no",
    "meldal.no",
    "melhus.no",
    "meloy.no",
    "meløy.no",
    "meraker.no",
    "meråker.no",
    "moareke.no",
    "moåreke.no",
    "midsund.no",
    "midtre-gauldal.no",
    "modalen.no",
    "modum.no",
    "molde.no",
    "moskenes.no",
    "moss.no",
    "mosvik.no",
    "malselv.no",
    "målselv.no",
    "malatvuopmi.no",
    "málatvuopmi.no",
    "namdalseid.no",
    "aejrie.no",
    "namsos.no",
    "namsskogan.no",
    "naamesjevuemie.no",
    "nååmesjevuemie.no",
    "laakesvuemie.no",
    "nannestad.no",
    "narvik.no",
    "narviika.no",
    "naustdal.no",
    "nedre-eiker.no",
    "nes.akershus.no",
    "nes.buskerud.no",
    "nesna.no",
    "nesodden.no",
    "nesseby.no",
    "unjarga.no",
    "unjárga.no",
    "nesset.no",
    "nissedal.no",
    "nittedal.no",
    "nord-aurdal.no",
    "nord-fron.no",
    "nord-odal.no",
    "norddal.no",
    "nordkapp.no",
    "davvenjarga.no",
    "davvenjárga.no",
    "nordre-land.no",
    "nordreisa.no",
    "raisa.no",
    "ráisa.no",
    "nore-og-uvdal.no",
    "notodden.no",
    "naroy.no",
    "nærøy.no",
    "notteroy.no",
    "nøtterøy.no",
    "odda.no",
    "oksnes.no",
    "øksnes.no",
    "oppdal.no",
    "oppegard.no",
    "oppegård.no",
    "orkdal.no",
    "orland.no",
    "ørland.no",
    "orskog.no",
    "ørskog.no",
    "orsta.no",
    "ørsta.no",
    "os.hedmark.no",
    "os.hordaland.no",
    "osen.no",
    "osteroy.no",
    "osterøy.no",
    "ostre-toten.no",
    "østre-toten.no",
    "overhalla.no",
    "ovre-eiker.no",
    "øvre-eiker.no",
    "oyer.no",
    "øyer.no",
    "oygarden.no",
    "øygarden.no",
    "oystre-slidre.no",
    "øystre-slidre.no",
    "porsanger.no",
    "porsangu.no",
    "porsáŋgu.no",
    "porsgrunn.no",
    "radoy.no",
    "radøy.no",
    "rakkestad.no",
    "rana.no",
    "ruovat.no",
    "randaberg.no",
    "rauma.no",
    "rendalen.no",
    "rennebu.no",
    "rennesoy.no",
    "rennesøy.no",
    "rindal.no",
    "ringebu.no",
    "ringerike.no",
    "ringsaker.no",
    "rissa.no",
    "risor.no",
    "risør.no",
    "roan.no",
    "rollag.no",
    "rygge.no",
    "ralingen.no",
    "rælingen.no",
    "rodoy.no",
    "rødøy.no",
    "romskog.no",
    "rømskog.no",
    "roros.no",
    "røros.no",
    "rost.no",
    "røst.no",
    "royken.no",
    "røyken.no",
    "royrvik.no",
    "røyrvik.no",
    "rade.no",
    "råde.no",
    "salangen.no",
    "siellak.no",
    "saltdal.no",
    "salat.no",
    "sálát.no",
    "sálat.no",
    "samnanger.no",
    "sande.more-og-romsdal.no",
    "sande.møre-og-romsdal.no",
    "sande.vestfold.no",
    "sandefjord.no",
    "sandnes.no",
    "sandoy.no",
    "sandøy.no",
    "sarpsborg.no",
    "sauda.no",
    "sauherad.no",
    "sel.no",
    "selbu.no",
    "selje.no",
    "seljord.no",
    "sigdal.no",
    "siljan.no",
    "sirdal.no",
    "skaun.no",
    "skedsmo.no",
    "ski.no",
    "skien.no",
    "skiptvet.no",
    "skjervoy.no",
    "skjervøy.no",
    "skierva.no",
    "skiervá.no",
    "skjak.no",
    "skjåk.no",
    "skodje.no",
    "skanland.no",
    "skånland.no",
    "skanit.no",
    "skánit.no",
    "smola.no",
    "smøla.no",
    "snillfjord.no",
    "snasa.no",
    "snåsa.no",
    "snoasa.no",
    "snaase.no",
    "snåase.no",
    "sogndal.no",
    "sokndal.no",
    "sola.no",
    "solund.no",
    "songdalen.no",
    "sortland.no",
    "spydeberg.no",
    "stange.no",
    "stavanger.no",
    "steigen.no",
    "steinkjer.no",
    "stjordal.no",
    "stjørdal.no",
    "stokke.no",
    "stor-elvdal.no",
    "stord.no",
    "stordal.no",
    "storfjord.no",
    "omasvuotna.no",
    "strand.no",
    "stranda.no",
    "stryn.no",
    "sula.no",
    "suldal.no",
    "sund.no",
    "sunndal.no",
    "surnadal.no",
    "sveio.no",
    "svelvik.no",
    "sykkylven.no",
    "sogne.no",
    "søgne.no",
    "somna.no",
    "sømna.no",
    "sondre-land.no",
    "søndre-land.no",
    "sor-aurdal.no",
    "sør-aurdal.no",
    "sor-fron.no",
    "sør-fron.no",
    "sor-odal.no",
    "sør-odal.no",
    "sor-varanger.no",
    "sør-varanger.no",
    "matta-varjjat.no",
    "mátta-várjjat.no",
    "sorfold.no",
    "sørfold.no",
    "sorreisa.no",
    "sørreisa.no",
    "sorum.no",
    "sørum.no",
    "tana.no",
    "deatnu.no",
    "time.no",
    "tingvoll.no",
    "tinn.no",
    "tjeldsund.no",
    "dielddanuorri.no",
    "tjome.no",
    "tjøme.no",
    "tokke.no",
    "tolga.no",
    "torsken.no",
    "tranoy.no",
    "tranøy.no",
    "tromso.no",
    "tromsø.no",
    "tromsa.no",
    "romsa.no",
    "trondheim.no",
    "troandin.no",
    "trysil.no",
    "trana.no",
    "træna.no",
    "trogstad.no",
    "trøgstad.no",
    "tvedestrand.no",
    "tydal.no",
    "tynset.no",
    "tysfjord.no",
    "divtasvuodna.no",
    "divttasvuotna.no",
    "tysnes.no",
    "tysvar.no",
    "tysvær.no",
    "tonsberg.no",
    "tønsberg.no",
    "ullensaker.no",
    "ullensvang.no",
    "ulvik.no",
    "utsira.no",
    "vadso.no",
    "vadsø.no",
    "cahcesuolo.no",
    "čáhcesuolo.no",
    "vaksdal.no",
    "valle.no",
    "vang.no",
    "vanylven.no",
    "vardo.no",
    "vardø.no",
    "varggat.no",
    "várggát.no",
    "vefsn.no",
    "vaapste.no",
    "vega.no",
    "vegarshei.no",
    "vegårshei.no",
    "vennesla.no",
    "verdal.no",
    "verran.no",
    "vestby.no",
    "vestnes.no",
    "vestre-slidre.no",
    "vestre-toten.no",
    "vestvagoy.no",
    "vestvågøy.no",
    "vevelstad.no",
    "vik.no",
    "vikna.no",
    "vindafjord.no",
    "volda.no",
    "voss.no",
    "varoy.no",
    "værøy.no",
    "vagan.no",
    "vågan.no",
    "voagat.no",
    "vagsoy.no",
    "vågsøy.no",
    "vaga.no",
    "vågå.no",
    "valer.ostfold.no",
    "våler.østfold.no",
    "valer.hedmark.no",
    "våler.hedmark.no",
    "*.np",
    "nr",
    "biz.nr",
    "info.nr",
    "gov.nr",
    "edu.nr",
    "org.nr",
    "net.nr",
    "com.nr",
    "nu",
    "nz",
    "ac.nz",
    "co.nz",
    "cri.nz",
    "geek.nz",
    "gen.nz",
    "govt.nz",
    "health.nz",
    "iwi.nz",
    "kiwi.nz",
    "maori.nz",
    "mil.nz",
    "māori.nz",
    "net.nz",
    "org.nz",
    "parliament.nz",
    "school.nz",
    "om",
    "co.om",
    "com.om",
    "edu.om",
    "gov.om",
    "med.om",
    "museum.om",
    "net.om",
    "org.om",
    "pro.om",
    "onion",
    "org",
    "pa",
    "ac.pa",
    "gob.pa",
    "com.pa",
    "org.pa",
    "sld.pa",
    "edu.pa",
    "net.pa",
    "ing.pa",
    "abo.pa",
    "med.pa",
    "nom.pa",
    "pe",
    "edu.pe",
    "gob.pe",
    "nom.pe",
    "mil.pe",
    "org.pe",
    "com.pe",
    "net.pe",
    "pf",
    "com.pf",
    "org.pf",
    "edu.pf",
    "*.pg",
    "ph",
    "com.ph",
    "net.ph",
    "org.ph",
    "gov.ph",
    "edu.ph",
    "ngo.ph",
    "mil.ph",
    "i.ph",
    "pk",
    "com.pk",
    "net.pk",
    "edu.pk",
    "org.pk",
    "fam.pk",
    "biz.pk",
    "web.pk",
    "gov.pk",
    "gob.pk",
    "gok.pk",
    "gon.pk",
    "gop.pk",
    "gos.pk",
    "info.pk",
    "pl",
    "com.pl",
    "net.pl",
    "org.pl",
    "aid.pl",
    "agro.pl",
    "atm.pl",
    "auto.pl",
    "biz.pl",
    "edu.pl",
    "gmina.pl",
    "gsm.pl",
    "info.pl",
    "mail.pl",
    "miasta.pl",
    "media.pl",
    "mil.pl",
    "nieruchomosci.pl",
    "nom.pl",
    "pc.pl",
    "powiat.pl",
    "priv.pl",
    "realestate.pl",
    "rel.pl",
    "sex.pl",
    "shop.pl",
    "sklep.pl",
    "sos.pl",
    "szkola.pl",
    "targi.pl",
    "tm.pl",
    "tourism.pl",
    "travel.pl",
    "turystyka.pl",
    "gov.pl",
    "ap.gov.pl",
    "ic.gov.pl",
    "is.gov.pl",
    "us.gov.pl",
    "kmpsp.gov.pl",
    "kppsp.gov.pl",
    "kwpsp.gov.pl",
    "psp.gov.pl",
    "wskr.gov.pl",
    "kwp.gov.pl",
    "mw.gov.pl",
    "ug.gov.pl",
    "um.gov.pl",
    "umig.gov.pl",
    "ugim.gov.pl",
    "upow.gov.pl",
    "uw.gov.pl",
    "starostwo.gov.pl",
    "pa.gov.pl",
    "po.gov.pl",
    "psse.gov.pl",
    "pup.gov.pl",
    "rzgw.gov.pl",
    "sa.gov.pl",
    "so.gov.pl",
    "sr.gov.pl",
    "wsa.gov.pl",
    "sko.gov.pl",
    "uzs.gov.pl",
    "wiih.gov.pl",
    "winb.gov.pl",
    "pinb.gov.pl",
    "wios.gov.pl",
    "witd.gov.pl",
    "wzmiuw.gov.pl",
    "piw.gov.pl",
    "wiw.gov.pl",
    "griw.gov.pl",
    "wif.gov.pl",
    "oum.gov.pl",
    "sdn.gov.pl",
    "zp.gov.pl",
    "uppo.gov.pl",
    "mup.gov.pl",
    "wuoz.gov.pl",
    "konsulat.gov.pl",
    "oirm.gov.pl",
    "augustow.pl",
    "babia-gora.pl",
    "bedzin.pl",
    "beskidy.pl",
    "bialowieza.pl",
    "bialystok.pl",
    "bielawa.pl",
    "bieszczady.pl",
    "boleslawiec.pl",
    "bydgoszcz.pl",
    "bytom.pl",
    "cieszyn.pl",
    "czeladz.pl",
    "czest.pl",
    "dlugoleka.pl",
    "elblag.pl",
    "elk.pl",
    "glogow.pl",
    "gniezno.pl",
    "gorlice.pl",
    "grajewo.pl",
    "ilawa.pl",
    "jaworzno.pl",
    "jelenia-gora.pl",
    "jgora.pl",
    "kalisz.pl",
    "kazimierz-dolny.pl",
    "karpacz.pl",
    "kartuzy.pl",
    "kaszuby.pl",
    "katowice.pl",
    "kepno.pl",
    "ketrzyn.pl",
    "klodzko.pl",
    "kobierzyce.pl",
    "kolobrzeg.pl",
    "konin.pl",
    "konskowola.pl",
    "kutno.pl",
    "lapy.pl",
    "lebork.pl",
    "legnica.pl",
    "lezajsk.pl",
    "limanowa.pl",
    "lomza.pl",
    "lowicz.pl",
    "lubin.pl",
    "lukow.pl",
    "malbork.pl",
    "malopolska.pl",
    "mazowsze.pl",
    "mazury.pl",
    "mielec.pl",
    "mielno.pl",
    "mragowo.pl",
    "naklo.pl",
    "nowaruda.pl",
    "nysa.pl",
    "olawa.pl",
    "olecko.pl",
    "olkusz.pl",
    "olsztyn.pl",
    "opoczno.pl",
    "opole.pl",
    "ostroda.pl",
    "ostroleka.pl",
    "ostrowiec.pl",
    "ostrowwlkp.pl",
    "pila.pl",
    "pisz.pl",
    "podhale.pl",
    "podlasie.pl",
    "polkowice.pl",
    "pomorze.pl",
    "pomorskie.pl",
    "prochowice.pl",
    "pruszkow.pl",
    "przeworsk.pl",
    "pulawy.pl",
    "radom.pl",
    "rawa-maz.pl",
    "rybnik.pl",
    "rzeszow.pl",
    "sanok.pl",
    "sejny.pl",
    "slask.pl",
    "slupsk.pl",
    "sosnowiec.pl",
    "stalowa-wola.pl",
    "skoczow.pl",
    "starachowice.pl",
    "stargard.pl",
    "suwalki.pl",
    "swidnica.pl",
    "swiebodzin.pl",
    "swinoujscie.pl",
    "szczecin.pl",
    "szczytno.pl",
    "tarnobrzeg.pl",
    "tgory.pl",
    "turek.pl",
    "tychy.pl",
    "ustka.pl",
    "walbrzych.pl",
    "warmia.pl",
    "warszawa.pl",
    "waw.pl",
    "wegrow.pl",
    "wielun.pl",
    "wlocl.pl",
    "wloclawek.pl",
    "wodzislaw.pl",
    "wolomin.pl",
    "wroclaw.pl",
    "zachpomor.pl",
    "zagan.pl",
    "zarow.pl",
    "zgora.pl",
    "zgorzelec.pl",
    "pm",
    "pn",
    "gov.pn",
    "co.pn",
    "org.pn",
    "edu.pn",
    "net.pn",
    "post",
    "pr",
    "com.pr",
    "net.pr",
    "org.pr",
    "gov.pr",
    "edu.pr",
    "isla.pr",
    "pro.pr",
    "biz.pr",
    "info.pr",
    "name.pr",
    "est.pr",
    "prof.pr",
    "ac.pr",
    "pro",
    "aaa.pro",
    "aca.pro",
    "acct.pro",
    "avocat.pro",
    "bar.pro",
    "cpa.pro",
    "eng.pro",
    "jur.pro",
    "law.pro",
    "med.pro",
    "recht.pro",
    "ps",
    "edu.ps",
    "gov.ps",
    "sec.ps",
    "plo.ps",
    "com.ps",
    "org.ps",
    "net.ps",
    "pt",
    "net.pt",
    "gov.pt",
    "org.pt",
    "edu.pt",
    "int.pt",
    "publ.pt",
    "com.pt",
    "nome.pt",
    "pw",
    "co.pw",
    "ne.pw",
    "or.pw",
    "ed.pw",
    "go.pw",
    "belau.pw",
    "py",
    "com.py",
    "coop.py",
    "edu.py",
    "gov.py",
    "mil.py",
    "net.py",
    "org.py",
    "qa",
    "com.qa",
    "edu.qa",
    "gov.qa",
    "mil.qa",
    "name.qa",
    "net.qa",
    "org.qa",
    "sch.qa",
    "re",
    "asso.re",
    "com.re",
    "nom.re",
    "ro",
    "arts.ro",
    "com.ro",
    "firm.ro",
    "info.ro",
    "nom.ro",
    "nt.ro",
    "org.ro",
    "rec.ro",
    "store.ro",
    "tm.ro",
    "www.ro",
    "rs",
    "ac.rs",
    "co.rs",
    "edu.rs",
    "gov.rs",
    "in.rs",
    "org.rs",
    "ru",
    "rw",
    "ac.rw",
    "co.rw",
    "coop.rw",
    "gov.rw",
    "mil.rw",
    "net.rw",
    "org.rw",
    "sa",
    "com.sa",
    "net.sa",
    "org.sa",
    "gov.sa",
    "med.sa",
    "pub.sa",
    "edu.sa",
    "sch.sa",
    "sb",
    "com.sb",
    "edu.sb",
    "gov.sb",
    "net.sb",
    "org.sb",
    "sc",
    "com.sc",
    "gov.sc",
    "net.sc",
    "org.sc",
    "edu.sc",
    "sd",
    "com.sd",
    "net.sd",
    "org.sd",
    "edu.sd",
    "med.sd",
    "tv.sd",
    "gov.sd",
    "info.sd",
    "se",
    "a.se",
    "ac.se",
    "b.se",
    "bd.se",
    "brand.se",
    "c.se",
    "d.se",
    "e.se",
    "f.se",
    "fh.se",
    "fhsk.se",
    "fhv.se",
    "g.se",
    "h.se",
    "i.se",
    "k.se",
    "komforb.se",
    "kommunalforbund.se",
    "komvux.se",
    "l.se",
    "lanbib.se",
    "m.se",
    "n.se",
    "naturbruksgymn.se",
    "o.se",
    "org.se",
    "p.se",
    "parti.se",
    "pp.se",
    "press.se",
    "r.se",
    "s.se",
    "t.se",
    "tm.se",
    "u.se",
    "w.se",
    "x.se",
    "y.se",
    "z.se",
    "sg",
    "com.sg",
    "net.sg",
    "org.sg",
    "gov.sg",
    "edu.sg",
    "per.sg",
    "sh",
    "com.sh",
    "net.sh",
    "gov.sh",
    "org.sh",
    "mil.sh",
    "si",
    "sj",
    "sk",
    "sl",
    "com.sl",
    "net.sl",
    "edu.sl",
    "gov.sl",
    "org.sl",
    "sm",
    "sn",
    "art.sn",
    "com.sn",
    "edu.sn",
    "gouv.sn",
    "org.sn",
    "perso.sn",
    "univ.sn",
    "so",
    "com.so",
    "edu.so",
    "gov.so",
    "me.so",
    "net.so",
    "org.so",
    "sr",
    "ss",
    "biz.ss",
    "com.ss",
    "edu.ss",
    "gov.ss",
    "me.ss",
    "net.ss",
    "org.ss",
    "sch.ss",
    "st",
    "co.st",
    "com.st",
    "consulado.st",
    "edu.st",
    "embaixada.st",
    "mil.st",
    "net.st",
    "org.st",
    "principe.st",
    "saotome.st",
    "store.st",
    "su",
    "sv",
    "com.sv",
    "edu.sv",
    "gob.sv",
    "org.sv",
    "red.sv",
    "sx",
    "gov.sx",
    "sy",
    "edu.sy",
    "gov.sy",
    "net.sy",
    "mil.sy",
    "com.sy",
    "org.sy",
    "sz",
    "co.sz",
    "ac.sz",
    "org.sz",
    "tc",
    "td",
    "tel",
    "tf",
    "tg",
    "th",
    "ac.th",
    "co.th",
    "go.th",
    "in.th",
    "mi.th",
    "net.th",
    "or.th",
    "tj",
    "ac.tj",
    "biz.tj",
    "co.tj",
    "com.tj",
    "edu.tj",
    "go.tj",
    "gov.tj",
    "int.tj",
    "mil.tj",
    "name.tj",
    "net.tj",
    "nic.tj",
    "org.tj",
    "test.tj",
    "web.tj",
    "tk",
    "tl",
    "gov.tl",
    "tm",
    "com.tm",
    "co.tm",
    "org.tm",
    "net.tm",
    "nom.tm",
    "gov.tm",
    "mil.tm",
    "edu.tm",
    "tn",
    "com.tn",
    "ens.tn",
    "fin.tn",
    "gov.tn",
    "ind.tn",
    "info.tn",
    "intl.tn",
    "mincom.tn",
    "nat.tn",
    "net.tn",
    "org.tn",
    "perso.tn",
    "tourism.tn",
    "to",
    "com.to",
    "gov.to",
    "net.to",
    "org.to",
    "edu.to",
    "mil.to",
    "tr",
    "av.tr",
    "bbs.tr",
    "bel.tr",
    "biz.tr",
    "com.tr",
    "dr.tr",
    "edu.tr",
    "gen.tr",
    "gov.tr",
    "info.tr",
    "mil.tr",
    "k12.tr",
    "kep.tr",
    "name.tr",
    "net.tr",
    "org.tr",
    "pol.tr",
    "tel.tr",
    "tsk.tr",
    "tv.tr",
    "web.tr",
    "nc.tr",
    "gov.nc.tr",
    "tt",
    "co.tt",
    "com.tt",
    "org.tt",
    "net.tt",
    "biz.tt",
    "info.tt",
    "pro.tt",
    "int.tt",
    "coop.tt",
    "jobs.tt",
    "mobi.tt",
    "travel.tt",
    "museum.tt",
    "aero.tt",
    "name.tt",
    "gov.tt",
    "edu.tt",
    "tv",
    "tw",
    "edu.tw",
    "gov.tw",
    "mil.tw",
    "com.tw",
    "net.tw",
    "org.tw",
    "idv.tw",
    "game.tw",
    "ebiz.tw",
    "club.tw",
    "網路.tw",
    "組織.tw",
    "商業.tw",
    "tz",
    "ac.tz",
    "co.tz",
    "go.tz",
    "hotel.tz",
    "info.tz",
    "me.tz",
    "mil.tz",
    "mobi.tz",
    "ne.tz",
    "or.tz",
    "sc.tz",
    "tv.tz",
    "ua",
    "com.ua",
    "edu.ua",
    "gov.ua",
    "in.ua",
    "net.ua",
    "org.ua",
    "cherkassy.ua",
    "cherkasy.ua",
    "chernigov.ua",
    "chernihiv.ua",
    "chernivtsi.ua",
    "chernovtsy.ua",
    "ck.ua",
    "cn.ua",
    "cr.ua",
    "crimea.ua",
    "cv.ua",
    "dn.ua",
    "dnepropetrovsk.ua",
    "dnipropetrovsk.ua",
    "donetsk.ua",
    "dp.ua",
    "if.ua",
    "ivano-frankivsk.ua",
    "kh.ua",
    "kharkiv.ua",
    "kharkov.ua",
    "kherson.ua",
    "khmelnitskiy.ua",
    "khmelnytskyi.ua",
    "kiev.ua",
    "kirovograd.ua",
    "km.ua",
    "kr.ua",
    "krym.ua",
    "ks.ua",
    "kv.ua",
    "kyiv.ua",
    "lg.ua",
    "lt.ua",
    "lugansk.ua",
    "lutsk.ua",
    "lv.ua",
    "lviv.ua",
    "mk.ua",
    "mykolaiv.ua",
    "nikolaev.ua",
    "od.ua",
    "odesa.ua",
    "odessa.ua",
    "pl.ua",
    "poltava.ua",
    "rivne.ua",
    "rovno.ua",
    "rv.ua",
    "sb.ua",
    "sebastopol.ua",
    "sevastopol.ua",
    "sm.ua",
    "sumy.ua",
    "te.ua",
    "ternopil.ua",
    "uz.ua",
    "uzhgorod.ua",
    "vinnica.ua",
    "vinnytsia.ua",
    "vn.ua",
    "volyn.ua",
    "yalta.ua",
    "zaporizhzhe.ua",
    "zaporizhzhia.ua",
    "zhitomir.ua",
    "zhytomyr.ua",
    "zp.ua",
    "zt.ua",
    "ug",
    "co.ug",
    "or.ug",
    "ac.ug",
    "sc.ug",
    "go.ug",
    "ne.ug",
    "com.ug",
    "org.ug",
    "uk",
    "ac.uk",
    "co.uk",
    "gov.uk",
    "ltd.uk",
    "me.uk",
    "net.uk",
    "nhs.uk",
    "org.uk",
    "plc.uk",
    "police.uk",
    "*.sch.uk",
    "us",
    "dni.us",
    "fed.us",
    "isa.us",
    "kids.us",
    "nsn.us",
    "ak.us",
    "al.us",
    "ar.us",
    "as.us",
    "az.us",
    "ca.us",
    "co.us",
    "ct.us",
    "dc.us",
    "de.us",
    "fl.us",
    "ga.us",
    "gu.us",
    "hi.us",
    "ia.us",
    "id.us",
    "il.us",
    "in.us",
    "ks.us",
    "ky.us",
    "la.us",
    "ma.us",
    "md.us",
    "me.us",
    "mi.us",
    "mn.us",
    "mo.us",
    "ms.us",
    "mt.us",
    "nc.us",
    "nd.us",
    "ne.us",
    "nh.us",
    "nj.us",
    "nm.us",
    "nv.us",
    "ny.us",
    "oh.us",
    "ok.us",
    "or.us",
    "pa.us",
    "pr.us",
    "ri.us",
    "sc.us",
    "sd.us",
    "tn.us",
    "tx.us",
    "ut.us",
    "vi.us",
    "vt.us",
    "va.us",
    "wa.us",
    "wi.us",
    "wv.us",
    "wy.us",
    "k12.ak.us",
    "k12.al.us",
    "k12.ar.us",
    "k12.as.us",
    "k12.az.us",
    "k12.ca.us",
    "k12.co.us",
    "k12.ct.us",
    "k12.dc.us",
    "k12.de.us",
    "k12.fl.us",
    "k12.ga.us",
    "k12.gu.us",
    "k12.ia.us",
    "k12.id.us",
    "k12.il.us",
    "k12.in.us",
    "k12.ks.us",
    "k12.ky.us",
    "k12.la.us",
    "k12.ma.us",
    "k12.md.us",
    "k12.me.us",
    "k12.mi.us",
    "k12.mn.us",
    "k12.mo.us",
    "k12.ms.us",
    "k12.mt.us",
    "k12.nc.us",
    "k12.ne.us",
    "k12.nh.us",
    "k12.nj.us",
    "k12.nm.us",
    "k12.nv.us",
    "k12.ny.us",
    "k12.oh.us",
    "k12.ok.us",
    "k12.or.us",
    "k12.pa.us",
    "k12.pr.us",
    "k12.sc.us",
    "k12.tn.us",
    "k12.tx.us",
    "k12.ut.us",
    "k12.vi.us",
    "k12.vt.us",
    "k12.va.us",
    "k12.wa.us",
    "k12.wi.us",
    "k12.wy.us",
    "cc.ak.us",
    "cc.al.us",
    "cc.ar.us",
    "cc.as.us",
    "cc.az.us",
    "cc.ca.us",
    "cc.co.us",
    "cc.ct.us",
    "cc.dc.us",
    "cc.de.us",
    "cc.fl.us",
    "cc.ga.us",
    "cc.gu.us",
    "cc.hi.us",
    "cc.ia.us",
    "cc.id.us",
    "cc.il.us",
    "cc.in.us",
    "cc.ks.us",
    "cc.ky.us",
    "cc.la.us",
    "cc.ma.us",
    "cc.md.us",
    "cc.me.us",
    "cc.mi.us",
    "cc.mn.us",
    "cc.mo.us",
    "cc.ms.us",
    "cc.mt.us",
    "cc.nc.us",
    "cc.nd.us",
    "cc.ne.us",
    "cc.nh.us",
    "cc.nj.us",
    "cc.nm.us",
    "cc.nv.us",
    "cc.ny.us",
    "cc.oh.us",
    "cc.ok.us",
    "cc.or.us",
    "cc.pa.us",
    "cc.pr.us",
    "cc.ri.us",
    "cc.sc.us",
    "cc.sd.us",
    "cc.tn.us",
    "cc.tx.us",
    "cc.ut.us",
    "cc.vi.us",
    "cc.vt.us",
    "cc.va.us",
    "cc.wa.us",
    "cc.wi.us",
    "cc.wv.us",
    "cc.wy.us",
    "lib.ak.us",
    "lib.al.us",
    "lib.ar.us",
    "lib.as.us",
    "lib.az.us",
    "lib.ca.us",
    "lib.co.us",
    "lib.ct.us",
    "lib.dc.us",
    "lib.fl.us",
    "lib.ga.us",
    "lib.gu.us",
    "lib.hi.us",
    "lib.ia.us",
    "lib.id.us",
    "lib.il.us",
    "lib.in.us",
    "lib.ks.us",
    "lib.ky.us",
    "lib.la.us",
    "lib.ma.us",
    "lib.md.us",
    "lib.me.us",
    "lib.mi.us",
    "lib.mn.us",
    "lib.mo.us",
    "lib.ms.us",
    "lib.mt.us",
    "lib.nc.us",
    "lib.nd.us",
    "lib.ne.us",
    "lib.nh.us",
    "lib.nj.us",
    "lib.nm.us",
    "lib.nv.us",
    "lib.ny.us",
    "lib.oh.us",
    "lib.ok.us",
    "lib.or.us",
    "lib.pa.us",
    "lib.pr.us",
    "lib.ri.us",
    "lib.sc.us",
    "lib.sd.us",
    "lib.tn.us",
    "lib.tx.us",
    "lib.ut.us",
    "lib.vi.us",
    "lib.vt.us",
    "lib.va.us",
    "lib.wa.us",
    "lib.wi.us",
    "lib.wy.us",
    "pvt.k12.ma.us",
    "chtr.k12.ma.us",
    "paroch.k12.ma.us",
    "ann-arbor.mi.us",
    "cog.mi.us",
    "dst.mi.us",
    "eaton.mi.us",
    "gen.mi.us",
    "mus.mi.us",
    "tec.mi.us",
    "washtenaw.mi.us",
    "uy",
    "com.uy",
    "edu.uy",
    "gub.uy",
    "mil.uy",
    "net.uy",
    "org.uy",
    "uz",
    "co.uz",
    "com.uz",
    "net.uz",
    "org.uz",
    "va",
    "vc",
    "com.vc",
    "net.vc",
    "org.vc",
    "gov.vc",
    "mil.vc",
    "edu.vc",
    "ve",
    "arts.ve",
    "bib.ve",
    "co.ve",
    "com.ve",
    "e12.ve",
    "edu.ve",
    "firm.ve",
    "gob.ve",
    "gov.ve",
    "info.ve",
    "int.ve",
    "mil.ve",
    "net.ve",
    "nom.ve",
    "org.ve",
    "rar.ve",
    "rec.ve",
    "store.ve",
    "tec.ve",
    "web.ve",
    "vg",
    "vi",
    "co.vi",
    "com.vi",
    "k12.vi",
    "net.vi",
    "org.vi",
    "vn",
    "com.vn",
    "net.vn",
    "org.vn",
    "edu.vn",
    "gov.vn",
    "int.vn",
    "ac.vn",
    "biz.vn",
    "info.vn",
    "name.vn",
    "pro.vn",
    "health.vn",
    "vu",
    "com.vu",
    "edu.vu",
    "net.vu",
    "org.vu",
    "wf",
    "ws",
    "com.ws",
    "net.ws",
    "org.ws",
    "gov.ws",
    "edu.ws",
    "yt",
    "امارات",
    "հայ",
    "বাংলা",
    "бг",
    "البحرين",
    "бел",
    "中国",
    "中國",
    "الجزائر",
    "مصر",
    "ею",
    "ευ",
    "موريتانيا",
    "გე",
    "ελ",
    "香港",
    "公司.香港",
    "教育.香港",
    "政府.香港",
    "個人.香港",
    "網絡.香港",
    "組織.香港",
    "ಭಾರತ",
    "ଭାରତ",
    "ভাৰত",
    "भारतम्",
    "भारोत",
    "ڀارت",
    "ഭാരതം",
    "भारत",
    "بارت",
    "بھارت",
    "భారత్",
    "ભારત",
    "ਭਾਰਤ",
    "ভারত",
    "இந்தியா",
    "ایران",
    "ايران",
    "عراق",
    "الاردن",
    "한국",
    "қаз",
    "ລາວ",
    "ලංකා",
    "இலங்கை",
    "المغرب",
    "мкд",
    "мон",
    "澳門",
    "澳门",
    "مليسيا",
    "عمان",
    "پاکستان",
    "پاكستان",
    "فلسطين",
    "срб",
    "пр.срб",
    "орг.срб",
    "обр.срб",
    "од.срб",
    "упр.срб",
    "ак.срб",
    "рф",
    "قطر",
    "السعودية",
    "السعودیة",
    "السعودیۃ",
    "السعوديه",
    "سودان",
    "新加坡",
    "சிங்கப்பூர்",
    "سورية",
    "سوريا",
    "ไทย",
    "ศึกษา.ไทย",
    "ธุรกิจ.ไทย",
    "รัฐบาล.ไทย",
    "ทหาร.ไทย",
    "เน็ต.ไทย",
    "องค์กร.ไทย",
    "تونس",
    "台灣",
    "台湾",
    "臺灣",
    "укр",
    "اليمن",
    "xxx",
    "ye",
    "com.ye",
    "edu.ye",
    "gov.ye",
    "net.ye",
    "mil.ye",
    "org.ye",
    "ac.za",
    "agric.za",
    "alt.za",
    "co.za",
    "edu.za",
    "gov.za",
    "grondar.za",
    "law.za",
    "mil.za",
    "net.za",
    "ngo.za",
    "nic.za",
    "nis.za",
    "nom.za",
    "org.za",
    "school.za",
    "tm.za",
    "web.za",
    "zm",
    "ac.zm",
    "biz.zm",
    "co.zm",
    "com.zm",
    "edu.zm",
    "gov.zm",
    "info.zm",
    "mil.zm",
    "net.zm",
    "org.zm",
    "sch.zm",
    "zw",
    "ac.zw",
    "co.zw",
    "gov.zw",
    "mil.zw",
    "org.zw",
    "aaa",
    "aarp",
    "abarth",
    "abb",
    "abbott",
    "abbvie",
    "abc",
    "able",
    "abogado",
    "abudhabi",
    "academy",
    "accenture",
    "accountant",
    "accountants",
    "aco",
    "actor",
    "adac",
    "ads",
    "adult",
    "aeg",
    "aetna",
    "afl",
    "africa",
    "agakhan",
    "agency",
    "aig",
    "airbus",
    "airforce",
    "airtel",
    "akdn",
    "alfaromeo",
    "alibaba",
    "alipay",
    "allfinanz",
    "allstate",
    "ally",
    "alsace",
    "alstom",
    "amazon",
    "americanexpress",
    "americanfamily",
    "amex",
    "amfam",
    "amica",
    "amsterdam",
    "analytics",
    "android",
    "anquan",
    "anz",
    "aol",
    "apartments",
    "app",
    "apple",
    "aquarelle",
    "arab",
    "aramco",
    "archi",
    "army",
    "art",
    "arte",
    "asda",
    "associates",
    "athleta",
    "attorney",
    "auction",
    "audi",
    "audible",
    "audio",
    "auspost",
    "author",
    "auto",
    "autos",
    "avianca",
    "aws",
    "axa",
    "azure",
    "baby",
    "baidu",
    "banamex",
    "bananarepublic",
    "band",
    "bank",
    "bar",
    "barcelona",
    "barclaycard",
    "barclays",
    "barefoot",
    "bargains",
    "baseball",
    "basketball",
    "bauhaus",
    "bayern",
    "bbc",
    "bbt",
    "bbva",
    "bcg",
    "bcn",
    "beats",
    "beauty",
    "beer",
    "bentley",
    "berlin",
    "best",
    "bestbuy",
    "bet",
    "bharti",
    "bible",
    "bid",
    "bike",
    "bing",
    "bingo",
    "bio",
    "black",
    "blackfriday",
    "blockbuster",
    "blog",
    "bloomberg",
    "blue",
    "bms",
    "bmw",
    "bnpparibas",
    "boats",
    "boehringer",
    "bofa",
    "bom",
    "bond",
    "boo",
    "book",
    "booking",
    "bosch",
    "bostik",
    "boston",
    "bot",
    "boutique",
    "box",
    "bradesco",
    "bridgestone",
    "broadway",
    "broker",
    "brother",
    "brussels",
    "bugatti",
    "build",
    "builders",
    "business",
    "buy",
    "buzz",
    "bzh",
    "cab",
    "cafe",
    "cal",
    "call",
    "calvinklein",
    "cam",
    "camera",
    "camp",
    "cancerresearch",
    "canon",
    "capetown",
    "capital",
    "capitalone",
    "car",
    "caravan",
    "cards",
    "care",
    "career",
    "careers",
    "cars",
    "casa",
    "case",
    "cash",
    "casino",
    "catering",
    "catholic",
    "cba",
    "cbn",
    "cbre",
    "cbs",
    "center",
    "ceo",
    "cern",
    "cfa",
    "cfd",
    "chanel",
    "channel",
    "charity",
    "chase",
    "chat",
    "cheap",
    "chintai",
    "christmas",
    "chrome",
    "church",
    "cipriani",
    "circle",
    "cisco",
    "citadel",
    "citi",
    "citic",
    "city",
    "cityeats",
    "claims",
    "cleaning",
    "click",
    "clinic",
    "clinique",
    "clothing",
    "cloud",
    "club",
    "clubmed",
    "coach",
    "codes",
    "coffee",
    "college",
    "cologne",
    "comcast",
    "commbank",
    "community",
    "company",
    "compare",
    "computer",
    "comsec",
    "condos",
    "construction",
    "consulting",
    "contact",
    "contractors",
    "cooking",
    "cookingchannel",
    "cool",
    "corsica",
    "country",
    "coupon",
    "coupons",
    "courses",
    "cpa",
    "credit",
    "creditcard",
    "creditunion",
    "cricket",
    "crown",
    "crs",
    "cruise",
    "cruises",
    "cuisinella",
    "cymru",
    "cyou",
    "dabur",
    "dad",
    "dance",
    "data",
    "date",
    "dating",
    "datsun",
    "day",
    "dclk",
    "dds",
    "deal",
    "dealer",
    "deals",
    "degree",
    "delivery",
    "dell",
    "deloitte",
    "delta",
    "democrat",
    "dental",
    "dentist",
    "desi",
    "design",
    "dev",
    "dhl",
    "diamonds",
    "diet",
    "digital",
    "direct",
    "directory",
    "discount",
    "discover",
    "dish",
    "diy",
    "dnp",
    "docs",
    "doctor",
    "dog",
    "domains",
    "dot",
    "download",
    "drive",
    "dtv",
    "dubai",
    "dunlop",
    "dupont",
    "durban",
    "dvag",
    "dvr",
    "earth",
    "eat",
    "eco",
    "edeka",
    "education",
    "email",
    "emerck",
    "energy",
    "engineer",
    "engineering",
    "enterprises",
    "epson",
    "equipment",
    "ericsson",
    "erni",
    "esq",
    "estate",
    "etisalat",
    "eurovision",
    "eus",
    "events",
    "exchange",
    "expert",
    "exposed",
    "express",
    "extraspace",
    "fage",
    "fail",
    "fairwinds",
    "faith",
    "family",
    "fan",
    "fans",
    "farm",
    "farmers",
    "fashion",
    "fast",
    "fedex",
    "feedback",
    "ferrari",
    "ferrero",
    "fiat",
    "fidelity",
    "fido",
    "film",
    "final",
    "finance",
    "financial",
    "fire",
    "firestone",
    "firmdale",
    "fish",
    "fishing",
    "fit",
    "fitness",
    "flickr",
    "flights",
    "flir",
    "florist",
    "flowers",
    "fly",
    "foo",
    "food",
    "foodnetwork",
    "football",
    "ford",
    "forex",
    "forsale",
    "forum",
    "foundation",
    "fox",
    "free",
    "fresenius",
    "frl",
    "frogans",
    "frontdoor",
    "frontier",
    "ftr",
    "fujitsu",
    "fun",
    "fund",
    "furniture",
    "futbol",
    "fyi",
    "gal",
    "gallery",
    "gallo",
    "gallup",
    "game",
    "games",
    "gap",
    "garden",
    "gay",
    "gbiz",
    "gdn",
    "gea",
    "gent",
    "genting",
    "george",
    "ggee",
    "gift",
    "gifts",
    "gives",
    "giving",
    "glass",
    "gle",
    "global",
    "globo",
    "gmail",
    "gmbh",
    "gmo",
    "gmx",
    "godaddy",
    "gold",
    "goldpoint",
    "golf",
    "goo",
    "goodyear",
    "goog",
    "google",
    "gop",
    "got",
    "grainger",
    "graphics",
    "gratis",
    "green",
    "gripe",
    "grocery",
    "group",
    "guardian",
    "gucci",
    "guge",
    "guide",
    "guitars",
    "guru",
    "hair",
    "hamburg",
    "hangout",
    "haus",
    "hbo",
    "hdfc",
    "hdfcbank",
    "health",
    "healthcare",
    "help",
    "helsinki",
    "here",
    "hermes",
    "hgtv",
    "hiphop",
    "hisamitsu",
    "hitachi",
    "hiv",
    "hkt",
    "hockey",
    "holdings",
    "holiday",
    "homedepot",
    "homegoods",
    "homes",
    "homesense",
    "honda",
    "horse",
    "hospital",
    "host",
    "hosting",
    "hot",
    "hoteles",
    "hotels",
    "hotmail",
    "house",
    "how",
    "hsbc",
    "hughes",
    "hyatt",
    "hyundai",
    "ibm",
    "icbc",
    "ice",
    "icu",
    "ieee",
    "ifm",
    "ikano",
    "imamat",
    "imdb",
    "immo",
    "immobilien",
    "inc",
    "industries",
    "infiniti",
    "ing",
    "ink",
    "institute",
    "insurance",
    "insure",
    "international",
    "intuit",
    "investments",
    "ipiranga",
    "irish",
    "ismaili",
    "ist",
    "istanbul",
    "itau",
    "itv",
    "jaguar",
    "java",
    "jcb",
    "jeep",
    "jetzt",
    "jewelry",
    "jio",
    "jll",
    "jmp",
    "jnj",
    "joburg",
    "jot",
    "joy",
    "jpmorgan",
    "jprs",
    "juegos",
    "juniper",
    "kaufen",
    "kddi",
    "kerryhotels",
    "kerrylogistics",
    "kerryproperties",
    "kfh",
    "kia",
    "kids",
    "kim",
    "kinder",
    "kindle",
    "kitchen",
    "kiwi",
    "koeln",
    "komatsu",
    "kosher",
    "kpmg",
    "kpn",
    "krd",
    "kred",
    "kuokgroup",
    "kyoto",
    "lacaixa",
    "lamborghini",
    "lamer",
    "lancaster",
    "lancia",
    "land",
    "landrover",
    "lanxess",
    "lasalle",
    "lat",
    "latino",
    "latrobe",
    "law",
    "lawyer",
    "lds",
    "lease",
    "leclerc",
    "lefrak",
    "legal",
    "lego",
    "lexus",
    "lgbt",
    "lidl",
    "life",
    "lifeinsurance",
    "lifestyle",
    "lighting",
    "like",
    "lilly",
    "limited",
    "limo",
    "lincoln",
    "linde",
    "link",
    "lipsy",
    "live",
    "living",
    "llc",
    "llp",
    "loan",
    "loans",
    "locker",
    "locus",
    "loft",
    "lol",
    "london",
    "lotte",
    "lotto",
    "love",
    "lpl",
    "lplfinancial",
    "ltd",
    "ltda",
    "lundbeck",
    "luxe",
    "luxury",
    "macys",
    "madrid",
    "maif",
    "maison",
    "makeup",
    "man",
    "management",
    "mango",
    "map",
    "market",
    "marketing",
    "markets",
    "marriott",
    "marshalls",
    "maserati",
    "mattel",
    "mba",
    "mckinsey",
    "med",
    "media",
    "meet",
    "melbourne",
    "meme",
    "memorial",
    "men",
    "menu",
    "merckmsd",
    "miami",
    "microsoft",
    "mini",
    "mint",
    "mit",
    "mitsubishi",
    "mlb",
    "mls",
    "mma",
    "mobile",
    "moda",
    "moe",
    "moi",
    "mom",
    "monash",
    "money",
    "monster",
    "mormon",
    "mortgage",
    "moscow",
    "moto",
    "motorcycles",
    "mov",
    "movie",
    "msd",
    "mtn",
    "mtr",
    "music",
    "mutual",
    "nab",
    "nagoya",
    "natura",
    "navy",
    "nba",
    "nec",
    "netbank",
    "netflix",
    "network",
    "neustar",
    "new",
    "news",
    "next",
    "nextdirect",
    "nexus",
    "nfl",
    "ngo",
    "nhk",
    "nico",
    "nike",
    "nikon",
    "ninja",
    "nissan",
    "nissay",
    "nokia",
    "northwesternmutual",
    "norton",
    "now",
    "nowruz",
    "nowtv",
    "nra",
    "nrw",
    "ntt",
    "nyc",
    "obi",
    "observer",
    "office",
    "okinawa",
    "olayan",
    "olayangroup",
    "oldnavy",
    "ollo",
    "omega",
    "one",
    "ong",
    "onl",
    "online",
    "ooo",
    "open",
    "oracle",
    "orange",
    "organic",
    "origins",
    "osaka",
    "otsuka",
    "ott",
    "ovh",
    "page",
    "panasonic",
    "paris",
    "pars",
    "partners",
    "parts",
    "party",
    "passagens",
    "pay",
    "pccw",
    "pet",
    "pfizer",
    "pharmacy",
    "phd",
    "philips",
    "phone",
    "photo",
    "photography",
    "photos",
    "physio",
    "pics",
    "pictet",
    "pictures",
    "pid",
    "pin",
    "ping",
    "pink",
    "pioneer",
    "pizza",
    "place",
    "play",
    "playstation",
    "plumbing",
    "plus",
    "pnc",
    "pohl",
    "poker",
    "politie",
    "porn",
    "pramerica",
    "praxi",
    "press",
    "prime",
    "prod",
    "productions",
    "prof",
    "progressive",
    "promo",
    "properties",
    "property",
    "protection",
    "pru",
    "prudential",
    "pub",
    "pwc",
    "qpon",
    "quebec",
    "quest",
    "racing",
    "radio",
    "read",
    "realestate",
    "realtor",
    "realty",
    "recipes",
    "red",
    "redstone",
    "redumbrella",
    "rehab",
    "reise",
    "reisen",
    "reit",
    "reliance",
    "ren",
    "rent",
    "rentals",
    "repair",
    "report",
    "republican",
    "rest",
    "restaurant",
    "review",
    "reviews",
    "rexroth",
    "rich",
    "richardli",
    "ricoh",
    "ril",
    "rio",
    "rip",
    "rocher",
    "rocks",
    "rodeo",
    "rogers",
    "room",
    "rsvp",
    "rugby",
    "ruhr",
    "run",
    "rwe",
    "ryukyu",
    "saarland",
    "safe",
    "safety",
    "sakura",
    "sale",
    "salon",
    "samsclub",
    "samsung",
    "sandvik",
    "sandvikcoromant",
    "sanofi",
    "sap",
    "sarl",
    "sas",
    "save",
    "saxo",
    "sbi",
    "sbs",
    "sca",
    "scb",
    "schaeffler",
    "schmidt",
    "scholarships",
    "school",
    "schule",
    "schwarz",
    "science",
    "scot",
    "search",
    "seat",
    "secure",
    "security",
    "seek",
    "select",
    "sener",
    "services",
    "ses",
    "seven",
    "sew",
    "sex",
    "sexy",
    "sfr",
    "shangrila",
    "sharp",
    "shaw",
    "shell",
    "shia",
    "shiksha",
    "shoes",
    "shop",
    "shopping",
    "shouji",
    "show",
    "showtime",
    "silk",
    "sina",
    "singles",
    "site",
    "ski",
    "skin",
    "sky",
    "skype",
    "sling",
    "smart",
    "smile",
    "sncf",
    "soccer",
    "social",
    "softbank",
    "software",
    "sohu",
    "solar",
    "solutions",
    "song",
    "sony",
    "soy",
    "spa",
    "space",
    "sport",
    "spot",
    "srl",
    "stada",
    "staples",
    "star",
    "statebank",
    "statefarm",
    "stc",
    "stcgroup",
    "stockholm",
    "storage",
    "store",
    "stream",
    "studio",
    "study",
    "style",
    "sucks",
    "supplies",
    "supply",
    "support",
    "surf",
    "surgery",
    "suzuki",
    "swatch",
    "swiss",
    "sydney",
    "systems",
    "tab",
    "taipei",
    "talk",
    "taobao",
    "target",
    "tatamotors",
    "tatar",
    "tattoo",
    "tax",
    "taxi",
    "tci",
    "tdk",
    "team",
    "tech",
    "technology",
    "temasek",
    "tennis",
    "teva",
    "thd",
    "theater",
    "theatre",
    "tiaa",
    "tickets",
    "tienda",
    "tiffany",
    "tips",
    "tires",
    "tirol",
    "tjmaxx",
    "tjx",
    "tkmaxx",
    "tmall",
    "today",
    "tokyo",
    "tools",
    "top",
    "toray",
    "toshiba",
    "total",
    "tours",
    "town",
    "toyota",
    "toys",
    "trade",
    "trading",
    "training",
    "travel",
    "travelchannel",
    "travelers",
    "travelersinsurance",
    "trust",
    "trv",
    "tube",
    "tui",
    "tunes",
    "tushu",
    "tvs",
    "ubank",
    "ubs",
    "unicom",
    "university",
    "uno",
    "uol",
    "ups",
    "vacations",
    "vana",
    "vanguard",
    "vegas",
    "ventures",
    "verisign",
    "versicherung",
    "vet",
    "viajes",
    "video",
    "vig",
    "viking",
    "villas",
    "vin",
    "vip",
    "virgin",
    "visa",
    "vision",
    "viva",
    "vivo",
    "vlaanderen",
    "vodka",
    "volkswagen",
    "volvo",
    "vote",
    "voting",
    "voto",
    "voyage",
    "vuelos",
    "wales",
    "walmart",
    "walter",
    "wang",
    "wanggou",
    "watch",
    "watches",
    "weather",
    "weatherchannel",
    "webcam",
    "weber",
    "website",
    "wedding",
    "weibo",
    "weir",
    "whoswho",
    "wien",
    "wiki",
    "williamhill",
    "win",
    "windows",
    "wine",
    "winners",
    "wme",
    "wolterskluwer",
    "woodside",
    "work",
    "works",
    "world",
    "wow",
    "wtc",
    "wtf",
    "xbox",
    "xerox",
    "xfinity",
    "xihuan",
    "xin",
    "कॉम",
    "セール",
    "佛山",
    "慈善",
    "集团",
    "在线",
    "点看",
    "คอม",
    "八卦",
    "موقع",
    "公益",
    "公司",
    "香格里拉",
    "网站",
    "移动",
    "我爱你",
    "москва",
    "католик",
    "онлайн",
    "сайт",
    "联通",
    "קום",
    "时尚",
    "微博",
    "淡马锡",
    "ファッション",
    "орг",
    "नेट",
    "ストア",
    "アマゾン",
    "삼성",
    "商标",
    "商店",
    "商城",
    "дети",
    "ポイント",
    "新闻",
    "家電",
    "كوم",
    "中文网",
    "中信",
    "娱乐",
    "谷歌",
    "電訊盈科",
    "购物",
    "クラウド",
    "通販",
    "网店",
    "संगठन",
    "餐厅",
    "网络",
    "ком",
    "亚马逊",
    "诺基亚",
    "食品",
    "飞利浦",
    "手机",
    "ارامكو",
    "العليان",
    "اتصالات",
    "بازار",
    "ابوظبي",
    "كاثوليك",
    "همراه",
    "닷컴",
    "政府",
    "شبكة",
    "بيتك",
    "عرب",
    "机构",
    "组织机构",
    "健康",
    "招聘",
    "рус",
    "大拿",
    "みんな",
    "グーグル",
    "世界",
    "書籍",
    "网址",
    "닷넷",
    "コム",
    "天主教",
    "游戏",
    "vermögensberater",
    "vermögensberatung",
    "企业",
    "信息",
    "嘉里大酒店",
    "嘉里",
    "广东",
    "政务",
    "xyz",
    "yachts",
    "yahoo",
    "yamaxun",
    "yandex",
    "yodobashi",
    "yoga",
    "yokohama",
    "you",
    "youtube",
    "yun",
    "zappos",
    "zara",
    "zero",
    "zip",
    "zone",
    "zuerich",
    "cc.ua",
    "inf.ua",
    "ltd.ua",
    "611.to",
    "graphox.us",
    "*.devcdnaccesso.com",
    "adobeaemcloud.com",
    "*.dev.adobeaemcloud.com",
    "hlx.live",
    "adobeaemcloud.net",
    "hlx.page",
    "hlx3.page",
    "beep.pl",
    "airkitapps.com",
    "airkitapps-au.com",
    "airkitapps.eu",
    "aivencloud.com",
    "barsy.ca",
    "*.compute.estate",
    "*.alces.network",
    "kasserver.com",
    "altervista.org",
    "alwaysdata.net",
    "cloudfront.net",
    "*.compute.amazonaws.com",
    "*.compute-1.amazonaws.com",
    "*.compute.amazonaws.com.cn",
    "us-east-1.amazonaws.com",
    "cn-north-1.eb.amazonaws.com.cn",
    "cn-northwest-1.eb.amazonaws.com.cn",
    "elasticbeanstalk.com",
    "ap-northeast-1.elasticbeanstalk.com",
    "ap-northeast-2.elasticbeanstalk.com",
    "ap-northeast-3.elasticbeanstalk.com",
    "ap-south-1.elasticbeanstalk.com",
    "ap-southeast-1.elasticbeanstalk.com",
    "ap-southeast-2.elasticbeanstalk.com",
    "ca-central-1.elasticbeanstalk.com",
    "eu-central-1.elasticbeanstalk.com",
    "eu-west-1.elasticbeanstalk.com",
    "eu-west-2.elasticbeanstalk.com",
    "eu-west-3.elasticbeanstalk.com",
    "sa-east-1.elasticbeanstalk.com",
    "us-east-1.elasticbeanstalk.com",
    "us-east-2.elasticbeanstalk.com",
    "us-gov-west-1.elasticbeanstalk.com",
    "us-west-1.elasticbeanstalk.com",
    "us-west-2.elasticbeanstalk.com",
    "*.elb.amazonaws.com",
    "*.elb.amazonaws.com.cn",
    "awsglobalaccelerator.com",
    "s3.amazonaws.com",
    "s3-ap-northeast-1.amazonaws.com",
    "s3-ap-northeast-2.amazonaws.com",
    "s3-ap-south-1.amazonaws.com",
    "s3-ap-southeast-1.amazonaws.com",
    "s3-ap-southeast-2.amazonaws.com",
    "s3-ca-central-1.amazonaws.com",
    "s3-eu-central-1.amazonaws.com",
    "s3-eu-west-1.amazonaws.com",
    "s3-eu-west-2.amazonaws.com",
    "s3-eu-west-3.amazonaws.com",
    "s3-external-1.amazonaws.com",
    "s3-fips-us-gov-west-1.amazonaws.com",
    "s3-sa-east-1.amazonaws.com",
    "s3-us-gov-west-1.amazonaws.com",
    "s3-us-east-2.amazonaws.com",
    "s3-us-west-1.amazonaws.com",
    "s3-us-west-2.amazonaws.com",
    "s3.ap-northeast-2.amazonaws.com",
    "s3.ap-south-1.amazonaws.com",
    "s3.cn-north-1.amazonaws.com.cn",
    "s3.ca-central-1.amazonaws.com",
    "s3.eu-central-1.amazonaws.com",
    "s3.eu-west-2.amazonaws.com",
    "s3.eu-west-3.amazonaws.com",
    "s3.us-east-2.amazonaws.com",
    "s3.dualstack.ap-northeast-1.amazonaws.com",
    "s3.dualstack.ap-northeast-2.amazonaws.com",
    "s3.dualstack.ap-south-1.amazonaws.com",
    "s3.dualstack.ap-southeast-1.amazonaws.com",
    "s3.dualstack.ap-southeast-2.amazonaws.com",
    "s3.dualstack.ca-central-1.amazonaws.com",
    "s3.dualstack.eu-central-1.amazonaws.com",
    "s3.dualstack.eu-west-1.amazonaws.com",
    "s3.dualstack.eu-west-2.amazonaws.com",
    "s3.dualstack.eu-west-3.amazonaws.com",
    "s3.dualstack.sa-east-1.amazonaws.com",
    "s3.dualstack.us-east-1.amazonaws.com",
    "s3.dualstack.us-east-2.amazonaws.com",
    "s3-website-us-east-1.amazonaws.com",
    "s3-website-us-west-1.amazonaws.com",
    "s3-website-us-west-2.amazonaws.com",
    "s3-website-ap-northeast-1.amazonaws.com",
    "s3-website-ap-southeast-1.amazonaws.com",
    "s3-website-ap-southeast-2.amazonaws.com",
    "s3-website-eu-west-1.amazonaws.com",
    "s3-website-sa-east-1.amazonaws.com",
    "s3-website.ap-northeast-2.amazonaws.com",
    "s3-website.ap-south-1.amazonaws.com",
    "s3-website.ca-central-1.amazonaws.com",
    "s3-website.eu-central-1.amazonaws.com",
    "s3-website.eu-west-2.amazonaws.com",
    "s3-website.eu-west-3.amazonaws.com",
    "s3-website.us-east-2.amazonaws.com",
    "t3l3p0rt.net",
    "tele.amune.org",
    "apigee.io",
    "siiites.com",
    "appspacehosted.com",
    "appspaceusercontent.com",
    "appudo.net",
    "on-aptible.com",
    "user.aseinet.ne.jp",
    "gv.vc",
    "d.gv.vc",
    "user.party.eus",
    "pimienta.org",
    "poivron.org",
    "potager.org",
    "sweetpepper.org",
    "myasustor.com",
    "cdn.prod.atlassian-dev.net",
    "translated.page",
    "myfritz.net",
    "onavstack.net",
    "*.awdev.ca",
    "*.advisor.ws",
    "ecommerce-shop.pl",
    "b-data.io",
    "backplaneapp.io",
    "balena-devices.com",
    "rs.ba",
    "*.banzai.cloud",
    "app.banzaicloud.io",
    "*.backyards.banzaicloud.io",
    "base.ec",
    "official.ec",
    "buyshop.jp",
    "fashionstore.jp",
    "handcrafted.jp",
    "kawaiishop.jp",
    "supersale.jp",
    "theshop.jp",
    "shopselect.net",
    "base.shop",
    "*.beget.app",
    "betainabox.com",
    "bnr.la",
    "bitbucket.io",
    "blackbaudcdn.net",
    "of.je",
    "bluebite.io",
    "boomla.net",
    "boutir.com",
    "boxfuse.io",
    "square7.ch",
    "bplaced.com",
    "bplaced.de",
    "square7.de",
    "bplaced.net",
    "square7.net",
    "shop.brendly.rs",
    "browsersafetymark.io",
    "uk0.bigv.io",
    "dh.bytemark.co.uk",
    "vm.bytemark.co.uk",
    "cafjs.com",
    "mycd.eu",
    "drr.ac",
    "uwu.ai",
    "carrd.co",
    "crd.co",
    "ju.mp",
    "ae.org",
    "br.com",
    "cn.com",
    "com.de",
    "com.se",
    "de.com",
    "eu.com",
    "gb.net",
    "hu.net",
    "jp.net",
    "jpn.com",
    "mex.com",
    "ru.com",
    "sa.com",
    "se.net",
    "uk.com",
    "uk.net",
    "us.com",
    "za.bz",
    "za.com",
    "ar.com",
    "hu.com",
    "kr.com",
    "no.com",
    "qc.com",
    "uy.com",
    "africa.com",
    "gr.com",
    "in.net",
    "web.in",
    "us.org",
    "co.com",
    "aus.basketball",
    "nz.basketball",
    "radio.am",
    "radio.fm",
    "c.la",
    "certmgr.org",
    "cx.ua",
    "discourse.group",
    "discourse.team",
    "cleverapps.io",
    "clerk.app",
    "clerkstage.app",
    "*.lcl.dev",
    "*.lclstage.dev",
    "*.stg.dev",
    "*.stgstage.dev",
    "clickrising.net",
    "c66.me",
    "cloud66.ws",
    "cloud66.zone",
    "jdevcloud.com",
    "wpdevcloud.com",
    "cloudaccess.host",
    "freesite.host",
    "cloudaccess.net",
    "cloudcontrolled.com",
    "cloudcontrolapp.com",
    "*.cloudera.site",
    "pages.dev",
    "trycloudflare.com",
    "workers.dev",
    "wnext.app",
    "co.ca",
    "*.otap.co",
    "co.cz",
    "c.cdn77.org",
    "cdn77-ssl.net",
    "r.cdn77.net",
    "rsc.cdn77.org",
    "ssl.origin.cdn77-secure.org",
    "cloudns.asia",
    "cloudns.biz",
    "cloudns.club",
    "cloudns.cc",
    "cloudns.eu",
    "cloudns.in",
    "cloudns.info",
    "cloudns.org",
    "cloudns.pro",
    "cloudns.pw",
    "cloudns.us",
    "cnpy.gdn",
    "codeberg.page",
    "co.nl",
    "co.no",
    "webhosting.be",
    "hosting-cluster.nl",
    "ac.ru",
    "edu.ru",
    "gov.ru",
    "int.ru",
    "mil.ru",
    "test.ru",
    "dyn.cosidns.de",
    "dynamisches-dns.de",
    "dnsupdater.de",
    "internet-dns.de",
    "l-o-g-i-n.de",
    "dynamic-dns.info",
    "feste-ip.net",
    "knx-server.net",
    "static-access.net",
    "realm.cz",
    "*.cryptonomic.net",
    "cupcake.is",
    "curv.dev",
    "*.customer-oci.com",
    "*.oci.customer-oci.com",
    "*.ocp.customer-oci.com",
    "*.ocs.customer-oci.com",
    "cyon.link",
    "cyon.site",
    "fnwk.site",
    "folionetwork.site",
    "platform0.app",
    "daplie.me",
    "localhost.daplie.me",
    "dattolocal.com",
    "dattorelay.com",
    "dattoweb.com",
    "mydatto.com",
    "dattolocal.net",
    "mydatto.net",
    "biz.dk",
    "co.dk",
    "firm.dk",
    "reg.dk",
    "store.dk",
    "dyndns.dappnode.io",
    "*.dapps.earth",
    "*.bzz.dapps.earth",
    "builtwithdark.com",
    "demo.datadetect.com",
    "instance.datadetect.com",
    "edgestack.me",
    "ddns5.com",
    "debian.net",
    "deno.dev",
    "deno-staging.dev",
    "dedyn.io",
    "deta.app",
    "deta.dev",
    "*.rss.my.id",
    "*.diher.solutions",
    "discordsays.com",
    "discordsez.com",
    "jozi.biz",
    "dnshome.de",
    "online.th",
    "shop.th",
    "drayddns.com",
    "shoparena.pl",
    "dreamhosters.com",
    "mydrobo.com",
    "drud.io",
    "drud.us",
    "duckdns.org",
    "bip.sh",
    "bitbridge.net",
    "dy.fi",
    "tunk.org",
    "dyndns-at-home.com",
    "dyndns-at-work.com",
    "dyndns-blog.com",
    "dyndns-free.com",
    "dyndns-home.com",
    "dyndns-ip.com",
    "dyndns-mail.com",
    "dyndns-office.com",
    "dyndns-pics.com",
    "dyndns-remote.com",
    "dyndns-server.com",
    "dyndns-web.com",
    "dyndns-wiki.com",
    "dyndns-work.com",
    "dyndns.biz",
    "dyndns.info",
    "dyndns.org",
    "dyndns.tv",
    "at-band-camp.net",
    "ath.cx",
    "barrel-of-knowledge.info",
    "barrell-of-knowledge.info",
    "better-than.tv",
    "blogdns.com",
    "blogdns.net",
    "blogdns.org",
    "blogsite.org",
    "boldlygoingnowhere.org",
    "broke-it.net",
    "buyshouses.net",
    "cechire.com",
    "dnsalias.com",
    "dnsalias.net",
    "dnsalias.org",
    "dnsdojo.com",
    "dnsdojo.net",
    "dnsdojo.org",
    "does-it.net",
    "doesntexist.com",
    "doesntexist.org",
    "dontexist.com",
    "dontexist.net",
    "dontexist.org",
    "doomdns.com",
    "doomdns.org",
    "dvrdns.org",
    "dyn-o-saur.com",
    "dynalias.com",
    "dynalias.net",
    "dynalias.org",
    "dynathome.net",
    "dyndns.ws",
    "endofinternet.net",
    "endofinternet.org",
    "endoftheinternet.org",
    "est-a-la-maison.com",
    "est-a-la-masion.com",
    "est-le-patron.com",
    "est-mon-blogueur.com",
    "for-better.biz",
    "for-more.biz",
    "for-our.info",
    "for-some.biz",
    "for-the.biz",
    "forgot.her.name",
    "forgot.his.name",
    "from-ak.com",
    "from-al.com",
    "from-ar.com",
    "from-az.net",
    "from-ca.com",
    "from-co.net",
    "from-ct.com",
    "from-dc.com",
    "from-de.com",
    "from-fl.com",
    "from-ga.com",
    "from-hi.com",
    "from-ia.com",
    "from-id.com",
    "from-il.com",
    "from-in.com",
    "from-ks.com",
    "from-ky.com",
    "from-la.net",
    "from-ma.com",
    "from-md.com",
    "from-me.org",
    "from-mi.com",
    "from-mn.com",
    "from-mo.com",
    "from-ms.com",
    "from-mt.com",
    "from-nc.com",
    "from-nd.com",
    "from-ne.com",
    "from-nh.com",
    "from-nj.com",
    "from-nm.com",
    "from-nv.com",
    "from-ny.net",
    "from-oh.com",
    "from-ok.com",
    "from-or.com",
    "from-pa.com",
    "from-pr.com",
    "from-ri.com",
    "from-sc.com",
    "from-sd.com",
    "from-tn.com",
    "from-tx.com",
    "from-ut.com",
    "from-va.com",
    "from-vt.com",
    "from-wa.com",
    "from-wi.com",
    "from-wv.com",
    "from-wy.com",
    "ftpaccess.cc",
    "fuettertdasnetz.de",
    "game-host.org",
    "game-server.cc",
    "getmyip.com",
    "gets-it.net",
    "go.dyndns.org",
    "gotdns.com",
    "gotdns.org",
    "groks-the.info",
    "groks-this.info",
    "ham-radio-op.net",
    "here-for-more.info",
    "hobby-site.com",
    "hobby-site.org",
    "home.dyndns.org",
    "homedns.org",
    "homeftp.net",
    "homeftp.org",
    "homeip.net",
    "homelinux.com",
    "homelinux.net",
    "homelinux.org",
    "homeunix.com",
    "homeunix.net",
    "homeunix.org",
    "iamallama.com",
    "in-the-band.net",
    "is-a-anarchist.com",
    "is-a-blogger.com",
    "is-a-bookkeeper.com",
    "is-a-bruinsfan.org",
    "is-a-bulls-fan.com",
    "is-a-candidate.org",
    "is-a-caterer.com",
    "is-a-celticsfan.org",
    "is-a-chef.com",
    "is-a-chef.net",
    "is-a-chef.org",
    "is-a-conservative.com",
    "is-a-cpa.com",
    "is-a-cubicle-slave.com",
    "is-a-democrat.com",
    "is-a-designer.com",
    "is-a-doctor.com",
    "is-a-financialadvisor.com",
    "is-a-geek.com",
    "is-a-geek.net",
    "is-a-geek.org",
    "is-a-green.com",
    "is-a-guru.com",
    "is-a-hard-worker.com",
    "is-a-hunter.com",
    "is-a-knight.org",
    "is-a-landscaper.com",
    "is-a-lawyer.com",
    "is-a-liberal.com",
    "is-a-libertarian.com",
    "is-a-linux-user.org",
    "is-a-llama.com",
    "is-a-musician.com",
    "is-a-nascarfan.com",
    "is-a-nurse.com",
    "is-a-painter.com",
    "is-a-patsfan.org",
    "is-a-personaltrainer.com",
    "is-a-photographer.com",
    "is-a-player.com",
    "is-a-republican.com",
    "is-a-rockstar.com",
    "is-a-socialist.com",
    "is-a-soxfan.org",
    "is-a-student.com",
    "is-a-teacher.com",
    "is-a-techie.com",
    "is-a-therapist.com",
    "is-an-accountant.com",
    "is-an-actor.com",
    "is-an-actress.com",
    "is-an-anarchist.com",
    "is-an-artist.com",
    "is-an-engineer.com",
    "is-an-entertainer.com",
    "is-by.us",
    "is-certified.com",
    "is-found.org",
    "is-gone.com",
    "is-into-anime.com",
    "is-into-cars.com",
    "is-into-cartoons.com",
    "is-into-games.com",
    "is-leet.com",
    "is-lost.org",
    "is-not-certified.com",
    "is-saved.org",
    "is-slick.com",
    "is-uberleet.com",
    "is-very-bad.org",
    "is-very-evil.org",
    "is-very-good.org",
    "is-very-nice.org",
    "is-very-sweet.org",
    "is-with-theband.com",
    "isa-geek.com",
    "isa-geek.net",
    "isa-geek.org",
    "isa-hockeynut.com",
    "issmarterthanyou.com",
    "isteingeek.de",
    "istmein.de",
    "kicks-ass.net",
    "kicks-ass.org",
    "knowsitall.info",
    "land-4-sale.us",
    "lebtimnetz.de",
    "leitungsen.de",
    "likes-pie.com",
    "likescandy.com",
    "merseine.nu",
    "mine.nu",
    "misconfused.org",
    "mypets.ws",
    "myphotos.cc",
    "neat-url.com",
    "office-on-the.net",
    "on-the-web.tv",
    "podzone.net",
    "podzone.org",
    "readmyblog.org",
    "saves-the-whales.com",
    "scrapper-site.net",
    "scrapping.cc",
    "selfip.biz",
    "selfip.com",
    "selfip.info",
    "selfip.net",
    "selfip.org",
    "sells-for-less.com",
    "sells-for-u.com",
    "sells-it.net",
    "sellsyourhome.org",
    "servebbs.com",
    "servebbs.net",
    "servebbs.org",
    "serveftp.net",
    "serveftp.org",
    "servegame.org",
    "shacknet.nu",
    "simple-url.com",
    "space-to-rent.com",
    "stuff-4-sale.org",
    "stuff-4-sale.us",
    "teaches-yoga.com",
    "thruhere.net",
    "traeumtgerade.de",
    "webhop.biz",
    "webhop.info",
    "webhop.net",
    "webhop.org",
    "worse-than.tv",
    "writesthisblog.com",
    "ddnss.de",
    "dyn.ddnss.de",
    "dyndns.ddnss.de",
    "dyndns1.de",
    "dyn-ip24.de",
    "home-webserver.de",
    "dyn.home-webserver.de",
    "myhome-server.de",
    "ddnss.org",
    "definima.net",
    "definima.io",
    "ondigitalocean.app",
    "*.digitaloceanspaces.com",
    "bci.dnstrace.pro",
    "ddnsfree.com",
    "ddnsgeek.com",
    "giize.com",
    "gleeze.com",
    "kozow.com",
    "loseyourip.com",
    "ooguy.com",
    "theworkpc.com",
    "casacam.net",
    "dynu.net",
    "accesscam.org",
    "camdvr.org",
    "freeddns.org",
    "mywire.org",
    "webredirect.org",
    "myddns.rocks",
    "blogsite.xyz",
    "dynv6.net",
    "e4.cz",
    "eero.online",
    "eero-stage.online",
    "elementor.cloud",
    "elementor.cool",
    "en-root.fr",
    "mytuleap.com",
    "tuleap-partners.com",
    "encr.app",
    "encoreapi.com",
    "onred.one",
    "staging.onred.one",
    "eu.encoway.cloud",
    "eu.org",
    "al.eu.org",
    "asso.eu.org",
    "at.eu.org",
    "au.eu.org",
    "be.eu.org",
    "bg.eu.org",
    "ca.eu.org",
    "cd.eu.org",
    "ch.eu.org",
    "cn.eu.org",
    "cy.eu.org",
    "cz.eu.org",
    "de.eu.org",
    "dk.eu.org",
    "edu.eu.org",
    "ee.eu.org",
    "es.eu.org",
    "fi.eu.org",
    "fr.eu.org",
    "gr.eu.org",
    "hr.eu.org",
    "hu.eu.org",
    "ie.eu.org",
    "il.eu.org",
    "in.eu.org",
    "int.eu.org",
    "is.eu.org",
    "it.eu.org",
    "jp.eu.org",
    "kr.eu.org",
    "lt.eu.org",
    "lu.eu.org",
    "lv.eu.org",
    "mc.eu.org",
    "me.eu.org",
    "mk.eu.org",
    "mt.eu.org",
    "my.eu.org",
    "net.eu.org",
    "ng.eu.org",
    "nl.eu.org",
    "no.eu.org",
    "nz.eu.org",
    "paris.eu.org",
    "pl.eu.org",
    "pt.eu.org",
    "q-a.eu.org",
    "ro.eu.org",
    "ru.eu.org",
    "se.eu.org",
    "si.eu.org",
    "sk.eu.org",
    "tr.eu.org",
    "uk.eu.org",
    "us.eu.org",
    "eurodir.ru",
    "eu-1.evennode.com",
    "eu-2.evennode.com",
    "eu-3.evennode.com",
    "eu-4.evennode.com",
    "us-1.evennode.com",
    "us-2.evennode.com",
    "us-3.evennode.com",
    "us-4.evennode.com",
    "twmail.cc",
    "twmail.net",
    "twmail.org",
    "mymailer.com.tw",
    "url.tw",
    "onfabrica.com",
    "apps.fbsbx.com",
    "ru.net",
    "adygeya.ru",
    "bashkiria.ru",
    "bir.ru",
    "cbg.ru",
    "com.ru",
    "dagestan.ru",
    "grozny.ru",
    "kalmykia.ru",
    "kustanai.ru",
    "marine.ru",
    "mordovia.ru",
    "msk.ru",
    "mytis.ru",
    "nalchik.ru",
    "nov.ru",
    "pyatigorsk.ru",
    "spb.ru",
    "vladikavkaz.ru",
    "vladimir.ru",
    "abkhazia.su",
    "adygeya.su",
    "aktyubinsk.su",
    "arkhangelsk.su",
    "armenia.su",
    "ashgabad.su",
    "azerbaijan.su",
    "balashov.su",
    "bashkiria.su",
    "bryansk.su",
    "bukhara.su",
    "chimkent.su",
    "dagestan.su",
    "east-kazakhstan.su",
    "exnet.su",
    "georgia.su",
    "grozny.su",
    "ivanovo.su",
    "jambyl.su",
    "kalmykia.su",
    "kaluga.su",
    "karacol.su",
    "karaganda.su",
    "karelia.su",
    "khakassia.su",
    "krasnodar.su",
    "kurgan.su",
    "kustanai.su",
    "lenug.su",
    "mangyshlak.su",
    "mordovia.su",
    "msk.su",
    "murmansk.su",
    "nalchik.su",
    "navoi.su",
    "north-kazakhstan.su",
    "nov.su",
    "obninsk.su",
    "penza.su",
    "pokrovsk.su",
    "sochi.su",
    "spb.su",
    "tashkent.su",
    "termez.su",
    "togliatti.su",
    "troitsk.su",
    "tselinograd.su",
    "tula.su",
    "tuva.su",
    "vladikavkaz.su",
    "vladimir.su",
    "vologda.su",
    "channelsdvr.net",
    "u.channelsdvr.net",
    "edgecompute.app",
    "fastly-terrarium.com",
    "fastlylb.net",
    "map.fastlylb.net",
    "freetls.fastly.net",
    "map.fastly.net",
    "a.prod.fastly.net",
    "global.prod.fastly.net",
    "a.ssl.fastly.net",
    "b.ssl.fastly.net",
    "global.ssl.fastly.net",
    "fastvps-server.com",
    "fastvps.host",
    "myfast.host",
    "fastvps.site",
    "myfast.space",
    "fedorainfracloud.org",
    "fedorapeople.org",
    "cloud.fedoraproject.org",
    "app.os.fedoraproject.org",
    "app.os.stg.fedoraproject.org",
    "conn.uk",
    "copro.uk",
    "hosp.uk",
    "mydobiss.com",
    "fh-muenster.io",
    "filegear.me",
    "filegear-au.me",
    "filegear-de.me",
    "filegear-gb.me",
    "filegear-ie.me",
    "filegear-jp.me",
    "filegear-sg.me",
    "firebaseapp.com",
    "fireweb.app",
    "flap.id",
    "onflashdrive.app",
    "fldrv.com",
    "fly.dev",
    "edgeapp.net",
    "shw.io",
    "flynnhosting.net",
    "forgeblocks.com",
    "id.forgerock.io",
    "framer.app",
    "framercanvas.com",
    "*.frusky.de",
    "ravpage.co.il",
    "0e.vc",
    "freebox-os.com",
    "freeboxos.com",
    "fbx-os.fr",
    "fbxos.fr",
    "freebox-os.fr",
    "freeboxos.fr",
    "freedesktop.org",
    "freemyip.com",
    "wien.funkfeuer.at",
    "*.futurecms.at",
    "*.ex.futurecms.at",
    "*.in.futurecms.at",
    "futurehosting.at",
    "futuremailing.at",
    "*.ex.ortsinfo.at",
    "*.kunden.ortsinfo.at",
    "*.statics.cloud",
    "independent-commission.uk",
    "independent-inquest.uk",
    "independent-inquiry.uk",
    "independent-panel.uk",
    "independent-review.uk",
    "public-inquiry.uk",
    "royal-commission.uk",
    "campaign.gov.uk",
    "service.gov.uk",
    "api.gov.uk",
    "gehirn.ne.jp",
    "usercontent.jp",
    "gentapps.com",
    "gentlentapis.com",
    "lab.ms",
    "cdn-edges.net",
    "ghost.io",
    "gsj.bz",
    "githubusercontent.com",
    "githubpreview.dev",
    "github.io",
    "gitlab.io",
    "gitapp.si",
    "gitpage.si",
    "glitch.me",
    "nog.community",
    "co.ro",
    "shop.ro",
    "lolipop.io",
    "angry.jp",
    "babyblue.jp",
    "babymilk.jp",
    "backdrop.jp",
    "bambina.jp",
    "bitter.jp",
    "blush.jp",
    "boo.jp",
    "boy.jp",
    "boyfriend.jp",
    "but.jp",
    "candypop.jp",
    "capoo.jp",
    "catfood.jp",
    "cheap.jp",
    "chicappa.jp",
    "chillout.jp",
    "chips.jp",
    "chowder.jp",
    "chu.jp",
    "ciao.jp",
    "cocotte.jp",
    "coolblog.jp",
    "cranky.jp",
    "cutegirl.jp",
    "daa.jp",
    "deca.jp",
    "deci.jp",
    "digick.jp",
    "egoism.jp",
    "fakefur.jp",
    "fem.jp",
    "flier.jp",
    "floppy.jp",
    "fool.jp",
    "frenchkiss.jp",
    "girlfriend.jp",
    "girly.jp",
    "gloomy.jp",
    "gonna.jp",
    "greater.jp",
    "hacca.jp",
    "heavy.jp",
    "her.jp",
    "hiho.jp",
    "hippy.jp",
    "holy.jp",
    "hungry.jp",
    "icurus.jp",
    "itigo.jp",
    "jellybean.jp",
    "kikirara.jp",
    "kill.jp",
    "kilo.jp",
    "kuron.jp",
    "littlestar.jp",
    "lolipopmc.jp",
    "lolitapunk.jp",
    "lomo.jp",
    "lovepop.jp",
    "lovesick.jp",
    "main.jp",
    "mods.jp",
    "mond.jp",
    "mongolian.jp",
    "moo.jp",
    "namaste.jp",
    "nikita.jp",
    "nobushi.jp",
    "noor.jp",
    "oops.jp",
    "parallel.jp",
    "parasite.jp",
    "pecori.jp",
    "peewee.jp",
    "penne.jp",
    "pepper.jp",
    "perma.jp",
    "pigboat.jp",
    "pinoko.jp",
    "punyu.jp",
    "pupu.jp",
    "pussycat.jp",
    "pya.jp",
    "raindrop.jp",
    "readymade.jp",
    "sadist.jp",
    "schoolbus.jp",
    "secret.jp",
    "staba.jp",
    "stripper.jp",
    "sub.jp",
    "sunnyday.jp",
    "thick.jp",
    "tonkotsu.jp",
    "under.jp",
    "upper.jp",
    "velvet.jp",
    "verse.jp",
    "versus.jp",
    "vivian.jp",
    "watson.jp",
    "weblike.jp",
    "whitesnow.jp",
    "zombie.jp",
    "heteml.net",
    "cloudapps.digital",
    "london.cloudapps.digital",
    "pymnt.uk",
    "homeoffice.gov.uk",
    "ro.im",
    "goip.de",
    "run.app",
    "a.run.app",
    "web.app",
    "*.0emm.com",
    "appspot.com",
    "*.r.appspot.com",
    "codespot.com",
    "googleapis.com",
    "googlecode.com",
    "pagespeedmobilizer.com",
    "publishproxy.com",
    "withgoogle.com",
    "withyoutube.com",
    "*.gateway.dev",
    "cloud.goog",
    "translate.goog",
    "*.usercontent.goog",
    "cloudfunctions.net",
    "blogspot.ae",
    "blogspot.al",
    "blogspot.am",
    "blogspot.ba",
    "blogspot.be",
    "blogspot.bg",
    "blogspot.bj",
    "blogspot.ca",
    "blogspot.cf",
    "blogspot.ch",
    "blogspot.cl",
    "blogspot.co.at",
    "blogspot.co.id",
    "blogspot.co.il",
    "blogspot.co.ke",
    "blogspot.co.nz",
    "blogspot.co.uk",
    "blogspot.co.za",
    "blogspot.com",
    "blogspot.com.ar",
    "blogspot.com.au",
    "blogspot.com.br",
    "blogspot.com.by",
    "blogspot.com.co",
    "blogspot.com.cy",
    "blogspot.com.ee",
    "blogspot.com.eg",
    "blogspot.com.es",
    "blogspot.com.mt",
    "blogspot.com.ng",
    "blogspot.com.tr",
    "blogspot.com.uy",
    "blogspot.cv",
    "blogspot.cz",
    "blogspot.de",
    "blogspot.dk",
    "blogspot.fi",
    "blogspot.fr",
    "blogspot.gr",
    "blogspot.hk",
    "blogspot.hr",
    "blogspot.hu",
    "blogspot.ie",
    "blogspot.in",
    "blogspot.is",
    "blogspot.it",
    "blogspot.jp",
    "blogspot.kr",
    "blogspot.li",
    "blogspot.lt",
    "blogspot.lu",
    "blogspot.md",
    "blogspot.mk",
    "blogspot.mr",
    "blogspot.mx",
    "blogspot.my",
    "blogspot.nl",
    "blogspot.no",
    "blogspot.pe",
    "blogspot.pt",
    "blogspot.qa",
    "blogspot.re",
    "blogspot.ro",
    "blogspot.rs",
    "blogspot.ru",
    "blogspot.se",
    "blogspot.sg",
    "blogspot.si",
    "blogspot.sk",
    "blogspot.sn",
    "blogspot.td",
    "blogspot.tw",
    "blogspot.ug",
    "blogspot.vn",
    "goupile.fr",
    "gov.nl",
    "awsmppl.com",
    "günstigbestellen.de",
    "günstigliefern.de",
    "fin.ci",
    "free.hr",
    "caa.li",
    "ua.rs",
    "conf.se",
    "hs.zone",
    "hs.run",
    "hashbang.sh",
    "hasura.app",
    "hasura-app.io",
    "pages.it.hs-heilbronn.de",
    "hepforge.org",
    "herokuapp.com",
    "herokussl.com",
    "ravendb.cloud",
    "myravendb.com",
    "ravendb.community",
    "ravendb.me",
    "development.run",
    "ravendb.run",
    "homesklep.pl",
    "secaas.hk",
    "hoplix.shop",
    "orx.biz",
    "biz.gl",
    "col.ng",
    "firm.ng",
    "gen.ng",
    "ltd.ng",
    "ngo.ng",
    "edu.scot",
    "sch.so",
    "hostyhosting.io",
    "häkkinen.fi",
    "*.moonscale.io",
    "moonscale.net",
    "iki.fi",
    "ibxos.it",
    "iliadboxos.it",
    "impertrixcdn.com",
    "impertrix.com",
    "smushcdn.com",
    "wphostedmail.com",
    "wpmucdn.com",
    "tempurl.host",
    "wpmudev.host",
    "dyn-berlin.de",
    "in-berlin.de",
    "in-brb.de",
    "in-butter.de",
    "in-dsl.de",
    "in-dsl.net",
    "in-dsl.org",
    "in-vpn.de",
    "in-vpn.net",
    "in-vpn.org",
    "biz.at",
    "info.at",
    "info.cx",
    "ac.leg.br",
    "al.leg.br",
    "am.leg.br",
    "ap.leg.br",
    "ba.leg.br",
    "ce.leg.br",
    "df.leg.br",
    "es.leg.br",
    "go.leg.br",
    "ma.leg.br",
    "mg.leg.br",
    "ms.leg.br",
    "mt.leg.br",
    "pa.leg.br",
    "pb.leg.br",
    "pe.leg.br",
    "pi.leg.br",
    "pr.leg.br",
    "rj.leg.br",
    "rn.leg.br",
    "ro.leg.br",
    "rr.leg.br",
    "rs.leg.br",
    "sc.leg.br",
    "se.leg.br",
    "sp.leg.br",
    "to.leg.br",
    "pixolino.com",
    "na4u.ru",
    "iopsys.se",
    "ipifony.net",
    "iservschule.de",
    "mein-iserv.de",
    "schulplattform.de",
    "schulserver.de",
    "test-iserv.de",
    "iserv.dev",
    "iobb.net",
    "mel.cloudlets.com.au",
    "cloud.interhostsolutions.be",
    "users.scale.virtualcloud.com.br",
    "mycloud.by",
    "alp1.ae.flow.ch",
    "appengine.flow.ch",
    "es-1.axarnet.cloud",
    "diadem.cloud",
    "vip.jelastic.cloud",
    "jele.cloud",
    "it1.eur.aruba.jenv-aruba.cloud",
    "it1.jenv-aruba.cloud",
    "keliweb.cloud",
    "cs.keliweb.cloud",
    "oxa.cloud",
    "tn.oxa.cloud",
    "uk.oxa.cloud",
    "primetel.cloud",
    "uk.primetel.cloud",
    "ca.reclaim.cloud",
    "uk.reclaim.cloud",
    "us.reclaim.cloud",
    "ch.trendhosting.cloud",
    "de.trendhosting.cloud",
    "jele.club",
    "amscompute.com",
    "clicketcloud.com",
    "dopaas.com",
    "hidora.com",
    "paas.hosted-by-previder.com",
    "rag-cloud.hosteur.com",
    "rag-cloud-ch.hosteur.com",
    "jcloud.ik-server.com",
    "jcloud-ver-jpc.ik-server.com",
    "demo.jelastic.com",
    "kilatiron.com",
    "paas.massivegrid.com",
    "jed.wafaicloud.com",
    "lon.wafaicloud.com",
    "ryd.wafaicloud.com",
    "j.scaleforce.com.cy",
    "jelastic.dogado.eu",
    "fi.cloudplatform.fi",
    "demo.datacenter.fi",
    "paas.datacenter.fi",
    "jele.host",
    "mircloud.host",
    "paas.beebyte.io",
    "sekd1.beebyteapp.io",
    "jele.io",
    "cloud-fr1.unispace.io",
    "jc.neen.it",
    "cloud.jelastic.open.tim.it",
    "jcloud.kz",
    "upaas.kazteleport.kz",
    "cloudjiffy.net",
    "fra1-de.cloudjiffy.net",
    "west1-us.cloudjiffy.net",
    "jls-sto1.elastx.net",
    "jls-sto2.elastx.net",
    "jls-sto3.elastx.net",
    "faststacks.net",
    "fr-1.paas.massivegrid.net",
    "lon-1.paas.massivegrid.net",
    "lon-2.paas.massivegrid.net",
    "ny-1.paas.massivegrid.net",
    "ny-2.paas.massivegrid.net",
    "sg-1.paas.massivegrid.net",
    "jelastic.saveincloud.net",
    "nordeste-idc.saveincloud.net",
    "j.scaleforce.net",
    "jelastic.tsukaeru.net",
    "sdscloud.pl",
    "unicloud.pl",
    "mircloud.ru",
    "jelastic.regruhosting.ru",
    "enscaled.sg",
    "jele.site",
    "jelastic.team",
    "orangecloud.tn",
    "j.layershift.co.uk",
    "phx.enscaled.us",
    "mircloud.us",
    "myjino.ru",
    "*.hosting.myjino.ru",
    "*.landing.myjino.ru",
    "*.spectrum.myjino.ru",
    "*.vps.myjino.ru",
    "jotelulu.cloud",
    "*.triton.zone",
    "*.cns.joyent.com",
    "js.org",
    "kaas.gg",
    "khplay.nl",
    "ktistory.com",
    "kapsi.fi",
    "keymachine.de",
    "kinghost.net",
    "uni5.net",
    "knightpoint.systems",
    "koobin.events",
    "oya.to",
    "kuleuven.cloud",
    "ezproxy.kuleuven.be",
    "co.krd",
    "edu.krd",
    "krellian.net",
    "webthings.io",
    "git-repos.de",
    "lcube-server.de",
    "svn-repos.de",
    "leadpages.co",
    "lpages.co",
    "lpusercontent.com",
    "lelux.site",
    "co.business",
    "co.education",
    "co.events",
    "co.financial",
    "co.network",
    "co.place",
    "co.technology",
    "app.lmpm.com",
    "linkyard.cloud",
    "linkyard-cloud.ch",
    "members.linode.com",
    "*.nodebalancer.linode.com",
    "*.linodeobjects.com",
    "ip.linodeusercontent.com",
    "we.bs",
    "*.user.localcert.dev",
    "localzone.xyz",
    "loginline.app",
    "loginline.dev",
    "loginline.io",
    "loginline.services",
    "loginline.site",
    "servers.run",
    "lohmus.me",
    "krasnik.pl",
    "leczna.pl",
    "lubartow.pl",
    "lublin.pl",
    "poniatowa.pl",
    "swidnik.pl",
    "glug.org.uk",
    "lug.org.uk",
    "lugs.org.uk",
    "barsy.bg",
    "barsy.co.uk",
    "barsyonline.co.uk",
    "barsycenter.com",
    "barsyonline.com",
    "barsy.club",
    "barsy.de",
    "barsy.eu",
    "barsy.in",
    "barsy.info",
    "barsy.io",
    "barsy.me",
    "barsy.menu",
    "barsy.mobi",
    "barsy.net",
    "barsy.online",
    "barsy.org",
    "barsy.pro",
    "barsy.pub",
    "barsy.ro",
    "barsy.shop",
    "barsy.site",
    "barsy.support",
    "barsy.uk",
    "*.magentosite.cloud",
    "mayfirst.info",
    "mayfirst.org",
    "hb.cldmail.ru",
    "cn.vu",
    "mazeplay.com",
    "mcpe.me",
    "mcdir.me",
    "mcdir.ru",
    "mcpre.ru",
    "vps.mcdir.ru",
    "mediatech.by",
    "mediatech.dev",
    "hra.health",
    "miniserver.com",
    "memset.net",
    "messerli.app",
    "*.cloud.metacentrum.cz",
    "custom.metacentrum.cz",
    "flt.cloud.muni.cz",
    "usr.cloud.muni.cz",
    "meteorapp.com",
    "eu.meteorapp.com",
    "co.pl",
    "*.azurecontainer.io",
    "azurewebsites.net",
    "azure-mobile.net",
    "cloudapp.net",
    "azurestaticapps.net",
    "1.azurestaticapps.net",
    "centralus.azurestaticapps.net",
    "eastasia.azurestaticapps.net",
    "eastus2.azurestaticapps.net",
    "westeurope.azurestaticapps.net",
    "westus2.azurestaticapps.net",
    "csx.cc",
    "mintere.site",
    "forte.id",
    "mozilla-iot.org",
    "bmoattachments.org",
    "net.ru",
    "org.ru",
    "pp.ru",
    "hostedpi.com",
    "customer.mythic-beasts.com",
    "caracal.mythic-beasts.com",
    "fentiger.mythic-beasts.com",
    "lynx.mythic-beasts.com",
    "ocelot.mythic-beasts.com",
    "oncilla.mythic-beasts.com",
    "onza.mythic-beasts.com",
    "sphinx.mythic-beasts.com",
    "vs.mythic-beasts.com",
    "x.mythic-beasts.com",
    "yali.mythic-beasts.com",
    "cust.retrosnub.co.uk",
    "ui.nabu.casa",
    "pony.club",
    "of.fashion",
    "in.london",
    "of.london",
    "from.marketing",
    "with.marketing",
    "for.men",
    "repair.men",
    "and.mom",
    "for.mom",
    "for.one",
    "under.one",
    "for.sale",
    "that.win",
    "from.work",
    "to.work",
    "cloud.nospamproxy.com",
    "netlify.app",
    "4u.com",
    "ngrok.io",
    "nh-serv.co.uk",
    "nfshost.com",
    "*.developer.app",
    "noop.app",
    "*.northflank.app",
    "*.build.run",
    "*.code.run",
    "*.database.run",
    "*.migration.run",
    "noticeable.news",
    "dnsking.ch",
    "mypi.co",
    "n4t.co",
    "001www.com",
    "ddnslive.com",
    "myiphost.com",
    "forumz.info",
    "16-b.it",
    "32-b.it",
    "64-b.it",
    "soundcast.me",
    "tcp4.me",
    "dnsup.net",
    "hicam.net",
    "now-dns.net",
    "ownip.net",
    "vpndns.net",
    "dynserv.org",
    "now-dns.org",
    "x443.pw",
    "now-dns.top",
    "ntdll.top",
    "freeddns.us",
    "crafting.xyz",
    "zapto.xyz",
    "nsupdate.info",
    "nerdpol.ovh",
    "blogsyte.com",
    "brasilia.me",
    "cable-modem.org",
    "ciscofreak.com",
    "collegefan.org",
    "couchpotatofries.org",
    "damnserver.com",
    "ddns.me",
    "ditchyourip.com",
    "dnsfor.me",
    "dnsiskinky.com",
    "dvrcam.info",
    "dynns.com",
    "eating-organic.net",
    "fantasyleague.cc",
    "geekgalaxy.com",
    "golffan.us",
    "health-carereform.com",
    "homesecuritymac.com",
    "homesecuritypc.com",
    "hopto.me",
    "ilovecollege.info",
    "loginto.me",
    "mlbfan.org",
    "mmafan.biz",
    "myactivedirectory.com",
    "mydissent.net",
    "myeffect.net",
    "mymediapc.net",
    "mypsx.net",
    "mysecuritycamera.com",
    "mysecuritycamera.net",
    "mysecuritycamera.org",
    "net-freaks.com",
    "nflfan.org",
    "nhlfan.net",
    "no-ip.ca",
    "no-ip.co.uk",
    "no-ip.net",
    "noip.us",
    "onthewifi.com",
    "pgafan.net",
    "point2this.com",
    "pointto.us",
    "privatizehealthinsurance.net",
    "quicksytes.com",
    "read-books.org",
    "securitytactics.com",
    "serveexchange.com",
    "servehumour.com",
    "servep2p.com",
    "servesarcasm.com",
    "stufftoread.com",
    "ufcfan.org",
    "unusualperson.com",
    "workisboring.com",
    "3utilities.com",
    "bounceme.net",
    "ddns.net",
    "ddnsking.com",
    "gotdns.ch",
    "hopto.org",
    "myftp.biz",
    "myftp.org",
    "myvnc.com",
    "no-ip.biz",
    "no-ip.info",
    "no-ip.org",
    "noip.me",
    "redirectme.net",
    "servebeer.com",
    "serveblog.net",
    "servecounterstrike.com",
    "serveftp.com",
    "servegame.com",
    "servehalflife.com",
    "servehttp.com",
    "serveirc.com",
    "serveminecraft.net",
    "servemp3.com",
    "servepics.com",
    "servequake.com",
    "sytes.net",
    "webhop.me",
    "zapto.org",
    "stage.nodeart.io",
    "pcloud.host",
    "nyc.mn",
    "static.observableusercontent.com",
    "cya.gg",
    "omg.lol",
    "cloudycluster.net",
    "omniwe.site",
    "service.one",
    "nid.io",
    "opensocial.site",
    "opencraft.hosting",
    "orsites.com",
    "operaunite.com",
    "tech.orange",
    "authgear-staging.com",
    "authgearapps.com",
    "skygearapp.com",
    "outsystemscloud.com",
    "*.webpaas.ovh.net",
    "*.hosting.ovh.net",
    "ownprovider.com",
    "own.pm",
    "*.owo.codes",
    "ox.rs",
    "oy.lc",
    "pgfog.com",
    "pagefrontapp.com",
    "pagexl.com",
    "*.paywhirl.com",
    "bar0.net",
    "bar1.net",
    "bar2.net",
    "rdv.to",
    "art.pl",
    "gliwice.pl",
    "krakow.pl",
    "poznan.pl",
    "wroc.pl",
    "zakopane.pl",
    "pantheonsite.io",
    "gotpantheon.com",
    "mypep.link",
    "perspecta.cloud",
    "lk3.ru",
    "on-web.fr",
    "bc.platform.sh",
    "ent.platform.sh",
    "eu.platform.sh",
    "us.platform.sh",
    "*.platformsh.site",
    "*.tst.site",
    "platter-app.com",
    "platter-app.dev",
    "platterp.us",
    "pdns.page",
    "plesk.page",
    "pleskns.com",
    "dyn53.io",
    "onporter.run",
    "co.bn",
    "postman-echo.com",
    "pstmn.io",
    "mock.pstmn.io",
    "httpbin.org",
    "prequalifyme.today",
    "xen.prgmr.com",
    "priv.at",
    "prvcy.page",
    "*.dweb.link",
    "protonet.io",
    "chirurgiens-dentistes-en-france.fr",
    "byen.site",
    "pubtls.org",
    "pythonanywhere.com",
    "eu.pythonanywhere.com",
    "qoto.io",
    "qualifioapp.com",
    "qbuser.com",
    "cloudsite.builders",
    "instances.spawn.cc",
    "instantcloud.cn",
    "ras.ru",
    "qa2.com",
    "qcx.io",
    "*.sys.qcx.io",
    "dev-myqnapcloud.com",
    "alpha-myqnapcloud.com",
    "myqnapcloud.com",
    "*.quipelements.com",
    "vapor.cloud",
    "vaporcloud.io",
    "rackmaze.com",
    "rackmaze.net",
    "g.vbrplsbx.io",
    "*.on-k3s.io",
    "*.on-rancher.cloud",
    "*.on-rio.io",
    "readthedocs.io",
    "rhcloud.com",
    "app.render.com",
    "onrender.com",
    "repl.co",
    "id.repl.co",
    "repl.run",
    "resindevice.io",
    "devices.resinstaging.io",
    "hzc.io",
    "wellbeingzone.eu",
    "wellbeingzone.co.uk",
    "adimo.co.uk",
    "itcouldbewor.se",
    "git-pages.rit.edu",
    "rocky.page",
    "биз.рус",
    "ком.рус",
    "крым.рус",
    "мир.рус",
    "мск.рус",
    "орг.рус",
    "самара.рус",
    "сочи.рус",
    "спб.рус",
    "я.рус",
    "*.builder.code.com",
    "*.dev-builder.code.com",
    "*.stg-builder.code.com",
    "sandcats.io",
    "logoip.de",
    "logoip.com",
    "fr-par-1.baremetal.scw.cloud",
    "fr-par-2.baremetal.scw.cloud",
    "nl-ams-1.baremetal.scw.cloud",
    "fnc.fr-par.scw.cloud",
    "functions.fnc.fr-par.scw.cloud",
    "k8s.fr-par.scw.cloud",
    "nodes.k8s.fr-par.scw.cloud",
    "s3.fr-par.scw.cloud",
    "s3-website.fr-par.scw.cloud",
    "whm.fr-par.scw.cloud",
    "priv.instances.scw.cloud",
    "pub.instances.scw.cloud",
    "k8s.scw.cloud",
    "k8s.nl-ams.scw.cloud",
    "nodes.k8s.nl-ams.scw.cloud",
    "s3.nl-ams.scw.cloud",
    "s3-website.nl-ams.scw.cloud",
    "whm.nl-ams.scw.cloud",
    "k8s.pl-waw.scw.cloud",
    "nodes.k8s.pl-waw.scw.cloud",
    "s3.pl-waw.scw.cloud",
    "s3-website.pl-waw.scw.cloud",
    "scalebook.scw.cloud",
    "smartlabeling.scw.cloud",
    "dedibox.fr",
    "schokokeks.net",
    "gov.scot",
    "service.gov.scot",
    "scrysec.com",
    "firewall-gateway.com",
    "firewall-gateway.de",
    "my-gateway.de",
    "my-router.de",
    "spdns.de",
    "spdns.eu",
    "firewall-gateway.net",
    "my-firewall.org",
    "myfirewall.org",
    "spdns.org",
    "seidat.net",
    "sellfy.store",
    "senseering.net",
    "minisite.ms",
    "magnet.page",
    "biz.ua",
    "co.ua",
    "pp.ua",
    "shiftcrypto.dev",
    "shiftcrypto.io",
    "shiftedit.io",
    "myshopblocks.com",
    "myshopify.com",
    "shopitsite.com",
    "shopware.store",
    "mo-siemens.io",
    "1kapp.com",
    "appchizi.com",
    "applinzi.com",
    "sinaapp.com",
    "vipsinaapp.com",
    "siteleaf.net",
    "bounty-full.com",
    "alpha.bounty-full.com",
    "beta.bounty-full.com",
    "small-web.org",
    "vp4.me",
    "try-snowplow.com",
    "srht.site",
    "stackhero-network.com",
    "musician.io",
    "novecore.site",
    "static.land",
    "dev.static.land",
    "sites.static.land",
    "storebase.store",
    "vps-host.net",
    "atl.jelastic.vps-host.net",
    "njs.jelastic.vps-host.net",
    "ric.jelastic.vps-host.net",
    "playstation-cloud.com",
    "apps.lair.io",
    "*.stolos.io",
    "spacekit.io",
    "customer.speedpartner.de",
    "myspreadshop.at",
    "myspreadshop.com.au",
    "myspreadshop.be",
    "myspreadshop.ca",
    "myspreadshop.ch",
    "myspreadshop.com",
    "myspreadshop.de",
    "myspreadshop.dk",
    "myspreadshop.es",
    "myspreadshop.fi",
    "myspreadshop.fr",
    "myspreadshop.ie",
    "myspreadshop.it",
    "myspreadshop.net",
    "myspreadshop.nl",
    "myspreadshop.no",
    "myspreadshop.pl",
    "myspreadshop.se",
    "myspreadshop.co.uk",
    "api.stdlib.com",
    "storj.farm",
    "utwente.io",
    "soc.srcf.net",
    "user.srcf.net",
    "temp-dns.com",
    "supabase.co",
    "supabase.in",
    "supabase.net",
    "su.paba.se",
    "*.s5y.io",
    "*.sensiosite.cloud",
    "syncloud.it",
    "dscloud.biz",
    "direct.quickconnect.cn",
    "dsmynas.com",
    "familyds.com",
    "diskstation.me",
    "dscloud.me",
    "i234.me",
    "myds.me",
    "synology.me",
    "dscloud.mobi",
    "dsmynas.net",
    "familyds.net",
    "dsmynas.org",
    "familyds.org",
    "vpnplus.to",
    "direct.quickconnect.to",
    "tabitorder.co.il",
    "taifun-dns.de",
    "beta.tailscale.net",
    "ts.net",
    "gda.pl",
    "gdansk.pl",
    "gdynia.pl",
    "med.pl",
    "sopot.pl",
    "site.tb-hosting.com",
    "edugit.io",
    "s3.teckids.org",
    "telebit.app",
    "telebit.io",
    "*.telebit.xyz",
    "gwiddle.co.uk",
    "*.firenet.ch",
    "*.svc.firenet.ch",
    "reservd.com",
    "thingdustdata.com",
    "cust.dev.thingdust.io",
    "cust.disrec.thingdust.io",
    "cust.prod.thingdust.io",
    "cust.testing.thingdust.io",
    "reservd.dev.thingdust.io",
    "reservd.disrec.thingdust.io",
    "reservd.testing.thingdust.io",
    "tickets.io",
    "arvo.network",
    "azimuth.network",
    "tlon.network",
    "torproject.net",
    "pages.torproject.net",
    "bloxcms.com",
    "townnews-staging.com",
    "tbits.me",
    "12hp.at",
    "2ix.at",
    "4lima.at",
    "lima-city.at",
    "12hp.ch",
    "2ix.ch",
    "4lima.ch",
    "lima-city.ch",
    "trafficplex.cloud",
    "de.cool",
    "12hp.de",
    "2ix.de",
    "4lima.de",
    "lima-city.de",
    "1337.pictures",
    "clan.rip",
    "lima-city.rocks",
    "webspace.rocks",
    "lima.zone",
    "*.transurl.be",
    "*.transurl.eu",
    "*.transurl.nl",
    "site.transip.me",
    "tuxfamily.org",
    "dd-dns.de",
    "diskstation.eu",
    "diskstation.org",
    "dray-dns.de",
    "draydns.de",
    "dyn-vpn.de",
    "dynvpn.de",
    "mein-vigor.de",
    "my-vigor.de",
    "my-wan.de",
    "syno-ds.de",
    "synology-diskstation.de",
    "synology-ds.de",
    "typedream.app",
    "pro.typeform.com",
    "uber.space",
    "*.uberspace.de",
    "hk.com",
    "hk.org",
    "ltd.hk",
    "inc.hk",
    "name.pm",
    "sch.tf",
    "biz.wf",
    "sch.wf",
    "org.yt",
    "virtualuser.de",
    "virtual-user.de",
    "upli.io",
    "urown.cloud",
    "dnsupdate.info",
    "lib.de.us",
    "2038.io",
    "vercel.app",
    "vercel.dev",
    "now.sh",
    "router.management",
    "v-info.info",
    "voorloper.cloud",
    "neko.am",
    "nyaa.am",
    "be.ax",
    "cat.ax",
    "es.ax",
    "eu.ax",
    "gg.ax",
    "mc.ax",
    "us.ax",
    "xy.ax",
    "nl.ci",
    "xx.gl",
    "app.gp",
    "blog.gt",
    "de.gt",
    "to.gt",
    "be.gy",
    "cc.hn",
    "blog.kg",
    "io.kg",
    "jp.kg",
    "tv.kg",
    "uk.kg",
    "us.kg",
    "de.ls",
    "at.md",
    "de.md",
    "jp.md",
    "to.md",
    "indie.porn",
    "vxl.sh",
    "ch.tc",
    "me.tc",
    "we.tc",
    "nyan.to",
    "at.vg",
    "blog.vu",
    "dev.vu",
    "me.vu",
    "v.ua",
    "*.vultrobjects.com",
    "wafflecell.com",
    "*.webhare.dev",
    "reserve-online.net",
    "reserve-online.com",
    "bookonline.app",
    "hotelwithflight.com",
    "wedeploy.io",
    "wedeploy.me",
    "wedeploy.sh",
    "remotewd.com",
    "pages.wiardweb.com",
    "wmflabs.org",
    "toolforge.org",
    "wmcloud.org",
    "panel.gg",
    "daemon.panel.gg",
    "messwithdns.com",
    "woltlab-demo.com",
    "myforum.community",
    "community-pro.de",
    "diskussionsbereich.de",
    "community-pro.net",
    "meinforum.net",
    "affinitylottery.org.uk",
    "raffleentry.org.uk",
    "weeklylottery.org.uk",
    "wpenginepowered.com",
    "js.wpenginepowered.com",
    "wixsite.com",
    "editorx.io",
    "half.host",
    "xnbay.com",
    "u2.xnbay.com",
    "u2-local.xnbay.com",
    "cistron.nl",
    "demon.nl",
    "xs4all.space",
    "yandexcloud.net",
    "storage.yandexcloud.net",
    "website.yandexcloud.net",
    "official.academy",
    "yolasite.com",
    "ybo.faith",
    "yombo.me",
    "homelink.one",
    "ybo.party",
    "ybo.review",
    "ybo.science",
    "ybo.trade",
    "ynh.fr",
    "nohost.me",
    "noho.st",
    "za.net",
    "za.org",
    "bss.design",
    "basicserver.io",
    "virtualserver.io",
    "enterprisecloud.nu"
  ];
  (function(exports) {
    var Punycode = require$$0;
    var internals = {};
    internals.rules = require$$1.map(function(rule) {
      return {
        rule,
        suffix: rule.replace(/^(\*\.|\!)/, ""),
        punySuffix: -1,
        wildcard: rule.charAt(0) === "*",
        exception: rule.charAt(0) === "!"
      };
    });
    internals.endsWith = function(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    internals.findRule = function(domain) {
      var punyDomain = Punycode.toASCII(domain);
      return internals.rules.reduce(function(memo, rule) {
        if (rule.punySuffix === -1) {
          rule.punySuffix = Punycode.toASCII(rule.suffix);
        }
        if (!internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix) {
          return memo;
        }
        return rule;
      }, null);
    };
    exports.errorCodes = {
      DOMAIN_TOO_SHORT: "Domain name too short.",
      DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
      LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
      LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
      LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
      LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
      LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
    };
    internals.validate = function(input) {
      var ascii = Punycode.toASCII(input);
      if (ascii.length < 1) {
        return "DOMAIN_TOO_SHORT";
      }
      if (ascii.length > 255) {
        return "DOMAIN_TOO_LONG";
      }
      var labels = ascii.split(".");
      var label;
      for (var i2 = 0; i2 < labels.length; ++i2) {
        label = labels[i2];
        if (!label.length) {
          return "LABEL_TOO_SHORT";
        }
        if (label.length > 63) {
          return "LABEL_TOO_LONG";
        }
        if (label.charAt(0) === "-") {
          return "LABEL_STARTS_WITH_DASH";
        }
        if (label.charAt(label.length - 1) === "-") {
          return "LABEL_ENDS_WITH_DASH";
        }
        if (!/^[a-z0-9\-]+$/.test(label)) {
          return "LABEL_INVALID_CHARS";
        }
      }
    };
    exports.parse = function(input) {
      if (typeof input !== "string") {
        throw new TypeError("Domain name must be a string.");
      }
      var domain = input.slice(0).toLowerCase();
      if (domain.charAt(domain.length - 1) === ".") {
        domain = domain.slice(0, domain.length - 1);
      }
      var error2 = internals.validate(domain);
      if (error2) {
        return {
          input,
          error: {
            message: exports.errorCodes[error2],
            code: error2
          }
        };
      }
      var parsed = {
        input,
        tld: null,
        sld: null,
        domain: null,
        subdomain: null,
        listed: false
      };
      var domainParts = domain.split(".");
      if (domainParts[domainParts.length - 1] === "local") {
        return parsed;
      }
      var handlePunycode = function() {
        if (!/xn--/.test(domain)) {
          return parsed;
        }
        if (parsed.domain) {
          parsed.domain = Punycode.toASCII(parsed.domain);
        }
        if (parsed.subdomain) {
          parsed.subdomain = Punycode.toASCII(parsed.subdomain);
        }
        return parsed;
      };
      var rule = internals.findRule(domain);
      if (!rule) {
        if (domainParts.length < 2) {
          return parsed;
        }
        parsed.tld = domainParts.pop();
        parsed.sld = domainParts.pop();
        parsed.domain = [parsed.sld, parsed.tld].join(".");
        if (domainParts.length) {
          parsed.subdomain = domainParts.pop();
        }
        return handlePunycode();
      }
      parsed.listed = true;
      var tldParts = rule.suffix.split(".");
      var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
      if (rule.exception) {
        privateParts.push(tldParts.shift());
      }
      parsed.tld = tldParts.join(".");
      if (!privateParts.length) {
        return handlePunycode();
      }
      if (rule.wildcard) {
        tldParts.unshift(privateParts.pop());
        parsed.tld = tldParts.join(".");
      }
      if (!privateParts.length) {
        return handlePunycode();
      }
      parsed.sld = privateParts.pop();
      parsed.domain = [parsed.sld, parsed.tld].join(".");
      if (privateParts.length) {
        parsed.subdomain = privateParts.join(".");
      }
      return handlePunycode();
    };
    exports.get = function(domain) {
      if (!domain) {
        return null;
      }
      return exports.parse(domain).domain || null;
    };
    exports.isValid = function(domain) {
      var parsed = exports.parse(domain);
      return Boolean(parsed.domain && parsed.listed);
    };
  })(psl$1);
  const psl = /* @__PURE__ */ getDefaultExportFromCjs(psl$1);
  function R(t, e) {
    var s2;
    const n = f$1(t);
    if (!n)
      return [];
    const i2 = ((s2 = getRelatedDomains(n.psl.domain ?? n.url.hostname)) == null ? void 0 : s2.map((r2) => f$1(`https://${r2}`)).filter(c)) ?? [];
    return Object.entries(e).map(([r2, u2]) => {
      let l = Math.max(...u2.websites.map((o) => a(n, o)).filter(c));
      return l === -1 / 0 && (l = Math.max(...u2.websites.flatMap((o) => i2.map((g2) => a(g2, o))).filter(c))), {
        ...u2,
        id: r2,
        urlSimilarity: l
      };
    }).filter(({
      urlSimilarity: r2
    }) => r2 !== -1 / 0);
  }
  function a(t, e) {
    const n = getNormalizedPatternParts(e, {
      usePunycode: true
    });
    if (n.port !== "" && n.port !== t.url.port)
      return null;
    const i2 = M(t, n.hostname);
    if (i2 === null)
      return null;
    const s2 = w(t.url.pathname, n.pathname);
    return i2 * 100 + s2;
  }
  function M(t, e) {
    if (e = S(e), !e || !t.url.hostname.endsWith(e))
      return null;
    const n = psl.parse(e);
    if (n.error || // either both are on the psl, or none is
    t.psl.listed !== n.listed || t.psl.domain !== n.domain)
      return null;
    const i2 = t.psl.listed ? t.psl.subdomain : t.url.hostname, s2 = n.listed ? n.subdomain : e, r2 = (i2 == null ? void 0 : i2.split(".")) ?? [], u2 = (s2 == null ? void 0 : s2.split(".")) ?? [];
    r2.reverse(), u2.reverse();
    const l = v(r2, u2);
    return l === null ? null : l + 1;
  }
  function S(t) {
    for (; t.startsWith("www."); )
      t = t.substring(4);
    return t;
  }
  function w(t, e) {
    const n = m(e), i2 = m(t), s2 = p(i2, n, true), r2 = s2.findIndex(([l, o]) => l !== o);
    if (r2 === -1)
      return n.length;
    const [, u2] = s2[r2];
    if (u2 === void 0)
      return n.length;
    if (r2 !== 0) {
      const l = n.length - r2;
      return -(l / (l + 1));
    }
    return -n.length;
  }
  function f$1(t) {
    let e;
    try {
      e = new URL(t);
    } catch {
      return;
    }
    const n = x(e.hostname);
    if (!n.error)
      return {
        url: e,
        psl: n
      };
  }
  const h = /* @__PURE__ */ new Map();
  function x(t) {
    const e = h.get(t);
    if (e)
      return e;
    const n = psl.parse(t);
    return h.set(t, n), n;
  }
  function m(t) {
    const e = t.replace(/^\/+|\/+$/g, "");
    return e === "" ? [] : e.split("/");
  }
  function v(t, e) {
    const n = p(t, e, true), i2 = n.findIndex(([r2, u2]) => r2 !== u2);
    if (i2 === -1)
      return e.length;
    const [, s2] = n[i2];
    return s2 === void 0 ? e.length : null;
  }
  function p(t, e, n) {
    const s2 = (n ? Math.max : Math.min)(t.length, e.length);
    return Array.from(Array(s2).keys()).map((r2) => [t[r2], e[r2]]);
  }
  function c(t) {
    return t != null;
  }
  function f(r2, i2) {
    for (const e of i2.profiles)
      if (e.profile.email)
        return e.profile.email;
    for (const e of i2.disabledProfiles)
      if (e.email)
        return e.email;
    if (r2.preliminaryEmail)
      return r2.preliminaryEmail;
    for (const e of r2.preliminaryProfiles)
      if (e.email)
        return e.email;
    const a2 = r2.getPrimaryEmail();
    return a2 || "";
  }
  const messages$1 = JSON.parse(`{"jBI8Lx":[["0","plural",{"other":["#"," Logins durchsuchen"]}]],"ZsmGRL":["'am' ",["atAbsoluteDate"]],"aHvVg8":[["browserName"]," blockiert Browser-Erweiterungen auf dieser Seite"],"aLmCR/":[["browserName"]," blockiert heylogin auf dieser Seite"],"uooG+Q":[["hiddenLoginsCount","plural",{"one":["#"," weiteres Login anzeigen"],"other":["#"," weitere Logins anzeigen"]}]],"pgvip9":[["uppercaseName"]," kopiert!"],"8d6VgQ":["<0>In</0> ",["vaultLabel"]],"RQWed3":"1-Klick-Login erfolgreich eingerichtet. Du kannst dich jetzt auf jeder Webseite einloggen.","PWU3n3":"Zu Login hinzufügen","2vJK8B":"Nutzernamen hinzufügen","8uQ9hR":"Automatisch erzeugten Screenshot mitschicken","iH8pgl":"Zurück","lKI/c0":"weil dies ein InPrivate-Fenster ist","qxcrNq":"weil dieses Fenster im Inkognitomodus ist","96zC3l":"Dieses Fenster ist privat oder Chronik ist deaktiviert","06CVam":"Schildere kurz das Problem (optional)","dEgA5A":"Abbrechen","cQOi/5":"Kreditkartennummer","fFUXog":"Für mehr Optionen klicken","yz7wBu":"Schließen","mPl5nx":[["name"]," kopieren"],"F5QOVM":"Strg","7LG+7N":"Login löschen","OdTay+":"Login nicht speichern","jJzLu4":"Autom. Speichern auf diesem Gerät aktivieren","MAvRTx":"heylogin für diese Seite aktivieren","9Vnjc9":"Enter","zO1gmR":"Esc","7lpQPT":"Ablaufdatum","7Bj3x9":"Fehlgeschlagen","EB0nRS":["für ",["disabledPageHost"]],"NAPj3s":"Synchronisierung erzwingen","ziAjHi":"Generieren","19BWU3":"Passwort generieren","aAnzIW":["heylogin funktioniert für ",["0"]," nicht?"],"dkq141":"heylogin ist aktiv","U03GX6":"heylogin wird laufend verbesert. Mit deiner Hilfe schaffen wir das beste Login-Erlebnis!","6gkdg6":"heylogin wird an der falschen Stelle angezeigt","jMvyI+":"heylogin ist deaktiviert","XZBV9j":"heylogin wird nicht angezeigt","D1KO61":"heylogin: Du bist ausgeloggt","leDFPX":"heylogin einmalig auf dieser Seite ausblenden","Izy/1n":"Einloggen mit heylogin hat nicht funktioniert","Jq4085":"letzten","3oE2TF":"Login & Speichern","aoJeWE":"Einloggen in","DhwLlb":"Login hinzugefügt","NoL4kU":"Trotzdem einloggen","zUtMod":"Login abgebrochen","8MPwY1":["Login ",["relativeDate"]," erstellt"],"ZZ1E+C":"Login verschoben","Gx/Vss":"Login nicht gespeichert","Ym+sui":"Jetzt einloggen","J9IEfH":"Login gespeichert","71P+9z":"Login aktualisiert","z1owM3":"Login wurde entfernt","aabQDn":"Logins werden nicht gespeichert","m2TB6y":"Logins werden automatisch gespeichert","wckWOP":"Verwalten","rkcRqy":"Plan verwalten","QWdKwH":"Verschieben","00OyIR":"Login verschieben","S8X3Kf":"nächsten","OCApeu":"Keine Logins gefunden","/hpEcX":"Notiz","Fdp03t":"auf","UCQiqt":["auf ",["0"]],"qjzFN0":["auf ",["disabledPageHost"]],"7h/ahr":"auf allen Webseiten","yaFLo0":[["frontendServerHost"]," öffnen"],"qdCXwe":["Öffne <0>",["0"],"</0> im Browser um dich zu verbinden."],"fYyARG":"Öffne heylogin im Browser","+Gd0x/":"In heylogin öffnen","IHjtVj":"Login-Fenster öffnen","Qf8ECA":"Schnellzugriff öffnen","Yp+Hi/":"Einstellungen öffnen","yxTdsJ":"Webseite öffnen","/IX/7x":"Anderes Problem","uP0aE4":"Override-Version:","OMcfn6":"Passwort","8ZsakT":"Passwort","zJx6Vx":"Passwort geändert","PPgwqo":"Passwort nicht geändert","sXULwc":"PIN","3hTaGP":"Plan pausiert","Tpekep":"Stell bitte sicher, dass du Verbindung zum Internet hast.","0MTaJs":"Privater Account","WmGifL":"Wiederholung","SeI3Z8":"Als Standard festlegen","TRo55K":"Speichern in","idD8Ev":"Gespeichert","K/F6pa":"Wird gespeichert…","VObepA":"Screenshot","0FzuA+":[["0"]," Logins durchsuchen"],"ekAm3+":"Alle Logins durchsuchen","v8vJR1":"Deine Logins durchsuchen","3r06QJ":"Sicherheitscode","JlFcis":"Abschicken","PGetcZ":"Shift","kf83Ld":"Etwas ist schief gelaufen.","13X+48":"Fehler gefunden?","KM6m8p":"Team","JzZPb0":"Vielen Dank für deine Meldung.","gOW54d":["Der heylogin-Plan deiner Organisation <0>“",["organizationName"],"”</0> ist pausiert."],"+zHEzW":["Die heylogin-Testphase für <0>„",["organizationName"],"“</0> ist abgelaufen."],"imSNi2":"Die heylogin-Browser-Erweiterung benötigt ein Update. Bitte update die App, um heylogin zu verwenden.<0>heylogin updaten</0>","/jQctM":"In","hYzVzQ":"Bitte erlaube den Zugriff, um die Erweiterung zu aktivieren.","yPCvpC":"heute um","t9zNOe":"morgen","Kvajkr":"TOTP","XMUTjs":"TOTP-Code","6xOPtp":"TOTP-Schlüssel für","HyrObi":"Testphase abgelaufen","KDw4GX":"Erneut versuchen","9uI/rE":"Rückgängig","rtir7c":"unbekannt","1ZAe/6":"unbekannter Ort","VAOn4r":"Entsperren","4QFgr2":"Unbenanntes Login","GpHZ5V":"Änderung rückgängig gemacht","IURrEe":"Jetzt upgraden","vNZ8of":"Neues Login aus dem Posteingang verwenden?","Ha3UBC":"Security Key benutzen","silO9A":"Nutzername","7sNhEz":"Nutzername","i0/HKI":"Nutzername unbekannt","csCoda":"Version:","hdwiS9":"Login anzeigen","xgPaC3":"WLAN-Netzwerk","rQRrkB":"gestern","sGsut8":"Du bist ausgeloggt","Uqbot7":"Du bist nicht verbunden","IL3O8e":"Du hast keine Logins mit TOTP auf dieser Seite.","AlS6pf":"Dein Browser"}`);
  const messages = JSON.parse('{"jBI8Lx":[["0","plural",{"other":["Search ","#"," logins"]}]],"ZsmGRL":[["atAbsoluteDate"]],"aHvVg8":[["browserName"]," blocks extensions on this page"],"aLmCR/":[["browserName"]," blocks heylogin on this page"],"uooG+Q":[["hiddenLoginsCount","plural",{"one":["Show ","#"," more login"],"other":["Show ","#"," more logins"]}]],"pgvip9":[["uppercaseName"]," copied!"],"8d6VgQ":["<0>In</0> ",["vaultLabel"]],"RQWed3":"1-click login set up successfully. You can now log in on any website.","PWU3n3":"Add to login","2vJK8B":"Add username","8uQ9hR":"Automatically include screenshot of current website","iH8pgl":"Back","lKI/c0":"because this is an InPrivate window","qxcrNq":"because this window is in incognito mode","96zC3l":"because this window is private or history is disabled","06CVam":"Briefly describe your problem (optional)","dEgA5A":"Cancel","cQOi/5":"card number","fFUXog":"Click for more options","yz7wBu":"Close","mPl5nx":["Copy ",["name"]],"F5QOVM":"Ctrl","7LG+7N":"Delete login","OdTay+":"Do not save login","jJzLu4":"Enable autosave on this device","MAvRTx":"Enable heylogin for this page","9Vnjc9":"Enter","zO1gmR":"Esc","7lpQPT":"expiration","7Bj3x9":"Failed","EB0nRS":["for ",["disabledPageHost"]],"NAPj3s":"Force sync (to fix syncing problems)","ziAjHi":"Generate","19BWU3":"Generate password","aAnzIW":["heylogin does not work for ",["0"],"?"],"dkq141":"heylogin is active","U03GX6":"heylogin is always improving. With your help, we can provide the best login experience!","6gkdg6":"heylogin is at the wrong position","jMvyI+":"heylogin is disabled","XZBV9j":"heylogin is not displayed","D1KO61":"heylogin: You are logged out","leDFPX":"Hide heylogin once on this page","Izy/1n":"I was not logged in","Jq4085":"last","3oE2TF":"Log in & save","aoJeWE":"Log into","DhwLlb":"Login added","NoL4kU":"Login anyways","zUtMod":"Login cancelled","8MPwY1":["Login created ",["relativeDate"]],"ZZ1E+C":"Login moved","Gx/Vss":"Login not saved","Ym+sui":"Login now","J9IEfH":"Login saved","71P+9z":"Login updated","z1owM3":"Login was removed","aabQDn":"Logins are not saved","m2TB6y":"Logins are saved automatically","wckWOP":"Manage","rkcRqy":"Manage plan","QWdKwH":"Move","00OyIR":"Move login","S8X3Kf":"next","OCApeu":"No logins found","/hpEcX":"note","Fdp03t":"on","UCQiqt":["on ",["0"]],"qjzFN0":["on ",["disabledPageHost"]],"7h/ahr":"on all websites","yaFLo0":["Open ",["frontendServerHost"]],"qdCXwe":["Open <0>",["0"],"</0> in the browser to connect."],"fYyARG":"Open heylogin in the browser","+Gd0x/":"Open in heylogin","IHjtVj":"Open login window","Qf8ECA":"Open quick access","Yp+Hi/":"Open settings","yxTdsJ":"Open website","/IX/7x":"Other","uP0aE4":"Override version:","OMcfn6":"password","8ZsakT":"Password","zJx6Vx":"Password changed","PPgwqo":"Password not changed","sXULwc":"PIN","3hTaGP":"Plan paused","Tpekep":"Please make sure you have internet connection.","0MTaJs":"Private Account","WmGifL":"Repeated password","SeI3Z8":"Save as default","TRo55K":"Save to","idD8Ev":"Saved","K/F6pa":"Saving…","VObepA":"screenshot","0FzuA+":["Search ",["0"]," logins"],"ekAm3+":"Search all logins","v8vJR1":"Search your logins","3r06QJ":"security code","JlFcis":"Send","PGetcZ":"Shift","kf83Ld":"Something went wrong.","13X+48":"Spotted a mistake?","KM6m8p":"Team","JzZPb0":"Thank you for your report","gOW54d":["The heylogin plan of your organization <0>“",["organizationName"],"”</0> is paused."],"+zHEzW":["The heylogin trial for <0>“",["organizationName"],"”</0> has expired."],"imSNi2":"The installed heylogin browser extension requires an update. To use heylogin, please update.<0>Update heylogin</0>","/jQctM":"To","hYzVzQ":"To activate the extension, please grant access.","yPCvpC":"today at","t9zNOe":"tomorrow","Kvajkr":"TOTP","XMUTjs":"TOTP code","6xOPtp":"TOTP secret for","HyrObi":"Trial Expired","KDw4GX":"Try again","9uI/rE":"Undo","rtir7c":"unknown","1ZAe/6":"unknown location","VAOn4r":"Unlock","4QFgr2":"Unnamed login","GpHZ5V":"Update reverted","IURrEe":"Upgrade now","vNZ8of":"Use new login from your inbox?","Ha3UBC":"Use security key","silO9A":"username","7sNhEz":"Username","i0/HKI":"Username unknown","csCoda":"Version:","hdwiS9":"View login","xgPaC3":"wifi network","rQRrkB":"yesterday","sGsut8":"You are logged out","Uqbot7":"You are not connected","IL3O8e":"You have no logins with TOTP on this page.","AlS6pf":"Your browser"}');
  function initUiLocale() {
    const uiLocale = browser$1.i18n.getUILanguage();
    y({
      en: messages,
      de: messages$1
    }, uiLocale);
  }
  background;
  var _dec$4, _class$4;
  let DebugMode = (_dec$4 = Emittery$3.mixin("emitter"), _dec$4(_class$4 = class DebugMode2 {
    constructor() {
      __publicField(this, "debugFlag", false);
      __publicField(this, "localDebugOverrideFlag");
      __publicField(this, "handleStorageChanged", (changes, areaName) => {
        if (areaName !== "local" || changes.debug === void 0) {
          return;
        }
        this.internalUpdateDebugFlag(changes.debug.newValue);
      });
    }
    async init() {
      browser$1.storage.onChanged.addListener(this.handleStorageChanged);
      const {
        debug: storageDebugFlag
      } = await browser$1.storage.local.get("debug");
      this.internalUpdateDebugFlag(storageDebugFlag);
    }
    get debug() {
      return this.localDebugOverrideFlag ?? this.debugFlag;
    }
    set debug(newDebug) {
      this.internalUpdateDebugFlag(newDebug);
      browser$1.storage.local.set({
        debug: this.debugFlag
      }).catch(trackError);
    }
    get localDebugOverride() {
      return this.localDebugOverrideFlag;
    }
    set localDebugOverride(newOverride) {
      this.withEvents(() => {
        this.localDebugOverrideFlag = newOverride;
      });
    }
    internalUpdateDebugFlag(newDebugFlag) {
      this.withEvents(() => {
        this.debugFlag = newDebugFlag;
      });
    }
    withEvents(cb) {
      const oldDebug = this.debug;
      cb();
      if (oldDebug !== this.debug) {
        debugConsole.showDebugMessages = this.debug;
        this.emitter.emit("change", {
          debug: this.debug
        }).catch(trackError);
      }
    }
  }) || _class$4);
  const debugMode = new DebugMode();
  debugMode.init().catch(trackError);
  background;
  function isSafari(precomputedBrowser) {
    const browser2 = precomputedBrowser ?? Bowser.parse(navigator.userAgent);
    return browser2.browser.name === "Safari";
  }
  function isMobileSafari(precomputedBrowser) {
    const browser2 = precomputedBrowser ?? Bowser.parse(navigator.userAgent);
    return browser2.browser.name === "Safari" && browser2.os.name === "iOS" || m$1(browser2);
  }
  function isDesktopSafari(precomputedBrowser) {
    const browser2 = precomputedBrowser ?? Bowser.parse(navigator.userAgent);
    return browser2.browser.name === "Safari" && browser2.os.name === "macOS" && !m$1(browser2);
  }
  function isMobileBrowser(precomputedBrowser) {
    const browser2 = precomputedBrowser ?? Bowser.parse(navigator.userAgent);
    return isMobileSafari(precomputedBrowser) || browser2.os.name === "Android";
  }
  background;
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class Semaphore {
    constructor(_maxConcurrency) {
      this._maxConcurrency = _maxConcurrency;
      this._queue = [];
      if (_maxConcurrency <= 0) {
        throw new Error("semaphore must be initialized to a positive value");
      }
      this._value = _maxConcurrency;
    }
    acquire() {
      const locked = this.isLocked();
      const ticket = new Promise((r2) => this._queue.push(r2));
      if (!locked)
        this._dispatch();
      return ticket;
    }
    runExclusive(callback) {
      return __awaiter(this, void 0, void 0, function* () {
        const [value, release] = yield this.acquire();
        try {
          return yield callback(value);
        } finally {
          release();
        }
      });
    }
    isLocked() {
      return this._value <= 0;
    }
    release() {
      if (this._maxConcurrency > 1) {
        throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
      }
      if (this._currentReleaser) {
        this._currentReleaser();
        this._currentReleaser = void 0;
      }
    }
    _dispatch() {
      const nextConsumer = this._queue.shift();
      if (!nextConsumer)
        return;
      let released = false;
      this._currentReleaser = () => {
        if (released)
          return;
        released = true;
        this._value++;
        this._dispatch();
      };
      nextConsumer([this._value--, this._currentReleaser]);
    }
  }
  var __awaiter$1 = function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result2) {
        result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  class Mutex {
    constructor() {
      this._semaphore = new Semaphore(1);
    }
    acquire() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const [, releaser] = yield this._semaphore.acquire();
        return releaser;
      });
    }
    runExclusive(callback) {
      return this._semaphore.runExclusive(() => callback());
    }
    isLocked() {
      return this._semaphore.isLocked();
    }
    release() {
      this._semaphore.release();
    }
  }
  function throttle(delay, noTrailing, callback, debounceMode) {
    var timeoutID;
    var cancelled = false;
    var lastExec = 0;
    function clearExistingTimeout() {
      if (timeoutID) {
        clearTimeout(timeoutID);
      }
    }
    function cancel() {
      clearExistingTimeout();
      cancelled = true;
    }
    if (typeof noTrailing !== "boolean") {
      debounceMode = callback;
      callback = noTrailing;
      noTrailing = void 0;
    }
    function wrapper() {
      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
        arguments_[_key] = arguments[_key];
      }
      var self2 = this;
      var elapsed = Date.now() - lastExec;
      if (cancelled) {
        return;
      }
      function exec() {
        lastExec = Date.now();
        callback.apply(self2, arguments_);
      }
      function clear() {
        timeoutID = void 0;
      }
      if (debounceMode && !timeoutID) {
        exec();
      }
      clearExistingTimeout();
      if (debounceMode === void 0 && elapsed > delay) {
        exec();
      } else if (noTrailing !== true) {
        timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
      }
    }
    wrapper.cancel = cancel;
    return wrapper;
  }
  function debounce(delay, atBegin, callback) {
    return callback === void 0 ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
  }
  class PersistentClientCoreSyncStateStore {
    constructor() {
      __publicField(this, "internalState");
    }
    async init() {
      this.internalState = await this.getFromStorage();
    }
    get lastConnectAttemptDate() {
      var _a2;
      return (_a2 = this.internalState) == null ? void 0 : _a2.lastConnectAttemptDate;
    }
    set lastConnectAttemptDate(date2) {
      if (!this.internalState) {
        return;
      }
      this.internalState.lastConnectAttemptDate = date2;
      this.save();
    }
    get lastConnectAttempt() {
      var _a2;
      return ((_a2 = this.internalState) == null ? void 0 : _a2.lastConnectAttempt) ?? 0;
    }
    set lastConnectAttempt(attempt) {
      if (!this.internalState) {
        return;
      }
      this.internalState.lastConnectAttempt = attempt;
      this.save();
    }
    async getFromStorage() {
      const fromStorage = (await browser.storage.local.get("clientCoreSyncStateJson")).clientCoreSyncStateJson;
      if (typeof fromStorage !== "string") {
        return {};
      }
      try {
        const parsed = jsonParseThaw(fromStorage);
        if (typeof parsed === "object" && parsed !== null) {
          return parsed;
        }
        return {};
      } catch (error2) {
        return {};
      }
    }
    save() {
      browser.storage.local.set({
        clientCoreSyncStateJson: jsonStringifyFreeze(this.internalState)
      }).catch(trackError);
    }
  }
  background;
  var _dec$3, _class$3;
  let ClientCoreLoader = (_dec$3 = Emittery$3.mixin("emitter"), _dec$3(_class$3 = class ClientCoreLoader2 {
    constructor() {
      __publicField(this, "activeClientCoreSync");
      __publicField(this, "retryLoadTimeoutId");
      __publicField(this, "loadMutex", new Mutex());
      __publicField(this, "clientOutdated", false);
      __publicField(this, "messageListener", makeMessageListener({
        IsClientOutdated: () => this.clientOutdated,
        RequestForceRefreshClientCoreParameters: async () => {
          if (!this.clientCore) {
            return;
          }
          await this.clientCore.debugEmitClientCoreParametersRefreshNeeded();
        }
      }));
      __publicField(this, "handleSyncEnd", () => {
        this.clientOutdated = false;
        this.schedulePersistClientCore();
      });
      __publicField(this, "handleSyncError", ({
        error: error2
      }) => {
        if (error2 instanceof DomainError$1 && error2.code === BackendErrorCode.INVALID_CREDENTIALS) {
          this.loadWithClientCoreParameters(null).catch(trackError);
          return;
        }
        if (error2 instanceof DomainError$1 && error2.code === BackendErrorCode.CLIENT_OUTDATED) {
          this.clientOutdated = true;
          return;
        }
        trackError(error2);
      });
      __publicField(this, "handleRefreshNeeded", () => {
        this.refreshClientCoreParameters().catch(trackError);
      });
      __publicField(this, "schedulePersistClientCore", debounce(5e3, () => {
        this.persistClientCore().catch(trackError);
      }));
      eventProxy.addListener("runtime.onMessage", this.messageListener);
    }
    get clientCore() {
      var _a2;
      return (_a2 = this.clientCoreSync) == null ? void 0 : _a2.clientCore;
    }
    get clientCoreSync() {
      return this.activeClientCoreSync;
    }
    isClientOutdated() {
      return this.clientOutdated;
    }
    async loadWithClientCoreParameters(clientCoreParameters, pinnedAuthenticatorSecret, clientType = ClientType.EXT) {
      await this.loadMutex.runExclusive(async () => {
        var _a2, _b2, _c2, _d2, _e2;
        debugConsole.log("[ClientCoreLoader]", "loadWithClientCoreParameters", clientCoreParameters);
        globalThis.clearTimeout(this.retryLoadTimeoutId);
        const oldClientCoreParameters = ((_a2 = this.clientCore) == null ? void 0 : _a2.getClientCoreParameters()) ?? null;
        if (deepEqual$1(oldClientCoreParameters, clientCoreParameters)) {
          debugConsole.log("[ClientCoreLoader]", "skipping load due to unchanged CCP");
          return;
        }
        (_b2 = this.activeClientCoreSync) == null ? void 0 : _b2.off("syncError", this.handleSyncError);
        (_c2 = this.clientCore) == null ? void 0 : _c2.off("syncEnd", this.handleSyncEnd);
        (_d2 = this.clientCore) == null ? void 0 : _d2.off("clientCoreParametersRefreshNeeded", this.handleRefreshNeeded);
        (_e2 = this.activeClientCoreSync) == null ? void 0 : _e2.close();
        this.activeClientCoreSync = void 0;
        let newClientCore = void 0;
        let newClientCoreSync = void 0;
        if (clientCoreParameters) {
          const backend = new BackendClient({
            backendBaseUri: getBackendUrl(),
            auditlogBaseUri: getAuditlogUrl(),
            clientId: newUuid$1(),
            clientType,
            clientVersion: HEYLOGIN_VERSION
          });
          try {
            updateSentryScope(clientCoreParameters.loginData.userId, backend.config.clientId);
            const persistableClientCore = await getPersistableClientCore();
            newClientCore = await ClientCore$1.onlineLoad(clientCoreParameters, backend, persistableClientCore, pinnedAuthenticatorSecret);
            updateSentryScope(newClientCore.accountState.userId, newClientCore.backendClient.config.clientId ?? void 0);
            await newClientCore.addAchievement(Achievement.EXT_INSTALL);
            if (!newClientCore.vaultRepo.isInitialized()) {
              await newClientCore.onlineSync();
              this.clientOutdated = false;
            }
            const stateStore = new PersistentClientCoreSyncStateStore();
            await stateStore.init();
            newClientCoreSync = new ClientCoreSync$1(newClientCore, {
              stateStore
            });
            newClientCoreSync.setSyncConnectionMode("streamingOrFallback");
            newClientCoreSync.setDelayExtendUnlock(true);
            newClientCoreSync.on("syncError", this.handleSyncError);
            newClientCore.on("syncEnd", this.handleSyncEnd);
            newClientCore.on("clientCoreParametersRefreshNeeded", this.handleRefreshNeeded);
            newClientCoreSync.open();
          } catch (e) {
            updateSentryScope(void 0, void 0);
            if (e instanceof BackendDomainError && e.code === BackendErrorCode.INVALID_CREDENTIALS)
              ;
            else if (e instanceof BackendDomainError && e.code === BackendErrorCode.CLIENT_OUTDATED) {
              this.clientOutdated = true;
            } else {
              if (
                // don't report NoResponse, that's not our fault and we can't do anything about it
                !(e instanceof BackendClientDomainError && e.code === BackendClientErrorCode.NoResponse)
              ) {
                debugConsole.log("reporting");
                trackError(e);
              }
              debugConsole.log("[ClientCoreLoader]", "load failed, scheduling retry");
              this.retryLoadTimeoutId = globalThis.setTimeout(() => {
                debugConsole.log("[ClientCoreLoader]", "retrying");
                this.loadWithClientCoreParameters(clientCoreParameters).catch(trackError);
              }, 1e4);
            }
          }
        }
        this.activeClientCoreSync = newClientCoreSync;
        await Promise.all([this.persistClientCore(), this.persistClientCoreParameters(), this.emitter.emit("clientCoreChange", {
          newClientCoreSync
        })]);
      });
    }
    async refreshClientCoreParameters() {
      if (!this.clientCore) {
        return;
      }
      const newClientCoreParameters = await this.clientCore.onlineCreateRefreshedClientCoreParameters();
      await this.loadWithClientCoreParameters(newClientCoreParameters);
    }
    async persistClientCore() {
      if (this.clientCore) {
        await browser$1.storage.local.set({
          persistableClientCore: jsonStringifyFreeze(this.clientCore.getPersistable())
        });
      } else {
        await browser$1.storage.local.remove("persistableClientCore");
      }
    }
    async persistClientCoreParameters() {
      if (this.clientCore) {
        await browser$1.storage.local.set({
          clientCoreParameters: jsonStringifyFreeze(this.clientCore.getClientCoreParameters())
        });
      } else {
        await browser$1.storage.local.remove("clientCoreParameters");
      }
    }
  }) || _class$3);
  async function getPersistableClientCore() {
    const fieldValue = (await browser$1.storage.local.get("persistableClientCore")).persistableClientCore;
    try {
      return PersistableClientCore.parse(jsonParseThaw(fieldValue));
    } catch (e) {
      return void 0;
    }
  }
  background;
  var _dec$2, _class$2;
  let BrowserClientCoreParametersStorage = (_dec$2 = Emittery$3.mixin("emitter"), _dec$2(_class$2 = class BrowserClientCoreParametersStorage2 {
    async setClientCoreParameters(ccp) {
      if (ccp) {
        await browser$1.storage.local.set({
          clientCoreParameters: jsonStringifyFreeze(ccp)
        });
      } else {
        await browser$1.storage.local.remove("clientCoreParameters");
      }
    }
    async getClientCoreParameters() {
      const fieldValue = (await browser$1.storage.local.get("clientCoreParameters")).clientCoreParameters;
      try {
        return ClientCoreParameters.parse(jsonParseThaw(fieldValue));
      } catch (e) {
        return void 0;
      }
    }
  }) || _class$2);
  background;
  var _dec$1, _class$1;
  const GetClientCoreParametersResponse = z.object({
    clientCoreParametersJson: z.string().nullish(),
    fetchError: z.boolean().optional()
  });
  let DesktopSafariClientCoreParametersStorage = (_dec$1 = Emittery$3.mixin("emitter"), _dec$1(_class$1 = class DesktopSafariClientCoreParametersStorage2 {
    constructor() {
      __publicField(this, "cachedCCPJson");
    }
    async init() {
      this.checkCCP().catch(trackError);
    }
    async setClientCoreParameters(ccp) {
      await browser$1.runtime.sendNativeMessage("application.id", {
        type: "setClientCoreParameters",
        clientCoreParametersJson: ccp ? jsonStringifyFreeze(ccp) : void 0
      });
    }
    async getClientCoreParameters() {
      const clientCoreParametersJson = await this.getClientCoreParametersJson();
      return this.parseClientClientCoreParametersJson(clientCoreParametersJson);
    }
    async getClientCoreParametersJson() {
      let response;
      try {
        response = await browser$1.runtime.sendNativeMessage("application.id", {
          type: "getClientCoreParameters"
        });
      } catch (e) {
        debugConsole.log("[DesktopSafariClientCoreParametersStorage]", "getClientCoreParameters", "returning cached ccp due to message error", e, this.cachedCCPJson);
        return;
      }
      const parsedResponse = GetClientCoreParametersResponse.safeParse(response);
      if (!parsedResponse.success || parsedResponse.data.fetchError) {
        debugConsole.log("[DesktopSafariClientCoreParametersStorage]", "getClientCoreParameters", "returning cached ccp", parsedResponse, this.cachedCCPJson);
        return this.cachedCCPJson;
      }
      const newCCP = parsedResponse.data.clientCoreParametersJson ?? void 0;
      this.cachedCCPJson = newCCP;
      return newCCP;
    }
    parseClientClientCoreParametersJson(clientCoreParametersJson) {
      if (!clientCoreParametersJson) {
        return void 0;
      }
      try {
        return ClientCoreParameters.parse(jsonParseThaw(clientCoreParametersJson));
      } catch (e) {
        return void 0;
      }
    }
    async checkCCP() {
      let oldValueJson = await this.getClientCoreParametersJson();
      while (true) {
        await sleep(5e3);
        const newValueJson = await this.getClientCoreParametersJson();
        if (oldValueJson !== newValueJson) {
          oldValueJson = newValueJson;
          this.emitter.emit("change", {
            newClientCoreParameters: this.parseClientClientCoreParametersJson(newValueJson)
          }).catch(trackError);
        }
      }
    }
  }) || _class$1);
  background;
  class DefaultClientCoreUpdater {
    constructor(clientCoreLoader, clientCoreParametersStorage) {
      __publicField(this, "messageListener", makeMessageListener({
        WebappClientCoreParametersExtracted: async ({
          clientCoreParametersJSON
        }, sender) => {
          if (!sender.tab) {
            return;
          }
          if (sender.tab.incognito && !await onlyIncognitoWebappTabs()) {
            debugConsole.log("[ClientCoreLoader]", "ignoring incognito tab message while non-incognito tab is open");
            return;
          }
          const clientCoreParametersParseResult = ClientCoreParameters.safeParse(jsonParseThaw(clientCoreParametersJSON));
          if (!clientCoreParametersParseResult.success) {
            return;
          }
          await this.clientCoreLoader.loadWithClientCoreParameters(clientCoreParametersParseResult.data);
        },
        GetClientCoreParameters: () => {
          if (!this.clientCoreLoader.clientCore || this.clientCoreLoader.isClientOutdated()) {
            return void 0;
          }
          return {
            clientCoreParametersJSON: jsonStringifyFreeze(this.clientCoreLoader.clientCore.getClientCoreParameters())
          };
        }
      }));
      this.clientCoreLoader = clientCoreLoader;
      this.clientCoreParametersStorage = clientCoreParametersStorage;
    }
    async init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
      this.clientCoreLoader.on("clientCoreChange", () => {
        this.persistClientCoreParameters().catch(trackError);
      });
      this.clientCoreParametersStorage.on("change", ({
        newClientCoreParameters
      }) => {
        this.clientCoreLoader.loadWithClientCoreParameters(newClientCoreParameters ?? null).catch(trackError);
      });
      const clientCoreParameters = await this.clientCoreParametersStorage.getClientCoreParameters();
      await this.clientCoreLoader.loadWithClientCoreParameters(clientCoreParameters ?? null);
    }
    async persistClientCoreParameters() {
      var _a2;
      await this.clientCoreParametersStorage.setClientCoreParameters((_a2 = this.clientCoreLoader.clientCore) == null ? void 0 : _a2.getClientCoreParameters());
    }
  }
  async function onlyIncognitoWebappTabs() {
    const webappUrl = new URL(getFrontendServerUrl());
    webappUrl.port = "";
    const webappTabs = await browser$1.tabs.query({
      url: `${webappUrl}*`
    });
    debugConsole.log({
      webappTabs
    });
    return webappTabs.every((t) => t.incognito);
  }
  background;
  class MobileSafariClientCoreUpdater {
    constructor(clientCoreLoader) {
      this.clientCoreLoader = clientCoreLoader;
    }
    async init() {
      const response = await browser$1.runtime.sendNativeMessage("application.id", {
        type: "getClientCoreParameters"
      });
      const clientCoreParameters = ClientCoreParameters.parse(jsonParseThaw(response.clientCoreParametersJson));
      const authenticatorSecret = {
        authenticatorId: clientCoreParameters.unlockedAuthenticator.authenticator.id,
        seed: naclUtilExports.decodeBase64(response.authSeedBase64)
      };
      await this.clientCoreLoader.loadWithClientCoreParameters(clientCoreParameters, authenticatorSecret, ClientType.EXT_IOS);
    }
  }
  background;
  function createAutosnatchLoginWebsites(urlStr, addTldPlus1) {
    const url = new URL(urlStr);
    url.pathname = "";
    const pslParsed = psl.parse(url.hostname);
    if (pslParsed.error || !pslParsed.listed || pslParsed.domain === null) {
      const resultStr = `${url}`;
      const normalizedWebsite = normalizeWebsitePattern(resultStr);
      return {
        websites: [normalizedWebsite],
        websiteAttributes: {
          [normalizedWebsite]: getWebsiteAttributesEntry(resultStr)
        }
      };
    }
    const websites = [];
    const websiteAttributes = {};
    let fullWebsite;
    if (pslParsed.subdomain) {
      const registrationPrefixesStrippedSubdomain = stripRegistrationLoginPrefixes(pslParsed.subdomain);
      if (registrationPrefixesStrippedSubdomain) {
        const registrationPrefixesStrippedHostname = `${registrationPrefixesStrippedSubdomain}.${pslParsed.domain}`;
        url.hostname = registrationPrefixesStrippedHostname;
        const resultStr = `${url}`;
        fullWebsite = normalizeWebsitePattern(resultStr);
        websites.push(fullWebsite);
        websiteAttributes[fullWebsite] = getWebsiteAttributesEntry(resultStr);
      }
    }
    if (addTldPlus1 || websites.length === 0) {
      url.hostname = pslParsed.domain;
      const resultStr = `${url}`;
      const eTLDPlusOneWebsite = normalizeWebsitePattern(resultStr);
      if (eTLDPlusOneWebsite !== fullWebsite) {
        websites.push(eTLDPlusOneWebsite);
        websiteAttributes[eTLDPlusOneWebsite] = getWebsiteAttributesEntry(resultStr);
      }
    }
    return {
      websites,
      websiteAttributes
    };
  }
  function stripRegistrationLoginPrefixes(hostname, keepLastSegment = false) {
    const hostnameSegments = hostname.split(".");
    const minSegments = keepLastSegment ? 1 : 0;
    while (hostnameSegments.length > minSegments && REGISTRATION_OR_LOGIN_PREFIXES.has(hostnameSegments[0])) {
      hostnameSegments.splice(0, 1);
    }
    return hostnameSegments.join(".");
  }
  const REGISTRATION_OR_LOGIN_PREFIXES = /* @__PURE__ */ new Set([
    "account",
    "accounts",
    "app",
    "auth",
    // auth.api.sonyentertainmentnetwork.com
    "business-login",
    // business-login.telekom.de
    "cim",
    // cim.allianz.de
    "iam",
    "id",
    "identity",
    "idm",
    // accounts.login.idm.telekom.com
    "join",
    "kunde",
    // kunde.comdirect.de
    "kundencenter",
    // kundencenter.htp.net
    "login",
    "mein",
    // mein.t-mobile.de
    "meine",
    // meine.stadtwerke-wf.de
    "my",
    "myaccount",
    "myaccounts",
    "passport",
    // (used by yandex)
    "password",
    "passwort",
    "portal",
    // portal.sangoma.com
    "register",
    "registration",
    "registrierung",
    // registrierung.web.de
    "secure",
    "service",
    "signin",
    "signup",
    "sso",
    // sso.kabelmail.de
    "trial",
    "websso",
    // websso.t-systems.de
    "www"
    // n.b.: not specific to registration/login, but we should drop it anyways
  ]);
  background;
  async function applyEnqueued(modificationFunctions, undos, queue) {
    let pendingUndos;
    ({
      pendingUndos
    } = await applyUndos(modificationFunctions, undos));
    let newUndos;
    ({
      newUndos
    } = await applyEnqueuedAutosnatches(modificationFunctions, queue));
    return {
      undos: [...newUndos, ...pendingUndos]
    };
  }
  async function applyEnqueuedAutosnatches(modificationFunctions, queue) {
    const sortedQueue = [...queue].sort(byDate);
    const newUndos = [];
    for (const enq of sortedQueue) {
      const result2 = await applyEnqueuedAutosnatch(modificationFunctions, enq);
      if (result2) {
        newUndos.push(result2.undo);
      }
    }
    newUndos.reverse();
    return {
      newUndos
    };
  }
  async function applyEnqueuedAutosnatch(modificationFunctions, enq) {
    var _a2;
    const logins = modificationFunctions.getVaultContent().logins;
    const login = enq.forceCreate ? void 0 : getMatchingLogin(enq, logins);
    const newUnprotectedPassword = {
      contentId: newUuid$1(),
      unencrypted: enq.password
    };
    if (login !== void 0) {
      const loginEditTime = login.editTime;
      if (enq.date < loginEditTime) {
        return void 0;
      }
      const oldPassword = modificationFunctions.unprotectWithContentId(login.password);
      const passwordChanged = oldPassword.unencrypted !== enq.password;
      const usernameChanged = login.username !== enq.username;
      if (!passwordChanged && !usernameChanged) {
        return void 0;
      }
      await modificationFunctions.modifyLogin(login.id, {
        username: enq.username,
        password: passwordChanged ? newUnprotectedPassword : oldPassword
      }, {
        editTime: enq.date,
        changeTime: enq.date
      }, enq.source);
      const undo2 = {
        id: newUuid$1(),
        type: "update",
        editTime: enq.date,
        loginId: login.id,
        vaultId: enq.targetVaultId,
        oldEditTime: login.editTime,
        oldPassword: passwordChanged ? oldPassword : void 0,
        oldUsername: usernameChanged ? login.username : void 0,
        seen: !!enq.seen,
        newRevisionId: (_a2 = modificationFunctions.getVaultContent().logins[login.id].history) == null ? void 0 : _a2.currentRevisionId,
        oldEditProfile: login.editProfileId,
        oldEditSource: login.editSource
      };
      return {
        undo: undo2
      };
    }
    const undo = {
      id: newUuid$1(),
      type: "create",
      editTime: enq.date,
      loginId: enq.id,
      vaultId: enq.targetVaultId,
      seen: !!enq.seen
    };
    const {
      websites,
      websiteAttributes
    } = createAutosnatchLoginWebsites(enq.url, !!enq.addTldPlus1);
    const newLogin = {
      uiType: LoginUiType.login,
      title: "",
      username: enq.username ?? "",
      websites,
      websiteAttributes,
      password: newUnprotectedPassword,
      note: "",
      customFields: []
    };
    await modificationFunctions.addOrModifyLogin(enq.id, newLogin, {
      creationTime: enq.date,
      editTime: enq.date,
      changeTime: enq.date
    }, enq.source);
    return {
      undo
    };
  }
  async function applyUndos(modificationFunctions, undos) {
    const sortedUndos = [...undos].sort(byEditTime).reverse();
    const loginHasPendingUndo = /* @__PURE__ */ new Map();
    const pendingUndos = [];
    for (const undo of sortedUndos) {
      const undoApplicable = isUndoApplicable(modificationFunctions.getVaultContent(), undo);
      if (undo.applied) {
        if (undoApplicable) {
          await applyUndo(modificationFunctions, undo);
        }
      } else if (undoApplicable || loginHasPendingUndo.get(undo.loginId)) {
        loginHasPendingUndo.set(undo.loginId, true);
        pendingUndos.push(undo);
      }
    }
    return {
      pendingUndos
    };
  }
  function byEditTime(a2, b) {
    return a2.editTime.localeCompare(b.editTime);
  }
  function byDate(a2, b) {
    return a2.date.localeCompare(b.date);
  }
  function isUndoApplicable(loginVaultContent, undo) {
    const login = loginVaultContent.logins[undo.loginId];
    if (!login) {
      return false;
    }
    return undo.editTime === login.editTime;
  }
  function applyUndo(modificationFunctions, undo) {
    if (undo.type === "create") {
      return modificationFunctions.deleteLogin(undo.loginId);
    }
    const {
      newLogin,
      timesOverride
    } = createUndoUpdateAppliedLogin(undo);
    return modificationFunctions.modifyLogin(undo.loginId, newLogin, timesOverride, LoginSource.undo);
  }
  function createUndoUpdateAppliedLogin(undo) {
    const newLogin = {};
    if (undo.oldPassword !== void 0) {
      newLogin.password = undo.oldPassword;
    }
    if (undo.oldUsername !== void 0) {
      newLogin.username = undo.oldUsername;
    }
    return {
      newLogin,
      timesOverride: {
        editTime: undo.oldEditTime,
        // Here, changeTime is the time of the undo, resulting in the login being sorted first
        changeTime: undo.editTime
      }
    };
  }
  function getMatchingLogin(enqueued, loginVaultContent) {
    const existingLogins = R(enqueued.url, loginVaultContent);
    return findMatchingLogin(enqueued, existingLogins);
  }
  function findMatchingLogin(enqueued, existingLogins) {
    const loginByTargetId = enqueued.targetLoginId && existingLogins.find(
      // NOTE: read-only vaults must be filtered before
      (login) => login.id === enqueued.targetLoginId && canEditLogin(login, {
        editLogins: true
      })
    );
    if (loginByTargetId) {
      return loginByTargetId;
    }
    const loginsSortedById = [...existingLogins].sort((a2, b) => a2.id.localeCompare(b.id));
    for (const login of loginsSortedById) {
      if (login.username === enqueued.username) {
        return login;
      }
    }
    return void 0;
  }
  background;
  function createModificationFunctions(clientCore, vaultId) {
    return {
      getVaultContent: () => clientCore.vaultRepo.getVaultById(vaultId).getContent(),
      addOrModifyLogin: async (id, login, timesOverride, source) => {
        await clientCore.addOrModifyLogin({
          loginId: id,
          vaultId,
          source: source ?? LoginSource.autosave,
          login,
          timesOverride
        });
      },
      modifyLogin: async (loginId, login, timesOverride, source = LoginSource.autosave) => clientCore.modifyLogin({
        vaultId,
        loginId,
        login,
        timesOverride,
        source
      }),
      deleteLogin: async (id) => {
        await clientCore.deleteOrArchiveLogins({
          loginId: id,
          vaultId
        });
      },
      unprotectWithContentId: clientCore.protectedSecretRepo.getProtectedSecretFunctions(clientCore.vaultRepo.getVaultById(vaultId)).unprotectWithContentId
    };
  }
  background;
  var _dec, _class;
  let AutosnatchCache = (_dec = Emittery$3.mixin("emitter"), _dec(_class = class AutosnatchCache2 {
    constructor(settings, userId, queue = [], undos = []) {
      __publicField(this, "modifyMutex", new Mutex());
      this.settings = settings;
      this.userId = userId;
      this.queue = queue;
      this.undos = undos;
    }
    static create(settings, userId, persistable) {
      if (persistable && persistable.userId === userId) {
        return new AutosnatchCache2(settings, persistable.userId, persistable.queue, persistable.undos);
      }
      return new AutosnatchCache2(settings, userId);
    }
    getPersistable() {
      return {
        userId: this.userId,
        queue: this.queue,
        undos: this.undos
      };
    }
    async checkWaitingAutosnatches(tabId) {
      const loadedTabIds = (await browser.tabs.query({
        discarded: false
      })).map((t) => t.id);
      const responsePromises = {};
      for (const autosnatch of this.queue) {
        if (autosnatch.waitForContentScript !== void 0 && (tabId === void 0 || autosnatch.waitForContentScript.tabId === tabId)) {
          if (!loadedTabIds.includes(tabId)) {
            return responsePromises[autosnatch.id] = Promise.resolve(false);
          }
          responsePromises[autosnatch.id] = sendMessageToTab(autosnatch.waitForContentScript.tabId, {
            type: "GetIsAutosnatchActive",
            autosnatchId: autosnatch.id
          }, autosnatch.waitForContentScript.frameId);
        }
      }
      let autosnatchUpdated = false;
      for (const autosnatch of this.queue) {
        if (autosnatch.waitForContentScript !== void 0) {
          try {
            const isActive = await responsePromises[autosnatch.id];
            if (isActive === false) {
              autosnatch.waitForContentScript = void 0;
              autosnatch.hideUntilCompletion = false;
              autosnatchUpdated = true;
            }
          } catch (e) {
            autosnatch.waitForContentScript = void 0;
            autosnatch.hideUntilCompletion = false;
            autosnatchUpdated = true;
            trackError(new Error("Failed to check waiting autosnatch", {
              cause: e
            }));
          }
        }
      }
      return autosnatchUpdated;
    }
    async processEnqueuedChanges(clientCore) {
      await this.modifyWithOptionalChangeEvent(async () => {
        const {
          changed
        } = await this.doProcessEnqueuedChanges(clientCore);
        return {
          changed,
          result: void 0
        };
      });
    }
    async doProcessEnqueuedChanges(clientCore) {
      if (!clientCore.isUnlocked()) {
        return {
          wasLocked: true,
          changed: false
        };
      }
      let changed, newQueue, newUndos;
      try {
        ({
          changed,
          newQueue,
          newUndos
        } = await this.getNewQueueAndUndos(clientCore));
        this.queue = newQueue;
        this.undos = newUndos;
      } catch (e) {
        if (e instanceof ClientCoreIsLockedError) {
          return {
            wasLocked: true,
            changed: false
          };
        }
        throw e;
      }
      await this.setAutosnatchAchievements(clientCore);
      const {
        changed: undosChanged
      } = await this.deleteUndosOlderThan(getExpiredUndoDate());
      return {
        wasLocked: false,
        changed: changed || undosChanged
      };
    }
    async setAutosnatchAchievements(clientCore) {
      if (this.undos.some((u2) => u2.type === "create")) {
        await clientCore.addAchievement(Achievement.EXT_LOGIN_INSERT);
      }
      if (this.undos.some((u2) => u2.type === "update")) {
        await clientCore.addAchievement(Achievement.EXT_LOGIN_UPDATE);
      }
    }
    async getNewQueueAndUndos(clientCore) {
      let changed = await this.checkWaitingAutosnatches();
      const {
        vaultQueues,
        waiting
      } = this.splitByVaultId();
      const newUndos = [];
      const newQueue = waiting;
      for (const [vaultId, {
        queue,
        undos
      }] of vaultQueues.entries()) {
        if (vaultId === void 0) {
          newQueue.push(...queue);
          newUndos.push(...undos);
        } else {
          if (queue.length === 0 && undos.every((u2) => !u2.applied)) {
            newUndos.push(...undos);
          } else {
            const newVaultUndos = await this.applyToVault(clientCore, vaultId, queue, undos);
            newUndos.push(...newVaultUndos);
            changed = true;
          }
        }
      }
      return {
        changed,
        newQueue,
        newUndos
      };
    }
    async applyToVault(clientCore, vaultId, queue, undos) {
      try {
        return await clientCore.batchModify(async (batchCC) => {
          const modificationFunctions = createModificationFunctions(batchCC, vaultId);
          const {
            undos: newUndos
          } = await applyEnqueued(modificationFunctions, undos, queue);
          return newUndos;
        });
      } catch (e) {
        if (e instanceof DomainError$1 && e.code === ClientCoreErrorCode.VaultNotFound) {
          return [];
        }
        throw e;
      }
    }
    async addAndProcessAutosnatch(login, vaultId, url, contentScript, {
      seen
    }, clientCore) {
      return this.modifyWithOptionalChangeEvent(async () => {
        const id = login.autosnatchId;
        const waitForContentScript = login.waitForTab ? contentScript : void 0;
        this.queue.push({
          id,
          username: login.username,
          password: login.password,
          url,
          date: (/* @__PURE__ */ new Date()).toISOString(),
          seen,
          forceCreate: login.forceCreate,
          targetLoginId: login.targetLoginId,
          targetVaultId: vaultId,
          waitForContentScript,
          hideUntilCompletion: login.hideUntilCompletion,
          addTldPlus1: login.addTldPlus1,
          source: login.source
        });
        const processResult = await this.doProcessEnqueuedChanges(clientCore);
        return {
          changed: processResult.wasLocked ? true : processResult.changed,
          result: id
        };
      });
    }
    async updateAutosnatch(login) {
      return this.modify(() => {
        const index = this.queue.findIndex((autosnatch) => autosnatch.id === login.autosnatchId);
        if (index === -1) {
          throw new Error("Autosnatch not found");
        }
        if (this.queue[index].waitForContentScript === void 0) {
          throw new Error("refusing to update an autosnatch without waitForTabId");
        }
        const update = {};
        if (login.overrideTargetVaultId) {
          update.targetVaultId = login.overrideTargetVaultId;
        }
        if (login.password !== void 0) {
          update.password = login.password;
        }
        if (login.username !== void 0) {
          update.username = login.username;
        }
        if (login.waitForTab === false) {
          update.waitForContentScript = void 0;
        }
        if (login.targetLoginId !== void 0) {
          throw new Error("cannot update targetLoginId");
        }
        this.queue[index] = {
          ...this.queue[index],
          ...update
        };
      });
    }
    async updateAutosnatchesWaitingForTab(tabId, tabRemoved) {
      return this.modifyWithOptionalChangeEvent(async () => {
        let queueUpdated = false;
        if (tabRemoved) {
          for (const q of this.queue) {
            if (q.waitForContentScript && q.waitForContentScript.tabId === tabId) {
              q.waitForContentScript = void 0;
              queueUpdated = true;
            }
          }
        } else {
          queueUpdated = await this.checkWaitingAutosnatches(tabId);
        }
        return {
          changed: queueUpdated,
          result: queueUpdated
        };
      });
    }
    async deleteUndosOlderThan(date2) {
      const previousUndoLength = this.undos.length;
      this.undos = this.undos.filter((u2) => u2.applied || new Date(u2.editTime) > date2);
      return {
        changed: this.undos.length !== previousUndoLength
      };
    }
    async markAsSeen(ids) {
      await this.modifyWithOptionalChangeEvent(() => {
        let changed = false;
        [...this.undos, ...this.queue].filter((u2) => ids.includes(u2.id)).forEach((u2) => {
          u2.seen = true;
          changed = true;
        });
        return {
          changed,
          result: void 0
        };
      });
    }
    async undo(id) {
      await this.modifyWithOptionalChangeEvent(() => {
        const undo = this.undos.find((u2) => !u2.applied && u2.id === id);
        if (undo) {
          undo.applied = true;
          return {
            changed: true,
            result: void 0
          };
        }
        const enqueuedAutosnatchIndex = this.queue.findIndex((u2) => u2.id === id);
        if (enqueuedAutosnatchIndex !== -1) {
          this.queue.splice(enqueuedAutosnatchIndex, 1);
          return {
            changed: true,
            result: void 0
          };
        }
        trackError(new Error("Undo with unknown undo id"));
        return {
          changed: false,
          result: void 0
        };
      });
    }
    getContentLoginsWithUndoInfo(url, loginsForUrl, clientCore, options) {
      const queue = (options == null ? void 0 : options.omitIncomplete) ? this.queue.filter((q) => !q.hideUntilCompletion) : [...this.queue];
      const undos = [...this.undos];
      const logins = loginsForUrl.map((l) => ({
        ...l
      }));
      for (const undo of undos) {
        const matchingLogins = logins.filter((l) => l.id === undo.loginId && undo.editTime === l.editTime).sort((a2, b) => a2.id.localeCompare(b.id));
        const matchingLogin = matchingLogins.length ? matchingLogins[0] : void 0;
        if (matchingLogin) {
          if (undo.applied) {
            if (undo.type === "update") {
              matchingLogin.editTime = undo.oldEditTime;
              if (undo.oldPassword) {
                matchingLogin.password = undo.oldPassword;
              }
              if (undo.oldUsername) {
                matchingLogin.username = undo.oldUsername;
              }
            } else {
              logins.splice(logins.findIndex((l) => l.id === undo.loginId), 1);
            }
          } else {
            matchingLogin.undo = {
              id: undo.id,
              type: undo.type,
              date: undo.editTime,
              seen: !!undo.seen
            };
          }
        }
      }
      for (const enq of queue) {
        const matchingLogin = findMatchingLogin(enq, logins);
        if (matchingLogin) {
          if (!autosnatchIsNoopForLogin(clientCore, matchingLogin, enq)) {
            matchingLogin.undo = {
              id: enq.id,
              type: "update",
              date: enq.date,
              seen: !!enq.seen
            };
          }
        } else {
          const {
            websites,
            websiteAttributes
          } = createAutosnatchLoginWebsites(enq.url, !!enq.addTldPlus1);
          const parsedUrl = f$1(url);
          const urlSimilarity = parsedUrl ? Math.max(...websites.flatMap((ws) => {
            const similarity = a(parsedUrl, ws);
            return similarity !== null ? [similarity] : [];
          })) : -Infinity;
          if (urlSimilarity !== -Infinity) {
            const vaultId = enq.targetVaultId ?? this.settings.getTargetVaultId();
            let vaultMetadata;
            let organizationMetadata;
            if (vaultId) {
              const vaultPair = clientCore.vaultRepo.getLoginVaultPairById(vaultId);
              if (vaultPair) {
                vaultMetadata = getLoginVaultMetadata(clientCore, vaultPair);
              }
              if (vaultPair == null ? void 0 : vaultPair.login.organizationId) {
                const organization = clientCore.accountState.getOrganization(vaultPair == null ? void 0 : vaultPair.login.organizationId);
                if (organization) {
                  organizationMetadata = {
                    id: organization.id,
                    isAdmin: organization.isAdmin,
                    name: organization.name
                  };
                }
              }
            }
            const login = {
              uiType: LoginUiType.login,
              title: "",
              username: enq.username,
              password: {
                unencrypted: enq.password,
                contentId: newUuid$1()
              },
              websites,
              websiteAttributes,
              note: "",
              editTime: enq.date,
              creationTime: enq.date,
              customFields: [],
              changeTime: enq.date
            };
            logins.push({
              ...login,
              urlSimilarity,
              permissions: getLoginPermissions(login, (vaultMetadata == null ? void 0 : vaultMetadata.permissions) ?? ALL_LOGIN_VAULT_PERMISSIONS),
              uiType: LoginUiType.login,
              id: enq.id,
              vaultMetadata,
              organization: organizationMetadata,
              undo: {
                id: enq.id,
                type: "create",
                date: enq.date,
                seen: !!enq.seen
              },
              totp: void 0,
              showTotpTimeOffsetWarning: false
            });
          }
        }
      }
      return logins;
    }
    async modify(cb) {
      return this.modifyWithOptionalChangeEvent(async () => {
        const result2 = await cb();
        return {
          result: result2,
          changed: true
        };
      });
    }
    async modifyWithOptionalChangeEvent(cb) {
      return this.modifyMutex.runExclusive(async () => {
        const {
          result: result2,
          changed
        } = await cb();
        if (changed) {
          await this.emitter.emit("change");
        }
        return result2;
      });
    }
    splitByVaultId() {
      const autosnatchTargetVaultId = this.settings.getTargetVaultId();
      const waiting = [];
      const vaultQueues = /* @__PURE__ */ new Map();
      for (const enq of this.queue) {
        if (enq.waitForContentScript !== void 0) {
          waiting.push(enq);
          continue;
        }
        const vaultId = enq.targetVaultId ?? autosnatchTargetVaultId;
        let vaultQueue = vaultQueues.get(vaultId);
        if (!vaultQueue) {
          vaultQueue = {
            undos: [],
            queue: []
          };
          vaultQueues.set(vaultId, vaultQueue);
        }
        vaultQueue.queue.push(enq);
      }
      for (const undo of this.undos) {
        const vaultId = undo.vaultId ?? autosnatchTargetVaultId;
        let vaultQueue = vaultQueues.get(vaultId);
        if (!vaultQueue) {
          vaultQueue = {
            undos: [],
            queue: []
          };
          vaultQueues.set(vaultId, vaultQueue);
        }
        vaultQueue.undos.push(undo);
      }
      return {
        waiting,
        vaultQueues
      };
    }
  }) || _class);
  function autosnatchIsNoopForLogin(clientCore, matchingLogin, enq) {
    var _a2, _b2;
    if (matchingLogin.username !== enq.username) {
      return false;
    }
    if ("unencrypted" in matchingLogin.password) {
      return matchingLogin.password.unencrypted === enq.password;
    }
    const vaultId = (_a2 = matchingLogin.vaultMetadata) == null ? void 0 : _a2.id;
    if (!vaultId) {
      return false;
    }
    const vault = clientCore.getLoginVaultById(vaultId);
    if (!vault) {
      return false;
    }
    try {
      const password = (_b2 = clientCore.protectedSecretRepo) == null ? void 0 : _b2.unprotect(vault, matchingLogin.password);
      return password === enq.password;
    } catch (e) {
      if (e instanceof CannotUnprotectError) {
        return false;
      }
      throw e;
    }
  }
  function getExpiredUndoDate() {
    const date2 = new Date((/* @__PURE__ */ new Date()).getTime() - 864e5);
    date2.setHours(2, 0, 0, 0);
    return date2;
  }
  background;
  async function extractTargetTab(sender) {
    return sender.tab ?? getActiveTab();
  }
  async function getActiveTab() {
    const tabs = await browser$1.tabs.query({
      active: true,
      currentWindow: true
    });
    if (tabs && tabs.length) {
      return tabs[0];
    }
    const allActiveTabs = await browser$1.tabs.query({
      active: true
    });
    return allActiveTabs[0];
  }
  background;
  class AutosnatchHandler {
    constructor(clientCore, settings) {
      __publicField(this, "autosnatchCache");
      __publicField(this, "messageListener", makeMessageListener({
        LoginSnatched: ({
          login
        }, sender) => this.handleLoginSnatched(login, sender).catch(trackError),
        UpdateAutosnatchLogin: ({
          login
        }) => this.handleUpdateAutosnatchLogin(login).catch(trackError),
        UndoAutosnatch: ({
          id
        }) => this.processUndo(id),
        MarkAutosnatchesSeen: ({
          ids
        }) => this.autosnatchCache.markAsSeen(ids).catch(trackError)
      }));
      __publicField(this, "handleSyncEnd", () => {
        this.processEnqueuedChangesDebounced();
      });
      __publicField(this, "handleUnlockedChange", ({
        isUnlocked
      }) => {
        if (isUnlocked) {
          this.processEnqueuedChanges().catch(trackError);
        }
      });
      __publicField(this, "handleAutosnatchCacheChange", debounce(5e3, () => {
        this.persistAutosnatchCache().catch(trackError);
      }));
      __publicField(this, "handleTabRemoved", (tabId) => {
        const f2 = async () => {
          const cacheChanged = await this.autosnatchCache.updateAutosnatchesWaitingForTab(tabId, true);
          if (cacheChanged) {
            await this.autosnatchCache.processEnqueuedChanges(this.clientCore);
          }
        };
        f2().catch(trackError);
      });
      __publicField(this, "handleTabUpdated", (tabId) => {
        const f2 = async () => {
          const cacheChanged = await this.autosnatchCache.updateAutosnatchesWaitingForTab(tabId);
          if (cacheChanged) {
            await this.autosnatchCache.processEnqueuedChanges(this.clientCore);
          }
        };
        f2().catch(trackError);
      });
      __publicField(this, "processEnqueuedChangesDebounced", debounce(1e3, () => {
        this.processEnqueuedChanges().catch(trackError);
      }));
      this.clientCore = clientCore;
      this.settings = settings;
    }
    async init() {
      const persistable = await AutosnatchHandler.getPersistableAutosnatchCache();
      this.autosnatchCache = AutosnatchCache.create(this.settings, this.clientCore.accountState.userId, persistable);
      this.autosnatchCache.on("change", this.handleAutosnatchCacheChange);
      this.clientCore.on("syncEnd", this.handleSyncEnd);
      this.clientCore.on("unlockedChange", this.handleUnlockedChange);
      eventProxy.addListener("runtime.onMessage", this.messageListener);
      eventProxy.addListener("tabs.onRemoved", this.handleTabRemoved);
      eventProxy.addListener("tabs.onUpdated", this.handleTabUpdated);
    }
    close() {
      AutosnatchHandler.clearPersistedAutosnatchCache().catch(trackError);
      this.autosnatchCache.off("change", this.handleAutosnatchCacheChange);
      this.clientCore.off("syncEnd", this.handleSyncEnd);
      this.clientCore.off("unlockedChange", this.handleUnlockedChange);
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
      eventProxy.removeListener("tabs.onRemoved", this.handleTabRemoved);
      eventProxy.removeListener("tabs.onUpdated", this.handleTabUpdated);
    }
    getAutosnatchCache() {
      return this.autosnatchCache;
    }
    async handleLoginSnatched(autosnatchLogin, sender) {
      var _a2;
      const tab = await extractTargetTab(sender);
      const url = tab == null ? void 0 : tab.url;
      if (!url) {
        return;
      }
      if (!autosnatchLogin.targetLoginId && !autosnatchLogin.forceCreate) {
        const vaultId = autosnatchLogin.overrideTargetVaultId ?? this.settings.getTargetVaultId();
        const hasMatchingLoginInOtherVault = this.clientCore.vaultRepo.getLoginVaultPairs().filter(({
          login
        }) => login.id !== vaultId).some(({
          login
        }) => {
          const loginsForUrl = R(url, login.getContent().logins);
          return loginsForUrl.some(({
            username
          }) => username === autosnatchLogin.username);
        });
        if (hasMatchingLoginInOtherVault) {
          debugConsole.log("[AutosnatchHandler]", "not enqueuing autosnatch because login with same username for website present in other vault");
          return;
        }
      }
      const contentScript = ((_a2 = sender.tab) == null ? void 0 : _a2.id) ? {
        tabId: sender.tab.id,
        frameId: sender.frameId
      } : void 0;
      await this.addAndProcessAutosnatch(autosnatchLogin, url, contentScript, autosnatchLogin.targetLoginId ? {
        seen: true
      } : void 0);
    }
    async handleUpdateAutosnatchLogin(login) {
      await this.autosnatchCache.updateAutosnatch(login);
      await this.processEnqueuedChanges();
    }
    async addAndProcessAutosnatch(autosnatchLogin, url, contentScript, {
      seen = false
    } = {}) {
      const vaultId = autosnatchLogin.overrideTargetVaultId ?? this.settings.getTargetVaultId();
      const id = await this.autosnatchCache.addAndProcessAutosnatch(autosnatchLogin, vaultId, url, contentScript, {
        seen
      }, this.clientCore);
      return id;
    }
    async processUndo(id) {
      await this.autosnatchCache.undo(id);
      await this.processEnqueuedChanges();
    }
    async processEnqueuedChanges() {
      await this.autosnatchCache.processEnqueuedChanges(this.clientCore);
    }
    async persistAutosnatchCache() {
      await browser$1.storage.local.set({
        autosnatchCache: jsonStringifyFreeze(this.autosnatchCache.getPersistable())
      });
    }
    static async clearPersistedAutosnatchCache() {
      await browser$1.storage.local.remove("autosnatchCache");
    }
    static async getPersistableAutosnatchCache() {
      const fieldValue = (await browser$1.storage.local.get("autosnatchCache")).autosnatchCache;
      try {
        return PersistableAutosnatchCache.parse(jsonParseThaw(fieldValue));
      } catch (e) {
        return null;
      }
    }
  }
  background;
  class AutosnatchSettingsHandler {
    constructor(clientCore) {
      __publicField(this, "messageListener", makeMessageListener({
        GetAutosnatchTargets: () => this.handleGetAutosnatchTargets(),
        GetAutosnatchSettings: () => this.handleGetAutosnatchSettings(),
        SetAutosnatchSettings: (msg) => this.handleSetAutosnatchSettings(msg)
      }));
      this.clientCore = clientCore;
    }
    init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
    async handleGetAutosnatchTargets() {
      const menuStructure = getMenuStructure(this.clientCore);
      const targetGroups = menuStructure.flatMap((me) => {
        if (!me.profileId) {
          return [];
        }
        const vaults = me.vaults.flatMap((v2) => canAutosnatchToVault(v2) ? {
          vaultId: v2.id,
          label: g$1(v2)
        } : []);
        if (!vaults.length) {
          return [];
        }
        return [{
          profileId: me.profileId,
          organizationId: me.type === "organization" ? me.organization.id : void 0,
          accountLabel: me.type === "private" ? i18n._(
            /*i18n*/
            {
              id: "0MTaJs"
            }
          ) : me.organization.name,
          vaults
        }];
      }).filter((g2) => g2.vaults.length !== 0);
      const hasDisabledProfiles = this.clientCore.profileRepo.disabledProfiles.length > 0;
      return {
        targetGroups,
        hasDisabledProfiles
      };
    }
    getTargetVaultId() {
      const meta = this.clientCore.getSessionMetaById(this.clientCore.getSessionId());
      const targetVaultId = meta == null ? void 0 : meta.autosnatchTarget;
      if (!targetVaultId || !this.clientCore.vaultRepo.getLoginVaultById(targetVaultId)) {
        return this.getDefaultAutosnatchTargetVaultId();
      }
      return targetVaultId;
    }
    getAutosnatchDisabled() {
      var _a2;
      return !!((_a2 = this.clientCore.getSessionMetaById(this.clientCore.getSessionId())) == null ? void 0 : _a2.autosnatchDisabled);
    }
    async handleGetAutosnatchSettings() {
      return {
        targetVaultId: this.getTargetVaultId(),
        disabled: this.getAutosnatchDisabled()
      };
    }
    async handleSetAutosnatchSettings({
      targetVaultId,
      disabled
    }) {
      const sessionId = this.clientCore.getSessionId();
      let sessionMeta = {};
      if (targetVaultId !== void 0) {
        sessionMeta = {
          ...sessionMeta,
          autosnatchTarget: targetVaultId
        };
      }
      if (disabled !== void 0) {
        sessionMeta = {
          ...sessionMeta,
          autosnatchDisabled: disabled
        };
      }
      await this.clientCore.modifyMetaVault((c2, ts, {
        replaceSession: replaceSession2
      }) => replaceSession2(c2, ts, sessionId, sessionMeta));
    }
    // The default autosnatch target is the the first private or personal vault in the menu structure
    getDefaultAutosnatchTargetVaultId() {
      var _a2;
      const menu = getMenuStructure(this.clientCore);
      const vaultCandidates = menu.flatMap((me) => me.vaults);
      return (_a2 = vaultCandidates.find((v2) => canAutosnatchToVault(v2) && (v2.type === VaultType.PRIVATE || v2.type === VaultType.ORGANIZATION_PERSONAL))) == null ? void 0 : _a2.id;
    }
  }
  function canAutosnatchToVault(vmd) {
    return vmd.permissions.createLogins && vmd.permissions.editLogins;
  }
  background;
  const browserActionShim = browser$1.action ?? browser$1.browserAction;
  const _BadgeUpdater = class _BadgeUpdater {
    constructor(clientCore, loginsForUrl, autosnatchCache, siteSettingsHandler) {
      // We need to cache tab urls, since we can get update events in which the url doesn't change, e.g.
      // a page reload. But a reload still counts as a "navigation" and thus clear the tab badge text.
      __publicField(this, "tabUrls", /* @__PURE__ */ new Map());
      __publicField(this, "handleTabUpdate", (tabId, {
        url
      }) => {
        this.updateTabBadge(tabId, url).catch(trackError);
      });
      __publicField(this, "handleTabActivate", ({
        tabId
      }) => {
        this.updateTabBadge(tabId, void 0).catch(trackError);
      });
      __publicField(this, "handleTabCreate", ({
        id,
        url
      }) => {
        if (id) {
          this.updateTabBadge(id, url).catch(trackError);
        }
      });
      __publicField(this, "handleTabRemove", (tabId) => {
        this.tabUrls.delete(tabId);
      });
      __publicField(this, "handleVaultRepoChange", () => {
        this.updateAllActiveTabBadges().catch(trackError);
      });
      __publicField(this, "handleAutosnatchCacheChange", () => {
        this.updateAllActiveTabBadges().catch(trackError);
      });
      this.clientCore = clientCore;
      this.loginsForUrl = loginsForUrl;
      this.autosnatchCache = autosnatchCache;
      this.siteSettingsHandler = siteSettingsHandler;
    }
    init() {
      var _a2;
      eventProxy.addListener("tabs.onUpdated", this.handleTabUpdate);
      eventProxy.addListener("tabs.onCreated", this.handleTabCreate);
      eventProxy.addListener("tabs.onActivated", this.handleTabActivate);
      eventProxy.addListener("tabs.onRemoved", this.handleTabRemove);
      this.clientCore.on("vaultRepoChange", this.handleVaultRepoChange);
      this.autosnatchCache.on("change", this.handleAutosnatchCacheChange);
      (_a2 = browserActionShim.setBadgeBackgroundColor({
        color: _BadgeUpdater.BADGE_COLOR_DEFAULT
      })) == null ? void 0 : _a2.catch(trackError);
      this.updateAllActiveTabBadges().catch(trackError);
    }
    close() {
      eventProxy.removeListener("tabs.onUpdated", this.handleTabUpdate);
      eventProxy.removeListener("tabs.onCreated", this.handleTabCreate);
      eventProxy.removeListener("tabs.onRemoved", this.handleTabRemove);
      this.clientCore.off("vaultRepoChange", this.handleVaultRepoChange);
      this.autosnatchCache.off("change", this.handleAutosnatchCacheChange);
      _BadgeUpdater.clearAllBadges().catch(trackError);
    }
    async updateAllActiveTabBadges() {
      const tabs = await browser$1.tabs.query({
        active: true
      });
      const updatePromises = [];
      for (const {
        id,
        url
      } of tabs) {
        if (id && url) {
          this.tabUrls.set(id, url);
          const badgeUpdate = this.getBadgeUpdate(id, url);
          if (badgeUpdate) {
            updatePromises.push(_BadgeUpdater.applyBadgeUpdate(badgeUpdate));
          }
          await yieldToEventLoop();
        }
      }
      await Promise.all(updatePromises);
    }
    async updateTabBadge(tabId, urlCandidate) {
      let url = urlCandidate ?? this.tabUrls.get(tabId);
      if (!url) {
        const tab = await browser$1.tabs.get(tabId);
        if (tab) {
          ({
            url
          } = tab);
        }
      }
      if (!url) {
        return;
      }
      this.tabUrls.set(tabId, url);
      const badgeUpdate = this.getBadgeUpdate(tabId, url);
      if (!badgeUpdate) {
        return;
      }
      await _BadgeUpdater.applyBadgeUpdate(badgeUpdate);
    }
    getBadgeUpdate(tabId, url) {
      const {
        disabled
      } = this.siteSettingsHandler.getDisabledSiteSettingForUrl(url);
      const logins = this.loginsForUrl.getLogins(url) ?? [];
      const contentLogins = this.autosnatchCache.getContentLoginsWithUndoInfo(url, logins, this.clientCore, {
        omitIncomplete: true
      });
      const text = contentLogins.length ? `${contentLogins.length}` : disabled ? "X" : "";
      const {
        backgroundColor,
        textColor
      } = _BadgeUpdater.getBadgeColors(!!disabled);
      return {
        tabId,
        text,
        backgroundColor,
        textColor
      };
    }
    static async applyBadgeUpdate({
      tabId,
      text,
      backgroundColor,
      textColor
    }) {
      try {
        await Promise.all([browserActionShim.setBadgeText({
          tabId,
          text
        }), browserActionShim.setBadgeBackgroundColor({
          tabId,
          color: backgroundColor
        }), browserActionShim.setBadgeTextColor({
          tabId,
          color: textColor
        })]);
      } catch (e) {
      }
    }
    static getBadgeColors(disabledForUrl) {
      if (disabledForUrl) {
        return {
          backgroundColor: _BadgeUpdater.BADGE_COLOR_DISABLED,
          textColor: _BadgeUpdater.BADGE_TEXT_COLOR_LIGHT
        };
      }
      return {
        backgroundColor: _BadgeUpdater.BADGE_COLOR_DEFAULT,
        textColor: _BadgeUpdater.BADGE_TEXT_COLOR_LIGHT
      };
    }
    static async clearAllBadges() {
      const tabs = await browser$1.tabs.query({});
      const updatePromises = tabs.map(async ({
        id
      }) => browserActionShim.setBadgeText({
        tabId: id,
        text: null
      }));
      return Promise.all(updatePromises);
    }
  };
  // --hl-color-spanish-gray-600
  __publicField(_BadgeUpdater, "BADGE_COLOR_DEFAULT", "hsla(0, 0%, 44%, 255)");
  // --hl-color-red-crayola-500, --color-error
  __publicField(_BadgeUpdater, "BADGE_COLOR_DISABLED", "hsla(352, 92%, 53%, 255)");
  // --hl-
  __publicField(_BadgeUpdater, "BADGE_TEXT_COLOR_LIGHT", "white");
  let BadgeUpdater = _BadgeUpdater;
  async function yieldToEventLoop() {
    await sleep(15);
  }
  background;
  const REQUEST_FILTER = {
    urls: ["*://*/*"]
  };
  class BasicAuthHandler {
    constructor(loginsForUrl) {
      __publicField(this, "pendingRequests", []);
      __publicField(this, "handleAuthRequired", (requestDetails) => {
        debugConsole.log("[BasicAuthHandler]", requestDetails);
        return this.processBasicAuth(requestDetails.requestId, requestDetails.url);
      });
      __publicField(this, "handleCompleted", ({
        requestId
      }) => {
        const index = this.pendingRequests.indexOf(requestId);
        if (index > -1) {
          this.pendingRequests.splice(index, 1);
        }
      });
      this.loginsForUrl = loginsForUrl;
      this.loginsForUrl = loginsForUrl;
    }
    init() {
      if (!browser$1.webRequest) {
        return;
      }
      browser$1.webRequest.onAuthRequired.addListener(this.handleAuthRequired, REQUEST_FILTER, ["blocking"]);
      browser$1.webRequest.onCompleted.addListener(this.handleCompleted, REQUEST_FILTER);
      browser$1.webRequest.onErrorOccurred.addListener(this.handleCompleted, REQUEST_FILTER);
    }
    close() {
      if (!browser$1.webRequest) {
        return;
      }
      browser$1.webRequest.onAuthRequired.removeListener(this.handleAuthRequired);
      browser$1.webRequest.onCompleted.removeListener(this.handleCompleted);
      browser$1.webRequest.onErrorOccurred.removeListener(this.handleCompleted);
    }
    processBasicAuth(requestId, url) {
      if (this.pendingRequests.includes(requestId)) {
        debugConsole.log("[BasicAuthHandler]", `bad credentials for: ${requestId}`);
        return;
      }
      this.pendingRequests.push(requestId);
      const logins = this.loginsForUrl.getLogins(url);
      if (!logins) {
        return;
      }
      const loginList = logins.filter((l) => l.customFields.some((cf) => cf.name.toLowerCase().includes("basic auth")));
      if (loginList.length !== 1) {
        return;
      }
      const login = loginList[0];
      const password = this.loginsForUrl.unprotect(login.vaultMetadata.id, login.password);
      if (password === void 0) {
        return;
      }
      return {
        authCredentials: {
          username: login.username,
          password
        }
      };
    }
  }
  background;
  background;
  background;
  background;
  background;
  background;
  function makeConnectionListener(handlers2) {
    return (port) => {
      const {
        name,
        connectionId
      } = parsePortName(port.name);
      if (!isKey(name, handlers2)) {
        return;
      }
      const handler = handlers2[name];
      if (handler) {
        handler(port, connectionId);
      }
    };
  }
  function parsePortName(portName) {
    const [name, ...rest] = portName.split(",");
    if (rest.length) {
      return {
        name,
        connectionId: rest.join(",")
      };
    }
    return {
      name,
      connectionId: void 0
    };
  }
  function isKey(k, obj) {
    return k in obj;
  }
  background;
  let creating;
  async function setupOffscreenDocument(reason, justification) {
    const path = "offscreen.html";
    const offscreenUrl = browser$1.runtime.getURL(path);
    if (await hasOffscreenDocument(offscreenUrl)) {
      return;
    }
    if (creating) {
      await creating;
    } else {
      creating = chrome.offscreen.createDocument({
        url: offscreenUrl,
        reasons: [reason],
        justification
      });
      await creating;
      creating = void 0;
    }
  }
  function isOffscreenDocumentSupported() {
    return !!chrome.offscreen;
  }
  async function hasOffscreenDocument(offscreenUrl) {
    if (!("getContexts" in chrome.runtime)) {
      const matchedClients = await clients.matchAll();
      return matchedClients.some((client) => client.url.includes(browser$1.runtime.id));
    }
    const contexts = await chrome.runtime.getContexts({
      contextTypes: [chrome.runtime.ContextType.OFFSCREEN_DOCUMENT],
      documentUrls: [offscreenUrl]
    });
    return contexts.length > 0;
  }
  background;
  function getHost$1(urlStr) {
    const url = new URL(urlStr);
    return url.host.replace(/^(www\.)+/, "");
  }
  background;
  class UnlockHandler {
    constructor(port, tabId, url, clientCoreSync, loginsForUrl, webauthnUnlockPortTracker) {
      __publicField(this, "cancelToken", new CancelToken());
      __publicField(this, "onMessage", (message) => {
        debugConsole.log("[UnlockHandler]", "message", message);
        if (message.type === "RequestFormFill") {
          this.handlePerformLogin(message.loginId, {
            confirmLogin: message.confirmLogin,
            skipWebauthnUnlock: message.skipWebauthnUnlock
          }).catch(trackError);
          return;
        }
        if (message.type === "RequestUnlock") {
          debugConsole.log("[UnlockHandler]", message);
          this.handleRequestUnlock(message.skipWebauthnUnlock).catch(trackError);
          return;
        }
        if (message.type === "AddTotpParametersToLogin") {
          this.handleAddTotpParametersToLogin(message.loginId, message.vaultId, message.totpParameters, message.skipWebauthnUnlock).catch(trackError);
          return;
        }
        if (message.type === "WebauthnUnlockIframeSetUp") {
          this.handleWebauthnUnlockIframeSetUp(message.webauthnUnlockId).catch(trackError);
          return;
        }
        assertExhaustive();
      });
      __publicField(this, "onDisconnect", () => {
        this.cancelToken.cancel();
        debugConsole.log("[UnlockHandler]", "disconnect");
        this.port.onMessage.removeListener(this.onMessage);
        this.port.onDisconnect.removeListener(this.onDisconnect);
      });
      this.port = port;
      this.tabId = tabId;
      this.url = url;
      this.clientCoreSync = clientCoreSync;
      this.loginsForUrl = loginsForUrl;
      this.webauthnUnlockPortTracker = webauthnUnlockPortTracker;
    }
    start() {
      debugConsole.log("[UnlockHandler]", "start");
      this.port.onMessage.addListener(this.onMessage);
      this.port.onDisconnect.addListener(this.onDisconnect);
    }
    postStateMessage(state) {
      const msg = {
        type: "StateUpdate",
        state
      };
      debugConsole.log("[UnlockHandler]", "postStateMessage", state);
      this.port.postMessage(msg);
    }
    async ensureUnlocked(skipWebauthnUnlock) {
      if (this.clientCoreSync.clientCore.isPinnedUnlocked()) {
        this.postStateMessage("unlocking");
        const response = await browser$1.runtime.sendNativeMessage("application.id", {
          type: "triggerBiometricUnlock"
        });
        if (response.success) {
          this.postStateMessage("unlocked");
          return true;
        } else {
          this.postStateMessage("error");
          return false;
        }
      }
      if (!this.isUnlocked()) {
        this.postStateMessage("unlocking");
        try {
          await setPromiseTimeout(this.requestUnlock(this.cancelToken, skipWebauthnUnlock), 3e4);
        } catch (e) {
          if (e instanceof UnlockRejectedError) {
            this.postStateMessage("error");
            return false;
          }
          if (e instanceof UnlockTimeout) {
            this.cancelToken.cancel();
            this.postStateMessage("warning");
            return false;
          }
          if (e instanceof Cancel) {
            return false;
          }
          throw e;
        }
      }
      this.postStateMessage("unlocked");
      return true;
    }
    triggerWebauthnUnlockIfPossible() {
      if (!C()) {
        return;
      }
      const clientCore = this.clientCoreSync.clientCore;
      if (clientCore.accountState.isWebauthnPossibleForSession(clientCore.getSessionId())) {
        this.port.postMessage({
          type: "TriggerWebauthnUnlock"
        });
      }
    }
    async handleRequestUnlock(skipWebauthnUnlock) {
      await this.ensureUnlocked(skipWebauthnUnlock);
      this.port.disconnect();
    }
    async handlePerformLogin(loginId, {
      confirmLogin,
      skipWebauthnUnlock
    }) {
      var _a2, _b2;
      if (await this.ensureUnlocked(skipWebauthnUnlock)) {
        const login = (_a2 = this.getLogins()) == null ? void 0 : _a2.find(({
          id
        }) => id === loginId);
        if (!login) {
          debugConsole.warn(`[UnlockHandler]`, "RequestFormFill", "no login with id", loginId);
          return;
        }
        try {
          if (login.vaultMetadata) {
            await this.clearTeamNewlyJoined(login.vaultMetadata);
          }
          if (confirmLogin) {
            await this.confirmLogin(loginId);
          }
          const host = getHost$1(this.url);
          if ((_b2 = login.vaultMetadata) == null ? void 0 : _b2.id) {
            this.sendLoginNotification(login.vaultMetadata.id, loginId, login.username, host).catch((e) => {
              debugConsole.warn(`[UnlockHandler]`, "RequestFormFill", "failed to send notification", loginId);
              debugConsole.error(e);
            });
          }
          this.writeAutofillAuditlogEvent(login).catch(trackError);
        } catch (e) {
          trackError(e);
        }
        const unprotectedValues = this.getUnprotectedValues(login);
        if (unprotectedValues) {
          await sendMessageToTab(this.tabId, {
            type: "FillForm",
            username: login.username,
            hideSecrets: !login.permissions.viewSecrets,
            ...unprotectedValues
          });
        }
      }
      this.port.disconnect();
    }
    async handleAddTotpParametersToLogin(loginId, vaultId, totpParameters, skipWebauthnUnlock) {
      if (await this.ensureUnlocked(skipWebauthnUnlock)) {
        await this.addTotpParametersToLogin(loginId, vaultId, totpParameters);
      }
      this.port.disconnect();
    }
    getUnprotectedValues(login) {
      var _a2;
      const vaultId = (_a2 = login.vaultMetadata) == null ? void 0 : _a2.id;
      if (!vaultId) {
        return null;
      }
      const customFields = login.customFields.map((cf) => !cf.protected ? cf : {
        ...cf,
        value: this.unprotect(vaultId, cf.value)
      });
      const totp = login.totp && this.unprotect(vaultId, login.totp);
      const password = this.unprotect(vaultId, login.password);
      return {
        password,
        totp,
        customFields
      };
    }
    getLogins() {
      return this.loginsForUrl.getLogins(this.url);
    }
    isUnlocked() {
      return this.clientCoreSync.clientCore.isUnlocked();
    }
    async requestUnlock(cancelToken, skipWebauthnUnlock) {
      await this.clientCoreSync.startRequestUnlock(cancelToken);
      if (skipWebauthnUnlock) {
        const accountState = this.clientCoreSync.clientCore.accountState;
        const isWebauthnOnly = accountState.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.SESSION_UNLOCK) && !accountState.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.PUSH);
        if (isWebauthnOnly) {
          this.port.postMessage({
            type: "WebauthnOnlyUnlockSkipped"
          });
        }
      } else {
        this.triggerWebauthnUnlockIfPossible();
      }
      await this.clientCoreSync.finishRequestUnlock(cancelToken);
    }
    unprotect(vaultId, pv) {
      const vault = this.clientCoreSync.clientCore.vaultRepo.getVaultById(vaultId);
      const {
        protectedSecretRepo
      } = this.clientCoreSync.clientCore;
      if (!protectedSecretRepo) {
        throw new CannotUnprotectError();
      }
      return protectedSecretRepo.unprotect(vault, pv);
    }
    async clearTeamNewlyJoined(vaultMetadata) {
      if (![VaultType.TEAM, VaultType.INBOX].includes(vaultMetadata.type)) {
        return;
      }
      const pair = this.clientCoreSync.clientCore.vaultRepo.getTeamVaultPairById(vaultMetadata.id);
      if (!pair) {
        return;
      }
      const profileId = pair.meta.getProfileId();
      if (profileId && getNewlyJoinedInfo(pair.meta.getContent(), profileId)) {
        await this.clientCoreSync.clientCore.teamClearNewlyJoined(pair.login.id);
      }
    }
    async confirmLogin(loginId) {
      var _a2, _b2;
      const login = (_a2 = this.getLogins()) == null ? void 0 : _a2.find(({
        id
      }) => id === loginId);
      if (!login) {
        debugConsole.warn(`[UnlockHandler]`, "RequestFormFill", "no login with id", loginId);
        return;
      }
      if (!((_b2 = login.vaultMetadata) == null ? void 0 : _b2.id)) {
        throw new Error("trying to modify a login wihtout vaultId");
      }
      await this.clientCoreSync.clientCore.loginSetConfirmed(login.vaultMetadata.id, loginId);
    }
    async sendLoginNotification(vaultId, loginId, username, domain) {
      await this.clientCoreSync.clientCore.onlineSendLoginEventNotification(vaultId, loginId, username, domain);
    }
    async writeAutofillAuditlogEvent(login) {
      var _a2;
      if (!login.organization || !login.vaultMetadata) {
        return;
      }
      await this.clientCoreSync.clientCore.auditlogWriteEventsWithRetry(login.organization.id, {
        type: AuditlogEventType.LOGIN_R_AUTOFILL,
        vaultId: login.vaultMetadata.id,
        loginId: login.id,
        loginRevisionId: (_a2 = login.history) == null ? void 0 : _a2.currentRevisionId,
        loginEditTime: login.editTime
      });
    }
    async addTotpParametersToLogin(loginId, vaultId, totpParameters) {
      await this.clientCoreSync.clientCore.batchModify(async (batchCC) => {
        const vault = batchCC.getLoginVaultById(vaultId);
        if (!vault) {
          debugConsole.warn(`[UnlockHandler]`, "AddTotpToLogin", "no vault with id", vaultId);
          return;
        }
        const login = vault == null ? void 0 : vault.getContent().logins[loginId];
        if (!login) {
          debugConsole.warn(`[UnlockHandler]`, "AddTotpToLogin", "no login with id", loginId);
          return;
        }
        return batchCC.modifyLogin({
          vaultId,
          loginId,
          login: {
            totp: {
              contentId: newUuid$1(),
              unencrypted: totpParameters.secret
            },
            totpAlgorithm: totpParameters.algorithm,
            totpDigits: totpParameters.digits,
            totpPeriod: totpParameters.period
          },
          source: LoginSource.addTotpFromOverlay
        });
      });
    }
    async handleWebauthnUnlockIframeSetUp(webauthnUnlockId) {
      const unlockRequest = await this.getWebauthnUnlockRequest();
      if (!unlockRequest) {
        return;
      }
      const portCandidate = this.webauthnUnlockPortTracker.getPort(webauthnUnlockId);
      if (!portCandidate) {
        debugConsole.log("[UnlockHandler]", "no port");
        return;
      }
      const port = portCandidate;
      const resultPromise = new Promise((resolve) => {
        function onMessage(msg) {
          if (msg.type === "ReturnWebauthnResult") {
            resolve(msg.credentialGetResultJSON);
          }
        }
        function onDisconnect() {
          port.onDisconnect.removeListener(onDisconnect);
          port.onMessage.removeListener(onMessage);
        }
        port.onDisconnect.addListener(onDisconnect);
        port.onMessage.addListener(onMessage);
      });
      const {
        signal: _,
        ...restOptions
      } = unlockRequest.options;
      port.postMessage({
        type: "TriggerWebauthnUnlockInIframe",
        requestOptionsJSON: jsonStringifyFreeze(restOptions)
      });
      const result2 = await Promise.race([resultPromise, sleep(3e4)]);
      if (!result2) {
        return;
      }
      const cred = jsonParseThaw(result2);
      await this.clientCoreSync.clientCore.onlineWebauthnUnlockSessionFinish(unlockRequest.requestId, cred);
      try {
        await this.clientCoreSync.clientCore.onlineWebauthnEnablePrfOpportunistically(unlockRequest, cred);
      } catch (e) {
        debugConsole.log("[useRequestUnlock]", "failed to opportunistically setup prf", e);
      }
    }
    async getWebauthnUnlockRequest() {
      if (!this.clientCoreSync.clientCore.accountState.isWebauthnPossibleForSession(this.clientCoreSync.clientCore.getSessionId())) {
        return void 0;
      }
      try {
        return await this.clientCoreSync.clientCore.onlineWebauthnUnlockSessionInit();
      } catch (e) {
        if (e instanceof DomainError$1) {
          if (e.code === BackendErrorCode.MISSING_WEBAUTHN_CREDENTIAL) {
            return void 0;
          }
          if (e.code === BackendErrorCode.SESSION_NOT_UNLOCKED) {
            return void 0;
          }
        }
        trackError(e);
        return void 0;
      }
    }
  }
  class UnlockTimeout extends Error {
    constructor() {
      super(...arguments);
      __publicField(this, "name", "UnlockTimeout");
    }
  }
  function setPromiseTimeout(pr, timeout) {
    const timeoutPromise = new Promise((_, reject) => {
      globalThis.setTimeout(reject.bind(null, new UnlockTimeout()), timeout);
    });
    return Promise.race([pr, timeoutPromise]);
  }
  background;
  class WebauthnUnlockPortTracker {
    constructor() {
      __publicField(this, "webauthnUnlockPorts", /* @__PURE__ */ new Map());
      __publicField(this, "onConnect", makeConnectionListener({
        WebauthnUnlock: (port) => {
          let webauthnUnlockId;
          const onMessage = (msg) => {
            var _a2;
            if (msg.type === "SetWebauthnUnlockId") {
              if (webauthnUnlockId) {
                (_a2 = this.webauthnUnlockPorts.get(webauthnUnlockId)) == null ? void 0 : _a2.disconnect();
              }
              webauthnUnlockId = msg.id;
              this.webauthnUnlockPorts.set(webauthnUnlockId, port);
            }
          };
          const onDisconnect = () => {
            port.onMessage.removeListener(onMessage);
            port.onDisconnect.removeListener(onDisconnect);
            if (webauthnUnlockId) {
              this.webauthnUnlockPorts.delete(webauthnUnlockId);
            }
          };
          port.onMessage.addListener(onMessage);
          port.onDisconnect.addListener(onDisconnect);
        }
      }));
    }
    init() {
      eventProxy.addListener("runtime.onConnect", this.onConnect);
    }
    close() {
      eventProxy.removeListener("runtime.onConnect", this.onConnect);
    }
    getPort(webauthnUnlockId) {
      return this.webauthnUnlockPorts.get(webauthnUnlockId);
    }
  }
  background;
  class ClientCoreMessageHandler {
    constructor(clientCore, clientCoreSync, loginsForUrl, autosnatchCache) {
      __publicField(this, "webauthnUnlockPortTracker", new WebauthnUnlockPortTracker());
      __publicField(this, "clearClipboardTimeoutId");
      __publicField(this, "handleVaultRepoChange", debounce(500, () => {
        ClientCoreMessageHandler.sendDataUpdate();
      }));
      __publicField(this, "handleAutosnatchCacheChange", () => {
        ClientCoreMessageHandler.sendDataUpdate();
      });
      __publicField(this, "handleUnlockedChange", ({
        isUnlocked
      }) => {
        ClientCoreMessageHandler.sendUnlockStateUpdateMessage(isUnlocked);
        ClientCoreMessageHandler.sendDataUpdate();
      });
      __publicField(this, "messageListener", makeMessageListener({
        GetLogins: ({
          all
        }, sender) => this.handleGetLogins(sender, all),
        GetUser: () => this.getUserData(),
        RequestSync: () => {
          var _a2;
          return (_a2 = this.clientCoreSync) == null ? void 0 : _a2.onlineSyncNonBlocking(null);
        },
        AddAchievements: ({
          achievements
        }) => this.clientCore.addAchievement(...achievements),
        GetPasswordGeneratorSettings: () => this.handleGetPasswordGeneratorSettings(),
        SavePasswordGeneratorSettings: ({
          settings
        }) => this.handleSavePasswordGeneratorSettings(settings),
        WriteAuditlogEvent: async ({
          organizationId,
          event
        }) => {
          await this.clientCore.auditlogWriteEventsWithRetry(organizationId, event);
        },
        GetUnlockDeviceType: () => this.getUnlockDeviceType(),
        PingActivity: () => {
          var _a2;
          return (_a2 = this.clientCoreSync) == null ? void 0 : _a2.pingActivity();
        },
        SetClearValueFromClipboardAfterTimeout: ({
          clearAfterTimeout,
          value
        }) => this.handleSetClearValueFromClipboardAfterTimeout(clearAfterTimeout, value),
        GetUnprotectedValue: ({
          vaultId,
          value
        }) => this.loginsForUrl.unprotectWithContentId(vaultId, value)
      }));
      __publicField(this, "connectionListener", makeConnectionListener({
        Unlock: (port) => {
          this.handleUnlock(port).catch(trackError);
        }
      }));
      this.clientCore = clientCore;
      this.clientCoreSync = clientCoreSync;
      this.loginsForUrl = loginsForUrl;
      this.autosnatchCache = autosnatchCache;
    }
    init() {
      this.clientCore.on("vaultRepoChange", this.handleVaultRepoChange);
      this.clientCore.on("unlockedChange", this.handleUnlockedChange);
      this.autosnatchCache.on("change", this.handleAutosnatchCacheChange);
      eventProxy.addListener("runtime.onMessage", this.messageListener);
      eventProxy.addListener("runtime.onConnect", this.connectionListener);
      this.webauthnUnlockPortTracker.init();
      ClientCoreMessageHandler.sendDataUpdate();
    }
    close() {
      this.clientCore.off("vaultRepoChange", this.handleVaultRepoChange);
      this.clientCore.off("unlockedChange", this.handleUnlockedChange);
      this.autosnatchCache.off("change", this.handleAutosnatchCacheChange);
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
      eventProxy.removeListener("runtime.onConnect", this.connectionListener);
      this.webauthnUnlockPortTracker.close();
      ClientCoreMessageHandler.sendDataUpdate();
    }
    async handleUnlock(port) {
      if (!this.clientCore || !this.clientCoreSync || !port.sender) {
        return;
      }
      const extractedTab = await extractTargetTab(port.sender);
      const url = extractedTab == null ? void 0 : extractedTab.url;
      const tabId = extractedTab == null ? void 0 : extractedTab.id;
      if (!url || !tabId) {
        debugConsole.log(`[Background]`, "Unlock", "no sender!");
        return;
      }
      const unlockHandler = new UnlockHandler(port, tabId, url, this.clientCoreSync, this.loginsForUrl, this.webauthnUnlockPortTracker);
      unlockHandler.start();
    }
    static sendUnlockStateUpdateMessage(isUnlocked) {
      broadcastMessage({
        type: "UnlockStateUpdate",
        isUnlocked
      }).catch(trackError);
    }
    static sendDataUpdate() {
      broadcastMessage({
        type: "DataUpdate"
      }).catch(trackError);
    }
    async getUserData() {
      return {
        userId: this.clientCore.accountState.userId,
        clientId: this.clientCore.backendClient.config.clientId ?? void 0,
        displayEmail: f(this.clientCore.accountState, this.clientCore.profileRepo),
        userClientSettings: this.clientCore.accountState.userClientSettings
      };
    }
    async handleGetLogins(sender, all) {
      const tab = await extractTargetTab(sender);
      let logins;
      if (all) {
        logins = this.loginsForUrl.getAllLogins();
      } else if (!(tab == null ? void 0 : tab.url)) {
        return void 0;
      } else {
        logins = this.loginsForUrl.getLogins(tab.url) ?? [];
      }
      return {
        logins: this.autosnatchCache.getContentLoginsWithUndoInfo((tab == null ? void 0 : tab.url) ?? "", logins, this.clientCore, {
          omitIncomplete: true
        })
      };
    }
    async handleGetPasswordGeneratorSettings() {
      var _a2, _b2;
      const metaVaultContent = (_a2 = this.clientCore.vaultRepo.getMetaVault()) == null ? void 0 : _a2.getContent();
      if (!metaVaultContent) {
        return void 0;
      }
      const settings = ((_b2 = getAccountSettings(metaVaultContent)) == null ? void 0 : _b2.passwordGenerator) ?? null;
      return {
        settings
      };
    }
    async handleSetClearValueFromClipboardAfterTimeout(clear, value) {
      if (this.clearClipboardTimeoutId !== void 0) {
        globalThis.clearTimeout(this.clearClipboardTimeoutId);
      }
      if (!clear) {
        return;
      }
      this.clearClipboardTimeoutId = globalThis.setTimeout(() => {
        this.clearValueFromClipboard(value).catch(trackError);
      }, CLIPBOARD_CLEAR_TIMEOUT_MS);
    }
    async clearValueFromClipboard(value) {
      if (isOffscreenDocumentSupported()) {
        await setupOffscreenDocument(chrome.offscreen.Reason.CLIPBOARD, "Need access to clipboard to clear it if a given value is currently copied");
        await sendMessage({
          type: "ClearValueFromClipboard",
          value
        });
      } else {
        const activeTabs = await browser$1.tabs.query({
          active: true
        });
        const activeTabWithId = activeTabs.find((t) => !!t.id);
        if (activeTabWithId) {
          await sendMessageToTab(activeTabWithId.id, {
            type: "ClearValueFromClipboard",
            value
          });
        }
      }
    }
    async handleSavePasswordGeneratorSettings(settings) {
      await this.clientCore.modifyMetaVault((c2, ts, {
        modifyAccountSettings: modifyAccountSettings2
      }) => modifyAccountSettings2(c2, ts, {
        passwordGenerator: settings
      }));
    }
    getUnlockDeviceType() {
      if (isMobileSafari()) {
        return "mobileSafari";
      }
      const securityKeyPossible = C() && this.clientCore.accountState.isWebauthnPossibleForSession(this.clientCore.getSessionId());
      const phonePossible = this.clientCore.accountState.hasPushAuthenticator();
      if (securityKeyPossible && phonePossible) {
        return "multiple";
      }
      if (securityKeyPossible) {
        return "securityKey";
      }
      return "phone";
    }
  }
  class FallbackClientCoreMessageHandler {
    constructor() {
      __publicField(this, "messageListener", makeMessageListener({
        GetLogins: () => void 0,
        GetUser: () => ({}),
        RequestSync: () => void 0,
        AddAchievements: () => void 0,
        GetPasswordGeneratorSettings: () => void 0,
        SavePasswordGeneratorSettings: () => void 0
      }));
    }
    init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
  }
  background;
  function documentUrlPatternFromWebsite(website) {
    const {
      hostname
    } = getNormalizedPatternParts(website);
    return `*://*.${hostname}/*`;
  }
  background;
  function getBrowserName(precomputedBowser) {
    const browser2 = precomputedBowser ?? Bowser.parse(navigator.userAgent);
    return browser2.browser.name ?? i18n._(
      /*i18n*/
      {
        id: "AlS6pf"
      }
    );
  }
  background;
  const contentScriptBlockedUrls = [
    // firefox
    "accounts-static.cdn.mozilla.net",
    "accounts.firefox.com",
    "addons.cdn.mozilla.net",
    "addons.mozilla.org",
    "api.accounts.firefox.com",
    "content.cdn.mozilla.net",
    "discovery.addons.mozilla.org",
    "input.mozilla.org",
    "install.mozilla.org",
    "oauth.accounts.firefox.com",
    "profile.accounts.firefox.com",
    "support.mozilla.org",
    "sync.services.mozilla.com",
    "testpilot.firefox.com",
    // chrome, edge
    "chrome.google.com",
    // edge
    "microsoftedge.microsoft.com"
  ];
  function isContentScriptBlockedByBrowser(urlStr) {
    let url;
    try {
      url = new URL(urlStr);
    } catch {
      return false;
    }
    return contentScriptBlockedUrls.some((u2) => `.${url.host}`.endsWith(`.${u2}`));
  }
  background;
  const NoopAction = z.object({
    type: z.literal("noop"),
    // Actions are used as id string and need to be unique. Since there may be multiple noops, we add
    // a random value to ensure uniqueness
    random: z.number()
  });
  const EnableForPageAction = z.object({
    type: z.literal("enableForPage")
  });
  const FillUsernameAction = z.object({
    type: z.literal("fillUsername"),
    loginId: z.string().uuid()
  });
  const FillPasswordAction = z.object({
    type: z.literal("fillPassword"),
    loginId: z.string().uuid()
  });
  const FillTotpAction = z.object({
    type: z.literal("fillTotp"),
    loginId: z.string().uuid()
  });
  const FillCustomFieldAction = z.object({
    type: z.literal("fillCustomField"),
    loginId: z.string().uuid(),
    customFieldId: z.string().uuid()
  });
  const ContextMenuAction = z.discriminatedUnion("type", [NoopAction, EnableForPageAction, FillUsernameAction, FillPasswordAction, FillTotpAction, FillCustomFieldAction]);
  background;
  const PROTECTED_PLACEHOLDER = "************";
  class ContextMenuHandler {
    constructor(clientCore, loginsForUrl, siteSettingsHandler) {
      __publicField(this, "unlocked");
      __publicField(this, "setupMenuMutex", new Mutex());
      __publicField(this, "setupMenuCancelToken", new CancelToken());
      __publicField(this, "handleContentScriptMessage");
      __publicField(this, "refreshCallback", () => {
        this.refresh().catch(trackError);
      });
      __publicField(this, "unlockChanged", ({
        isUnlocked
      }) => {
        this.unlocked = isUnlocked;
        this.refresh().catch(trackError);
      });
      __publicField(this, "tabUrlChanged", (tabId, {
        url
      }) => {
        if (url) {
          this.refreshIfTabActive(tabId).catch(trackError);
        }
      });
      __publicField(this, "contextMenuClicked", (info, tab) => {
        if (!info.pageUrl || !(tab == null ? void 0 : tab.id) || typeof info.menuItemId !== "string") {
          return;
        }
        let action;
        try {
          action = ContextMenuAction.parse(jsonParseThaw(info.menuItemId));
        } catch {
          return;
        }
        this.performAction(info.pageUrl, tab == null ? void 0 : tab.id, action).catch(trackError);
      });
      this.clientCore = clientCore;
      this.loginsForUrl = loginsForUrl;
      this.siteSettingsHandler = siteSettingsHandler;
      this.unlocked = this.clientCore.isUnlocked();
      this.handleContentScriptMessage = makeMessageListener({
        ContentScriptModeChanged: (msg, sender) => this.handleContentScriptModeChanged(msg, sender)
      });
    }
    init() {
      if (!browser$1.contextMenus) {
        return;
      }
      eventProxy.addListener("contextMenus.onClicked", this.contextMenuClicked);
      eventProxy.addListener("tabs.onActivated", this.refreshCallback);
      eventProxy.addListener("tabs.onUpdated", this.tabUrlChanged);
      eventProxy.addListener("windows.onFocusChanged", this.refreshCallback);
      eventProxy.addListener("runtime.onMessage", this.handleContentScriptMessage);
      this.clientCore.on("unlockedChange", this.unlockChanged);
      this.clientCore.on("localVaultChange", this.refreshCallback);
      this.clientCore.on("vaultRepoChange", this.refreshCallback);
      this.refreshCallback();
    }
    close() {
      if (!browser$1.contextMenus) {
        return;
      }
      eventProxy.removeListener("contextMenus.onClicked", this.contextMenuClicked);
      eventProxy.removeListener("tabs.onActivated", this.refreshCallback);
      eventProxy.removeListener("tabs.onUpdated", this.tabUrlChanged);
      eventProxy.removeListener("windows.onFocusChanged", this.refreshCallback);
      eventProxy.removeListener("runtime.onMessage", this.handleContentScriptMessage);
      this.clientCore.off("unlockedChange", this.unlockChanged);
      this.clientCore.off("localVaultChange", this.refreshCallback);
      this.clientCore.off("vaultRepoChange", this.refreshCallback);
      browser$1.contextMenus.removeAll().catch(trackError);
    }
    async handleContentScriptModeChanged(msg, sender) {
      var _a2;
      if (!((_a2 = sender.tab) == null ? void 0 : _a2.id)) {
        return;
      }
      const activeTab = await getActiveTab();
      if ((activeTab == null ? void 0 : activeTab.id) !== sender.tab.id) {
        return;
      }
      await this.setupMenu(activeTab, msg.mode);
    }
    async refresh() {
      const activeTab = await getActiveTab();
      if (activeTab) {
        await this.setupMenu(activeTab);
      }
    }
    async refreshIfTabActive(tabId) {
      const activeTab = await getActiveTab();
      if (tabId === (activeTab == null ? void 0 : activeTab.id)) {
        await this.setupMenu(activeTab);
      }
    }
    async setupMenu(tab, contentScriptMode) {
      this.setupMenuCancelToken.cancel();
      await this.setupMenuMutex.runExclusive(async () => {
        this.setupMenuCancelToken = new CancelToken();
        try {
          await this.doSetupMenu(tab, this.setupMenuCancelToken, contentScriptMode);
        } catch (e) {
          if (e instanceof Cancel) {
            return;
          }
          throw e;
        }
      });
    }
    async doSetupMenu(tab, cancelToken, contentScriptModeInput) {
      await withCancel(cancelToken, browser$1.contextMenus.removeAll());
      if (!this.unlocked) {
        browser$1.contextMenus.create({
          type: "normal",
          contexts: ["editable"],
          enabled: false,
          title: i18n._(
            /*i18n*/
            {
              id: "D1KO61"
            }
          ),
          id: this.createId({
            type: "noop",
            random: Math.random()
          })
        });
        return;
      }
      if (!tab.active || !tab.url || !tab.id) {
        return;
      }
      const contentScriptMode = contentScriptModeInput ?? await withCancel(cancelToken, sendMessageToTab(tab.id, {
        type: "GetContentScriptMode"
      }));
      if (contentScriptMode === void 0 && isContentScriptBlockedByBrowser(tab.url)) {
        const browserName = getBrowserName();
        browser$1.contextMenus.create({
          type: "normal",
          contexts: ["editable"],
          enabled: false,
          title: i18n._(
            /*i18n*/
            {
              id: "aLmCR/",
              values: {
                browserName
              }
            }
          ),
          id: this.createId({
            type: "noop",
            random: Math.random()
          })
        });
        return;
      }
      if (contentScriptMode === void 0 || contentScriptMode === "heyloginWebapp") {
        return;
      }
      const {
        url
      } = tab;
      let firstEntry = true;
      const disabledSiteSettingResult = this.siteSettingsHandler.getDisabledSiteSettingForUrl(url);
      if (disabledSiteSettingResult.disabled) {
        browser$1.contextMenus.create({
          type: "normal",
          contexts: ["editable"],
          title: i18n._(
            /*i18n*/
            {
              id: "MAvRTx"
            }
          ),
          id: this.createId({
            type: "enableForPage"
          })
        });
        firstEntry = false;
      }
      const logins = this.getContextMenuLogins(url);
      if (!(logins == null ? void 0 : logins.length)) {
        return;
      }
      for (const l of logins) {
        if (!firstEntry) {
          browser$1.contextMenus.create({
            type: "separator",
            contexts: ["editable"],
            id: this.createId({
              type: "noop",
              random: Math.random()
            })
          });
        }
        firstEntry = false;
        this.createContextMenuEntriesForLogin(l);
      }
    }
    createContextMenuEntriesForLogin(l) {
      const documentUrlPatterns = l.websites.map(documentUrlPatternFromWebsite);
      if (l.title) {
        browser$1.contextMenus.create({
          type: "normal",
          enabled: false,
          title: l.title,
          contexts: ["editable"],
          documentUrlPatterns,
          id: this.createId({
            type: "noop",
            random: Math.random()
          })
        });
      }
      if (l.username) {
        this.addPlainField(i18n._(
          /*i18n*/
          {
            id: "7sNhEz"
          }
        ), l.username, documentUrlPatterns, this.createId({
          type: "fillUsername",
          loginId: l.id
        }));
      }
      if (l.password) {
        this.addProtectedField(i18n._(
          /*i18n*/
          {
            id: "8ZsakT"
          }
        ), documentUrlPatterns, this.createId({
          type: "fillPassword",
          loginId: l.id
        }));
      }
      if (l.totp) {
        this.addTotpField(documentUrlPatterns, this.createId({
          type: "fillTotp",
          loginId: l.id
        }));
      }
      for (const cf of l.customFields) {
        if (cf.name.trim() === "") {
          continue;
        }
        if (cf.protected) {
          this.addProtectedField(cf.name, documentUrlPatterns, this.createId({
            type: "fillCustomField",
            loginId: l.id,
            customFieldId: cf.id
          }));
        } else {
          this.addPlainField(cf.name, cf.value, documentUrlPatterns, this.createId({
            type: "fillCustomField",
            loginId: l.id,
            customFieldId: cf.id
          }));
        }
      }
    }
    addPlainField(name, value, documentUrlPatterns, id) {
      browser$1.contextMenus.create({
        type: "normal",
        contexts: ["editable"],
        title: `${name}: ${value}`,
        documentUrlPatterns,
        id
      });
    }
    addProtectedField(name, documentUrlPatterns, id) {
      browser$1.contextMenus.create({
        type: "normal",
        contexts: ["editable"],
        title: `${name}: ${PROTECTED_PLACEHOLDER}`,
        documentUrlPatterns,
        id
      });
    }
    addTotpField(documentUrlPatterns, id) {
      browser$1.contextMenus.create({
        type: "normal",
        contexts: ["editable"],
        title: i18n._(
          /*i18n*/
          {
            id: "Kvajkr"
          }
        ),
        documentUrlPatterns,
        id
      });
    }
    createId(action) {
      return jsonStringifyFreeze(action);
    }
    async performAction(url, tabId, action) {
      var _a2;
      if (action.type === "noop") {
        return;
      }
      if (action.type === "enableForPage") {
        await this.siteSettingsHandler.setDisabledSiteSettingForUrl(url, false);
        await this.clientCore.addAchievement(Achievement.EXT_CONTEXT_MENU_HEYLOGIN_ENABLED);
        return;
      }
      const logins = this.getContextMenuLogins(url);
      const login = logins == null ? void 0 : logins.find((l) => l.id === action.loginId);
      if (!login) {
        return;
      }
      const properties = this.getFillActionProperties(action, login);
      if (!properties) {
        return;
      }
      await sendMessageToTab(tabId, {
        type: "FillActive",
        value: properties.value
      });
      await this.clientCore.addAchievement(properties.achievement);
      if (properties.event && login.vaultMetadata && login.organization) {
        await this.clientCore.auditlogWriteEventsWithRetry(login.organization.id, {
          loginId: login.id,
          vaultId: login == null ? void 0 : login.vaultMetadata.id,
          loginRevisionId: (_a2 = login.history) == null ? void 0 : _a2.currentRevisionId,
          loginEditTime: login.editTime,
          ...properties.event
        });
      }
    }
    getFillActionProperties(action, login) {
      switch (action.type) {
        case "fillUsername":
          return {
            value: login.username,
            achievement: Achievement.EXT_CONTEXT_MENU_USERNAME_FILLED
          };
        case "fillPassword":
          const password = this.loginsForUrl.unprotect(login.vaultMetadata.id, login.password);
          if (!password) {
            return;
          }
          return {
            value: password,
            achievement: Achievement.EXT_CONTEXT_MENU_PASSWORD_FILLED,
            event: {
              type: AuditlogEventType.LOGIN_R_PASSWORD_INSERT_CONTEXT_MENU
            }
          };
        case "fillTotp":
          const totpSecret = login.totp ? this.loginsForUrl.unprotect(login.vaultMetadata.id, login.totp) : void 0;
          if (!totpSecret) {
            return;
          }
          const {
            totp
          } = calculateTotp(totpSecret.toUpperCase().trim(), getValueWithPlaceholder(login.totpAlgorithm) ?? DEFAULT_TOTP_ALGORITHM, login.totpDigits ?? DEFAULT_TOTP_DIGITS, login.totpPeriod ?? DEFAULT_TOTP_PERIOD);
          return {
            value: totp,
            achievement: Achievement.EXT_CONTEXT_MENU_CUSTOM_TOTP_FILLED
          };
        case "fillCustomField":
          const customField = login.customFields.find((cf) => cf.id === action.customFieldId);
          if (!customField) {
            return;
          }
          if (customField.protected) {
            const value = this.loginsForUrl.unprotect(login.vaultMetadata.id, customField.value);
            if (!value) {
              return;
            }
            return {
              value,
              achievement: Achievement.EXT_CONTEXT_MENU_CUSTOM_PROTECTED_FILLED,
              event: {
                type: AuditlogEventType.LOGIN_R_CUSTOM_FIELD_INSERT_CONTEXT_MENU,
                customFieldId: customField.id
              }
            };
          }
          return {
            value: customField.value,
            achievement: Achievement.EXT_CONTEXT_MENU_CUSTOM_PLAIN_FILLED
          };
        default:
          assertExhaustive();
      }
    }
    getContextMenuLogins(url) {
      var _a2;
      return (_a2 = this.loginsForUrl.getLogins(url)) == null ? void 0 : _a2.filter((l) => l.permissions.viewSecrets);
    }
  }
  async function withCancel(cancelToken, promise) {
    const cancelPromise = new Promise((_, reject) => {
      function handleCancel() {
        cancelToken.offCancel(handleCancel);
        reject(new Cancel());
      }
      cancelToken.onCancel(handleCancel);
    });
    return Promise.race([promise, cancelPromise]);
  }
  background;
  async function forceDisableBrowserPasswordSaving(disable) {
    if (!browser$1.privacy) {
      return;
    }
    const details = await browser$1.privacy.services.passwordSavingEnabled.get({});
    if (!details) {
      return;
    }
    if (details.levelOfControl === "controlled_by_this_extension" || details.levelOfControl === "controllable_by_this_extension") {
      if (disable) {
        await browser$1.privacy.services.passwordSavingEnabled.set({
          value: false
        });
        debugConsole.log(`Set passwordSavingEnabled to false`);
      } else {
        await browser$1.privacy.services.passwordSavingEnabled.clear({});
        debugConsole.log(`Cleared passwordSavingEnabled`);
      }
    } else {
      debugConsole.error("Not able to set passwordSavingEnabled");
    }
  }
  background;
  function shouldAskForLoginUsername(login) {
    return !login.username && !login.title && login.permissions.editLogin;
  }
  background;
  class GeneratedPasswordHandler {
    constructor(clientCore, autosnatchHandler, settings) {
      __publicField(this, "messageListener", makeMessageListener({
        ArchiveAddUsernameLogin: ({
          loginId
        }) => this.archiveAddUsernameLogin(loginId).catch(trackError)
      }));
      this.clientCore = clientCore;
      this.autosnatchHandler = autosnatchHandler;
      this.settings = settings;
    }
    init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
    async archiveAddUsernameLogin(loginId) {
      const targetVaultId = this.settings.getTargetVaultId();
      if (!targetVaultId) {
        return;
      }
      const vaultPair = this.clientCore.vaultRepo.getLoginVaultPairById(targetVaultId);
      if (!vaultPair) {
        return;
      }
      const vmd = getLoginVaultMetadata(this.clientCore, vaultPair);
      const foundLogin = vaultPair == null ? void 0 : vaultPair.login.getContent().logins[loginId];
      if (foundLogin && shouldAskForLoginUsername({
        ...foundLogin,
        permissions: getLoginPermissions(foundLogin, vmd.permissions)
      })) {
        await this.clientCore.deleteOrArchiveLogins({
          vaultId: vaultPair.login.id,
          loginId
        });
      }
    }
  }
  background;
  const DEFAULT_WIDTH = 500;
  const DEFAULT_HEIGHT = 145;
  const MIN_WIDTH = 200;
  const MIN_HEIGHT = DEFAULT_HEIGHT;
  const SEARCH_COMMAND = "search";
  class GlobalSearchHandler {
    constructor(clientCore) {
      __publicField(this, "searchWindowId");
      __publicField(this, "state");
      __publicField(this, "commandListener", (command) => {
        if (command === SEARCH_COMMAND) {
          this.openOrFocus().catch(trackError);
        }
      });
      __publicField(this, "messageListener", makeMessageListener({
        SaveGlobalSearchState: (m2) => {
          this.state = m2.state;
        },
        SetGlobalSearchHeight: async ({
          height
        }) => {
          if (this.searchWindowId) {
            await browser$1.windows.update(this.searchWindowId, {
              height
            });
          }
        },
        GlobalSearchOpenUrl: async ({
          url
        }) => {
          const tab = await browser$1.tabs.create({
            url,
            active: true
          });
          if (tab.windowId) {
            await browser$1.windows.update(tab.windowId, {
              focused: true
            });
          }
        },
        GetGlobalSearchShortcut: async () => {
          var _a2;
          try {
            const commands = await browser$1.commands.getAll();
            const globalSearchCommand = commands.find((cmd) => cmd.name === SEARCH_COMMAND);
            return {
              type: "GetGlobalSearchShortcutResponse",
              // Chrome can return empty string to indicate no shortcut set, force to undefined
              globalSearchShortcut: ((_a2 = globalSearchCommand == null ? void 0 : globalSearchCommand.shortcut) == null ? void 0 : _a2.trim()) || void 0
            };
          } catch (e) {
            return {
              type: "GetGlobalSearchShortcutResponse",
              globalSearchShortcut: void 0
            };
          }
        },
        OpenGlobalSearchWindow: async () => {
          await this.openOrFocus();
        },
        OpenShortcutSettings: async () => {
          browser$1.tabs.create({
            url: "chrome://extensions/shortcuts"
          }).catch(trackError);
        }
      }));
      this.clientCore = clientCore;
    }
    init() {
      if (!browser$1.commands) {
        return;
      }
      eventProxy.addListener("runtime.onMessage", this.messageListener);
      eventProxy.addListener("commands.onCommand", this.commandListener);
    }
    close() {
      if (!browser$1.commands) {
        return;
      }
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
      eventProxy.removeListener("commands.onCommand", this.commandListener);
    }
    async openOrFocus() {
      if (this.searchWindowId !== void 0) {
        try {
          const window2 = await browser$1.windows.get(this.searchWindowId);
          if (window2 && window2.id) {
            await browser$1.windows.update(window2.id, {
              focused: true
            });
            return;
          }
        } catch (e) {
        }
      }
      const screenSize = await getScreenSize();
      const state = this.getOpenState(screenSize);
      try {
        await this.openWithState(state);
      } catch (e) {
        if (isWebExtError(e, "INVALID_VALUE_FOR_BOUNDS")) {
          await this.openWithState({
            ...state,
            ...this.getDefaultBounds(screenSize)
          });
          return;
        }
        throw e;
      }
    }
    async openWithState(state) {
      const url = browser$1.runtime.getURL("globalSearch.html");
      const params = new URLSearchParams({
        searchString: state.searchString
      });
      if (state.highlightedIndex !== void 0) {
        params.set("highlightedIndex", `${state.highlightedIndex}`);
      }
      if (state.highlightedItemExpanded) {
        params.set("highlightedItemExpanded", "");
      }
      if (this.clientCore.isUnlocked()) {
        params.set("initiallyUnlocked", "");
      }
      const popupWindow = await browser$1.windows.create({
        type: "popup",
        url: `${url}?${params.toString()}`,
        width: state.width,
        height: state.height,
        top: state.top,
        left: state.left
      });
      this.searchWindowId = popupWindow.id;
    }
    getOpenState(screenSize) {
      if (this.state && Date.now() - this.state.lastUpdateTimestampMs < 6e4) {
        const width = Math.max(MIN_WIDTH, screenSize ? Math.min(this.state.width, screenSize.availWidth) : this.state.width);
        const height = Math.max(MIN_HEIGHT, screenSize ? Math.min(this.state.height, screenSize.availHeight) : this.state.height);
        const top = Math.max(0, screenSize ? Math.min(this.state.top, screenSize.height - height) : this.state.top);
        const left = Math.max(0, screenSize ? Math.min(this.state.left, screenSize.width - width) : this.state.left);
        return {
          ...this.state,
          width,
          height,
          top,
          left
        };
      }
      return this.getDefaultState(screenSize);
    }
    getDefaultState(screenSize) {
      return {
        searchString: "",
        highlightedIndex: void 0,
        highlightedItemExpanded: false,
        ...this.getDefaultBounds(screenSize)
      };
    }
    getDefaultBounds(screenSize) {
      return {
        width: DEFAULT_WIDTH,
        height: DEFAULT_HEIGHT,
        top: screenSize ? Math.round(screenSize.availHeight / 3 - DEFAULT_HEIGHT / 2) : 100,
        left: screenSize ? Math.round((screenSize.availWidth - DEFAULT_WIDTH) / 2) : 300
      };
    }
  }
  async function getScreenSize() {
    if (globalThis.screen) {
      return globalThis.screen;
    }
    if (!isOffscreenDocumentSupported()) {
      return void 0;
    }
    try {
      await setupOffscreenDocument(chrome.offscreen.Reason.DOM_SCRAPING, "Need access to window.screen to position a popup window.");
      const screenSize = await sendMessage({
        type: "GetScreenSize"
      });
      return screenSize === messageError ? void 0 : screenSize;
    } catch (e) {
      return void 0;
    }
  }
  background;
  class HeyproblemsMessageHandler {
    constructor(clientCore) {
      __publicField(this, "messageListener", makeMessageListener({
        SendHeyproblemsReport: ({
          info
        }) => this.sendReport(info)
      }));
      this.clientCore = clientCore;
    }
    init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
    async sendReport(info) {
      const [activeTab] = await browser$1.tabs.query({
        active: true,
        currentWindow: true
      });
      this.clientCore.addAchievement(Achievement.EXT_REPORT_PAGE).catch(trackError);
      this.clientCore.backendClient.support.reportPage(activeTab.url ?? null, info.problem, info.comment, info.screenshot ?? null, info.hasLogin, info.hasHideSecretsLogin).catch(trackError);
      return true;
    }
  }
  background;
  class LoginsForUrl {
    constructor(clientCore) {
      __publicField(this, "loginsCache", /* @__PURE__ */ new Map());
      __publicField(this, "isMobileSafari");
      __publicField(this, "isMobileBrowser");
      __publicField(this, "handleClientCoreEvents", () => {
        this.loginsCache.clear();
      });
      this.clientCore = clientCore;
      const browser2 = Bowser.parse(navigator.userAgent);
      this.isMobileSafari = isMobileSafari(browser2);
      this.isMobileBrowser = isMobileBrowser(browser2);
    }
    init() {
      this.clientCore.on("vaultRepoChange", this.handleClientCoreEvents);
      this.clientCore.on("unlockedChange", this.handleClientCoreEvents);
      this.clientCore.on("accountStateChange", this.handleClientCoreEvents);
    }
    close() {
      this.clientCore.off("vaultRepoChange", this.handleClientCoreEvents);
      this.clientCore.off("unlockedChange", this.handleClientCoreEvents);
      this.clientCore.off("accountStateChange", this.handleClientCoreEvents);
    }
    getLogins(urlStr) {
      if (!this.loginsCache.has(urlStr)) {
        const vaults = this.getVaults();
        const logins = this.doGetLoginsForUrl(vaults, urlStr);
        this.loginsCache.set(urlStr, logins);
      }
      return this.loginsCache.get(urlStr);
    }
    doGetLoginsForUrl(vaults, urlStr) {
      return this.doGetLogins(vaults, (loginVault) => {
        return R(urlStr, loginVault.getContent().logins);
      });
    }
    getAllLogins() {
      return this.doGetLogins(this.getVaults(), (loginVault) => {
        return Object.entries(loginVault.getContent().logins).map(([id, login]) => ({
          ...login,
          id,
          urlSimilarity: 0
        }));
      });
    }
    unprotect(vaultId, protectedValue) {
      var _a2;
      return (_a2 = this.unprotectWithContentId(vaultId, protectedValue)) == null ? void 0 : _a2.unencrypted;
    }
    unprotectWithContentId(vaultId, protectedValue) {
      var _a2;
      const vault = this.clientCore.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        return void 0;
      }
      try {
        return (_a2 = this.clientCore.protectedSecretRepo) == null ? void 0 : _a2.unprotectWithContentId(vault, protectedValue);
      } catch (e) {
        if (e instanceof CannotUnprotectError) {
          return void 0;
        }
        throw e;
      }
    }
    getVaults() {
      const allVaults = this.clientCore.vaultRepo.getLoginVaultPairs();
      if (!this.isMobileBrowser) {
        return allVaults;
      }
      return allVaults.filter((pair) => showLoginVaultOnMobile(pair, this.clientCore.accountState));
    }
    doGetLogins(vaults, getVaultLogins) {
      const showTotpTimeOffsetWarningForTotpLogins = shouldShowTotpTimeOffsetWarning(this.clientCore.clientServerTimeOffsetMs);
      const knownLoginVaultIds = new Set(vaults.map(({
        login
      }) => login.id));
      let allLogins = vaults.reduce((acc, vaultPair) => {
        const {
          login: loginVault
        } = vaultPair;
        const logins = getVaultLogins(loginVault);
        const vaultMetadata = getLoginVaultMetadata(this.clientCore, vaultPair);
        if (!vaultMetadata.permissions.useLogins) {
          return acc;
        }
        const vaultUrl = `${getFrontendServerUrl()}${vaultMetadata.path}`;
        const vaultLogins = logins.flatMap(({
          id,
          urlSimilarity,
          ...login
        }) => {
          if (login.linkedFrom && knownLoginVaultIds.has(login.linkedFrom.originVaultId)) {
            return [];
          }
          const transformedLogin = transformLoginTotpForAutofill(login);
          const permissions = getLoginPermissions(login, vaultMetadata.permissions);
          if (!permissions.useLogin) {
            return [];
          }
          return {
            ...transformedLogin,
            id,
            vaultMetadata,
            urlSimilarity,
            loginUrl: this.isMobileSafari ? `heylogin://editLogin?loginId=${id}&vaultId=${loginVault.id}` : `${vaultUrl}/${id}`,
            vaultUrl,
            organization: getOrganizationInfo(loginVault, this.clientCore.accountState),
            showTotpTimeOffsetWarning: login.totp !== void 0 && showTotpTimeOffsetWarningForTotpLogins,
            permissions
          };
        });
        return [...acc, ...vaultLogins];
      }, []);
      allLogins.sort(loginComparator);
      allLogins = allLogins.filter(({
        id
      }, pos, all) => !pos || id !== all[pos - 1].id);
      return allLogins;
    }
  }
  function isVaultNewlyJoined(vmd) {
    return !!vmd && vmd.type === VaultType.TEAM && !!vmd.newlyJoinedInfo;
  }
  function loginComparator(l, r2) {
    const similarityDiff = r2.urlSimilarity - l.urlSimilarity;
    if (similarityDiff) {
      return similarityDiff;
    }
    if (l) {
      if (isVaultNewlyJoined(l.vaultMetadata) !== isVaultNewlyJoined(r2.vaultMetadata)) {
        return isVaultNewlyJoined(l.vaultMetadata) ? -1 : 1;
      }
    }
    if (l.vaultMetadata && r2.vaultMetadata && l.vaultMetadata.id !== r2.vaultMetadata.id) {
      return compareLoginVaultMetadata(l.vaultMetadata, r2.vaultMetadata);
    }
    return compareLoginsByChangeTime(l, r2);
  }
  function getOrganizationInfo(loginVault, accountState) {
    var _a2;
    if (!loginVault.organizationId) {
      return void 0;
    }
    const org = accountState.organizations.find(({
      id
    }) => id === loginVault.organizationId);
    if (!org) {
      return void 0;
    }
    let subscriptionError = org.subscriptionError ?? void 0;
    if (!subscriptionError) {
      subscriptionError = (_a2 = accountState.serverSideSettings.injectSubscriptionError) == null ? void 0 : _a2[org.id];
    }
    return {
      id: org.id,
      name: org.name,
      isAdmin: org.isAdmin,
      subscriptionError
    };
  }
  background;
  class OmniboxHandler {
    constructor(clientCore) {
      __publicField(this, "inputChanged", (content, suggest) => {
        this.clientCore.addAchievement(Achievement.EXT_OMNIBOX_INPUT_CHANGED).catch(trackError);
        const allLogins = this.clientCore.vaultRepo.getLoginVaultPairs().flatMap(({
          login
        }) => Object.entries(login.getContent().logins));
        const filtered = allLogins.filter(([id, l]) => (searchPredicate(l, content) || id.includes(content)) && getDescription(l) !== "");
        const suggestions = filtered.map(([id, l]) => ({
          content: id,
          description: getDescription(l)
        }));
        suggest(suggestions);
      });
      __publicField(this, "inputEntered", (content, disposition) => {
        this.clientCore.addAchievement(Achievement.EXT_OMNIBOX_INPUT_ENTERED).catch(trackError);
        const url = `${getFrontendServerUrl()}${this.getPathFromContent(content)}`;
        if (disposition === "currentTab") {
          browser$1.tabs.update({
            url
          }).catch(trackError);
        } else if (disposition === "newForegroundTab") {
          browser$1.tabs.create({
            url
          }).catch(trackError);
        } else {
          browser$1.tabs.create({
            url,
            active: false
          }).catch(trackError);
        }
      });
      this.clientCore = clientCore;
    }
    init() {
      if (!browser$1.omnibox) {
        return;
      }
      eventProxy.addListener("omnibox.onInputChanged", this.inputChanged);
      eventProxy.addListener("omnibox.onInputEntered", this.inputEntered);
      browser$1.omnibox.setDefaultSuggestion({
        description: i18n._(
          /*i18n*/
          {
            id: "v8vJR1"
          }
        )
      });
    }
    close() {
      if (!browser$1.omnibox) {
        return;
      }
      eventProxy.removeListener("omnibox.onInputChanged", this.inputChanged);
      eventProxy.removeListener("omnibox.onInputEntered", this.inputEntered);
    }
    getPathFromContent(content) {
      if (isUuid(content)) {
        const vaultPair = this.clientCore.vaultRepo.getLoginVaultPairs().find((p2) => Object.keys(p2.login.getContent().logins).includes(content));
        if (vaultPair) {
          const metadata = getLoginVaultMetadata(this.clientCore, vaultPair);
          return `${metadata.path}/${content}`;
        }
      }
      return `/search?filter=${content}`;
    }
  }
  function getDescription(login) {
    const {
      headline,
      subheadline
    } = L(login);
    if (subheadline) {
      return `${headline} - ${subheadline}`;
    }
    return headline;
  }
  function isUuid(s2) {
    return /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(s2);
  }
  background;
  const OVERRIDE_UPDATE_INTERVAL_MS = 24 * 60 * 60 * 1e3;
  class OverrideHandler {
    constructor(backendClient) {
      __publicField(this, "library");
      // Backend provided during request, last time that any override was changed
      __publicField(this, "overridesUpdateTime");
      __publicField(this, "overrideUpdateTimeoutId");
      __publicField(this, "messageListener", makeMessageListener({
        GetOverrideLibrary: () => this.library ?? this.getBundledOverrideLibrary(),
        ReplaceOverrides: ({
          overrides
        }) => this.handleReplaceOverrides(overrides),
        DeleteOverrides: ({
          overrideIds
        }) => this.handleDeleteOverrides(overrideIds),
        ForceOverrideUpdate: () => this.updateOverrideLibrary()
      }));
      this.backendClient = backendClient;
    }
    async init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
      await this.loadFromStorage();
      this.updateOverrideLibraryWithRetry().catch(trackError);
      this.scheduleOverrideUpdate();
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
    async loadFromStorage() {
      const storageValues = await browser$1.storage.local.get(["overrideLibrary", "overridesUpdateTime"]);
      if (storageValues.overrideLibrary) {
        const libraryParseResult = OverrideLibrary.safeParse(storageValues.overrideLibrary);
        if (libraryParseResult.success) {
          this.library = libraryParseResult.data;
        }
      }
      try {
        const overridesUpdateTime = jsonParseThaw(storageValues.overridesUpdateTime);
        if (overridesUpdateTime instanceof Date) {
          this.overridesUpdateTime = overridesUpdateTime;
        }
      } catch (e) {
      }
    }
    async persistToStorage() {
      await browser$1.storage.local.set({
        overrideLibrary: this.library,
        overridesUpdateTime: this.overridesUpdateTime ? jsonStringifyFreeze(this.overridesUpdateTime) : void 0
      });
    }
    scheduleOverrideUpdate() {
      debugConsole.log("[OverrideHandler]", `Scheduling override update at ${new Date(Date.now() + OVERRIDE_UPDATE_INTERVAL_MS).toISOString()}`);
      globalThis.clearTimeout(this.overrideUpdateTimeoutId);
      this.overrideUpdateTimeoutId = globalThis.setTimeout(() => {
        this.updateOverrideLibraryWithRetry().catch(trackError);
        this.scheduleOverrideUpdate();
      }, OVERRIDE_UPDATE_INTERVAL_MS);
    }
    async getBundledOverrideLibrary() {
      const url = browser$1.runtime.getURL("overrides.json");
      const response = await fetch(url);
      const libraryJson = await response.json();
      return OverrideLibrary.parse(libraryJson);
    }
    async handleReplaceOverrides(overrides) {
      const adminClient = await this.getLFDOverridesAdminClient();
      await adminClient.replace(...overrides.map((o) => JSON.stringify(o)));
      await this.updateOverrideLibrary();
    }
    async handleDeleteOverrides(overrideIds) {
      const adminClient = await this.getLFDOverridesAdminClient();
      await adminClient.delete(...overrideIds);
      await this.updateOverrideLibrary();
    }
    async updateOverrideLibraryWithRetry() {
      let retries = 0;
      while (retries < 10) {
        try {
          await this.updateOverrideLibrary();
        } catch (e) {
          if (e instanceof DomainError$1 && e.code === BackendClientErrorCode.NoResponse) {
            debugConsole.log("[OverrideHandler]", "failed to update overrides due to NoResponse, retrying in 10 minutes");
          } else {
            throw e;
          }
        }
        await sleep(10 * 60 * 1e3);
        retries++;
      }
      debugConsole.log("[OverrideHandler]", "failed to update overrides after retries, giving up");
    }
    async updateOverrideLibrary() {
      debugConsole.log("[OverrideHandler]", "Updating override library");
      const response = await this.backendClient.lfdOverrides.list(this.overridesUpdateTime);
      if (this.overridesUpdateTime && response.overridesUpdateTime.getTime() === this.overridesUpdateTime.getTime()) {
        return;
      }
      const newLibrary = response.overridesJson.flatMap((jsonStr) => {
        try {
          const json = JSON.parse(jsonStr);
          return WebpageOverride.parse(json);
        } catch (e) {
          trackError(e);
          return [];
        }
      });
      this.library = newLibrary;
      this.overridesUpdateTime = response.overridesUpdateTime;
      await sendMessageToAllTabs({
        type: "OverridesUpdate"
      });
      await this.persistToStorage();
    }
    async getLFDOverridesAdminClient() {
      const token = await this.backendClient.credential.createLFDOverridesAdminToken();
      const adminClient = this.backendClient.getLFDOverridesAdminClient(token);
      return adminClient;
    }
  }
  background;
  class SiteSettingsHandler {
    constructor(clientCore) {
      __publicField(this, "messageListener", makeMessageListener({
        GetDisabledSiteSettingForUrl: ({
          url
        }) => this.getDisabledSiteSettingForUrl(url),
        SetDisabledSiteSettingForUrl: ({
          url,
          disabled
        }) => this.setDisabledSiteSettingForUrl(url, disabled)
      }));
      this.clientCore = clientCore;
    }
    init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
      this.migrateFlaggedPagesToSiteSettingsIfNecessary().catch(trackError);
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
    getDisabledSiteSettingForUrl(url) {
      let host;
      try {
        host = getHost$1(url);
      } catch (e) {
        return {
          disabled: void 0,
          host: void 0
        };
      }
      const applicableSiteSetting = this.getApplicableSiteSetting(host, ["extensionDisabled"]);
      if (applicableSiteSetting) {
        return {
          disabled: !!applicableSiteSetting.extensionDisabled,
          host: applicableSiteSetting.host
        };
      }
      return {
        disabled: false,
        host
      };
    }
    async setDisabledSiteSettingForUrl(url, disabled) {
      let host;
      try {
        host = getHost$1(url);
      } catch (e) {
        return;
      }
      await this.clientCore.modifyMetaVault((c2, t, {
        addOrModifySiteSettings: addOrModifySiteSettings2
      }) => {
        const applicableSiteSetting = this.getApplicableSiteSetting(host, ["extensionDisabled"]);
        const applySettingHost = (applicableSiteSetting == null ? void 0 : applicableSiteSetting.host) ?? host;
        const shadowedHosts = this.getShadowedHosts(applySettingHost);
        let newVaultContent = c2;
        for (const shadowedHost of shadowedHosts) {
          ({
            newVaultContent
          } = addOrModifySiteSettings2(newVaultContent, t, shadowedHost, {
            extensionDisabled: void 0
          }));
        }
        const newSiteSettings = {
          extensionDisabled: disabled
        };
        debugConsole.log("[SiteSettingsHandler]", newSiteSettings, disabled);
        ({
          newVaultContent
        } = addOrModifySiteSettings2(newVaultContent, t, applySettingHost, newSiteSettings));
        return {
          newVaultContent,
          result: void 0
        };
      });
    }
    /**
     * Get's the least specific site setting that has a truthy value for  at least one of the
     * specified setting keys.
     *
     * For example, if there are site settings for foo.bar.example.org, bar.example.org and
     * example.org which all have the key, passing in "foo.bar.example.org" will return the settings
     * for example.org. The more specific settings are shadowed by the general config.
     */
    getApplicableSiteSetting(host, settingKeys) {
      var _a2;
      const allSiteSettings = ((_a2 = this.clientCore.getMetaContent()) == null ? void 0 : _a2.siteSettings) ?? {};
      const allSiteSettingsHosts = Object.keys(allSiteSettings);
      const matchingHosts = getMatchingHosts(host, allSiteSettingsHosts);
      const matchingSiteSettings = matchingHosts.map((h2) => ({
        ...allSiteSettings[h2],
        host: h2
      }));
      const applicableSiteSetting = matchingSiteSettings.find((s2) => settingKeys.some((sk) => !!s2[sk]));
      return applicableSiteSetting;
    }
    getShadowedHosts(host) {
      var _a2;
      const allSiteSettings = ((_a2 = this.clientCore.getMetaContent()) == null ? void 0 : _a2.siteSettings) ?? {};
      const allSiteSettingsHosts = Object.keys(allSiteSettings);
      return getShadowedHosts(host, allSiteSettingsHosts);
    }
    async migrateFlaggedPagesToSiteSettingsIfNecessary() {
      const {
        disabledPages: disablePagesFieldValue,
        autosnatchDisabledPages: autosnatchDisabledPagesFieldValue
      } = await browser$1.storage.local.get(["autosnatchDisabledPages", "disabledPages"]);
      const disabledPages = this.parseFlaggedPages(disablePagesFieldValue);
      const autosnatchDisabledPages = this.parseFlaggedPages(autosnatchDisabledPagesFieldValue);
      if (!(autosnatchDisabledPages == null ? void 0 : autosnatchDisabledPages.size) && !(disabledPages == null ? void 0 : disabledPages.size)) {
        return;
      }
      await this.clientCore.modifyMetaVault((c2, t, {
        addOrModifySiteSettings: addOrModifySiteSettings2
      }) => {
        var _a2;
        let newVaultContent = c2;
        for (const host of /* @__PURE__ */ new Set([...disabledPages, ...autosnatchDisabledPages])) {
          if (!((_a2 = newVaultContent.siteSettings) == null ? void 0 : _a2[host])) {
            ({
              newVaultContent
            } = addOrModifySiteSettings2(newVaultContent, t, host, {
              extensionDisabled: disabledPages.has(host)
            }));
          }
        }
        return {
          newVaultContent,
          result: void 0
        };
      });
      await browser$1.storage.local.remove(["autosnatchDisabledPages", "disabledPages"]);
    }
    parseFlaggedPages(fieldValue) {
      let flaggedPages;
      try {
        flaggedPages = jsonParseThaw(fieldValue);
      } catch {
        return /* @__PURE__ */ new Set();
      }
      if (!Array.isArray(flaggedPages)) {
        return /* @__PURE__ */ new Set();
      }
      return new Set(flaggedPages);
    }
  }
  function getMatchingHosts(host, siteSettingsHosts) {
    const matchingHosts = siteSettingsHosts.filter((disabledHost) => hostMatches(host, disabledHost));
    matchingHosts.sort((p1, p2) => p1.length - p2.length);
    return matchingHosts;
  }
  function getShadowedHosts(host, siteSettingsHosts) {
    return siteSettingsHosts.filter((settingHost) => hostMatches(settingHost, host));
  }
  function hostMatches(pageHost, settingHost) {
    const [pageHostname, pagePort] = getHostnameAndPort(pageHost);
    const [settingHostname, settingPort] = getHostnameAndPort(settingHost);
    return (
      // Add a leading period to prevent a pattern like "login.app" to match host "heylogin.app"
      `.${pageHostname}`.endsWith(`.${settingHostname}`) && (settingPort === void 0 || settingPort === pagePort)
    );
  }
  function getHostnameAndPort(host) {
    return host.split(":");
  }
  background;
  class ClientCoreUsers {
    constructor(clientCoreLoader) {
      __publicField(this, "loginsForUrl");
      __publicField(this, "autosnatchHandler");
      __publicField(this, "autosnatchSettingsHandler");
      __publicField(this, "generatedPasswordHandler");
      __publicField(this, "clientCoreMessageHandler");
      __publicField(this, "badgeUpdater");
      __publicField(this, "fallbackClientCoreMessageHandler");
      __publicField(this, "omniboxHandler");
      __publicField(this, "siteSettingsHandler");
      __publicField(this, "heyproblemsMessageHandler");
      __publicField(this, "basicAuthHandler");
      __publicField(this, "contextMenuHandler");
      __publicField(this, "overrideHandler");
      __publicField(this, "globalSearchHandler");
      __publicField(this, "updateMutex", new Mutex());
      this.clientCoreLoader = clientCoreLoader;
    }
    async init() {
      this.clientCoreLoader.on("clientCoreChange", ({
        newClientCoreSync
      }) => {
        this.updateClientCore(newClientCoreSync).catch(trackError);
      });
      await this.updateClientCore(this.clientCoreLoader.clientCoreSync);
    }
    async updateClientCore(newClientCoreSync) {
      await this.updateMutex.runExclusive(async () => {
        await this.closeAll();
        if (newClientCoreSync) {
          await this.createAll(newClientCoreSync);
        }
      });
    }
    async closeAll() {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n;
      try {
        (_a2 = this.loginsForUrl) == null ? void 0 : _a2.close();
        this.loginsForUrl = void 0;
        (_b2 = this.autosnatchHandler) == null ? void 0 : _b2.close();
        this.autosnatchHandler = void 0;
        (_c2 = this.autosnatchSettingsHandler) == null ? void 0 : _c2.close();
        this.autosnatchSettingsHandler = void 0;
        (_d2 = this.generatedPasswordHandler) == null ? void 0 : _d2.close();
        this.generatedPasswordHandler = void 0;
        (_e2 = this.clientCoreMessageHandler) == null ? void 0 : _e2.close();
        this.clientCoreMessageHandler = void 0;
        (_f2 = this.badgeUpdater) == null ? void 0 : _f2.close();
        this.badgeUpdater = void 0;
        (_g2 = this.omniboxHandler) == null ? void 0 : _g2.close();
        this.omniboxHandler = void 0;
        (_h2 = this.siteSettingsHandler) == null ? void 0 : _h2.close();
        this.siteSettingsHandler = void 0;
        (_i2 = this.heyproblemsMessageHandler) == null ? void 0 : _i2.close();
        this.heyproblemsMessageHandler = void 0;
        (_j2 = this.basicAuthHandler) == null ? void 0 : _j2.close();
        this.basicAuthHandler = void 0;
        (_k2 = this.contextMenuHandler) == null ? void 0 : _k2.close();
        this.contextMenuHandler = void 0;
        (_l2 = this.overrideHandler) == null ? void 0 : _l2.close();
        this.overrideHandler = void 0;
        (_m2 = this.globalSearchHandler) == null ? void 0 : _m2.close();
        this.globalSearchHandler = void 0;
        (_n = this.fallbackClientCoreMessageHandler) == null ? void 0 : _n.close();
        this.fallbackClientCoreMessageHandler = new FallbackClientCoreMessageHandler();
        this.fallbackClientCoreMessageHandler.init();
        await forceDisableBrowserPasswordSaving(false);
      } catch (e) {
        setExtra("originalError", e);
        trackError(new Error("Failed ClientCoreUsers.closeAll due to unexpected exception", {
          cause: e
        }));
      }
    }
    async createAll(clientCoreSync) {
      var _a2;
      try {
        const clientCore = clientCoreSync.clientCore;
        (_a2 = this.fallbackClientCoreMessageHandler) == null ? void 0 : _a2.close();
        this.fallbackClientCoreMessageHandler = void 0;
        this.loginsForUrl = new LoginsForUrl(clientCore);
        this.loginsForUrl.init();
        this.autosnatchSettingsHandler = new AutosnatchSettingsHandler(clientCore);
        this.autosnatchSettingsHandler.init();
        this.autosnatchHandler = new AutosnatchHandler(clientCore, this.autosnatchSettingsHandler);
        await this.autosnatchHandler.init();
        this.generatedPasswordHandler = new GeneratedPasswordHandler(clientCore, this.autosnatchHandler, this.autosnatchSettingsHandler);
        this.generatedPasswordHandler.init();
        this.clientCoreMessageHandler = new ClientCoreMessageHandler(clientCore, clientCoreSync, this.loginsForUrl, this.autosnatchHandler.getAutosnatchCache());
        this.clientCoreMessageHandler.init();
        this.siteSettingsHandler = new SiteSettingsHandler(clientCore);
        this.siteSettingsHandler.init();
        this.badgeUpdater = new BadgeUpdater(clientCore, this.loginsForUrl, this.autosnatchHandler.getAutosnatchCache(), this.siteSettingsHandler);
        this.badgeUpdater.init();
        this.omniboxHandler = new OmniboxHandler(clientCore);
        this.omniboxHandler.init();
        this.contextMenuHandler = new ContextMenuHandler(clientCore, this.loginsForUrl, this.siteSettingsHandler);
        this.contextMenuHandler.init();
        this.heyproblemsMessageHandler = new HeyproblemsMessageHandler(clientCore);
        this.heyproblemsMessageHandler.init();
        this.basicAuthHandler = new BasicAuthHandler(this.loginsForUrl);
        this.basicAuthHandler.init();
        this.overrideHandler = new OverrideHandler(clientCore.backendClient);
        await this.overrideHandler.init();
        this.globalSearchHandler = new GlobalSearchHandler(clientCore);
        this.globalSearchHandler.init();
        await forceDisableBrowserPasswordSaving(true);
      } catch (e) {
        setExtra("originalError", e);
        trackError(new Error("Failed ClientCoreUsers.createAll due to unexpected exception", {
          cause: e
        }));
        await this.closeAll();
      }
    }
  }
  background;
  async function isInstalledByPolicy() {
    var _a2;
    if ((_a2 = browser$1.management) == null ? void 0 : _a2.getSelf) {
      const selfInfo = await browser$1.management.getSelf();
      return selfInfo.installType === "admin";
    }
    return false;
  }
  background;
  async function setupConflictingHeyloginExtensionHandling() {
    eventProxy.addListener("runtime.onMessageExternal", (msg) => {
      if (typeof msg === "object" && msg !== null && "type" in msg && msg.type === "uninstallSelf") {
        handleUninstallSelf().catch(trackError);
      }
    });
    await tellConflictingExtensionsToUninstall();
  }
  async function handleUninstallSelf() {
    const installedByPolicy = await isInstalledByPolicy();
    if (installedByPolicy) {
      await tellConflictingExtensionsToUninstall();
    } else {
      await browser$1.management.uninstallSelf();
    }
  }
  async function tellConflictingExtensionsToUninstall() {
    var _a2, _b2;
    const manifestParseResult = ManifestExternallyConnectable.safeParse(browser$1.runtime.getManifest());
    if (!manifestParseResult.success || !((_b2 = (_a2 = manifestParseResult.data.externally_connectable) == null ? void 0 : _a2.ids) == null ? void 0 : _b2.length)) {
      debugConsole.log("[otherHeyloginExtensionHandling]", "skipping installed message due to error or no other extensions found in manifest");
      return;
    }
    const otherExtensionIds = manifestParseResult.data.externally_connectable.ids;
    for (const id of otherExtensionIds) {
      try {
        await browser$1.runtime.sendMessage(id, {
          type: "uninstallSelf"
        });
      } catch (e) {
        if (!isWebExtError(e, "COULD_NOT_ESTABLISH_CONNECTION")) {
          trackError(e);
        }
      }
    }
  }
  const ManifestExternallyConnectable = z.object({
    externally_connectable: z.object({
      ids: z.array(z.string()).optional()
    }).optional()
  });
  background;
  class ConnectionForwarder {
    constructor() {
      __publicField(this, "contentPorts", /* @__PURE__ */ new Map());
      __publicField(this, "iframePorts", /* @__PURE__ */ new Map());
      __publicField(this, "contentToIframeMessageBuffers", /* @__PURE__ */ new Map());
      __publicField(this, "iframeToContentMessageBuffers", /* @__PURE__ */ new Map());
    }
    init() {
      eventProxy.addListener("runtime.onConnect", makeConnectionListener({
        ForwardContent: (p2, connectionId) => this.addContentPort(p2, connectionId),
        ForwardIframe: (p2, connectionId) => this.addIframePort(p2, connectionId)
      }));
    }
    addContentPort(port, connectionId) {
      ConnectionForwarder.addPort(this.contentPorts, this.iframePorts, this.contentToIframeMessageBuffers, this.iframeToContentMessageBuffers, port, connectionId);
    }
    addIframePort(port, connectionId) {
      ConnectionForwarder.addPort(this.iframePorts, this.contentPorts, this.iframeToContentMessageBuffers, this.contentToIframeMessageBuffers, port, connectionId);
    }
    static addPort(sourcePorts, targetPorts, sourceMessageBuffers, targetMessageBuffers, port, connectionId) {
      if (!connectionId) {
        trackError(new Error(`Failed to add port ${port.name}, no connectionId set!`));
        return;
      }
      const onMessage = (msg) => {
        const targetPort = targetPorts.get(connectionId);
        if (!targetPort) {
          let bufferedSourceMessages = sourceMessageBuffers.get(connectionId);
          if (!bufferedSourceMessages) {
            bufferedSourceMessages = [];
            sourceMessageBuffers.set(connectionId, bufferedSourceMessages);
          }
          bufferedSourceMessages.push(msg);
          return;
        }
        targetPort.postMessage(msg);
      };
      const onDisconnect = () => {
        port.onMessage.removeListener(onMessage);
        port.onDisconnect.removeListener(onDisconnect);
        if (connectionId) {
          sourcePorts.delete(connectionId);
        }
      };
      const previousPort = sourcePorts.get(connectionId);
      if (previousPort) {
        trackError(new Error(`Error when adding port ${port.name}. Already had a port for the given connection id ${connectionId}. Name: ${previousPort.name}`));
        previousPort == null ? void 0 : previousPort.disconnect();
      }
      sourcePorts.set(connectionId, port);
      port.onMessage.addListener(onMessage);
      port.onDisconnect.addListener(onDisconnect);
      const bufferedTargetMessages = targetMessageBuffers.get(connectionId);
      if (bufferedTargetMessages) {
        for (const targetMessage of bufferedTargetMessages) {
          port.postMessage(targetMessage);
        }
        targetMessageBuffers.delete(connectionId);
      }
    }
  }
  background;
  function requiredArgs(required, args) {
    if (args.length < required) {
      throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }
  function toDate(argument) {
    requiredArgs(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
        console.warn(new Error().stack);
      }
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var dateLeft = toDate(dirtyDateLeft);
    var dateRight = toDate(dirtyDateRight);
    return dateLeft.getTime() - dateRight.getTime();
  }
  function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
    requiredArgs(2, arguments);
    var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1e3;
    return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
  }
  class ContentScriptStateStore {
    constructor() {
      __publicField(this, "contentScriptState", /* @__PURE__ */ new Map());
      __publicField(this, "scheduleCleanup", debounce(2e3, () => {
        for (const [tabId, r2] of [...this.contentScriptState.entries()]) {
          if (!isRecent(r2.date)) {
            this.contentScriptState.delete(tabId);
          }
        }
      }));
    }
    init() {
      eventProxy.addListener("runtime.onMessage", makeMessageListener({
        SaveContentScriptState: ({
          state
        }, sender) => this.setContentScriptState(sender, state),
        GetContentScriptState: (_, sender) => this.getContentScriptState(sender)
      }));
      eventProxy.addListener("tabs.onUpdated", (tabId, {
        url
      }) => {
        if (!url) {
          return;
        }
        this.clearStateOnNavigation(tabId, url);
      });
    }
    setContentScriptState(sender, state) {
      var _a2;
      const {
        tab
      } = sender;
      const tabId = (_a2 = sender.tab) == null ? void 0 : _a2.id;
      const {
        frameId
      } = sender;
      if (tab === void 0 || tabId === void 0 || frameId === void 0) {
        return;
      }
      if (!this.contentScriptState.has(tabId)) {
        const stateByFrame = /* @__PURE__ */ new Map();
        stateByFrame.set(frameId, state);
        this.contentScriptState.set(tabId, {
          host: getHost(tab.url),
          date: /* @__PURE__ */ new Date(),
          stateByFrame
        });
      } else {
        const tabState = this.contentScriptState.get(tabId);
        tabState.host = getHost(tab.url);
        tabState.date = /* @__PURE__ */ new Date();
        tabState.stateByFrame.set(frameId, state);
      }
      this.scheduleCleanup();
    }
    getContentScriptState(sender) {
      var _a2;
      const tabId = (_a2 = sender.tab) == null ? void 0 : _a2.id;
      const {
        frameId
      } = sender;
      if (tabId === void 0 || frameId === void 0) {
        return void 0;
      }
      const tabState = this.contentScriptState.get(tabId);
      if (!tabState) {
        return void 0;
      }
      if (!isRecent(tabState.date)) {
        return void 0;
      }
      const state = tabState.stateByFrame.get(frameId);
      tabState.stateByFrame.delete(frameId);
      return state ?? void 0;
    }
    clearStateOnNavigation(tabId, url) {
      var _a2;
      const host = getHost(url);
      if (this.contentScriptState.has(tabId) && ((_a2 = this.contentScriptState.get(tabId)) == null ? void 0 : _a2.host) !== host) {
        this.contentScriptState.delete(tabId);
      }
    }
  }
  function isRecent(date2) {
    const seconds = differenceInSeconds(/* @__PURE__ */ new Date(), date2);
    return seconds <= 15;
  }
  function getHost(urlString) {
    return new URL(urlString).host;
  }
  background;
  async function injectContentScripts() {
    const tabs = await browser$1.tabs.query({});
    const tabIds = tabs.map((tab) => tab.id).filter((tid) => tid !== void 0);
    const contentScriptFile = "/content-scripts/content.js";
    const scriptPromises = tabIds.flatMap((tid) => executeContentScript(tid, contentScriptFile));
    await Promise.allSettled(scriptPromises);
  }
  function executeContentScript(tid, file) {
    if (browser$1.scripting && browser$1.scripting.executeScript) {
      return browser$1.scripting.executeScript({
        target: {
          tabId: tid,
          allFrames: true
        },
        files: [file]
      });
    }
    return browser$1.tabs.executeScript(tid, {
      file
    });
  }
  async function getFrontendTab() {
    const frontendUrl = getFrontendServerUrl();
    const tabsInCurrentWindow = await browser$1.tabs.query({});
    const currentWindowFrontendTab = tabsInCurrentWindow.find((t) => {
      var _a2;
      return (_a2 = t.url) == null ? void 0 : _a2.startsWith(frontendUrl);
    });
    if (currentWindowFrontendTab) {
      return currentWindowFrontendTab;
    }
    const tabs = await browser$1.tabs.query({});
    const frontendTab = tabs.find((t) => {
      var _a2;
      return (_a2 = t.url) == null ? void 0 : _a2.startsWith(frontendUrl);
    });
    if (frontendTab) {
      return frontendTab;
    }
    return void 0;
  }
  async function openWebapp() {
    if (await isInstalledByPolicy()) {
      return;
    }
    const tab = await getFrontendTab();
    if ((tab == null ? void 0 : tab.id) !== void 0) {
      await browser$1.windows.update(tab.windowId, {
        focused: true
      });
      await browser$1.tabs.update(tab.id, {
        active: true
      });
    } else {
      await browser$1.tabs.create({
        url: getFrontendServerUrl()
      });
    }
  }
  async function safariSpecialCase(parsedBrowser) {
    const webappUrl = new URL(getFrontendServerUrl());
    webappUrl.port = "";
    const hasWebappPermission = await browser$1.permissions.contains({
      origins: [`${webappUrl}*`]
    });
    if (!hasWebappPermission) {
      const permissionsPath = isMobileSafari(parsedBrowser) ? "/extensionSetup/mobileSafari/permissions" : "/extensionSetup/desktopSafari/permissions";
      await browser$1.tabs.create({
        url: `${getFrontendServerUrl()}${permissionsPath}`
      });
    }
  }
  function setupInstallationHandling() {
    const parsedBrowser = Bowser.parse(navigator.userAgent);
    if (isSafari(parsedBrowser)) {
      safariSpecialCase(parsedBrowser).catch(trackError);
      return;
    }
    eventProxy.addListener("runtime.onInstalled", ({
      reason
    }) => {
      const promises = [];
      promises.push(injectContentScripts());
      if (reason === "install") {
        promises.push(openWebapp());
      }
      Promise.all(promises).catch(trackError);
    });
  }
  background;
  class RequestsSettledHandler {
    constructor() {
      __publicField(this, "messageListener", makeMessageListener({
        WaitForSenderTabRequestsSettled: ({
          timeoutMs
        }, sender) => this.handleWaitForSenderTabRequestsSettled(sender, timeoutMs)
      }));
    }
    init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
    async handleWaitForSenderTabRequestsSettled(sender, timeoutMs) {
      var _a2;
      const tabId = (_a2 = sender.tab) == null ? void 0 : _a2.id;
      const frameId = sender.frameId;
      if (tabId === void 0 || frameId === void 0) {
        return;
      }
      await new TabRequestTracker(tabId, frameId).waitForTabRequestsSettled(timeoutMs);
    }
  }
  class TabRequestTracker {
    constructor(tabId, frameId) {
      __publicField(this, "requests", /* @__PURE__ */ new Set());
      __publicField(this, "resolve");
      __publicField(this, "handleBeforeRequest", (req) => {
        if (req.frameId !== this.frameId) {
          return;
        }
        debugConsole.log("[RequestsSettledHandler]", "onBeforeRequest", req);
        this.requests.add(req.requestId);
      });
      __publicField(this, "handleCompleted", (req) => {
        if (req.frameId !== this.frameId) {
          return;
        }
        debugConsole.log("[RequestsSettledHandler]", "onCompleted", req);
        this.requests.delete(req.requestId);
        this.scheduleResolveCheck();
      });
      __publicField(this, "handleErrorOccurred", (req) => {
        if (req.frameId !== this.frameId) {
          return;
        }
        debugConsole.log("[RequestsSettledHandler]", "onErrorOccurred", req);
        this.requests.delete(req.requestId);
        this.scheduleResolveCheck();
      });
      __publicField(this, "handleBeforeRedirect", (req) => {
        if (req.frameId !== this.frameId || !req.redirectUrl.startsWith("data:")) {
          return;
        }
        debugConsole.log("[RequestsSettledHandler]", "onBeforeRedirect", req);
        this.requests.delete(req.requestId);
        this.scheduleResolveCheck();
      });
      __publicField(this, "scheduleResolveCheck", debounce(300, () => {
        var _a2;
        if (this.requests.size === 0) {
          debugConsole.log("[RequestsSettledHandler]", "all requests done");
          (_a2 = this.resolve) == null ? void 0 : _a2.call(this);
        }
      }));
      this.tabId = tabId;
      this.frameId = frameId;
    }
    async waitForTabRequestsSettled(timeoutMs) {
      try {
        const timeoutPromise = new Promise((resolve) => setTimeout(resolve, timeoutMs));
        const allRequestsSettledPromise = new Promise((resolve) => {
          this.resolve = () => {
            resolve();
            this.resolve = void 0;
          };
        });
        const filter2 = {
          tabId: this.tabId,
          urls: ["*://*/*"]
          // We could wait only for specific types. However, for the current use of
          // RequestsSettledHandler (block autosnatch during our own login process), there is no
          // advantage to that. So we just use all.
          // types: ['main_frame', 'sub_frame', 'xmlhttprequest'],
        };
        browser$1.webRequest.onBeforeRequest.addListener(this.handleBeforeRequest, filter2);
        browser$1.webRequest.onCompleted.addListener(this.handleCompleted, filter2);
        browser$1.webRequest.onErrorOccurred.addListener(this.handleErrorOccurred, filter2);
        browser$1.webRequest.onBeforeRedirect.addListener(this.handleBeforeRedirect, filter2);
        return await Promise.race([allRequestsSettledPromise, timeoutPromise]);
      } finally {
        this.cleanup();
      }
    }
    cleanup() {
      browser$1.webRequest.onBeforeRequest.removeListener(this.handleBeforeRequest);
      browser$1.webRequest.onCompleted.removeListener(this.handleCompleted);
      browser$1.webRequest.onErrorOccurred.removeListener(this.handleErrorOccurred);
      browser$1.webRequest.onBeforeRedirect.removeListener(this.handleBeforeRedirect);
    }
  }
  background;
  var jsQR$1 = { exports: {} };
  (function(module2, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
      module2.exports = factory();
    })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 3);
        }([
          /* 0 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix = (
              /** @class */
              function() {
                function BitMatrix2(data, width) {
                  this.width = width;
                  this.height = data.length / width;
                  this.data = data;
                }
                BitMatrix2.createEmpty = function(width, height) {
                  return new BitMatrix2(new Uint8ClampedArray(width * height), width);
                };
                BitMatrix2.prototype.get = function(x2, y2) {
                  if (x2 < 0 || x2 >= this.width || y2 < 0 || y2 >= this.height) {
                    return false;
                  }
                  return !!this.data[y2 * this.width + x2];
                };
                BitMatrix2.prototype.set = function(x2, y2, v2) {
                  this.data[y2 * this.width + x2] = v2 ? 1 : 0;
                };
                BitMatrix2.prototype.setRegion = function(left, top, width, height, v2) {
                  for (var y2 = top; y2 < top + height; y2++) {
                    for (var x2 = left; x2 < left + width; x2++) {
                      this.set(x2, y2, !!v2);
                    }
                  }
                };
                return BitMatrix2;
              }()
            );
            exports2.BitMatrix = BitMatrix;
          },
          /* 1 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var GenericGFPoly_1 = __webpack_require__(2);
            function addOrSubtractGF(a2, b) {
              return a2 ^ b;
            }
            exports2.addOrSubtractGF = addOrSubtractGF;
            var GenericGF = (
              /** @class */
              function() {
                function GenericGF2(primitive, size, genBase) {
                  this.primitive = primitive;
                  this.size = size;
                  this.generatorBase = genBase;
                  this.expTable = new Array(this.size);
                  this.logTable = new Array(this.size);
                  var x2 = 1;
                  for (var i2 = 0; i2 < this.size; i2++) {
                    this.expTable[i2] = x2;
                    x2 = x2 * 2;
                    if (x2 >= this.size) {
                      x2 = (x2 ^ this.primitive) & this.size - 1;
                    }
                  }
                  for (var i2 = 0; i2 < this.size - 1; i2++) {
                    this.logTable[this.expTable[i2]] = i2;
                  }
                  this.zero = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([0]));
                  this.one = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([1]));
                }
                GenericGF2.prototype.multiply = function(a2, b) {
                  if (a2 === 0 || b === 0) {
                    return 0;
                  }
                  return this.expTable[(this.logTable[a2] + this.logTable[b]) % (this.size - 1)];
                };
                GenericGF2.prototype.inverse = function(a2) {
                  if (a2 === 0) {
                    throw new Error("Can't invert 0");
                  }
                  return this.expTable[this.size - this.logTable[a2] - 1];
                };
                GenericGF2.prototype.buildMonomial = function(degree, coefficient) {
                  if (degree < 0) {
                    throw new Error("Invalid monomial degree less than 0");
                  }
                  if (coefficient === 0) {
                    return this.zero;
                  }
                  var coefficients = new Uint8ClampedArray(degree + 1);
                  coefficients[0] = coefficient;
                  return new GenericGFPoly_1.default(this, coefficients);
                };
                GenericGF2.prototype.log = function(a2) {
                  if (a2 === 0) {
                    throw new Error("Can't take log(0)");
                  }
                  return this.logTable[a2];
                };
                GenericGF2.prototype.exp = function(a2) {
                  return this.expTable[a2];
                };
                return GenericGF2;
              }()
            );
            exports2.default = GenericGF;
          },
          /* 2 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var GenericGF_1 = __webpack_require__(1);
            var GenericGFPoly = (
              /** @class */
              function() {
                function GenericGFPoly2(field, coefficients) {
                  if (coefficients.length === 0) {
                    throw new Error("No coefficients.");
                  }
                  this.field = field;
                  var coefficientsLength = coefficients.length;
                  if (coefficientsLength > 1 && coefficients[0] === 0) {
                    var firstNonZero = 1;
                    while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                      firstNonZero++;
                    }
                    if (firstNonZero === coefficientsLength) {
                      this.coefficients = field.zero.coefficients;
                    } else {
                      this.coefficients = new Uint8ClampedArray(coefficientsLength - firstNonZero);
                      for (var i2 = 0; i2 < this.coefficients.length; i2++) {
                        this.coefficients[i2] = coefficients[firstNonZero + i2];
                      }
                    }
                  } else {
                    this.coefficients = coefficients;
                  }
                }
                GenericGFPoly2.prototype.degree = function() {
                  return this.coefficients.length - 1;
                };
                GenericGFPoly2.prototype.isZero = function() {
                  return this.coefficients[0] === 0;
                };
                GenericGFPoly2.prototype.getCoefficient = function(degree) {
                  return this.coefficients[this.coefficients.length - 1 - degree];
                };
                GenericGFPoly2.prototype.addOrSubtract = function(other) {
                  var _a2;
                  if (this.isZero()) {
                    return other;
                  }
                  if (other.isZero()) {
                    return this;
                  }
                  var smallerCoefficients = this.coefficients;
                  var largerCoefficients = other.coefficients;
                  if (smallerCoefficients.length > largerCoefficients.length) {
                    _a2 = [largerCoefficients, smallerCoefficients], smallerCoefficients = _a2[0], largerCoefficients = _a2[1];
                  }
                  var sumDiff = new Uint8ClampedArray(largerCoefficients.length);
                  var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
                  for (var i2 = 0; i2 < lengthDiff; i2++) {
                    sumDiff[i2] = largerCoefficients[i2];
                  }
                  for (var i2 = lengthDiff; i2 < largerCoefficients.length; i2++) {
                    sumDiff[i2] = GenericGF_1.addOrSubtractGF(smallerCoefficients[i2 - lengthDiff], largerCoefficients[i2]);
                  }
                  return new GenericGFPoly2(this.field, sumDiff);
                };
                GenericGFPoly2.prototype.multiply = function(scalar) {
                  if (scalar === 0) {
                    return this.field.zero;
                  }
                  if (scalar === 1) {
                    return this;
                  }
                  var size = this.coefficients.length;
                  var product = new Uint8ClampedArray(size);
                  for (var i2 = 0; i2 < size; i2++) {
                    product[i2] = this.field.multiply(this.coefficients[i2], scalar);
                  }
                  return new GenericGFPoly2(this.field, product);
                };
                GenericGFPoly2.prototype.multiplyPoly = function(other) {
                  if (this.isZero() || other.isZero()) {
                    return this.field.zero;
                  }
                  var aCoefficients = this.coefficients;
                  var aLength = aCoefficients.length;
                  var bCoefficients = other.coefficients;
                  var bLength = bCoefficients.length;
                  var product = new Uint8ClampedArray(aLength + bLength - 1);
                  for (var i2 = 0; i2 < aLength; i2++) {
                    var aCoeff = aCoefficients[i2];
                    for (var j = 0; j < bLength; j++) {
                      product[i2 + j] = GenericGF_1.addOrSubtractGF(product[i2 + j], this.field.multiply(aCoeff, bCoefficients[j]));
                    }
                  }
                  return new GenericGFPoly2(this.field, product);
                };
                GenericGFPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
                  if (degree < 0) {
                    throw new Error("Invalid degree less than 0");
                  }
                  if (coefficient === 0) {
                    return this.field.zero;
                  }
                  var size = this.coefficients.length;
                  var product = new Uint8ClampedArray(size + degree);
                  for (var i2 = 0; i2 < size; i2++) {
                    product[i2] = this.field.multiply(this.coefficients[i2], coefficient);
                  }
                  return new GenericGFPoly2(this.field, product);
                };
                GenericGFPoly2.prototype.evaluateAt = function(a2) {
                  var result2 = 0;
                  if (a2 === 0) {
                    return this.getCoefficient(0);
                  }
                  var size = this.coefficients.length;
                  if (a2 === 1) {
                    this.coefficients.forEach(function(coefficient) {
                      result2 = GenericGF_1.addOrSubtractGF(result2, coefficient);
                    });
                    return result2;
                  }
                  result2 = this.coefficients[0];
                  for (var i2 = 1; i2 < size; i2++) {
                    result2 = GenericGF_1.addOrSubtractGF(this.field.multiply(a2, result2), this.coefficients[i2]);
                  }
                  return result2;
                };
                return GenericGFPoly2;
              }()
            );
            exports2.default = GenericGFPoly;
          },
          /* 3 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var binarizer_1 = __webpack_require__(4);
            var decoder_1 = __webpack_require__(5);
            var extractor_1 = __webpack_require__(11);
            var locator_1 = __webpack_require__(12);
            function scan(matrix) {
              var locations = locator_1.locate(matrix);
              if (!locations) {
                return null;
              }
              for (var _i2 = 0, locations_1 = locations; _i2 < locations_1.length; _i2++) {
                var location_1 = locations_1[_i2];
                var extracted = extractor_1.extract(matrix, location_1);
                var decoded = decoder_1.decode(extracted.matrix);
                if (decoded) {
                  return {
                    binaryData: decoded.bytes,
                    data: decoded.text,
                    chunks: decoded.chunks,
                    version: decoded.version,
                    location: {
                      topRightCorner: extracted.mappingFunction(location_1.dimension, 0),
                      topLeftCorner: extracted.mappingFunction(0, 0),
                      bottomRightCorner: extracted.mappingFunction(location_1.dimension, location_1.dimension),
                      bottomLeftCorner: extracted.mappingFunction(0, location_1.dimension),
                      topRightFinderPattern: location_1.topRight,
                      topLeftFinderPattern: location_1.topLeft,
                      bottomLeftFinderPattern: location_1.bottomLeft,
                      bottomRightAlignmentPattern: location_1.alignmentPattern
                    }
                  };
                }
              }
              return null;
            }
            var defaultOptions = {
              inversionAttempts: "attemptBoth"
            };
            function jsQR2(data, width, height, providedOptions) {
              if (providedOptions === void 0) {
                providedOptions = {};
              }
              var options = defaultOptions;
              Object.keys(options || {}).forEach(function(opt) {
                options[opt] = providedOptions[opt] || options[opt];
              });
              var shouldInvert = options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst";
              var tryInvertedFirst = options.inversionAttempts === "onlyInvert" || options.inversionAttempts === "invertFirst";
              var _a2 = binarizer_1.binarize(data, width, height, shouldInvert), binarized = _a2.binarized, inverted = _a2.inverted;
              var result2 = scan(tryInvertedFirst ? inverted : binarized);
              if (!result2 && (options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst")) {
                result2 = scan(tryInvertedFirst ? binarized : inverted);
              }
              return result2;
            }
            jsQR2.default = jsQR2;
            exports2.default = jsQR2;
          },
          /* 4 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix_1 = __webpack_require__(0);
            var REGION_SIZE = 8;
            var MIN_DYNAMIC_RANGE = 24;
            function numBetween(value, min, max2) {
              return value < min ? min : value > max2 ? max2 : value;
            }
            var Matrix = (
              /** @class */
              function() {
                function Matrix2(width, height) {
                  this.width = width;
                  this.data = new Uint8ClampedArray(width * height);
                }
                Matrix2.prototype.get = function(x2, y2) {
                  return this.data[y2 * this.width + x2];
                };
                Matrix2.prototype.set = function(x2, y2, value) {
                  this.data[y2 * this.width + x2] = value;
                };
                return Matrix2;
              }()
            );
            function binarize(data, width, height, returnInverted) {
              if (data.length !== width * height * 4) {
                throw new Error("Malformed data passed to binarizer.");
              }
              var greyscalePixels = new Matrix(width, height);
              for (var x2 = 0; x2 < width; x2++) {
                for (var y2 = 0; y2 < height; y2++) {
                  var r2 = data[(y2 * width + x2) * 4 + 0];
                  var g2 = data[(y2 * width + x2) * 4 + 1];
                  var b = data[(y2 * width + x2) * 4 + 2];
                  greyscalePixels.set(x2, y2, 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b);
                }
              }
              var horizontalRegionCount = Math.ceil(width / REGION_SIZE);
              var verticalRegionCount = Math.ceil(height / REGION_SIZE);
              var blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);
              for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
                for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
                  var sum = 0;
                  var min = Infinity;
                  var max2 = 0;
                  for (var y2 = 0; y2 < REGION_SIZE; y2++) {
                    for (var x2 = 0; x2 < REGION_SIZE; x2++) {
                      var pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x2, verticalRegion * REGION_SIZE + y2);
                      sum += pixelLumosity;
                      min = Math.min(min, pixelLumosity);
                      max2 = Math.max(max2, pixelLumosity);
                    }
                  }
                  var average = sum / Math.pow(REGION_SIZE, 2);
                  if (max2 - min <= MIN_DYNAMIC_RANGE) {
                    average = min / 2;
                    if (verticalRegion > 0 && hortizontalRegion > 0) {
                      var averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - 1) + 2 * blackPoints.get(hortizontalRegion - 1, verticalRegion) + blackPoints.get(hortizontalRegion - 1, verticalRegion - 1)) / 4;
                      if (min < averageNeighborBlackPoint) {
                        average = averageNeighborBlackPoint;
                      }
                    }
                  }
                  blackPoints.set(hortizontalRegion, verticalRegion, average);
                }
              }
              var binarized = BitMatrix_1.BitMatrix.createEmpty(width, height);
              var inverted = null;
              if (returnInverted) {
                inverted = BitMatrix_1.BitMatrix.createEmpty(width, height);
              }
              for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
                for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
                  var left = numBetween(hortizontalRegion, 2, horizontalRegionCount - 3);
                  var top_1 = numBetween(verticalRegion, 2, verticalRegionCount - 3);
                  var sum = 0;
                  for (var xRegion = -2; xRegion <= 2; xRegion++) {
                    for (var yRegion = -2; yRegion <= 2; yRegion++) {
                      sum += blackPoints.get(left + xRegion, top_1 + yRegion);
                    }
                  }
                  var threshold = sum / 25;
                  for (var xRegion = 0; xRegion < REGION_SIZE; xRegion++) {
                    for (var yRegion = 0; yRegion < REGION_SIZE; yRegion++) {
                      var x2 = hortizontalRegion * REGION_SIZE + xRegion;
                      var y2 = verticalRegion * REGION_SIZE + yRegion;
                      var lum = greyscalePixels.get(x2, y2);
                      binarized.set(x2, y2, lum <= threshold);
                      if (returnInverted) {
                        inverted.set(x2, y2, !(lum <= threshold));
                      }
                    }
                  }
                }
              }
              if (returnInverted) {
                return { binarized, inverted };
              }
              return { binarized };
            }
            exports2.binarize = binarize;
          },
          /* 5 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix_1 = __webpack_require__(0);
            var decodeData_1 = __webpack_require__(6);
            var reedsolomon_1 = __webpack_require__(9);
            var version_1 = __webpack_require__(10);
            function numBitsDiffering(x2, y2) {
              var z2 = x2 ^ y2;
              var bitCount = 0;
              while (z2) {
                bitCount++;
                z2 &= z2 - 1;
              }
              return bitCount;
            }
            function pushBit(bit, byte) {
              return byte << 1 | bit;
            }
            var FORMAT_INFO_TABLE = [
              { bits: 21522, formatInfo: { errorCorrectionLevel: 1, dataMask: 0 } },
              { bits: 20773, formatInfo: { errorCorrectionLevel: 1, dataMask: 1 } },
              { bits: 24188, formatInfo: { errorCorrectionLevel: 1, dataMask: 2 } },
              { bits: 23371, formatInfo: { errorCorrectionLevel: 1, dataMask: 3 } },
              { bits: 17913, formatInfo: { errorCorrectionLevel: 1, dataMask: 4 } },
              { bits: 16590, formatInfo: { errorCorrectionLevel: 1, dataMask: 5 } },
              { bits: 20375, formatInfo: { errorCorrectionLevel: 1, dataMask: 6 } },
              { bits: 19104, formatInfo: { errorCorrectionLevel: 1, dataMask: 7 } },
              { bits: 30660, formatInfo: { errorCorrectionLevel: 0, dataMask: 0 } },
              { bits: 29427, formatInfo: { errorCorrectionLevel: 0, dataMask: 1 } },
              { bits: 32170, formatInfo: { errorCorrectionLevel: 0, dataMask: 2 } },
              { bits: 30877, formatInfo: { errorCorrectionLevel: 0, dataMask: 3 } },
              { bits: 26159, formatInfo: { errorCorrectionLevel: 0, dataMask: 4 } },
              { bits: 25368, formatInfo: { errorCorrectionLevel: 0, dataMask: 5 } },
              { bits: 27713, formatInfo: { errorCorrectionLevel: 0, dataMask: 6 } },
              { bits: 26998, formatInfo: { errorCorrectionLevel: 0, dataMask: 7 } },
              { bits: 5769, formatInfo: { errorCorrectionLevel: 3, dataMask: 0 } },
              { bits: 5054, formatInfo: { errorCorrectionLevel: 3, dataMask: 1 } },
              { bits: 7399, formatInfo: { errorCorrectionLevel: 3, dataMask: 2 } },
              { bits: 6608, formatInfo: { errorCorrectionLevel: 3, dataMask: 3 } },
              { bits: 1890, formatInfo: { errorCorrectionLevel: 3, dataMask: 4 } },
              { bits: 597, formatInfo: { errorCorrectionLevel: 3, dataMask: 5 } },
              { bits: 3340, formatInfo: { errorCorrectionLevel: 3, dataMask: 6 } },
              { bits: 2107, formatInfo: { errorCorrectionLevel: 3, dataMask: 7 } },
              { bits: 13663, formatInfo: { errorCorrectionLevel: 2, dataMask: 0 } },
              { bits: 12392, formatInfo: { errorCorrectionLevel: 2, dataMask: 1 } },
              { bits: 16177, formatInfo: { errorCorrectionLevel: 2, dataMask: 2 } },
              { bits: 14854, formatInfo: { errorCorrectionLevel: 2, dataMask: 3 } },
              { bits: 9396, formatInfo: { errorCorrectionLevel: 2, dataMask: 4 } },
              { bits: 8579, formatInfo: { errorCorrectionLevel: 2, dataMask: 5 } },
              { bits: 11994, formatInfo: { errorCorrectionLevel: 2, dataMask: 6 } },
              { bits: 11245, formatInfo: { errorCorrectionLevel: 2, dataMask: 7 } }
            ];
            var DATA_MASKS = [
              function(p2) {
                return (p2.y + p2.x) % 2 === 0;
              },
              function(p2) {
                return p2.y % 2 === 0;
              },
              function(p2) {
                return p2.x % 3 === 0;
              },
              function(p2) {
                return (p2.y + p2.x) % 3 === 0;
              },
              function(p2) {
                return (Math.floor(p2.y / 2) + Math.floor(p2.x / 3)) % 2 === 0;
              },
              function(p2) {
                return p2.x * p2.y % 2 + p2.x * p2.y % 3 === 0;
              },
              function(p2) {
                return (p2.y * p2.x % 2 + p2.y * p2.x % 3) % 2 === 0;
              },
              function(p2) {
                return ((p2.y + p2.x) % 2 + p2.y * p2.x % 3) % 2 === 0;
              }
            ];
            function buildFunctionPatternMask(version) {
              var dimension = 17 + 4 * version.versionNumber;
              var matrix = BitMatrix_1.BitMatrix.createEmpty(dimension, dimension);
              matrix.setRegion(0, 0, 9, 9, true);
              matrix.setRegion(dimension - 8, 0, 8, 9, true);
              matrix.setRegion(0, dimension - 8, 9, 8, true);
              for (var _i2 = 0, _a2 = version.alignmentPatternCenters; _i2 < _a2.length; _i2++) {
                var x2 = _a2[_i2];
                for (var _b2 = 0, _c2 = version.alignmentPatternCenters; _b2 < _c2.length; _b2++) {
                  var y2 = _c2[_b2];
                  if (!(x2 === 6 && y2 === 6 || x2 === 6 && y2 === dimension - 7 || x2 === dimension - 7 && y2 === 6)) {
                    matrix.setRegion(x2 - 2, y2 - 2, 5, 5, true);
                  }
                }
              }
              matrix.setRegion(6, 9, 1, dimension - 17, true);
              matrix.setRegion(9, 6, dimension - 17, 1, true);
              if (version.versionNumber > 6) {
                matrix.setRegion(dimension - 11, 0, 3, 6, true);
                matrix.setRegion(0, dimension - 11, 6, 3, true);
              }
              return matrix;
            }
            function readCodewords(matrix, version, formatInfo) {
              var dataMask = DATA_MASKS[formatInfo.dataMask];
              var dimension = matrix.height;
              var functionPatternMask = buildFunctionPatternMask(version);
              var codewords = [];
              var currentByte = 0;
              var bitsRead = 0;
              var readingUp = true;
              for (var columnIndex = dimension - 1; columnIndex > 0; columnIndex -= 2) {
                if (columnIndex === 6) {
                  columnIndex--;
                }
                for (var i2 = 0; i2 < dimension; i2++) {
                  var y2 = readingUp ? dimension - 1 - i2 : i2;
                  for (var columnOffset = 0; columnOffset < 2; columnOffset++) {
                    var x2 = columnIndex - columnOffset;
                    if (!functionPatternMask.get(x2, y2)) {
                      bitsRead++;
                      var bit = matrix.get(x2, y2);
                      if (dataMask({ y: y2, x: x2 })) {
                        bit = !bit;
                      }
                      currentByte = pushBit(bit, currentByte);
                      if (bitsRead === 8) {
                        codewords.push(currentByte);
                        bitsRead = 0;
                        currentByte = 0;
                      }
                    }
                  }
                }
                readingUp = !readingUp;
              }
              return codewords;
            }
            function readVersion(matrix) {
              var dimension = matrix.height;
              var provisionalVersion = Math.floor((dimension - 17) / 4);
              if (provisionalVersion <= 6) {
                return version_1.VERSIONS[provisionalVersion - 1];
              }
              var topRightVersionBits = 0;
              for (var y2 = 5; y2 >= 0; y2--) {
                for (var x2 = dimension - 9; x2 >= dimension - 11; x2--) {
                  topRightVersionBits = pushBit(matrix.get(x2, y2), topRightVersionBits);
                }
              }
              var bottomLeftVersionBits = 0;
              for (var x2 = 5; x2 >= 0; x2--) {
                for (var y2 = dimension - 9; y2 >= dimension - 11; y2--) {
                  bottomLeftVersionBits = pushBit(matrix.get(x2, y2), bottomLeftVersionBits);
                }
              }
              var bestDifference = Infinity;
              var bestVersion;
              for (var _i2 = 0, VERSIONS_1 = version_1.VERSIONS; _i2 < VERSIONS_1.length; _i2++) {
                var version = VERSIONS_1[_i2];
                if (version.infoBits === topRightVersionBits || version.infoBits === bottomLeftVersionBits) {
                  return version;
                }
                var difference = numBitsDiffering(topRightVersionBits, version.infoBits);
                if (difference < bestDifference) {
                  bestVersion = version;
                  bestDifference = difference;
                }
                difference = numBitsDiffering(bottomLeftVersionBits, version.infoBits);
                if (difference < bestDifference) {
                  bestVersion = version;
                  bestDifference = difference;
                }
              }
              if (bestDifference <= 3) {
                return bestVersion;
              }
            }
            function readFormatInformation(matrix) {
              var topLeftFormatInfoBits = 0;
              for (var x2 = 0; x2 <= 8; x2++) {
                if (x2 !== 6) {
                  topLeftFormatInfoBits = pushBit(matrix.get(x2, 8), topLeftFormatInfoBits);
                }
              }
              for (var y2 = 7; y2 >= 0; y2--) {
                if (y2 !== 6) {
                  topLeftFormatInfoBits = pushBit(matrix.get(8, y2), topLeftFormatInfoBits);
                }
              }
              var dimension = matrix.height;
              var topRightBottomRightFormatInfoBits = 0;
              for (var y2 = dimension - 1; y2 >= dimension - 7; y2--) {
                topRightBottomRightFormatInfoBits = pushBit(matrix.get(8, y2), topRightBottomRightFormatInfoBits);
              }
              for (var x2 = dimension - 8; x2 < dimension; x2++) {
                topRightBottomRightFormatInfoBits = pushBit(matrix.get(x2, 8), topRightBottomRightFormatInfoBits);
              }
              var bestDifference = Infinity;
              var bestFormatInfo = null;
              for (var _i2 = 0, FORMAT_INFO_TABLE_1 = FORMAT_INFO_TABLE; _i2 < FORMAT_INFO_TABLE_1.length; _i2++) {
                var _a2 = FORMAT_INFO_TABLE_1[_i2], bits = _a2.bits, formatInfo = _a2.formatInfo;
                if (bits === topLeftFormatInfoBits || bits === topRightBottomRightFormatInfoBits) {
                  return formatInfo;
                }
                var difference = numBitsDiffering(topLeftFormatInfoBits, bits);
                if (difference < bestDifference) {
                  bestFormatInfo = formatInfo;
                  bestDifference = difference;
                }
                if (topLeftFormatInfoBits !== topRightBottomRightFormatInfoBits) {
                  difference = numBitsDiffering(topRightBottomRightFormatInfoBits, bits);
                  if (difference < bestDifference) {
                    bestFormatInfo = formatInfo;
                    bestDifference = difference;
                  }
                }
              }
              if (bestDifference <= 3) {
                return bestFormatInfo;
              }
              return null;
            }
            function getDataBlocks(codewords, version, ecLevel) {
              var ecInfo = version.errorCorrectionLevels[ecLevel];
              var dataBlocks = [];
              var totalCodewords = 0;
              ecInfo.ecBlocks.forEach(function(block) {
                for (var i3 = 0; i3 < block.numBlocks; i3++) {
                  dataBlocks.push({ numDataCodewords: block.dataCodewordsPerBlock, codewords: [] });
                  totalCodewords += block.dataCodewordsPerBlock + ecInfo.ecCodewordsPerBlock;
                }
              });
              if (codewords.length < totalCodewords) {
                return null;
              }
              codewords = codewords.slice(0, totalCodewords);
              var shortBlockSize = ecInfo.ecBlocks[0].dataCodewordsPerBlock;
              for (var i2 = 0; i2 < shortBlockSize; i2++) {
                for (var _i2 = 0, dataBlocks_1 = dataBlocks; _i2 < dataBlocks_1.length; _i2++) {
                  var dataBlock = dataBlocks_1[_i2];
                  dataBlock.codewords.push(codewords.shift());
                }
              }
              if (ecInfo.ecBlocks.length > 1) {
                var smallBlockCount = ecInfo.ecBlocks[0].numBlocks;
                var largeBlockCount = ecInfo.ecBlocks[1].numBlocks;
                for (var i2 = 0; i2 < largeBlockCount; i2++) {
                  dataBlocks[smallBlockCount + i2].codewords.push(codewords.shift());
                }
              }
              while (codewords.length > 0) {
                for (var _a2 = 0, dataBlocks_2 = dataBlocks; _a2 < dataBlocks_2.length; _a2++) {
                  var dataBlock = dataBlocks_2[_a2];
                  dataBlock.codewords.push(codewords.shift());
                }
              }
              return dataBlocks;
            }
            function decodeMatrix(matrix) {
              var version = readVersion(matrix);
              if (!version) {
                return null;
              }
              var formatInfo = readFormatInformation(matrix);
              if (!formatInfo) {
                return null;
              }
              var codewords = readCodewords(matrix, version, formatInfo);
              var dataBlocks = getDataBlocks(codewords, version, formatInfo.errorCorrectionLevel);
              if (!dataBlocks) {
                return null;
              }
              var totalBytes = dataBlocks.reduce(function(a2, b) {
                return a2 + b.numDataCodewords;
              }, 0);
              var resultBytes = new Uint8ClampedArray(totalBytes);
              var resultIndex = 0;
              for (var _i2 = 0, dataBlocks_3 = dataBlocks; _i2 < dataBlocks_3.length; _i2++) {
                var dataBlock = dataBlocks_3[_i2];
                var correctedBytes = reedsolomon_1.decode(dataBlock.codewords, dataBlock.codewords.length - dataBlock.numDataCodewords);
                if (!correctedBytes) {
                  return null;
                }
                for (var i2 = 0; i2 < dataBlock.numDataCodewords; i2++) {
                  resultBytes[resultIndex++] = correctedBytes[i2];
                }
              }
              try {
                return decodeData_1.decode(resultBytes, version.versionNumber);
              } catch (_a2) {
                return null;
              }
            }
            function decode2(matrix) {
              if (matrix == null) {
                return null;
              }
              var result2 = decodeMatrix(matrix);
              if (result2) {
                return result2;
              }
              for (var x2 = 0; x2 < matrix.width; x2++) {
                for (var y2 = x2 + 1; y2 < matrix.height; y2++) {
                  if (matrix.get(x2, y2) !== matrix.get(y2, x2)) {
                    matrix.set(x2, y2, !matrix.get(x2, y2));
                    matrix.set(y2, x2, !matrix.get(y2, x2));
                  }
                }
              }
              return decodeMatrix(matrix);
            }
            exports2.decode = decode2;
          },
          /* 6 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitStream_1 = __webpack_require__(7);
            var shiftJISTable_1 = __webpack_require__(8);
            var Mode;
            (function(Mode2) {
              Mode2["Numeric"] = "numeric";
              Mode2["Alphanumeric"] = "alphanumeric";
              Mode2["Byte"] = "byte";
              Mode2["Kanji"] = "kanji";
              Mode2["ECI"] = "eci";
            })(Mode = exports2.Mode || (exports2.Mode = {}));
            var ModeByte;
            (function(ModeByte2) {
              ModeByte2[ModeByte2["Terminator"] = 0] = "Terminator";
              ModeByte2[ModeByte2["Numeric"] = 1] = "Numeric";
              ModeByte2[ModeByte2["Alphanumeric"] = 2] = "Alphanumeric";
              ModeByte2[ModeByte2["Byte"] = 4] = "Byte";
              ModeByte2[ModeByte2["Kanji"] = 8] = "Kanji";
              ModeByte2[ModeByte2["ECI"] = 7] = "ECI";
            })(ModeByte || (ModeByte = {}));
            function decodeNumeric(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [10, 12, 14][size];
              var length = stream.readBits(characterCountSize);
              while (length >= 3) {
                var num = stream.readBits(10);
                if (num >= 1e3) {
                  throw new Error("Invalid numeric value above 999");
                }
                var a2 = Math.floor(num / 100);
                var b = Math.floor(num / 10) % 10;
                var c2 = num % 10;
                bytes.push(48 + a2, 48 + b, 48 + c2);
                text += a2.toString() + b.toString() + c2.toString();
                length -= 3;
              }
              if (length === 2) {
                var num = stream.readBits(7);
                if (num >= 100) {
                  throw new Error("Invalid numeric value above 99");
                }
                var a2 = Math.floor(num / 10);
                var b = num % 10;
                bytes.push(48 + a2, 48 + b);
                text += a2.toString() + b.toString();
              } else if (length === 1) {
                var num = stream.readBits(4);
                if (num >= 10) {
                  throw new Error("Invalid numeric value above 9");
                }
                bytes.push(48 + num);
                text += num.toString();
              }
              return { bytes, text };
            }
            var AlphanumericCharacterCodes = [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "A",
              "B",
              "C",
              "D",
              "E",
              "F",
              "G",
              "H",
              "I",
              "J",
              "K",
              "L",
              "M",
              "N",
              "O",
              "P",
              "Q",
              "R",
              "S",
              "T",
              "U",
              "V",
              "W",
              "X",
              "Y",
              "Z",
              " ",
              "$",
              "%",
              "*",
              "+",
              "-",
              ".",
              "/",
              ":"
            ];
            function decodeAlphanumeric(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [9, 11, 13][size];
              var length = stream.readBits(characterCountSize);
              while (length >= 2) {
                var v2 = stream.readBits(11);
                var a2 = Math.floor(v2 / 45);
                var b = v2 % 45;
                bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0), AlphanumericCharacterCodes[b].charCodeAt(0));
                text += AlphanumericCharacterCodes[a2] + AlphanumericCharacterCodes[b];
                length -= 2;
              }
              if (length === 1) {
                var a2 = stream.readBits(6);
                bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0));
                text += AlphanumericCharacterCodes[a2];
              }
              return { bytes, text };
            }
            function decodeByte(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [8, 16, 16][size];
              var length = stream.readBits(characterCountSize);
              for (var i2 = 0; i2 < length; i2++) {
                var b = stream.readBits(8);
                bytes.push(b);
              }
              try {
                text += decodeURIComponent(bytes.map(function(b2) {
                  return "%" + ("0" + b2.toString(16)).substr(-2);
                }).join(""));
              } catch (_a2) {
              }
              return { bytes, text };
            }
            function decodeKanji(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [8, 10, 12][size];
              var length = stream.readBits(characterCountSize);
              for (var i2 = 0; i2 < length; i2++) {
                var k = stream.readBits(13);
                var c2 = Math.floor(k / 192) << 8 | k % 192;
                if (c2 < 7936) {
                  c2 += 33088;
                } else {
                  c2 += 49472;
                }
                bytes.push(c2 >> 8, c2 & 255);
                text += String.fromCharCode(shiftJISTable_1.shiftJISTable[c2]);
              }
              return { bytes, text };
            }
            function decode2(data, version) {
              var _a2, _b2, _c2, _d2;
              var stream = new BitStream_1.BitStream(data);
              var size = version <= 9 ? 0 : version <= 26 ? 1 : 2;
              var result2 = {
                text: "",
                bytes: [],
                chunks: [],
                version
              };
              while (stream.available() >= 4) {
                var mode = stream.readBits(4);
                if (mode === ModeByte.Terminator) {
                  return result2;
                } else if (mode === ModeByte.ECI) {
                  if (stream.readBits(1) === 0) {
                    result2.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: stream.readBits(7)
                    });
                  } else if (stream.readBits(1) === 0) {
                    result2.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: stream.readBits(14)
                    });
                  } else if (stream.readBits(1) === 0) {
                    result2.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: stream.readBits(21)
                    });
                  } else {
                    result2.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: -1
                    });
                  }
                } else if (mode === ModeByte.Numeric) {
                  var numericResult = decodeNumeric(stream, size);
                  result2.text += numericResult.text;
                  (_a2 = result2.bytes).push.apply(_a2, numericResult.bytes);
                  result2.chunks.push({
                    type: Mode.Numeric,
                    text: numericResult.text
                  });
                } else if (mode === ModeByte.Alphanumeric) {
                  var alphanumericResult = decodeAlphanumeric(stream, size);
                  result2.text += alphanumericResult.text;
                  (_b2 = result2.bytes).push.apply(_b2, alphanumericResult.bytes);
                  result2.chunks.push({
                    type: Mode.Alphanumeric,
                    text: alphanumericResult.text
                  });
                } else if (mode === ModeByte.Byte) {
                  var byteResult = decodeByte(stream, size);
                  result2.text += byteResult.text;
                  (_c2 = result2.bytes).push.apply(_c2, byteResult.bytes);
                  result2.chunks.push({
                    type: Mode.Byte,
                    bytes: byteResult.bytes,
                    text: byteResult.text
                  });
                } else if (mode === ModeByte.Kanji) {
                  var kanjiResult = decodeKanji(stream, size);
                  result2.text += kanjiResult.text;
                  (_d2 = result2.bytes).push.apply(_d2, kanjiResult.bytes);
                  result2.chunks.push({
                    type: Mode.Kanji,
                    bytes: kanjiResult.bytes,
                    text: kanjiResult.text
                  });
                }
              }
              if (stream.available() === 0 || stream.readBits(stream.available()) === 0) {
                return result2;
              }
            }
            exports2.decode = decode2;
          },
          /* 7 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitStream = (
              /** @class */
              function() {
                function BitStream2(bytes) {
                  this.byteOffset = 0;
                  this.bitOffset = 0;
                  this.bytes = bytes;
                }
                BitStream2.prototype.readBits = function(numBits) {
                  if (numBits < 1 || numBits > 32 || numBits > this.available()) {
                    throw new Error("Cannot read " + numBits.toString() + " bits");
                  }
                  var result2 = 0;
                  if (this.bitOffset > 0) {
                    var bitsLeft = 8 - this.bitOffset;
                    var toRead = numBits < bitsLeft ? numBits : bitsLeft;
                    var bitsToNotRead = bitsLeft - toRead;
                    var mask = 255 >> 8 - toRead << bitsToNotRead;
                    result2 = (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
                    numBits -= toRead;
                    this.bitOffset += toRead;
                    if (this.bitOffset === 8) {
                      this.bitOffset = 0;
                      this.byteOffset++;
                    }
                  }
                  if (numBits > 0) {
                    while (numBits >= 8) {
                      result2 = result2 << 8 | this.bytes[this.byteOffset] & 255;
                      this.byteOffset++;
                      numBits -= 8;
                    }
                    if (numBits > 0) {
                      var bitsToNotRead = 8 - numBits;
                      var mask = 255 >> bitsToNotRead << bitsToNotRead;
                      result2 = result2 << numBits | (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
                      this.bitOffset += numBits;
                    }
                  }
                  return result2;
                };
                BitStream2.prototype.available = function() {
                  return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
                };
                return BitStream2;
              }()
            );
            exports2.BitStream = BitStream;
          },
          /* 8 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.shiftJISTable = {
              32: 32,
              33: 33,
              34: 34,
              35: 35,
              36: 36,
              37: 37,
              38: 38,
              39: 39,
              40: 40,
              41: 41,
              42: 42,
              43: 43,
              44: 44,
              45: 45,
              46: 46,
              47: 47,
              48: 48,
              49: 49,
              50: 50,
              51: 51,
              52: 52,
              53: 53,
              54: 54,
              55: 55,
              56: 56,
              57: 57,
              58: 58,
              59: 59,
              60: 60,
              61: 61,
              62: 62,
              63: 63,
              64: 64,
              65: 65,
              66: 66,
              67: 67,
              68: 68,
              69: 69,
              70: 70,
              71: 71,
              72: 72,
              73: 73,
              74: 74,
              75: 75,
              76: 76,
              77: 77,
              78: 78,
              79: 79,
              80: 80,
              81: 81,
              82: 82,
              83: 83,
              84: 84,
              85: 85,
              86: 86,
              87: 87,
              88: 88,
              89: 89,
              90: 90,
              91: 91,
              92: 165,
              93: 93,
              94: 94,
              95: 95,
              96: 96,
              97: 97,
              98: 98,
              99: 99,
              100: 100,
              101: 101,
              102: 102,
              103: 103,
              104: 104,
              105: 105,
              106: 106,
              107: 107,
              108: 108,
              109: 109,
              110: 110,
              111: 111,
              112: 112,
              113: 113,
              114: 114,
              115: 115,
              116: 116,
              117: 117,
              118: 118,
              119: 119,
              120: 120,
              121: 121,
              122: 122,
              123: 123,
              124: 124,
              125: 125,
              126: 8254,
              33088: 12288,
              33089: 12289,
              33090: 12290,
              33091: 65292,
              33092: 65294,
              33093: 12539,
              33094: 65306,
              33095: 65307,
              33096: 65311,
              33097: 65281,
              33098: 12443,
              33099: 12444,
              33100: 180,
              33101: 65344,
              33102: 168,
              33103: 65342,
              33104: 65507,
              33105: 65343,
              33106: 12541,
              33107: 12542,
              33108: 12445,
              33109: 12446,
              33110: 12291,
              33111: 20189,
              33112: 12293,
              33113: 12294,
              33114: 12295,
              33115: 12540,
              33116: 8213,
              33117: 8208,
              33118: 65295,
              33119: 92,
              33120: 12316,
              33121: 8214,
              33122: 65372,
              33123: 8230,
              33124: 8229,
              33125: 8216,
              33126: 8217,
              33127: 8220,
              33128: 8221,
              33129: 65288,
              33130: 65289,
              33131: 12308,
              33132: 12309,
              33133: 65339,
              33134: 65341,
              33135: 65371,
              33136: 65373,
              33137: 12296,
              33138: 12297,
              33139: 12298,
              33140: 12299,
              33141: 12300,
              33142: 12301,
              33143: 12302,
              33144: 12303,
              33145: 12304,
              33146: 12305,
              33147: 65291,
              33148: 8722,
              33149: 177,
              33150: 215,
              33152: 247,
              33153: 65309,
              33154: 8800,
              33155: 65308,
              33156: 65310,
              33157: 8806,
              33158: 8807,
              33159: 8734,
              33160: 8756,
              33161: 9794,
              33162: 9792,
              33163: 176,
              33164: 8242,
              33165: 8243,
              33166: 8451,
              33167: 65509,
              33168: 65284,
              33169: 162,
              33170: 163,
              33171: 65285,
              33172: 65283,
              33173: 65286,
              33174: 65290,
              33175: 65312,
              33176: 167,
              33177: 9734,
              33178: 9733,
              33179: 9675,
              33180: 9679,
              33181: 9678,
              33182: 9671,
              33183: 9670,
              33184: 9633,
              33185: 9632,
              33186: 9651,
              33187: 9650,
              33188: 9661,
              33189: 9660,
              33190: 8251,
              33191: 12306,
              33192: 8594,
              33193: 8592,
              33194: 8593,
              33195: 8595,
              33196: 12307,
              33208: 8712,
              33209: 8715,
              33210: 8838,
              33211: 8839,
              33212: 8834,
              33213: 8835,
              33214: 8746,
              33215: 8745,
              33224: 8743,
              33225: 8744,
              33226: 172,
              33227: 8658,
              33228: 8660,
              33229: 8704,
              33230: 8707,
              33242: 8736,
              33243: 8869,
              33244: 8978,
              33245: 8706,
              33246: 8711,
              33247: 8801,
              33248: 8786,
              33249: 8810,
              33250: 8811,
              33251: 8730,
              33252: 8765,
              33253: 8733,
              33254: 8757,
              33255: 8747,
              33256: 8748,
              33264: 8491,
              33265: 8240,
              33266: 9839,
              33267: 9837,
              33268: 9834,
              33269: 8224,
              33270: 8225,
              33271: 182,
              33276: 9711,
              33359: 65296,
              33360: 65297,
              33361: 65298,
              33362: 65299,
              33363: 65300,
              33364: 65301,
              33365: 65302,
              33366: 65303,
              33367: 65304,
              33368: 65305,
              33376: 65313,
              33377: 65314,
              33378: 65315,
              33379: 65316,
              33380: 65317,
              33381: 65318,
              33382: 65319,
              33383: 65320,
              33384: 65321,
              33385: 65322,
              33386: 65323,
              33387: 65324,
              33388: 65325,
              33389: 65326,
              33390: 65327,
              33391: 65328,
              33392: 65329,
              33393: 65330,
              33394: 65331,
              33395: 65332,
              33396: 65333,
              33397: 65334,
              33398: 65335,
              33399: 65336,
              33400: 65337,
              33401: 65338,
              33409: 65345,
              33410: 65346,
              33411: 65347,
              33412: 65348,
              33413: 65349,
              33414: 65350,
              33415: 65351,
              33416: 65352,
              33417: 65353,
              33418: 65354,
              33419: 65355,
              33420: 65356,
              33421: 65357,
              33422: 65358,
              33423: 65359,
              33424: 65360,
              33425: 65361,
              33426: 65362,
              33427: 65363,
              33428: 65364,
              33429: 65365,
              33430: 65366,
              33431: 65367,
              33432: 65368,
              33433: 65369,
              33434: 65370,
              33439: 12353,
              33440: 12354,
              33441: 12355,
              33442: 12356,
              33443: 12357,
              33444: 12358,
              33445: 12359,
              33446: 12360,
              33447: 12361,
              33448: 12362,
              33449: 12363,
              33450: 12364,
              33451: 12365,
              33452: 12366,
              33453: 12367,
              33454: 12368,
              33455: 12369,
              33456: 12370,
              33457: 12371,
              33458: 12372,
              33459: 12373,
              33460: 12374,
              33461: 12375,
              33462: 12376,
              33463: 12377,
              33464: 12378,
              33465: 12379,
              33466: 12380,
              33467: 12381,
              33468: 12382,
              33469: 12383,
              33470: 12384,
              33471: 12385,
              33472: 12386,
              33473: 12387,
              33474: 12388,
              33475: 12389,
              33476: 12390,
              33477: 12391,
              33478: 12392,
              33479: 12393,
              33480: 12394,
              33481: 12395,
              33482: 12396,
              33483: 12397,
              33484: 12398,
              33485: 12399,
              33486: 12400,
              33487: 12401,
              33488: 12402,
              33489: 12403,
              33490: 12404,
              33491: 12405,
              33492: 12406,
              33493: 12407,
              33494: 12408,
              33495: 12409,
              33496: 12410,
              33497: 12411,
              33498: 12412,
              33499: 12413,
              33500: 12414,
              33501: 12415,
              33502: 12416,
              33503: 12417,
              33504: 12418,
              33505: 12419,
              33506: 12420,
              33507: 12421,
              33508: 12422,
              33509: 12423,
              33510: 12424,
              33511: 12425,
              33512: 12426,
              33513: 12427,
              33514: 12428,
              33515: 12429,
              33516: 12430,
              33517: 12431,
              33518: 12432,
              33519: 12433,
              33520: 12434,
              33521: 12435,
              33600: 12449,
              33601: 12450,
              33602: 12451,
              33603: 12452,
              33604: 12453,
              33605: 12454,
              33606: 12455,
              33607: 12456,
              33608: 12457,
              33609: 12458,
              33610: 12459,
              33611: 12460,
              33612: 12461,
              33613: 12462,
              33614: 12463,
              33615: 12464,
              33616: 12465,
              33617: 12466,
              33618: 12467,
              33619: 12468,
              33620: 12469,
              33621: 12470,
              33622: 12471,
              33623: 12472,
              33624: 12473,
              33625: 12474,
              33626: 12475,
              33627: 12476,
              33628: 12477,
              33629: 12478,
              33630: 12479,
              33631: 12480,
              33632: 12481,
              33633: 12482,
              33634: 12483,
              33635: 12484,
              33636: 12485,
              33637: 12486,
              33638: 12487,
              33639: 12488,
              33640: 12489,
              33641: 12490,
              33642: 12491,
              33643: 12492,
              33644: 12493,
              33645: 12494,
              33646: 12495,
              33647: 12496,
              33648: 12497,
              33649: 12498,
              33650: 12499,
              33651: 12500,
              33652: 12501,
              33653: 12502,
              33654: 12503,
              33655: 12504,
              33656: 12505,
              33657: 12506,
              33658: 12507,
              33659: 12508,
              33660: 12509,
              33661: 12510,
              33662: 12511,
              33664: 12512,
              33665: 12513,
              33666: 12514,
              33667: 12515,
              33668: 12516,
              33669: 12517,
              33670: 12518,
              33671: 12519,
              33672: 12520,
              33673: 12521,
              33674: 12522,
              33675: 12523,
              33676: 12524,
              33677: 12525,
              33678: 12526,
              33679: 12527,
              33680: 12528,
              33681: 12529,
              33682: 12530,
              33683: 12531,
              33684: 12532,
              33685: 12533,
              33686: 12534,
              33695: 913,
              33696: 914,
              33697: 915,
              33698: 916,
              33699: 917,
              33700: 918,
              33701: 919,
              33702: 920,
              33703: 921,
              33704: 922,
              33705: 923,
              33706: 924,
              33707: 925,
              33708: 926,
              33709: 927,
              33710: 928,
              33711: 929,
              33712: 931,
              33713: 932,
              33714: 933,
              33715: 934,
              33716: 935,
              33717: 936,
              33718: 937,
              33727: 945,
              33728: 946,
              33729: 947,
              33730: 948,
              33731: 949,
              33732: 950,
              33733: 951,
              33734: 952,
              33735: 953,
              33736: 954,
              33737: 955,
              33738: 956,
              33739: 957,
              33740: 958,
              33741: 959,
              33742: 960,
              33743: 961,
              33744: 963,
              33745: 964,
              33746: 965,
              33747: 966,
              33748: 967,
              33749: 968,
              33750: 969,
              33856: 1040,
              33857: 1041,
              33858: 1042,
              33859: 1043,
              33860: 1044,
              33861: 1045,
              33862: 1025,
              33863: 1046,
              33864: 1047,
              33865: 1048,
              33866: 1049,
              33867: 1050,
              33868: 1051,
              33869: 1052,
              33870: 1053,
              33871: 1054,
              33872: 1055,
              33873: 1056,
              33874: 1057,
              33875: 1058,
              33876: 1059,
              33877: 1060,
              33878: 1061,
              33879: 1062,
              33880: 1063,
              33881: 1064,
              33882: 1065,
              33883: 1066,
              33884: 1067,
              33885: 1068,
              33886: 1069,
              33887: 1070,
              33888: 1071,
              33904: 1072,
              33905: 1073,
              33906: 1074,
              33907: 1075,
              33908: 1076,
              33909: 1077,
              33910: 1105,
              33911: 1078,
              33912: 1079,
              33913: 1080,
              33914: 1081,
              33915: 1082,
              33916: 1083,
              33917: 1084,
              33918: 1085,
              33920: 1086,
              33921: 1087,
              33922: 1088,
              33923: 1089,
              33924: 1090,
              33925: 1091,
              33926: 1092,
              33927: 1093,
              33928: 1094,
              33929: 1095,
              33930: 1096,
              33931: 1097,
              33932: 1098,
              33933: 1099,
              33934: 1100,
              33935: 1101,
              33936: 1102,
              33937: 1103,
              33951: 9472,
              33952: 9474,
              33953: 9484,
              33954: 9488,
              33955: 9496,
              33956: 9492,
              33957: 9500,
              33958: 9516,
              33959: 9508,
              33960: 9524,
              33961: 9532,
              33962: 9473,
              33963: 9475,
              33964: 9487,
              33965: 9491,
              33966: 9499,
              33967: 9495,
              33968: 9507,
              33969: 9523,
              33970: 9515,
              33971: 9531,
              33972: 9547,
              33973: 9504,
              33974: 9519,
              33975: 9512,
              33976: 9527,
              33977: 9535,
              33978: 9501,
              33979: 9520,
              33980: 9509,
              33981: 9528,
              33982: 9538,
              34975: 20124,
              34976: 21782,
              34977: 23043,
              34978: 38463,
              34979: 21696,
              34980: 24859,
              34981: 25384,
              34982: 23030,
              34983: 36898,
              34984: 33909,
              34985: 33564,
              34986: 31312,
              34987: 24746,
              34988: 25569,
              34989: 28197,
              34990: 26093,
              34991: 33894,
              34992: 33446,
              34993: 39925,
              34994: 26771,
              34995: 22311,
              34996: 26017,
              34997: 25201,
              34998: 23451,
              34999: 22992,
              35e3: 34427,
              35001: 39156,
              35002: 32098,
              35003: 32190,
              35004: 39822,
              35005: 25110,
              35006: 31903,
              35007: 34999,
              35008: 23433,
              35009: 24245,
              35010: 25353,
              35011: 26263,
              35012: 26696,
              35013: 38343,
              35014: 38797,
              35015: 26447,
              35016: 20197,
              35017: 20234,
              35018: 20301,
              35019: 20381,
              35020: 20553,
              35021: 22258,
              35022: 22839,
              35023: 22996,
              35024: 23041,
              35025: 23561,
              35026: 24799,
              35027: 24847,
              35028: 24944,
              35029: 26131,
              35030: 26885,
              35031: 28858,
              35032: 30031,
              35033: 30064,
              35034: 31227,
              35035: 32173,
              35036: 32239,
              35037: 32963,
              35038: 33806,
              35039: 34915,
              35040: 35586,
              35041: 36949,
              35042: 36986,
              35043: 21307,
              35044: 20117,
              35045: 20133,
              35046: 22495,
              35047: 32946,
              35048: 37057,
              35049: 30959,
              35050: 19968,
              35051: 22769,
              35052: 28322,
              35053: 36920,
              35054: 31282,
              35055: 33576,
              35056: 33419,
              35057: 39983,
              35058: 20801,
              35059: 21360,
              35060: 21693,
              35061: 21729,
              35062: 22240,
              35063: 23035,
              35064: 24341,
              35065: 39154,
              35066: 28139,
              35067: 32996,
              35068: 34093,
              35136: 38498,
              35137: 38512,
              35138: 38560,
              35139: 38907,
              35140: 21515,
              35141: 21491,
              35142: 23431,
              35143: 28879,
              35144: 32701,
              35145: 36802,
              35146: 38632,
              35147: 21359,
              35148: 40284,
              35149: 31418,
              35150: 19985,
              35151: 30867,
              35152: 33276,
              35153: 28198,
              35154: 22040,
              35155: 21764,
              35156: 27421,
              35157: 34074,
              35158: 39995,
              35159: 23013,
              35160: 21417,
              35161: 28006,
              35162: 29916,
              35163: 38287,
              35164: 22082,
              35165: 20113,
              35166: 36939,
              35167: 38642,
              35168: 33615,
              35169: 39180,
              35170: 21473,
              35171: 21942,
              35172: 23344,
              35173: 24433,
              35174: 26144,
              35175: 26355,
              35176: 26628,
              35177: 27704,
              35178: 27891,
              35179: 27945,
              35180: 29787,
              35181: 30408,
              35182: 31310,
              35183: 38964,
              35184: 33521,
              35185: 34907,
              35186: 35424,
              35187: 37613,
              35188: 28082,
              35189: 30123,
              35190: 30410,
              35191: 39365,
              35192: 24742,
              35193: 35585,
              35194: 36234,
              35195: 38322,
              35196: 27022,
              35197: 21421,
              35198: 20870,
              35200: 22290,
              35201: 22576,
              35202: 22852,
              35203: 23476,
              35204: 24310,
              35205: 24616,
              35206: 25513,
              35207: 25588,
              35208: 27839,
              35209: 28436,
              35210: 28814,
              35211: 28948,
              35212: 29017,
              35213: 29141,
              35214: 29503,
              35215: 32257,
              35216: 33398,
              35217: 33489,
              35218: 34199,
              35219: 36960,
              35220: 37467,
              35221: 40219,
              35222: 22633,
              35223: 26044,
              35224: 27738,
              35225: 29989,
              35226: 20985,
              35227: 22830,
              35228: 22885,
              35229: 24448,
              35230: 24540,
              35231: 25276,
              35232: 26106,
              35233: 27178,
              35234: 27431,
              35235: 27572,
              35236: 29579,
              35237: 32705,
              35238: 35158,
              35239: 40236,
              35240: 40206,
              35241: 40644,
              35242: 23713,
              35243: 27798,
              35244: 33659,
              35245: 20740,
              35246: 23627,
              35247: 25014,
              35248: 33222,
              35249: 26742,
              35250: 29281,
              35251: 20057,
              35252: 20474,
              35253: 21368,
              35254: 24681,
              35255: 28201,
              35256: 31311,
              35257: 38899,
              35258: 19979,
              35259: 21270,
              35260: 20206,
              35261: 20309,
              35262: 20285,
              35263: 20385,
              35264: 20339,
              35265: 21152,
              35266: 21487,
              35267: 22025,
              35268: 22799,
              35269: 23233,
              35270: 23478,
              35271: 23521,
              35272: 31185,
              35273: 26247,
              35274: 26524,
              35275: 26550,
              35276: 27468,
              35277: 27827,
              35278: 28779,
              35279: 29634,
              35280: 31117,
              35281: 31166,
              35282: 31292,
              35283: 31623,
              35284: 33457,
              35285: 33499,
              35286: 33540,
              35287: 33655,
              35288: 33775,
              35289: 33747,
              35290: 34662,
              35291: 35506,
              35292: 22057,
              35293: 36008,
              35294: 36838,
              35295: 36942,
              35296: 38686,
              35297: 34442,
              35298: 20420,
              35299: 23784,
              35300: 25105,
              35301: 29273,
              35302: 30011,
              35303: 33253,
              35304: 33469,
              35305: 34558,
              35306: 36032,
              35307: 38597,
              35308: 39187,
              35309: 39381,
              35310: 20171,
              35311: 20250,
              35312: 35299,
              35313: 22238,
              35314: 22602,
              35315: 22730,
              35316: 24315,
              35317: 24555,
              35318: 24618,
              35319: 24724,
              35320: 24674,
              35321: 25040,
              35322: 25106,
              35323: 25296,
              35324: 25913,
              35392: 39745,
              35393: 26214,
              35394: 26800,
              35395: 28023,
              35396: 28784,
              35397: 30028,
              35398: 30342,
              35399: 32117,
              35400: 33445,
              35401: 34809,
              35402: 38283,
              35403: 38542,
              35404: 35997,
              35405: 20977,
              35406: 21182,
              35407: 22806,
              35408: 21683,
              35409: 23475,
              35410: 23830,
              35411: 24936,
              35412: 27010,
              35413: 28079,
              35414: 30861,
              35415: 33995,
              35416: 34903,
              35417: 35442,
              35418: 37799,
              35419: 39608,
              35420: 28012,
              35421: 39336,
              35422: 34521,
              35423: 22435,
              35424: 26623,
              35425: 34510,
              35426: 37390,
              35427: 21123,
              35428: 22151,
              35429: 21508,
              35430: 24275,
              35431: 25313,
              35432: 25785,
              35433: 26684,
              35434: 26680,
              35435: 27579,
              35436: 29554,
              35437: 30906,
              35438: 31339,
              35439: 35226,
              35440: 35282,
              35441: 36203,
              35442: 36611,
              35443: 37101,
              35444: 38307,
              35445: 38548,
              35446: 38761,
              35447: 23398,
              35448: 23731,
              35449: 27005,
              35450: 38989,
              35451: 38990,
              35452: 25499,
              35453: 31520,
              35454: 27179,
              35456: 27263,
              35457: 26806,
              35458: 39949,
              35459: 28511,
              35460: 21106,
              35461: 21917,
              35462: 24688,
              35463: 25324,
              35464: 27963,
              35465: 28167,
              35466: 28369,
              35467: 33883,
              35468: 35088,
              35469: 36676,
              35470: 19988,
              35471: 39993,
              35472: 21494,
              35473: 26907,
              35474: 27194,
              35475: 38788,
              35476: 26666,
              35477: 20828,
              35478: 31427,
              35479: 33970,
              35480: 37340,
              35481: 37772,
              35482: 22107,
              35483: 40232,
              35484: 26658,
              35485: 33541,
              35486: 33841,
              35487: 31909,
              35488: 21e3,
              35489: 33477,
              35490: 29926,
              35491: 20094,
              35492: 20355,
              35493: 20896,
              35494: 23506,
              35495: 21002,
              35496: 21208,
              35497: 21223,
              35498: 24059,
              35499: 21914,
              35500: 22570,
              35501: 23014,
              35502: 23436,
              35503: 23448,
              35504: 23515,
              35505: 24178,
              35506: 24185,
              35507: 24739,
              35508: 24863,
              35509: 24931,
              35510: 25022,
              35511: 25563,
              35512: 25954,
              35513: 26577,
              35514: 26707,
              35515: 26874,
              35516: 27454,
              35517: 27475,
              35518: 27735,
              35519: 28450,
              35520: 28567,
              35521: 28485,
              35522: 29872,
              35523: 29976,
              35524: 30435,
              35525: 30475,
              35526: 31487,
              35527: 31649,
              35528: 31777,
              35529: 32233,
              35530: 32566,
              35531: 32752,
              35532: 32925,
              35533: 33382,
              35534: 33694,
              35535: 35251,
              35536: 35532,
              35537: 36011,
              35538: 36996,
              35539: 37969,
              35540: 38291,
              35541: 38289,
              35542: 38306,
              35543: 38501,
              35544: 38867,
              35545: 39208,
              35546: 33304,
              35547: 20024,
              35548: 21547,
              35549: 23736,
              35550: 24012,
              35551: 29609,
              35552: 30284,
              35553: 30524,
              35554: 23721,
              35555: 32747,
              35556: 36107,
              35557: 38593,
              35558: 38929,
              35559: 38996,
              35560: 39e3,
              35561: 20225,
              35562: 20238,
              35563: 21361,
              35564: 21916,
              35565: 22120,
              35566: 22522,
              35567: 22855,
              35568: 23305,
              35569: 23492,
              35570: 23696,
              35571: 24076,
              35572: 24190,
              35573: 24524,
              35574: 25582,
              35575: 26426,
              35576: 26071,
              35577: 26082,
              35578: 26399,
              35579: 26827,
              35580: 26820,
              35648: 27231,
              35649: 24112,
              35650: 27589,
              35651: 27671,
              35652: 27773,
              35653: 30079,
              35654: 31048,
              35655: 23395,
              35656: 31232,
              35657: 32e3,
              35658: 24509,
              35659: 35215,
              35660: 35352,
              35661: 36020,
              35662: 36215,
              35663: 36556,
              35664: 36637,
              35665: 39138,
              35666: 39438,
              35667: 39740,
              35668: 20096,
              35669: 20605,
              35670: 20736,
              35671: 22931,
              35672: 23452,
              35673: 25135,
              35674: 25216,
              35675: 25836,
              35676: 27450,
              35677: 29344,
              35678: 30097,
              35679: 31047,
              35680: 32681,
              35681: 34811,
              35682: 35516,
              35683: 35696,
              35684: 25516,
              35685: 33738,
              35686: 38816,
              35687: 21513,
              35688: 21507,
              35689: 21931,
              35690: 26708,
              35691: 27224,
              35692: 35440,
              35693: 30759,
              35694: 26485,
              35695: 40653,
              35696: 21364,
              35697: 23458,
              35698: 33050,
              35699: 34384,
              35700: 36870,
              35701: 19992,
              35702: 20037,
              35703: 20167,
              35704: 20241,
              35705: 21450,
              35706: 21560,
              35707: 23470,
              35708: 24339,
              35709: 24613,
              35710: 25937,
              35712: 26429,
              35713: 27714,
              35714: 27762,
              35715: 27875,
              35716: 28792,
              35717: 29699,
              35718: 31350,
              35719: 31406,
              35720: 31496,
              35721: 32026,
              35722: 31998,
              35723: 32102,
              35724: 26087,
              35725: 29275,
              35726: 21435,
              35727: 23621,
              35728: 24040,
              35729: 25298,
              35730: 25312,
              35731: 25369,
              35732: 28192,
              35733: 34394,
              35734: 35377,
              35735: 36317,
              35736: 37624,
              35737: 28417,
              35738: 31142,
              35739: 39770,
              35740: 20136,
              35741: 20139,
              35742: 20140,
              35743: 20379,
              35744: 20384,
              35745: 20689,
              35746: 20807,
              35747: 31478,
              35748: 20849,
              35749: 20982,
              35750: 21332,
              35751: 21281,
              35752: 21375,
              35753: 21483,
              35754: 21932,
              35755: 22659,
              35756: 23777,
              35757: 24375,
              35758: 24394,
              35759: 24623,
              35760: 24656,
              35761: 24685,
              35762: 25375,
              35763: 25945,
              35764: 27211,
              35765: 27841,
              35766: 29378,
              35767: 29421,
              35768: 30703,
              35769: 33016,
              35770: 33029,
              35771: 33288,
              35772: 34126,
              35773: 37111,
              35774: 37857,
              35775: 38911,
              35776: 39255,
              35777: 39514,
              35778: 20208,
              35779: 20957,
              35780: 23597,
              35781: 26241,
              35782: 26989,
              35783: 23616,
              35784: 26354,
              35785: 26997,
              35786: 29577,
              35787: 26704,
              35788: 31873,
              35789: 20677,
              35790: 21220,
              35791: 22343,
              35792: 24062,
              35793: 37670,
              35794: 26020,
              35795: 27427,
              35796: 27453,
              35797: 29748,
              35798: 31105,
              35799: 31165,
              35800: 31563,
              35801: 32202,
              35802: 33465,
              35803: 33740,
              35804: 34943,
              35805: 35167,
              35806: 35641,
              35807: 36817,
              35808: 37329,
              35809: 21535,
              35810: 37504,
              35811: 20061,
              35812: 20534,
              35813: 21477,
              35814: 21306,
              35815: 29399,
              35816: 29590,
              35817: 30697,
              35818: 33510,
              35819: 36527,
              35820: 39366,
              35821: 39368,
              35822: 39378,
              35823: 20855,
              35824: 24858,
              35825: 34398,
              35826: 21936,
              35827: 31354,
              35828: 20598,
              35829: 23507,
              35830: 36935,
              35831: 38533,
              35832: 20018,
              35833: 27355,
              35834: 37351,
              35835: 23633,
              35836: 23624,
              35904: 25496,
              35905: 31391,
              35906: 27795,
              35907: 38772,
              35908: 36705,
              35909: 31402,
              35910: 29066,
              35911: 38536,
              35912: 31874,
              35913: 26647,
              35914: 32368,
              35915: 26705,
              35916: 37740,
              35917: 21234,
              35918: 21531,
              35919: 34219,
              35920: 35347,
              35921: 32676,
              35922: 36557,
              35923: 37089,
              35924: 21350,
              35925: 34952,
              35926: 31041,
              35927: 20418,
              35928: 20670,
              35929: 21009,
              35930: 20804,
              35931: 21843,
              35932: 22317,
              35933: 29674,
              35934: 22411,
              35935: 22865,
              35936: 24418,
              35937: 24452,
              35938: 24693,
              35939: 24950,
              35940: 24935,
              35941: 25001,
              35942: 25522,
              35943: 25658,
              35944: 25964,
              35945: 26223,
              35946: 26690,
              35947: 28179,
              35948: 30054,
              35949: 31293,
              35950: 31995,
              35951: 32076,
              35952: 32153,
              35953: 32331,
              35954: 32619,
              35955: 33550,
              35956: 33610,
              35957: 34509,
              35958: 35336,
              35959: 35427,
              35960: 35686,
              35961: 36605,
              35962: 38938,
              35963: 40335,
              35964: 33464,
              35965: 36814,
              35966: 39912,
              35968: 21127,
              35969: 25119,
              35970: 25731,
              35971: 28608,
              35972: 38553,
              35973: 26689,
              35974: 20625,
              35975: 27424,
              35976: 27770,
              35977: 28500,
              35978: 31348,
              35979: 32080,
              35980: 34880,
              35981: 35363,
              35982: 26376,
              35983: 20214,
              35984: 20537,
              35985: 20518,
              35986: 20581,
              35987: 20860,
              35988: 21048,
              35989: 21091,
              35990: 21927,
              35991: 22287,
              35992: 22533,
              35993: 23244,
              35994: 24314,
              35995: 25010,
              35996: 25080,
              35997: 25331,
              35998: 25458,
              35999: 26908,
              36e3: 27177,
              36001: 29309,
              36002: 29356,
              36003: 29486,
              36004: 30740,
              36005: 30831,
              36006: 32121,
              36007: 30476,
              36008: 32937,
              36009: 35211,
              36010: 35609,
              36011: 36066,
              36012: 36562,
              36013: 36963,
              36014: 37749,
              36015: 38522,
              36016: 38997,
              36017: 39443,
              36018: 40568,
              36019: 20803,
              36020: 21407,
              36021: 21427,
              36022: 24187,
              36023: 24358,
              36024: 28187,
              36025: 28304,
              36026: 29572,
              36027: 29694,
              36028: 32067,
              36029: 33335,
              36030: 35328,
              36031: 35578,
              36032: 38480,
              36033: 20046,
              36034: 20491,
              36035: 21476,
              36036: 21628,
              36037: 22266,
              36038: 22993,
              36039: 23396,
              36040: 24049,
              36041: 24235,
              36042: 24359,
              36043: 25144,
              36044: 25925,
              36045: 26543,
              36046: 28246,
              36047: 29392,
              36048: 31946,
              36049: 34996,
              36050: 32929,
              36051: 32993,
              36052: 33776,
              36053: 34382,
              36054: 35463,
              36055: 36328,
              36056: 37431,
              36057: 38599,
              36058: 39015,
              36059: 40723,
              36060: 20116,
              36061: 20114,
              36062: 20237,
              36063: 21320,
              36064: 21577,
              36065: 21566,
              36066: 23087,
              36067: 24460,
              36068: 24481,
              36069: 24735,
              36070: 26791,
              36071: 27278,
              36072: 29786,
              36073: 30849,
              36074: 35486,
              36075: 35492,
              36076: 35703,
              36077: 37264,
              36078: 20062,
              36079: 39881,
              36080: 20132,
              36081: 20348,
              36082: 20399,
              36083: 20505,
              36084: 20502,
              36085: 20809,
              36086: 20844,
              36087: 21151,
              36088: 21177,
              36089: 21246,
              36090: 21402,
              36091: 21475,
              36092: 21521,
              36160: 21518,
              36161: 21897,
              36162: 22353,
              36163: 22434,
              36164: 22909,
              36165: 23380,
              36166: 23389,
              36167: 23439,
              36168: 24037,
              36169: 24039,
              36170: 24055,
              36171: 24184,
              36172: 24195,
              36173: 24218,
              36174: 24247,
              36175: 24344,
              36176: 24658,
              36177: 24908,
              36178: 25239,
              36179: 25304,
              36180: 25511,
              36181: 25915,
              36182: 26114,
              36183: 26179,
              36184: 26356,
              36185: 26477,
              36186: 26657,
              36187: 26775,
              36188: 27083,
              36189: 27743,
              36190: 27946,
              36191: 28009,
              36192: 28207,
              36193: 28317,
              36194: 30002,
              36195: 30343,
              36196: 30828,
              36197: 31295,
              36198: 31968,
              36199: 32005,
              36200: 32024,
              36201: 32094,
              36202: 32177,
              36203: 32789,
              36204: 32771,
              36205: 32943,
              36206: 32945,
              36207: 33108,
              36208: 33167,
              36209: 33322,
              36210: 33618,
              36211: 34892,
              36212: 34913,
              36213: 35611,
              36214: 36002,
              36215: 36092,
              36216: 37066,
              36217: 37237,
              36218: 37489,
              36219: 30783,
              36220: 37628,
              36221: 38308,
              36222: 38477,
              36224: 38917,
              36225: 39321,
              36226: 39640,
              36227: 40251,
              36228: 21083,
              36229: 21163,
              36230: 21495,
              36231: 21512,
              36232: 22741,
              36233: 25335,
              36234: 28640,
              36235: 35946,
              36236: 36703,
              36237: 40633,
              36238: 20811,
              36239: 21051,
              36240: 21578,
              36241: 22269,
              36242: 31296,
              36243: 37239,
              36244: 40288,
              36245: 40658,
              36246: 29508,
              36247: 28425,
              36248: 33136,
              36249: 29969,
              36250: 24573,
              36251: 24794,
              36252: 39592,
              36253: 29403,
              36254: 36796,
              36255: 27492,
              36256: 38915,
              36257: 20170,
              36258: 22256,
              36259: 22372,
              36260: 22718,
              36261: 23130,
              36262: 24680,
              36263: 25031,
              36264: 26127,
              36265: 26118,
              36266: 26681,
              36267: 26801,
              36268: 28151,
              36269: 30165,
              36270: 32058,
              36271: 33390,
              36272: 39746,
              36273: 20123,
              36274: 20304,
              36275: 21449,
              36276: 21766,
              36277: 23919,
              36278: 24038,
              36279: 24046,
              36280: 26619,
              36281: 27801,
              36282: 29811,
              36283: 30722,
              36284: 35408,
              36285: 37782,
              36286: 35039,
              36287: 22352,
              36288: 24231,
              36289: 25387,
              36290: 20661,
              36291: 20652,
              36292: 20877,
              36293: 26368,
              36294: 21705,
              36295: 22622,
              36296: 22971,
              36297: 23472,
              36298: 24425,
              36299: 25165,
              36300: 25505,
              36301: 26685,
              36302: 27507,
              36303: 28168,
              36304: 28797,
              36305: 37319,
              36306: 29312,
              36307: 30741,
              36308: 30758,
              36309: 31085,
              36310: 25998,
              36311: 32048,
              36312: 33756,
              36313: 35009,
              36314: 36617,
              36315: 38555,
              36316: 21092,
              36317: 22312,
              36318: 26448,
              36319: 32618,
              36320: 36001,
              36321: 20916,
              36322: 22338,
              36323: 38442,
              36324: 22586,
              36325: 27018,
              36326: 32948,
              36327: 21682,
              36328: 23822,
              36329: 22524,
              36330: 30869,
              36331: 40442,
              36332: 20316,
              36333: 21066,
              36334: 21643,
              36335: 25662,
              36336: 26152,
              36337: 26388,
              36338: 26613,
              36339: 31364,
              36340: 31574,
              36341: 32034,
              36342: 37679,
              36343: 26716,
              36344: 39853,
              36345: 31545,
              36346: 21273,
              36347: 20874,
              36348: 21047,
              36416: 23519,
              36417: 25334,
              36418: 25774,
              36419: 25830,
              36420: 26413,
              36421: 27578,
              36422: 34217,
              36423: 38609,
              36424: 30352,
              36425: 39894,
              36426: 25420,
              36427: 37638,
              36428: 39851,
              36429: 30399,
              36430: 26194,
              36431: 19977,
              36432: 20632,
              36433: 21442,
              36434: 23665,
              36435: 24808,
              36436: 25746,
              36437: 25955,
              36438: 26719,
              36439: 29158,
              36440: 29642,
              36441: 29987,
              36442: 31639,
              36443: 32386,
              36444: 34453,
              36445: 35715,
              36446: 36059,
              36447: 37240,
              36448: 39184,
              36449: 26028,
              36450: 26283,
              36451: 27531,
              36452: 20181,
              36453: 20180,
              36454: 20282,
              36455: 20351,
              36456: 21050,
              36457: 21496,
              36458: 21490,
              36459: 21987,
              36460: 22235,
              36461: 22763,
              36462: 22987,
              36463: 22985,
              36464: 23039,
              36465: 23376,
              36466: 23629,
              36467: 24066,
              36468: 24107,
              36469: 24535,
              36470: 24605,
              36471: 25351,
              36472: 25903,
              36473: 23388,
              36474: 26031,
              36475: 26045,
              36476: 26088,
              36477: 26525,
              36478: 27490,
              36480: 27515,
              36481: 27663,
              36482: 29509,
              36483: 31049,
              36484: 31169,
              36485: 31992,
              36486: 32025,
              36487: 32043,
              36488: 32930,
              36489: 33026,
              36490: 33267,
              36491: 35222,
              36492: 35422,
              36493: 35433,
              36494: 35430,
              36495: 35468,
              36496: 35566,
              36497: 36039,
              36498: 36060,
              36499: 38604,
              36500: 39164,
              36501: 27503,
              36502: 20107,
              36503: 20284,
              36504: 20365,
              36505: 20816,
              36506: 23383,
              36507: 23546,
              36508: 24904,
              36509: 25345,
              36510: 26178,
              36511: 27425,
              36512: 28363,
              36513: 27835,
              36514: 29246,
              36515: 29885,
              36516: 30164,
              36517: 30913,
              36518: 31034,
              36519: 32780,
              36520: 32819,
              36521: 33258,
              36522: 33940,
              36523: 36766,
              36524: 27728,
              36525: 40575,
              36526: 24335,
              36527: 35672,
              36528: 40235,
              36529: 31482,
              36530: 36600,
              36531: 23437,
              36532: 38635,
              36533: 19971,
              36534: 21489,
              36535: 22519,
              36536: 22833,
              36537: 23241,
              36538: 23460,
              36539: 24713,
              36540: 28287,
              36541: 28422,
              36542: 30142,
              36543: 36074,
              36544: 23455,
              36545: 34048,
              36546: 31712,
              36547: 20594,
              36548: 26612,
              36549: 33437,
              36550: 23649,
              36551: 34122,
              36552: 32286,
              36553: 33294,
              36554: 20889,
              36555: 23556,
              36556: 25448,
              36557: 36198,
              36558: 26012,
              36559: 29038,
              36560: 31038,
              36561: 32023,
              36562: 32773,
              36563: 35613,
              36564: 36554,
              36565: 36974,
              36566: 34503,
              36567: 37034,
              36568: 20511,
              36569: 21242,
              36570: 23610,
              36571: 26451,
              36572: 28796,
              36573: 29237,
              36574: 37196,
              36575: 37320,
              36576: 37675,
              36577: 33509,
              36578: 23490,
              36579: 24369,
              36580: 24825,
              36581: 20027,
              36582: 21462,
              36583: 23432,
              36584: 25163,
              36585: 26417,
              36586: 27530,
              36587: 29417,
              36588: 29664,
              36589: 31278,
              36590: 33131,
              36591: 36259,
              36592: 37202,
              36593: 39318,
              36594: 20754,
              36595: 21463,
              36596: 21610,
              36597: 23551,
              36598: 25480,
              36599: 27193,
              36600: 32172,
              36601: 38656,
              36602: 22234,
              36603: 21454,
              36604: 21608,
              36672: 23447,
              36673: 23601,
              36674: 24030,
              36675: 20462,
              36676: 24833,
              36677: 25342,
              36678: 27954,
              36679: 31168,
              36680: 31179,
              36681: 32066,
              36682: 32333,
              36683: 32722,
              36684: 33261,
              36685: 33311,
              36686: 33936,
              36687: 34886,
              36688: 35186,
              36689: 35728,
              36690: 36468,
              36691: 36655,
              36692: 36913,
              36693: 37195,
              36694: 37228,
              36695: 38598,
              36696: 37276,
              36697: 20160,
              36698: 20303,
              36699: 20805,
              36700: 21313,
              36701: 24467,
              36702: 25102,
              36703: 26580,
              36704: 27713,
              36705: 28171,
              36706: 29539,
              36707: 32294,
              36708: 37325,
              36709: 37507,
              36710: 21460,
              36711: 22809,
              36712: 23487,
              36713: 28113,
              36714: 31069,
              36715: 32302,
              36716: 31899,
              36717: 22654,
              36718: 29087,
              36719: 20986,
              36720: 34899,
              36721: 36848,
              36722: 20426,
              36723: 23803,
              36724: 26149,
              36725: 30636,
              36726: 31459,
              36727: 33308,
              36728: 39423,
              36729: 20934,
              36730: 24490,
              36731: 26092,
              36732: 26991,
              36733: 27529,
              36734: 28147,
              36736: 28310,
              36737: 28516,
              36738: 30462,
              36739: 32020,
              36740: 24033,
              36741: 36981,
              36742: 37255,
              36743: 38918,
              36744: 20966,
              36745: 21021,
              36746: 25152,
              36747: 26257,
              36748: 26329,
              36749: 28186,
              36750: 24246,
              36751: 32210,
              36752: 32626,
              36753: 26360,
              36754: 34223,
              36755: 34295,
              36756: 35576,
              36757: 21161,
              36758: 21465,
              36759: 22899,
              36760: 24207,
              36761: 24464,
              36762: 24661,
              36763: 37604,
              36764: 38500,
              36765: 20663,
              36766: 20767,
              36767: 21213,
              36768: 21280,
              36769: 21319,
              36770: 21484,
              36771: 21736,
              36772: 21830,
              36773: 21809,
              36774: 22039,
              36775: 22888,
              36776: 22974,
              36777: 23100,
              36778: 23477,
              36779: 23558,
              36780: 23567,
              36781: 23569,
              36782: 23578,
              36783: 24196,
              36784: 24202,
              36785: 24288,
              36786: 24432,
              36787: 25215,
              36788: 25220,
              36789: 25307,
              36790: 25484,
              36791: 25463,
              36792: 26119,
              36793: 26124,
              36794: 26157,
              36795: 26230,
              36796: 26494,
              36797: 26786,
              36798: 27167,
              36799: 27189,
              36800: 27836,
              36801: 28040,
              36802: 28169,
              36803: 28248,
              36804: 28988,
              36805: 28966,
              36806: 29031,
              36807: 30151,
              36808: 30465,
              36809: 30813,
              36810: 30977,
              36811: 31077,
              36812: 31216,
              36813: 31456,
              36814: 31505,
              36815: 31911,
              36816: 32057,
              36817: 32918,
              36818: 33750,
              36819: 33931,
              36820: 34121,
              36821: 34909,
              36822: 35059,
              36823: 35359,
              36824: 35388,
              36825: 35412,
              36826: 35443,
              36827: 35937,
              36828: 36062,
              36829: 37284,
              36830: 37478,
              36831: 37758,
              36832: 37912,
              36833: 38556,
              36834: 38808,
              36835: 19978,
              36836: 19976,
              36837: 19998,
              36838: 20055,
              36839: 20887,
              36840: 21104,
              36841: 22478,
              36842: 22580,
              36843: 22732,
              36844: 23330,
              36845: 24120,
              36846: 24773,
              36847: 25854,
              36848: 26465,
              36849: 26454,
              36850: 27972,
              36851: 29366,
              36852: 30067,
              36853: 31331,
              36854: 33976,
              36855: 35698,
              36856: 37304,
              36857: 37664,
              36858: 22065,
              36859: 22516,
              36860: 39166,
              36928: 25325,
              36929: 26893,
              36930: 27542,
              36931: 29165,
              36932: 32340,
              36933: 32887,
              36934: 33394,
              36935: 35302,
              36936: 39135,
              36937: 34645,
              36938: 36785,
              36939: 23611,
              36940: 20280,
              36941: 20449,
              36942: 20405,
              36943: 21767,
              36944: 23072,
              36945: 23517,
              36946: 23529,
              36947: 24515,
              36948: 24910,
              36949: 25391,
              36950: 26032,
              36951: 26187,
              36952: 26862,
              36953: 27035,
              36954: 28024,
              36955: 28145,
              36956: 30003,
              36957: 30137,
              36958: 30495,
              36959: 31070,
              36960: 31206,
              36961: 32051,
              36962: 33251,
              36963: 33455,
              36964: 34218,
              36965: 35242,
              36966: 35386,
              36967: 36523,
              36968: 36763,
              36969: 36914,
              36970: 37341,
              36971: 38663,
              36972: 20154,
              36973: 20161,
              36974: 20995,
              36975: 22645,
              36976: 22764,
              36977: 23563,
              36978: 29978,
              36979: 23613,
              36980: 33102,
              36981: 35338,
              36982: 36805,
              36983: 38499,
              36984: 38765,
              36985: 31525,
              36986: 35535,
              36987: 38920,
              36988: 37218,
              36989: 22259,
              36990: 21416,
              36992: 36887,
              36993: 21561,
              36994: 22402,
              36995: 24101,
              36996: 25512,
              36997: 27700,
              36998: 28810,
              36999: 30561,
              37e3: 31883,
              37001: 32736,
              37002: 34928,
              37003: 36930,
              37004: 37204,
              37005: 37648,
              37006: 37656,
              37007: 38543,
              37008: 29790,
              37009: 39620,
              37010: 23815,
              37011: 23913,
              37012: 25968,
              37013: 26530,
              37014: 36264,
              37015: 38619,
              37016: 25454,
              37017: 26441,
              37018: 26905,
              37019: 33733,
              37020: 38935,
              37021: 38592,
              37022: 35070,
              37023: 28548,
              37024: 25722,
              37025: 23544,
              37026: 19990,
              37027: 28716,
              37028: 30045,
              37029: 26159,
              37030: 20932,
              37031: 21046,
              37032: 21218,
              37033: 22995,
              37034: 24449,
              37035: 24615,
              37036: 25104,
              37037: 25919,
              37038: 25972,
              37039: 26143,
              37040: 26228,
              37041: 26866,
              37042: 26646,
              37043: 27491,
              37044: 28165,
              37045: 29298,
              37046: 29983,
              37047: 30427,
              37048: 31934,
              37049: 32854,
              37050: 22768,
              37051: 35069,
              37052: 35199,
              37053: 35488,
              37054: 35475,
              37055: 35531,
              37056: 36893,
              37057: 37266,
              37058: 38738,
              37059: 38745,
              37060: 25993,
              37061: 31246,
              37062: 33030,
              37063: 38587,
              37064: 24109,
              37065: 24796,
              37066: 25114,
              37067: 26021,
              37068: 26132,
              37069: 26512,
              37070: 30707,
              37071: 31309,
              37072: 31821,
              37073: 32318,
              37074: 33034,
              37075: 36012,
              37076: 36196,
              37077: 36321,
              37078: 36447,
              37079: 30889,
              37080: 20999,
              37081: 25305,
              37082: 25509,
              37083: 25666,
              37084: 25240,
              37085: 35373,
              37086: 31363,
              37087: 31680,
              37088: 35500,
              37089: 38634,
              37090: 32118,
              37091: 33292,
              37092: 34633,
              37093: 20185,
              37094: 20808,
              37095: 21315,
              37096: 21344,
              37097: 23459,
              37098: 23554,
              37099: 23574,
              37100: 24029,
              37101: 25126,
              37102: 25159,
              37103: 25776,
              37104: 26643,
              37105: 26676,
              37106: 27849,
              37107: 27973,
              37108: 27927,
              37109: 26579,
              37110: 28508,
              37111: 29006,
              37112: 29053,
              37113: 26059,
              37114: 31359,
              37115: 31661,
              37116: 32218,
              37184: 32330,
              37185: 32680,
              37186: 33146,
              37187: 33307,
              37188: 33337,
              37189: 34214,
              37190: 35438,
              37191: 36046,
              37192: 36341,
              37193: 36984,
              37194: 36983,
              37195: 37549,
              37196: 37521,
              37197: 38275,
              37198: 39854,
              37199: 21069,
              37200: 21892,
              37201: 28472,
              37202: 28982,
              37203: 20840,
              37204: 31109,
              37205: 32341,
              37206: 33203,
              37207: 31950,
              37208: 22092,
              37209: 22609,
              37210: 23720,
              37211: 25514,
              37212: 26366,
              37213: 26365,
              37214: 26970,
              37215: 29401,
              37216: 30095,
              37217: 30094,
              37218: 30990,
              37219: 31062,
              37220: 31199,
              37221: 31895,
              37222: 32032,
              37223: 32068,
              37224: 34311,
              37225: 35380,
              37226: 38459,
              37227: 36961,
              37228: 40736,
              37229: 20711,
              37230: 21109,
              37231: 21452,
              37232: 21474,
              37233: 20489,
              37234: 21930,
              37235: 22766,
              37236: 22863,
              37237: 29245,
              37238: 23435,
              37239: 23652,
              37240: 21277,
              37241: 24803,
              37242: 24819,
              37243: 25436,
              37244: 25475,
              37245: 25407,
              37246: 25531,
              37248: 25805,
              37249: 26089,
              37250: 26361,
              37251: 24035,
              37252: 27085,
              37253: 27133,
              37254: 28437,
              37255: 29157,
              37256: 20105,
              37257: 30185,
              37258: 30456,
              37259: 31379,
              37260: 31967,
              37261: 32207,
              37262: 32156,
              37263: 32865,
              37264: 33609,
              37265: 33624,
              37266: 33900,
              37267: 33980,
              37268: 34299,
              37269: 35013,
              37270: 36208,
              37271: 36865,
              37272: 36973,
              37273: 37783,
              37274: 38684,
              37275: 39442,
              37276: 20687,
              37277: 22679,
              37278: 24974,
              37279: 33235,
              37280: 34101,
              37281: 36104,
              37282: 36896,
              37283: 20419,
              37284: 20596,
              37285: 21063,
              37286: 21363,
              37287: 24687,
              37288: 25417,
              37289: 26463,
              37290: 28204,
              37291: 36275,
              37292: 36895,
              37293: 20439,
              37294: 23646,
              37295: 36042,
              37296: 26063,
              37297: 32154,
              37298: 21330,
              37299: 34966,
              37300: 20854,
              37301: 25539,
              37302: 23384,
              37303: 23403,
              37304: 23562,
              37305: 25613,
              37306: 26449,
              37307: 36956,
              37308: 20182,
              37309: 22810,
              37310: 22826,
              37311: 27760,
              37312: 35409,
              37313: 21822,
              37314: 22549,
              37315: 22949,
              37316: 24816,
              37317: 25171,
              37318: 26561,
              37319: 33333,
              37320: 26965,
              37321: 38464,
              37322: 39364,
              37323: 39464,
              37324: 20307,
              37325: 22534,
              37326: 23550,
              37327: 32784,
              37328: 23729,
              37329: 24111,
              37330: 24453,
              37331: 24608,
              37332: 24907,
              37333: 25140,
              37334: 26367,
              37335: 27888,
              37336: 28382,
              37337: 32974,
              37338: 33151,
              37339: 33492,
              37340: 34955,
              37341: 36024,
              37342: 36864,
              37343: 36910,
              37344: 38538,
              37345: 40667,
              37346: 39899,
              37347: 20195,
              37348: 21488,
              37349: 22823,
              37350: 31532,
              37351: 37261,
              37352: 38988,
              37353: 40441,
              37354: 28381,
              37355: 28711,
              37356: 21331,
              37357: 21828,
              37358: 23429,
              37359: 25176,
              37360: 25246,
              37361: 25299,
              37362: 27810,
              37363: 28655,
              37364: 29730,
              37365: 35351,
              37366: 37944,
              37367: 28609,
              37368: 35582,
              37369: 33592,
              37370: 20967,
              37371: 34552,
              37372: 21482,
              37440: 21481,
              37441: 20294,
              37442: 36948,
              37443: 36784,
              37444: 22890,
              37445: 33073,
              37446: 24061,
              37447: 31466,
              37448: 36799,
              37449: 26842,
              37450: 35895,
              37451: 29432,
              37452: 40008,
              37453: 27197,
              37454: 35504,
              37455: 20025,
              37456: 21336,
              37457: 22022,
              37458: 22374,
              37459: 25285,
              37460: 25506,
              37461: 26086,
              37462: 27470,
              37463: 28129,
              37464: 28251,
              37465: 28845,
              37466: 30701,
              37467: 31471,
              37468: 31658,
              37469: 32187,
              37470: 32829,
              37471: 32966,
              37472: 34507,
              37473: 35477,
              37474: 37723,
              37475: 22243,
              37476: 22727,
              37477: 24382,
              37478: 26029,
              37479: 26262,
              37480: 27264,
              37481: 27573,
              37482: 30007,
              37483: 35527,
              37484: 20516,
              37485: 30693,
              37486: 22320,
              37487: 24347,
              37488: 24677,
              37489: 26234,
              37490: 27744,
              37491: 30196,
              37492: 31258,
              37493: 32622,
              37494: 33268,
              37495: 34584,
              37496: 36933,
              37497: 39347,
              37498: 31689,
              37499: 30044,
              37500: 31481,
              37501: 31569,
              37502: 33988,
              37504: 36880,
              37505: 31209,
              37506: 31378,
              37507: 33590,
              37508: 23265,
              37509: 30528,
              37510: 20013,
              37511: 20210,
              37512: 23449,
              37513: 24544,
              37514: 25277,
              37515: 26172,
              37516: 26609,
              37517: 27880,
              37518: 34411,
              37519: 34935,
              37520: 35387,
              37521: 37198,
              37522: 37619,
              37523: 39376,
              37524: 27159,
              37525: 28710,
              37526: 29482,
              37527: 33511,
              37528: 33879,
              37529: 36015,
              37530: 19969,
              37531: 20806,
              37532: 20939,
              37533: 21899,
              37534: 23541,
              37535: 24086,
              37536: 24115,
              37537: 24193,
              37538: 24340,
              37539: 24373,
              37540: 24427,
              37541: 24500,
              37542: 25074,
              37543: 25361,
              37544: 26274,
              37545: 26397,
              37546: 28526,
              37547: 29266,
              37548: 30010,
              37549: 30522,
              37550: 32884,
              37551: 33081,
              37552: 33144,
              37553: 34678,
              37554: 35519,
              37555: 35548,
              37556: 36229,
              37557: 36339,
              37558: 37530,
              37559: 38263,
              37560: 38914,
              37561: 40165,
              37562: 21189,
              37563: 25431,
              37564: 30452,
              37565: 26389,
              37566: 27784,
              37567: 29645,
              37568: 36035,
              37569: 37806,
              37570: 38515,
              37571: 27941,
              37572: 22684,
              37573: 26894,
              37574: 27084,
              37575: 36861,
              37576: 37786,
              37577: 30171,
              37578: 36890,
              37579: 22618,
              37580: 26626,
              37581: 25524,
              37582: 27131,
              37583: 20291,
              37584: 28460,
              37585: 26584,
              37586: 36795,
              37587: 34086,
              37588: 32180,
              37589: 37716,
              37590: 26943,
              37591: 28528,
              37592: 22378,
              37593: 22775,
              37594: 23340,
              37595: 32044,
              37596: 29226,
              37597: 21514,
              37598: 37347,
              37599: 40372,
              37600: 20141,
              37601: 20302,
              37602: 20572,
              37603: 20597,
              37604: 21059,
              37605: 35998,
              37606: 21576,
              37607: 22564,
              37608: 23450,
              37609: 24093,
              37610: 24213,
              37611: 24237,
              37612: 24311,
              37613: 24351,
              37614: 24716,
              37615: 25269,
              37616: 25402,
              37617: 25552,
              37618: 26799,
              37619: 27712,
              37620: 30855,
              37621: 31118,
              37622: 31243,
              37623: 32224,
              37624: 33351,
              37625: 35330,
              37626: 35558,
              37627: 36420,
              37628: 36883,
              37696: 37048,
              37697: 37165,
              37698: 37336,
              37699: 40718,
              37700: 27877,
              37701: 25688,
              37702: 25826,
              37703: 25973,
              37704: 28404,
              37705: 30340,
              37706: 31515,
              37707: 36969,
              37708: 37841,
              37709: 28346,
              37710: 21746,
              37711: 24505,
              37712: 25764,
              37713: 36685,
              37714: 36845,
              37715: 37444,
              37716: 20856,
              37717: 22635,
              37718: 22825,
              37719: 23637,
              37720: 24215,
              37721: 28155,
              37722: 32399,
              37723: 29980,
              37724: 36028,
              37725: 36578,
              37726: 39003,
              37727: 28857,
              37728: 20253,
              37729: 27583,
              37730: 28593,
              37731: 3e4,
              37732: 38651,
              37733: 20814,
              37734: 21520,
              37735: 22581,
              37736: 22615,
              37737: 22956,
              37738: 23648,
              37739: 24466,
              37740: 26007,
              37741: 26460,
              37742: 28193,
              37743: 30331,
              37744: 33759,
              37745: 36077,
              37746: 36884,
              37747: 37117,
              37748: 37709,
              37749: 30757,
              37750: 30778,
              37751: 21162,
              37752: 24230,
              37753: 22303,
              37754: 22900,
              37755: 24594,
              37756: 20498,
              37757: 20826,
              37758: 20908,
              37760: 20941,
              37761: 20992,
              37762: 21776,
              37763: 22612,
              37764: 22616,
              37765: 22871,
              37766: 23445,
              37767: 23798,
              37768: 23947,
              37769: 24764,
              37770: 25237,
              37771: 25645,
              37772: 26481,
              37773: 26691,
              37774: 26812,
              37775: 26847,
              37776: 30423,
              37777: 28120,
              37778: 28271,
              37779: 28059,
              37780: 28783,
              37781: 29128,
              37782: 24403,
              37783: 30168,
              37784: 31095,
              37785: 31561,
              37786: 31572,
              37787: 31570,
              37788: 31958,
              37789: 32113,
              37790: 21040,
              37791: 33891,
              37792: 34153,
              37793: 34276,
              37794: 35342,
              37795: 35588,
              37796: 35910,
              37797: 36367,
              37798: 36867,
              37799: 36879,
              37800: 37913,
              37801: 38518,
              37802: 38957,
              37803: 39472,
              37804: 38360,
              37805: 20685,
              37806: 21205,
              37807: 21516,
              37808: 22530,
              37809: 23566,
              37810: 24999,
              37811: 25758,
              37812: 27934,
              37813: 30643,
              37814: 31461,
              37815: 33012,
              37816: 33796,
              37817: 36947,
              37818: 37509,
              37819: 23776,
              37820: 40199,
              37821: 21311,
              37822: 24471,
              37823: 24499,
              37824: 28060,
              37825: 29305,
              37826: 30563,
              37827: 31167,
              37828: 31716,
              37829: 27602,
              37830: 29420,
              37831: 35501,
              37832: 26627,
              37833: 27233,
              37834: 20984,
              37835: 31361,
              37836: 26932,
              37837: 23626,
              37838: 40182,
              37839: 33515,
              37840: 23493,
              37841: 37193,
              37842: 28702,
              37843: 22136,
              37844: 23663,
              37845: 24775,
              37846: 25958,
              37847: 27788,
              37848: 35930,
              37849: 36929,
              37850: 38931,
              37851: 21585,
              37852: 26311,
              37853: 37389,
              37854: 22856,
              37855: 37027,
              37856: 20869,
              37857: 20045,
              37858: 20970,
              37859: 34201,
              37860: 35598,
              37861: 28760,
              37862: 25466,
              37863: 37707,
              37864: 26978,
              37865: 39348,
              37866: 32260,
              37867: 30071,
              37868: 21335,
              37869: 26976,
              37870: 36575,
              37871: 38627,
              37872: 27741,
              37873: 20108,
              37874: 23612,
              37875: 24336,
              37876: 36841,
              37877: 21250,
              37878: 36049,
              37879: 32905,
              37880: 34425,
              37881: 24319,
              37882: 26085,
              37883: 20083,
              37884: 20837,
              37952: 22914,
              37953: 23615,
              37954: 38894,
              37955: 20219,
              37956: 22922,
              37957: 24525,
              37958: 35469,
              37959: 28641,
              37960: 31152,
              37961: 31074,
              37962: 23527,
              37963: 33905,
              37964: 29483,
              37965: 29105,
              37966: 24180,
              37967: 24565,
              37968: 25467,
              37969: 25754,
              37970: 29123,
              37971: 31896,
              37972: 20035,
              37973: 24316,
              37974: 20043,
              37975: 22492,
              37976: 22178,
              37977: 24745,
              37978: 28611,
              37979: 32013,
              37980: 33021,
              37981: 33075,
              37982: 33215,
              37983: 36786,
              37984: 35223,
              37985: 34468,
              37986: 24052,
              37987: 25226,
              37988: 25773,
              37989: 35207,
              37990: 26487,
              37991: 27874,
              37992: 27966,
              37993: 29750,
              37994: 30772,
              37995: 23110,
              37996: 32629,
              37997: 33453,
              37998: 39340,
              37999: 20467,
              38e3: 24259,
              38001: 25309,
              38002: 25490,
              38003: 25943,
              38004: 26479,
              38005: 30403,
              38006: 29260,
              38007: 32972,
              38008: 32954,
              38009: 36649,
              38010: 37197,
              38011: 20493,
              38012: 22521,
              38013: 23186,
              38014: 26757,
              38016: 26995,
              38017: 29028,
              38018: 29437,
              38019: 36023,
              38020: 22770,
              38021: 36064,
              38022: 38506,
              38023: 36889,
              38024: 34687,
              38025: 31204,
              38026: 30695,
              38027: 33833,
              38028: 20271,
              38029: 21093,
              38030: 21338,
              38031: 25293,
              38032: 26575,
              38033: 27850,
              38034: 30333,
              38035: 31636,
              38036: 31893,
              38037: 33334,
              38038: 34180,
              38039: 36843,
              38040: 26333,
              38041: 28448,
              38042: 29190,
              38043: 32283,
              38044: 33707,
              38045: 39361,
              38046: 40614,
              38047: 20989,
              38048: 31665,
              38049: 30834,
              38050: 31672,
              38051: 32903,
              38052: 31560,
              38053: 27368,
              38054: 24161,
              38055: 32908,
              38056: 30033,
              38057: 30048,
              38058: 20843,
              38059: 37474,
              38060: 28300,
              38061: 30330,
              38062: 37271,
              38063: 39658,
              38064: 20240,
              38065: 32624,
              38066: 25244,
              38067: 31567,
              38068: 38309,
              38069: 40169,
              38070: 22138,
              38071: 22617,
              38072: 34532,
              38073: 38588,
              38074: 20276,
              38075: 21028,
              38076: 21322,
              38077: 21453,
              38078: 21467,
              38079: 24070,
              38080: 25644,
              38081: 26001,
              38082: 26495,
              38083: 27710,
              38084: 27726,
              38085: 29256,
              38086: 29359,
              38087: 29677,
              38088: 30036,
              38089: 32321,
              38090: 33324,
              38091: 34281,
              38092: 36009,
              38093: 31684,
              38094: 37318,
              38095: 29033,
              38096: 38930,
              38097: 39151,
              38098: 25405,
              38099: 26217,
              38100: 30058,
              38101: 30436,
              38102: 30928,
              38103: 34115,
              38104: 34542,
              38105: 21290,
              38106: 21329,
              38107: 21542,
              38108: 22915,
              38109: 24199,
              38110: 24444,
              38111: 24754,
              38112: 25161,
              38113: 25209,
              38114: 25259,
              38115: 26e3,
              38116: 27604,
              38117: 27852,
              38118: 30130,
              38119: 30382,
              38120: 30865,
              38121: 31192,
              38122: 32203,
              38123: 32631,
              38124: 32933,
              38125: 34987,
              38126: 35513,
              38127: 36027,
              38128: 36991,
              38129: 38750,
              38130: 39131,
              38131: 27147,
              38132: 31800,
              38133: 20633,
              38134: 23614,
              38135: 24494,
              38136: 26503,
              38137: 27608,
              38138: 29749,
              38139: 30473,
              38140: 32654,
              38208: 40763,
              38209: 26570,
              38210: 31255,
              38211: 21305,
              38212: 30091,
              38213: 39661,
              38214: 24422,
              38215: 33181,
              38216: 33777,
              38217: 32920,
              38218: 24380,
              38219: 24517,
              38220: 30050,
              38221: 31558,
              38222: 36924,
              38223: 26727,
              38224: 23019,
              38225: 23195,
              38226: 32016,
              38227: 30334,
              38228: 35628,
              38229: 20469,
              38230: 24426,
              38231: 27161,
              38232: 27703,
              38233: 28418,
              38234: 29922,
              38235: 31080,
              38236: 34920,
              38237: 35413,
              38238: 35961,
              38239: 24287,
              38240: 25551,
              38241: 30149,
              38242: 31186,
              38243: 33495,
              38244: 37672,
              38245: 37618,
              38246: 33948,
              38247: 34541,
              38248: 39981,
              38249: 21697,
              38250: 24428,
              38251: 25996,
              38252: 27996,
              38253: 28693,
              38254: 36007,
              38255: 36051,
              38256: 38971,
              38257: 25935,
              38258: 29942,
              38259: 19981,
              38260: 20184,
              38261: 22496,
              38262: 22827,
              38263: 23142,
              38264: 23500,
              38265: 20904,
              38266: 24067,
              38267: 24220,
              38268: 24598,
              38269: 25206,
              38270: 25975,
              38272: 26023,
              38273: 26222,
              38274: 28014,
              38275: 29238,
              38276: 31526,
              38277: 33104,
              38278: 33178,
              38279: 33433,
              38280: 35676,
              38281: 36e3,
              38282: 36070,
              38283: 36212,
              38284: 38428,
              38285: 38468,
              38286: 20398,
              38287: 25771,
              38288: 27494,
              38289: 33310,
              38290: 33889,
              38291: 34154,
              38292: 37096,
              38293: 23553,
              38294: 26963,
              38295: 39080,
              38296: 33914,
              38297: 34135,
              38298: 20239,
              38299: 21103,
              38300: 24489,
              38301: 24133,
              38302: 26381,
              38303: 31119,
              38304: 33145,
              38305: 35079,
              38306: 35206,
              38307: 28149,
              38308: 24343,
              38309: 25173,
              38310: 27832,
              38311: 20175,
              38312: 29289,
              38313: 39826,
              38314: 20998,
              38315: 21563,
              38316: 22132,
              38317: 22707,
              38318: 24996,
              38319: 25198,
              38320: 28954,
              38321: 22894,
              38322: 31881,
              38323: 31966,
              38324: 32027,
              38325: 38640,
              38326: 25991,
              38327: 32862,
              38328: 19993,
              38329: 20341,
              38330: 20853,
              38331: 22592,
              38332: 24163,
              38333: 24179,
              38334: 24330,
              38335: 26564,
              38336: 20006,
              38337: 34109,
              38338: 38281,
              38339: 38491,
              38340: 31859,
              38341: 38913,
              38342: 20731,
              38343: 22721,
              38344: 30294,
              38345: 30887,
              38346: 21029,
              38347: 30629,
              38348: 34065,
              38349: 31622,
              38350: 20559,
              38351: 22793,
              38352: 29255,
              38353: 31687,
              38354: 32232,
              38355: 36794,
              38356: 36820,
              38357: 36941,
              38358: 20415,
              38359: 21193,
              38360: 23081,
              38361: 24321,
              38362: 38829,
              38363: 20445,
              38364: 33303,
              38365: 37610,
              38366: 22275,
              38367: 25429,
              38368: 27497,
              38369: 29995,
              38370: 35036,
              38371: 36628,
              38372: 31298,
              38373: 21215,
              38374: 22675,
              38375: 24917,
              38376: 25098,
              38377: 26286,
              38378: 27597,
              38379: 31807,
              38380: 33769,
              38381: 20515,
              38382: 20472,
              38383: 21253,
              38384: 21574,
              38385: 22577,
              38386: 22857,
              38387: 23453,
              38388: 23792,
              38389: 23791,
              38390: 23849,
              38391: 24214,
              38392: 25265,
              38393: 25447,
              38394: 25918,
              38395: 26041,
              38396: 26379,
              38464: 27861,
              38465: 27873,
              38466: 28921,
              38467: 30770,
              38468: 32299,
              38469: 32990,
              38470: 33459,
              38471: 33804,
              38472: 34028,
              38473: 34562,
              38474: 35090,
              38475: 35370,
              38476: 35914,
              38477: 37030,
              38478: 37586,
              38479: 39165,
              38480: 40179,
              38481: 40300,
              38482: 20047,
              38483: 20129,
              38484: 20621,
              38485: 21078,
              38486: 22346,
              38487: 22952,
              38488: 24125,
              38489: 24536,
              38490: 24537,
              38491: 25151,
              38492: 26292,
              38493: 26395,
              38494: 26576,
              38495: 26834,
              38496: 20882,
              38497: 32033,
              38498: 32938,
              38499: 33192,
              38500: 35584,
              38501: 35980,
              38502: 36031,
              38503: 37502,
              38504: 38450,
              38505: 21536,
              38506: 38956,
              38507: 21271,
              38508: 20693,
              38509: 21340,
              38510: 22696,
              38511: 25778,
              38512: 26420,
              38513: 29287,
              38514: 30566,
              38515: 31302,
              38516: 37350,
              38517: 21187,
              38518: 27809,
              38519: 27526,
              38520: 22528,
              38521: 24140,
              38522: 22868,
              38523: 26412,
              38524: 32763,
              38525: 20961,
              38526: 30406,
              38528: 25705,
              38529: 30952,
              38530: 39764,
              38531: 40635,
              38532: 22475,
              38533: 22969,
              38534: 26151,
              38535: 26522,
              38536: 27598,
              38537: 21737,
              38538: 27097,
              38539: 24149,
              38540: 33180,
              38541: 26517,
              38542: 39850,
              38543: 26622,
              38544: 40018,
              38545: 26717,
              38546: 20134,
              38547: 20451,
              38548: 21448,
              38549: 25273,
              38550: 26411,
              38551: 27819,
              38552: 36804,
              38553: 20397,
              38554: 32365,
              38555: 40639,
              38556: 19975,
              38557: 24930,
              38558: 28288,
              38559: 28459,
              38560: 34067,
              38561: 21619,
              38562: 26410,
              38563: 39749,
              38564: 24051,
              38565: 31637,
              38566: 23724,
              38567: 23494,
              38568: 34588,
              38569: 28234,
              38570: 34001,
              38571: 31252,
              38572: 33032,
              38573: 22937,
              38574: 31885,
              38575: 27665,
              38576: 30496,
              38577: 21209,
              38578: 22818,
              38579: 28961,
              38580: 29279,
              38581: 30683,
              38582: 38695,
              38583: 40289,
              38584: 26891,
              38585: 23167,
              38586: 23064,
              38587: 20901,
              38588: 21517,
              38589: 21629,
              38590: 26126,
              38591: 30431,
              38592: 36855,
              38593: 37528,
              38594: 40180,
              38595: 23018,
              38596: 29277,
              38597: 28357,
              38598: 20813,
              38599: 26825,
              38600: 32191,
              38601: 32236,
              38602: 38754,
              38603: 40634,
              38604: 25720,
              38605: 27169,
              38606: 33538,
              38607: 22916,
              38608: 23391,
              38609: 27611,
              38610: 29467,
              38611: 30450,
              38612: 32178,
              38613: 32791,
              38614: 33945,
              38615: 20786,
              38616: 26408,
              38617: 40665,
              38618: 30446,
              38619: 26466,
              38620: 21247,
              38621: 39173,
              38622: 23588,
              38623: 25147,
              38624: 31870,
              38625: 36016,
              38626: 21839,
              38627: 24758,
              38628: 32011,
              38629: 38272,
              38630: 21249,
              38631: 20063,
              38632: 20918,
              38633: 22812,
              38634: 29242,
              38635: 32822,
              38636: 37326,
              38637: 24357,
              38638: 30690,
              38639: 21380,
              38640: 24441,
              38641: 32004,
              38642: 34220,
              38643: 35379,
              38644: 36493,
              38645: 38742,
              38646: 26611,
              38647: 34222,
              38648: 37971,
              38649: 24841,
              38650: 24840,
              38651: 27833,
              38652: 30290,
              38720: 35565,
              38721: 36664,
              38722: 21807,
              38723: 20305,
              38724: 20778,
              38725: 21191,
              38726: 21451,
              38727: 23461,
              38728: 24189,
              38729: 24736,
              38730: 24962,
              38731: 25558,
              38732: 26377,
              38733: 26586,
              38734: 28263,
              38735: 28044,
              38736: 29494,
              38737: 29495,
              38738: 30001,
              38739: 31056,
              38740: 35029,
              38741: 35480,
              38742: 36938,
              38743: 37009,
              38744: 37109,
              38745: 38596,
              38746: 34701,
              38747: 22805,
              38748: 20104,
              38749: 20313,
              38750: 19982,
              38751: 35465,
              38752: 36671,
              38753: 38928,
              38754: 20653,
              38755: 24188,
              38756: 22934,
              38757: 23481,
              38758: 24248,
              38759: 25562,
              38760: 25594,
              38761: 25793,
              38762: 26332,
              38763: 26954,
              38764: 27096,
              38765: 27915,
              38766: 28342,
              38767: 29076,
              38768: 29992,
              38769: 31407,
              38770: 32650,
              38771: 32768,
              38772: 33865,
              38773: 33993,
              38774: 35201,
              38775: 35617,
              38776: 36362,
              38777: 36965,
              38778: 38525,
              38779: 39178,
              38780: 24958,
              38781: 25233,
              38782: 27442,
              38784: 27779,
              38785: 28020,
              38786: 32716,
              38787: 32764,
              38788: 28096,
              38789: 32645,
              38790: 34746,
              38791: 35064,
              38792: 26469,
              38793: 33713,
              38794: 38972,
              38795: 38647,
              38796: 27931,
              38797: 32097,
              38798: 33853,
              38799: 37226,
              38800: 20081,
              38801: 21365,
              38802: 23888,
              38803: 27396,
              38804: 28651,
              38805: 34253,
              38806: 34349,
              38807: 35239,
              38808: 21033,
              38809: 21519,
              38810: 23653,
              38811: 26446,
              38812: 26792,
              38813: 29702,
              38814: 29827,
              38815: 30178,
              38816: 35023,
              38817: 35041,
              38818: 37324,
              38819: 38626,
              38820: 38520,
              38821: 24459,
              38822: 29575,
              38823: 31435,
              38824: 33870,
              38825: 25504,
              38826: 30053,
              38827: 21129,
              38828: 27969,
              38829: 28316,
              38830: 29705,
              38831: 30041,
              38832: 30827,
              38833: 31890,
              38834: 38534,
              38835: 31452,
              38836: 40845,
              38837: 20406,
              38838: 24942,
              38839: 26053,
              38840: 34396,
              38841: 20102,
              38842: 20142,
              38843: 20698,
              38844: 20001,
              38845: 20940,
              38846: 23534,
              38847: 26009,
              38848: 26753,
              38849: 28092,
              38850: 29471,
              38851: 30274,
              38852: 30637,
              38853: 31260,
              38854: 31975,
              38855: 33391,
              38856: 35538,
              38857: 36988,
              38858: 37327,
              38859: 38517,
              38860: 38936,
              38861: 21147,
              38862: 32209,
              38863: 20523,
              38864: 21400,
              38865: 26519,
              38866: 28107,
              38867: 29136,
              38868: 29747,
              38869: 33256,
              38870: 36650,
              38871: 38563,
              38872: 40023,
              38873: 40607,
              38874: 29792,
              38875: 22593,
              38876: 28057,
              38877: 32047,
              38878: 39006,
              38879: 20196,
              38880: 20278,
              38881: 20363,
              38882: 20919,
              38883: 21169,
              38884: 23994,
              38885: 24604,
              38886: 29618,
              38887: 31036,
              38888: 33491,
              38889: 37428,
              38890: 38583,
              38891: 38646,
              38892: 38666,
              38893: 40599,
              38894: 40802,
              38895: 26278,
              38896: 27508,
              38897: 21015,
              38898: 21155,
              38899: 28872,
              38900: 35010,
              38901: 24265,
              38902: 24651,
              38903: 24976,
              38904: 28451,
              38905: 29001,
              38906: 31806,
              38907: 32244,
              38908: 32879,
              38976: 34030,
              38977: 36899,
              38978: 37676,
              38979: 21570,
              38980: 39791,
              38981: 27347,
              38982: 28809,
              38983: 36034,
              38984: 36335,
              38985: 38706,
              38986: 21172,
              38987: 23105,
              38988: 24266,
              38989: 24324,
              38990: 26391,
              38991: 27004,
              38992: 27028,
              38993: 28010,
              38994: 28431,
              38995: 29282,
              38996: 29436,
              38997: 31725,
              38998: 32769,
              38999: 32894,
              39e3: 34635,
              39001: 37070,
              39002: 20845,
              39003: 40595,
              39004: 31108,
              39005: 32907,
              39006: 37682,
              39007: 35542,
              39008: 20525,
              39009: 21644,
              39010: 35441,
              39011: 27498,
              39012: 36036,
              39013: 33031,
              39014: 24785,
              39015: 26528,
              39016: 40434,
              39017: 20121,
              39018: 20120,
              39019: 39952,
              39020: 35435,
              39021: 34241,
              39022: 34152,
              39023: 26880,
              39024: 28286,
              39025: 30871,
              39026: 33109,
              39071: 24332,
              39072: 19984,
              39073: 19989,
              39074: 20010,
              39075: 20017,
              39076: 20022,
              39077: 20028,
              39078: 20031,
              39079: 20034,
              39080: 20054,
              39081: 20056,
              39082: 20098,
              39083: 20101,
              39084: 35947,
              39085: 20106,
              39086: 33298,
              39087: 24333,
              39088: 20110,
              39089: 20126,
              39090: 20127,
              39091: 20128,
              39092: 20130,
              39093: 20144,
              39094: 20147,
              39095: 20150,
              39096: 20174,
              39097: 20173,
              39098: 20164,
              39099: 20166,
              39100: 20162,
              39101: 20183,
              39102: 20190,
              39103: 20205,
              39104: 20191,
              39105: 20215,
              39106: 20233,
              39107: 20314,
              39108: 20272,
              39109: 20315,
              39110: 20317,
              39111: 20311,
              39112: 20295,
              39113: 20342,
              39114: 20360,
              39115: 20367,
              39116: 20376,
              39117: 20347,
              39118: 20329,
              39119: 20336,
              39120: 20369,
              39121: 20335,
              39122: 20358,
              39123: 20374,
              39124: 20760,
              39125: 20436,
              39126: 20447,
              39127: 20430,
              39128: 20440,
              39129: 20443,
              39130: 20433,
              39131: 20442,
              39132: 20432,
              39133: 20452,
              39134: 20453,
              39135: 20506,
              39136: 20520,
              39137: 20500,
              39138: 20522,
              39139: 20517,
              39140: 20485,
              39141: 20252,
              39142: 20470,
              39143: 20513,
              39144: 20521,
              39145: 20524,
              39146: 20478,
              39147: 20463,
              39148: 20497,
              39149: 20486,
              39150: 20547,
              39151: 20551,
              39152: 26371,
              39153: 20565,
              39154: 20560,
              39155: 20552,
              39156: 20570,
              39157: 20566,
              39158: 20588,
              39159: 20600,
              39160: 20608,
              39161: 20634,
              39162: 20613,
              39163: 20660,
              39164: 20658,
              39232: 20681,
              39233: 20682,
              39234: 20659,
              39235: 20674,
              39236: 20694,
              39237: 20702,
              39238: 20709,
              39239: 20717,
              39240: 20707,
              39241: 20718,
              39242: 20729,
              39243: 20725,
              39244: 20745,
              39245: 20737,
              39246: 20738,
              39247: 20758,
              39248: 20757,
              39249: 20756,
              39250: 20762,
              39251: 20769,
              39252: 20794,
              39253: 20791,
              39254: 20796,
              39255: 20795,
              39256: 20799,
              39257: 20800,
              39258: 20818,
              39259: 20812,
              39260: 20820,
              39261: 20834,
              39262: 31480,
              39263: 20841,
              39264: 20842,
              39265: 20846,
              39266: 20864,
              39267: 20866,
              39268: 22232,
              39269: 20876,
              39270: 20873,
              39271: 20879,
              39272: 20881,
              39273: 20883,
              39274: 20885,
              39275: 20886,
              39276: 20900,
              39277: 20902,
              39278: 20898,
              39279: 20905,
              39280: 20906,
              39281: 20907,
              39282: 20915,
              39283: 20913,
              39284: 20914,
              39285: 20912,
              39286: 20917,
              39287: 20925,
              39288: 20933,
              39289: 20937,
              39290: 20955,
              39291: 20960,
              39292: 34389,
              39293: 20969,
              39294: 20973,
              39296: 20976,
              39297: 20981,
              39298: 20990,
              39299: 20996,
              39300: 21003,
              39301: 21012,
              39302: 21006,
              39303: 21031,
              39304: 21034,
              39305: 21038,
              39306: 21043,
              39307: 21049,
              39308: 21071,
              39309: 21060,
              39310: 21067,
              39311: 21068,
              39312: 21086,
              39313: 21076,
              39314: 21098,
              39315: 21108,
              39316: 21097,
              39317: 21107,
              39318: 21119,
              39319: 21117,
              39320: 21133,
              39321: 21140,
              39322: 21138,
              39323: 21105,
              39324: 21128,
              39325: 21137,
              39326: 36776,
              39327: 36775,
              39328: 21164,
              39329: 21165,
              39330: 21180,
              39331: 21173,
              39332: 21185,
              39333: 21197,
              39334: 21207,
              39335: 21214,
              39336: 21219,
              39337: 21222,
              39338: 39149,
              39339: 21216,
              39340: 21235,
              39341: 21237,
              39342: 21240,
              39343: 21241,
              39344: 21254,
              39345: 21256,
              39346: 30008,
              39347: 21261,
              39348: 21264,
              39349: 21263,
              39350: 21269,
              39351: 21274,
              39352: 21283,
              39353: 21295,
              39354: 21297,
              39355: 21299,
              39356: 21304,
              39357: 21312,
              39358: 21318,
              39359: 21317,
              39360: 19991,
              39361: 21321,
              39362: 21325,
              39363: 20950,
              39364: 21342,
              39365: 21353,
              39366: 21358,
              39367: 22808,
              39368: 21371,
              39369: 21367,
              39370: 21378,
              39371: 21398,
              39372: 21408,
              39373: 21414,
              39374: 21413,
              39375: 21422,
              39376: 21424,
              39377: 21430,
              39378: 21443,
              39379: 31762,
              39380: 38617,
              39381: 21471,
              39382: 26364,
              39383: 29166,
              39384: 21486,
              39385: 21480,
              39386: 21485,
              39387: 21498,
              39388: 21505,
              39389: 21565,
              39390: 21568,
              39391: 21548,
              39392: 21549,
              39393: 21564,
              39394: 21550,
              39395: 21558,
              39396: 21545,
              39397: 21533,
              39398: 21582,
              39399: 21647,
              39400: 21621,
              39401: 21646,
              39402: 21599,
              39403: 21617,
              39404: 21623,
              39405: 21616,
              39406: 21650,
              39407: 21627,
              39408: 21632,
              39409: 21622,
              39410: 21636,
              39411: 21648,
              39412: 21638,
              39413: 21703,
              39414: 21666,
              39415: 21688,
              39416: 21669,
              39417: 21676,
              39418: 21700,
              39419: 21704,
              39420: 21672,
              39488: 21675,
              39489: 21698,
              39490: 21668,
              39491: 21694,
              39492: 21692,
              39493: 21720,
              39494: 21733,
              39495: 21734,
              39496: 21775,
              39497: 21780,
              39498: 21757,
              39499: 21742,
              39500: 21741,
              39501: 21754,
              39502: 21730,
              39503: 21817,
              39504: 21824,
              39505: 21859,
              39506: 21836,
              39507: 21806,
              39508: 21852,
              39509: 21829,
              39510: 21846,
              39511: 21847,
              39512: 21816,
              39513: 21811,
              39514: 21853,
              39515: 21913,
              39516: 21888,
              39517: 21679,
              39518: 21898,
              39519: 21919,
              39520: 21883,
              39521: 21886,
              39522: 21912,
              39523: 21918,
              39524: 21934,
              39525: 21884,
              39526: 21891,
              39527: 21929,
              39528: 21895,
              39529: 21928,
              39530: 21978,
              39531: 21957,
              39532: 21983,
              39533: 21956,
              39534: 21980,
              39535: 21988,
              39536: 21972,
              39537: 22036,
              39538: 22007,
              39539: 22038,
              39540: 22014,
              39541: 22013,
              39542: 22043,
              39543: 22009,
              39544: 22094,
              39545: 22096,
              39546: 29151,
              39547: 22068,
              39548: 22070,
              39549: 22066,
              39550: 22072,
              39552: 22123,
              39553: 22116,
              39554: 22063,
              39555: 22124,
              39556: 22122,
              39557: 22150,
              39558: 22144,
              39559: 22154,
              39560: 22176,
              39561: 22164,
              39562: 22159,
              39563: 22181,
              39564: 22190,
              39565: 22198,
              39566: 22196,
              39567: 22210,
              39568: 22204,
              39569: 22209,
              39570: 22211,
              39571: 22208,
              39572: 22216,
              39573: 22222,
              39574: 22225,
              39575: 22227,
              39576: 22231,
              39577: 22254,
              39578: 22265,
              39579: 22272,
              39580: 22271,
              39581: 22276,
              39582: 22281,
              39583: 22280,
              39584: 22283,
              39585: 22285,
              39586: 22291,
              39587: 22296,
              39588: 22294,
              39589: 21959,
              39590: 22300,
              39591: 22310,
              39592: 22327,
              39593: 22328,
              39594: 22350,
              39595: 22331,
              39596: 22336,
              39597: 22351,
              39598: 22377,
              39599: 22464,
              39600: 22408,
              39601: 22369,
              39602: 22399,
              39603: 22409,
              39604: 22419,
              39605: 22432,
              39606: 22451,
              39607: 22436,
              39608: 22442,
              39609: 22448,
              39610: 22467,
              39611: 22470,
              39612: 22484,
              39613: 22482,
              39614: 22483,
              39615: 22538,
              39616: 22486,
              39617: 22499,
              39618: 22539,
              39619: 22553,
              39620: 22557,
              39621: 22642,
              39622: 22561,
              39623: 22626,
              39624: 22603,
              39625: 22640,
              39626: 27584,
              39627: 22610,
              39628: 22589,
              39629: 22649,
              39630: 22661,
              39631: 22713,
              39632: 22687,
              39633: 22699,
              39634: 22714,
              39635: 22750,
              39636: 22715,
              39637: 22712,
              39638: 22702,
              39639: 22725,
              39640: 22739,
              39641: 22737,
              39642: 22743,
              39643: 22745,
              39644: 22744,
              39645: 22757,
              39646: 22748,
              39647: 22756,
              39648: 22751,
              39649: 22767,
              39650: 22778,
              39651: 22777,
              39652: 22779,
              39653: 22780,
              39654: 22781,
              39655: 22786,
              39656: 22794,
              39657: 22800,
              39658: 22811,
              39659: 26790,
              39660: 22821,
              39661: 22828,
              39662: 22829,
              39663: 22834,
              39664: 22840,
              39665: 22846,
              39666: 31442,
              39667: 22869,
              39668: 22864,
              39669: 22862,
              39670: 22874,
              39671: 22872,
              39672: 22882,
              39673: 22880,
              39674: 22887,
              39675: 22892,
              39676: 22889,
              39744: 22904,
              39745: 22913,
              39746: 22941,
              39747: 20318,
              39748: 20395,
              39749: 22947,
              39750: 22962,
              39751: 22982,
              39752: 23016,
              39753: 23004,
              39754: 22925,
              39755: 23001,
              39756: 23002,
              39757: 23077,
              39758: 23071,
              39759: 23057,
              39760: 23068,
              39761: 23049,
              39762: 23066,
              39763: 23104,
              39764: 23148,
              39765: 23113,
              39766: 23093,
              39767: 23094,
              39768: 23138,
              39769: 23146,
              39770: 23194,
              39771: 23228,
              39772: 23230,
              39773: 23243,
              39774: 23234,
              39775: 23229,
              39776: 23267,
              39777: 23255,
              39778: 23270,
              39779: 23273,
              39780: 23254,
              39781: 23290,
              39782: 23291,
              39783: 23308,
              39784: 23307,
              39785: 23318,
              39786: 23346,
              39787: 23248,
              39788: 23338,
              39789: 23350,
              39790: 23358,
              39791: 23363,
              39792: 23365,
              39793: 23360,
              39794: 23377,
              39795: 23381,
              39796: 23386,
              39797: 23387,
              39798: 23397,
              39799: 23401,
              39800: 23408,
              39801: 23411,
              39802: 23413,
              39803: 23416,
              39804: 25992,
              39805: 23418,
              39806: 23424,
              39808: 23427,
              39809: 23462,
              39810: 23480,
              39811: 23491,
              39812: 23495,
              39813: 23497,
              39814: 23508,
              39815: 23504,
              39816: 23524,
              39817: 23526,
              39818: 23522,
              39819: 23518,
              39820: 23525,
              39821: 23531,
              39822: 23536,
              39823: 23542,
              39824: 23539,
              39825: 23557,
              39826: 23559,
              39827: 23560,
              39828: 23565,
              39829: 23571,
              39830: 23584,
              39831: 23586,
              39832: 23592,
              39833: 23608,
              39834: 23609,
              39835: 23617,
              39836: 23622,
              39837: 23630,
              39838: 23635,
              39839: 23632,
              39840: 23631,
              39841: 23409,
              39842: 23660,
              39843: 23662,
              39844: 20066,
              39845: 23670,
              39846: 23673,
              39847: 23692,
              39848: 23697,
              39849: 23700,
              39850: 22939,
              39851: 23723,
              39852: 23739,
              39853: 23734,
              39854: 23740,
              39855: 23735,
              39856: 23749,
              39857: 23742,
              39858: 23751,
              39859: 23769,
              39860: 23785,
              39861: 23805,
              39862: 23802,
              39863: 23789,
              39864: 23948,
              39865: 23786,
              39866: 23819,
              39867: 23829,
              39868: 23831,
              39869: 23900,
              39870: 23839,
              39871: 23835,
              39872: 23825,
              39873: 23828,
              39874: 23842,
              39875: 23834,
              39876: 23833,
              39877: 23832,
              39878: 23884,
              39879: 23890,
              39880: 23886,
              39881: 23883,
              39882: 23916,
              39883: 23923,
              39884: 23926,
              39885: 23943,
              39886: 23940,
              39887: 23938,
              39888: 23970,
              39889: 23965,
              39890: 23980,
              39891: 23982,
              39892: 23997,
              39893: 23952,
              39894: 23991,
              39895: 23996,
              39896: 24009,
              39897: 24013,
              39898: 24019,
              39899: 24018,
              39900: 24022,
              39901: 24027,
              39902: 24043,
              39903: 24050,
              39904: 24053,
              39905: 24075,
              39906: 24090,
              39907: 24089,
              39908: 24081,
              39909: 24091,
              39910: 24118,
              39911: 24119,
              39912: 24132,
              39913: 24131,
              39914: 24128,
              39915: 24142,
              39916: 24151,
              39917: 24148,
              39918: 24159,
              39919: 24162,
              39920: 24164,
              39921: 24135,
              39922: 24181,
              39923: 24182,
              39924: 24186,
              39925: 40636,
              39926: 24191,
              39927: 24224,
              39928: 24257,
              39929: 24258,
              39930: 24264,
              39931: 24272,
              39932: 24271,
              4e4: 24278,
              40001: 24291,
              40002: 24285,
              40003: 24282,
              40004: 24283,
              40005: 24290,
              40006: 24289,
              40007: 24296,
              40008: 24297,
              40009: 24300,
              40010: 24305,
              40011: 24307,
              40012: 24304,
              40013: 24308,
              40014: 24312,
              40015: 24318,
              40016: 24323,
              40017: 24329,
              40018: 24413,
              40019: 24412,
              40020: 24331,
              40021: 24337,
              40022: 24342,
              40023: 24361,
              40024: 24365,
              40025: 24376,
              40026: 24385,
              40027: 24392,
              40028: 24396,
              40029: 24398,
              40030: 24367,
              40031: 24401,
              40032: 24406,
              40033: 24407,
              40034: 24409,
              40035: 24417,
              40036: 24429,
              40037: 24435,
              40038: 24439,
              40039: 24451,
              40040: 24450,
              40041: 24447,
              40042: 24458,
              40043: 24456,
              40044: 24465,
              40045: 24455,
              40046: 24478,
              40047: 24473,
              40048: 24472,
              40049: 24480,
              40050: 24488,
              40051: 24493,
              40052: 24508,
              40053: 24534,
              40054: 24571,
              40055: 24548,
              40056: 24568,
              40057: 24561,
              40058: 24541,
              40059: 24755,
              40060: 24575,
              40061: 24609,
              40062: 24672,
              40064: 24601,
              40065: 24592,
              40066: 24617,
              40067: 24590,
              40068: 24625,
              40069: 24603,
              40070: 24597,
              40071: 24619,
              40072: 24614,
              40073: 24591,
              40074: 24634,
              40075: 24666,
              40076: 24641,
              40077: 24682,
              40078: 24695,
              40079: 24671,
              40080: 24650,
              40081: 24646,
              40082: 24653,
              40083: 24675,
              40084: 24643,
              40085: 24676,
              40086: 24642,
              40087: 24684,
              40088: 24683,
              40089: 24665,
              40090: 24705,
              40091: 24717,
              40092: 24807,
              40093: 24707,
              40094: 24730,
              40095: 24708,
              40096: 24731,
              40097: 24726,
              40098: 24727,
              40099: 24722,
              40100: 24743,
              40101: 24715,
              40102: 24801,
              40103: 24760,
              40104: 24800,
              40105: 24787,
              40106: 24756,
              40107: 24560,
              40108: 24765,
              40109: 24774,
              40110: 24757,
              40111: 24792,
              40112: 24909,
              40113: 24853,
              40114: 24838,
              40115: 24822,
              40116: 24823,
              40117: 24832,
              40118: 24820,
              40119: 24826,
              40120: 24835,
              40121: 24865,
              40122: 24827,
              40123: 24817,
              40124: 24845,
              40125: 24846,
              40126: 24903,
              40127: 24894,
              40128: 24872,
              40129: 24871,
              40130: 24906,
              40131: 24895,
              40132: 24892,
              40133: 24876,
              40134: 24884,
              40135: 24893,
              40136: 24898,
              40137: 24900,
              40138: 24947,
              40139: 24951,
              40140: 24920,
              40141: 24921,
              40142: 24922,
              40143: 24939,
              40144: 24948,
              40145: 24943,
              40146: 24933,
              40147: 24945,
              40148: 24927,
              40149: 24925,
              40150: 24915,
              40151: 24949,
              40152: 24985,
              40153: 24982,
              40154: 24967,
              40155: 25004,
              40156: 24980,
              40157: 24986,
              40158: 24970,
              40159: 24977,
              40160: 25003,
              40161: 25006,
              40162: 25036,
              40163: 25034,
              40164: 25033,
              40165: 25079,
              40166: 25032,
              40167: 25027,
              40168: 25030,
              40169: 25018,
              40170: 25035,
              40171: 32633,
              40172: 25037,
              40173: 25062,
              40174: 25059,
              40175: 25078,
              40176: 25082,
              40177: 25076,
              40178: 25087,
              40179: 25085,
              40180: 25084,
              40181: 25086,
              40182: 25088,
              40183: 25096,
              40184: 25097,
              40185: 25101,
              40186: 25100,
              40187: 25108,
              40188: 25115,
              40256: 25118,
              40257: 25121,
              40258: 25130,
              40259: 25134,
              40260: 25136,
              40261: 25138,
              40262: 25139,
              40263: 25153,
              40264: 25166,
              40265: 25182,
              40266: 25187,
              40267: 25179,
              40268: 25184,
              40269: 25192,
              40270: 25212,
              40271: 25218,
              40272: 25225,
              40273: 25214,
              40274: 25234,
              40275: 25235,
              40276: 25238,
              40277: 25300,
              40278: 25219,
              40279: 25236,
              40280: 25303,
              40281: 25297,
              40282: 25275,
              40283: 25295,
              40284: 25343,
              40285: 25286,
              40286: 25812,
              40287: 25288,
              40288: 25308,
              40289: 25292,
              40290: 25290,
              40291: 25282,
              40292: 25287,
              40293: 25243,
              40294: 25289,
              40295: 25356,
              40296: 25326,
              40297: 25329,
              40298: 25383,
              40299: 25346,
              40300: 25352,
              40301: 25327,
              40302: 25333,
              40303: 25424,
              40304: 25406,
              40305: 25421,
              40306: 25628,
              40307: 25423,
              40308: 25494,
              40309: 25486,
              40310: 25472,
              40311: 25515,
              40312: 25462,
              40313: 25507,
              40314: 25487,
              40315: 25481,
              40316: 25503,
              40317: 25525,
              40318: 25451,
              40320: 25449,
              40321: 25534,
              40322: 25577,
              40323: 25536,
              40324: 25542,
              40325: 25571,
              40326: 25545,
              40327: 25554,
              40328: 25590,
              40329: 25540,
              40330: 25622,
              40331: 25652,
              40332: 25606,
              40333: 25619,
              40334: 25638,
              40335: 25654,
              40336: 25885,
              40337: 25623,
              40338: 25640,
              40339: 25615,
              40340: 25703,
              40341: 25711,
              40342: 25718,
              40343: 25678,
              40344: 25898,
              40345: 25749,
              40346: 25747,
              40347: 25765,
              40348: 25769,
              40349: 25736,
              40350: 25788,
              40351: 25818,
              40352: 25810,
              40353: 25797,
              40354: 25799,
              40355: 25787,
              40356: 25816,
              40357: 25794,
              40358: 25841,
              40359: 25831,
              40360: 33289,
              40361: 25824,
              40362: 25825,
              40363: 25260,
              40364: 25827,
              40365: 25839,
              40366: 25900,
              40367: 25846,
              40368: 25844,
              40369: 25842,
              40370: 25850,
              40371: 25856,
              40372: 25853,
              40373: 25880,
              40374: 25884,
              40375: 25861,
              40376: 25892,
              40377: 25891,
              40378: 25899,
              40379: 25908,
              40380: 25909,
              40381: 25911,
              40382: 25910,
              40383: 25912,
              40384: 30027,
              40385: 25928,
              40386: 25942,
              40387: 25941,
              40388: 25933,
              40389: 25944,
              40390: 25950,
              40391: 25949,
              40392: 25970,
              40393: 25976,
              40394: 25986,
              40395: 25987,
              40396: 35722,
              40397: 26011,
              40398: 26015,
              40399: 26027,
              40400: 26039,
              40401: 26051,
              40402: 26054,
              40403: 26049,
              40404: 26052,
              40405: 26060,
              40406: 26066,
              40407: 26075,
              40408: 26073,
              40409: 26080,
              40410: 26081,
              40411: 26097,
              40412: 26482,
              40413: 26122,
              40414: 26115,
              40415: 26107,
              40416: 26483,
              40417: 26165,
              40418: 26166,
              40419: 26164,
              40420: 26140,
              40421: 26191,
              40422: 26180,
              40423: 26185,
              40424: 26177,
              40425: 26206,
              40426: 26205,
              40427: 26212,
              40428: 26215,
              40429: 26216,
              40430: 26207,
              40431: 26210,
              40432: 26224,
              40433: 26243,
              40434: 26248,
              40435: 26254,
              40436: 26249,
              40437: 26244,
              40438: 26264,
              40439: 26269,
              40440: 26305,
              40441: 26297,
              40442: 26313,
              40443: 26302,
              40444: 26300,
              40512: 26308,
              40513: 26296,
              40514: 26326,
              40515: 26330,
              40516: 26336,
              40517: 26175,
              40518: 26342,
              40519: 26345,
              40520: 26352,
              40521: 26357,
              40522: 26359,
              40523: 26383,
              40524: 26390,
              40525: 26398,
              40526: 26406,
              40527: 26407,
              40528: 38712,
              40529: 26414,
              40530: 26431,
              40531: 26422,
              40532: 26433,
              40533: 26424,
              40534: 26423,
              40535: 26438,
              40536: 26462,
              40537: 26464,
              40538: 26457,
              40539: 26467,
              40540: 26468,
              40541: 26505,
              40542: 26480,
              40543: 26537,
              40544: 26492,
              40545: 26474,
              40546: 26508,
              40547: 26507,
              40548: 26534,
              40549: 26529,
              40550: 26501,
              40551: 26551,
              40552: 26607,
              40553: 26548,
              40554: 26604,
              40555: 26547,
              40556: 26601,
              40557: 26552,
              40558: 26596,
              40559: 26590,
              40560: 26589,
              40561: 26594,
              40562: 26606,
              40563: 26553,
              40564: 26574,
              40565: 26566,
              40566: 26599,
              40567: 27292,
              40568: 26654,
              40569: 26694,
              40570: 26665,
              40571: 26688,
              40572: 26701,
              40573: 26674,
              40574: 26702,
              40576: 26803,
              40577: 26667,
              40578: 26713,
              40579: 26723,
              40580: 26743,
              40581: 26751,
              40582: 26783,
              40583: 26767,
              40584: 26797,
              40585: 26772,
              40586: 26781,
              40587: 26779,
              40588: 26755,
              40589: 27310,
              40590: 26809,
              40591: 26740,
              40592: 26805,
              40593: 26784,
              40594: 26810,
              40595: 26895,
              40596: 26765,
              40597: 26750,
              40598: 26881,
              40599: 26826,
              40600: 26888,
              40601: 26840,
              40602: 26914,
              40603: 26918,
              40604: 26849,
              40605: 26892,
              40606: 26829,
              40607: 26836,
              40608: 26855,
              40609: 26837,
              40610: 26934,
              40611: 26898,
              40612: 26884,
              40613: 26839,
              40614: 26851,
              40615: 26917,
              40616: 26873,
              40617: 26848,
              40618: 26863,
              40619: 26920,
              40620: 26922,
              40621: 26906,
              40622: 26915,
              40623: 26913,
              40624: 26822,
              40625: 27001,
              40626: 26999,
              40627: 26972,
              40628: 27e3,
              40629: 26987,
              40630: 26964,
              40631: 27006,
              40632: 26990,
              40633: 26937,
              40634: 26996,
              40635: 26941,
              40636: 26969,
              40637: 26928,
              40638: 26977,
              40639: 26974,
              40640: 26973,
              40641: 27009,
              40642: 26986,
              40643: 27058,
              40644: 27054,
              40645: 27088,
              40646: 27071,
              40647: 27073,
              40648: 27091,
              40649: 27070,
              40650: 27086,
              40651: 23528,
              40652: 27082,
              40653: 27101,
              40654: 27067,
              40655: 27075,
              40656: 27047,
              40657: 27182,
              40658: 27025,
              40659: 27040,
              40660: 27036,
              40661: 27029,
              40662: 27060,
              40663: 27102,
              40664: 27112,
              40665: 27138,
              40666: 27163,
              40667: 27135,
              40668: 27402,
              40669: 27129,
              40670: 27122,
              40671: 27111,
              40672: 27141,
              40673: 27057,
              40674: 27166,
              40675: 27117,
              40676: 27156,
              40677: 27115,
              40678: 27146,
              40679: 27154,
              40680: 27329,
              40681: 27171,
              40682: 27155,
              40683: 27204,
              40684: 27148,
              40685: 27250,
              40686: 27190,
              40687: 27256,
              40688: 27207,
              40689: 27234,
              40690: 27225,
              40691: 27238,
              40692: 27208,
              40693: 27192,
              40694: 27170,
              40695: 27280,
              40696: 27277,
              40697: 27296,
              40698: 27268,
              40699: 27298,
              40700: 27299,
              40768: 27287,
              40769: 34327,
              40770: 27323,
              40771: 27331,
              40772: 27330,
              40773: 27320,
              40774: 27315,
              40775: 27308,
              40776: 27358,
              40777: 27345,
              40778: 27359,
              40779: 27306,
              40780: 27354,
              40781: 27370,
              40782: 27387,
              40783: 27397,
              40784: 34326,
              40785: 27386,
              40786: 27410,
              40787: 27414,
              40788: 39729,
              40789: 27423,
              40790: 27448,
              40791: 27447,
              40792: 30428,
              40793: 27449,
              40794: 39150,
              40795: 27463,
              40796: 27459,
              40797: 27465,
              40798: 27472,
              40799: 27481,
              40800: 27476,
              40801: 27483,
              40802: 27487,
              40803: 27489,
              40804: 27512,
              40805: 27513,
              40806: 27519,
              40807: 27520,
              40808: 27524,
              40809: 27523,
              40810: 27533,
              40811: 27544,
              40812: 27541,
              40813: 27550,
              40814: 27556,
              40815: 27562,
              40816: 27563,
              40817: 27567,
              40818: 27570,
              40819: 27569,
              40820: 27571,
              40821: 27575,
              40822: 27580,
              40823: 27590,
              40824: 27595,
              40825: 27603,
              40826: 27615,
              40827: 27628,
              40828: 27627,
              40829: 27635,
              40830: 27631,
              40832: 40638,
              40833: 27656,
              40834: 27667,
              40835: 27668,
              40836: 27675,
              40837: 27684,
              40838: 27683,
              40839: 27742,
              40840: 27733,
              40841: 27746,
              40842: 27754,
              40843: 27778,
              40844: 27789,
              40845: 27802,
              40846: 27777,
              40847: 27803,
              40848: 27774,
              40849: 27752,
              40850: 27763,
              40851: 27794,
              40852: 27792,
              40853: 27844,
              40854: 27889,
              40855: 27859,
              40856: 27837,
              40857: 27863,
              40858: 27845,
              40859: 27869,
              40860: 27822,
              40861: 27825,
              40862: 27838,
              40863: 27834,
              40864: 27867,
              40865: 27887,
              40866: 27865,
              40867: 27882,
              40868: 27935,
              40869: 34893,
              40870: 27958,
              40871: 27947,
              40872: 27965,
              40873: 27960,
              40874: 27929,
              40875: 27957,
              40876: 27955,
              40877: 27922,
              40878: 27916,
              40879: 28003,
              40880: 28051,
              40881: 28004,
              40882: 27994,
              40883: 28025,
              40884: 27993,
              40885: 28046,
              40886: 28053,
              40887: 28644,
              40888: 28037,
              40889: 28153,
              40890: 28181,
              40891: 28170,
              40892: 28085,
              40893: 28103,
              40894: 28134,
              40895: 28088,
              40896: 28102,
              40897: 28140,
              40898: 28126,
              40899: 28108,
              40900: 28136,
              40901: 28114,
              40902: 28101,
              40903: 28154,
              40904: 28121,
              40905: 28132,
              40906: 28117,
              40907: 28138,
              40908: 28142,
              40909: 28205,
              40910: 28270,
              40911: 28206,
              40912: 28185,
              40913: 28274,
              40914: 28255,
              40915: 28222,
              40916: 28195,
              40917: 28267,
              40918: 28203,
              40919: 28278,
              40920: 28237,
              40921: 28191,
              40922: 28227,
              40923: 28218,
              40924: 28238,
              40925: 28196,
              40926: 28415,
              40927: 28189,
              40928: 28216,
              40929: 28290,
              40930: 28330,
              40931: 28312,
              40932: 28361,
              40933: 28343,
              40934: 28371,
              40935: 28349,
              40936: 28335,
              40937: 28356,
              40938: 28338,
              40939: 28372,
              40940: 28373,
              40941: 28303,
              40942: 28325,
              40943: 28354,
              40944: 28319,
              40945: 28481,
              40946: 28433,
              40947: 28748,
              40948: 28396,
              40949: 28408,
              40950: 28414,
              40951: 28479,
              40952: 28402,
              40953: 28465,
              40954: 28399,
              40955: 28466,
              40956: 28364,
              161: 65377,
              162: 65378,
              163: 65379,
              164: 65380,
              165: 65381,
              166: 65382,
              167: 65383,
              168: 65384,
              169: 65385,
              170: 65386,
              171: 65387,
              172: 65388,
              173: 65389,
              174: 65390,
              175: 65391,
              176: 65392,
              177: 65393,
              178: 65394,
              179: 65395,
              180: 65396,
              181: 65397,
              182: 65398,
              183: 65399,
              184: 65400,
              185: 65401,
              186: 65402,
              187: 65403,
              188: 65404,
              189: 65405,
              190: 65406,
              191: 65407,
              192: 65408,
              193: 65409,
              194: 65410,
              195: 65411,
              196: 65412,
              197: 65413,
              198: 65414,
              199: 65415,
              200: 65416,
              201: 65417,
              202: 65418,
              203: 65419,
              204: 65420,
              205: 65421,
              206: 65422,
              207: 65423,
              208: 65424,
              209: 65425,
              210: 65426,
              211: 65427,
              212: 65428,
              213: 65429,
              214: 65430,
              215: 65431,
              216: 65432,
              217: 65433,
              218: 65434,
              219: 65435,
              220: 65436,
              221: 65437,
              222: 65438,
              223: 65439,
              57408: 28478,
              57409: 28435,
              57410: 28407,
              57411: 28550,
              57412: 28538,
              57413: 28536,
              57414: 28545,
              57415: 28544,
              57416: 28527,
              57417: 28507,
              57418: 28659,
              57419: 28525,
              57420: 28546,
              57421: 28540,
              57422: 28504,
              57423: 28558,
              57424: 28561,
              57425: 28610,
              57426: 28518,
              57427: 28595,
              57428: 28579,
              57429: 28577,
              57430: 28580,
              57431: 28601,
              57432: 28614,
              57433: 28586,
              57434: 28639,
              57435: 28629,
              57436: 28652,
              57437: 28628,
              57438: 28632,
              57439: 28657,
              57440: 28654,
              57441: 28635,
              57442: 28681,
              57443: 28683,
              57444: 28666,
              57445: 28689,
              57446: 28673,
              57447: 28687,
              57448: 28670,
              57449: 28699,
              57450: 28698,
              57451: 28532,
              57452: 28701,
              57453: 28696,
              57454: 28703,
              57455: 28720,
              57456: 28734,
              57457: 28722,
              57458: 28753,
              57459: 28771,
              57460: 28825,
              57461: 28818,
              57462: 28847,
              57463: 28913,
              57464: 28844,
              57465: 28856,
              57466: 28851,
              57467: 28846,
              57468: 28895,
              57469: 28875,
              57470: 28893,
              57472: 28889,
              57473: 28937,
              57474: 28925,
              57475: 28956,
              57476: 28953,
              57477: 29029,
              57478: 29013,
              57479: 29064,
              57480: 29030,
              57481: 29026,
              57482: 29004,
              57483: 29014,
              57484: 29036,
              57485: 29071,
              57486: 29179,
              57487: 29060,
              57488: 29077,
              57489: 29096,
              57490: 29100,
              57491: 29143,
              57492: 29113,
              57493: 29118,
              57494: 29138,
              57495: 29129,
              57496: 29140,
              57497: 29134,
              57498: 29152,
              57499: 29164,
              57500: 29159,
              57501: 29173,
              57502: 29180,
              57503: 29177,
              57504: 29183,
              57505: 29197,
              57506: 29200,
              57507: 29211,
              57508: 29224,
              57509: 29229,
              57510: 29228,
              57511: 29232,
              57512: 29234,
              57513: 29243,
              57514: 29244,
              57515: 29247,
              57516: 29248,
              57517: 29254,
              57518: 29259,
              57519: 29272,
              57520: 29300,
              57521: 29310,
              57522: 29314,
              57523: 29313,
              57524: 29319,
              57525: 29330,
              57526: 29334,
              57527: 29346,
              57528: 29351,
              57529: 29369,
              57530: 29362,
              57531: 29379,
              57532: 29382,
              57533: 29380,
              57534: 29390,
              57535: 29394,
              57536: 29410,
              57537: 29408,
              57538: 29409,
              57539: 29433,
              57540: 29431,
              57541: 20495,
              57542: 29463,
              57543: 29450,
              57544: 29468,
              57545: 29462,
              57546: 29469,
              57547: 29492,
              57548: 29487,
              57549: 29481,
              57550: 29477,
              57551: 29502,
              57552: 29518,
              57553: 29519,
              57554: 40664,
              57555: 29527,
              57556: 29546,
              57557: 29544,
              57558: 29552,
              57559: 29560,
              57560: 29557,
              57561: 29563,
              57562: 29562,
              57563: 29640,
              57564: 29619,
              57565: 29646,
              57566: 29627,
              57567: 29632,
              57568: 29669,
              57569: 29678,
              57570: 29662,
              57571: 29858,
              57572: 29701,
              57573: 29807,
              57574: 29733,
              57575: 29688,
              57576: 29746,
              57577: 29754,
              57578: 29781,
              57579: 29759,
              57580: 29791,
              57581: 29785,
              57582: 29761,
              57583: 29788,
              57584: 29801,
              57585: 29808,
              57586: 29795,
              57587: 29802,
              57588: 29814,
              57589: 29822,
              57590: 29835,
              57591: 29854,
              57592: 29863,
              57593: 29898,
              57594: 29903,
              57595: 29908,
              57596: 29681,
              57664: 29920,
              57665: 29923,
              57666: 29927,
              57667: 29929,
              57668: 29934,
              57669: 29938,
              57670: 29936,
              57671: 29937,
              57672: 29944,
              57673: 29943,
              57674: 29956,
              57675: 29955,
              57676: 29957,
              57677: 29964,
              57678: 29966,
              57679: 29965,
              57680: 29973,
              57681: 29971,
              57682: 29982,
              57683: 29990,
              57684: 29996,
              57685: 30012,
              57686: 30020,
              57687: 30029,
              57688: 30026,
              57689: 30025,
              57690: 30043,
              57691: 30022,
              57692: 30042,
              57693: 30057,
              57694: 30052,
              57695: 30055,
              57696: 30059,
              57697: 30061,
              57698: 30072,
              57699: 30070,
              57700: 30086,
              57701: 30087,
              57702: 30068,
              57703: 30090,
              57704: 30089,
              57705: 30082,
              57706: 30100,
              57707: 30106,
              57708: 30109,
              57709: 30117,
              57710: 30115,
              57711: 30146,
              57712: 30131,
              57713: 30147,
              57714: 30133,
              57715: 30141,
              57716: 30136,
              57717: 30140,
              57718: 30129,
              57719: 30157,
              57720: 30154,
              57721: 30162,
              57722: 30169,
              57723: 30179,
              57724: 30174,
              57725: 30206,
              57726: 30207,
              57728: 30204,
              57729: 30209,
              57730: 30192,
              57731: 30202,
              57732: 30194,
              57733: 30195,
              57734: 30219,
              57735: 30221,
              57736: 30217,
              57737: 30239,
              57738: 30247,
              57739: 30240,
              57740: 30241,
              57741: 30242,
              57742: 30244,
              57743: 30260,
              57744: 30256,
              57745: 30267,
              57746: 30279,
              57747: 30280,
              57748: 30278,
              57749: 30300,
              57750: 30296,
              57751: 30305,
              57752: 30306,
              57753: 30312,
              57754: 30313,
              57755: 30314,
              57756: 30311,
              57757: 30316,
              57758: 30320,
              57759: 30322,
              57760: 30326,
              57761: 30328,
              57762: 30332,
              57763: 30336,
              57764: 30339,
              57765: 30344,
              57766: 30347,
              57767: 30350,
              57768: 30358,
              57769: 30355,
              57770: 30361,
              57771: 30362,
              57772: 30384,
              57773: 30388,
              57774: 30392,
              57775: 30393,
              57776: 30394,
              57777: 30402,
              57778: 30413,
              57779: 30422,
              57780: 30418,
              57781: 30430,
              57782: 30433,
              57783: 30437,
              57784: 30439,
              57785: 30442,
              57786: 34351,
              57787: 30459,
              57788: 30472,
              57789: 30471,
              57790: 30468,
              57791: 30505,
              57792: 30500,
              57793: 30494,
              57794: 30501,
              57795: 30502,
              57796: 30491,
              57797: 30519,
              57798: 30520,
              57799: 30535,
              57800: 30554,
              57801: 30568,
              57802: 30571,
              57803: 30555,
              57804: 30565,
              57805: 30591,
              57806: 30590,
              57807: 30585,
              57808: 30606,
              57809: 30603,
              57810: 30609,
              57811: 30624,
              57812: 30622,
              57813: 30640,
              57814: 30646,
              57815: 30649,
              57816: 30655,
              57817: 30652,
              57818: 30653,
              57819: 30651,
              57820: 30663,
              57821: 30669,
              57822: 30679,
              57823: 30682,
              57824: 30684,
              57825: 30691,
              57826: 30702,
              57827: 30716,
              57828: 30732,
              57829: 30738,
              57830: 31014,
              57831: 30752,
              57832: 31018,
              57833: 30789,
              57834: 30862,
              57835: 30836,
              57836: 30854,
              57837: 30844,
              57838: 30874,
              57839: 30860,
              57840: 30883,
              57841: 30901,
              57842: 30890,
              57843: 30895,
              57844: 30929,
              57845: 30918,
              57846: 30923,
              57847: 30932,
              57848: 30910,
              57849: 30908,
              57850: 30917,
              57851: 30922,
              57852: 30956,
              57920: 30951,
              57921: 30938,
              57922: 30973,
              57923: 30964,
              57924: 30983,
              57925: 30994,
              57926: 30993,
              57927: 31001,
              57928: 31020,
              57929: 31019,
              57930: 31040,
              57931: 31072,
              57932: 31063,
              57933: 31071,
              57934: 31066,
              57935: 31061,
              57936: 31059,
              57937: 31098,
              57938: 31103,
              57939: 31114,
              57940: 31133,
              57941: 31143,
              57942: 40779,
              57943: 31146,
              57944: 31150,
              57945: 31155,
              57946: 31161,
              57947: 31162,
              57948: 31177,
              57949: 31189,
              57950: 31207,
              57951: 31212,
              57952: 31201,
              57953: 31203,
              57954: 31240,
              57955: 31245,
              57956: 31256,
              57957: 31257,
              57958: 31264,
              57959: 31263,
              57960: 31104,
              57961: 31281,
              57962: 31291,
              57963: 31294,
              57964: 31287,
              57965: 31299,
              57966: 31319,
              57967: 31305,
              57968: 31329,
              57969: 31330,
              57970: 31337,
              57971: 40861,
              57972: 31344,
              57973: 31353,
              57974: 31357,
              57975: 31368,
              57976: 31383,
              57977: 31381,
              57978: 31384,
              57979: 31382,
              57980: 31401,
              57981: 31432,
              57982: 31408,
              57984: 31414,
              57985: 31429,
              57986: 31428,
              57987: 31423,
              57988: 36995,
              57989: 31431,
              57990: 31434,
              57991: 31437,
              57992: 31439,
              57993: 31445,
              57994: 31443,
              57995: 31449,
              57996: 31450,
              57997: 31453,
              57998: 31457,
              57999: 31458,
              58e3: 31462,
              58001: 31469,
              58002: 31472,
              58003: 31490,
              58004: 31503,
              58005: 31498,
              58006: 31494,
              58007: 31539,
              58008: 31512,
              58009: 31513,
              58010: 31518,
              58011: 31541,
              58012: 31528,
              58013: 31542,
              58014: 31568,
              58015: 31610,
              58016: 31492,
              58017: 31565,
              58018: 31499,
              58019: 31564,
              58020: 31557,
              58021: 31605,
              58022: 31589,
              58023: 31604,
              58024: 31591,
              58025: 31600,
              58026: 31601,
              58027: 31596,
              58028: 31598,
              58029: 31645,
              58030: 31640,
              58031: 31647,
              58032: 31629,
              58033: 31644,
              58034: 31642,
              58035: 31627,
              58036: 31634,
              58037: 31631,
              58038: 31581,
              58039: 31641,
              58040: 31691,
              58041: 31681,
              58042: 31692,
              58043: 31695,
              58044: 31668,
              58045: 31686,
              58046: 31709,
              58047: 31721,
              58048: 31761,
              58049: 31764,
              58050: 31718,
              58051: 31717,
              58052: 31840,
              58053: 31744,
              58054: 31751,
              58055: 31763,
              58056: 31731,
              58057: 31735,
              58058: 31767,
              58059: 31757,
              58060: 31734,
              58061: 31779,
              58062: 31783,
              58063: 31786,
              58064: 31775,
              58065: 31799,
              58066: 31787,
              58067: 31805,
              58068: 31820,
              58069: 31811,
              58070: 31828,
              58071: 31823,
              58072: 31808,
              58073: 31824,
              58074: 31832,
              58075: 31839,
              58076: 31844,
              58077: 31830,
              58078: 31845,
              58079: 31852,
              58080: 31861,
              58081: 31875,
              58082: 31888,
              58083: 31908,
              58084: 31917,
              58085: 31906,
              58086: 31915,
              58087: 31905,
              58088: 31912,
              58089: 31923,
              58090: 31922,
              58091: 31921,
              58092: 31918,
              58093: 31929,
              58094: 31933,
              58095: 31936,
              58096: 31941,
              58097: 31938,
              58098: 31960,
              58099: 31954,
              58100: 31964,
              58101: 31970,
              58102: 39739,
              58103: 31983,
              58104: 31986,
              58105: 31988,
              58106: 31990,
              58107: 31994,
              58108: 32006,
              58176: 32002,
              58177: 32028,
              58178: 32021,
              58179: 32010,
              58180: 32069,
              58181: 32075,
              58182: 32046,
              58183: 32050,
              58184: 32063,
              58185: 32053,
              58186: 32070,
              58187: 32115,
              58188: 32086,
              58189: 32078,
              58190: 32114,
              58191: 32104,
              58192: 32110,
              58193: 32079,
              58194: 32099,
              58195: 32147,
              58196: 32137,
              58197: 32091,
              58198: 32143,
              58199: 32125,
              58200: 32155,
              58201: 32186,
              58202: 32174,
              58203: 32163,
              58204: 32181,
              58205: 32199,
              58206: 32189,
              58207: 32171,
              58208: 32317,
              58209: 32162,
              58210: 32175,
              58211: 32220,
              58212: 32184,
              58213: 32159,
              58214: 32176,
              58215: 32216,
              58216: 32221,
              58217: 32228,
              58218: 32222,
              58219: 32251,
              58220: 32242,
              58221: 32225,
              58222: 32261,
              58223: 32266,
              58224: 32291,
              58225: 32289,
              58226: 32274,
              58227: 32305,
              58228: 32287,
              58229: 32265,
              58230: 32267,
              58231: 32290,
              58232: 32326,
              58233: 32358,
              58234: 32315,
              58235: 32309,
              58236: 32313,
              58237: 32323,
              58238: 32311,
              58240: 32306,
              58241: 32314,
              58242: 32359,
              58243: 32349,
              58244: 32342,
              58245: 32350,
              58246: 32345,
              58247: 32346,
              58248: 32377,
              58249: 32362,
              58250: 32361,
              58251: 32380,
              58252: 32379,
              58253: 32387,
              58254: 32213,
              58255: 32381,
              58256: 36782,
              58257: 32383,
              58258: 32392,
              58259: 32393,
              58260: 32396,
              58261: 32402,
              58262: 32400,
              58263: 32403,
              58264: 32404,
              58265: 32406,
              58266: 32398,
              58267: 32411,
              58268: 32412,
              58269: 32568,
              58270: 32570,
              58271: 32581,
              58272: 32588,
              58273: 32589,
              58274: 32590,
              58275: 32592,
              58276: 32593,
              58277: 32597,
              58278: 32596,
              58279: 32600,
              58280: 32607,
              58281: 32608,
              58282: 32616,
              58283: 32617,
              58284: 32615,
              58285: 32632,
              58286: 32642,
              58287: 32646,
              58288: 32643,
              58289: 32648,
              58290: 32647,
              58291: 32652,
              58292: 32660,
              58293: 32670,
              58294: 32669,
              58295: 32666,
              58296: 32675,
              58297: 32687,
              58298: 32690,
              58299: 32697,
              58300: 32686,
              58301: 32694,
              58302: 32696,
              58303: 35697,
              58304: 32709,
              58305: 32710,
              58306: 32714,
              58307: 32725,
              58308: 32724,
              58309: 32737,
              58310: 32742,
              58311: 32745,
              58312: 32755,
              58313: 32761,
              58314: 39132,
              58315: 32774,
              58316: 32772,
              58317: 32779,
              58318: 32786,
              58319: 32792,
              58320: 32793,
              58321: 32796,
              58322: 32801,
              58323: 32808,
              58324: 32831,
              58325: 32827,
              58326: 32842,
              58327: 32838,
              58328: 32850,
              58329: 32856,
              58330: 32858,
              58331: 32863,
              58332: 32866,
              58333: 32872,
              58334: 32883,
              58335: 32882,
              58336: 32880,
              58337: 32886,
              58338: 32889,
              58339: 32893,
              58340: 32895,
              58341: 32900,
              58342: 32902,
              58343: 32901,
              58344: 32923,
              58345: 32915,
              58346: 32922,
              58347: 32941,
              58348: 20880,
              58349: 32940,
              58350: 32987,
              58351: 32997,
              58352: 32985,
              58353: 32989,
              58354: 32964,
              58355: 32986,
              58356: 32982,
              58357: 33033,
              58358: 33007,
              58359: 33009,
              58360: 33051,
              58361: 33065,
              58362: 33059,
              58363: 33071,
              58364: 33099,
              58432: 38539,
              58433: 33094,
              58434: 33086,
              58435: 33107,
              58436: 33105,
              58437: 33020,
              58438: 33137,
              58439: 33134,
              58440: 33125,
              58441: 33126,
              58442: 33140,
              58443: 33155,
              58444: 33160,
              58445: 33162,
              58446: 33152,
              58447: 33154,
              58448: 33184,
              58449: 33173,
              58450: 33188,
              58451: 33187,
              58452: 33119,
              58453: 33171,
              58454: 33193,
              58455: 33200,
              58456: 33205,
              58457: 33214,
              58458: 33208,
              58459: 33213,
              58460: 33216,
              58461: 33218,
              58462: 33210,
              58463: 33225,
              58464: 33229,
              58465: 33233,
              58466: 33241,
              58467: 33240,
              58468: 33224,
              58469: 33242,
              58470: 33247,
              58471: 33248,
              58472: 33255,
              58473: 33274,
              58474: 33275,
              58475: 33278,
              58476: 33281,
              58477: 33282,
              58478: 33285,
              58479: 33287,
              58480: 33290,
              58481: 33293,
              58482: 33296,
              58483: 33302,
              58484: 33321,
              58485: 33323,
              58486: 33336,
              58487: 33331,
              58488: 33344,
              58489: 33369,
              58490: 33368,
              58491: 33373,
              58492: 33370,
              58493: 33375,
              58494: 33380,
              58496: 33378,
              58497: 33384,
              58498: 33386,
              58499: 33387,
              58500: 33326,
              58501: 33393,
              58502: 33399,
              58503: 33400,
              58504: 33406,
              58505: 33421,
              58506: 33426,
              58507: 33451,
              58508: 33439,
              58509: 33467,
              58510: 33452,
              58511: 33505,
              58512: 33507,
              58513: 33503,
              58514: 33490,
              58515: 33524,
              58516: 33523,
              58517: 33530,
              58518: 33683,
              58519: 33539,
              58520: 33531,
              58521: 33529,
              58522: 33502,
              58523: 33542,
              58524: 33500,
              58525: 33545,
              58526: 33497,
              58527: 33589,
              58528: 33588,
              58529: 33558,
              58530: 33586,
              58531: 33585,
              58532: 33600,
              58533: 33593,
              58534: 33616,
              58535: 33605,
              58536: 33583,
              58537: 33579,
              58538: 33559,
              58539: 33560,
              58540: 33669,
              58541: 33690,
              58542: 33706,
              58543: 33695,
              58544: 33698,
              58545: 33686,
              58546: 33571,
              58547: 33678,
              58548: 33671,
              58549: 33674,
              58550: 33660,
              58551: 33717,
              58552: 33651,
              58553: 33653,
              58554: 33696,
              58555: 33673,
              58556: 33704,
              58557: 33780,
              58558: 33811,
              58559: 33771,
              58560: 33742,
              58561: 33789,
              58562: 33795,
              58563: 33752,
              58564: 33803,
              58565: 33729,
              58566: 33783,
              58567: 33799,
              58568: 33760,
              58569: 33778,
              58570: 33805,
              58571: 33826,
              58572: 33824,
              58573: 33725,
              58574: 33848,
              58575: 34054,
              58576: 33787,
              58577: 33901,
              58578: 33834,
              58579: 33852,
              58580: 34138,
              58581: 33924,
              58582: 33911,
              58583: 33899,
              58584: 33965,
              58585: 33902,
              58586: 33922,
              58587: 33897,
              58588: 33862,
              58589: 33836,
              58590: 33903,
              58591: 33913,
              58592: 33845,
              58593: 33994,
              58594: 33890,
              58595: 33977,
              58596: 33983,
              58597: 33951,
              58598: 34009,
              58599: 33997,
              58600: 33979,
              58601: 34010,
              58602: 34e3,
              58603: 33985,
              58604: 33990,
              58605: 34006,
              58606: 33953,
              58607: 34081,
              58608: 34047,
              58609: 34036,
              58610: 34071,
              58611: 34072,
              58612: 34092,
              58613: 34079,
              58614: 34069,
              58615: 34068,
              58616: 34044,
              58617: 34112,
              58618: 34147,
              58619: 34136,
              58620: 34120,
              58688: 34113,
              58689: 34306,
              58690: 34123,
              58691: 34133,
              58692: 34176,
              58693: 34212,
              58694: 34184,
              58695: 34193,
              58696: 34186,
              58697: 34216,
              58698: 34157,
              58699: 34196,
              58700: 34203,
              58701: 34282,
              58702: 34183,
              58703: 34204,
              58704: 34167,
              58705: 34174,
              58706: 34192,
              58707: 34249,
              58708: 34234,
              58709: 34255,
              58710: 34233,
              58711: 34256,
              58712: 34261,
              58713: 34269,
              58714: 34277,
              58715: 34268,
              58716: 34297,
              58717: 34314,
              58718: 34323,
              58719: 34315,
              58720: 34302,
              58721: 34298,
              58722: 34310,
              58723: 34338,
              58724: 34330,
              58725: 34352,
              58726: 34367,
              58727: 34381,
              58728: 20053,
              58729: 34388,
              58730: 34399,
              58731: 34407,
              58732: 34417,
              58733: 34451,
              58734: 34467,
              58735: 34473,
              58736: 34474,
              58737: 34443,
              58738: 34444,
              58739: 34486,
              58740: 34479,
              58741: 34500,
              58742: 34502,
              58743: 34480,
              58744: 34505,
              58745: 34851,
              58746: 34475,
              58747: 34516,
              58748: 34526,
              58749: 34537,
              58750: 34540,
              58752: 34527,
              58753: 34523,
              58754: 34543,
              58755: 34578,
              58756: 34566,
              58757: 34568,
              58758: 34560,
              58759: 34563,
              58760: 34555,
              58761: 34577,
              58762: 34569,
              58763: 34573,
              58764: 34553,
              58765: 34570,
              58766: 34612,
              58767: 34623,
              58768: 34615,
              58769: 34619,
              58770: 34597,
              58771: 34601,
              58772: 34586,
              58773: 34656,
              58774: 34655,
              58775: 34680,
              58776: 34636,
              58777: 34638,
              58778: 34676,
              58779: 34647,
              58780: 34664,
              58781: 34670,
              58782: 34649,
              58783: 34643,
              58784: 34659,
              58785: 34666,
              58786: 34821,
              58787: 34722,
              58788: 34719,
              58789: 34690,
              58790: 34735,
              58791: 34763,
              58792: 34749,
              58793: 34752,
              58794: 34768,
              58795: 38614,
              58796: 34731,
              58797: 34756,
              58798: 34739,
              58799: 34759,
              58800: 34758,
              58801: 34747,
              58802: 34799,
              58803: 34802,
              58804: 34784,
              58805: 34831,
              58806: 34829,
              58807: 34814,
              58808: 34806,
              58809: 34807,
              58810: 34830,
              58811: 34770,
              58812: 34833,
              58813: 34838,
              58814: 34837,
              58815: 34850,
              58816: 34849,
              58817: 34865,
              58818: 34870,
              58819: 34873,
              58820: 34855,
              58821: 34875,
              58822: 34884,
              58823: 34882,
              58824: 34898,
              58825: 34905,
              58826: 34910,
              58827: 34914,
              58828: 34923,
              58829: 34945,
              58830: 34942,
              58831: 34974,
              58832: 34933,
              58833: 34941,
              58834: 34997,
              58835: 34930,
              58836: 34946,
              58837: 34967,
              58838: 34962,
              58839: 34990,
              58840: 34969,
              58841: 34978,
              58842: 34957,
              58843: 34980,
              58844: 34992,
              58845: 35007,
              58846: 34993,
              58847: 35011,
              58848: 35012,
              58849: 35028,
              58850: 35032,
              58851: 35033,
              58852: 35037,
              58853: 35065,
              58854: 35074,
              58855: 35068,
              58856: 35060,
              58857: 35048,
              58858: 35058,
              58859: 35076,
              58860: 35084,
              58861: 35082,
              58862: 35091,
              58863: 35139,
              58864: 35102,
              58865: 35109,
              58866: 35114,
              58867: 35115,
              58868: 35137,
              58869: 35140,
              58870: 35131,
              58871: 35126,
              58872: 35128,
              58873: 35148,
              58874: 35101,
              58875: 35168,
              58876: 35166,
              58944: 35174,
              58945: 35172,
              58946: 35181,
              58947: 35178,
              58948: 35183,
              58949: 35188,
              58950: 35191,
              58951: 35198,
              58952: 35203,
              58953: 35208,
              58954: 35210,
              58955: 35219,
              58956: 35224,
              58957: 35233,
              58958: 35241,
              58959: 35238,
              58960: 35244,
              58961: 35247,
              58962: 35250,
              58963: 35258,
              58964: 35261,
              58965: 35263,
              58966: 35264,
              58967: 35290,
              58968: 35292,
              58969: 35293,
              58970: 35303,
              58971: 35316,
              58972: 35320,
              58973: 35331,
              58974: 35350,
              58975: 35344,
              58976: 35340,
              58977: 35355,
              58978: 35357,
              58979: 35365,
              58980: 35382,
              58981: 35393,
              58982: 35419,
              58983: 35410,
              58984: 35398,
              58985: 35400,
              58986: 35452,
              58987: 35437,
              58988: 35436,
              58989: 35426,
              58990: 35461,
              58991: 35458,
              58992: 35460,
              58993: 35496,
              58994: 35489,
              58995: 35473,
              58996: 35493,
              58997: 35494,
              58998: 35482,
              58999: 35491,
              59e3: 35524,
              59001: 35533,
              59002: 35522,
              59003: 35546,
              59004: 35563,
              59005: 35571,
              59006: 35559,
              59008: 35556,
              59009: 35569,
              59010: 35604,
              59011: 35552,
              59012: 35554,
              59013: 35575,
              59014: 35550,
              59015: 35547,
              59016: 35596,
              59017: 35591,
              59018: 35610,
              59019: 35553,
              59020: 35606,
              59021: 35600,
              59022: 35607,
              59023: 35616,
              59024: 35635,
              59025: 38827,
              59026: 35622,
              59027: 35627,
              59028: 35646,
              59029: 35624,
              59030: 35649,
              59031: 35660,
              59032: 35663,
              59033: 35662,
              59034: 35657,
              59035: 35670,
              59036: 35675,
              59037: 35674,
              59038: 35691,
              59039: 35679,
              59040: 35692,
              59041: 35695,
              59042: 35700,
              59043: 35709,
              59044: 35712,
              59045: 35724,
              59046: 35726,
              59047: 35730,
              59048: 35731,
              59049: 35734,
              59050: 35737,
              59051: 35738,
              59052: 35898,
              59053: 35905,
              59054: 35903,
              59055: 35912,
              59056: 35916,
              59057: 35918,
              59058: 35920,
              59059: 35925,
              59060: 35938,
              59061: 35948,
              59062: 35960,
              59063: 35962,
              59064: 35970,
              59065: 35977,
              59066: 35973,
              59067: 35978,
              59068: 35981,
              59069: 35982,
              59070: 35988,
              59071: 35964,
              59072: 35992,
              59073: 25117,
              59074: 36013,
              59075: 36010,
              59076: 36029,
              59077: 36018,
              59078: 36019,
              59079: 36014,
              59080: 36022,
              59081: 36040,
              59082: 36033,
              59083: 36068,
              59084: 36067,
              59085: 36058,
              59086: 36093,
              59087: 36090,
              59088: 36091,
              59089: 36100,
              59090: 36101,
              59091: 36106,
              59092: 36103,
              59093: 36111,
              59094: 36109,
              59095: 36112,
              59096: 40782,
              59097: 36115,
              59098: 36045,
              59099: 36116,
              59100: 36118,
              59101: 36199,
              59102: 36205,
              59103: 36209,
              59104: 36211,
              59105: 36225,
              59106: 36249,
              59107: 36290,
              59108: 36286,
              59109: 36282,
              59110: 36303,
              59111: 36314,
              59112: 36310,
              59113: 36300,
              59114: 36315,
              59115: 36299,
              59116: 36330,
              59117: 36331,
              59118: 36319,
              59119: 36323,
              59120: 36348,
              59121: 36360,
              59122: 36361,
              59123: 36351,
              59124: 36381,
              59125: 36382,
              59126: 36368,
              59127: 36383,
              59128: 36418,
              59129: 36405,
              59130: 36400,
              59131: 36404,
              59132: 36426,
              59200: 36423,
              59201: 36425,
              59202: 36428,
              59203: 36432,
              59204: 36424,
              59205: 36441,
              59206: 36452,
              59207: 36448,
              59208: 36394,
              59209: 36451,
              59210: 36437,
              59211: 36470,
              59212: 36466,
              59213: 36476,
              59214: 36481,
              59215: 36487,
              59216: 36485,
              59217: 36484,
              59218: 36491,
              59219: 36490,
              59220: 36499,
              59221: 36497,
              59222: 36500,
              59223: 36505,
              59224: 36522,
              59225: 36513,
              59226: 36524,
              59227: 36528,
              59228: 36550,
              59229: 36529,
              59230: 36542,
              59231: 36549,
              59232: 36552,
              59233: 36555,
              59234: 36571,
              59235: 36579,
              59236: 36604,
              59237: 36603,
              59238: 36587,
              59239: 36606,
              59240: 36618,
              59241: 36613,
              59242: 36629,
              59243: 36626,
              59244: 36633,
              59245: 36627,
              59246: 36636,
              59247: 36639,
              59248: 36635,
              59249: 36620,
              59250: 36646,
              59251: 36659,
              59252: 36667,
              59253: 36665,
              59254: 36677,
              59255: 36674,
              59256: 36670,
              59257: 36684,
              59258: 36681,
              59259: 36678,
              59260: 36686,
              59261: 36695,
              59262: 36700,
              59264: 36706,
              59265: 36707,
              59266: 36708,
              59267: 36764,
              59268: 36767,
              59269: 36771,
              59270: 36781,
              59271: 36783,
              59272: 36791,
              59273: 36826,
              59274: 36837,
              59275: 36834,
              59276: 36842,
              59277: 36847,
              59278: 36999,
              59279: 36852,
              59280: 36869,
              59281: 36857,
              59282: 36858,
              59283: 36881,
              59284: 36885,
              59285: 36897,
              59286: 36877,
              59287: 36894,
              59288: 36886,
              59289: 36875,
              59290: 36903,
              59291: 36918,
              59292: 36917,
              59293: 36921,
              59294: 36856,
              59295: 36943,
              59296: 36944,
              59297: 36945,
              59298: 36946,
              59299: 36878,
              59300: 36937,
              59301: 36926,
              59302: 36950,
              59303: 36952,
              59304: 36958,
              59305: 36968,
              59306: 36975,
              59307: 36982,
              59308: 38568,
              59309: 36978,
              59310: 36994,
              59311: 36989,
              59312: 36993,
              59313: 36992,
              59314: 37002,
              59315: 37001,
              59316: 37007,
              59317: 37032,
              59318: 37039,
              59319: 37041,
              59320: 37045,
              59321: 37090,
              59322: 37092,
              59323: 25160,
              59324: 37083,
              59325: 37122,
              59326: 37138,
              59327: 37145,
              59328: 37170,
              59329: 37168,
              59330: 37194,
              59331: 37206,
              59332: 37208,
              59333: 37219,
              59334: 37221,
              59335: 37225,
              59336: 37235,
              59337: 37234,
              59338: 37259,
              59339: 37257,
              59340: 37250,
              59341: 37282,
              59342: 37291,
              59343: 37295,
              59344: 37290,
              59345: 37301,
              59346: 37300,
              59347: 37306,
              59348: 37312,
              59349: 37313,
              59350: 37321,
              59351: 37323,
              59352: 37328,
              59353: 37334,
              59354: 37343,
              59355: 37345,
              59356: 37339,
              59357: 37372,
              59358: 37365,
              59359: 37366,
              59360: 37406,
              59361: 37375,
              59362: 37396,
              59363: 37420,
              59364: 37397,
              59365: 37393,
              59366: 37470,
              59367: 37463,
              59368: 37445,
              59369: 37449,
              59370: 37476,
              59371: 37448,
              59372: 37525,
              59373: 37439,
              59374: 37451,
              59375: 37456,
              59376: 37532,
              59377: 37526,
              59378: 37523,
              59379: 37531,
              59380: 37466,
              59381: 37583,
              59382: 37561,
              59383: 37559,
              59384: 37609,
              59385: 37647,
              59386: 37626,
              59387: 37700,
              59388: 37678,
              59456: 37657,
              59457: 37666,
              59458: 37658,
              59459: 37667,
              59460: 37690,
              59461: 37685,
              59462: 37691,
              59463: 37724,
              59464: 37728,
              59465: 37756,
              59466: 37742,
              59467: 37718,
              59468: 37808,
              59469: 37804,
              59470: 37805,
              59471: 37780,
              59472: 37817,
              59473: 37846,
              59474: 37847,
              59475: 37864,
              59476: 37861,
              59477: 37848,
              59478: 37827,
              59479: 37853,
              59480: 37840,
              59481: 37832,
              59482: 37860,
              59483: 37914,
              59484: 37908,
              59485: 37907,
              59486: 37891,
              59487: 37895,
              59488: 37904,
              59489: 37942,
              59490: 37931,
              59491: 37941,
              59492: 37921,
              59493: 37946,
              59494: 37953,
              59495: 37970,
              59496: 37956,
              59497: 37979,
              59498: 37984,
              59499: 37986,
              59500: 37982,
              59501: 37994,
              59502: 37417,
              59503: 38e3,
              59504: 38005,
              59505: 38007,
              59506: 38013,
              59507: 37978,
              59508: 38012,
              59509: 38014,
              59510: 38017,
              59511: 38015,
              59512: 38274,
              59513: 38279,
              59514: 38282,
              59515: 38292,
              59516: 38294,
              59517: 38296,
              59518: 38297,
              59520: 38304,
              59521: 38312,
              59522: 38311,
              59523: 38317,
              59524: 38332,
              59525: 38331,
              59526: 38329,
              59527: 38334,
              59528: 38346,
              59529: 28662,
              59530: 38339,
              59531: 38349,
              59532: 38348,
              59533: 38357,
              59534: 38356,
              59535: 38358,
              59536: 38364,
              59537: 38369,
              59538: 38373,
              59539: 38370,
              59540: 38433,
              59541: 38440,
              59542: 38446,
              59543: 38447,
              59544: 38466,
              59545: 38476,
              59546: 38479,
              59547: 38475,
              59548: 38519,
              59549: 38492,
              59550: 38494,
              59551: 38493,
              59552: 38495,
              59553: 38502,
              59554: 38514,
              59555: 38508,
              59556: 38541,
              59557: 38552,
              59558: 38549,
              59559: 38551,
              59560: 38570,
              59561: 38567,
              59562: 38577,
              59563: 38578,
              59564: 38576,
              59565: 38580,
              59566: 38582,
              59567: 38584,
              59568: 38585,
              59569: 38606,
              59570: 38603,
              59571: 38601,
              59572: 38605,
              59573: 35149,
              59574: 38620,
              59575: 38669,
              59576: 38613,
              59577: 38649,
              59578: 38660,
              59579: 38662,
              59580: 38664,
              59581: 38675,
              59582: 38670,
              59583: 38673,
              59584: 38671,
              59585: 38678,
              59586: 38681,
              59587: 38692,
              59588: 38698,
              59589: 38704,
              59590: 38713,
              59591: 38717,
              59592: 38718,
              59593: 38724,
              59594: 38726,
              59595: 38728,
              59596: 38722,
              59597: 38729,
              59598: 38748,
              59599: 38752,
              59600: 38756,
              59601: 38758,
              59602: 38760,
              59603: 21202,
              59604: 38763,
              59605: 38769,
              59606: 38777,
              59607: 38789,
              59608: 38780,
              59609: 38785,
              59610: 38778,
              59611: 38790,
              59612: 38795,
              59613: 38799,
              59614: 38800,
              59615: 38812,
              59616: 38824,
              59617: 38822,
              59618: 38819,
              59619: 38835,
              59620: 38836,
              59621: 38851,
              59622: 38854,
              59623: 38856,
              59624: 38859,
              59625: 38876,
              59626: 38893,
              59627: 40783,
              59628: 38898,
              59629: 31455,
              59630: 38902,
              59631: 38901,
              59632: 38927,
              59633: 38924,
              59634: 38968,
              59635: 38948,
              59636: 38945,
              59637: 38967,
              59638: 38973,
              59639: 38982,
              59640: 38991,
              59641: 38987,
              59642: 39019,
              59643: 39023,
              59644: 39024,
              59712: 39025,
              59713: 39028,
              59714: 39027,
              59715: 39082,
              59716: 39087,
              59717: 39089,
              59718: 39094,
              59719: 39108,
              59720: 39107,
              59721: 39110,
              59722: 39145,
              59723: 39147,
              59724: 39171,
              59725: 39177,
              59726: 39186,
              59727: 39188,
              59728: 39192,
              59729: 39201,
              59730: 39197,
              59731: 39198,
              59732: 39204,
              59733: 39200,
              59734: 39212,
              59735: 39214,
              59736: 39229,
              59737: 39230,
              59738: 39234,
              59739: 39241,
              59740: 39237,
              59741: 39248,
              59742: 39243,
              59743: 39249,
              59744: 39250,
              59745: 39244,
              59746: 39253,
              59747: 39319,
              59748: 39320,
              59749: 39333,
              59750: 39341,
              59751: 39342,
              59752: 39356,
              59753: 39391,
              59754: 39387,
              59755: 39389,
              59756: 39384,
              59757: 39377,
              59758: 39405,
              59759: 39406,
              59760: 39409,
              59761: 39410,
              59762: 39419,
              59763: 39416,
              59764: 39425,
              59765: 39439,
              59766: 39429,
              59767: 39394,
              59768: 39449,
              59769: 39467,
              59770: 39479,
              59771: 39493,
              59772: 39490,
              59773: 39488,
              59774: 39491,
              59776: 39486,
              59777: 39509,
              59778: 39501,
              59779: 39515,
              59780: 39511,
              59781: 39519,
              59782: 39522,
              59783: 39525,
              59784: 39524,
              59785: 39529,
              59786: 39531,
              59787: 39530,
              59788: 39597,
              59789: 39600,
              59790: 39612,
              59791: 39616,
              59792: 39631,
              59793: 39633,
              59794: 39635,
              59795: 39636,
              59796: 39646,
              59797: 39647,
              59798: 39650,
              59799: 39651,
              59800: 39654,
              59801: 39663,
              59802: 39659,
              59803: 39662,
              59804: 39668,
              59805: 39665,
              59806: 39671,
              59807: 39675,
              59808: 39686,
              59809: 39704,
              59810: 39706,
              59811: 39711,
              59812: 39714,
              59813: 39715,
              59814: 39717,
              59815: 39719,
              59816: 39720,
              59817: 39721,
              59818: 39722,
              59819: 39726,
              59820: 39727,
              59821: 39730,
              59822: 39748,
              59823: 39747,
              59824: 39759,
              59825: 39757,
              59826: 39758,
              59827: 39761,
              59828: 39768,
              59829: 39796,
              59830: 39827,
              59831: 39811,
              59832: 39825,
              59833: 39830,
              59834: 39831,
              59835: 39839,
              59836: 39840,
              59837: 39848,
              59838: 39860,
              59839: 39872,
              59840: 39882,
              59841: 39865,
              59842: 39878,
              59843: 39887,
              59844: 39889,
              59845: 39890,
              59846: 39907,
              59847: 39906,
              59848: 39908,
              59849: 39892,
              59850: 39905,
              59851: 39994,
              59852: 39922,
              59853: 39921,
              59854: 39920,
              59855: 39957,
              59856: 39956,
              59857: 39945,
              59858: 39955,
              59859: 39948,
              59860: 39942,
              59861: 39944,
              59862: 39954,
              59863: 39946,
              59864: 39940,
              59865: 39982,
              59866: 39963,
              59867: 39973,
              59868: 39972,
              59869: 39969,
              59870: 39984,
              59871: 40007,
              59872: 39986,
              59873: 40006,
              59874: 39998,
              59875: 40026,
              59876: 40032,
              59877: 40039,
              59878: 40054,
              59879: 40056,
              59880: 40167,
              59881: 40172,
              59882: 40176,
              59883: 40201,
              59884: 40200,
              59885: 40171,
              59886: 40195,
              59887: 40198,
              59888: 40234,
              59889: 40230,
              59890: 40367,
              59891: 40227,
              59892: 40223,
              59893: 40260,
              59894: 40213,
              59895: 40210,
              59896: 40257,
              59897: 40255,
              59898: 40254,
              59899: 40262,
              59900: 40264,
              59968: 40285,
              59969: 40286,
              59970: 40292,
              59971: 40273,
              59972: 40272,
              59973: 40281,
              59974: 40306,
              59975: 40329,
              59976: 40327,
              59977: 40363,
              59978: 40303,
              59979: 40314,
              59980: 40346,
              59981: 40356,
              59982: 40361,
              59983: 40370,
              59984: 40388,
              59985: 40385,
              59986: 40379,
              59987: 40376,
              59988: 40378,
              59989: 40390,
              59990: 40399,
              59991: 40386,
              59992: 40409,
              59993: 40403,
              59994: 40440,
              59995: 40422,
              59996: 40429,
              59997: 40431,
              59998: 40445,
              59999: 40474,
              6e4: 40475,
              60001: 40478,
              60002: 40565,
              60003: 40569,
              60004: 40573,
              60005: 40577,
              60006: 40584,
              60007: 40587,
              60008: 40588,
              60009: 40594,
              60010: 40597,
              60011: 40593,
              60012: 40605,
              60013: 40613,
              60014: 40617,
              60015: 40632,
              60016: 40618,
              60017: 40621,
              60018: 38753,
              60019: 40652,
              60020: 40654,
              60021: 40655,
              60022: 40656,
              60023: 40660,
              60024: 40668,
              60025: 40670,
              60026: 40669,
              60027: 40672,
              60028: 40677,
              60029: 40680,
              60030: 40687,
              60032: 40692,
              60033: 40694,
              60034: 40695,
              60035: 40697,
              60036: 40699,
              60037: 40700,
              60038: 40701,
              60039: 40711,
              60040: 40712,
              60041: 30391,
              60042: 40725,
              60043: 40737,
              60044: 40748,
              60045: 40766,
              60046: 40778,
              60047: 40786,
              60048: 40788,
              60049: 40803,
              60050: 40799,
              60051: 40800,
              60052: 40801,
              60053: 40806,
              60054: 40807,
              60055: 40812,
              60056: 40810,
              60057: 40823,
              60058: 40818,
              60059: 40822,
              60060: 40853,
              60061: 40860,
              60062: 40864,
              60063: 22575,
              60064: 27079,
              60065: 36953,
              60066: 29796,
              60067: 20956,
              60068: 29081
            };
          },
          /* 9 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var GenericGF_1 = __webpack_require__(1);
            var GenericGFPoly_1 = __webpack_require__(2);
            function runEuclideanAlgorithm(field, a2, b, R2) {
              var _a2;
              if (a2.degree() < b.degree()) {
                _a2 = [b, a2], a2 = _a2[0], b = _a2[1];
              }
              var rLast = a2;
              var r2 = b;
              var tLast = field.zero;
              var t = field.one;
              while (r2.degree() >= R2 / 2) {
                var rLastLast = rLast;
                var tLastLast = tLast;
                rLast = r2;
                tLast = t;
                if (rLast.isZero()) {
                  return null;
                }
                r2 = rLastLast;
                var q = field.zero;
                var denominatorLeadingTerm = rLast.getCoefficient(rLast.degree());
                var dltInverse = field.inverse(denominatorLeadingTerm);
                while (r2.degree() >= rLast.degree() && !r2.isZero()) {
                  var degreeDiff = r2.degree() - rLast.degree();
                  var scale = field.multiply(r2.getCoefficient(r2.degree()), dltInverse);
                  q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
                  r2 = r2.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
                }
                t = q.multiplyPoly(tLast).addOrSubtract(tLastLast);
                if (r2.degree() >= rLast.degree()) {
                  return null;
                }
              }
              var sigmaTildeAtZero = t.getCoefficient(0);
              if (sigmaTildeAtZero === 0) {
                return null;
              }
              var inverse = field.inverse(sigmaTildeAtZero);
              return [t.multiply(inverse), r2.multiply(inverse)];
            }
            function findErrorLocations(field, errorLocator) {
              var numErrors = errorLocator.degree();
              if (numErrors === 1) {
                return [errorLocator.getCoefficient(1)];
              }
              var result2 = new Array(numErrors);
              var errorCount = 0;
              for (var i2 = 1; i2 < field.size && errorCount < numErrors; i2++) {
                if (errorLocator.evaluateAt(i2) === 0) {
                  result2[errorCount] = field.inverse(i2);
                  errorCount++;
                }
              }
              if (errorCount !== numErrors) {
                return null;
              }
              return result2;
            }
            function findErrorMagnitudes(field, errorEvaluator, errorLocations) {
              var s2 = errorLocations.length;
              var result2 = new Array(s2);
              for (var i2 = 0; i2 < s2; i2++) {
                var xiInverse = field.inverse(errorLocations[i2]);
                var denominator = 1;
                for (var j = 0; j < s2; j++) {
                  if (i2 !== j) {
                    denominator = field.multiply(denominator, GenericGF_1.addOrSubtractGF(1, field.multiply(errorLocations[j], xiInverse)));
                  }
                }
                result2[i2] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
                if (field.generatorBase !== 0) {
                  result2[i2] = field.multiply(result2[i2], xiInverse);
                }
              }
              return result2;
            }
            function decode2(bytes, twoS) {
              var outputBytes = new Uint8ClampedArray(bytes.length);
              outputBytes.set(bytes);
              var field = new GenericGF_1.default(285, 256, 0);
              var poly = new GenericGFPoly_1.default(field, outputBytes);
              var syndromeCoefficients = new Uint8ClampedArray(twoS);
              var error2 = false;
              for (var s2 = 0; s2 < twoS; s2++) {
                var evaluation = poly.evaluateAt(field.exp(s2 + field.generatorBase));
                syndromeCoefficients[syndromeCoefficients.length - 1 - s2] = evaluation;
                if (evaluation !== 0) {
                  error2 = true;
                }
              }
              if (!error2) {
                return outputBytes;
              }
              var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
              var sigmaOmega = runEuclideanAlgorithm(field, field.buildMonomial(twoS, 1), syndrome, twoS);
              if (sigmaOmega === null) {
                return null;
              }
              var errorLocations = findErrorLocations(field, sigmaOmega[0]);
              if (errorLocations == null) {
                return null;
              }
              var errorMagnitudes = findErrorMagnitudes(field, sigmaOmega[1], errorLocations);
              for (var i2 = 0; i2 < errorLocations.length; i2++) {
                var position = outputBytes.length - 1 - field.log(errorLocations[i2]);
                if (position < 0) {
                  return null;
                }
                outputBytes[position] = GenericGF_1.addOrSubtractGF(outputBytes[position], errorMagnitudes[i2]);
              }
              return outputBytes;
            }
            exports2.decode = decode2;
          },
          /* 10 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.VERSIONS = [
              {
                infoBits: null,
                versionNumber: 1,
                alignmentPatternCenters: [],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 7,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 19 }]
                  },
                  {
                    ecCodewordsPerBlock: 10,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
                  },
                  {
                    ecCodewordsPerBlock: 13,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 13 }]
                  },
                  {
                    ecCodewordsPerBlock: 17,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 9 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 2,
                alignmentPatternCenters: [6, 18],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 10,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 34 }]
                  },
                  {
                    ecCodewordsPerBlock: 16,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 28 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 22 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 3,
                alignmentPatternCenters: [6, 22],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 15,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 55 }]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 44 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 17 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 13 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 4,
                alignmentPatternCenters: [6, 26],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 80 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 32 }]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 24 }]
                  },
                  {
                    ecCodewordsPerBlock: 16,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 9 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 5,
                alignmentPatternCenters: [6, 30],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 108 }]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 43 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 15 },
                      { numBlocks: 2, dataCodewordsPerBlock: 16 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 11 },
                      { numBlocks: 2, dataCodewordsPerBlock: 12 }
                    ]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 6,
                alignmentPatternCenters: [6, 34],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 68 }]
                  },
                  {
                    ecCodewordsPerBlock: 16,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 27 }]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 19 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 15 }]
                  }
                ]
              },
              {
                infoBits: 31892,
                versionNumber: 7,
                alignmentPatternCenters: [6, 22, 38],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 78 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 31 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 14 },
                      { numBlocks: 4, dataCodewordsPerBlock: 15 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 13 },
                      { numBlocks: 1, dataCodewordsPerBlock: 14 }
                    ]
                  }
                ]
              },
              {
                infoBits: 34236,
                versionNumber: 8,
                alignmentPatternCenters: [6, 24, 42],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 97 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 38 },
                      { numBlocks: 2, dataCodewordsPerBlock: 39 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 18 },
                      { numBlocks: 2, dataCodewordsPerBlock: 19 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 14 },
                      { numBlocks: 2, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 39577,
                versionNumber: 9,
                alignmentPatternCenters: [6, 26, 46],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 116 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 36 },
                      { numBlocks: 2, dataCodewordsPerBlock: 37 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 16 },
                      { numBlocks: 4, dataCodewordsPerBlock: 17 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 12 },
                      { numBlocks: 4, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 42195,
                versionNumber: 10,
                alignmentPatternCenters: [6, 28, 50],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 68 },
                      { numBlocks: 2, dataCodewordsPerBlock: 69 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 43 },
                      { numBlocks: 1, dataCodewordsPerBlock: 44 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 19 },
                      { numBlocks: 2, dataCodewordsPerBlock: 20 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 15 },
                      { numBlocks: 2, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 48118,
                versionNumber: 11,
                alignmentPatternCenters: [6, 30, 54],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 81 }]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 50 },
                      { numBlocks: 4, dataCodewordsPerBlock: 51 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 22 },
                      { numBlocks: 4, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 12 },
                      { numBlocks: 8, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 51042,
                versionNumber: 12,
                alignmentPatternCenters: [6, 32, 58],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 92 },
                      { numBlocks: 2, dataCodewordsPerBlock: 93 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 36 },
                      { numBlocks: 2, dataCodewordsPerBlock: 37 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 20 },
                      { numBlocks: 6, dataCodewordsPerBlock: 21 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 14 },
                      { numBlocks: 4, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 55367,
                versionNumber: 13,
                alignmentPatternCenters: [6, 34, 62],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 107 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 37 },
                      { numBlocks: 1, dataCodewordsPerBlock: 38 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 20 },
                      { numBlocks: 4, dataCodewordsPerBlock: 21 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 11 },
                      { numBlocks: 4, dataCodewordsPerBlock: 12 }
                    ]
                  }
                ]
              },
              {
                infoBits: 58893,
                versionNumber: 14,
                alignmentPatternCenters: [6, 26, 46, 66],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 115 },
                      { numBlocks: 1, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 40 },
                      { numBlocks: 5, dataCodewordsPerBlock: 41 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 16 },
                      { numBlocks: 5, dataCodewordsPerBlock: 17 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 12 },
                      { numBlocks: 5, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 63784,
                versionNumber: 15,
                alignmentPatternCenters: [6, 26, 48, 70],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 87 },
                      { numBlocks: 1, dataCodewordsPerBlock: 88 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 41 },
                      { numBlocks: 5, dataCodewordsPerBlock: 42 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 24 },
                      { numBlocks: 7, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 12 },
                      { numBlocks: 7, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 68472,
                versionNumber: 16,
                alignmentPatternCenters: [6, 26, 50, 74],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 98 },
                      { numBlocks: 1, dataCodewordsPerBlock: 99 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 45 },
                      { numBlocks: 3, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 19 },
                      { numBlocks: 2, dataCodewordsPerBlock: 20 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 15 },
                      { numBlocks: 13, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 70749,
                versionNumber: 17,
                alignmentPatternCenters: [6, 30, 54, 78],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 107 },
                      { numBlocks: 5, dataCodewordsPerBlock: 108 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 46 },
                      { numBlocks: 1, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 22 },
                      { numBlocks: 15, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 14 },
                      { numBlocks: 17, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 76311,
                versionNumber: 18,
                alignmentPatternCenters: [6, 30, 56, 82],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 120 },
                      { numBlocks: 1, dataCodewordsPerBlock: 121 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 9, dataCodewordsPerBlock: 43 },
                      { numBlocks: 4, dataCodewordsPerBlock: 44 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 22 },
                      { numBlocks: 1, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 14 },
                      { numBlocks: 19, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 79154,
                versionNumber: 19,
                alignmentPatternCenters: [6, 30, 58, 86],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 113 },
                      { numBlocks: 4, dataCodewordsPerBlock: 114 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 44 },
                      { numBlocks: 11, dataCodewordsPerBlock: 45 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 21 },
                      { numBlocks: 4, dataCodewordsPerBlock: 22 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 9, dataCodewordsPerBlock: 13 },
                      { numBlocks: 16, dataCodewordsPerBlock: 14 }
                    ]
                  }
                ]
              },
              {
                infoBits: 84390,
                versionNumber: 20,
                alignmentPatternCenters: [6, 34, 62, 90],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 107 },
                      { numBlocks: 5, dataCodewordsPerBlock: 108 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 41 },
                      { numBlocks: 13, dataCodewordsPerBlock: 42 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 24 },
                      { numBlocks: 5, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 15 },
                      { numBlocks: 10, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 87683,
                versionNumber: 21,
                alignmentPatternCenters: [6, 28, 50, 72, 94],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 116 },
                      { numBlocks: 4, dataCodewordsPerBlock: 117 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 42 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 22 },
                      { numBlocks: 6, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 16 },
                      { numBlocks: 6, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 92361,
                versionNumber: 22,
                alignmentPatternCenters: [6, 26, 50, 74, 98],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 111 },
                      { numBlocks: 7, dataCodewordsPerBlock: 112 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 46 }]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 24 },
                      { numBlocks: 16, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 34, dataCodewordsPerBlock: 13 }]
                  }
                ]
              },
              {
                infoBits: 96236,
                versionNumber: 23,
                alignmentPatternCenters: [6, 30, 54, 74, 102],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 121 },
                      { numBlocks: 5, dataCodewordsPerBlock: 122 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 47 },
                      { numBlocks: 14, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 24 },
                      { numBlocks: 14, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 16, dataCodewordsPerBlock: 15 },
                      { numBlocks: 14, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 102084,
                versionNumber: 24,
                alignmentPatternCenters: [6, 28, 54, 80, 106],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 117 },
                      { numBlocks: 4, dataCodewordsPerBlock: 118 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 45 },
                      { numBlocks: 14, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 24 },
                      { numBlocks: 16, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 30, dataCodewordsPerBlock: 16 },
                      { numBlocks: 2, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 102881,
                versionNumber: 25,
                alignmentPatternCenters: [6, 32, 58, 84, 110],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 106 },
                      { numBlocks: 4, dataCodewordsPerBlock: 107 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 47 },
                      { numBlocks: 13, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 24 },
                      { numBlocks: 22, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 22, dataCodewordsPerBlock: 15 },
                      { numBlocks: 13, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 110507,
                versionNumber: 26,
                alignmentPatternCenters: [6, 30, 58, 86, 114],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 114 },
                      { numBlocks: 2, dataCodewordsPerBlock: 115 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 46 },
                      { numBlocks: 4, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 28, dataCodewordsPerBlock: 22 },
                      { numBlocks: 6, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 33, dataCodewordsPerBlock: 16 },
                      { numBlocks: 4, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 110734,
                versionNumber: 27,
                alignmentPatternCenters: [6, 34, 62, 90, 118],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 122 },
                      { numBlocks: 4, dataCodewordsPerBlock: 123 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 22, dataCodewordsPerBlock: 45 },
                      { numBlocks: 3, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 23 },
                      { numBlocks: 26, dataCodewordsPerBlock: 24 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 15 },
                      { numBlocks: 28, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 117786,
                versionNumber: 28,
                alignmentPatternCenters: [6, 26, 50, 74, 98, 122],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 117 },
                      { numBlocks: 10, dataCodewordsPerBlock: 118 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 45 },
                      { numBlocks: 23, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 24 },
                      { numBlocks: 31, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 15 },
                      { numBlocks: 31, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 119615,
                versionNumber: 29,
                alignmentPatternCenters: [6, 30, 54, 78, 102, 126],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 116 },
                      { numBlocks: 7, dataCodewordsPerBlock: 117 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 21, dataCodewordsPerBlock: 45 },
                      { numBlocks: 7, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 23 },
                      { numBlocks: 37, dataCodewordsPerBlock: 24 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 15 },
                      { numBlocks: 26, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 126325,
                versionNumber: 30,
                alignmentPatternCenters: [6, 26, 52, 78, 104, 130],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 115 },
                      { numBlocks: 10, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 47 },
                      { numBlocks: 10, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 24 },
                      { numBlocks: 25, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 23, dataCodewordsPerBlock: 15 },
                      { numBlocks: 25, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 127568,
                versionNumber: 31,
                alignmentPatternCenters: [6, 30, 56, 82, 108, 134],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 13, dataCodewordsPerBlock: 115 },
                      { numBlocks: 3, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 46 },
                      { numBlocks: 29, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 42, dataCodewordsPerBlock: 24 },
                      { numBlocks: 1, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 23, dataCodewordsPerBlock: 15 },
                      { numBlocks: 28, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 133589,
                versionNumber: 32,
                alignmentPatternCenters: [6, 34, 60, 86, 112, 138],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 115 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 46 },
                      { numBlocks: 23, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 24 },
                      { numBlocks: 35, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 15 },
                      { numBlocks: 35, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 136944,
                versionNumber: 33,
                alignmentPatternCenters: [6, 30, 58, 86, 114, 142],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 115 },
                      { numBlocks: 1, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 14, dataCodewordsPerBlock: 46 },
                      { numBlocks: 21, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 29, dataCodewordsPerBlock: 24 },
                      { numBlocks: 19, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 15 },
                      { numBlocks: 46, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 141498,
                versionNumber: 34,
                alignmentPatternCenters: [6, 34, 62, 90, 118, 146],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 13, dataCodewordsPerBlock: 115 },
                      { numBlocks: 6, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 14, dataCodewordsPerBlock: 46 },
                      { numBlocks: 23, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 44, dataCodewordsPerBlock: 24 },
                      { numBlocks: 7, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 59, dataCodewordsPerBlock: 16 },
                      { numBlocks: 1, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 145311,
                versionNumber: 35,
                alignmentPatternCenters: [6, 30, 54, 78, 102, 126, 150],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 121 },
                      { numBlocks: 7, dataCodewordsPerBlock: 122 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 47 },
                      { numBlocks: 26, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 39, dataCodewordsPerBlock: 24 },
                      { numBlocks: 14, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 22, dataCodewordsPerBlock: 15 },
                      { numBlocks: 41, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 150283,
                versionNumber: 36,
                alignmentPatternCenters: [6, 24, 50, 76, 102, 128, 154],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 121 },
                      { numBlocks: 14, dataCodewordsPerBlock: 122 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 47 },
                      { numBlocks: 34, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 46, dataCodewordsPerBlock: 24 },
                      { numBlocks: 10, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 15 },
                      { numBlocks: 64, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 152622,
                versionNumber: 37,
                alignmentPatternCenters: [6, 28, 54, 80, 106, 132, 158],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 122 },
                      { numBlocks: 4, dataCodewordsPerBlock: 123 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 29, dataCodewordsPerBlock: 46 },
                      { numBlocks: 14, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 49, dataCodewordsPerBlock: 24 },
                      { numBlocks: 10, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 24, dataCodewordsPerBlock: 15 },
                      { numBlocks: 46, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 158308,
                versionNumber: 38,
                alignmentPatternCenters: [6, 32, 58, 84, 110, 136, 162],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 122 },
                      { numBlocks: 18, dataCodewordsPerBlock: 123 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 13, dataCodewordsPerBlock: 46 },
                      { numBlocks: 32, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 48, dataCodewordsPerBlock: 24 },
                      { numBlocks: 14, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 42, dataCodewordsPerBlock: 15 },
                      { numBlocks: 32, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 161089,
                versionNumber: 39,
                alignmentPatternCenters: [6, 26, 54, 82, 110, 138, 166],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 20, dataCodewordsPerBlock: 117 },
                      { numBlocks: 4, dataCodewordsPerBlock: 118 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 40, dataCodewordsPerBlock: 47 },
                      { numBlocks: 7, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 43, dataCodewordsPerBlock: 24 },
                      { numBlocks: 22, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 15 },
                      { numBlocks: 67, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 167017,
                versionNumber: 40,
                alignmentPatternCenters: [6, 30, 58, 86, 114, 142, 170],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 118 },
                      { numBlocks: 6, dataCodewordsPerBlock: 119 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 18, dataCodewordsPerBlock: 47 },
                      { numBlocks: 31, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 34, dataCodewordsPerBlock: 24 },
                      { numBlocks: 34, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 20, dataCodewordsPerBlock: 15 },
                      { numBlocks: 61, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              }
            ];
          },
          /* 11 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix_1 = __webpack_require__(0);
            function squareToQuadrilateral(p1, p2, p3, p4) {
              var dx3 = p1.x - p2.x + p3.x - p4.x;
              var dy3 = p1.y - p2.y + p3.y - p4.y;
              if (dx3 === 0 && dy3 === 0) {
                return {
                  a11: p2.x - p1.x,
                  a12: p2.y - p1.y,
                  a13: 0,
                  a21: p3.x - p2.x,
                  a22: p3.y - p2.y,
                  a23: 0,
                  a31: p1.x,
                  a32: p1.y,
                  a33: 1
                };
              } else {
                var dx1 = p2.x - p3.x;
                var dx2 = p4.x - p3.x;
                var dy1 = p2.y - p3.y;
                var dy2 = p4.y - p3.y;
                var denominator = dx1 * dy2 - dx2 * dy1;
                var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
                var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
                return {
                  a11: p2.x - p1.x + a13 * p2.x,
                  a12: p2.y - p1.y + a13 * p2.y,
                  a13,
                  a21: p4.x - p1.x + a23 * p4.x,
                  a22: p4.y - p1.y + a23 * p4.y,
                  a23,
                  a31: p1.x,
                  a32: p1.y,
                  a33: 1
                };
              }
            }
            function quadrilateralToSquare(p1, p2, p3, p4) {
              var sToQ = squareToQuadrilateral(p1, p2, p3, p4);
              return {
                a11: sToQ.a22 * sToQ.a33 - sToQ.a23 * sToQ.a32,
                a12: sToQ.a13 * sToQ.a32 - sToQ.a12 * sToQ.a33,
                a13: sToQ.a12 * sToQ.a23 - sToQ.a13 * sToQ.a22,
                a21: sToQ.a23 * sToQ.a31 - sToQ.a21 * sToQ.a33,
                a22: sToQ.a11 * sToQ.a33 - sToQ.a13 * sToQ.a31,
                a23: sToQ.a13 * sToQ.a21 - sToQ.a11 * sToQ.a23,
                a31: sToQ.a21 * sToQ.a32 - sToQ.a22 * sToQ.a31,
                a32: sToQ.a12 * sToQ.a31 - sToQ.a11 * sToQ.a32,
                a33: sToQ.a11 * sToQ.a22 - sToQ.a12 * sToQ.a21
              };
            }
            function times(a2, b) {
              return {
                a11: a2.a11 * b.a11 + a2.a21 * b.a12 + a2.a31 * b.a13,
                a12: a2.a12 * b.a11 + a2.a22 * b.a12 + a2.a32 * b.a13,
                a13: a2.a13 * b.a11 + a2.a23 * b.a12 + a2.a33 * b.a13,
                a21: a2.a11 * b.a21 + a2.a21 * b.a22 + a2.a31 * b.a23,
                a22: a2.a12 * b.a21 + a2.a22 * b.a22 + a2.a32 * b.a23,
                a23: a2.a13 * b.a21 + a2.a23 * b.a22 + a2.a33 * b.a23,
                a31: a2.a11 * b.a31 + a2.a21 * b.a32 + a2.a31 * b.a33,
                a32: a2.a12 * b.a31 + a2.a22 * b.a32 + a2.a32 * b.a33,
                a33: a2.a13 * b.a31 + a2.a23 * b.a32 + a2.a33 * b.a33
              };
            }
            function extract(image, location) {
              var qToS = quadrilateralToSquare({ x: 3.5, y: 3.5 }, { x: location.dimension - 3.5, y: 3.5 }, { x: location.dimension - 6.5, y: location.dimension - 6.5 }, { x: 3.5, y: location.dimension - 3.5 });
              var sToQ = squareToQuadrilateral(location.topLeft, location.topRight, location.alignmentPattern, location.bottomLeft);
              var transform = times(sToQ, qToS);
              var matrix = BitMatrix_1.BitMatrix.createEmpty(location.dimension, location.dimension);
              var mappingFunction = function(x3, y3) {
                var denominator = transform.a13 * x3 + transform.a23 * y3 + transform.a33;
                return {
                  x: (transform.a11 * x3 + transform.a21 * y3 + transform.a31) / denominator,
                  y: (transform.a12 * x3 + transform.a22 * y3 + transform.a32) / denominator
                };
              };
              for (var y2 = 0; y2 < location.dimension; y2++) {
                for (var x2 = 0; x2 < location.dimension; x2++) {
                  var xValue = x2 + 0.5;
                  var yValue = y2 + 0.5;
                  var sourcePixel = mappingFunction(xValue, yValue);
                  matrix.set(x2, y2, image.get(Math.floor(sourcePixel.x), Math.floor(sourcePixel.y)));
                }
              }
              return {
                matrix,
                mappingFunction
              };
            }
            exports2.extract = extract;
          },
          /* 12 */
          /***/
          function(module3, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", { value: true });
            var MAX_FINDERPATTERNS_TO_SEARCH = 4;
            var MIN_QUAD_RATIO = 0.5;
            var MAX_QUAD_RATIO = 1.5;
            var distance = function(a2, b) {
              return Math.sqrt(Math.pow(b.x - a2.x, 2) + Math.pow(b.y - a2.y, 2));
            };
            function sum(values) {
              return values.reduce(function(a2, b) {
                return a2 + b;
              });
            }
            function reorderFinderPatterns(pattern1, pattern2, pattern3) {
              var _a2, _b2, _c2, _d2;
              var oneTwoDistance = distance(pattern1, pattern2);
              var twoThreeDistance = distance(pattern2, pattern3);
              var oneThreeDistance = distance(pattern1, pattern3);
              var bottomLeft;
              var topLeft;
              var topRight;
              if (twoThreeDistance >= oneTwoDistance && twoThreeDistance >= oneThreeDistance) {
                _a2 = [pattern2, pattern1, pattern3], bottomLeft = _a2[0], topLeft = _a2[1], topRight = _a2[2];
              } else if (oneThreeDistance >= twoThreeDistance && oneThreeDistance >= oneTwoDistance) {
                _b2 = [pattern1, pattern2, pattern3], bottomLeft = _b2[0], topLeft = _b2[1], topRight = _b2[2];
              } else {
                _c2 = [pattern1, pattern3, pattern2], bottomLeft = _c2[0], topLeft = _c2[1], topRight = _c2[2];
              }
              if ((topRight.x - topLeft.x) * (bottomLeft.y - topLeft.y) - (topRight.y - topLeft.y) * (bottomLeft.x - topLeft.x) < 0) {
                _d2 = [topRight, bottomLeft], bottomLeft = _d2[0], topRight = _d2[1];
              }
              return { bottomLeft, topLeft, topRight };
            }
            function computeDimension(topLeft, topRight, bottomLeft, matrix) {
              var moduleSize = (sum(countBlackWhiteRun(topLeft, bottomLeft, matrix, 5)) / 7 + // Divide by 7 since the ratio is 1:1:3:1:1
              sum(countBlackWhiteRun(topLeft, topRight, matrix, 5)) / 7 + sum(countBlackWhiteRun(bottomLeft, topLeft, matrix, 5)) / 7 + sum(countBlackWhiteRun(topRight, topLeft, matrix, 5)) / 7) / 4;
              if (moduleSize < 1) {
                throw new Error("Invalid module size");
              }
              var topDimension = Math.round(distance(topLeft, topRight) / moduleSize);
              var sideDimension = Math.round(distance(topLeft, bottomLeft) / moduleSize);
              var dimension = Math.floor((topDimension + sideDimension) / 2) + 7;
              switch (dimension % 4) {
                case 0:
                  dimension++;
                  break;
                case 2:
                  dimension--;
                  break;
              }
              return { dimension, moduleSize };
            }
            function countBlackWhiteRunTowardsPoint(origin, end, matrix, length) {
              var switchPoints = [{ x: Math.floor(origin.x), y: Math.floor(origin.y) }];
              var steep = Math.abs(end.y - origin.y) > Math.abs(end.x - origin.x);
              var fromX;
              var fromY;
              var toX;
              var toY;
              if (steep) {
                fromX = Math.floor(origin.y);
                fromY = Math.floor(origin.x);
                toX = Math.floor(end.y);
                toY = Math.floor(end.x);
              } else {
                fromX = Math.floor(origin.x);
                fromY = Math.floor(origin.y);
                toX = Math.floor(end.x);
                toY = Math.floor(end.y);
              }
              var dx = Math.abs(toX - fromX);
              var dy = Math.abs(toY - fromY);
              var error2 = Math.floor(-dx / 2);
              var xStep = fromX < toX ? 1 : -1;
              var yStep = fromY < toY ? 1 : -1;
              var currentPixel = true;
              for (var x2 = fromX, y2 = fromY; x2 !== toX + xStep; x2 += xStep) {
                var realX = steep ? y2 : x2;
                var realY = steep ? x2 : y2;
                if (matrix.get(realX, realY) !== currentPixel) {
                  currentPixel = !currentPixel;
                  switchPoints.push({ x: realX, y: realY });
                  if (switchPoints.length === length + 1) {
                    break;
                  }
                }
                error2 += dy;
                if (error2 > 0) {
                  if (y2 === toY) {
                    break;
                  }
                  y2 += yStep;
                  error2 -= dx;
                }
              }
              var distances = [];
              for (var i2 = 0; i2 < length; i2++) {
                if (switchPoints[i2] && switchPoints[i2 + 1]) {
                  distances.push(distance(switchPoints[i2], switchPoints[i2 + 1]));
                } else {
                  distances.push(0);
                }
              }
              return distances;
            }
            function countBlackWhiteRun(origin, end, matrix, length) {
              var _a2;
              var rise = end.y - origin.y;
              var run = end.x - origin.x;
              var towardsEnd = countBlackWhiteRunTowardsPoint(origin, end, matrix, Math.ceil(length / 2));
              var awayFromEnd = countBlackWhiteRunTowardsPoint(origin, { x: origin.x - run, y: origin.y - rise }, matrix, Math.ceil(length / 2));
              var middleValue = towardsEnd.shift() + awayFromEnd.shift() - 1;
              return (_a2 = awayFromEnd.concat(middleValue)).concat.apply(_a2, towardsEnd);
            }
            function scoreBlackWhiteRun(sequence, ratios) {
              var averageSize = sum(sequence) / sum(ratios);
              var error2 = 0;
              ratios.forEach(function(ratio, i2) {
                error2 += Math.pow(sequence[i2] - ratio * averageSize, 2);
              });
              return { averageSize, error: error2 };
            }
            function scorePattern(point, ratios, matrix) {
              try {
                var horizontalRun = countBlackWhiteRun(point, { x: -1, y: point.y }, matrix, ratios.length);
                var verticalRun = countBlackWhiteRun(point, { x: point.x, y: -1 }, matrix, ratios.length);
                var topLeftPoint = {
                  x: Math.max(0, point.x - point.y) - 1,
                  y: Math.max(0, point.y - point.x) - 1
                };
                var topLeftBottomRightRun = countBlackWhiteRun(point, topLeftPoint, matrix, ratios.length);
                var bottomLeftPoint = {
                  x: Math.min(matrix.width, point.x + point.y) + 1,
                  y: Math.min(matrix.height, point.y + point.x) + 1
                };
                var bottomLeftTopRightRun = countBlackWhiteRun(point, bottomLeftPoint, matrix, ratios.length);
                var horzError = scoreBlackWhiteRun(horizontalRun, ratios);
                var vertError = scoreBlackWhiteRun(verticalRun, ratios);
                var diagDownError = scoreBlackWhiteRun(topLeftBottomRightRun, ratios);
                var diagUpError = scoreBlackWhiteRun(bottomLeftTopRightRun, ratios);
                var ratioError = Math.sqrt(horzError.error * horzError.error + vertError.error * vertError.error + diagDownError.error * diagDownError.error + diagUpError.error * diagUpError.error);
                var avgSize = (horzError.averageSize + vertError.averageSize + diagDownError.averageSize + diagUpError.averageSize) / 4;
                var sizeError = (Math.pow(horzError.averageSize - avgSize, 2) + Math.pow(vertError.averageSize - avgSize, 2) + Math.pow(diagDownError.averageSize - avgSize, 2) + Math.pow(diagUpError.averageSize - avgSize, 2)) / avgSize;
                return ratioError + sizeError;
              } catch (_a2) {
                return Infinity;
              }
            }
            function recenterLocation(matrix, p2) {
              var leftX = Math.round(p2.x);
              while (matrix.get(leftX, Math.round(p2.y))) {
                leftX--;
              }
              var rightX = Math.round(p2.x);
              while (matrix.get(rightX, Math.round(p2.y))) {
                rightX++;
              }
              var x2 = (leftX + rightX) / 2;
              var topY = Math.round(p2.y);
              while (matrix.get(Math.round(x2), topY)) {
                topY--;
              }
              var bottomY = Math.round(p2.y);
              while (matrix.get(Math.round(x2), bottomY)) {
                bottomY++;
              }
              var y2 = (topY + bottomY) / 2;
              return { x: x2, y: y2 };
            }
            function locate(matrix) {
              var finderPatternQuads = [];
              var activeFinderPatternQuads = [];
              var alignmentPatternQuads = [];
              var activeAlignmentPatternQuads = [];
              var _loop_1 = function(y3) {
                var length_1 = 0;
                var lastBit = false;
                var scans = [0, 0, 0, 0, 0];
                var _loop_2 = function(x3) {
                  var v2 = matrix.get(x3, y3);
                  if (v2 === lastBit) {
                    length_1++;
                  } else {
                    scans = [scans[1], scans[2], scans[3], scans[4], length_1];
                    length_1 = 1;
                    lastBit = v2;
                    var averageFinderPatternBlocksize = sum(scans) / 7;
                    var validFinderPattern = Math.abs(scans[0] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[1] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[2] - 3 * averageFinderPatternBlocksize) < 3 * averageFinderPatternBlocksize && Math.abs(scans[3] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[4] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && !v2;
                    var averageAlignmentPatternBlocksize = sum(scans.slice(-3)) / 3;
                    var validAlignmentPattern = Math.abs(scans[2] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[3] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[4] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && v2;
                    if (validFinderPattern) {
                      var endX_1 = x3 - scans[3] - scans[4];
                      var startX_1 = endX_1 - scans[2];
                      var line = { startX: startX_1, endX: endX_1, y: y3 };
                      var matchingQuads = activeFinderPatternQuads.filter(function(q) {
                        return startX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX || endX_1 >= q.bottom.startX && startX_1 <= q.bottom.endX || startX_1 <= q.bottom.startX && endX_1 >= q.bottom.endX && (scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO);
                      });
                      if (matchingQuads.length > 0) {
                        matchingQuads[0].bottom = line;
                      } else {
                        activeFinderPatternQuads.push({ top: line, bottom: line });
                      }
                    }
                    if (validAlignmentPattern) {
                      var endX_2 = x3 - scans[4];
                      var startX_2 = endX_2 - scans[3];
                      var line = { startX: startX_2, y: y3, endX: endX_2 };
                      var matchingQuads = activeAlignmentPatternQuads.filter(function(q) {
                        return startX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX || endX_2 >= q.bottom.startX && startX_2 <= q.bottom.endX || startX_2 <= q.bottom.startX && endX_2 >= q.bottom.endX && (scans[2] / (q.bottom.endX - q.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q.bottom.endX - q.bottom.startX) > MIN_QUAD_RATIO);
                      });
                      if (matchingQuads.length > 0) {
                        matchingQuads[0].bottom = line;
                      } else {
                        activeAlignmentPatternQuads.push({ top: line, bottom: line });
                      }
                    }
                  }
                };
                for (var x2 = -1; x2 <= matrix.width; x2++) {
                  _loop_2(x2);
                }
                finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q) {
                  return q.bottom.y !== y3 && q.bottom.y - q.top.y >= 2;
                }));
                activeFinderPatternQuads = activeFinderPatternQuads.filter(function(q) {
                  return q.bottom.y === y3;
                });
                alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads.filter(function(q) {
                  return q.bottom.y !== y3;
                }));
                activeAlignmentPatternQuads = activeAlignmentPatternQuads.filter(function(q) {
                  return q.bottom.y === y3;
                });
              };
              for (var y2 = 0; y2 <= matrix.height; y2++) {
                _loop_1(y2);
              }
              finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q) {
                return q.bottom.y - q.top.y >= 2;
              }));
              alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads);
              var finderPatternGroups = finderPatternQuads.filter(function(q) {
                return q.bottom.y - q.top.y >= 2;
              }).map(function(q) {
                var x2 = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
                var y3 = (q.top.y + q.bottom.y + 1) / 2;
                if (!matrix.get(Math.round(x2), Math.round(y3))) {
                  return;
                }
                var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1];
                var size = sum(lengths) / lengths.length;
                var score = scorePattern({ x: Math.round(x2), y: Math.round(y3) }, [1, 1, 3, 1, 1], matrix);
                return { score, x: x2, y: y3, size };
              }).filter(function(q) {
                return !!q;
              }).sort(function(a2, b) {
                return a2.score - b.score;
              }).map(function(point, i2, finderPatterns) {
                if (i2 > MAX_FINDERPATTERNS_TO_SEARCH) {
                  return null;
                }
                var otherPoints = finderPatterns.filter(function(p2, ii) {
                  return i2 !== ii;
                }).map(function(p2) {
                  return { x: p2.x, y: p2.y, score: p2.score + Math.pow(p2.size - point.size, 2) / point.size, size: p2.size };
                }).sort(function(a2, b) {
                  return a2.score - b.score;
                });
                if (otherPoints.length < 2) {
                  return null;
                }
                var score = point.score + otherPoints[0].score + otherPoints[1].score;
                return { points: [point].concat(otherPoints.slice(0, 2)), score };
              }).filter(function(q) {
                return !!q;
              }).sort(function(a2, b) {
                return a2.score - b.score;
              });
              if (finderPatternGroups.length === 0) {
                return null;
              }
              var _a2 = reorderFinderPatterns(finderPatternGroups[0].points[0], finderPatternGroups[0].points[1], finderPatternGroups[0].points[2]), topRight = _a2.topRight, topLeft = _a2.topLeft, bottomLeft = _a2.bottomLeft;
              var alignment = findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft);
              var result2 = [];
              if (alignment) {
                result2.push({
                  alignmentPattern: { x: alignment.alignmentPattern.x, y: alignment.alignmentPattern.y },
                  bottomLeft: { x: bottomLeft.x, y: bottomLeft.y },
                  dimension: alignment.dimension,
                  topLeft: { x: topLeft.x, y: topLeft.y },
                  topRight: { x: topRight.x, y: topRight.y }
                });
              }
              var midTopRight = recenterLocation(matrix, topRight);
              var midTopLeft = recenterLocation(matrix, topLeft);
              var midBottomLeft = recenterLocation(matrix, bottomLeft);
              var centeredAlignment = findAlignmentPattern(matrix, alignmentPatternQuads, midTopRight, midTopLeft, midBottomLeft);
              if (centeredAlignment) {
                result2.push({
                  alignmentPattern: { x: centeredAlignment.alignmentPattern.x, y: centeredAlignment.alignmentPattern.y },
                  bottomLeft: { x: midBottomLeft.x, y: midBottomLeft.y },
                  topLeft: { x: midTopLeft.x, y: midTopLeft.y },
                  topRight: { x: midTopRight.x, y: midTopRight.y },
                  dimension: centeredAlignment.dimension
                });
              }
              if (result2.length === 0) {
                return null;
              }
              return result2;
            }
            exports2.locate = locate;
            function findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft) {
              var _a2;
              var dimension;
              var moduleSize;
              try {
                _a2 = computeDimension(topLeft, topRight, bottomLeft, matrix), dimension = _a2.dimension, moduleSize = _a2.moduleSize;
              } catch (e) {
                return null;
              }
              var bottomRightFinderPattern = {
                x: topRight.x - topLeft.x + bottomLeft.x,
                y: topRight.y - topLeft.y + bottomLeft.y
              };
              var modulesBetweenFinderPatterns = (distance(topLeft, bottomLeft) + distance(topLeft, topRight)) / 2 / moduleSize;
              var correctionToTopLeft = 1 - 3 / modulesBetweenFinderPatterns;
              var expectedAlignmentPattern = {
                x: topLeft.x + correctionToTopLeft * (bottomRightFinderPattern.x - topLeft.x),
                y: topLeft.y + correctionToTopLeft * (bottomRightFinderPattern.y - topLeft.y)
              };
              var alignmentPatterns = alignmentPatternQuads.map(function(q) {
                var x2 = (q.top.startX + q.top.endX + q.bottom.startX + q.bottom.endX) / 4;
                var y2 = (q.top.y + q.bottom.y + 1) / 2;
                if (!matrix.get(Math.floor(x2), Math.floor(y2))) {
                  return;
                }
                var lengths = [q.top.endX - q.top.startX, q.bottom.endX - q.bottom.startX, q.bottom.y - q.top.y + 1];
                sum(lengths) / lengths.length;
                var sizeScore = scorePattern({ x: Math.floor(x2), y: Math.floor(y2) }, [1, 1, 1], matrix);
                var score = sizeScore + distance({ x: x2, y: y2 }, expectedAlignmentPattern);
                return { x: x2, y: y2, score };
              }).filter(function(v2) {
                return !!v2;
              }).sort(function(a2, b) {
                return a2.score - b.score;
              });
              var alignmentPattern = modulesBetweenFinderPatterns >= 15 && alignmentPatterns.length ? alignmentPatterns[0] : expectedAlignmentPattern;
              return { alignmentPattern, dimension };
            }
          }
          /******/
        ])["default"]
      );
    });
  })(jsQR$1);
  var jsQRExports = jsQR$1.exports;
  const jsQR = /* @__PURE__ */ getDefaultExportFromCjs(jsQRExports);
  class ToptQrDetectionHandler {
    constructor() {
      __publicField(this, "lastCaptureVisibleTabCallTimestamp", 0);
      __publicField(this, "messageListener", makeMessageListener({
        DetectTotpQrSecretForTab: (msg, sender) => this.getTotpSetupCode(sender, msg.rects, msg.devicePixelRatio)
      }));
    }
    init() {
      eventProxy.addListener("runtime.onMessage", this.messageListener);
    }
    close() {
      eventProxy.removeListener("runtime.onMessage", this.messageListener);
    }
    async getTotpSetupCode(sender, rects, devicePixelRatio) {
      const tab = await extractTargetTab(sender);
      if (!tab) {
        return {
          status: "notFound"
        };
      }
      const now = Date.now();
      if (now - this.lastCaptureVisibleTabCallTimestamp <= 500) {
        return {
          status: "retryLater"
        };
      }
      this.lastCaptureVisibleTabCallTimestamp = now;
      let imageDataUri;
      try {
        imageDataUri = await browser$1.tabs.captureVisibleTab(tab.windowId, {
          format: "png"
        });
      } catch (e) {
        if (
          // Some transient errors can happen here. For these we instruct the content script to retry
          // with some delay, in the hope that error cause has resolved itself by the time of the
          // retry.
          isWebExtError(
            e,
            // Error happens in chrome when we call captureVisibleTab while a drag is in progress.
            "TAB_DRAG_IN_PROGRESS",
            // Error happens in chrome for unclear reasons. It can reliably be triggered by reloading
            // the extension while a page showing a totp qr code is open.
            "ACTIVE_TAB_PERMISSION_NOT_IN_EFFECT",
            // The following errors happens in chrome intermittently for unclear reasons.
            "CAPTURE_TAB_IMAGE_READBACK_FAILED",
            "CANNOT_ACCESS_CONTENTS_OF_URL",
            "ALL_URLS_OR_ACTIVE_TAB_PERMISSION_REQUIRED",
            "ERROR_CAPTURING_VISIBLE_TAB"
          )
        ) {
          return {
            status: "retryLater"
          };
        }
        if (
          // Some non-transient errors can also happen. We just won't retry (until the user to the
          // navigates to the website again).
          isWebExtError(
            e,
            // Error happens if we don't have the host permission assigned. This usually happens in
            // Safari if the user has not granted permissions (currently), in that case we'll just
            // accept the QR scanning mechanism doesn't work.
            "PERMISSION_ERROR"
          )
        ) {
          return {
            status: "notFound"
          };
        }
        trackError(new Error("Failed capture visible tab", {
          cause: e
        }));
        return {
          status: "notFound"
        };
      }
      const blob = await fetch(imageDataUri).then((r2) => r2.blob());
      const imageBitmap = await createImageBitmap(blob);
      const rect = getBoundingRect(rects);
      const {
        imageData,
        width,
        height
      } = await getImageData(imageBitmap, rect, devicePixelRatio);
      const qrCodeResult = jsQR(imageData.data, width, height);
      if (!qrCodeResult) {
        return {
          status: "notFound"
        };
      }
      const totpParameters = getTotpParametersFromOtpauthUrl(qrCodeResult.data);
      if (!totpParameters) {
        return {
          status: "notFound"
        };
      }
      return {
        status: "found",
        totpParameters,
        x: qrCodeResult.location.topLeftFinderPattern.x + rect.x,
        y: qrCodeResult.location.topLeftFinderPattern.y + rect.y
      };
    }
  }
  async function getImageData(imageBitmap, {
    x: x2,
    y: y2,
    width,
    height
  }, devicePixelRatio) {
    const canvas = new OffscreenCanvas(
      // never make the canvas larger than the source image
      Math.min(width, imageBitmap.width / devicePixelRatio),
      Math.min(height, imageBitmap.height / devicePixelRatio)
    );
    const context = canvas.getContext("2d");
    context.drawImage(
      imageBitmap,
      // Scale css pixels to source image coordinates
      x2 * devicePixelRatio,
      y2 * devicePixelRatio,
      width * devicePixelRatio,
      height * devicePixelRatio,
      // Destination uses css pixels. This will effectively scale the image to a pixel ratio of 1
      0,
      0,
      canvas.width,
      canvas.height
    );
    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    return {
      imageData,
      width: canvas.width,
      height: canvas.height
    };
  }
  function getBoundingRect(rects) {
    const boundingRect = rects.reduce((p1, p2) => ({
      top: Math.min(p1.top, p2.top),
      left: Math.min(p1.left, p2.left),
      bottom: Math.max(p1.bottom, p2.bottom),
      right: Math.max(p1.right, p2.right)
    }));
    return {
      x: boundingRect.left,
      y: boundingRect.top,
      width: boundingRect.right - boundingRect.left,
      height: boundingRect.bottom - boundingRect.top
    };
  }
  background;
  function registerUrlUpdateMessageListener() {
    eventProxy.addListener("tabs.onUpdated", (tabId, {
      url
    }) => {
      if (url) {
        sendMessageToTab(tabId, {
          type: "UrlUpdate",
          url
        }).catch(trackError);
      }
    });
  }
  background;
  initSentry({
    entryPoint: "background"
  });
  async function init() {
    EspbServiceClientFactory.silent = !debugMode.debug;
    debugMode.on("change", (newDebug) => {
      EspbServiceClientFactory.silent = !newDebug;
    });
    setupInstallationHandling();
    registerUrlUpdateMessageListener();
    initUiLocale();
    setupConflictingHeyloginExtensionHandling().catch(trackError);
    const clientCoreLoader = new ClientCoreLoader();
    const clientCoreUpdater = await buildClientCoreUpdater(clientCoreLoader);
    await clientCoreUpdater.init();
    const clientCoreUsers = new ClientCoreUsers(clientCoreLoader);
    await clientCoreUsers.init();
    const connectionForwarder = new ConnectionForwarder();
    connectionForwarder.init();
    const contentScriptStateStore = new ContentScriptStateStore();
    contentScriptStateStore.init();
    const totpQrDetectionHandler = new ToptQrDetectionHandler();
    totpQrDetectionHandler.init();
    const requestsSettledHandler = new RequestsSettledHandler();
    requestsSettledHandler.init();
    globalThis.DEBUG = {
      clientCoreLoader,
      clientCoreUsers,
      connectionForwarder,
      contentScriptStateStore,
      requestsSettledHandler,
      debugMode
    };
  }
  async function buildClientCoreUpdater(clientCoreLoader) {
    const browser2 = Bowser.parse(navigator.userAgent);
    if (isMobileSafari(browser2)) {
      return new MobileSafariClientCoreUpdater(clientCoreLoader);
    }
    const clientCoreParametersStorage = await buildClientCoreParametersStorage(browser2);
    return new DefaultClientCoreUpdater(clientCoreLoader, clientCoreParametersStorage);
  }
  async function buildClientCoreParametersStorage(browser2) {
    if (isDesktopSafari(browser2)) {
      const clientCoreParametersStorage = new DesktopSafariClientCoreParametersStorage();
      await clientCoreParametersStorage.init();
      return clientCoreParametersStorage;
    }
    return new BrowserClientCoreParametersStorage();
  }
  init().catch(trackError);
  if (self && self.isInServiceWorker) {
    async function keepaliveGadget() {
      while (true) {
        await browser.permissions.getAll();
        await sleep(15e3);
      }
    }
    keepaliveGadget().catch(trackError);
  }
  background;
  const wrappedIndex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null
  }, Symbol.toStringTag, { value: "Module" }));
  return result$1;
}();
background;
//# sourceMappingURL=background.js.map
