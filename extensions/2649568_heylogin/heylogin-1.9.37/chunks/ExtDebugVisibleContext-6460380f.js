var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { E as ErrorCode, D as DomainError, f as AuthenticatorReply, g as getDefaultExportFromCjs, h as getAugmentedNamespace, j as commonjsGlobal, k as AuthenticatorType, S as SubscriptionError, l as SessionType, P as ProfileType, L as LicenseType, O as OrganizationType, n as PrimaryLoginDevice, C as CredentialType, W as WebauthnPrfSupportStatus, A as AuditlogEventType, o as VaultMessageType, V as VaultType, t as trackError, a as Achievement, B as BackendClientErrorCode, d as debugConsole, M as MaintenanceTask, p as addBreadcrumb$1, q as CancelToken, N as NoResponseError, I as InvalidGrpcResponseError, r as ErrorGroup, u as pleaseUpdate$3, b as browser, m as makeMessageListener, s as sendMessage, c as messageError, v as Emittery$2 } from "./message-939596d6.js";
class Cancel extends Error {
}
const BackendErrorCode = ErrorCode;
class BackendDomainError extends DomainError {
  constructor(grpcStatus, code, short, userTitle, userDetail, requestId) {
    super(code, short, userTitle, userDetail);
    this.grpcStatus = grpcStatus;
    this.requestId = requestId;
    this.name = "BackendDomainError";
  }
}
function createEncryptedSecretAuthenticatorReply(dto) {
  const reply = new AuthenticatorReply({
    replyOneof: { case: "encryptedSecretReply", value: dto }
  });
  return reply.toBinary();
}
function sleep(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function assertExhaustive(_val) {
  throw new Error("This should never happen");
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols$1 = Object.getOwnPropertySymbols;
var hasOwnProperty$c = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject$1(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to2 = toObject$1(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty$c.call(from, key)) {
        to2[key] = from[key];
      }
    }
    if (getOwnPropertySymbols$1) {
      symbols = getOwnPropertySymbols$1(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to2[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to2;
};
var react = { exports: {} };
var react_production_min = {};
/** @license React v17.0.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = objectAssign, n$5 = 60103, p$4 = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q$3 = 60109, r$5 = 60110, t$3 = 60112;
react_production_min.Suspense = 60113;
var u$2 = 60115, v$3 = 60116;
if ("function" === typeof Symbol && Symbol.for) {
  var w$3 = Symbol.for;
  n$5 = w$3("react.element");
  p$4 = w$3("react.portal");
  react_production_min.Fragment = w$3("react.fragment");
  react_production_min.StrictMode = w$3("react.strict_mode");
  react_production_min.Profiler = w$3("react.profiler");
  q$3 = w$3("react.provider");
  r$5 = w$3("react.context");
  t$3 = w$3("react.forward_ref");
  react_production_min.Suspense = w$3("react.suspense");
  u$2 = w$3("react.memo");
  v$3 = w$3("react.lazy");
}
var x$3 = "function" === typeof Symbol && Symbol.iterator;
function y$6(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = x$3 && a2[x$3] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
function z$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$2 = {};
function C$1(a2, b2, c2) {
  this.props = a2;
  this.context = b2;
  this.refs = B$2;
  this.updater = c2 || A$2;
}
C$1.prototype.isReactComponent = {};
C$1.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error(z$3(85));
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
C$1.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function D$3() {
}
D$3.prototype = C$1.prototype;
function E$2(a2, b2, c2) {
  this.props = a2;
  this.context = b2;
  this.refs = B$2;
  this.updater = c2 || A$2;
}
var F$3 = E$2.prototype = new D$3();
F$3.constructor = E$2;
l$3(F$3, C$1.prototype);
F$3.isPureReactComponent = true;
var G$3 = { current: null }, H$2 = Object.prototype.hasOwnProperty, I$3 = { key: true, ref: true, __self: true, __source: true };
function J$1(a2, b2, c2) {
  var e2, d2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (e2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      H$2.call(b2, e2) && !I$3.hasOwnProperty(e2) && (d2[e2] = b2[e2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    d2.children = c2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    d2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (e2 in g2 = a2.defaultProps, g2)
      void 0 === d2[e2] && (d2[e2] = g2[e2]);
  return { $$typeof: n$5, type: a2, key: k2, ref: h2, props: d2, _owner: G$3.current };
}
function K$1(a2, b2) {
  return { $$typeof: n$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function L$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === n$5;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var M$2 = /\/+/g;
function N$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function O$2(a2, b2, c2, e2, d2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case n$5:
          case p$4:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, d2 = d2(h2), a2 = "" === e2 ? "." + N$1(h2, 0) : e2, Array.isArray(d2) ? (c2 = "", null != a2 && (c2 = a2.replace(M$2, "$&/") + "/"), O$2(d2, b2, c2, "", function(a3) {
      return a3;
    })) : null != d2 && (L$1(d2) && (d2 = K$1(d2, c2 + (!d2.key || h2 && h2.key === d2.key ? "" : ("" + d2.key).replace(M$2, "$&/") + "/") + a2)), b2.push(d2)), 1;
  h2 = 0;
  e2 = "" === e2 ? "." : e2 + ":";
  if (Array.isArray(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = e2 + N$1(k2, g2);
      h2 += O$2(k2, b2, c2, f2, d2);
    }
  else if (f2 = y$6(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = e2 + N$1(k2, g2++), h2 += O$2(k2, b2, c2, f2, d2);
  else if ("object" === k2)
    throw b2 = "" + a2, Error(z$3(31, "[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2));
  return h2;
}
function P$2(a2, b2, c2) {
  if (null == a2)
    return a2;
  var e2 = [], d2 = 0;
  O$2(a2, e2, "", "", function(a3) {
    return b2.call(c2, a3, d2++);
  });
  return e2;
}
function Q(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    a2._status = 0;
    a2._result = b2;
    b2.then(function(b3) {
      0 === a2._status && (b3 = b3.default, a2._status = 1, a2._result = b3);
    }, function(b3) {
      0 === a2._status && (a2._status = 2, a2._result = b3);
    });
  }
  if (1 === a2._status)
    return a2._result;
  throw a2._result;
}
var R$1 = { current: null };
function S$2() {
  var a2 = R$1.current;
  if (null === a2)
    throw Error(z$3(321));
  return a2;
}
var T$2 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$3, IsSomeRendererActing: { current: false }, assign: l$3 };
react_production_min.Children = { map: P$2, forEach: function(a2, b2, c2) {
  P$2(a2, function() {
    b2.apply(this, arguments);
  }, c2);
}, count: function(a2) {
  var b2 = 0;
  P$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return P$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!L$1(a2))
    throw Error(z$3(143));
  return a2;
} };
react_production_min.Component = C$1;
react_production_min.PureComponent = E$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$2;
react_production_min.cloneElement = function(a2, b2, c2) {
  if (null === a2 || void 0 === a2)
    throw Error(z$3(267, a2));
  var e2 = l$3({}, a2.props), d2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = G$3.current);
    void 0 !== b2.key && (d2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      H$2.call(b2, f2) && !I$3.hasOwnProperty(f2) && (e2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    e2.children = c2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    e2.children = g2;
  }
  return {
    $$typeof: n$5,
    type: a2.type,
    key: d2,
    ref: k2,
    props: e2,
    _owner: h2
  };
};
react_production_min.createContext = function(a2, b2) {
  void 0 === b2 && (b2 = null);
  a2 = { $$typeof: r$5, _calculateChangedBits: b2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null };
  a2.Provider = { $$typeof: q$3, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = J$1;
react_production_min.createFactory = function(a2) {
  var b2 = J$1.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: t$3, render: a2 };
};
react_production_min.isValidElement = L$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: v$3, _payload: { _status: -1, _result: a2 }, _init: Q };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: u$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.useCallback = function(a2, b2) {
  return S$2().useCallback(a2, b2);
};
react_production_min.useContext = function(a2, b2) {
  return S$2().useContext(a2, b2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a2, b2) {
  return S$2().useEffect(a2, b2);
};
react_production_min.useImperativeHandle = function(a2, b2, c2) {
  return S$2().useImperativeHandle(a2, b2, c2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return S$2().useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return S$2().useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, c2) {
  return S$2().useReducer(a2, b2, c2);
};
react_production_min.useRef = function(a2) {
  return S$2().useRef(a2);
};
react_production_min.useState = function(a2) {
  return S$2().useState(a2);
};
react_production_min.version = "17.0.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/** @license React v17.0.1
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$5 = reactExports, g$4 = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if ("function" === typeof Symbol && Symbol.for) {
  var h$4 = Symbol.for;
  g$4 = h$4("react.element");
  reactJsxRuntime_production_min.Fragment = h$4("react.fragment");
}
var m$5 = f$5.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$4 = Object.prototype.hasOwnProperty, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$2(c2, a2, k2) {
  var b2, d2 = {}, e2 = null, l2 = null;
  void 0 !== k2 && (e2 = "" + k2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (l2 = a2.ref);
  for (b2 in a2)
    n$4.call(a2, b2) && !p$3.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: g$4, type: c2, key: e2, ref: l2, props: d2, _owner: m$5.current };
}
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
const Fragment = jsxRuntimeExports.Fragment;
const jsx = jsxRuntimeExports.jsx;
const jsxs = jsxRuntimeExports.jsxs;
var dist$2 = {};
var errors$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.errorMessages = exports2.ErrorType = void 0;
  var ErrorType;
  (function(ErrorType2) {
    ErrorType2["MalformedUnicode"] = "MALFORMED_UNICODE";
    ErrorType2["MalformedHexadecimal"] = "MALFORMED_HEXADECIMAL";
    ErrorType2["CodePointLimit"] = "CODE_POINT_LIMIT";
    ErrorType2["OctalDeprecation"] = "OCTAL_DEPRECATION";
    ErrorType2["EndOfString"] = "END_OF_STRING";
  })(ErrorType = exports2.ErrorType || (exports2.ErrorType = {}));
  exports2.errorMessages = /* @__PURE__ */ new Map([
    [ErrorType.MalformedUnicode, "malformed Unicode character escape sequence"],
    [
      ErrorType.MalformedHexadecimal,
      "malformed hexadecimal character escape sequence"
    ],
    [
      ErrorType.CodePointLimit,
      "Unicode codepoint must not be greater than 0x10FFFF in escape sequence"
    ],
    [
      ErrorType.OctalDeprecation,
      '"0"-prefixed octal literals and octal escape sequences are deprecated; for octal literals use the "0o" prefix instead'
    ],
    [ErrorType.EndOfString, "malformed escape sequence at end of string"]
  ]);
})(errors$1);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.unraw = exports2.errorMessages = exports2.ErrorType = void 0;
  const errors_1 = errors$1;
  Object.defineProperty(exports2, "ErrorType", { enumerable: true, get: function() {
    return errors_1.ErrorType;
  } });
  Object.defineProperty(exports2, "errorMessages", { enumerable: true, get: function() {
    return errors_1.errorMessages;
  } });
  function parseHexToInt(hex) {
    const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);
    return isOnlyHexChars ? parseInt(hex, 16) : NaN;
  }
  function validateAndParseHex(hex, errorName, enforcedLength) {
    const parsedHex = parseHexToInt(hex);
    if (Number.isNaN(parsedHex) || enforcedLength !== void 0 && enforcedLength !== hex.length) {
      throw new SyntaxError(errors_1.errorMessages.get(errorName));
    }
    return parsedHex;
  }
  function parseHexadecimalCode(code) {
    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);
    return String.fromCharCode(parsedCode);
  }
  function parseUnicodeCode(code, surrogateCode) {
    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);
    if (surrogateCode !== void 0) {
      const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);
      return String.fromCharCode(parsedCode, parsedSurrogateCode);
    }
    return String.fromCharCode(parsedCode);
  }
  function isCurlyBraced(text) {
    return text.charAt(0) === "{" && text.charAt(text.length - 1) === "}";
  }
  function parseUnicodeCodePointCode(codePoint) {
    if (!isCurlyBraced(codePoint)) {
      throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));
    }
    const withoutBraces = codePoint.slice(1, -1);
    const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);
    try {
      return String.fromCodePoint(parsedCode);
    } catch (err) {
      throw err instanceof RangeError ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit)) : err;
    }
  }
  function parseOctalCode(code, error2 = false) {
    if (error2) {
      throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));
    }
    const parsedCode = parseInt(code, 8);
    return String.fromCharCode(parsedCode);
  }
  const singleCharacterEscapes = /* @__PURE__ */ new Map([
    ["b", "\b"],
    ["f", "\f"],
    ["n", "\n"],
    ["r", "\r"],
    ["t", "	"],
    ["v", "\v"],
    ["0", "\0"]
  ]);
  function parseSingleCharacterCode(code) {
    return singleCharacterEscapes.get(code) || code;
  }
  const escapeMatch = /\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;
  function unraw2(raw, allowOctals = false) {
    return raw.replace(escapeMatch, function(_2, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {
      if (backslash !== void 0) {
        return "\\";
      }
      if (hex !== void 0) {
        return parseHexadecimalCode(hex);
      }
      if (codePoint !== void 0) {
        return parseUnicodeCodePointCode(codePoint);
      }
      if (unicodeWithSurrogate !== void 0) {
        return parseUnicodeCode(unicodeWithSurrogate, surrogate);
      }
      if (unicode !== void 0) {
        return parseUnicodeCode(unicode);
      }
      if (octal === "0") {
        return "\0";
      }
      if (octal !== void 0) {
        return parseOctalCode(octal, !allowOctals);
      }
      if (singleCharacter !== void 0) {
        return parseSingleCharacterCode(singleCharacter);
      }
      throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));
    });
  }
  exports2.unraw = unraw2;
  exports2.default = unraw2;
})(dist$2);
const unraw = /* @__PURE__ */ getDefaultExportFromCjs(dist$2);
const isString$6 = (s2) => typeof s2 === "string";
const isFunction$3 = (f2) => typeof f2 === "function";
const cache = /* @__PURE__ */ new Map();
function normalizeLocales(locales) {
  const out = Array.isArray(locales) ? locales : [locales];
  return [...out, "en"];
}
function date(locales, value, format) {
  const _locales = normalizeLocales(locales);
  const formatter = getMemoized(
    () => cacheKey("date", _locales, format),
    () => new Intl.DateTimeFormat(_locales, format)
  );
  return formatter.format(isString$6(value) ? new Date(value) : value);
}
function number(locales, value, format) {
  const _locales = normalizeLocales(locales);
  const formatter = getMemoized(
    () => cacheKey("number", _locales, format),
    () => new Intl.NumberFormat(_locales, format)
  );
  return formatter.format(value);
}
function plural(locales, ordinal, value, { offset = 0, ...rules }) {
  const _locales = normalizeLocales(locales);
  const plurals = ordinal ? getMemoized(
    () => cacheKey("plural-ordinal", _locales),
    () => new Intl.PluralRules(_locales, { type: "ordinal" })
  ) : getMemoized(
    () => cacheKey("plural-cardinal", _locales),
    () => new Intl.PluralRules(_locales, { type: "cardinal" })
  );
  return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;
}
function getMemoized(getKey, construct) {
  const key = getKey();
  let formatter = cache.get(key);
  if (!formatter) {
    formatter = construct();
    cache.set(key, formatter);
  }
  return formatter;
}
function cacheKey(type, locales, options) {
  const localeKey = locales.join("-");
  return `${type}-${localeKey}-${JSON.stringify(options)}`;
}
const UNICODE_REGEX = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g;
const getDefaultFormats = (locale2, locales, formats = {}) => {
  locales = locales || locale2;
  const style = (format) => isString$6(format) ? formats[format] || { style: format } : format;
  const replaceOctothorpe = (value, message) => {
    const numberFormat = Object.keys(formats).length ? style("number") : {};
    const valueStr = number(locales, value, numberFormat);
    return message.replace("#", valueStr);
  };
  return {
    plural: (value, cases) => {
      const { offset = 0 } = cases;
      const message = plural(locales, false, value, cases);
      return replaceOctothorpe(value - offset, message);
    },
    selectordinal: (value, cases) => {
      const { offset = 0 } = cases;
      const message = plural(locales, true, value, cases);
      return replaceOctothorpe(value - offset, message);
    },
    select: (value, rules) => rules[value] ?? rules.other,
    number: (value, format) => number(locales, value, style(format)),
    date: (value, format) => date(locales, value, style(format)),
    undefined: (value) => value
  };
};
function interpolate(translation, locale2, locales) {
  return (values2, formats = {}) => {
    const formatters = getDefaultFormats(locale2, locales, formats);
    const formatMessage = (message) => {
      if (!Array.isArray(message))
        return message;
      return message.reduce((message2, token) => {
        if (isString$6(token))
          return message2 + token;
        const [name, type, format] = token;
        let interpolatedFormat = {};
        if (format != null && !isString$6(format)) {
          Object.keys(format).forEach((key) => {
            interpolatedFormat[key] = formatMessage(format[key]);
          });
        } else {
          interpolatedFormat = format;
        }
        const value = formatters[type](values2[name], interpolatedFormat);
        if (value == null)
          return message2;
        return message2 + value;
      }, "");
    };
    const result = formatMessage(translation);
    if (isString$6(result) && UNICODE_REGEX.test(result)) {
      return unraw(result.trim());
    }
    if (isString$6(result))
      return result.trim();
    return result;
  };
}
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class EventEmitter {
  constructor() {
    __publicField$1(this, "_events", {});
  }
  on(event, listener) {
    if (!this._hasEvent(event))
      this._events[event] = [];
    this._events[event].push(listener);
    return () => this.removeListener(event, listener);
  }
  removeListener(event, listener) {
    if (!this._hasEvent(event))
      return;
    const index2 = this._events[event].indexOf(listener);
    if (~index2)
      this._events[event].splice(index2, 1);
  }
  emit(event, ...args) {
    if (!this._hasEvent(event))
      return;
    this._events[event].map((listener) => listener.apply(this, args));
  }
  _hasEvent(event) {
    return Array.isArray(this._events[event]);
  }
}
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class I18n extends EventEmitter {
  constructor(params) {
    super();
    __publicField2(this, "_locale");
    __publicField2(this, "_locales");
    __publicField2(this, "_localeData");
    __publicField2(this, "_messages");
    __publicField2(this, "_missing");
    __publicField2(this, "t", this._.bind(this));
    this._messages = {};
    this._localeData = {};
    if (params.missing != null)
      this._missing = params.missing;
    if (params.messages != null)
      this.load(params.messages);
    if (params.localeData != null)
      this.loadLocaleData(params.localeData);
    if (params.locale != null || params.locales != null) {
      this.activate(params.locale, params.locales);
    }
  }
  get locale() {
    return this._locale;
  }
  get locales() {
    return this._locales;
  }
  get messages() {
    return this._messages[this._locale] ?? {};
  }
  /**
   * @deprecated this has no effect. Please remove this from the code. Deprecated in v4
   */
  get localeData() {
    return this._localeData[this._locale] ?? {};
  }
  _loadLocaleData(locale2, localeData) {
    if (this._localeData[locale2] == null) {
      this._localeData[locale2] = localeData;
    } else {
      Object.assign(this._localeData[locale2], localeData);
    }
  }
  /**
   * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4
   */
  loadLocaleData(localeOrAllData, localeData) {
    if (localeData != null) {
      this._loadLocaleData(localeOrAllData, localeData);
    } else {
      Object.keys(localeOrAllData).forEach(
        (locale2) => this._loadLocaleData(locale2, localeOrAllData[locale2])
      );
    }
    this.emit("change");
  }
  _load(locale2, messages2) {
    if (this._messages[locale2] == null) {
      this._messages[locale2] = messages2;
    } else {
      Object.assign(this._messages[locale2], messages2);
    }
  }
  load(localeOrMessages, messages2) {
    if (messages2 != null) {
      this._load(localeOrMessages, messages2);
    } else {
      Object.keys(localeOrMessages).forEach(
        (locale2) => this._load(locale2, localeOrMessages[locale2])
      );
    }
    this.emit("change");
  }
  /**
   * @param options {@link LoadAndActivateOptions}
   */
  loadAndActivate({ locale: locale2, locales, messages: messages2 }) {
    this._locale = locale2;
    this._locales = locales || void 0;
    this._messages[this._locale] = messages2;
    this.emit("change");
  }
  activate(locale2, locales) {
    this._locale = locale2;
    this._locales = locales;
    this.emit("change");
  }
  _(id2, values2 = {}, { message, formats } = {}) {
    if (!isString$6(id2)) {
      values2 = id2.values || values2;
      message = id2.message;
      id2 = id2.id;
    }
    const messageMissing = !this.messages[id2];
    const missing = this._missing;
    if (missing && messageMissing) {
      return isFunction$3(missing) ? missing(this._locale, id2) : missing;
    }
    if (messageMissing) {
      this.emit("missing", { id: id2, locale: this._locale });
    }
    let translation = this.messages[id2] || message || id2;
    if (isString$6(translation) && UNICODE_REGEX.test(translation))
      return JSON.parse(`"${translation}"`);
    if (isString$6(translation))
      return translation;
    return interpolate(
      translation,
      this._locale,
      this._locales
    )(values2, formats);
  }
  date(value, format) {
    return date(this._locales || this._locale, value, format);
  }
  number(value, format) {
    return number(this._locales || this._locale, value, format);
  }
}
function setupI18n(params = {}) {
  return new I18n(params);
}
const i18n = setupI18n();
const tagRe = /<([a-zA-Z0-9]+)>(.*?)<\/\1>|<([a-zA-Z0-9]+)\/>/;
const nlRe = /(?:\r\n|\r|\n)/g;
const voidElementTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
function formatElements(value, elements = {}) {
  const uniqueId = makeCounter(0, "$lingui$");
  const parts = value.replace(nlRe, "").split(tagRe);
  if (parts.length === 1)
    return value;
  const tree = [];
  const before = parts.shift();
  if (before)
    tree.push(before);
  for (const [index2, children, after] of getElements(parts)) {
    let element = typeof index2 !== "undefined" ? elements[index2] : void 0;
    if (!element || voidElementTags[element.type] && children) {
      if (!element) {
        console.error(
          `Can't use element at index '${index2}' as it is not declared in the original translation`
        );
      } else {
        console.error(
          `${element.type} is a void element tag therefore it must have no children`
        );
      }
      element = React$1.createElement(React$1.Fragment);
    }
    if (Array.isArray(element)) {
      element = React$1.createElement(React$1.Fragment, {}, element);
    }
    tree.push(
      React$1.cloneElement(
        element,
        { key: uniqueId() },
        // format children for pair tags
        // unpaired tags might have children if it's a component passed as a variable
        children ? formatElements(children, elements) : element.props.children
      )
    );
    if (after)
      tree.push(after);
  }
  return tree;
}
function getElements(parts) {
  if (!parts.length)
    return [];
  const [paired, children, unpaired, after] = parts.slice(0, 4);
  const triple = [paired || unpaired, children || "", after];
  return [triple].concat(getElements(parts.slice(4, parts.length)));
}
const makeCounter = (count = 0, prefix = "") => () => `${prefix}_${count++}`;
function TransNoContext(props) {
  const {
    render,
    component,
    id: id2,
    message,
    formats,
    lingui: { i18n: i18n2, defaultComponent }
  } = props;
  const values2 = { ...props.values };
  const components = { ...props.components };
  if (values2) {
    Object.keys(values2).forEach((key) => {
      const value = values2[key];
      const valueIsReactEl = React$1.isValidElement(value) || Array.isArray(value) && value.every(React$1.isValidElement);
      if (!valueIsReactEl)
        return;
      const index2 = Object.keys(components).length;
      components[index2] = value;
      values2[key] = `<${index2}/>`;
    });
  }
  const _translation = i18n2 && typeof i18n2._ === "function" ? i18n2._(id2, values2, { message, formats }) : id2;
  const translation = _translation ? formatElements(_translation, components) : null;
  if (render === null || component === null) {
    return translation;
  }
  const FallbackComponent = defaultComponent || RenderFragment;
  const i18nProps = {
    id: id2,
    message,
    translation,
    isTranslated: id2 !== translation && message !== translation,
    children: translation
    // for type-compatibility with `component` prop
  };
  if (render && component) {
    console.error(
      "You can't use both `component` and `render` prop at the same time. `component` is ignored."
    );
  } else if (render && typeof render !== "function") {
    console.error(
      `Invalid value supplied to prop \`render\`. It must be a function, provided ${render}`
    );
  } else if (component && typeof component !== "function") {
    console.error(
      `Invalid value supplied to prop \`component\`. It must be a React component, provided ${component}`
    );
    return React$1.createElement(FallbackComponent, i18nProps, translation);
  }
  if (typeof render === "function") {
    return render(i18nProps);
  }
  const Component = component || FallbackComponent;
  return React$1.createElement(Component, i18nProps, translation);
}
const RenderFragment = ({ children }) => {
  return /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, children);
};
const LinguiContext = React$1.createContext(null);
function useLingui() {
  const context = React$1.useContext(LinguiContext);
  return context;
}
const I18nProvider = ({
  i18n: i18n2,
  defaultComponent,
  children
}) => {
  const latestKnownLocale = React$1.useRef(i18n2.locale);
  const makeContext = React$1.useCallback(
    () => ({
      i18n: i18n2,
      defaultComponent,
      _: i18n2.t.bind(i18n2)
    }),
    [i18n2, defaultComponent]
  );
  const [context, setContext] = React$1.useState(makeContext());
  React$1.useEffect(() => {
    const updateContext = () => {
      latestKnownLocale.current = i18n2.locale;
      setContext(makeContext());
    };
    const unsubscribe = i18n2.on("change", updateContext);
    if (latestKnownLocale.current !== i18n2.locale) {
      updateContext();
    }
    return unsubscribe;
  }, [i18n2, makeContext]);
  if (!latestKnownLocale.current) {
    return null;
  }
  return /* @__PURE__ */ React$1.createElement(LinguiContext.Provider, { value: context }, children);
};
function Trans(props) {
  const lingui = useLingui();
  return React$1.createElement(TransNoContext, { ...props, lingui });
}
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.1
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports2) {
  var f2, g2, h2, k2;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports2.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports2.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t2 = null, u2 = null, w2 = function() {
      if (null !== t2)
        try {
          var a2 = exports2.unstable_now();
          t2(true, a2);
          t2 = null;
        } catch (b2) {
          throw setTimeout(w2, 0), b2;
        }
    };
    f2 = function(a2) {
      null !== t2 ? setTimeout(f2, 0, a2) : (t2 = a2, setTimeout(w2, 0));
    };
    g2 = function(a2, b2) {
      u2 = setTimeout(a2, b2);
    };
    h2 = function() {
      clearTimeout(u2);
    };
    exports2.unstable_shouldYield = function() {
      return false;
    };
    k2 = exports2.unstable_forceFrameRate = function() {
    };
  } else {
    var x = window.setTimeout, y2 = window.clearTimeout;
    if ("undefined" !== typeof console) {
      var z2 = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
    exports2.unstable_shouldYield = function() {
      return exports2.unstable_now() >= E2;
    };
    k2 = function() {
    };
    exports2.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (null !== B2) {
        var a2 = exports2.unstable_now();
        E2 = a2 + D2;
        try {
          B2(true, a2) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b2) {
          throw G2.postMessage(null), b2;
        }
      } else
        A2 = false;
    };
    f2 = function(a2) {
      B2 = a2;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g2 = function(a2, b2) {
      C2 = x(function() {
        a2(exports2.unstable_now());
      }, b2);
    };
    h2 = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; ; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (void 0 !== e2 && 0 < I2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function J2(a2) {
    a2 = a2[0];
    return void 0 === a2 ? null : a2;
  }
  function K2(a2) {
    var b2 = a2[0];
    if (void 0 !== b2) {
      var c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a:
          for (var d2 = 0, e2 = a2.length; d2 < e2; ) {
            var m2 = 2 * (d2 + 1) - 1, n2 = a2[m2], v2 = m2 + 1, r2 = a2[v2];
            if (void 0 !== n2 && 0 > I2(n2, c2))
              void 0 !== r2 && 0 > I2(r2, n2) ? (a2[d2] = r2, a2[v2] = c2, d2 = v2) : (a2[d2] = n2, a2[m2] = c2, d2 = m2);
            else if (void 0 !== r2 && 0 > I2(r2, c2))
              a2[d2] = r2, a2[v2] = c2, d2 = v2;
            else
              break a;
          }
      }
      return b2;
    }
    return null;
  }
  function I2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a2) {
    for (var b2 = J2(M2); null !== b2; ) {
      if (null === b2.callback)
        K2(M2);
      else if (b2.startTime <= a2)
        K2(M2), b2.sortIndex = b2.expirationTime, H2(L2, b2);
      else
        break;
      b2 = J2(M2);
    }
  }
  function U2(a2) {
    S2 = false;
    T2(a2);
    if (!R2)
      if (null !== J2(L2))
        R2 = true, f2(V2);
      else {
        var b2 = J2(M2);
        null !== b2 && g2(U2, b2.startTime - a2);
      }
  }
  function V2(a2, b2) {
    R2 = false;
    S2 && (S2 = false, h2());
    Q2 = true;
    var c2 = P2;
    try {
      T2(b2);
      for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b2) || a2 && !exports2.unstable_shouldYield()); ) {
        var d2 = O2.callback;
        if ("function" === typeof d2) {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e2 = d2(O2.expirationTime <= b2);
          b2 = exports2.unstable_now();
          "function" === typeof e2 ? O2.callback = e2 : O2 === J2(L2) && K2(L2);
          T2(b2);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (null !== O2)
        var m2 = true;
      else {
        var n2 = J2(M2);
        null !== n2 && g2(U2, n2.startTime - b2);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c2, Q2 = false;
    }
  }
  var W2 = k2;
  exports2.unstable_IdlePriority = 5;
  exports2.unstable_ImmediatePriority = 1;
  exports2.unstable_LowPriority = 4;
  exports2.unstable_NormalPriority = 3;
  exports2.unstable_Profiling = null;
  exports2.unstable_UserBlockingPriority = 2;
  exports2.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports2.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f2(V2));
  };
  exports2.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports2.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports2.unstable_next = function(a2) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = P2;
    }
    var c2 = P2;
    P2 = b2;
    try {
      return a2();
    } finally {
      P2 = c2;
    }
  };
  exports2.unstable_pauseExecution = function() {
  };
  exports2.unstable_requestPaint = W2;
  exports2.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = P2;
    P2 = a2;
    try {
      return b2();
    } finally {
      P2 = c2;
    }
  };
  exports2.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports2.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: N2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, H2(M2, a2), null === J2(L2) && a2 === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a2.sortIndex = e2, H2(L2, a2), R2 || Q2 || (R2 = true, f2(V2)));
    return a2;
  };
  exports2.unstable_wrapCallback = function(a2) {
    var b2 = P2;
    return function() {
      var c2 = P2;
      P2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        P2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/** @license React v17.0.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa$1 = reactExports, m$4 = objectAssign, r$4 = schedulerExports;
function y$5(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa$1)
  throw Error(y$5(227));
var ba$1 = /* @__PURE__ */ new Set(), ca$1 = {};
function da$1(a2, b2) {
  ea$1(a2, b2);
  ea$1(a2 + "Capture", b2);
}
function ea$1(a2, b2) {
  ca$1[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    ba$1.add(b2[a2]);
}
var fa$1 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha$1 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia$1 = Object.prototype.hasOwnProperty, ja$1 = {}, ka$1 = {};
function la$1(a2) {
  if (ia$1.call(ka$1, a2))
    return true;
  if (ia$1.call(ja$1, a2))
    return false;
  if (ha$1.test(a2))
    return ka$1[a2] = true;
  ja$1[a2] = true;
  return false;
}
function ma$1(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function na$1(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || ma$1(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function B$1(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var D$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  D$2[a2] = new B$1(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  D$2[b2] = new B$1(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  D$2[a2] = new B$1(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var oa$1 = /[\-:]([a-z])/g;
function pa$1(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    oa$1,
    pa$1
  );
  D$2[b2] = new B$1(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(oa$1, pa$1);
  D$2[b2] = new B$1(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(oa$1, pa$1);
  D$2[b2] = new B$1(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, false, false);
});
D$2.xlinkHref = new B$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  D$2[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function qa$1(a2, b2, c2, d2) {
  var e2 = D$2.hasOwnProperty(b2) ? D$2[b2] : null;
  var f2 = null !== e2 ? 0 === e2.type : d2 ? false : !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1] ? false : true;
  f2 || (na$1(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? la$1(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2))));
}
var ra$1 = aa$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa$1 = 60103, ta$1 = 60106, ua$1 = 60107, wa$1 = 60108, xa$1 = 60114, ya$1 = 60109, za$1 = 60110, Aa$1 = 60112, Ba$1 = 60113, Ca$1 = 60120, Da$1 = 60115, Ea$1 = 60116, Fa$1 = 60121, Ga = 60128, Ha$1 = 60129, Ia$1 = 60130, Ja = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var E$1 = Symbol.for;
  sa$1 = E$1("react.element");
  ta$1 = E$1("react.portal");
  ua$1 = E$1("react.fragment");
  wa$1 = E$1("react.strict_mode");
  xa$1 = E$1("react.profiler");
  ya$1 = E$1("react.provider");
  za$1 = E$1("react.context");
  Aa$1 = E$1("react.forward_ref");
  Ba$1 = E$1("react.suspense");
  Ca$1 = E$1("react.suspense_list");
  Da$1 = E$1("react.memo");
  Ea$1 = E$1("react.lazy");
  Fa$1 = E$1("react.block");
  E$1("react.scope");
  Ga = E$1("react.opaque.id");
  Ha$1 = E$1("react.debug_trace_mode");
  Ia$1 = E$1("react.offscreen");
  Ja = E$1("react.legacy_hidden");
}
var Ka$1 = "function" === typeof Symbol && Symbol.iterator;
function La$1(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ka$1 && a2[Ka$1] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var Ma$1;
function Na$1(a2) {
  if (void 0 === Ma$1)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      Ma$1 = b2 && b2[1] || "";
    }
  return "\n" + Ma$1 + a2;
}
var Oa$1 = false;
function Pa$1(a2, b2) {
  if (!a2 || Oa$1)
    return "";
  Oa$1 = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (k2) {
          var d2 = k2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (k2) {
          d2 = k2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k2) {
        d2 = k2;
      }
      a2();
    }
  } catch (k2) {
    if (k2 && d2 && "string" === typeof k2.stack) {
      for (var e2 = k2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2])
                return "\n" + e2[g2].replace(" at new ", " at ");
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Oa$1 = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Na$1(a2) : "";
}
function Qa(a2) {
  switch (a2.tag) {
    case 5:
      return Na$1(a2.type);
    case 16:
      return Na$1("Lazy");
    case 13:
      return Na$1("Suspense");
    case 19:
      return Na$1("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Pa$1(a2.type, false), a2;
    case 11:
      return a2 = Pa$1(a2.type.render, false), a2;
    case 22:
      return a2 = Pa$1(a2.type._render, false), a2;
    case 1:
      return a2 = Pa$1(a2.type, true), a2;
    default:
      return "";
  }
}
function Ra$1(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ua$1:
      return "Fragment";
    case ta$1:
      return "Portal";
    case xa$1:
      return "Profiler";
    case wa$1:
      return "StrictMode";
    case Ba$1:
      return "Suspense";
    case Ca$1:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case za$1:
        return (a2.displayName || "Context") + ".Consumer";
      case ya$1:
        return (a2._context.displayName || "Context") + ".Provider";
      case Aa$1:
        var b2 = a2.render;
        b2 = b2.displayName || b2.name || "";
        return a2.displayName || ("" !== b2 ? "ForwardRef(" + b2 + ")" : "ForwardRef");
      case Da$1:
        return Ra$1(a2.type);
      case Fa$1:
        return Ra$1(a2._render);
      case Ea$1:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Ra$1(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Sa$1(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a2;
    default:
      return "";
  }
}
function Ta$1(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua$1(a2) {
  var b2 = Ta$1(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va$1(a2) {
  a2._valueTracker || (a2._valueTracker = Ua$1(a2));
}
function Wa$1(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta$1(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa$1(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return m$4({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za$1(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa$1(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function $a$1(a2, b2) {
  b2 = b2.checked;
  null != b2 && qa$1(a2, "checked", b2, false);
}
function ab(a2, b2) {
  $a$1(a2, b2);
  var c2 = Sa$1(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? bb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && bb(a2, b2.type, Sa$1(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function cb(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function bb(a2, b2, c2) {
  if ("number" !== b2 || Xa$1(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
function db(a2) {
  var b2 = "";
  aa$1.Children.forEach(a2, function(a3) {
    null != a3 && (b2 += a3);
  });
  return b2;
}
function eb(a2, b2) {
  a2 = m$4({ children: void 0 }, b2);
  if (b2 = db(b2.children))
    a2.children = b2;
  return a2;
}
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa$1(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(y$5(91));
  return m$4({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(y$5(92));
      if (Array.isArray(c2)) {
        if (!(1 >= c2.length))
          throw Error(y$5(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa$1(c2) };
}
function ib(a2, b2) {
  var c2 = Sa$1(b2.value), d2 = Sa$1(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? lb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var nb, ob = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if (a2.namespaceURI !== kb.svg || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = nb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function pb(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a2) {
  rb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    qb[b2] = qb[a2];
  });
});
function sb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || qb.hasOwnProperty(a2) && qb[a2] ? ("" + b2).trim() : b2 + "px";
}
function tb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = sb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var ub = m$4({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a2, b2) {
  if (b2) {
    if (ub[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(y$5(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(y$5(60));
      if (!("object" === typeof b2.dangerouslySetInnerHTML && "__html" in b2.dangerouslySetInnerHTML))
        throw Error(y$5(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(y$5(62));
  }
}
function wb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(y$5(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb(a2, b2, c2, d2, e2) {
  return a2(b2, c2, d2, e2);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (null !== zb || null !== Ab)
    Ib(), Fb();
}
function Nb(a2, b2, c2) {
  if (Lb)
    return a2(b2, c2);
  Lb = true;
  try {
    return Jb(a2, b2, c2);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(y$5(231, b2, typeof c2));
  return c2;
}
var Pb = false;
if (fa$1)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a2) {
    Pb = false;
  }
function Rb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a2) {
  Sb = true;
  Tb = a2;
} };
function Xb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y$5(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 1026) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function $b(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function ac$1(a2) {
  if (Zb(a2) !== a2)
    throw Error(y$5(188));
}
function bc$1(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Zb(a2);
    if (null === b2)
      throw Error(y$5(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return ac$1(e2), a2;
        if (f2 === d2)
          return ac$1(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(y$5(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(y$5(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(y$5(190));
  }
  if (3 !== c2.tag)
    throw Error(y$5(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function cc$1(a2) {
  a2 = bc$1(a2);
  if (!a2)
    return null;
  for (var b2 = a2; ; ) {
    if (5 === b2.tag || 6 === b2.tag)
      return b2;
    if (b2.child)
      b2.child.return = b2, b2 = b2.child;
    else {
      if (b2 === a2)
        break;
      for (; !b2.sibling; ) {
        if (!b2.return || b2.return === a2)
          return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return null;
}
function dc$1(a2, b2) {
  for (var c2 = a2.alternate; null !== b2; ) {
    if (b2 === a2 || b2 === c2)
      return true;
    b2 = b2.return;
  }
  return false;
}
var ec$1, fc$1, gc$1, hc$1, ic$1 = false, jc$1 = [], kc$1 = null, lc$1 = null, mc$1 = null, nc$1 = /* @__PURE__ */ new Map(), oc$1 = /* @__PURE__ */ new Map(), pc$1 = [], qc$1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc$1(a2, b2, c2, d2, e2) {
  return { blockedOn: a2, domEventName: b2, eventSystemFlags: c2 | 16, nativeEvent: e2, targetContainers: [d2] };
}
function sc$1(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      kc$1 = null;
      break;
    case "dragenter":
    case "dragleave":
      lc$1 = null;
      break;
    case "mouseover":
    case "mouseout":
      mc$1 = null;
      break;
    case "pointerover":
    case "pointerout":
      nc$1.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc$1.delete(b2.pointerId);
  }
}
function tc$1(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = rc$1(b2, c2, d2, e2, f2), null !== b2 && (b2 = Cb(b2), null !== b2 && fc$1(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function uc$1(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return kc$1 = tc$1(kc$1, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return lc$1 = tc$1(lc$1, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return mc$1 = tc$1(mc$1, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      nc$1.set(f2, tc$1(nc$1.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, oc$1.set(f2, tc$1(oc$1.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function vc$1(a2) {
  var b2 = wc$1(a2.target);
  if (null !== b2) {
    var c2 = Zb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = $b(c2), null !== b2) {
          a2.blockedOn = b2;
          hc$1(a2.lanePriority, function() {
            r$4.unstable_runWithPriority(a2.priority, function() {
              gc$1(c2);
            });
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.hydrate) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function xc$1(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = yc$1(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null !== c2)
      return b2 = Cb(c2), null !== b2 && fc$1(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function zc$1(a2, b2, c2) {
  xc$1(a2) && c2.delete(b2);
}
function Ac$1() {
  for (ic$1 = false; 0 < jc$1.length; ) {
    var a2 = jc$1[0];
    if (null !== a2.blockedOn) {
      a2 = Cb(a2.blockedOn);
      null !== a2 && ec$1(a2);
      break;
    }
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = yc$1(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null !== c2) {
        a2.blockedOn = c2;
        break;
      }
      b2.shift();
    }
    null === a2.blockedOn && jc$1.shift();
  }
  null !== kc$1 && xc$1(kc$1) && (kc$1 = null);
  null !== lc$1 && xc$1(lc$1) && (lc$1 = null);
  null !== mc$1 && xc$1(mc$1) && (mc$1 = null);
  nc$1.forEach(zc$1);
  oc$1.forEach(zc$1);
}
function Bc$1(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, ic$1 || (ic$1 = true, r$4.unstable_scheduleCallback(r$4.unstable_NormalPriority, Ac$1)));
}
function Cc$1(a2) {
  function b2(b3) {
    return Bc$1(b3, a2);
  }
  if (0 < jc$1.length) {
    Bc$1(jc$1[0], a2);
    for (var c2 = 1; c2 < jc$1.length; c2++) {
      var d2 = jc$1[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== kc$1 && Bc$1(kc$1, a2);
  null !== lc$1 && Bc$1(lc$1, a2);
  null !== mc$1 && Bc$1(mc$1, a2);
  nc$1.forEach(b2);
  oc$1.forEach(b2);
  for (c2 = 0; c2 < pc$1.length; c2++)
    d2 = pc$1[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < pc$1.length && (c2 = pc$1[0], null === c2.blockedOn); )
    vc$1(c2), null === c2.blockedOn && pc$1.shift();
}
function Dc$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var Ec$1 = { animationend: Dc$1("Animation", "AnimationEnd"), animationiteration: Dc$1("Animation", "AnimationIteration"), animationstart: Dc$1("Animation", "AnimationStart"), transitionend: Dc$1("Transition", "TransitionEnd") }, Fc$1 = {}, Gc$1 = {};
fa$1 && (Gc$1 = document.createElement("div").style, "AnimationEvent" in window || (delete Ec$1.animationend.animation, delete Ec$1.animationiteration.animation, delete Ec$1.animationstart.animation), "TransitionEvent" in window || delete Ec$1.transitionend.transition);
function Hc$1(a2) {
  if (Fc$1[a2])
    return Fc$1[a2];
  if (!Ec$1[a2])
    return a2;
  var b2 = Ec$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Gc$1)
      return Fc$1[a2] = b2[c2];
  return a2;
}
var Ic$1 = Hc$1("animationend"), Jc$1 = Hc$1("animationiteration"), Kc$1 = Hc$1("animationstart"), Lc$1 = Hc$1("transitionend"), Mc$1 = /* @__PURE__ */ new Map(), Nc$1 = /* @__PURE__ */ new Map(), Oc$1 = [
  "abort",
  "abort",
  Ic$1,
  "animationEnd",
  Jc$1,
  "animationIteration",
  Kc$1,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc$1,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc$1(a2, b2) {
  for (var c2 = 0; c2 < a2.length; c2 += 2) {
    var d2 = a2[c2], e2 = a2[c2 + 1];
    e2 = "on" + (e2[0].toUpperCase() + e2.slice(1));
    Nc$1.set(d2, b2);
    Mc$1.set(d2, e2);
    da$1(e2, [d2]);
  }
}
var Qc$1 = r$4.unstable_now;
Qc$1();
var F$2 = 8;
function Rc$1(a2) {
  if (0 !== (1 & a2))
    return F$2 = 15, 1;
  if (0 !== (2 & a2))
    return F$2 = 14, 2;
  if (0 !== (4 & a2))
    return F$2 = 13, 4;
  var b2 = 24 & a2;
  if (0 !== b2)
    return F$2 = 12, b2;
  if (0 !== (a2 & 32))
    return F$2 = 11, 32;
  b2 = 192 & a2;
  if (0 !== b2)
    return F$2 = 10, b2;
  if (0 !== (a2 & 256))
    return F$2 = 9, 256;
  b2 = 3584 & a2;
  if (0 !== b2)
    return F$2 = 8, b2;
  if (0 !== (a2 & 4096))
    return F$2 = 7, 4096;
  b2 = 4186112 & a2;
  if (0 !== b2)
    return F$2 = 6, b2;
  b2 = 62914560 & a2;
  if (0 !== b2)
    return F$2 = 5, b2;
  if (a2 & 67108864)
    return F$2 = 4, 67108864;
  if (0 !== (a2 & 134217728))
    return F$2 = 3, 134217728;
  b2 = 805306368 & a2;
  if (0 !== b2)
    return F$2 = 2, b2;
  if (0 !== (1073741824 & a2))
    return F$2 = 1, 1073741824;
  F$2 = 8;
  return a2;
}
function Sc$1(a2) {
  switch (a2) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc$1(a2) {
  switch (a2) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y$5(358, a2));
  }
}
function Uc$1(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return F$2 = 0;
  var d2 = 0, e2 = 0, f2 = a2.expiredLanes, g2 = a2.suspendedLanes, h2 = a2.pingedLanes;
  if (0 !== f2)
    d2 = f2, e2 = F$2 = 15;
  else if (f2 = c2 & 134217727, 0 !== f2) {
    var k2 = f2 & ~g2;
    0 !== k2 ? (d2 = Rc$1(k2), e2 = F$2) : (h2 &= f2, 0 !== h2 && (d2 = Rc$1(h2), e2 = F$2));
  } else
    f2 = c2 & ~g2, 0 !== f2 ? (d2 = Rc$1(f2), e2 = F$2) : 0 !== h2 && (d2 = Rc$1(h2), e2 = F$2);
  if (0 === d2)
    return 0;
  d2 = 31 - Vc$1(d2);
  d2 = c2 & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & g2)) {
    Rc$1(b2);
    if (e2 <= F$2)
      return b2;
    F$2 = e2;
  }
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - Vc$1(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function Wc$1(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function Xc$1(a2, b2) {
  switch (a2) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a2 = Yc$1(24 & ~b2), 0 === a2 ? Xc$1(10, b2) : a2;
    case 10:
      return a2 = Yc$1(192 & ~b2), 0 === a2 ? Xc$1(8, b2) : a2;
    case 8:
      return a2 = Yc$1(3584 & ~b2), 0 === a2 && (a2 = Yc$1(4186112 & ~b2), 0 === a2 && (a2 = 512)), a2;
    case 2:
      return b2 = Yc$1(805306368 & ~b2), 0 === b2 && (b2 = 268435456), b2;
  }
  throw Error(y$5(358, a2));
}
function Yc$1(a2) {
  return a2 & -a2;
}
function Zc$1(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function $c$1(a2, b2, c2) {
  a2.pendingLanes |= b2;
  var d2 = b2 - 1;
  a2.suspendedLanes &= d2;
  a2.pingedLanes &= d2;
  a2 = a2.eventTimes;
  b2 = 31 - Vc$1(b2);
  a2[b2] = c2;
}
var Vc$1 = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a2) {
  return 0 === a2 ? 32 : 31 - (bd(a2) / cd | 0) | 0;
}
var dd = r$4.unstable_UserBlockingPriority, ed = r$4.unstable_runWithPriority, fd = true;
function gd(a2, b2, c2, d2) {
  Kb || Ib();
  var e2 = hd, f2 = Kb;
  Kb = true;
  try {
    Hb(e2, a2, b2, c2, d2);
  } finally {
    (Kb = f2) || Mb();
  }
}
function id(a2, b2, c2, d2) {
  ed(dd, hd.bind(null, a2, b2, c2, d2));
}
function hd(a2, b2, c2, d2) {
  if (fd) {
    var e2;
    if ((e2 = 0 === (b2 & 4)) && 0 < jc$1.length && -1 < qc$1.indexOf(a2))
      a2 = rc$1(null, a2, b2, c2, d2), jc$1.push(a2);
    else {
      var f2 = yc$1(a2, b2, c2, d2);
      if (null === f2)
        e2 && sc$1(a2, d2);
      else {
        if (e2) {
          if (-1 < qc$1.indexOf(a2)) {
            a2 = rc$1(f2, a2, b2, c2, d2);
            jc$1.push(a2);
            return;
          }
          if (uc$1(f2, a2, b2, c2, d2))
            return;
          sc$1(a2, d2);
        }
        jd(a2, b2, d2, null, c2);
      }
    }
  }
}
function yc$1(a2, b2, c2, d2) {
  var e2 = xb(d2);
  e2 = wc$1(e2);
  if (null !== e2) {
    var f2 = Zb(e2);
    if (null === f2)
      e2 = null;
    else {
      var g2 = f2.tag;
      if (13 === g2) {
        e2 = $b(f2);
        if (null !== e2)
          return e2;
        e2 = null;
      } else if (3 === g2) {
        if (f2.stateNode.hydrate)
          return 3 === f2.tag ? f2.stateNode.containerInfo : null;
        e2 = null;
      } else
        f2 !== e2 && (e2 = null);
    }
  }
  jd(a2, b2, d2, e2, c2);
  return null;
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m$4(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad$1 = m$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd$1 = rd(Ad$1), Cd = m$4({}, Ad$1, { dataTransfer: 0 }), Dd = rd(Cd), Ed$1 = m$4({}, ud, { relatedTarget: 0 }), Fd$1 = rd(Ed$1), Gd = m$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m$4({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m$4({}, sd, { data: 0 }), Ld = rd(Kd), Md$1 = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od$1 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd$1(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od$1[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd$1;
}
var Qd = m$4({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md$1[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = m$4({}, Ad$1, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td$1 = rd(Sd), Ud = m$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd$1 = m$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd$1), Yd = m$4({}, Ad$1, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d$1 = [9, 13, 27, 32], ae$1 = fa$1 && "CompositionEvent" in window, be$1 = null;
fa$1 && "documentMode" in document && (be$1 = document.documentMode);
var ce = fa$1 && "TextEvent" in window && !be$1, de$1 = fa$1 && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d$1.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae$1 && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa$1(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (fa$1) {
  var xe$1;
  if (fa$1) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne$1(b2, qe, a2, xb(a2));
    a2 = re;
    if (Kb)
      a2(b2);
    else {
      Kb = true;
      try {
        Gb(a2, b2);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge$1, Ie = Object.prototype.hasOwnProperty;
function Je(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++)
    if (!Ie.call(b2, c2[d2]) || !He(a2[c2[d2]], b2[c2[d2]]))
      return false;
  return true;
}
function Ke$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Le$1(a2, b2) {
  var c2 = Ke$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Ke$1(c2);
  }
}
function Me(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Me(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Ne() {
  for (var a2 = window, b2 = Xa$1(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa$1(a2.document);
  }
  return b2;
}
function Oe(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
var Pe = fa$1 && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re = null, Se$1 = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe$1 || Qe$1 !== Xa$1(d2) || (d2 = Qe$1, "selectionStart" in d2 && Oe(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Je(Se$1, d2) || (Se$1 = d2, d2 = oe$1(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
Pc$1(
  "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
  0
);
Pc$1("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc$1(Oc$1, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We$1 = 0; We$1 < Ve.length; We$1++)
  Nc$1.set(Ve[We$1], 0);
ea$1("onMouseEnter", ["mouseout", "mouseover"]);
ea$1("onMouseLeave", ["mouseout", "mouseover"]);
ea$1("onPointerEnter", ["pointerout", "pointerover"]);
ea$1("onPointerLeave", ["pointerout", "pointerover"]);
da$1("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da$1("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da$1("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da$1("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da$1("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da$1("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye$1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Yb(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          Ze(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Ub)
    throw a2 = Vb, Ub = false, Vb = null, a2;
}
function G$2(a2, b2) {
  var c2 = $e(b2), d2 = a2 + "__bubble";
  c2.has(d2) || (af(b2, a2, 2, false), c2.add(d2));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a2) {
  a2[bf] || (a2[bf] = true, ba$1.forEach(function(b2) {
    Ye$1.has(b2) || df(b2, false, a2, null);
    df(b2, true, a2, null);
  }));
}
function df(a2, b2, c2, d2) {
  var e2 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c2;
  "selectionchange" === a2 && 9 !== c2.nodeType && (f2 = c2.ownerDocument);
  if (null !== d2 && !b2 && Ye$1.has(a2)) {
    if ("scroll" !== a2)
      return;
    e2 |= 2;
    f2 = d2;
  }
  var g2 = $e(f2), h2 = a2 + "__" + (b2 ? "capture" : "bubble");
  g2.has(h2) || (b2 && (e2 |= 4), af(f2, a2, e2, b2), g2.add(h2));
}
function af(a2, b2, c2, d2) {
  var e2 = Nc$1.get(b2);
  switch (void 0 === e2 ? 2 : e2) {
    case 0:
      e2 = gd;
      break;
    case 1:
      e2 = id;
      break;
    default:
      e2 = hd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Pb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function jd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = wc$1(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Nb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = Mc$1.get(a2);
      if (void 0 !== h3) {
        var k3 = td, x = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            x = "focus";
            k3 = Fd$1;
            break;
          case "focusout":
            x = "blur";
            k3 = Fd$1;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd$1;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd$1;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case Ic$1:
          case Jc$1:
          case Kc$1:
            k3 = Hd;
            break;
          case Lc$1:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td$1;
        }
        var w2 = 0 !== (b2 & 4), z2 = !w2 && "scroll" === a2, u2 = w2 ? null !== h3 ? h3 + "Capture" : null : h3;
        w2 = [];
        for (var t2 = d3, q2; null !== t2; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w2.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w2.length && (h3 = new k3(h3, x, null, c2, e3), g3.push({ event: h3, listeners: w2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && 0 === (b2 & 16) && (x = c2.relatedTarget || c2.fromElement) && (wc$1(x) || x[ff]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (x = c2.relatedTarget || c2.toElement, k3 = d3, x = x ? wc$1(x) : null, null !== x && (z2 = Zb(x), x !== z2 || 5 !== x.tag && 6 !== x.tag))
              x = null;
          } else
            k3 = null, x = d3;
          if (k3 !== x) {
            w2 = Bd$1;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              w2 = Td$1, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = null == k3 ? h3 : ue(k3);
            q2 = null == x ? h3 : ue(x);
            h3 = new w2(v2, t2 + "leave", k3, c2, e3);
            h3.target = z2;
            h3.relatedTarget = q2;
            v2 = null;
            wc$1(e3) === d3 && (w2 = new w2(u2, t2 + "enter", x, c2, e3), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
            z2 = v2;
            if (k3 && x)
              b: {
                w2 = k3;
                u2 = x;
                t2 = 0;
                for (q2 = w2; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w2 = gf(w2), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w2 === u2 || null !== u2 && w2 === u2.alternate)
                    break b;
                  w2 = gf(w2);
                  u2 = gf(u2);
                }
                w2 = null;
              }
            else
              w2 = null;
            null !== k3 && hf(g3, h3, k3, w2, false);
            null !== x && null !== z2 && hf(g3, z2, x, w2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var J2 = ve$1;
        else if (me(h3))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (J2 = Ee);
        if (J2 && (J2 = J2(a2, d3))) {
          ne$1(g3, J2, c2, e3);
          break a;
        }
        K2 && K2(a2, h3, d3);
        "focusout" === a2 && (K2 = h3._wrapperState) && K2.controlled && "number" === h3.type && bb(h3, "number", h3.value);
      }
      K2 = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(K2) || "true" === K2.contentEditable)
            Qe$1 = K2, Re = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re = Qe$1 = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var Q2;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge(a2, c2) && (L2 = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (L2 = "onCompositionStart");
      L2 && (de$1 && "ko" !== c2.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe$1(d3, L2), 0 < K2.length && (L2 = new Ld(L2, a2, null, c2, e3), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he$1(c2), null !== Q2 && (L2.data = Q2))));
      if (Q2 = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe$1(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld(
          "onBeforeInput",
          "beforeinput",
          null,
          c2,
          e3
        ), g3.push({ event: e3, listeners: d3 }), e3.data = Q2);
    }
    se(g3, b2);
  });
}
function ef(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$1(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Ob(a2, c2), null != f2 && d2.unshift(ef(a2, f2, e2)), f2 = Ob(a2, b2), null != f2 && d2.push(ef(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function gf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function hf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Ob(c2, f2), null != k2 && g2.unshift(ef(c2, k2, h2))) : e2 || (k2 = Ob(c2, f2), null != k2 && g2.push(ef(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
function jf() {
}
var kf = null, lf = null;
function mf(a2, b2) {
  switch (a2) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b2.autoFocus;
  }
  return false;
}
function nf(a2, b2) {
  return "textarea" === a2 || "option" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
function qf(a2) {
  1 === a2.nodeType ? a2.textContent = "" : 9 === a2.nodeType && (a2 = a2.body, null != a2 && (a2.textContent = ""));
}
function rf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
  }
  return a2;
}
function sf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a2) {
  return { $$typeof: Ga, toString: a2, valueOf: a2 };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc$1(a2) {
  var b2 = a2[wf];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[ff] || c2[wf]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = sf(a2); null !== a2; ) {
          if (c2 = a2[wf])
            return c2;
          a2 = sf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[wf] || a2[ff];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(y$5(33));
}
function Db(a2) {
  return a2[xf] || null;
}
function $e(a2) {
  var b2 = a2[yf];
  void 0 === b2 && (b2 = a2[yf] = /* @__PURE__ */ new Set());
  return b2;
}
var zf = [], Af = -1;
function Bf(a2) {
  return { current: a2 };
}
function H$1(a2) {
  0 > Af || (a2.current = zf[Af], zf[Af] = null, Af--);
}
function I$2(a2, b2) {
  Af++;
  zf[Af] = a2.current;
  a2.current = b2;
}
var Cf = {}, M$1 = Bf(Cf), N = Bf(false), Df = Cf;
function Ef(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Cf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Ff(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function Gf() {
  H$1(N);
  H$1(M$1);
}
function Hf(a2, b2, c2) {
  if (M$1.current !== Cf)
    throw Error(y$5(168));
  I$2(M$1, b2);
  I$2(N, c2);
}
function If(a2, b2, c2) {
  var d2 = a2.stateNode;
  a2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in a2))
      throw Error(y$5(108, Ra$1(b2) || "Unknown", e2));
  return m$4({}, c2, d2);
}
function Jf(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M$1.current;
  I$2(M$1, a2);
  I$2(N, N.current);
  return true;
}
function Kf(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(y$5(169));
  c2 ? (a2 = If(a2, b2, Df), d2.__reactInternalMemoizedMergedChildContext = a2, H$1(N), H$1(M$1), I$2(M$1, a2)) : H$1(N);
  I$2(N, c2);
}
var Lf = null, Mf = null, Nf = r$4.unstable_runWithPriority, Of = r$4.unstable_scheduleCallback, Pf = r$4.unstable_cancelCallback, Qf = r$4.unstable_shouldYield, Rf = r$4.unstable_requestPaint, Sf = r$4.unstable_now, Tf = r$4.unstable_getCurrentPriorityLevel, Uf = r$4.unstable_ImmediatePriority, Vf = r$4.unstable_UserBlockingPriority, Wf = r$4.unstable_NormalPriority, Xf = r$4.unstable_LowPriority, Yf = r$4.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O$1 = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y$5(332));
  }
}
function fg(a2) {
  switch (a2) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y$5(332));
  }
}
function gg(a2, b2) {
  a2 = fg(a2);
  return Nf(a2, b2);
}
function hg(a2, b2, c2) {
  a2 = fg(a2);
  return Of(a2, b2, c2);
}
function ig() {
  if (null !== bg) {
    var a2 = bg;
    bg = null;
    Pf(a2);
  }
  jg();
}
function jg() {
  if (!cg && null !== ag) {
    cg = true;
    var a2 = 0;
    try {
      var b2 = ag;
      gg(99, function() {
        for (; a2 < b2.length; a2++) {
          var c2 = b2[a2];
          do
            c2 = c2(true);
          while (null !== c2);
        }
      });
      ag = null;
    } catch (c2) {
      throw null !== ag && (ag = ag.slice(a2 + 1)), Of(Uf, ig), c2;
    } finally {
      cg = false;
    }
  }
}
var kg = ra$1.ReactCurrentBatchConfig;
function lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = m$4({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a2) {
  var b2 = mg.current;
  H$1(mg);
  a2.type._context._currentValue = b2;
}
function sg(a2, b2) {
  for (; null !== a2; ) {
    var c2 = a2.alternate;
    if ((a2.childLanes & b2) === b2)
      if (null === c2 || (c2.childLanes & b2) === b2)
        break;
      else
        c2.childLanes |= b2;
    else
      a2.childLanes |= b2, null !== c2 && (c2.childLanes |= b2);
    a2 = a2.return;
  }
}
function tg(a2, b2) {
  ng = a2;
  pg = og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (ug = true), a2.firstContext = null);
}
function vg(a2, b2) {
  if (pg !== a2 && false !== b2 && 0 !== b2) {
    if ("number" !== typeof b2 || 1073741823 === b2)
      pg = a2, b2 = 1073741823;
    b2 = { context: a2, observedBits: b2, next: null };
    if (null === og) {
      if (null === ng)
        throw Error(y$5(308));
      og = b2;
      ng.dependencies = { lanes: 0, firstContext: b2, responders: null };
    } else
      og = og.next = b2;
  }
  return a2._currentValue;
}
var wg = false;
function xg(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function zg(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a2, b2) {
  a2 = a2.updateQueue;
  if (null !== a2) {
    a2 = a2.shared;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
}
function Bg(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function Cg(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  wg = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var n2 = a2.alternate;
    if (null !== n2) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k2);
    }
  }
  if (null !== f2) {
    A2 = e2.baseState;
    g2 = 0;
    n2 = l2 = k2 = null;
    do {
      h2 = f2.lane;
      var p2 = f2.eventTime;
      if ((d2 & h2) === h2) {
        null !== n2 && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f2.tag,
          payload: f2.payload,
          callback: f2.callback,
          next: null
        });
        a: {
          var C2 = a2, x = f2;
          h2 = b2;
          p2 = c2;
          switch (x.tag) {
            case 1:
              C2 = x.payload;
              if ("function" === typeof C2) {
                A2 = C2.call(p2, A2, h2);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x.payload;
              h2 = "function" === typeof C2 ? C2.call(p2, A2, h2) : C2;
              if (null === h2 || void 0 === h2)
                break a;
              A2 = m$4({}, A2, h2);
              break a;
            case 2:
              wg = true;
          }
        }
        null !== f2.callback && (a2.flags |= 32, h2 = e2.effects, null === h2 ? e2.effects = [f2] : h2.push(f2));
      } else
        p2 = { eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p2, k2 = A2) : n2 = n2.next = p2, g2 |= h2;
      f2 = f2.next;
      if (null === f2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          f2 = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
    } while (1);
    null === n2 && (k2 = A2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = n2;
    Dg |= g2;
    a2.lanes = g2;
    a2.memoizedState = A2;
  }
}
function Eg(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(y$5(191, e2));
        e2.call(d2);
      }
    }
}
var Fg = new aa$1.Component().refs;
function Gg(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : m$4({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Kg = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Zb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = Hg(), e2 = Ig(a2), f2 = zg(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  Ag(a2, f2);
  Jg(a2, e2, d2);
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = Hg(), e2 = Ig(a2), f2 = zg(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  Ag(a2, f2);
  Jg(a2, e2, d2);
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = Hg(), d2 = Ig(a2), e2 = zg(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  Ag(a2, e2);
  Jg(a2, d2, c2);
} };
function Lg(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Je(c2, d2) || !Je(e2, f2) : true;
}
function Mg(a2, b2, c2) {
  var d2 = false, e2 = Cf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e2 = Ff(b2) ? Df : M$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Ef(a2, e2) : Cf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Kg;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Ng(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Kg.enqueueReplaceState(b2, b2.state, null);
}
function Og(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = Fg;
  xg(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = vg(f2) : (f2 = Ff(b2) ? Df : M$1.current, e2.context = Ef(a2, f2));
  Cg(a2, c2, e2, d2);
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Gg(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Kg.enqueueReplaceState(e2, e2.state, null), Cg(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(y$5(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(y$5(147, a2));
      var e2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === e2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = d2.refs;
        b3 === Fg && (b3 = d2.refs = {});
        null === a3 ? delete b3[e2] : b3[e2] = a3;
      };
      b2._stringRef = e2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(y$5(284));
    if (!c2._owner)
      throw Error(y$5(290, a2));
  }
  return a2;
}
function Rg(a2, b2) {
  if ("textarea" !== a2.type)
    throw Error(y$5(31, "[object Object]" === Object.prototype.toString.call(b2) ? "object with keys {" + Object.keys(b2).join(", ") + "}" : b2));
}
function Sg(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.lastEffect;
      null !== d3 ? (d3.nextEffect = c3, b3.lastEffect = c3) : b3.firstEffect = b3.lastEffect = c3;
      c3.nextEffect = null;
      c3.flags = 8;
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = Tg(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags = 2, c3) : d3;
    b3.flags = 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags = 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = Ug(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    if (null !== b3 && b3.elementType === c3.type)
      return d3 = e2(b3, c3.props), d3.ref = Qg(a3, b3, c3), d3.return = a3, d3;
    d3 = Vg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Qg(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = Wg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function n2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Xg(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function A2(a3, b3, c3) {
    if ("string" === typeof b3 || "number" === typeof b3)
      return b3 = Ug("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case sa$1:
          return c3 = Vg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Qg(a3, null, b3), c3.return = a3, c3;
        case ta$1:
          return b3 = Wg(b3, a3.mode, c3), b3.return = a3, b3;
      }
      if (Pg(b3) || La$1(b3))
        return b3 = Xg(
          b3,
          a3.mode,
          c3,
          null
        ), b3.return = a3, b3;
      Rg(a3, b3);
    }
    return null;
  }
  function p2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case sa$1:
          return c3.key === e3 ? c3.type === ua$1 ? n2(a3, b3, c3.props.children, d3, e3) : k2(a3, b3, c3, d3) : null;
        case ta$1:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
      }
      if (Pg(c3) || La$1(c3))
        return null !== e3 ? null : n2(a3, b3, c3, d3, null);
      Rg(a3, c3);
    }
    return null;
  }
  function C2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case sa$1:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, d3.type === ua$1 ? n2(b3, a3, d3.props.children, e3, d3.key) : k2(b3, a3, d3, e3);
        case ta$1:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
      }
      if (Pg(d3) || La$1(d3))
        return a3 = a3.get(c3) || null, n2(b3, a3, d3, e3, null);
      Rg(b3, d3);
    }
    return null;
  }
  function x(e3, g3, h3, k3) {
    for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h3.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e3, u2, h3[z2], k3);
      if (null === n3) {
        null === u2 && (u2 = q2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, z2);
      null === t2 ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h3.length)
      return c2(e3, u2), l3;
    if (null === u2) {
      for (; z2 < h3.length; z2++)
        u2 = A2(e3, h3[z2], k3), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d2(e3, u2); z2 < h3.length; z2++)
      q2 = C2(u2, e3, z2, h3[z2], k3), null !== q2 && (a2 && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    return l3;
  }
  function w2(e3, g3, h3, k3) {
    var l3 = La$1(h3);
    if ("function" !== typeof l3)
      throw Error(y$5(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(y$5(151));
    for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); null !== u2 && !n3.done; z2++, n3 = h3.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w3 = p2(e3, u2, n3.value, k3);
      if (null === w3) {
        null === u2 && (u2 = q2);
        break;
      }
      a2 && u2 && null === w3.alternate && b2(e3, u2);
      g3 = f2(w3, g3, z2);
      null === t2 ? l3 = w3 : t2.sibling = w3;
      t2 = w3;
      u2 = q2;
    }
    if (n3.done)
      return c2(e3, u2), l3;
    if (null === u2) {
      for (; !n3.done; z2++, n3 = h3.next())
        n3 = A2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d2(e3, u2); !n3.done; z2++, n3 = h3.next())
      n3 = C2(u2, e3, z2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    return l3;
  }
  return function(a3, d3, f3, h3) {
    var k3 = "object" === typeof f3 && null !== f3 && f3.type === ua$1 && null === f3.key;
    k3 && (f3 = f3.props.children);
    var l3 = "object" === typeof f3 && null !== f3;
    if (l3)
      switch (f3.$$typeof) {
        case sa$1:
          a: {
            l3 = f3.key;
            for (k3 = d3; null !== k3; ) {
              if (k3.key === l3) {
                switch (k3.tag) {
                  case 7:
                    if (f3.type === ua$1) {
                      c2(a3, k3.sibling);
                      d3 = e2(k3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                    break;
                  default:
                    if (k3.elementType === f3.type) {
                      c2(a3, k3.sibling);
                      d3 = e2(k3, f3.props);
                      d3.ref = Qg(a3, k3, f3);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                }
                c2(a3, k3);
                break;
              } else
                b2(a3, k3);
              k3 = k3.sibling;
            }
            f3.type === ua$1 ? (d3 = Xg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Vg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Qg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case ta$1:
          a: {
            for (k3 = f3.key; null !== d3; ) {
              if (d3.key === k3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Wg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
      }
    if ("string" === typeof f3 || "number" === typeof f3)
      return f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Ug(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3);
    if (Pg(f3))
      return x(a3, d3, f3, h3);
    if (La$1(f3))
      return w2(a3, d3, f3, h3);
    l3 && Rg(a3, f3);
    if ("undefined" === typeof f3 && !k3)
      switch (a3.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y$5(152, Ra$1(a3.type) || "Component"));
      }
    return c2(a3, d3);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch$1 = Bf($g);
function dh$1(a2) {
  if (a2 === $g)
    throw Error(y$5(174));
  return a2;
}
function eh(a2, b2) {
  I$2(ch$1, b2);
  I$2(bh, a2);
  I$2(ah, $g);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : mb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = mb(b2, a2);
  }
  H$1(ah);
  I$2(ah, b2);
}
function fh() {
  H$1(ah);
  H$1(bh);
  H$1(ch$1);
}
function gh$1(a2) {
  dh$1(ch$1.current);
  var b2 = dh$1(ah.current);
  var c2 = mb(b2, a2.type);
  b2 !== c2 && (I$2(bh, a2), I$2(ah, c2));
}
function hh(a2) {
  bh.current === a2 && (H$1(ah), H$1(bh));
}
var P$1 = Bf(0);
function ih(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 64))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var jh = null, kh = null, lh$1 = false;
function mh$1(a2, b2) {
  var c2 = nh(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.type = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  c2.flags = 8;
  null !== a2.lastEffect ? (a2.lastEffect.nextEffect = c2, a2.lastEffect = c2) : a2.firstEffect = a2.lastEffect = c2;
}
function oh(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a2) {
  if (lh$1) {
    var b2 = kh;
    if (b2) {
      var c2 = b2;
      if (!oh(a2, b2)) {
        b2 = rf(c2.nextSibling);
        if (!b2 || !oh(a2, b2)) {
          a2.flags = a2.flags & -1025 | 2;
          lh$1 = false;
          jh = a2;
          return;
        }
        mh$1(jh, c2);
      }
      jh = a2;
      kh = rf(b2.firstChild);
    } else
      a2.flags = a2.flags & -1025 | 2, lh$1 = false, jh = a2;
  }
}
function qh(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  jh = a2;
}
function rh$1(a2) {
  if (a2 !== jh)
    return false;
  if (!lh$1)
    return qh(a2), lh$1 = true, false;
  var b2 = a2.type;
  if (5 !== a2.tag || "head" !== b2 && "body" !== b2 && !nf(b2, a2.memoizedProps))
    for (b2 = kh; b2; )
      mh$1(a2, b2), b2 = rf(b2.nextSibling);
  qh(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(y$5(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              kh = rf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a2.stateNode.nextSibling) : null;
  return true;
}
function sh$1() {
  kh = jh = null;
  lh$1 = false;
}
var th = [];
function uh() {
  for (var a2 = 0; a2 < th.length; a2++)
    th[a2]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh$1 = ra$1.ReactCurrentDispatcher, wh$1 = ra$1.ReactCurrentBatchConfig, xh = 0, R = null, S$1 = null, T$1 = null, yh$1 = false, zh = false;
function Ah$1() {
  throw Error(y$5(321));
}
function Bh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Ch(a2, b2, c2, d2, e2, f2) {
  xh = f2;
  R = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  vh$1.current = null === a2 || null === a2.memoizedState ? Dh : Eh;
  a2 = c2(d2, e2);
  if (zh) {
    f2 = 0;
    do {
      zh = false;
      if (!(25 > f2))
        throw Error(y$5(301));
      f2 += 1;
      T$1 = S$1 = null;
      b2.updateQueue = null;
      vh$1.current = Fh;
      a2 = c2(d2, e2);
    } while (zh);
  }
  vh$1.current = Gh;
  b2 = null !== S$1 && null !== S$1.next;
  xh = 0;
  T$1 = S$1 = R = null;
  yh$1 = false;
  if (b2)
    throw Error(y$5(300));
  return a2;
}
function Hh() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === T$1 ? R.memoizedState = T$1 = a2 : T$1 = T$1.next = a2;
  return T$1;
}
function Ih$1() {
  if (null === S$1) {
    var a2 = R.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = S$1.next;
  var b2 = null === T$1 ? R.memoizedState : T$1.next;
  if (null !== b2)
    T$1 = b2, S$1 = a2;
  else {
    if (null === a2)
      throw Error(y$5(310));
    S$1 = a2;
    a2 = { memoizedState: S$1.memoizedState, baseState: S$1.baseState, baseQueue: S$1.baseQueue, queue: S$1.queue, next: null };
    null === T$1 ? R.memoizedState = T$1 = a2 : T$1 = T$1.next = a2;
  }
  return T$1;
}
function Jh(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Kh$1(a2) {
  var b2 = Ih$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(y$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = S$1, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    e2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = f2 = null, k2 = e2;
    do {
      var l2 = k2.lane;
      if ((xh & l2) === l2)
        null !== h2 && (h2 = h2.next = { lane: 0, action: k2.action, eagerReducer: k2.eagerReducer, eagerState: k2.eagerState, next: null }), d2 = k2.eagerReducer === a2 ? k2.eagerState : a2(d2, k2.action);
      else {
        var n2 = {
          lane: l2,
          action: k2.action,
          eagerReducer: k2.eagerReducer,
          eagerState: k2.eagerState,
          next: null
        };
        null === h2 ? (g2 = h2 = n2, f2 = d2) : h2 = h2.next = n2;
        R.lanes |= l2;
        Dg |= l2;
      }
      k2 = k2.next;
    } while (null !== k2 && k2 !== e2);
    null === h2 ? f2 = d2 : h2.next = g2;
    He(d2, b2.memoizedState) || (ug = true);
    b2.memoizedState = d2;
    b2.baseState = f2;
    b2.baseQueue = h2;
    c2.lastRenderedState = d2;
  }
  return [b2.memoizedState, c2.dispatch];
}
function Lh(a2) {
  var b2 = Ih$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(y$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Mh(a2, b2, c2) {
  var d2 = b2._getVersion;
  d2 = d2(b2._source);
  var e2 = b2._workInProgressVersionPrimary;
  if (null !== e2)
    a2 = e2 === d2;
  else if (a2 = a2.mutableReadLanes, a2 = (xh & a2) === a2)
    b2._workInProgressVersionPrimary = d2, th.push(b2);
  if (a2)
    return c2(b2._source);
  th.push(b2);
  throw Error(y$5(350));
}
function Nh(a2, b2, c2, d2) {
  var e2 = U$1;
  if (null === e2)
    throw Error(y$5(349));
  var f2 = b2._getVersion, g2 = f2(b2._source), h2 = vh$1.current, k2 = h2.useState(function() {
    return Mh(e2, b2, c2);
  }), l2 = k2[1], n2 = k2[0];
  k2 = T$1;
  var A2 = a2.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x = A2.source;
  A2 = A2.subscribe;
  var w2 = R;
  a2.memoizedState = { refs: p2, source: b2, subscribe: d2 };
  h2.useEffect(function() {
    p2.getSnapshot = c2;
    p2.setSnapshot = l2;
    var a3 = f2(b2._source);
    if (!He(g2, a3)) {
      a3 = c2(b2._source);
      He(n2, a3) || (l2(a3), a3 = Ig(w2), e2.mutableReadLanes |= a3 & e2.pendingLanes);
      a3 = e2.mutableReadLanes;
      e2.entangledLanes |= a3;
      for (var d3 = e2.entanglements, h3 = a3; 0 < h3; ) {
        var k3 = 31 - Vc$1(h3), v2 = 1 << k3;
        d3[k3] |= a3;
        h3 &= ~v2;
      }
    }
  }, [c2, b2, d2]);
  h2.useEffect(function() {
    return d2(b2._source, function() {
      var a3 = p2.getSnapshot, c3 = p2.setSnapshot;
      try {
        c3(a3(b2._source));
        var d3 = Ig(w2);
        e2.mutableReadLanes |= d3 & e2.pendingLanes;
      } catch (q2) {
        c3(function() {
          throw q2;
        });
      }
    });
  }, [b2, d2]);
  He(C2, c2) && He(x, b2) && He(A2, d2) || (a2 = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a2.dispatch = l2 = Oh.bind(null, R, a2), k2.queue = a2, k2.baseQueue = null, n2 = Mh(e2, b2, c2), k2.memoizedState = k2.baseState = n2);
  return n2;
}
function Ph(a2, b2, c2) {
  var d2 = Ih$1();
  return Nh(d2, a2, b2, c2);
}
function Qh(a2) {
  var b2 = Hh();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = b2.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a2 };
  a2 = a2.dispatch = Oh.bind(null, R, a2);
  return [b2.memoizedState, a2];
}
function Rh(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = R.updateQueue;
  null === b2 ? (b2 = { lastEffect: null }, R.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function Sh$1(a2) {
  var b2 = Hh();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}
function Th$1() {
  return Ih$1().memoizedState;
}
function Uh(a2, b2, c2, d2) {
  var e2 = Hh();
  R.flags |= a2;
  e2.memoizedState = Rh(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function Vh(a2, b2, c2, d2) {
  var e2 = Ih$1();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== S$1) {
    var g2 = S$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Bh(d2, g2.deps)) {
      Rh(b2, c2, f2, d2);
      return;
    }
  }
  R.flags |= a2;
  e2.memoizedState = Rh(1 | b2, c2, f2, d2);
}
function Wh(a2, b2) {
  return Uh(516, 4, a2, b2);
}
function Xh(a2, b2) {
  return Vh(516, 4, a2, b2);
}
function Yh(a2, b2) {
  return Vh(4, 2, a2, b2);
}
function Zh(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function $h$1(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return Vh(4, 2, Zh.bind(null, b2, a2), c2);
}
function ai() {
}
function bi$1(a2, b2) {
  var c2 = Ih$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ci(a2, b2) {
  var c2 = Ih$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function di(a2, b2) {
  var c2 = eg();
  gg(98 > c2 ? 98 : c2, function() {
    a2(true);
  });
  gg(97 < c2 ? 97 : c2, function() {
    var c3 = wh$1.transition;
    wh$1.transition = 1;
    try {
      a2(false), b2();
    } finally {
      wh$1.transition = c3;
    }
  });
}
function Oh(a2, b2, c2) {
  var d2 = Hg(), e2 = Ig(a2), f2 = { lane: e2, action: c2, eagerReducer: null, eagerState: null, next: null }, g2 = b2.pending;
  null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
  b2.pending = f2;
  g2 = a2.alternate;
  if (a2 === R || null !== g2 && g2 === R)
    zh = yh$1 = true;
  else {
    if (0 === a2.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b2.lastRenderedReducer, null !== g2))
      try {
        var h2 = b2.lastRenderedState, k2 = g2(h2, c2);
        f2.eagerReducer = g2;
        f2.eagerState = k2;
        if (He(k2, h2))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a2, e2, d2);
  }
}
var Gh = { readContext: vg, useCallback: Ah$1, useContext: Ah$1, useEffect: Ah$1, useImperativeHandle: Ah$1, useLayoutEffect: Ah$1, useMemo: Ah$1, useReducer: Ah$1, useRef: Ah$1, useState: Ah$1, useDebugValue: Ah$1, useDeferredValue: Ah$1, useTransition: Ah$1, useMutableSource: Ah$1, useOpaqueIdentifier: Ah$1, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a2, b2) {
  Hh().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return Uh(4, 2, Zh.bind(
    null,
    b2,
    a2
  ), c2);
}, useLayoutEffect: function(a2, b2) {
  return Uh(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Hh();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Hh();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = d2.queue = { pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  a2 = a2.dispatch = Oh.bind(null, R, a2);
  return [d2.memoizedState, a2];
}, useRef: Sh$1, useState: Qh, useDebugValue: ai, useDeferredValue: function(a2) {
  var b2 = Qh(a2), c2 = b2[0], d2 = b2[1];
  Wh(function() {
    var b3 = wh$1.transition;
    wh$1.transition = 1;
    try {
      d2(a2);
    } finally {
      wh$1.transition = b3;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Qh(false), b2 = a2[0];
  a2 = di.bind(null, a2[1]);
  Sh$1(a2);
  return [a2, b2];
}, useMutableSource: function(a2, b2, c2) {
  var d2 = Hh();
  d2.memoizedState = { refs: { getSnapshot: b2, setSnapshot: null }, source: a2, subscribe: c2 };
  return Nh(d2, a2, b2, c2);
}, useOpaqueIdentifier: function() {
  if (lh$1) {
    var a2 = false, b2 = uf(function() {
      a2 || (a2 = true, c2("r:" + (tf++).toString(36)));
      throw Error(y$5(355));
    }), c2 = Qh(b2)[1];
    0 === (R.mode & 2) && (R.flags |= 516, Rh(
      5,
      function() {
        c2("r:" + (tf++).toString(36));
      },
      void 0,
      null
    ));
    return b2;
  }
  b2 = "r:" + (tf++).toString(36);
  Qh(b2);
  return b2;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi$1, useContext: vg, useEffect: Xh, useImperativeHandle: $h$1, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh$1, useRef: Th$1, useState: function() {
  return Kh$1(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b2 = Kh$1(Jh), c2 = b2[0], d2 = b2[1];
  Xh(function() {
    var b3 = wh$1.transition;
    wh$1.transition = 1;
    try {
      d2(a2);
    } finally {
      wh$1.transition = b3;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Kh$1(Jh)[0];
  return [
    Th$1().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh$1(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi$1, useContext: vg, useEffect: Xh, useImperativeHandle: $h$1, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th$1, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a2) {
  var b2 = Lh(Jh), c2 = b2[0], d2 = b2[1];
  Xh(function() {
    var b3 = wh$1.transition;
    wh$1.transition = 1;
    try {
      d2(a2);
    } finally {
      wh$1.transition = b3;
    }
  }, [a2]);
  return c2;
}, useTransition: function() {
  var a2 = Lh(Jh)[0];
  return [
    Th$1().current,
    a2
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra$1.ReactCurrentOwner, ug = false;
function fi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Zg(b2, null, c2, d2) : Yg(b2, a2.child, c2, d2);
}
function gi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  tg(b2, e2);
  d2 = Ch(a2, b2, c2, d2, f2, e2);
  if (null !== a2 && !ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, hi(a2, b2, e2);
  b2.flags |= 1;
  fi(a2, b2, d2, e2);
  return b2.child;
}
function ii(a2, b2, c2, d2, e2, f2) {
  if (null === a2) {
    var g2 = c2.type;
    if ("function" === typeof g2 && !ji$1(g2) && void 0 === g2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = g2, ki$1(a2, b2, g2, d2, e2, f2);
    a2 = Vg(c2.type, null, d2, b2, b2.mode, f2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  g2 = a2.child;
  if (0 === (e2 & f2) && (e2 = g2.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : Je, c2(e2, d2) && a2.ref === b2.ref))
    return hi(a2, b2, f2);
  b2.flags |= 1;
  a2 = Tg(g2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function ki$1(a2, b2, c2, d2, e2, f2) {
  if (null !== a2 && Je(a2.memoizedProps, d2) && a2.ref === b2.ref)
    if (ug = false, 0 !== (f2 & e2))
      0 !== (a2.flags & 16384) && (ug = true);
    else
      return b2.lanes = a2.lanes, hi(a2, b2, f2);
  return li(a2, b2, c2, d2, f2);
}
function mi(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode || "unstable-defer-without-hiding" === d2.mode)
    if (0 === (b2.mode & 4))
      b2.memoizedState = { baseLanes: 0 }, ni(b2, c2);
    else if (0 !== (c2 & 1073741824))
      b2.memoizedState = { baseLanes: 0 }, ni(b2, null !== f2 ? f2.baseLanes : c2);
    else
      return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2 }, ni(b2, a2), null;
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, ni(b2, d2);
  fi(a2, b2, e2, c2);
  return b2.child;
}
function oi(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 128;
}
function li(a2, b2, c2, d2, e2) {
  var f2 = Ff(c2) ? Df : M$1.current;
  f2 = Ef(b2, f2);
  tg(b2, e2);
  c2 = Ch(a2, b2, c2, d2, f2, e2);
  if (null !== a2 && !ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, hi(a2, b2, e2);
  b2.flags |= 1;
  fi(a2, b2, c2, e2);
  return b2.child;
}
function pi(a2, b2, c2, d2, e2) {
  if (Ff(c2)) {
    var f2 = true;
    Jf(b2);
  } else
    f2 = false;
  tg(b2, e2);
  if (null === b2.stateNode)
    null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), Mg(b2, c2, d2), Og(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c2) ? Df : M$1.current, l2 = Ef(b2, l2));
    var n2 = c2.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Ng(b2, g2, d2, l2);
    wg = false;
    var p2 = b2.memoizedState;
    g2.state = p2;
    Cg(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || p2 !== k2 || N.current || wg ? ("function" === typeof n2 && (Gg(b2, c2, n2, d2), k2 = b2.memoizedState), (h2 = wg || Lg(b2, c2, h2, d2, p2, k2, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), d2 = false);
  } else {
    g2 = b2.stateNode;
    yg(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : lg(b2.type, h2);
    g2.props = l2;
    A2 = b2.pendingProps;
    p2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = vg(k2) : (k2 = Ff(c2) ? Df : M$1.current, k2 = Ef(b2, k2));
    var C2 = c2.getDerivedStateFromProps;
    (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== A2 || p2 !== k2) && Ng(b2, g2, d2, k2);
    wg = false;
    p2 = b2.memoizedState;
    g2.state = p2;
    Cg(b2, d2, g2, e2);
    var x = b2.memoizedState;
    h2 !== A2 || p2 !== x || N.current || wg ? ("function" === typeof C2 && (Gg(b2, c2, C2, d2), x = b2.memoizedState), (l2 = wg || Lg(b2, c2, l2, d2, p2, x, k2)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
      d2,
      x,
      k2
    ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, x, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 256), b2.memoizedProps = d2, b2.memoizedState = x), g2.props = d2, g2.state = x, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 256), d2 = false);
  }
  return qi$1(a2, b2, c2, d2, f2, e2);
}
function qi$1(a2, b2, c2, d2, e2, f2) {
  oi(a2, b2);
  var g2 = 0 !== (b2.flags & 64);
  if (!d2 && !g2)
    return e2 && Kf(b2, c2, false), hi(a2, b2, f2);
  d2 = b2.stateNode;
  ei.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Yg(b2, a2.child, null, f2), b2.child = Yg(b2, null, h2, f2)) : fi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && Kf(b2, c2, true);
  return b2.child;
}
function ri(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? Hf(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && Hf(a2, b2.context, false);
  eh(a2, b2.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = P$1.current, f2 = false, g2;
  (g2 = 0 !== (b2.flags & 64)) || (g2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  g2 ? (f2 = true, b2.flags &= -65) : null !== a2 && null === a2.memoizedState || void 0 === d2.fallback || true === d2.unstable_avoidThisFallback || (e2 |= 1);
  I$2(P$1, e2 & 1);
  if (null === a2) {
    void 0 !== d2.fallback && ph(b2);
    a2 = d2.children;
    e2 = d2.fallback;
    if (f2)
      return a2 = ui(b2, a2, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, a2;
    if ("number" === typeof d2.unstable_expectedLoadTime)
      return a2 = ui(b2, a2, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, b2.lanes = 33554432, a2;
    c2 = vi({ mode: "visible", children: a2 }, b2.mode, c2, null);
    c2.return = b2;
    return b2.child = c2;
  }
  if (null !== a2.memoizedState) {
    if (f2)
      return d2 = wi(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = si, d2;
    c2 = xi(a2, b2, d2.children, c2);
    b2.memoizedState = null;
    return c2;
  }
  if (f2)
    return d2 = wi(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = si, d2;
  c2 = xi(a2, b2, d2.children, c2);
  b2.memoizedState = null;
  return c2;
}
function ui(a2, b2, c2, d2) {
  var e2 = a2.mode, f2 = a2.child;
  b2 = { mode: "hidden", children: b2 };
  0 === (e2 & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b2) : f2 = vi(b2, e2, 0, null);
  c2 = Xg(c2, e2, d2, null);
  f2.return = a2;
  c2.return = a2;
  f2.sibling = c2;
  a2.child = f2;
  return c2;
}
function xi(a2, b2, c2, d2) {
  var e2 = a2.child;
  a2 = e2.sibling;
  c2 = Tg(e2, { mode: "visible", children: c2 });
  0 === (b2.mode & 2) && (c2.lanes = d2);
  c2.return = b2;
  c2.sibling = null;
  null !== a2 && (a2.nextEffect = null, a2.flags = 8, b2.firstEffect = b2.lastEffect = a2);
  return b2.child = c2;
}
function wi(a2, b2, c2, d2, e2) {
  var f2 = b2.mode, g2 = a2.child;
  a2 = g2.sibling;
  var h2 = { mode: "hidden", children: c2 };
  0 === (f2 & 2) && b2.child !== g2 ? (c2 = b2.child, c2.childLanes = 0, c2.pendingProps = h2, g2 = c2.lastEffect, null !== g2 ? (b2.firstEffect = c2.firstEffect, b2.lastEffect = g2, g2.nextEffect = null) : b2.firstEffect = b2.lastEffect = null) : c2 = Tg(g2, h2);
  null !== a2 ? d2 = Tg(a2, d2) : (d2 = Xg(d2, f2, e2, null), d2.flags |= 2);
  d2.return = b2;
  c2.return = b2;
  c2.sibling = d2;
  b2.child = c2;
  return d2;
}
function yi(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  sg(a2.return, b2);
}
function zi$1(a2, b2, c2, d2, e2, f2) {
  var g2 = a2.memoizedState;
  null === g2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2, lastEffect: f2 } : (g2.isBackwards = b2, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d2, g2.tail = c2, g2.tailMode = e2, g2.lastEffect = f2);
}
function Ai$1(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  fi(a2, b2, d2.children, c2);
  d2 = P$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 64;
  else {
    if (null !== a2 && 0 !== (a2.flags & 64))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && yi(a2, c2);
          else if (19 === a2.tag)
            yi(a2, c2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  I$2(P$1, d2);
  if (0 === (b2.mode & 2))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === ih(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        zi$1(b2, false, e2, c2, f2, b2.lastEffect);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === ih(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        zi$1(b2, true, c2, null, f2, b2.lastEffect);
        break;
      case "together":
        zi$1(b2, false, null, null, void 0, b2.lastEffect);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function hi(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  Dg |= b2.lanes;
  if (0 !== (c2 & b2.childLanes)) {
    if (null !== a2 && b2.child !== a2.child)
      throw Error(y$5(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = Tg(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; )
        a2 = a2.sibling, c2 = c2.sibling = Tg(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  return null;
}
var Bi$1, Ci, Di$1, Ei$1;
Bi$1 = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Ci = function() {
};
Di$1 = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    dh$1(ah.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "option":
        e2 = eb(a2, e2);
        d2 = eb(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = m$4({}, e2, { value: void 0 });
        d2 = m$4({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = jf);
    }
    vb(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca$1.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(l2, c2)), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca$1.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && G$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : "object" === typeof k2 && null !== k2 && k2.$$typeof === Ga ? k2.toString() : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push(
      "style",
      c2
    );
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Ei$1 = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Fi$1(a2, b2) {
  if (!lh$1)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function Gi$1(a2, b2, c2) {
  var d2 = b2.pendingProps;
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b2.type) && Gf(), null;
    case 3:
      fh();
      H$1(N);
      H$1(M$1);
      uh();
      d2 = b2.stateNode;
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        rh$1(b2) ? b2.flags |= 4 : d2.hydrate || (b2.flags |= 256);
      Ci(b2);
      return null;
    case 5:
      hh(b2);
      var e2 = dh$1(ch$1.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Di$1(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 128);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(y$5(166));
          return null;
        }
        a2 = dh$1(ah.current);
        if (rh$1(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[wf] = b2;
          d2[xf] = f2;
          switch (c2) {
            case "dialog":
              G$2("cancel", d2);
              G$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              G$2("load", d2);
              break;
            case "video":
            case "audio":
              for (a2 = 0; a2 < Xe.length; a2++)
                G$2(Xe[a2], d2);
              break;
            case "source":
              G$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              G$2("error", d2);
              G$2("load", d2);
              break;
            case "details":
              G$2("toggle", d2);
              break;
            case "input":
              Za$1(d2, f2);
              G$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              G$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), G$2("invalid", d2);
          }
          vb(c2, f2);
          a2 = null;
          for (var g2 in f2)
            f2.hasOwnProperty(g2) && (e2 = f2[g2], "children" === g2 ? "string" === typeof e2 ? d2.textContent !== e2 && (a2 = ["children", e2]) : "number" === typeof e2 && d2.textContent !== "" + e2 && (a2 = ["children", "" + e2]) : ca$1.hasOwnProperty(g2) && null != e2 && "onScroll" === g2 && G$2("scroll", d2));
          switch (c2) {
            case "input":
              Va$1(d2);
              cb(d2, f2, true);
              break;
            case "textarea":
              Va$1(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = jf);
          }
          d2 = a2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          a2 === kb.html && (a2 = lb(c2));
          a2 === kb.html ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[wf] = b2;
          a2[xf] = d2;
          Bi$1(a2, b2, false, false);
          b2.stateNode = a2;
          g2 = wb(c2, d2);
          switch (c2) {
            case "dialog":
              G$2("cancel", a2);
              G$2("close", a2);
              e2 = d2;
              break;
            case "iframe":
            case "object":
            case "embed":
              G$2("load", a2);
              e2 = d2;
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < Xe.length; e2++)
                G$2(Xe[e2], a2);
              e2 = d2;
              break;
            case "source":
              G$2("error", a2);
              e2 = d2;
              break;
            case "img":
            case "image":
            case "link":
              G$2("error", a2);
              G$2("load", a2);
              e2 = d2;
              break;
            case "details":
              G$2("toggle", a2);
              e2 = d2;
              break;
            case "input":
              Za$1(a2, d2);
              e2 = Ya(a2, d2);
              G$2("invalid", a2);
              break;
            case "option":
              e2 = eb(a2, d2);
              break;
            case "select":
              a2._wrapperState = { wasMultiple: !!d2.multiple };
              e2 = m$4({}, d2, { value: void 0 });
              G$2("invalid", a2);
              break;
            case "textarea":
              hb(a2, d2);
              e2 = gb(a2, d2);
              G$2("invalid", a2);
              break;
            default:
              e2 = d2;
          }
          vb(c2, e2);
          var h2 = e2;
          for (f2 in h2)
            if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? tb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && ob(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && pb(a2, k2) : "number" === typeof k2 && pb(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca$1.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && G$2("scroll", a2) : null != k2 && qa$1(a2, f2, k2, g2));
            }
          switch (c2) {
            case "input":
              Va$1(a2);
              cb(a2, d2, false);
              break;
            case "textarea":
              Va$1(a2);
              jb(a2);
              break;
            case "option":
              null != d2.value && a2.setAttribute("value", "" + Sa$1(d2.value));
              break;
            case "select":
              a2.multiple = !!d2.multiple;
              f2 = d2.value;
              null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(a2, !!d2.multiple, d2.defaultValue, true);
              break;
            default:
              "function" === typeof e2.onClick && (a2.onclick = jf);
          }
          mf(c2, d2) && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 128);
      }
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Ei$1(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(y$5(166));
        c2 = dh$1(ch$1.current);
        dh$1(ah.current);
        rh$1(b2) ? (d2 = b2.stateNode, c2 = b2.memoizedProps, d2[wf] = b2, d2.nodeValue !== c2 && (b2.flags |= 4)) : (d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[wf] = b2, b2.stateNode = d2);
      }
      return null;
    case 13:
      H$1(P$1);
      d2 = b2.memoizedState;
      if (0 !== (b2.flags & 64))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      c2 = false;
      null === a2 ? void 0 !== b2.memoizedProps.fallback && rh$1(b2) : c2 = null !== a2.memoizedState;
      if (d2 && !c2 && 0 !== (b2.mode & 2))
        if (null === a2 && true !== b2.memoizedProps.unstable_avoidThisFallback || 0 !== (P$1.current & 1))
          0 === V$1 && (V$1 = 3);
        else {
          if (0 === V$1 || 3 === V$1)
            V$1 = 4;
          null === U$1 || 0 === (Dg & 134217727) && 0 === (Hi$1 & 134217727) || Ii$1(U$1, W);
        }
      if (d2 || c2)
        b2.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b2), null === a2 && cf(b2.stateNode.containerInfo), null;
    case 10:
      return rg(b2), null;
    case 17:
      return Ff(b2.type) && Gf(), null;
    case 19:
      H$1(P$1);
      d2 = b2.memoizedState;
      if (null === d2)
        return null;
      f2 = 0 !== (b2.flags & 64);
      g2 = d2.rendering;
      if (null === g2)
        if (f2)
          Fi$1(d2, false);
        else {
          if (0 !== V$1 || null !== a2 && 0 !== (a2.flags & 64))
            for (a2 = b2.child; null !== a2; ) {
              g2 = ih(a2);
              if (null !== g2) {
                b2.flags |= 64;
                Fi$1(d2, false);
                f2 = g2.updateQueue;
                null !== f2 && (b2.updateQueue = f2, b2.flags |= 4);
                null === d2.lastEffect && (b2.firstEffect = null);
                b2.lastEffect = d2.lastEffect;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                I$2(P$1, P$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== d2.tail && O$1() > Ji$1 && (b2.flags |= 64, f2 = true, Fi$1(d2, false), b2.lanes = 33554432);
        }
      else {
        if (!f2)
          if (a2 = ih(g2), null !== a2) {
            if (b2.flags |= 64, f2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Fi$1(d2, true), null === d2.tail && "hidden" === d2.tailMode && !g2.alternate && !lh$1)
              return b2 = b2.lastEffect = d2.lastEffect, null !== b2 && (b2.nextEffect = null), null;
          } else
            2 * O$1() - d2.renderingStartTime > Ji$1 && 1073741824 !== c2 && (b2.flags |= 64, f2 = true, Fi$1(d2, false), b2.lanes = 33554432);
        d2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = d2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, d2.last = g2);
      }
      return null !== d2.tail ? (c2 = d2.tail, d2.rendering = c2, d2.tail = c2.sibling, d2.lastEffect = b2.lastEffect, d2.renderingStartTime = O$1(), c2.sibling = null, b2 = P$1.current, I$2(P$1, f2 ? b2 & 1 | 2 : b2 & 1), c2) : null;
    case 23:
    case 24:
      return Ki$1(), null !== a2 && null !== a2.memoizedState !== (null !== b2.memoizedState) && "unstable-defer-without-hiding" !== d2.mode && (b2.flags |= 4), null;
  }
  throw Error(y$5(156, b2.tag));
}
function Li$1(a2) {
  switch (a2.tag) {
    case 1:
      Ff(a2.type) && Gf();
      var b2 = a2.flags;
      return b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
    case 3:
      fh();
      H$1(N);
      H$1(M$1);
      uh();
      b2 = a2.flags;
      if (0 !== (b2 & 64))
        throw Error(y$5(285));
      a2.flags = b2 & -4097 | 64;
      return a2;
    case 5:
      return hh(a2), null;
    case 13:
      return H$1(P$1), b2 = a2.flags, b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
    case 19:
      return H$1(P$1), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a2), null;
    case 23:
    case 24:
      return Ki$1(), null;
    default:
      return null;
  }
}
function Mi$1(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Qa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2 };
}
function Ni$1(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Oi$1 = "function" === typeof WeakMap ? WeakMap : Map;
function Pi$1(a2, b2, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Qi$1 || (Qi$1 = true, Ri$1 = d2);
    Ni$1(a2, b2);
  };
  return c2;
}
function Si$1(a2, b2, c2) {
  c2 = zg(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      Ni$1(a2, b2);
      return d2(e2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    "function" !== typeof d2 && (null === Ti$1 ? Ti$1 = /* @__PURE__ */ new Set([this]) : Ti$1.add(this), Ni$1(a2, b2));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
var Ui$1 = "function" === typeof WeakSet ? WeakSet : Set;
function Vi$1(a2) {
  var b2 = a2.ref;
  if (null !== b2)
    if ("function" === typeof b2)
      try {
        b2(null);
      } catch (c2) {
        Wi$1(a2, c2);
      }
    else
      b2.current = null;
}
function Xi$1(a2, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b2.flags & 256 && null !== a2) {
        var c2 = a2.memoizedProps, d2 = a2.memoizedState;
        a2 = b2.stateNode;
        b2 = a2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? c2 : lg(b2.type, c2), d2);
        a2.__reactInternalSnapshotBeforeUpdate = b2;
      }
      return;
    case 3:
      b2.flags & 256 && qf(b2.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y$5(163));
}
function Yi$1(a2, b2, c2) {
  switch (c2.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b2 = c2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        a2 = b2 = b2.next;
        do {
          if (3 === (a2.tag & 3)) {
            var d2 = a2.create;
            a2.destroy = d2();
          }
          a2 = a2.next;
        } while (a2 !== b2);
      }
      b2 = c2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        a2 = b2 = b2.next;
        do {
          var e2 = a2;
          d2 = e2.next;
          e2 = e2.tag;
          0 !== (e2 & 4) && 0 !== (e2 & 1) && (Zi$1(c2, a2), $i$1(c2, a2));
          a2 = d2;
        } while (a2 !== b2);
      }
      return;
    case 1:
      a2 = c2.stateNode;
      c2.flags & 4 && (null === b2 ? a2.componentDidMount() : (d2 = c2.elementType === c2.type ? b2.memoizedProps : lg(c2.type, b2.memoizedProps), a2.componentDidUpdate(
        d2,
        b2.memoizedState,
        a2.__reactInternalSnapshotBeforeUpdate
      )));
      b2 = c2.updateQueue;
      null !== b2 && Eg(c2, b2, a2);
      return;
    case 3:
      b2 = c2.updateQueue;
      if (null !== b2) {
        a2 = null;
        if (null !== c2.child)
          switch (c2.child.tag) {
            case 5:
              a2 = c2.child.stateNode;
              break;
            case 1:
              a2 = c2.child.stateNode;
          }
        Eg(c2, b2, a2);
      }
      return;
    case 5:
      a2 = c2.stateNode;
      null === b2 && c2.flags & 4 && mf(c2.type, c2.memoizedProps) && a2.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      null === c2.memoizedState && (c2 = c2.alternate, null !== c2 && (c2 = c2.memoizedState, null !== c2 && (c2 = c2.dehydrated, null !== c2 && Cc$1(c2))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y$5(163));
}
function aj(a2, b2) {
  for (var c2 = a2; ; ) {
    if (5 === c2.tag) {
      var d2 = c2.stateNode;
      if (b2)
        d2 = d2.style, "function" === typeof d2.setProperty ? d2.setProperty("display", "none", "important") : d2.display = "none";
      else {
        d2 = c2.stateNode;
        var e2 = c2.memoizedProps.style;
        e2 = void 0 !== e2 && null !== e2 && e2.hasOwnProperty("display") ? e2.display : null;
        d2.style.display = sb("display", e2);
      }
    } else if (6 === c2.tag)
      c2.stateNode.nodeValue = b2 ? "" : c2.memoizedProps;
    else if ((23 !== c2.tag && 24 !== c2.tag || null === c2.memoizedState || c2 === a2) && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === a2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === a2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function bj(a2, b2) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
    try {
      Mf.onCommitFiberUnmount(Lf, b2);
    } catch (f2) {
    }
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a2 = b2.updateQueue;
      if (null !== a2 && (a2 = a2.lastEffect, null !== a2)) {
        var c2 = a2 = a2.next;
        do {
          var d2 = c2, e2 = d2.destroy;
          d2 = d2.tag;
          if (void 0 !== e2)
            if (0 !== (d2 & 4))
              Zi$1(b2, c2);
            else {
              d2 = b2;
              try {
                e2();
              } catch (f2) {
                Wi$1(d2, f2);
              }
            }
          c2 = c2.next;
        } while (c2 !== a2);
      }
      break;
    case 1:
      Vi$1(b2);
      a2 = b2.stateNode;
      if ("function" === typeof a2.componentWillUnmount)
        try {
          a2.props = b2.memoizedProps, a2.state = b2.memoizedState, a2.componentWillUnmount();
        } catch (f2) {
          Wi$1(
            b2,
            f2
          );
        }
      break;
    case 5:
      Vi$1(b2);
      break;
    case 4:
      cj(a2, b2);
  }
}
function dj(a2) {
  a2.alternate = null;
  a2.child = null;
  a2.dependencies = null;
  a2.firstEffect = null;
  a2.lastEffect = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.return = null;
  a2.updateQueue = null;
}
function ej(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function fj(a2) {
  a: {
    for (var b2 = a2.return; null !== b2; ) {
      if (ej(b2))
        break a;
      b2 = b2.return;
    }
    throw Error(y$5(160));
  }
  var c2 = b2;
  b2 = c2.stateNode;
  switch (c2.tag) {
    case 5:
      var d2 = false;
      break;
    case 3:
      b2 = b2.containerInfo;
      d2 = true;
      break;
    case 4:
      b2 = b2.containerInfo;
      d2 = true;
      break;
    default:
      throw Error(y$5(161));
  }
  c2.flags & 16 && (pb(b2, ""), c2.flags &= -17);
  a:
    b:
      for (c2 = a2; ; ) {
        for (; null === c2.sibling; ) {
          if (null === c2.return || ej(c2.return)) {
            c2 = null;
            break a;
          }
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
          if (c2.flags & 2)
            continue b;
          if (null === c2.child || 4 === c2.tag)
            continue b;
          else
            c2.child.return = c2, c2 = c2.child;
        }
        if (!(c2.flags & 2)) {
          c2 = c2.stateNode;
          break a;
        }
      }
  d2 ? gj(a2, c2, b2) : hj(a2, c2, b2);
}
function gj(a2, b2, c2) {
  var d2 = a2.tag, e2 = 5 === d2 || 6 === d2;
  if (e2)
    a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = jf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (gj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      gj(a2, b2, c2), a2 = a2.sibling;
}
function hj(a2, b2, c2) {
  var d2 = a2.tag, e2 = 5 === d2 || 6 === d2;
  if (e2)
    a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (hj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      hj(a2, b2, c2), a2 = a2.sibling;
}
function cj(a2, b2) {
  for (var c2 = b2, d2 = false, e2, f2; ; ) {
    if (!d2) {
      d2 = c2.return;
      a:
        for (; ; ) {
          if (null === d2)
            throw Error(y$5(160));
          e2 = d2.stateNode;
          switch (d2.tag) {
            case 5:
              f2 = false;
              break a;
            case 3:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
            case 4:
              e2 = e2.containerInfo;
              f2 = true;
              break a;
          }
          d2 = d2.return;
        }
      d2 = true;
    }
    if (5 === c2.tag || 6 === c2.tag) {
      a:
        for (var g2 = a2, h2 = c2, k2 = h2; ; )
          if (bj(g2, k2), null !== k2.child && 4 !== k2.tag)
            k2.child.return = k2, k2 = k2.child;
          else {
            if (k2 === h2)
              break a;
            for (; null === k2.sibling; ) {
              if (null === k2.return || k2.return === h2)
                break a;
              k2 = k2.return;
            }
            k2.sibling.return = k2.return;
            k2 = k2.sibling;
          }
      f2 ? (g2 = e2, h2 = c2.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e2.removeChild(c2.stateNode);
    } else if (4 === c2.tag) {
      if (null !== c2.child) {
        e2 = c2.stateNode.containerInfo;
        f2 = true;
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
    } else if (bj(a2, c2), null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
      4 === c2.tag && (d2 = false);
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function ij(a2, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c2 = b2.updateQueue;
      c2 = null !== c2 ? c2.lastEffect : null;
      if (null !== c2) {
        var d2 = c2 = c2.next;
        do
          3 === (d2.tag & 3) && (a2 = d2.destroy, d2.destroy = void 0, void 0 !== a2 && a2()), d2 = d2.next;
        while (d2 !== c2);
      }
      return;
    case 1:
      return;
    case 5:
      c2 = b2.stateNode;
      if (null != c2) {
        d2 = b2.memoizedProps;
        var e2 = null !== a2 ? a2.memoizedProps : d2;
        a2 = b2.type;
        var f2 = b2.updateQueue;
        b2.updateQueue = null;
        if (null !== f2) {
          c2[xf] = d2;
          "input" === a2 && "radio" === d2.type && null != d2.name && $a$1(c2, d2);
          wb(a2, e2);
          b2 = wb(a2, d2);
          for (e2 = 0; e2 < f2.length; e2 += 2) {
            var g2 = f2[e2], h2 = f2[e2 + 1];
            "style" === g2 ? tb(c2, h2) : "dangerouslySetInnerHTML" === g2 ? ob(c2, h2) : "children" === g2 ? pb(c2, h2) : qa$1(c2, g2, h2, b2);
          }
          switch (a2) {
            case "input":
              ab(c2, d2);
              break;
            case "textarea":
              ib(c2, d2);
              break;
            case "select":
              a2 = c2._wrapperState.wasMultiple, c2._wrapperState.wasMultiple = !!d2.multiple, f2 = d2.value, null != f2 ? fb(c2, !!d2.multiple, f2, false) : a2 !== !!d2.multiple && (null != d2.defaultValue ? fb(c2, !!d2.multiple, d2.defaultValue, true) : fb(c2, !!d2.multiple, d2.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (null === b2.stateNode)
        throw Error(y$5(162));
      b2.stateNode.nodeValue = b2.memoizedProps;
      return;
    case 3:
      c2 = b2.stateNode;
      c2.hydrate && (c2.hydrate = false, Cc$1(c2.containerInfo));
      return;
    case 12:
      return;
    case 13:
      null !== b2.memoizedState && (jj = O$1(), aj(b2.child, true));
      kj(b2);
      return;
    case 19:
      kj(b2);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b2, null !== b2.memoizedState);
      return;
  }
  throw Error(y$5(163));
}
function kj(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Ui$1());
    b2.forEach(function(b3) {
      var d2 = lj.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function mj(a2, b2) {
  return null !== a2 && (a2 = a2.memoizedState, null === a2 || null !== a2.dehydrated) ? (b2 = b2.memoizedState, null !== b2 && null === b2.dehydrated) : false;
}
var nj = Math.ceil, oj = ra$1.ReactCurrentDispatcher, pj = ra$1.ReactCurrentOwner, X = 0, U$1 = null, Y$1 = null, W = 0, qj = 0, rj = Bf(0), V$1 = 0, sj = null, tj = 0, Dg = 0, Hi$1 = 0, uj = 0, vj = null, jj = 0, Ji$1 = Infinity;
function wj() {
  Ji$1 = O$1() + 500;
}
var Z$1 = null, Qi$1 = false, Ri$1 = null, Ti$1 = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return 0 !== (X & 48) ? O$1() : -1 !== Fj ? Fj : Fj = O$1();
}
function Ig(a2) {
  a2 = a2.mode;
  if (0 === (a2 & 2))
    return 1;
  if (0 === (a2 & 4))
    return 99 === eg() ? 1 : 2;
  0 === Gj && (Gj = tj);
  if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
    a2 = Gj;
    var b2 = 4186112 & ~Hj;
    b2 &= -b2;
    0 === b2 && (a2 = 4186112 & ~a2, b2 = a2 & -a2, 0 === b2 && (b2 = 8192));
    return b2;
  }
  a2 = eg();
  0 !== (X & 4) && 98 === a2 ? a2 = Xc$1(12, Gj) : (a2 = Sc$1(a2), a2 = Xc$1(a2, Gj));
  return a2;
}
function Jg(a2, b2, c2) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y$5(185));
  a2 = Kj(a2, b2);
  if (null === a2)
    return null;
  $c$1(a2, b2, c2);
  a2 === U$1 && (Hi$1 |= b2, 4 === V$1 && Ii$1(a2, W));
  var d2 = eg();
  1 === b2 ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a2) : (Mj(a2, c2), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d2 && 99 !== d2 || (null === Cj ? Cj = /* @__PURE__ */ new Set([a2]) : Cj.add(a2)), Mj(a2, c2));
  vj = a2;
}
function Kj(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
function Mj(a2, b2) {
  for (var c2 = a2.callbackNode, d2 = a2.suspendedLanes, e2 = a2.pingedLanes, f2 = a2.expirationTimes, g2 = a2.pendingLanes; 0 < g2; ) {
    var h2 = 31 - Vc$1(g2), k2 = 1 << h2, l2 = f2[h2];
    if (-1 === l2) {
      if (0 === (k2 & d2) || 0 !== (k2 & e2)) {
        l2 = b2;
        Rc$1(k2);
        var n2 = F$2;
        f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b2 && (a2.expiredLanes |= k2);
    g2 &= ~k2;
  }
  d2 = Uc$1(a2, a2 === U$1 ? W : 0);
  b2 = F$2;
  if (0 === d2)
    null !== c2 && (c2 !== Zf && Pf(c2), a2.callbackNode = null, a2.callbackPriority = 0);
  else {
    if (null !== c2) {
      if (a2.callbackPriority === b2)
        return;
      c2 !== Zf && Pf(c2);
    }
    15 === b2 ? (c2 = Lj.bind(null, a2), null === ag ? (ag = [c2], bg = Of(Uf, jg)) : ag.push(c2), c2 = Zf) : 14 === b2 ? c2 = hg(99, Lj.bind(null, a2)) : (c2 = Tc$1(b2), c2 = hg(c2, Nj.bind(null, a2)));
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Nj(a2) {
  Fj = -1;
  Hj = Gj = 0;
  if (0 !== (X & 48))
    throw Error(y$5(327));
  var b2 = a2.callbackNode;
  if (Oj() && a2.callbackNode !== b2)
    return null;
  var c2 = Uc$1(a2, a2 === U$1 ? W : 0);
  if (0 === c2)
    return null;
  var d2 = c2;
  var e2 = X;
  X |= 16;
  var f2 = Pj();
  if (U$1 !== a2 || W !== d2)
    wj(), Qj(a2, d2);
  do
    try {
      Rj();
      break;
    } catch (h2) {
      Sj(a2, h2);
    }
  while (1);
  qg();
  oj.current = f2;
  X = e2;
  null !== Y$1 ? d2 = 0 : (U$1 = null, W = 0, d2 = V$1);
  if (0 !== (tj & Hi$1))
    Qj(a2, 0);
  else if (0 !== d2) {
    2 === d2 && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), c2 = Wc$1(a2), 0 !== c2 && (d2 = Tj(a2, c2)));
    if (1 === d2)
      throw b2 = sj, Qj(a2, 0), Ii$1(a2, c2), Mj(a2, O$1()), b2;
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = c2;
    switch (d2) {
      case 0:
      case 1:
        throw Error(y$5(345));
      case 2:
        Uj(a2);
        break;
      case 3:
        Ii$1(a2, c2);
        if ((c2 & 62914560) === c2 && (d2 = jj + 500 - O$1(), 10 < d2)) {
          if (0 !== Uc$1(a2, 0))
            break;
          e2 = a2.suspendedLanes;
          if ((e2 & c2) !== c2) {
            Hg();
            a2.pingedLanes |= a2.suspendedLanes & e2;
            break;
          }
          a2.timeoutHandle = of(Uj.bind(null, a2), d2);
          break;
        }
        Uj(a2);
        break;
      case 4:
        Ii$1(a2, c2);
        if ((c2 & 4186112) === c2)
          break;
        d2 = a2.eventTimes;
        for (e2 = -1; 0 < c2; ) {
          var g2 = 31 - Vc$1(c2);
          f2 = 1 << g2;
          g2 = d2[g2];
          g2 > e2 && (e2 = g2);
          c2 &= ~f2;
        }
        c2 = e2;
        c2 = O$1() - c2;
        c2 = (120 > c2 ? 120 : 480 > c2 ? 480 : 1080 > c2 ? 1080 : 1920 > c2 ? 1920 : 3e3 > c2 ? 3e3 : 4320 > c2 ? 4320 : 1960 * nj(c2 / 1960)) - c2;
        if (10 < c2) {
          a2.timeoutHandle = of(Uj.bind(null, a2), c2);
          break;
        }
        Uj(a2);
        break;
      case 5:
        Uj(a2);
        break;
      default:
        throw Error(y$5(329));
    }
  }
  Mj(a2, O$1());
  return a2.callbackNode === b2 ? Nj.bind(null, a2) : null;
}
function Ii$1(a2, b2) {
  b2 &= ~uj;
  b2 &= ~Hi$1;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - Vc$1(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Lj(a2) {
  if (0 !== (X & 48))
    throw Error(y$5(327));
  Oj();
  if (a2 === U$1 && 0 !== (a2.expiredLanes & W)) {
    var b2 = W;
    var c2 = Tj(a2, b2);
    0 !== (tj & Hi$1) && (b2 = Uc$1(a2, b2), c2 = Tj(a2, b2));
  } else
    b2 = Uc$1(a2, 0), c2 = Tj(a2, b2);
  0 !== a2.tag && 2 === c2 && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), b2 = Wc$1(a2), 0 !== b2 && (c2 = Tj(a2, b2)));
  if (1 === c2)
    throw c2 = sj, Qj(a2, 0), Ii$1(a2, b2), Mj(a2, O$1()), c2;
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Uj(a2);
  Mj(a2, O$1());
  return null;
}
function Vj() {
  if (null !== Cj) {
    var a2 = Cj;
    Cj = null;
    a2.forEach(function(a3) {
      a3.expiredLanes |= 24 & a3.pendingLanes;
      Mj(a3, O$1());
    });
  }
  ig();
}
function Wj(a2, b2) {
  var c2 = X;
  X |= 1;
  try {
    return a2(b2);
  } finally {
    X = c2, 0 === X && (wj(), ig());
  }
}
function Xj(a2, b2) {
  var c2 = X;
  X &= -2;
  X |= 8;
  try {
    return a2(b2);
  } finally {
    X = c2, 0 === X && (wj(), ig());
  }
}
function ni(a2, b2) {
  I$2(rj, qj);
  qj |= b2;
  tj |= b2;
}
function Ki$1() {
  qj = rj.current;
  H$1(rj);
}
function Qj(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, pf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && Gf();
          break;
        case 3:
          fh();
          H$1(N);
          H$1(M$1);
          uh();
          break;
        case 5:
          hh(d2);
          break;
        case 4:
          fh();
          break;
        case 13:
          H$1(P$1);
          break;
        case 19:
          H$1(P$1);
          break;
        case 10:
          rg(d2);
          break;
        case 23:
        case 24:
          Ki$1();
      }
      c2 = c2.return;
    }
  U$1 = a2;
  Y$1 = Tg(a2.current, null);
  W = qj = tj = b2;
  V$1 = 0;
  sj = null;
  uj = Hi$1 = Dg = 0;
}
function Sj(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      qg();
      vh$1.current = Gh;
      if (yh$1) {
        for (var d2 = R.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        yh$1 = false;
      }
      xh = 0;
      T$1 = S$1 = R = null;
      zh = false;
      pj.current = null;
      if (null === c2 || null === c2.return) {
        V$1 = 1;
        sj = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = W;
        h2.flags |= 2048;
        h2.firstEffect = h2.lastEffect = null;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2;
          if (0 === (h2.mode & 2)) {
            var n2 = h2.alternate;
            n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
          }
          var A2 = 0 !== (P$1.current & 1), p2 = g2;
          do {
            var C2;
            if (C2 = 13 === p2.tag) {
              var x = p2.memoizedState;
              if (null !== x)
                C2 = null !== x.dehydrated ? true : false;
              else {
                var w2 = p2.memoizedProps;
                C2 = void 0 === w2.fallback ? false : true !== w2.unstable_avoidThisFallback ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (null === z2) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if (0 === (p2.mode & 2)) {
                p2.flags |= 64;
                h2.flags |= 16384;
                h2.flags &= -2981;
                if (1 === h2.tag)
                  if (null === h2.alternate)
                    h2.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h2, t2);
                  }
                h2.lanes |= 1;
                break a;
              }
              k2 = void 0;
              h2 = b2;
              var q2 = f2.pingCache;
              null === q2 ? (q2 = f2.pingCache = new Oi$1(), k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)) : (k2 = q2.get(l2), void 0 === k2 && (k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)));
              if (!k2.has(h2)) {
                k2.add(h2);
                var v2 = Yj.bind(null, f2, l2, h2);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b2;
              break a;
            }
            p2 = p2.return;
          } while (null !== p2);
          k2 = Error((Ra$1(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        5 !== V$1 && (V$1 = 2);
        k2 = Mi$1(k2, h2);
        p2 = g2;
        do {
          switch (p2.tag) {
            case 3:
              f2 = k2;
              p2.flags |= 4096;
              b2 &= -b2;
              p2.lanes |= b2;
              var J2 = Pi$1(p2, f2, b2);
              Bg(p2, J2);
              break a;
            case 1:
              f2 = k2;
              var K2 = p2.type, Q2 = p2.stateNode;
              if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti$1 || !Ti$1.has(Q2)))) {
                p2.flags |= 4096;
                b2 &= -b2;
                p2.lanes |= b2;
                var L2 = Si$1(p2, f2, b2);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (null !== p2);
      }
      Zj(c2);
    } catch (va2) {
      b2 = va2;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a2 = oj.current;
  oj.current = Gh;
  return null === a2 ? Gh : a2;
}
function Tj(a2, b2) {
  var c2 = X;
  X |= 16;
  var d2 = Pj();
  U$1 === a2 && W === b2 || Qj(a2, b2);
  do
    try {
      ak();
      break;
    } catch (e2) {
      Sj(a2, e2);
    }
  while (1);
  qg();
  X = c2;
  oj.current = d2;
  if (null !== Y$1)
    throw Error(y$5(261));
  U$1 = null;
  W = 0;
  return V$1;
}
function ak() {
  for (; null !== Y$1; )
    bk(Y$1);
}
function Rj() {
  for (; null !== Y$1 && !Qf(); )
    bk(Y$1);
}
function bk(a2) {
  var b2 = ck(a2.alternate, a2, qj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Zj(a2) : Y$1 = b2;
  pj.current = null;
}
function Zj(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 2048)) {
      c2 = Gi$1(c2, b2, qj);
      if (null !== c2) {
        Y$1 = c2;
        return;
      }
      c2 = b2;
      if (24 !== c2.tag && 23 !== c2.tag || null === c2.memoizedState || 0 !== (qj & 1073741824) || 0 === (c2.mode & 4)) {
        for (var d2 = 0, e2 = c2.child; null !== e2; )
          d2 |= e2.lanes | e2.childLanes, e2 = e2.sibling;
        c2.childLanes = d2;
      }
      null !== a2 && 0 === (a2.flags & 2048) && (null === a2.firstEffect && (a2.firstEffect = b2.firstEffect), null !== b2.lastEffect && (null !== a2.lastEffect && (a2.lastEffect.nextEffect = b2.firstEffect), a2.lastEffect = b2.lastEffect), 1 < b2.flags && (null !== a2.lastEffect ? a2.lastEffect.nextEffect = b2 : a2.firstEffect = b2, a2.lastEffect = b2));
    } else {
      c2 = Li$1(b2);
      if (null !== c2) {
        c2.flags &= 2047;
        Y$1 = c2;
        return;
      }
      null !== a2 && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === V$1 && (V$1 = 5);
}
function Uj(a2) {
  var b2 = eg();
  gg(99, dk.bind(null, a2, b2));
  return null;
}
function dk(a2, b2) {
  do
    Oj();
  while (null !== yj);
  if (0 !== (X & 48))
    throw Error(y$5(327));
  var c2 = a2.finishedWork;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(y$5(177));
  a2.callbackNode = null;
  var d2 = c2.lanes | c2.childLanes, e2 = d2, f2 = a2.pendingLanes & ~e2;
  a2.pendingLanes = e2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= e2;
  a2.mutableReadLanes &= e2;
  a2.entangledLanes &= e2;
  e2 = a2.entanglements;
  for (var g2 = a2.eventTimes, h2 = a2.expirationTimes; 0 < f2; ) {
    var k2 = 31 - Vc$1(f2), l2 = 1 << k2;
    e2[k2] = 0;
    g2[k2] = -1;
    h2[k2] = -1;
    f2 &= ~l2;
  }
  null !== Cj && 0 === (d2 & 24) && Cj.has(a2) && Cj.delete(a2);
  a2 === U$1 && (Y$1 = U$1 = null, W = 0);
  1 < c2.flags ? null !== c2.lastEffect ? (c2.lastEffect.nextEffect = c2, d2 = c2.firstEffect) : d2 = c2 : d2 = c2.firstEffect;
  if (null !== d2) {
    e2 = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g2 = Ne();
    if (Oe(g2)) {
      if ("selectionStart" in g2)
        h2 = { start: g2.selectionStart, end: g2.selectionEnd };
      else
        a:
          if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && 0 !== l2.rangeCount) {
            h2 = l2.anchorNode;
            f2 = l2.anchorOffset;
            k2 = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h2.nodeType, k2.nodeType;
            } catch (va2) {
              h2 = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x = 0, w2 = g2, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w2 !== h2 || 0 !== f2 && 3 !== w2.nodeType || (A2 = n2 + f2);
                  w2 !== k2 || 0 !== l2 && 3 !== w2.nodeType || (p2 = n2 + l2);
                  3 === w2.nodeType && (n2 += w2.nodeValue.length);
                  if (null === (u2 = w2.firstChild))
                    break;
                  z2 = w2;
                  w2 = u2;
                }
                for (; ; ) {
                  if (w2 === g2)
                    break b;
                  z2 === h2 && ++C2 === f2 && (A2 = n2);
                  z2 === k2 && ++x === l2 && (p2 = n2);
                  if (null !== (u2 = w2.nextSibling))
                    break;
                  w2 = z2;
                  z2 = w2.parentNode;
                }
                w2 = u2;
              }
            h2 = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
          } else
            h2 = null;
      h2 = h2 || { start: 0, end: 0 };
    } else
      h2 = null;
    lf = { focusedElem: g2, selectionRange: h2 };
    fd = false;
    Ij = null;
    Jj = false;
    Z$1 = d2;
    do
      try {
        ek();
      } catch (va2) {
        if (null === Z$1)
          throw Error(y$5(330));
        Wi$1(Z$1, va2);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    Ij = null;
    Z$1 = d2;
    do
      try {
        for (g2 = a2; null !== Z$1; ) {
          var t2 = Z$1.flags;
          t2 & 16 && pb(Z$1.stateNode, "");
          if (t2 & 128) {
            var q2 = Z$1.alternate;
            if (null !== q2) {
              var v2 = q2.ref;
              null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z$1);
              Z$1.flags &= -3;
              break;
            case 6:
              fj(Z$1);
              Z$1.flags &= -3;
              ij(Z$1.alternate, Z$1);
              break;
            case 1024:
              Z$1.flags &= -1025;
              break;
            case 1028:
              Z$1.flags &= -1025;
              ij(Z$1.alternate, Z$1);
              break;
            case 4:
              ij(Z$1.alternate, Z$1);
              break;
            case 8:
              h2 = Z$1;
              cj(g2, h2);
              var J2 = h2.alternate;
              dj(h2);
              null !== J2 && dj(J2);
          }
          Z$1 = Z$1.nextEffect;
        }
      } catch (va2) {
        if (null === Z$1)
          throw Error(y$5(330));
        Wi$1(Z$1, va2);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g2 = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J2 = Math.min(g2.start, h2), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h2), !v2.extend && J2 > g2 && (h2 = g2, g2 = J2, J2 = h2), h2 = Le$1(t2, J2), f2 = Le$1(t2, g2), h2 && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      "function" === typeof t2.focus && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a2.current = c2;
    Z$1 = d2;
    do
      try {
        for (t2 = a2; null !== Z$1; ) {
          var K2 = Z$1.flags;
          K2 & 36 && Yi$1(t2, Z$1.alternate, Z$1);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z$1.ref;
            if (null !== Q2) {
              var L2 = Z$1.stateNode;
              switch (Z$1.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
            }
          }
          Z$1 = Z$1.nextEffect;
        }
      } catch (va2) {
        if (null === Z$1)
          throw Error(y$5(330));
        Wi$1(Z$1, va2);
        Z$1 = Z$1.nextEffect;
      }
    while (null !== Z$1);
    Z$1 = null;
    $f();
    X = e2;
  } else
    a2.current = c2;
  if (xj)
    xj = false, yj = a2, zj = b2;
  else
    for (Z$1 = d2; null !== Z$1; )
      b2 = Z$1.nextEffect, Z$1.nextEffect = null, Z$1.flags & 8 && (K2 = Z$1, K2.sibling = null, K2.stateNode = null), Z$1 = b2;
  d2 = a2.pendingLanes;
  0 === d2 && (Ti$1 = null);
  1 === d2 ? a2 === Ej ? Dj++ : (Dj = 0, Ej = a2) : Dj = 0;
  c2 = c2.stateNode;
  if (Mf && "function" === typeof Mf.onCommitFiberRoot)
    try {
      Mf.onCommitFiberRoot(Lf, c2, void 0, 64 === (c2.current.flags & 64));
    } catch (va2) {
    }
  Mj(a2, O$1());
  if (Qi$1)
    throw Qi$1 = false, a2 = Ri$1, Ri$1 = null, a2;
  if (0 !== (X & 8))
    return null;
  ig();
  return null;
}
function ek() {
  for (; null !== Z$1; ) {
    var a2 = Z$1.alternate;
    Jj || null === Ij || (0 !== (Z$1.flags & 8) ? dc$1(Z$1, Ij) && (Jj = true) : 13 === Z$1.tag && mj(a2, Z$1) && dc$1(Z$1, Ij) && (Jj = true));
    var b2 = Z$1.flags;
    0 !== (b2 & 256) && Xi$1(a2, Z$1);
    0 === (b2 & 512) || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z$1 = Z$1.nextEffect;
  }
}
function Oj() {
  if (90 !== zj) {
    var a2 = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a2, fk);
  }
  return false;
}
function $i$1(a2, b2) {
  Aj.push(b2, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi$1(a2, b2) {
  Bj.push(b2, a2);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (null === yj)
    return false;
  var a2 = yj;
  yj = null;
  if (0 !== (X & 48))
    throw Error(y$5(331));
  var b2 = X;
  X |= 32;
  var c2 = Bj;
  Bj = [];
  for (var d2 = 0; d2 < c2.length; d2 += 2) {
    var e2 = c2[d2], f2 = c2[d2 + 1], g2 = e2.destroy;
    e2.destroy = void 0;
    if ("function" === typeof g2)
      try {
        g2();
      } catch (k2) {
        if (null === f2)
          throw Error(y$5(330));
        Wi$1(f2, k2);
      }
  }
  c2 = Aj;
  Aj = [];
  for (d2 = 0; d2 < c2.length; d2 += 2) {
    e2 = c2[d2];
    f2 = c2[d2 + 1];
    try {
      var h2 = e2.create;
      e2.destroy = h2();
    } catch (k2) {
      if (null === f2)
        throw Error(y$5(330));
      Wi$1(f2, k2);
    }
  }
  for (h2 = a2.current.firstEffect; null !== h2; )
    a2 = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a2;
  X = b2;
  ig();
  return true;
}
function gk(a2, b2, c2) {
  b2 = Mi$1(c2, b2);
  b2 = Pi$1(a2, b2, 1);
  Ag(a2, b2);
  b2 = Hg();
  a2 = Kj(a2, 1);
  null !== a2 && ($c$1(a2, 1, b2), Mj(a2, b2));
}
function Wi$1(a2, b2) {
  if (3 === a2.tag)
    gk(a2, a2, b2);
  else
    for (var c2 = a2.return; null !== c2; ) {
      if (3 === c2.tag) {
        gk(c2, a2, b2);
        break;
      } else if (1 === c2.tag) {
        var d2 = c2.stateNode;
        if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ti$1 || !Ti$1.has(d2))) {
          a2 = Mi$1(b2, a2);
          var e2 = Si$1(c2, a2, 1);
          Ag(c2, e2);
          e2 = Hg();
          c2 = Kj(c2, 1);
          if (null !== c2)
            $c$1(c2, 1, e2), Mj(c2, e2);
          else if ("function" === typeof d2.componentDidCatch && (null === Ti$1 || !Ti$1.has(d2)))
            try {
              d2.componentDidCatch(b2, a2);
            } catch (f2) {
            }
          break;
        }
      }
      c2 = c2.return;
    }
}
function Yj(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = Hg();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  U$1 === a2 && (W & c2) === c2 && (4 === V$1 || 3 === V$1 && (W & 62914560) === W && 500 > O$1() - jj ? Qj(a2, 0) : uj |= c2);
  Mj(a2, b2);
}
function lj(a2, b2) {
  var c2 = a2.stateNode;
  null !== c2 && c2.delete(b2);
  b2 = 0;
  0 === b2 && (b2 = a2.mode, 0 === (b2 & 2) ? b2 = 1 : 0 === (b2 & 4) ? b2 = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b2 = Yc$1(62914560 & ~Gj), 0 === b2 && (b2 = 4194304)));
  c2 = Hg();
  a2 = Kj(a2, b2);
  null !== a2 && ($c$1(a2, b2, c2), Mj(a2, c2));
}
var ck;
ck = function(a2, b2, c2) {
  var d2 = b2.lanes;
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || N.current)
      ug = true;
    else if (0 !== (c2 & d2))
      ug = 0 !== (a2.flags & 16384) ? true : false;
    else {
      ug = false;
      switch (b2.tag) {
        case 3:
          ri(b2);
          sh$1();
          break;
        case 5:
          gh$1(b2);
          break;
        case 1:
          Ff(b2.type) && Jf(b2);
          break;
        case 4:
          eh(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          d2 = b2.memoizedProps.value;
          var e2 = b2.type._context;
          I$2(mg, e2._currentValue);
          e2._currentValue = d2;
          break;
        case 13:
          if (null !== b2.memoizedState) {
            if (0 !== (c2 & b2.child.childLanes))
              return ti(a2, b2, c2);
            I$2(P$1, P$1.current & 1);
            b2 = hi(a2, b2, c2);
            return null !== b2 ? b2.sibling : null;
          }
          I$2(P$1, P$1.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a2.flags & 64)) {
            if (d2)
              return Ai$1(a2, b2, c2);
            b2.flags |= 64;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          I$2(P$1, P$1.current);
          if (d2)
            break;
          else
            return null;
        case 23:
        case 24:
          return b2.lanes = 0, mi(a2, b2, c2);
      }
      return hi(a2, b2, c2);
    }
  else
    ug = false;
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      d2 = b2.type;
      null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
      a2 = b2.pendingProps;
      e2 = Ef(b2, M$1.current);
      tg(b2, c2);
      e2 = Ch(null, b2, d2, a2, e2, c2);
      b2.flags |= 1;
      if ("object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof) {
        b2.tag = 1;
        b2.memoizedState = null;
        b2.updateQueue = null;
        if (Ff(d2)) {
          var f2 = true;
          Jf(b2);
        } else
          f2 = false;
        b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null;
        xg(b2);
        var g2 = d2.getDerivedStateFromProps;
        "function" === typeof g2 && Gg(b2, d2, g2, a2);
        e2.updater = Kg;
        b2.stateNode = e2;
        e2._reactInternals = b2;
        Og(b2, d2, a2, c2);
        b2 = qi$1(null, b2, d2, true, f2, c2);
      } else
        b2.tag = 0, fi(null, b2, e2, c2), b2 = b2.child;
      return b2;
    case 16:
      e2 = b2.elementType;
      a: {
        null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
        a2 = b2.pendingProps;
        f2 = e2._init;
        e2 = f2(e2._payload);
        b2.type = e2;
        f2 = b2.tag = hk(e2);
        a2 = lg(e2, a2);
        switch (f2) {
          case 0:
            b2 = li(null, b2, e2, a2, c2);
            break a;
          case 1:
            b2 = pi(null, b2, e2, a2, c2);
            break a;
          case 11:
            b2 = gi(null, b2, e2, a2, c2);
            break a;
          case 14:
            b2 = ii(null, b2, e2, lg(e2.type, a2), d2, c2);
            break a;
        }
        throw Error(y$5(306, e2, ""));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), li(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), pi(a2, b2, d2, e2, c2);
    case 3:
      ri(b2);
      d2 = b2.updateQueue;
      if (null === a2 || null === d2)
        throw Error(y$5(282));
      d2 = b2.pendingProps;
      e2 = b2.memoizedState;
      e2 = null !== e2 ? e2.element : null;
      yg(a2, b2);
      Cg(b2, d2, null, c2);
      d2 = b2.memoizedState.element;
      if (d2 === e2)
        sh$1(), b2 = hi(a2, b2, c2);
      else {
        e2 = b2.stateNode;
        if (f2 = e2.hydrate)
          kh = rf(b2.stateNode.containerInfo.firstChild), jh = b2, f2 = lh$1 = true;
        if (f2) {
          a2 = e2.mutableSourceEagerHydrationData;
          if (null != a2)
            for (e2 = 0; e2 < a2.length; e2 += 2)
              f2 = a2[e2], f2._workInProgressVersionPrimary = a2[e2 + 1], th.push(f2);
          c2 = Zg(b2, null, d2, c2);
          for (b2.child = c2; c2; )
            c2.flags = c2.flags & -3 | 1024, c2 = c2.sibling;
        } else
          fi(a2, b2, d2, c2), sh$1();
        b2 = b2.child;
      }
      return b2;
    case 5:
      return gh$1(b2), null === a2 && ph(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, nf(d2, e2) ? g2 = null : null !== f2 && nf(d2, f2) && (b2.flags |= 16), oi(a2, b2), fi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && ph(b2), null;
    case 13:
      return ti(a2, b2, c2);
    case 4:
      return eh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Yg(b2, null, d2, c2) : fi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), gi(a2, b2, d2, e2, c2);
    case 7:
      return fi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return fi(
        a2,
        b2,
        b2.pendingProps.children,
        c2
      ), b2.child;
    case 12:
      return fi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        g2 = b2.memoizedProps;
        f2 = e2.value;
        var h2 = b2.type._context;
        I$2(mg, h2._currentValue);
        h2._currentValue = f2;
        if (null !== g2)
          if (h2 = g2.value, f2 = He(h2, f2) ? 0 : ("function" === typeof d2._calculateChangedBits ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
            if (g2.children === e2.children && !N.current) {
              b2 = hi(a2, b2, c2);
              break a;
            }
          } else
            for (h2 = b2.child, null !== h2 && (h2.return = b2); null !== h2; ) {
              var k2 = h2.dependencies;
              if (null !== k2) {
                g2 = h2.child;
                for (var l2 = k2.firstContext; null !== l2; ) {
                  if (l2.context === d2 && 0 !== (l2.observedBits & f2)) {
                    1 === h2.tag && (l2 = zg(-1, c2 & -c2), l2.tag = 2, Ag(h2, l2));
                    h2.lanes |= c2;
                    l2 = h2.alternate;
                    null !== l2 && (l2.lanes |= c2);
                    sg(h2.return, c2);
                    k2.lanes |= c2;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g2 = 10 === h2.tag ? h2.type === b2.type ? null : h2.child : h2.child;
              if (null !== g2)
                g2.return = h2;
              else
                for (g2 = h2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  h2 = g2.sibling;
                  if (null !== h2) {
                    h2.return = g2.return;
                    g2 = h2;
                    break;
                  }
                  g2 = g2.return;
                }
              h2 = g2;
            }
        fi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, f2 = b2.pendingProps, d2 = f2.children, tg(b2, c2), e2 = vg(
        e2,
        f2.unstable_observedBits
      ), d2 = d2(e2), b2.flags |= 1, fi(a2, b2, d2, c2), b2.child;
    case 14:
      return e2 = b2.type, f2 = lg(e2, b2.pendingProps), f2 = lg(e2.type, f2), ii(a2, b2, e2, f2, d2, c2);
    case 15:
      return ki$1(a2, b2, b2.type, b2.pendingProps, d2, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, Ff(d2) ? (a2 = true, Jf(b2)) : a2 = false, tg(b2, c2), Mg(b2, d2, e2), Og(b2, d2, e2, c2), qi$1(null, b2, d2, true, a2, c2);
    case 19:
      return Ai$1(a2, b2, c2);
    case 23:
      return mi(a2, b2, c2);
    case 24:
      return mi(a2, b2, c2);
  }
  throw Error(y$5(156, b2.tag));
};
function ik(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a2, b2, c2, d2) {
  return new ik(a2, b2, c2, d2);
}
function ji$1(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function hk(a2) {
  if ("function" === typeof a2)
    return ji$1(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Aa$1)
      return 11;
    if (a2 === Da$1)
      return 14;
  }
  return 2;
}
function Tg(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = nh(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Vg(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    ji$1(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ua$1:
          return Xg(c2.children, e2, f2, b2);
        case Ha$1:
          g2 = 8;
          e2 |= 16;
          break;
        case wa$1:
          g2 = 8;
          e2 |= 1;
          break;
        case xa$1:
          return a2 = nh(12, c2, b2, e2 | 8), a2.elementType = xa$1, a2.type = xa$1, a2.lanes = f2, a2;
        case Ba$1:
          return a2 = nh(13, c2, b2, e2), a2.type = Ba$1, a2.elementType = Ba$1, a2.lanes = f2, a2;
        case Ca$1:
          return a2 = nh(19, c2, b2, e2), a2.elementType = Ca$1, a2.lanes = f2, a2;
        case Ia$1:
          return vi(c2, e2, f2, b2);
        case Ja:
          return a2 = nh(24, c2, b2, e2), a2.elementType = Ja, a2.lanes = f2, a2;
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case ya$1:
                g2 = 10;
                break a;
              case za$1:
                g2 = 9;
                break a;
              case Aa$1:
                g2 = 11;
                break a;
              case Da$1:
                g2 = 14;
                break a;
              case Ea$1:
                g2 = 16;
                d2 = null;
                break a;
              case Fa$1:
                g2 = 22;
                break a;
            }
          throw Error(y$5(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = nh(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Xg(a2, b2, c2, d2) {
  a2 = nh(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function vi(a2, b2, c2, d2) {
  a2 = nh(23, a2, d2, b2);
  a2.elementType = Ia$1;
  a2.lanes = c2;
  return a2;
}
function Ug(a2, b2, c2) {
  a2 = nh(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function Wg(a2, b2, c2) {
  b2 = nh(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function jk(a2, b2, c2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c2;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc$1(0);
  this.expirationTimes = Zc$1(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc$1(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: ta$1, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function lk(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = Hg(), g2 = Ig(e2);
  a:
    if (c2) {
      c2 = c2._reactInternals;
      b: {
        if (Zb(c2) !== c2 || 1 !== c2.tag)
          throw Error(y$5(170));
        var h2 = c2;
        do {
          switch (h2.tag) {
            case 3:
              h2 = h2.stateNode.context;
              break b;
            case 1:
              if (Ff(h2.type)) {
                h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h2 = h2.return;
        } while (null !== h2);
        throw Error(y$5(171));
      }
      if (1 === c2.tag) {
        var k2 = c2.type;
        if (Ff(k2)) {
          c2 = If(c2, k2, h2);
          break a;
        }
      }
      c2 = h2;
    } else
      c2 = Cf;
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = zg(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  Ag(e2, b2);
  Jg(e2, g2, f2);
  return g2;
}
function mk(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function nk(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function ok(a2, b2) {
  nk(a2, b2);
  (a2 = a2.alternate) && nk(a2, b2);
}
function pk() {
  return null;
}
function qk(a2, b2, c2) {
  var d2 = null != c2 && null != c2.hydrationOptions && c2.hydrationOptions.mutableSources || null;
  c2 = new jk(a2, b2, null != c2 && true === c2.hydrate);
  b2 = nh(3, null, null, 2 === b2 ? 7 : 1 === b2 ? 3 : 0);
  c2.current = b2;
  b2.stateNode = c2;
  xg(b2);
  a2[ff] = c2.current;
  cf(8 === a2.nodeType ? a2.parentNode : a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++) {
      b2 = d2[a2];
      var e2 = b2._getVersion;
      e2 = e2(b2._source);
      null == c2.mutableSourceEagerHydrationData ? c2.mutableSourceEagerHydrationData = [b2, e2] : c2.mutableSourceEagerHydrationData.push(b2, e2);
    }
  this._internalRoot = c2;
}
qk.prototype.render = function(a2) {
  lk(a2, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a2 = this._internalRoot, b2 = a2.containerInfo;
  lk(null, a2, null, function() {
    b2[ff] = null;
  });
};
function rk(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function sk(a2, b2) {
  b2 || (b2 = a2 ? 9 === a2.nodeType ? a2.documentElement : a2.firstChild : null, b2 = !(!b2 || 1 !== b2.nodeType || !b2.hasAttribute("data-reactroot")));
  if (!b2)
    for (var c2; c2 = a2.lastChild; )
      a2.removeChild(c2);
  return new qk(a2, 0, b2 ? { hydrate: true } : void 0);
}
function tk(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2._internalRoot;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = mk(g2);
        h2.call(a3);
      };
    }
    lk(b2, g2, a2, e2);
  } else {
    f2 = c2._reactRootContainer = sk(c2, d2);
    g2 = f2._internalRoot;
    if ("function" === typeof e2) {
      var k2 = e2;
      e2 = function() {
        var a3 = mk(g2);
        k2.call(a3);
      };
    }
    Xj(function() {
      lk(b2, g2, a2, e2);
    });
  }
  return mk(g2);
}
ec$1 = function(a2) {
  if (13 === a2.tag) {
    var b2 = Hg();
    Jg(a2, 4, b2);
    ok(a2, 4);
  }
};
fc$1 = function(a2) {
  if (13 === a2.tag) {
    var b2 = Hg();
    Jg(a2, 67108864, b2);
    ok(a2, 67108864);
  }
};
gc$1 = function(a2) {
  if (13 === a2.tag) {
    var b2 = Hg(), c2 = Ig(a2);
    Jg(a2, c2, b2);
    ok(a2, c2);
  }
};
hc$1 = function(a2, b2) {
  return b2();
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      ab(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(y$5(90));
            Wa$1(d2);
            ab(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Wj;
Hb = function(a2, b2, c2, d2, e2) {
  var f2 = X;
  X |= 4;
  try {
    return gg(98, a2.bind(null, b2, c2, d2, e2));
  } finally {
    X = f2, 0 === X && (wj(), ig());
  }
};
Ib = function() {
  0 === (X & 49) && (Vj(), Oj());
};
Jb = function(a2, b2) {
  var c2 = X;
  X |= 2;
  try {
    return a2(b2);
  } finally {
    X = c2, 0 === X && (wj(), ig());
  }
};
function uk(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!rk(b2))
    throw Error(y$5(200));
  return kk(a2, b2, null, c2);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc$1, bundleType: 0, version: "17.0.1", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra$1.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = cc$1(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(y$5(188));
    throw Error(y$5(268, Object.keys(a2)));
  }
  a2 = cc$1(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2, b2) {
  var c2 = X;
  if (0 !== (c2 & 48))
    return a2(b2);
  X |= 1;
  try {
    if (a2)
      return gg(99, a2.bind(null, b2));
  } finally {
    X = c2, ig();
  }
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!rk(b2))
    throw Error(y$5(200));
  return tk(null, a2, b2, true, c2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!rk(b2))
    throw Error(y$5(200));
  return tk(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!rk(a2))
    throw Error(y$5(40));
  return a2._reactRootContainer ? (Xj(function() {
    tk(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a2, b2) {
  return uk(a2, b2, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!rk(c2))
    throw Error(y$5(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(y$5(38));
  return tk(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "17.0.1";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const index$2 = "";
var toStr$b = Object.prototype.toString;
var isArguments$5 = function isArguments(value) {
  var str = toStr$b.call(value);
  var isArgs2 = str === "[object Arguments]";
  if (!isArgs2) {
    isArgs2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$b.call(value.callee) === "[object Function]";
  }
  return isArgs2;
};
var implementation$e;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation$e;
  hasRequiredImplementation = 1;
  var keysShim2;
  if (!Object.keys) {
    var has2 = Object.prototype.hasOwnProperty;
    var toStr2 = Object.prototype.toString;
    var isArgs2 = isArguments$5;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o2) {
      var ctor = o2.constructor;
      return ctor && ctor.prototype === o2;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k2 in window) {
        try {
          if (!excludedKeys["$" + k2] && has2.call(window, k2) && window[k2] !== null && typeof window[k2] === "object") {
            try {
              equalsConstructorPrototype(window[k2]);
            } catch (e2) {
              return true;
            }
          }
        } catch (e2) {
          return true;
        }
      }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o2) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o2);
      }
      try {
        return equalsConstructorPrototype(o2);
      } catch (e2) {
        return false;
      }
    };
    keysShim2 = function keys3(object) {
      var isObject3 = object !== null && typeof object === "object";
      var isFunction3 = toStr2.call(object) === "[object Function]";
      var isArguments5 = isArgs2(object);
      var isString4 = isObject3 && toStr2.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject3 && !isFunction3 && !isArguments5) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction3;
      if (isString4 && object.length > 0 && !has2.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments5 && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object) {
          if (!(skipProto && name === "prototype") && has2.call(object, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k2 = 0; k2 < dontEnums.length; ++k2) {
          if (!(skipConstructor && dontEnums[k2] === "constructor") && has2.call(object, dontEnums[k2])) {
            theKeys.push(dontEnums[k2]);
          }
        }
      }
      return theKeys;
    };
  }
  implementation$e = keysShim2;
  return implementation$e;
}
var slice$1 = Array.prototype.slice;
var isArgs = isArguments$5;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o2) {
  return origKeys(o2);
} : requireImplementation();
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys3(object) {
        if (isArgs(object)) {
          return originalKeys(slice$1.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys$1 = keysShim;
var keys$2 = objectKeys$1;
var hasSymbols$8 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr$a = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction$2 = function(fn) {
  return typeof fn === "function" && toStr$a.call(fn) === "[object Function]";
};
var arePropertyDescriptorsSupported = function() {
  var obj = {};
  try {
    origDefineProperty(obj, "x", { enumerable: false, value: obj });
    for (var _2 in obj) {
      return false;
    }
    return obj.x === obj;
  } catch (e2) {
    return false;
  }
};
var supportsDescriptors$2 = origDefineProperty && arePropertyDescriptorsSupported();
var defineProperty$4 = function(object, name, value, predicate) {
  if (name in object && (!isFunction$2(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors$2) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value,
      writable: true
    });
  } else {
    object[name] = value;
  }
};
var defineProperties$1 = function(object, map2) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys$2(map2);
  if (hasSymbols$8) {
    props = concat.call(props, Object.getOwnPropertySymbols(map2));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty$4(object, props[i], map2[props[i]], predicates[props[i]]);
  }
};
defineProperties$1.supportsDescriptors = !!supportsDescriptors$2;
var defineProperties_1 = defineProperties$1;
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$9 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$d = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$9.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound2;
  var binder = function() {
    if (this instanceof bound2) {
      var result = target.apply(
        this,
        args.concat(slice.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound2.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound2;
};
var implementation$c = implementation$d;
var functionBind = Function.prototype.bind || implementation$c;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString$2 = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match$4 = String.prototype.match;
var bigIntValueOf$1 = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var inspectCustom = require$$0$1.custom;
var inspectSymbol = inspectCustom && isSymbol$3(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts = options || {};
  if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
  if (typeof customInspect !== "boolean") {
    throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
  }
  if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    return String(obj);
  }
  if (typeof obj === "bigint") {
    return String(obj) + "n";
  }
  var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$6(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value, from, noIndent) {
    if (from) {
      seen = seen.slice();
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };
      if (has(opts, "quoteStyle")) {
        newOpts.quoteStyle = opts.quoteStyle;
      }
      return inspect_(value, newOpts, depth + 1, seen);
    }
    return inspect_(value, opts, depth + 1, seen);
  }
  if (typeof obj === "function") {
    var name = nameOf(obj);
    return "[Function" + (name ? ": " + name : " (anonymous)") + "]";
  }
  if (isSymbol$3(obj)) {
    var symString = Symbol.prototype.toString.call(obj);
    return typeof obj === "object" ? markBoxed(symString) : symString;
  }
  if (isElement$1(obj)) {
    var s2 = "<" + String(obj.nodeName).toLowerCase();
    var attrs = obj.attributes || [];
    for (var i = 0; i < attrs.length; i++) {
      s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
    }
    s2 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s2 += "...";
    }
    s2 += "</" + String(obj.nodeName).toLowerCase() + ">";
    return s2;
  }
  if (isArray$6(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs2 = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs2)) {
      return "[" + indentedJoin(xs2, indent) + "]";
    }
    return "[ " + xs2.join(", ") + " ]";
  }
  if (isError$1(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + parts.join(", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
      return obj[inspectSymbol]();
    } else if (typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap$5(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value, key) {
      mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet$5(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value) {
      setParts.push(inspect2(value, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap$1(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet$1(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isNumber$1(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt$1(obj)) {
    return markBoxed(inspect2(bigIntValueOf$1.call(obj)));
  }
  if (isBoolean$1(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$5(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate$1(obj) && !isRegExp$1(obj)) {
    var ys2 = arrObjKeys(obj, inspect2);
    if (ys2.length === 0) {
      return "{}";
    }
    if (indent) {
      return "{" + indentedJoin(ys2, indent) + "}";
    }
    return "{ " + ys2.join(", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s2, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s2 + quoteChar;
}
function quote(s2) {
  return String(s2).replace(/"/g, "&quot;");
}
function isArray$6(obj) {
  return toStr$8(obj) === "[object Array]";
}
function isDate$1(obj) {
  return toStr$8(obj) === "[object Date]";
}
function isRegExp$1(obj) {
  return toStr$8(obj) === "[object RegExp]";
}
function isError$1(obj) {
  return toStr$8(obj) === "[object Error]";
}
function isSymbol$3(obj) {
  return toStr$8(obj) === "[object Symbol]";
}
function isString$5(obj) {
  return toStr$8(obj) === "[object String]";
}
function isNumber$1(obj) {
  return toStr$8(obj) === "[object Number]";
}
function isBigInt$1(obj) {
  return toStr$8(obj) === "[object BigInt]";
}
function isBoolean$1(obj) {
  return toStr$8(obj) === "[object Boolean]";
}
var hasOwn$3 = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has(obj, key) {
  return hasOwn$3.call(obj, key);
}
function toStr$8(obj) {
  return objectToString$2.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m2 = match$4.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m2) {
    return m2[1];
  }
  return null;
}
function indexOf(xs2, x) {
  if (xs2.indexOf) {
    return xs2.indexOf(x);
  }
  for (var i = 0, l2 = xs2.length; i < l2; i++) {
    if (xs2[i] === x) {
      return i;
    }
  }
  return -1;
}
function isMap$5(x) {
  if (!mapSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    mapSize.call(x);
    try {
      setSize.call(x);
    } catch (s2) {
      return true;
    }
    return x instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap$1(x) {
  if (!weakMapHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x, weakMapHas);
    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s2) {
      return true;
    }
    return x instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isSet$5(x) {
  if (!setSize || !x || typeof x !== "object") {
    return false;
  }
  try {
    setSize.call(x);
    try {
      mapSize.call(x);
    } catch (m2) {
      return true;
    }
    return x instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet$1(x) {
  if (!weakSetHas || !x || typeof x !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x, weakSetHas);
    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s2) {
      return true;
    }
    return x instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement$1(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
    return true;
  }
  return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
}
function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
  }
  var s2 = str.replace(/(['\\])/g, "\\$1").replace(/[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s2, "single", opts);
}
function lowbyte(c2) {
  var n2 = c2.charCodeAt(0);
  var x = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x) {
    return "\\" + x;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + n2.toString(16);
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(", ");
  return type + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs2) {
  for (var i = 0; i < xs2.length; i++) {
    if (indexOf(xs2[i], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts, depth) {
  var baseIndent;
  if (opts.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts.indent === "number" && opts.indent > 0) {
    baseIndent = Array(opts.indent + 1).join(" ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: Array(depth + 1).join(baseIndent)
  };
}
function indentedJoin(xs2, indent) {
  if (xs2.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + xs2.join("," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$6(obj);
  var xs2 = [];
  if (isArr) {
    xs2.length = obj.length;
    for (var i = 0; i < obj.length; i++) {
      xs2[i] = has(obj, i) ? inspect2(obj[i], obj) : "";
    }
  }
  for (var key in obj) {
    if (!has(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (/[^\w$]/.test(key)) {
      xs2.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs2.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  return xs2;
}
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = commonjsGlobal.Symbol;
var hasSymbolSham = shams;
var hasSymbols$7 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var undefined$2;
var $TypeError$8 = TypeError;
var $gOPD$2 = Object.getOwnPropertyDescriptor;
if ($gOPD$2) {
  try {
    $gOPD$2({}, "");
  } catch (e2) {
    $gOPD$2 = null;
  }
}
var throwTypeError$1 = function() {
  throw new $TypeError$8();
};
var ThrowTypeError$1 = $gOPD$2 ? function() {
  try {
    arguments.callee;
    return throwTypeError$1;
  } catch (calleeThrows) {
    try {
      return $gOPD$2(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError$1;
    }
  }
}() : throwTypeError$1;
var hasSymbols$6 = hasSymbols$7();
var getProto$2 = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var generatorFunction = undefined$2;
var asyncFunction = undefined$2;
var asyncGenFunction$1 = undefined$2;
var TypedArray$1 = typeof Uint8Array === "undefined" ? undefined$2 : getProto$2(Uint8Array);
var INTRINSICS$1 = {
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$2 : ArrayBuffer,
  "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$2 : ArrayBuffer.prototype,
  "%ArrayIteratorPrototype%": hasSymbols$6 ? getProto$2([][Symbol.iterator]()) : undefined$2,
  "%ArrayPrototype%": Array.prototype,
  "%ArrayProto_entries%": Array.prototype.entries,
  "%ArrayProto_forEach%": Array.prototype.forEach,
  "%ArrayProto_keys%": Array.prototype.keys,
  "%ArrayProto_values%": Array.prototype.values,
  "%AsyncFromSyncIteratorPrototype%": undefined$2,
  "%AsyncFunction%": asyncFunction,
  "%AsyncFunctionPrototype%": undefined$2,
  "%AsyncGenerator%": undefined$2,
  "%AsyncGeneratorFunction%": asyncGenFunction$1,
  "%AsyncGeneratorPrototype%": undefined$2,
  "%AsyncIteratorPrototype%": undefined$2,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$2 : Atomics,
  "%Boolean%": Boolean,
  "%BooleanPrototype%": Boolean.prototype,
  "%DataView%": typeof DataView === "undefined" ? undefined$2 : DataView,
  "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$2 : DataView.prototype,
  "%Date%": Date,
  "%DatePrototype%": Date.prototype,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%ErrorPrototype%": Error.prototype,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%EvalErrorPrototype%": EvalError.prototype,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$2 : Float32Array,
  "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$2 : Float32Array.prototype,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$2 : Float64Array,
  "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$2 : Float64Array.prototype,
  "%Function%": Function,
  "%FunctionPrototype%": Function.prototype,
  "%Generator%": undefined$2,
  "%GeneratorFunction%": generatorFunction,
  "%GeneratorPrototype%": undefined$2,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$2 : Int8Array,
  "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$2 : Int8Array.prototype,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$2 : Int16Array,
  "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$2 : Int8Array.prototype,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$2 : Int32Array,
  "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$2 : Int32Array.prototype,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$6 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$2,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$2,
  "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$2,
  "%Map%": typeof Map === "undefined" ? undefined$2 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$6 ? undefined$2 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%MapPrototype%": typeof Map === "undefined" ? undefined$2 : Map.prototype,
  "%Math%": Math,
  "%Number%": Number,
  "%NumberPrototype%": Number.prototype,
  "%Object%": Object,
  "%ObjectPrototype%": Object.prototype,
  "%ObjProto_toString%": Object.prototype.toString,
  "%ObjProto_valueOf%": Object.prototype.valueOf,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$2 : Promise,
  "%PromisePrototype%": typeof Promise === "undefined" ? undefined$2 : Promise.prototype,
  "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$2 : Promise.prototype.then,
  "%Promise_all%": typeof Promise === "undefined" ? undefined$2 : Promise.all,
  "%Promise_reject%": typeof Promise === "undefined" ? undefined$2 : Promise.reject,
  "%Promise_resolve%": typeof Promise === "undefined" ? undefined$2 : Promise.resolve,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$2 : Proxy,
  "%RangeError%": RangeError,
  "%RangeErrorPrototype%": RangeError.prototype,
  "%ReferenceError%": ReferenceError,
  "%ReferenceErrorPrototype%": ReferenceError.prototype,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$2 : Reflect,
  "%RegExp%": RegExp,
  "%RegExpPrototype%": RegExp.prototype,
  "%Set%": typeof Set === "undefined" ? undefined$2 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$6 ? undefined$2 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SetPrototype%": typeof Set === "undefined" ? undefined$2 : Set.prototype,
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$2 : SharedArrayBuffer,
  "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$2 : SharedArrayBuffer.prototype,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$6 ? getProto$2(""[Symbol.iterator]()) : undefined$2,
  "%StringPrototype%": String.prototype,
  "%Symbol%": hasSymbols$6 ? Symbol : undefined$2,
  "%SymbolPrototype%": hasSymbols$6 ? Symbol.prototype : undefined$2,
  "%SyntaxError%": SyntaxError,
  "%SyntaxErrorPrototype%": SyntaxError.prototype,
  "%ThrowTypeError%": ThrowTypeError$1,
  "%TypedArray%": TypedArray$1,
  "%TypedArrayPrototype%": TypedArray$1 ? TypedArray$1.prototype : undefined$2,
  "%TypeError%": $TypeError$8,
  "%TypeErrorPrototype%": $TypeError$8.prototype,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$2 : Uint8Array,
  "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$2 : Uint8Array.prototype,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$2 : Uint8ClampedArray,
  "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$2 : Uint8ClampedArray.prototype,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$2 : Uint16Array,
  "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$2 : Uint16Array.prototype,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$2 : Uint32Array,
  "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$2 : Uint32Array.prototype,
  "%URIError%": URIError,
  "%URIErrorPrototype%": URIError.prototype,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$2 : WeakMap,
  "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$2 : WeakMap.prototype,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$2 : WeakSet,
  "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$2 : WeakSet.prototype
};
var bind$3 = functionBind;
var $replace$1 = bind$3.call(Function.call, String.prototype.replace);
var rePropName$2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar$2 = /\\(\\)?/g;
var stringToPath$3 = function stringToPath(string) {
  var result = [];
  $replace$1(string, rePropName$2, function(match2, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar$2, "$1") : number2 || match2;
  });
  return result;
};
var getBaseIntrinsic$1 = function getBaseIntrinsic(name, allowMissing) {
  if (!(name in INTRINSICS$1)) {
    throw new SyntaxError("intrinsic " + name + " does not exist!");
  }
  if (typeof INTRINSICS$1[name] === "undefined" && !allowMissing) {
    throw new $TypeError$8("intrinsic " + name + " exists, but is not available. Please file an issue!");
  }
  return INTRINSICS$1[name];
};
var GetIntrinsic$d = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new TypeError('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath$3(name);
  var value = getBaseIntrinsic$1("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
  for (var i = 1; i < parts.length; i += 1) {
    if (value != null) {
      if ($gOPD$2 && i + 1 >= parts.length) {
        var desc = $gOPD$2(value, parts[i]);
        if (!allowMissing && !(parts[i] in value)) {
          throw new $TypeError$8("base intrinsic for " + name + " exists, but the property is not available.");
        }
        value = desc && "get" in desc && !("originalValue" in desc.get) ? desc.get : value[parts[i]];
      } else {
        value = value[parts[i]];
      }
    }
  }
  return value;
};
var callBind$8 = { exports: {} };
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $apply = GetIntrinsic4("%Function.prototype.apply%");
  var $call = GetIntrinsic4("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic4("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $defineProperty = GetIntrinsic4("%Object.defineProperty%", true);
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2() {
    return $reflectApply(bind3, $call, arguments);
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$8);
var callBindExports$1 = callBind$8.exports;
var GetIntrinsic$c = GetIntrinsic$d;
var callBind$7 = callBindExports$1;
var $indexOf$1 = callBind$7(GetIntrinsic$c("String.prototype.indexOf"));
var callBound$8 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$c(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.")) {
    return callBind$7(intrinsic);
  }
  return intrinsic;
};
var Call$1;
var hasRequiredCall;
function requireCall() {
  if (hasRequiredCall)
    return Call$1;
  hasRequiredCall = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var callBound2 = callBound$8;
  var $apply = GetIntrinsic4("%Reflect.apply%", true) || callBound2("%Function.prototype.apply%");
  Call$1 = function Call2(F2, V2) {
    var args = arguments.length > 2 ? arguments[2] : [];
    return $apply(F2, V2, args);
  };
  return Call$1;
}
var IsPropertyKey$2;
var hasRequiredIsPropertyKey;
function requireIsPropertyKey() {
  if (hasRequiredIsPropertyKey)
    return IsPropertyKey$2;
  hasRequiredIsPropertyKey = 1;
  IsPropertyKey$2 = function IsPropertyKey2(argument) {
    return typeof argument === "string" || typeof argument === "symbol";
  };
  return IsPropertyKey$2;
}
var Type$5 = function Type(x) {
  if (x === null) {
    return "Null";
  }
  if (typeof x === "undefined") {
    return "Undefined";
  }
  if (typeof x === "function" || typeof x === "object") {
    return "Object";
  }
  if (typeof x === "number") {
    return "Number";
  }
  if (typeof x === "boolean") {
    return "Boolean";
  }
  if (typeof x === "string") {
    return "String";
  }
};
var ES5Type = Type$5;
var Type$4 = function Type2(x) {
  if (typeof x === "symbol") {
    return "Symbol";
  }
  return ES5Type(x);
};
var GetIntrinsic$b = GetIntrinsic$d;
var $TypeError$7 = GetIntrinsic$b("%TypeError%");
var inspect$2 = objectInspect;
var IsPropertyKey$1 = requireIsPropertyKey();
var Type$3 = Type$4;
var Get$2 = function Get(O2, P2) {
  if (Type$3(O2) !== "Object") {
    throw new $TypeError$7("Assertion failed: Type(O) is not Object");
  }
  if (!IsPropertyKey$1(P2)) {
    throw new $TypeError$7("Assertion failed: IsPropertyKey(P) is not true, got " + inspect$2(P2));
  }
  return O2[P2];
};
var getIteratorMethod;
var hasRequiredGetIteratorMethod;
function requireGetIteratorMethod() {
  if (hasRequiredGetIteratorMethod)
    return getIteratorMethod;
  hasRequiredGetIteratorMethod = 1;
  var hasSymbols3 = hasSymbols$7();
  var GetIntrinsic4 = GetIntrinsic$d;
  var callBound2 = callBound$8;
  var $iterator = GetIntrinsic4("%Symbol.iterator%", true);
  var $stringSlice = callBound2("String.prototype.slice");
  getIteratorMethod = function getIteratorMethod2(ES, iterable) {
    var usingIterator;
    if (hasSymbols3) {
      usingIterator = ES.GetMethod(iterable, $iterator);
    } else if (ES.IsArray(iterable)) {
      usingIterator = function() {
        var i = -1;
        var arr = this;
        return {
          next: function() {
            i += 1;
            return {
              done: i >= arr.length,
              value: arr[i]
            };
          }
        };
      };
    } else if (ES.Type(iterable) === "String") {
      usingIterator = function() {
        var i = 0;
        return {
          next: function() {
            var nextIndex = ES.AdvanceStringIndex(iterable, i, true);
            var value = $stringSlice(iterable, i, nextIndex);
            i = nextIndex;
            return {
              done: nextIndex > iterable.length,
              value
            };
          }
        };
      };
    }
    return usingIterator;
  };
  return getIteratorMethod;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN)
    return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a2) {
    return a2 !== a2;
  };
  return _isNaN;
}
var _isFinite;
var hasRequired_isFinite;
function require_isFinite() {
  if (hasRequired_isFinite)
    return _isFinite;
  hasRequired_isFinite = 1;
  var $isNaN = Number.isNaN || function(a2) {
    return a2 !== a2;
  };
  _isFinite = Number.isFinite || function(x) {
    return typeof x === "number" && !$isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return _isFinite;
}
var IsInteger;
var hasRequiredIsInteger;
function requireIsInteger() {
  if (hasRequiredIsInteger)
    return IsInteger;
  hasRequiredIsInteger = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $Math = GetIntrinsic4("%Math%");
  var $floor = $Math.floor;
  var $abs = $Math.abs;
  var $isNaN = require_isNaN();
  var $isFinite = require_isFinite();
  IsInteger = function IsInteger2(argument) {
    if (typeof argument !== "number" || $isNaN(argument) || !$isFinite(argument)) {
      return false;
    }
    var abs = $abs(argument);
    return $floor(abs) === abs;
  };
  return IsInteger;
}
var maxSafeInteger;
var hasRequiredMaxSafeInteger;
function requireMaxSafeInteger() {
  if (hasRequiredMaxSafeInteger)
    return maxSafeInteger;
  hasRequiredMaxSafeInteger = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $Math = GetIntrinsic4("%Math%");
  var $Number = GetIntrinsic4("%Number%");
  maxSafeInteger = $Number.MAX_SAFE_INTEGER || $Math.pow(2, 53) - 1;
  return maxSafeInteger;
}
var AdvanceStringIndex;
var hasRequiredAdvanceStringIndex;
function requireAdvanceStringIndex() {
  if (hasRequiredAdvanceStringIndex)
    return AdvanceStringIndex;
  hasRequiredAdvanceStringIndex = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var IsInteger2 = requireIsInteger();
  var Type4 = Type$4;
  var MAX_SAFE_INTEGER2 = requireMaxSafeInteger();
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var $charCodeAt = callBound$8("String.prototype.charCodeAt");
  AdvanceStringIndex = function AdvanceStringIndex2(S2, index2, unicode) {
    if (Type4(S2) !== "String") {
      throw new $TypeError2("Assertion failed: `S` must be a String");
    }
    if (!IsInteger2(index2) || index2 < 0 || index2 > MAX_SAFE_INTEGER2) {
      throw new $TypeError2("Assertion failed: `length` must be an integer >= 0 and <= 2**53");
    }
    if (Type4(unicode) !== "Boolean") {
      throw new $TypeError2("Assertion failed: `unicode` must be a Boolean");
    }
    if (!unicode) {
      return index2 + 1;
    }
    var length = S2.length;
    if (index2 + 1 >= length) {
      return index2 + 1;
    }
    var first = $charCodeAt(S2, index2);
    if (first < 55296 || first > 56319) {
      return index2 + 1;
    }
    var second = $charCodeAt(S2, index2 + 1);
    if (second < 56320 || second > 57343) {
      return index2 + 1;
    }
    return index2 + 2;
  };
  return AdvanceStringIndex;
}
var GetIntrinsic$a = GetIntrinsic$d;
var $TypeError$6 = GetIntrinsic$a("%TypeError%");
var CheckObjectCoercible = function CheckObjectCoercible2(value, optMessage) {
  if (value == null) {
    throw new $TypeError$6(optMessage || "Cannot call method on " + value);
  }
  return value;
};
var RequireObjectCoercible$1 = CheckObjectCoercible;
var ToObject;
var hasRequiredToObject;
function requireToObject() {
  if (hasRequiredToObject)
    return ToObject;
  hasRequiredToObject = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $Object2 = GetIntrinsic4("%Object%");
  var RequireObjectCoercible2 = RequireObjectCoercible$1;
  ToObject = function ToObject2(value) {
    RequireObjectCoercible2(value);
    return $Object2(value);
  };
  return ToObject;
}
var GetV;
var hasRequiredGetV;
function requireGetV() {
  if (hasRequiredGetV)
    return GetV;
  hasRequiredGetV = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var IsPropertyKey2 = requireIsPropertyKey();
  var ToObject2 = requireToObject();
  GetV = function GetV2(V2, P2) {
    if (!IsPropertyKey2(P2)) {
      throw new $TypeError2("Assertion failed: IsPropertyKey(P) is not true");
    }
    var O2 = ToObject2(V2);
    return O2[P2];
  };
  return GetV;
}
var isCallable;
var hasRequiredIsCallable$1;
function requireIsCallable$1() {
  if (hasRequiredIsCallable$1)
    return isCallable;
  hasRequiredIsCallable$1 = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_2) {
      if (_2 !== isCallableMarker) {
        reflectApply = null;
      }
    }
  } else {
    reflectApply = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e2) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e2) {
      return false;
    }
  };
  var toStr2 = Object.prototype.toString;
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var hasToStringTag2 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  isCallable = reflectApply ? function isCallable2(value) {
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (typeof value === "function" && !value.prototype) {
      return true;
    }
    try {
      reflectApply(value, null, badArrayLike);
    } catch (e2) {
      if (e2 !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value);
  } : function isCallable2(value) {
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (typeof value === "function" && !value.prototype) {
      return true;
    }
    if (hasToStringTag2) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass2 = toStr2.call(value);
    return strClass2 === fnClass || strClass2 === genClass;
  };
  return isCallable;
}
var IsCallable$1;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return IsCallable$1;
  hasRequiredIsCallable = 1;
  IsCallable$1 = requireIsCallable$1();
  return IsCallable$1;
}
var GetMethod;
var hasRequiredGetMethod;
function requireGetMethod() {
  if (hasRequiredGetMethod)
    return GetMethod;
  hasRequiredGetMethod = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var GetV2 = requireGetV();
  var IsCallable2 = requireIsCallable();
  var IsPropertyKey2 = requireIsPropertyKey();
  GetMethod = function GetMethod2(O2, P2) {
    if (!IsPropertyKey2(P2)) {
      throw new $TypeError2("Assertion failed: IsPropertyKey(P) is not true");
    }
    var func = GetV2(O2, P2);
    if (func == null) {
      return void 0;
    }
    if (!IsCallable2(func)) {
      throw new $TypeError2(P2 + "is not a function");
    }
    return func;
  };
  return GetMethod;
}
var GetIntrinsic$9 = GetIntrinsic$d;
var $Array = GetIntrinsic$9("%Array%");
var toStr$7 = !$Array.isArray && callBound$8("Object.prototype.toString");
var IsArray$1 = $Array.isArray || function IsArray(argument) {
  return toStr$7(argument) === "[object Array]";
};
var GetIterator$1;
var hasRequiredGetIterator;
function requireGetIterator() {
  if (hasRequiredGetIterator)
    return GetIterator$1;
  hasRequiredGetIterator = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var getIteratorMethod2 = requireGetIteratorMethod();
  var AdvanceStringIndex2 = requireAdvanceStringIndex();
  var Call2 = requireCall();
  var GetMethod2 = requireGetMethod();
  var IsArray3 = IsArray$1;
  var Type4 = Type$4;
  GetIterator$1 = function GetIterator2(obj, method) {
    var actualMethod = method;
    if (arguments.length < 2) {
      actualMethod = getIteratorMethod2(
        {
          AdvanceStringIndex: AdvanceStringIndex2,
          GetMethod: GetMethod2,
          IsArray: IsArray3,
          Type: Type4
        },
        obj
      );
    }
    var iterator2 = Call2(actualMethod, obj);
    if (Type4(iterator2) !== "Object") {
      throw new $TypeError2("iterator must return an object");
    }
    return iterator2;
  };
  return GetIterator$1;
}
var IteratorClose$1;
var hasRequiredIteratorClose;
function requireIteratorClose() {
  if (hasRequiredIteratorClose)
    return IteratorClose$1;
  hasRequiredIteratorClose = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var Call2 = requireCall();
  var GetMethod2 = requireGetMethod();
  var IsCallable2 = requireIsCallable();
  var Type4 = Type$4;
  IteratorClose$1 = function IteratorClose2(iterator2, completion) {
    if (Type4(iterator2) !== "Object") {
      throw new $TypeError2("Assertion failed: Type(iterator) is not Object");
    }
    if (!IsCallable2(completion)) {
      throw new $TypeError2("Assertion failed: completion is not a thunk for a Completion Record");
    }
    var completionThunk = completion;
    var iteratorReturn = GetMethod2(iterator2, "return");
    if (typeof iteratorReturn === "undefined") {
      return completionThunk();
    }
    var completionRecord;
    try {
      var innerResult = Call2(iteratorReturn, iterator2, []);
    } catch (e2) {
      completionThunk();
      completionThunk = null;
      throw e2;
    }
    completionRecord = completionThunk();
    completionThunk = null;
    if (Type4(innerResult) !== "Object") {
      throw new $TypeError2("iterator .return must return an object");
    }
    return completionRecord;
  };
  return IteratorClose$1;
}
var ToBoolean;
var hasRequiredToBoolean;
function requireToBoolean() {
  if (hasRequiredToBoolean)
    return ToBoolean;
  hasRequiredToBoolean = 1;
  ToBoolean = function ToBoolean2(value) {
    return !!value;
  };
  return ToBoolean;
}
var IteratorComplete;
var hasRequiredIteratorComplete;
function requireIteratorComplete() {
  if (hasRequiredIteratorComplete)
    return IteratorComplete;
  hasRequiredIteratorComplete = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var Get3 = Get$2;
  var ToBoolean2 = requireToBoolean();
  var Type4 = Type$4;
  IteratorComplete = function IteratorComplete2(iterResult) {
    if (Type4(iterResult) !== "Object") {
      throw new $TypeError2("Assertion failed: Type(iterResult) is not Object");
    }
    return ToBoolean2(Get3(iterResult, "done"));
  };
  return IteratorComplete;
}
var Invoke;
var hasRequiredInvoke;
function requireInvoke() {
  if (hasRequiredInvoke)
    return Invoke;
  hasRequiredInvoke = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var $arraySlice = callBound$8("Array.prototype.slice");
  var Call2 = requireCall();
  var GetV2 = requireGetV();
  var IsPropertyKey2 = requireIsPropertyKey();
  Invoke = function Invoke2(O2, P2) {
    if (!IsPropertyKey2(P2)) {
      throw new $TypeError2("P must be a Property Key");
    }
    var argumentsList = $arraySlice(arguments, 2);
    var func = GetV2(O2, P2);
    return Call2(func, O2, argumentsList);
  };
  return Invoke;
}
var IteratorNext;
var hasRequiredIteratorNext;
function requireIteratorNext() {
  if (hasRequiredIteratorNext)
    return IteratorNext;
  hasRequiredIteratorNext = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var Invoke2 = requireInvoke();
  var Type4 = Type$4;
  IteratorNext = function IteratorNext2(iterator2, value) {
    var result = Invoke2(iterator2, "next", arguments.length < 2 ? [] : [value]);
    if (Type4(result) !== "Object") {
      throw new $TypeError2("iterator next must return an object");
    }
    return result;
  };
  return IteratorNext;
}
var IteratorStep$1;
var hasRequiredIteratorStep;
function requireIteratorStep() {
  if (hasRequiredIteratorStep)
    return IteratorStep$1;
  hasRequiredIteratorStep = 1;
  var IteratorComplete2 = requireIteratorComplete();
  var IteratorNext2 = requireIteratorNext();
  IteratorStep$1 = function IteratorStep2(iterator2) {
    var result = IteratorNext2(iterator2);
    var done = IteratorComplete2(result);
    return done === true ? false : result;
  };
  return IteratorStep$1;
}
var IteratorValue$1;
var hasRequiredIteratorValue;
function requireIteratorValue() {
  if (hasRequiredIteratorValue)
    return IteratorValue$1;
  hasRequiredIteratorValue = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var Get3 = Get$2;
  var Type4 = Type$4;
  IteratorValue$1 = function IteratorValue2(iterResult) {
    if (Type4(iterResult) !== "Object") {
      throw new $TypeError2("Assertion failed: Type(iterResult) is not Object");
    }
    return Get3(iterResult, "value");
  };
  return IteratorValue$1;
}
var inspect$1 = objectInspect;
var GetIntrinsic$8 = GetIntrinsic$d;
var $TypeError$5 = GetIntrinsic$8("%TypeError%");
var Call = requireCall();
var Get$1 = Get$2;
var GetIterator = requireGetIterator();
var IsCallable = requireIsCallable();
var IteratorClose = requireIteratorClose();
var IteratorStep = requireIteratorStep();
var IteratorValue = requireIteratorValue();
var Type$2 = Type$4;
var AddEntriesFromIterable$1 = function AddEntriesFromIterable(target, iterable, adder2) {
  if (!IsCallable(adder2)) {
    throw new $TypeError$5("Assertion failed: `adder` is not callable");
  }
  if (iterable == null) {
    throw new $TypeError$5("Assertion failed: `iterable` is present, and not nullish");
  }
  var iteratorRecord = GetIterator(iterable);
  while (true) {
    var next = IteratorStep(iteratorRecord);
    if (!next) {
      return target;
    }
    var nextItem = IteratorValue(next);
    if (Type$2(nextItem) !== "Object") {
      var error2 = new $TypeError$5("iterator next must return an Object, got " + inspect$1(nextItem));
      return IteratorClose(
        iteratorRecord,
        function() {
          throw error2;
        }
        // eslint-disable-line no-loop-func
      );
    }
    try {
      var k2 = Get$1(nextItem, "0");
      var v2 = Get$1(nextItem, "1");
      Call(adder2, target, [k2, v2]);
    } catch (e2) {
      return IteratorClose(
        iteratorRecord,
        function() {
          throw e2;
        }
      );
    }
  }
};
var DefineOwnProperty;
var hasRequiredDefineOwnProperty;
function requireDefineOwnProperty() {
  if (hasRequiredDefineOwnProperty)
    return DefineOwnProperty;
  hasRequiredDefineOwnProperty = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $defineProperty = GetIntrinsic4("%Object.defineProperty%", true);
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  var callBound2 = callBound$8;
  var $isEnumerable = callBound2("Object.prototype.propertyIsEnumerable");
  DefineOwnProperty = function DefineOwnProperty2(IsDataDescriptor2, SameValue2, FromPropertyDescriptor2, O2, P2, desc) {
    if (!$defineProperty) {
      if (!IsDataDescriptor2(desc)) {
        return false;
      }
      if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
        return false;
      }
      if (P2 in O2 && $isEnumerable(O2, P2) !== !!desc["[[Enumerable]]"]) {
        return false;
      }
      var V2 = desc["[[Value]]"];
      O2[P2] = V2;
      return SameValue2(O2[P2], V2);
    }
    $defineProperty(O2, P2, FromPropertyDescriptor2(desc));
    return true;
  };
  return DefineOwnProperty;
}
var bind$2 = functionBind;
var src = bind$2.call(Function.call, Object.prototype.hasOwnProperty);
var assertRecord;
var hasRequiredAssertRecord;
function requireAssertRecord() {
  if (hasRequiredAssertRecord)
    return assertRecord;
  hasRequiredAssertRecord = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var $SyntaxError2 = GetIntrinsic4("%SyntaxError%");
  var has2 = src;
  var predicates = {
    // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
    "Property Descriptor": function isPropertyDescriptor(Type4, Desc) {
      if (Type4(Desc) !== "Object") {
        return false;
      }
      var allowed = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Get]]": true,
        "[[Set]]": true,
        "[[Value]]": true,
        "[[Writable]]": true
      };
      for (var key in Desc) {
        if (has2(Desc, key) && !allowed[key]) {
          return false;
        }
      }
      var isData = has2(Desc, "[[Value]]");
      var IsAccessor = has2(Desc, "[[Get]]") || has2(Desc, "[[Set]]");
      if (isData && IsAccessor) {
        throw new $TypeError2("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    }
  };
  assertRecord = function assertRecord2(Type4, recordType2, argumentName, value) {
    var predicate = predicates[recordType2];
    if (typeof predicate !== "function") {
      throw new $SyntaxError2("unknown record type: " + recordType2);
    }
    if (!predicate(Type4, value)) {
      throw new $TypeError2(argumentName + " must be a " + recordType2);
    }
  };
  return assertRecord;
}
var FromPropertyDescriptor;
var hasRequiredFromPropertyDescriptor;
function requireFromPropertyDescriptor() {
  if (hasRequiredFromPropertyDescriptor)
    return FromPropertyDescriptor;
  hasRequiredFromPropertyDescriptor = 1;
  var assertRecord2 = requireAssertRecord();
  var Type4 = Type$4;
  FromPropertyDescriptor = function FromPropertyDescriptor2(Desc) {
    if (typeof Desc === "undefined") {
      return Desc;
    }
    assertRecord2(Type4, "Property Descriptor", "Desc", Desc);
    var obj = {};
    if ("[[Value]]" in Desc) {
      obj.value = Desc["[[Value]]"];
    }
    if ("[[Writable]]" in Desc) {
      obj.writable = Desc["[[Writable]]"];
    }
    if ("[[Get]]" in Desc) {
      obj.get = Desc["[[Get]]"];
    }
    if ("[[Set]]" in Desc) {
      obj.set = Desc["[[Set]]"];
    }
    if ("[[Enumerable]]" in Desc) {
      obj.enumerable = Desc["[[Enumerable]]"];
    }
    if ("[[Configurable]]" in Desc) {
      obj.configurable = Desc["[[Configurable]]"];
    }
    return obj;
  };
  return FromPropertyDescriptor;
}
var getOwnPropertyDescriptor$2;
var hasRequiredGetOwnPropertyDescriptor$1;
function requireGetOwnPropertyDescriptor$1() {
  if (hasRequiredGetOwnPropertyDescriptor$1)
    return getOwnPropertyDescriptor$2;
  hasRequiredGetOwnPropertyDescriptor$1 = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $gOPD2 = GetIntrinsic4("%Object.getOwnPropertyDescriptor%");
  if ($gOPD2) {
    try {
      $gOPD2([], "length");
    } catch (e2) {
      $gOPD2 = null;
    }
  }
  getOwnPropertyDescriptor$2 = $gOPD2;
  return getOwnPropertyDescriptor$2;
}
var hasSymbols$5 = hasSymbols$7();
var hasToStringTag$6 = hasSymbols$5 && typeof Symbol.toStringTag === "symbol";
var hasOwnProperty$b;
var regexExec;
var isRegexMarker;
var badStringifier;
if (hasToStringTag$6) {
  hasOwnProperty$b = Function.call.bind(Object.prototype.hasOwnProperty);
  regexExec = Function.call.bind(RegExp.prototype.exec);
  isRegexMarker = {};
  var throwRegexMarker = function() {
    throw isRegexMarker;
  };
  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  if (typeof Symbol.toPrimitive === "symbol") {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}
var toStr$6 = Object.prototype.toString;
var gOPD$2 = Object.getOwnPropertyDescriptor;
var regexClass = "[object RegExp]";
var isRegex$1 = hasToStringTag$6 ? function isRegex(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  var descriptor = gOPD$2(value, "lastIndex");
  var hasLastIndexDataProperty = descriptor && hasOwnProperty$b(descriptor, "value");
  if (!hasLastIndexDataProperty) {
    return false;
  }
  try {
    regexExec(value, badStringifier);
  } catch (e2) {
    return e2 === isRegexMarker;
  }
} : function isRegex2(value) {
  if (!value || typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return toStr$6.call(value) === regexClass;
};
var IsRegExp;
var hasRequiredIsRegExp;
function requireIsRegExp() {
  if (hasRequiredIsRegExp)
    return IsRegExp;
  hasRequiredIsRegExp = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $match = GetIntrinsic4("%Symbol.match%", true);
  var hasRegExpMatcher = isRegex$1;
  var ToBoolean2 = requireToBoolean();
  IsRegExp = function IsRegExp2(argument) {
    if (!argument || typeof argument !== "object") {
      return false;
    }
    if ($match) {
      var isRegExp2 = argument[$match];
      if (typeof isRegExp2 !== "undefined") {
        return ToBoolean2(isRegExp2);
      }
    }
    return hasRegExpMatcher(argument);
  };
  return IsRegExp;
}
var ToPropertyDescriptor;
var hasRequiredToPropertyDescriptor;
function requireToPropertyDescriptor() {
  if (hasRequiredToPropertyDescriptor)
    return ToPropertyDescriptor;
  hasRequiredToPropertyDescriptor = 1;
  var has2 = src;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var Type4 = Type$4;
  var ToBoolean2 = requireToBoolean();
  var IsCallable2 = requireIsCallable();
  ToPropertyDescriptor = function ToPropertyDescriptor2(Obj) {
    if (Type4(Obj) !== "Object") {
      throw new $TypeError2("ToPropertyDescriptor requires an object");
    }
    var desc = {};
    if (has2(Obj, "enumerable")) {
      desc["[[Enumerable]]"] = ToBoolean2(Obj.enumerable);
    }
    if (has2(Obj, "configurable")) {
      desc["[[Configurable]]"] = ToBoolean2(Obj.configurable);
    }
    if (has2(Obj, "value")) {
      desc["[[Value]]"] = Obj.value;
    }
    if (has2(Obj, "writable")) {
      desc["[[Writable]]"] = ToBoolean2(Obj.writable);
    }
    if (has2(Obj, "get")) {
      var getter = Obj.get;
      if (typeof getter !== "undefined" && !IsCallable2(getter)) {
        throw new $TypeError2("getter must be a function");
      }
      desc["[[Get]]"] = getter;
    }
    if (has2(Obj, "set")) {
      var setter = Obj.set;
      if (typeof setter !== "undefined" && !IsCallable2(setter)) {
        throw new $TypeError2("setter must be a function");
      }
      desc["[[Set]]"] = setter;
    }
    if ((has2(desc, "[[Get]]") || has2(desc, "[[Set]]")) && (has2(desc, "[[Value]]") || has2(desc, "[[Writable]]"))) {
      throw new $TypeError2("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
    }
    return desc;
  };
  return ToPropertyDescriptor;
}
var OrdinaryGetOwnProperty;
var hasRequiredOrdinaryGetOwnProperty;
function requireOrdinaryGetOwnProperty() {
  if (hasRequiredOrdinaryGetOwnProperty)
    return OrdinaryGetOwnProperty;
  hasRequiredOrdinaryGetOwnProperty = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $gOPD2 = requireGetOwnPropertyDescriptor$1();
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var callBound2 = callBound$8;
  var $isEnumerable = callBound2("Object.prototype.propertyIsEnumerable");
  var has2 = src;
  var IsArray3 = IsArray$1;
  var IsPropertyKey2 = requireIsPropertyKey();
  var IsRegExp2 = requireIsRegExp();
  var ToPropertyDescriptor2 = requireToPropertyDescriptor();
  var Type4 = Type$4;
  OrdinaryGetOwnProperty = function OrdinaryGetOwnProperty2(O2, P2) {
    if (Type4(O2) !== "Object") {
      throw new $TypeError2("Assertion failed: O must be an Object");
    }
    if (!IsPropertyKey2(P2)) {
      throw new $TypeError2("Assertion failed: P must be a Property Key");
    }
    if (!has2(O2, P2)) {
      return void 0;
    }
    if (!$gOPD2) {
      var arrayLength = IsArray3(O2) && P2 === "length";
      var regexLastIndex = IsRegExp2(O2) && P2 === "lastIndex";
      return {
        "[[Configurable]]": !(arrayLength || regexLastIndex),
        "[[Enumerable]]": $isEnumerable(O2, P2),
        "[[Value]]": O2[P2],
        "[[Writable]]": true
      };
    }
    return ToPropertyDescriptor2($gOPD2(O2, P2));
  };
  return OrdinaryGetOwnProperty;
}
var IsDataDescriptor;
var hasRequiredIsDataDescriptor;
function requireIsDataDescriptor() {
  if (hasRequiredIsDataDescriptor)
    return IsDataDescriptor;
  hasRequiredIsDataDescriptor = 1;
  var has2 = src;
  var assertRecord2 = requireAssertRecord();
  var Type4 = Type$4;
  IsDataDescriptor = function IsDataDescriptor2(Desc) {
    if (typeof Desc === "undefined") {
      return false;
    }
    assertRecord2(Type4, "Property Descriptor", "Desc", Desc);
    if (!has2(Desc, "[[Value]]") && !has2(Desc, "[[Writable]]")) {
      return false;
    }
    return true;
  };
  return IsDataDescriptor;
}
var isPrimitive$2;
var hasRequiredIsPrimitive$1;
function requireIsPrimitive$1() {
  if (hasRequiredIsPrimitive$1)
    return isPrimitive$2;
  hasRequiredIsPrimitive$1 = 1;
  isPrimitive$2 = function isPrimitive2(value) {
    return value === null || typeof value !== "function" && typeof value !== "object";
  };
  return isPrimitive$2;
}
var IsExtensible;
var hasRequiredIsExtensible;
function requireIsExtensible() {
  if (hasRequiredIsExtensible)
    return IsExtensible;
  hasRequiredIsExtensible = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $Object2 = GetIntrinsic4("%Object%");
  var isPrimitive2 = requireIsPrimitive$1();
  var $preventExtensions = $Object2.preventExtensions;
  var $isExtensible = $Object2.isExtensible;
  IsExtensible = $preventExtensions ? function IsExtensible2(obj) {
    return !isPrimitive2(obj) && $isExtensible(obj);
  } : function IsExtensible2(obj) {
    return !isPrimitive2(obj);
  };
  return IsExtensible;
}
var SameValue;
var hasRequiredSameValue;
function requireSameValue() {
  if (hasRequiredSameValue)
    return SameValue;
  hasRequiredSameValue = 1;
  var $isNaN = require_isNaN();
  SameValue = function SameValue2(x, y2) {
    if (x === y2) {
      if (x === 0) {
        return 1 / x === 1 / y2;
      }
      return true;
    }
    return $isNaN(x) && $isNaN(y2);
  };
  return SameValue;
}
var CreateDataProperty$1;
var hasRequiredCreateDataProperty;
function requireCreateDataProperty() {
  if (hasRequiredCreateDataProperty)
    return CreateDataProperty$1;
  hasRequiredCreateDataProperty = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  var DefineOwnProperty2 = requireDefineOwnProperty();
  var FromPropertyDescriptor2 = requireFromPropertyDescriptor();
  var OrdinaryGetOwnProperty2 = requireOrdinaryGetOwnProperty();
  var IsDataDescriptor2 = requireIsDataDescriptor();
  var IsExtensible2 = requireIsExtensible();
  var IsPropertyKey2 = requireIsPropertyKey();
  var SameValue2 = requireSameValue();
  var Type4 = Type$4;
  CreateDataProperty$1 = function CreateDataProperty2(O2, P2, V2) {
    if (Type4(O2) !== "Object") {
      throw new $TypeError2("Assertion failed: Type(O) is not Object");
    }
    if (!IsPropertyKey2(P2)) {
      throw new $TypeError2("Assertion failed: IsPropertyKey(P) is not true");
    }
    var oldDesc = OrdinaryGetOwnProperty2(O2, P2);
    var extensible = !oldDesc || IsExtensible2(O2);
    var immutable = oldDesc && (!oldDesc["[[Writable]]"] || !oldDesc["[[Configurable]]"]);
    if (immutable || !extensible) {
      return false;
    }
    return DefineOwnProperty2(
      IsDataDescriptor2,
      SameValue2,
      FromPropertyDescriptor2,
      O2,
      P2,
      {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V2,
        "[[Writable]]": true
      }
    );
  };
  return CreateDataProperty$1;
}
var GetIntrinsic$7 = GetIntrinsic$d;
var $TypeError$4 = GetIntrinsic$7("%TypeError%");
var CreateDataProperty = requireCreateDataProperty();
var IsPropertyKey = requireIsPropertyKey();
var Type$1 = Type$4;
var CreateDataPropertyOrThrow$1 = function CreateDataPropertyOrThrow(O2, P2, V2) {
  if (Type$1(O2) !== "Object") {
    throw new $TypeError$4("Assertion failed: Type(O) is not Object");
  }
  if (!IsPropertyKey(P2)) {
    throw new $TypeError$4("Assertion failed: IsPropertyKey(P) is not true");
  }
  var success = CreateDataProperty(O2, P2, V2);
  if (!success) {
    throw new $TypeError$4("unable to create data property");
  }
  return success;
};
var isPrimitive$1;
var hasRequiredIsPrimitive;
function requireIsPrimitive() {
  if (hasRequiredIsPrimitive)
    return isPrimitive$1;
  hasRequiredIsPrimitive = 1;
  isPrimitive$1 = function isPrimitive2(value) {
    return value === null || typeof value !== "function" && typeof value !== "object";
  };
  return isPrimitive$1;
}
var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$5 = Object.prototype.toString;
var dateClass = "[object Date]";
var hasToStringTag$5 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var isDateObject = function isDateObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  return hasToStringTag$5 ? tryDateObject(value) : toStr$5.call(value) === dateClass;
};
var isSymbol$2 = { exports: {} };
var toStr$4 = Object.prototype.toString;
var hasSymbols$4 = hasSymbols$7();
if (hasSymbols$4) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;
  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== "symbol") {
      return false;
    }
    return symStringRegex.test(symToStr.call(value));
  };
  isSymbol$2.exports = function isSymbol2(value) {
    if (typeof value === "symbol") {
      return true;
    }
    if (toStr$4.call(value) !== "[object Symbol]") {
      return false;
    }
    try {
      return isSymbolObject(value);
    } catch (e2) {
      return false;
    }
  };
} else {
  isSymbol$2.exports = function isSymbol2(value) {
    return false;
  };
}
var isSymbolExports = isSymbol$2.exports;
var es2015;
var hasRequiredEs2015;
function requireEs2015() {
  if (hasRequiredEs2015)
    return es2015;
  hasRequiredEs2015 = 1;
  var hasSymbols3 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
  var isPrimitive2 = requireIsPrimitive();
  var isCallable2 = requireIsCallable$1();
  var isDate2 = isDateObject;
  var isSymbol2 = isSymbolExports;
  var ordinaryToPrimitive = function OrdinaryToPrimitive(O2, hint) {
    if (typeof O2 === "undefined" || O2 === null) {
      throw new TypeError("Cannot call method on " + O2);
    }
    if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
      throw new TypeError('hint must be "string" or "number"');
    }
    var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
    var method, result, i;
    for (i = 0; i < methodNames.length; ++i) {
      method = O2[methodNames[i]];
      if (isCallable2(method)) {
        result = method.call(O2);
        if (isPrimitive2(result)) {
          return result;
        }
      }
    }
    throw new TypeError("No default value");
  };
  var GetMethod2 = function GetMethod3(O2, P2) {
    var func = O2[P2];
    if (func !== null && typeof func !== "undefined") {
      if (!isCallable2(func)) {
        throw new TypeError(func + " returned for property " + P2 + " of object " + O2 + " is not a function");
      }
      return func;
    }
    return void 0;
  };
  es2015 = function ToPrimitive2(input) {
    if (isPrimitive2(input)) {
      return input;
    }
    var hint = "default";
    if (arguments.length > 1) {
      if (arguments[1] === String) {
        hint = "string";
      } else if (arguments[1] === Number) {
        hint = "number";
      }
    }
    var exoticToPrim;
    if (hasSymbols3) {
      if (Symbol.toPrimitive) {
        exoticToPrim = GetMethod2(input, Symbol.toPrimitive);
      } else if (isSymbol2(input)) {
        exoticToPrim = Symbol.prototype.valueOf;
      }
    }
    if (typeof exoticToPrim !== "undefined") {
      var result = exoticToPrim.call(input, hint);
      if (isPrimitive2(result)) {
        return result;
      }
      throw new TypeError("unable to convert exotic object to primitive");
    }
    if (hint === "default" && (isDate2(input) || isSymbol2(input))) {
      hint = "string";
    }
    return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
  };
  return es2015;
}
var ToPrimitive$1;
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive)
    return ToPrimitive$1;
  hasRequiredToPrimitive = 1;
  var toPrimitive = requireEs2015();
  ToPrimitive$1 = function ToPrimitive2(input) {
    if (arguments.length > 1) {
      return toPrimitive(input, arguments[1]);
    }
    return toPrimitive(input);
  };
  return ToPrimitive$1;
}
var ToString$1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return ToString$1;
  hasRequiredToString = 1;
  var GetIntrinsic4 = GetIntrinsic$d;
  var $String2 = GetIntrinsic4("%String%");
  var $TypeError2 = GetIntrinsic4("%TypeError%");
  ToString$1 = function ToString2(argument) {
    if (typeof argument === "symbol") {
      throw new $TypeError2("Cannot convert a Symbol value to a string");
    }
    return $String2(argument);
  };
  return ToString$1;
}
var GetIntrinsic$6 = GetIntrinsic$d;
var $String = GetIntrinsic$6("%String%");
var ToPrimitive = requireToPrimitive();
var ToString = requireToString();
var ToPropertyKey$1 = function ToPropertyKey(argument) {
  var key = ToPrimitive(argument, $String);
  return typeof key === "symbol" ? key : ToString(key);
};
var AddEntriesFromIterable2 = AddEntriesFromIterable$1;
var CreateDataPropertyOrThrow2 = CreateDataPropertyOrThrow$1;
var Get2 = Get$2;
var IsArray2 = IsArray$1;
var RequireObjectCoercible = RequireObjectCoercible$1;
var ToPropertyKey2 = ToPropertyKey$1;
var Type3 = Type$4;
var adder = function addDataProperty(key, value) {
  var O2 = this;
  var propertyKey = ToPropertyKey2(key);
  CreateDataPropertyOrThrow2(O2, propertyKey, value);
};
var legacyAssign = function assign(obj, entries) {
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (Type3(entry) !== "Object") {
      throw new TypeError("iterator returned a non-object; entry expected");
    }
    var key = Get2(entry, "0");
    var value = Get2(entry, "1");
    var propertyKey = ToPropertyKey2(key);
    CreateDataPropertyOrThrow2(obj, propertyKey, value);
  }
};
var hasSymbols$3 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var implementation$b = function fromEntries(iterable) {
  RequireObjectCoercible(iterable);
  var obj = {};
  if (!hasSymbols$3) {
    if (!IsArray2(iterable)) {
      throw new TypeError("this environment lacks native Symbols, and can not support non-Array iterables");
    }
    legacyAssign(obj, iterable);
    return obj;
  }
  return AddEntriesFromIterable2(obj, iterable, adder);
};
var implementation$a = implementation$b;
var polyfill$6 = function getPolyfill() {
  return typeof Object.fromEntries === "function" ? Object.fromEntries : implementation$a;
};
var getPolyfill$7 = polyfill$6;
var define$5 = defineProperties_1;
var shim$7 = function shimEntries() {
  var polyfill2 = getPolyfill$7();
  define$5(Object, { fromEntries: polyfill2 }, {
    fromEntries: function testEntries() {
      return Object.fromEntries !== polyfill2;
    }
  });
  return polyfill2;
};
var define$4 = defineProperties_1;
var bind$1 = functionBind;
var implementation$9 = implementation$b;
var getPolyfill$6 = polyfill$6;
var shim$6 = shim$7;
var polyfill$5 = bind$1.call(getPolyfill$6());
define$4(polyfill$5, {
  getPolyfill: getPolyfill$6,
  implementation: implementation$9,
  shim: shim$6
});
var object_fromentries = polyfill$5;
const Bo = /* @__PURE__ */ getDefaultExportFromCjs(object_fromentries);
const t$2 = "_defaultStyle_14p2i_104", n$3 = "_highlightStyle_14p2i_105", i$2 = "_darkMode_14p2i_108", o = "_lightMode_14p2i_115", l$2 = "_Link_14p2i_158", _ = "_noAnimation_14p2i_190", e$3 = "_UnstyledButton_14p2i_205", d$2 = {
  defaultStyle: t$2,
  highlightStyle: n$3,
  darkMode: i$2,
  lightMode: o,
  Link: l$2,
  noAnimation: _,
  UnstyledButton: e$3
};
var psl$1 = {};
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type) {
  throw new RangeError(errors[type]);
}
function map(array, fn) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  const parts = string.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  const labels = string.split(".");
  const encoded = map(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const ucs2encode = (array) => String.fromCodePoint(...array);
const basicToDigit = function(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta, numPoints, firstTime) {
  let k2 = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
};
const decode$1 = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n2 = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
    let oldi = i;
    for (let w2 = 1, k2 = base; ; k2 += base) {
      if (index2 >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index2++));
      if (digit >= base || digit > floor((maxInt - i) / w2)) {
        error("overflow");
      }
      i += digit * w2;
      const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w2 > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w2 *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n2) {
      error("overflow");
    }
    n2 += floor(i / out);
    i %= out;
    output.splice(i++, 0, n2);
  }
  return String.fromCodePoint(...output);
};
const encode$1 = function(input) {
  const output = [];
  input = ucs2decode(input);
  let inputLength = input.length;
  let n2 = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  let basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m2 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (const currentValue of input) {
      if (currentValue < n2 && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        let q2 = delta;
        for (let k2 = base; ; k2 += base) {
          const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q2 < t2) {
            break;
          }
          const qMinusT = q2 - t2;
          const baseMinusT = base - t2;
          output.push(
            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
          );
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n2;
  }
  return output.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode$1(string.slice(4).toLowerCase()) : string;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode$1(string) : string;
  });
};
const punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.1.0",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode$1,
  "encode": encode$1,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
const punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: decode$1,
  default: punycode,
  encode: encode$1,
  toASCII,
  toUnicode,
  ucs2decode,
  ucs2encode
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
const require$$1 = [
  "ac",
  "com.ac",
  "edu.ac",
  "gov.ac",
  "net.ac",
  "mil.ac",
  "org.ac",
  "ad",
  "nom.ad",
  "ae",
  "co.ae",
  "net.ae",
  "org.ae",
  "sch.ae",
  "ac.ae",
  "gov.ae",
  "mil.ae",
  "aero",
  "accident-investigation.aero",
  "accident-prevention.aero",
  "aerobatic.aero",
  "aeroclub.aero",
  "aerodrome.aero",
  "agents.aero",
  "aircraft.aero",
  "airline.aero",
  "airport.aero",
  "air-surveillance.aero",
  "airtraffic.aero",
  "air-traffic-control.aero",
  "ambulance.aero",
  "amusement.aero",
  "association.aero",
  "author.aero",
  "ballooning.aero",
  "broker.aero",
  "caa.aero",
  "cargo.aero",
  "catering.aero",
  "certification.aero",
  "championship.aero",
  "charter.aero",
  "civilaviation.aero",
  "club.aero",
  "conference.aero",
  "consultant.aero",
  "consulting.aero",
  "control.aero",
  "council.aero",
  "crew.aero",
  "design.aero",
  "dgca.aero",
  "educator.aero",
  "emergency.aero",
  "engine.aero",
  "engineer.aero",
  "entertainment.aero",
  "equipment.aero",
  "exchange.aero",
  "express.aero",
  "federation.aero",
  "flight.aero",
  "fuel.aero",
  "gliding.aero",
  "government.aero",
  "groundhandling.aero",
  "group.aero",
  "hanggliding.aero",
  "homebuilt.aero",
  "insurance.aero",
  "journal.aero",
  "journalist.aero",
  "leasing.aero",
  "logistics.aero",
  "magazine.aero",
  "maintenance.aero",
  "media.aero",
  "microlight.aero",
  "modelling.aero",
  "navigation.aero",
  "parachuting.aero",
  "paragliding.aero",
  "passenger-association.aero",
  "pilot.aero",
  "press.aero",
  "production.aero",
  "recreation.aero",
  "repbody.aero",
  "res.aero",
  "research.aero",
  "rotorcraft.aero",
  "safety.aero",
  "scientist.aero",
  "services.aero",
  "show.aero",
  "skydiving.aero",
  "software.aero",
  "student.aero",
  "trader.aero",
  "trading.aero",
  "trainer.aero",
  "union.aero",
  "workinggroup.aero",
  "works.aero",
  "af",
  "gov.af",
  "com.af",
  "org.af",
  "net.af",
  "edu.af",
  "ag",
  "com.ag",
  "org.ag",
  "net.ag",
  "co.ag",
  "nom.ag",
  "ai",
  "off.ai",
  "com.ai",
  "net.ai",
  "org.ai",
  "al",
  "com.al",
  "edu.al",
  "gov.al",
  "mil.al",
  "net.al",
  "org.al",
  "am",
  "co.am",
  "com.am",
  "commune.am",
  "net.am",
  "org.am",
  "ao",
  "ed.ao",
  "gv.ao",
  "og.ao",
  "co.ao",
  "pb.ao",
  "it.ao",
  "aq",
  "ar",
  "bet.ar",
  "com.ar",
  "coop.ar",
  "edu.ar",
  "gob.ar",
  "gov.ar",
  "int.ar",
  "mil.ar",
  "musica.ar",
  "mutual.ar",
  "net.ar",
  "org.ar",
  "senasa.ar",
  "tur.ar",
  "arpa",
  "e164.arpa",
  "in-addr.arpa",
  "ip6.arpa",
  "iris.arpa",
  "uri.arpa",
  "urn.arpa",
  "as",
  "gov.as",
  "asia",
  "at",
  "ac.at",
  "co.at",
  "gv.at",
  "or.at",
  "sth.ac.at",
  "au",
  "com.au",
  "net.au",
  "org.au",
  "edu.au",
  "gov.au",
  "asn.au",
  "id.au",
  "info.au",
  "conf.au",
  "oz.au",
  "act.au",
  "nsw.au",
  "nt.au",
  "qld.au",
  "sa.au",
  "tas.au",
  "vic.au",
  "wa.au",
  "act.edu.au",
  "catholic.edu.au",
  "nsw.edu.au",
  "nt.edu.au",
  "qld.edu.au",
  "sa.edu.au",
  "tas.edu.au",
  "vic.edu.au",
  "wa.edu.au",
  "qld.gov.au",
  "sa.gov.au",
  "tas.gov.au",
  "vic.gov.au",
  "wa.gov.au",
  "schools.nsw.edu.au",
  "aw",
  "com.aw",
  "ax",
  "az",
  "com.az",
  "net.az",
  "int.az",
  "gov.az",
  "org.az",
  "edu.az",
  "info.az",
  "pp.az",
  "mil.az",
  "name.az",
  "pro.az",
  "biz.az",
  "ba",
  "com.ba",
  "edu.ba",
  "gov.ba",
  "mil.ba",
  "net.ba",
  "org.ba",
  "bb",
  "biz.bb",
  "co.bb",
  "com.bb",
  "edu.bb",
  "gov.bb",
  "info.bb",
  "net.bb",
  "org.bb",
  "store.bb",
  "tv.bb",
  "*.bd",
  "be",
  "ac.be",
  "bf",
  "gov.bf",
  "bg",
  "a.bg",
  "b.bg",
  "c.bg",
  "d.bg",
  "e.bg",
  "f.bg",
  "g.bg",
  "h.bg",
  "i.bg",
  "j.bg",
  "k.bg",
  "l.bg",
  "m.bg",
  "n.bg",
  "o.bg",
  "p.bg",
  "q.bg",
  "r.bg",
  "s.bg",
  "t.bg",
  "u.bg",
  "v.bg",
  "w.bg",
  "x.bg",
  "y.bg",
  "z.bg",
  "0.bg",
  "1.bg",
  "2.bg",
  "3.bg",
  "4.bg",
  "5.bg",
  "6.bg",
  "7.bg",
  "8.bg",
  "9.bg",
  "bh",
  "com.bh",
  "edu.bh",
  "net.bh",
  "org.bh",
  "gov.bh",
  "bi",
  "co.bi",
  "com.bi",
  "edu.bi",
  "or.bi",
  "org.bi",
  "biz",
  "bj",
  "asso.bj",
  "barreau.bj",
  "gouv.bj",
  "bm",
  "com.bm",
  "edu.bm",
  "gov.bm",
  "net.bm",
  "org.bm",
  "bn",
  "com.bn",
  "edu.bn",
  "gov.bn",
  "net.bn",
  "org.bn",
  "bo",
  "com.bo",
  "edu.bo",
  "gob.bo",
  "int.bo",
  "org.bo",
  "net.bo",
  "mil.bo",
  "tv.bo",
  "web.bo",
  "academia.bo",
  "agro.bo",
  "arte.bo",
  "blog.bo",
  "bolivia.bo",
  "ciencia.bo",
  "cooperativa.bo",
  "democracia.bo",
  "deporte.bo",
  "ecologia.bo",
  "economia.bo",
  "empresa.bo",
  "indigena.bo",
  "industria.bo",
  "info.bo",
  "medicina.bo",
  "movimiento.bo",
  "musica.bo",
  "natural.bo",
  "nombre.bo",
  "noticias.bo",
  "patria.bo",
  "politica.bo",
  "profesional.bo",
  "plurinacional.bo",
  "pueblo.bo",
  "revista.bo",
  "salud.bo",
  "tecnologia.bo",
  "tksat.bo",
  "transporte.bo",
  "wiki.bo",
  "br",
  "9guacu.br",
  "abc.br",
  "adm.br",
  "adv.br",
  "agr.br",
  "aju.br",
  "am.br",
  "anani.br",
  "aparecida.br",
  "app.br",
  "arq.br",
  "art.br",
  "ato.br",
  "b.br",
  "barueri.br",
  "belem.br",
  "bhz.br",
  "bib.br",
  "bio.br",
  "blog.br",
  "bmd.br",
  "boavista.br",
  "bsb.br",
  "campinagrande.br",
  "campinas.br",
  "caxias.br",
  "cim.br",
  "cng.br",
  "cnt.br",
  "com.br",
  "contagem.br",
  "coop.br",
  "coz.br",
  "cri.br",
  "cuiaba.br",
  "curitiba.br",
  "def.br",
  "des.br",
  "det.br",
  "dev.br",
  "ecn.br",
  "eco.br",
  "edu.br",
  "emp.br",
  "enf.br",
  "eng.br",
  "esp.br",
  "etc.br",
  "eti.br",
  "far.br",
  "feira.br",
  "flog.br",
  "floripa.br",
  "fm.br",
  "fnd.br",
  "fortal.br",
  "fot.br",
  "foz.br",
  "fst.br",
  "g12.br",
  "geo.br",
  "ggf.br",
  "goiania.br",
  "gov.br",
  "ac.gov.br",
  "al.gov.br",
  "am.gov.br",
  "ap.gov.br",
  "ba.gov.br",
  "ce.gov.br",
  "df.gov.br",
  "es.gov.br",
  "go.gov.br",
  "ma.gov.br",
  "mg.gov.br",
  "ms.gov.br",
  "mt.gov.br",
  "pa.gov.br",
  "pb.gov.br",
  "pe.gov.br",
  "pi.gov.br",
  "pr.gov.br",
  "rj.gov.br",
  "rn.gov.br",
  "ro.gov.br",
  "rr.gov.br",
  "rs.gov.br",
  "sc.gov.br",
  "se.gov.br",
  "sp.gov.br",
  "to.gov.br",
  "gru.br",
  "imb.br",
  "ind.br",
  "inf.br",
  "jab.br",
  "jampa.br",
  "jdf.br",
  "joinville.br",
  "jor.br",
  "jus.br",
  "leg.br",
  "lel.br",
  "log.br",
  "londrina.br",
  "macapa.br",
  "maceio.br",
  "manaus.br",
  "maringa.br",
  "mat.br",
  "med.br",
  "mil.br",
  "morena.br",
  "mp.br",
  "mus.br",
  "natal.br",
  "net.br",
  "niteroi.br",
  "*.nom.br",
  "not.br",
  "ntr.br",
  "odo.br",
  "ong.br",
  "org.br",
  "osasco.br",
  "palmas.br",
  "poa.br",
  "ppg.br",
  "pro.br",
  "psc.br",
  "psi.br",
  "pvh.br",
  "qsl.br",
  "radio.br",
  "rec.br",
  "recife.br",
  "rep.br",
  "ribeirao.br",
  "rio.br",
  "riobranco.br",
  "riopreto.br",
  "salvador.br",
  "sampa.br",
  "santamaria.br",
  "santoandre.br",
  "saobernardo.br",
  "saogonca.br",
  "seg.br",
  "sjc.br",
  "slg.br",
  "slz.br",
  "sorocaba.br",
  "srv.br",
  "taxi.br",
  "tc.br",
  "tec.br",
  "teo.br",
  "the.br",
  "tmp.br",
  "trd.br",
  "tur.br",
  "tv.br",
  "udi.br",
  "vet.br",
  "vix.br",
  "vlog.br",
  "wiki.br",
  "zlg.br",
  "bs",
  "com.bs",
  "net.bs",
  "org.bs",
  "edu.bs",
  "gov.bs",
  "bt",
  "com.bt",
  "edu.bt",
  "gov.bt",
  "net.bt",
  "org.bt",
  "bv",
  "bw",
  "co.bw",
  "org.bw",
  "by",
  "gov.by",
  "mil.by",
  "com.by",
  "of.by",
  "bz",
  "com.bz",
  "net.bz",
  "org.bz",
  "edu.bz",
  "gov.bz",
  "ca",
  "ab.ca",
  "bc.ca",
  "mb.ca",
  "nb.ca",
  "nf.ca",
  "nl.ca",
  "ns.ca",
  "nt.ca",
  "nu.ca",
  "on.ca",
  "pe.ca",
  "qc.ca",
  "sk.ca",
  "yk.ca",
  "gc.ca",
  "cat",
  "cc",
  "cd",
  "gov.cd",
  "cf",
  "cg",
  "ch",
  "ci",
  "org.ci",
  "or.ci",
  "com.ci",
  "co.ci",
  "edu.ci",
  "ed.ci",
  "ac.ci",
  "net.ci",
  "go.ci",
  "asso.ci",
  "aéroport.ci",
  "int.ci",
  "presse.ci",
  "md.ci",
  "gouv.ci",
  "*.ck",
  "!www.ck",
  "cl",
  "co.cl",
  "gob.cl",
  "gov.cl",
  "mil.cl",
  "cm",
  "co.cm",
  "com.cm",
  "gov.cm",
  "net.cm",
  "cn",
  "ac.cn",
  "com.cn",
  "edu.cn",
  "gov.cn",
  "net.cn",
  "org.cn",
  "mil.cn",
  "公司.cn",
  "网络.cn",
  "網絡.cn",
  "ah.cn",
  "bj.cn",
  "cq.cn",
  "fj.cn",
  "gd.cn",
  "gs.cn",
  "gz.cn",
  "gx.cn",
  "ha.cn",
  "hb.cn",
  "he.cn",
  "hi.cn",
  "hl.cn",
  "hn.cn",
  "jl.cn",
  "js.cn",
  "jx.cn",
  "ln.cn",
  "nm.cn",
  "nx.cn",
  "qh.cn",
  "sc.cn",
  "sd.cn",
  "sh.cn",
  "sn.cn",
  "sx.cn",
  "tj.cn",
  "xj.cn",
  "xz.cn",
  "yn.cn",
  "zj.cn",
  "hk.cn",
  "mo.cn",
  "tw.cn",
  "co",
  "arts.co",
  "com.co",
  "edu.co",
  "firm.co",
  "gov.co",
  "info.co",
  "int.co",
  "mil.co",
  "net.co",
  "nom.co",
  "org.co",
  "rec.co",
  "web.co",
  "com",
  "coop",
  "cr",
  "ac.cr",
  "co.cr",
  "ed.cr",
  "fi.cr",
  "go.cr",
  "or.cr",
  "sa.cr",
  "cu",
  "com.cu",
  "edu.cu",
  "org.cu",
  "net.cu",
  "gov.cu",
  "inf.cu",
  "cv",
  "com.cv",
  "edu.cv",
  "int.cv",
  "nome.cv",
  "org.cv",
  "cw",
  "com.cw",
  "edu.cw",
  "net.cw",
  "org.cw",
  "cx",
  "gov.cx",
  "cy",
  "ac.cy",
  "biz.cy",
  "com.cy",
  "ekloges.cy",
  "gov.cy",
  "ltd.cy",
  "mil.cy",
  "net.cy",
  "org.cy",
  "press.cy",
  "pro.cy",
  "tm.cy",
  "cz",
  "de",
  "dj",
  "dk",
  "dm",
  "com.dm",
  "net.dm",
  "org.dm",
  "edu.dm",
  "gov.dm",
  "do",
  "art.do",
  "com.do",
  "edu.do",
  "gob.do",
  "gov.do",
  "mil.do",
  "net.do",
  "org.do",
  "sld.do",
  "web.do",
  "dz",
  "art.dz",
  "asso.dz",
  "com.dz",
  "edu.dz",
  "gov.dz",
  "org.dz",
  "net.dz",
  "pol.dz",
  "soc.dz",
  "tm.dz",
  "ec",
  "com.ec",
  "info.ec",
  "net.ec",
  "fin.ec",
  "k12.ec",
  "med.ec",
  "pro.ec",
  "org.ec",
  "edu.ec",
  "gov.ec",
  "gob.ec",
  "mil.ec",
  "edu",
  "ee",
  "edu.ee",
  "gov.ee",
  "riik.ee",
  "lib.ee",
  "med.ee",
  "com.ee",
  "pri.ee",
  "aip.ee",
  "org.ee",
  "fie.ee",
  "eg",
  "com.eg",
  "edu.eg",
  "eun.eg",
  "gov.eg",
  "mil.eg",
  "name.eg",
  "net.eg",
  "org.eg",
  "sci.eg",
  "*.er",
  "es",
  "com.es",
  "nom.es",
  "org.es",
  "gob.es",
  "edu.es",
  "et",
  "com.et",
  "gov.et",
  "org.et",
  "edu.et",
  "biz.et",
  "name.et",
  "info.et",
  "net.et",
  "eu",
  "fi",
  "aland.fi",
  "fj",
  "ac.fj",
  "biz.fj",
  "com.fj",
  "gov.fj",
  "info.fj",
  "mil.fj",
  "name.fj",
  "net.fj",
  "org.fj",
  "pro.fj",
  "*.fk",
  "com.fm",
  "edu.fm",
  "net.fm",
  "org.fm",
  "fm",
  "fo",
  "fr",
  "asso.fr",
  "com.fr",
  "gouv.fr",
  "nom.fr",
  "prd.fr",
  "tm.fr",
  "aeroport.fr",
  "avocat.fr",
  "avoues.fr",
  "cci.fr",
  "chambagri.fr",
  "chirurgiens-dentistes.fr",
  "experts-comptables.fr",
  "geometre-expert.fr",
  "greta.fr",
  "huissier-justice.fr",
  "medecin.fr",
  "notaires.fr",
  "pharmacien.fr",
  "port.fr",
  "veterinaire.fr",
  "ga",
  "gb",
  "edu.gd",
  "gov.gd",
  "gd",
  "ge",
  "com.ge",
  "edu.ge",
  "gov.ge",
  "org.ge",
  "mil.ge",
  "net.ge",
  "pvt.ge",
  "gf",
  "gg",
  "co.gg",
  "net.gg",
  "org.gg",
  "gh",
  "com.gh",
  "edu.gh",
  "gov.gh",
  "org.gh",
  "mil.gh",
  "gi",
  "com.gi",
  "ltd.gi",
  "gov.gi",
  "mod.gi",
  "edu.gi",
  "org.gi",
  "gl",
  "co.gl",
  "com.gl",
  "edu.gl",
  "net.gl",
  "org.gl",
  "gm",
  "gn",
  "ac.gn",
  "com.gn",
  "edu.gn",
  "gov.gn",
  "org.gn",
  "net.gn",
  "gov",
  "gp",
  "com.gp",
  "net.gp",
  "mobi.gp",
  "edu.gp",
  "org.gp",
  "asso.gp",
  "gq",
  "gr",
  "com.gr",
  "edu.gr",
  "net.gr",
  "org.gr",
  "gov.gr",
  "gs",
  "gt",
  "com.gt",
  "edu.gt",
  "gob.gt",
  "ind.gt",
  "mil.gt",
  "net.gt",
  "org.gt",
  "gu",
  "com.gu",
  "edu.gu",
  "gov.gu",
  "guam.gu",
  "info.gu",
  "net.gu",
  "org.gu",
  "web.gu",
  "gw",
  "gy",
  "co.gy",
  "com.gy",
  "edu.gy",
  "gov.gy",
  "net.gy",
  "org.gy",
  "hk",
  "com.hk",
  "edu.hk",
  "gov.hk",
  "idv.hk",
  "net.hk",
  "org.hk",
  "公司.hk",
  "教育.hk",
  "敎育.hk",
  "政府.hk",
  "個人.hk",
  "个��.hk",
  "箇人.hk",
  "網络.hk",
  "网络.hk",
  "组織.hk",
  "網絡.hk",
  "网絡.hk",
  "组织.hk",
  "組織.hk",
  "組织.hk",
  "hm",
  "hn",
  "com.hn",
  "edu.hn",
  "org.hn",
  "net.hn",
  "mil.hn",
  "gob.hn",
  "hr",
  "iz.hr",
  "from.hr",
  "name.hr",
  "com.hr",
  "ht",
  "com.ht",
  "shop.ht",
  "firm.ht",
  "info.ht",
  "adult.ht",
  "net.ht",
  "pro.ht",
  "org.ht",
  "med.ht",
  "art.ht",
  "coop.ht",
  "pol.ht",
  "asso.ht",
  "edu.ht",
  "rel.ht",
  "gouv.ht",
  "perso.ht",
  "hu",
  "co.hu",
  "info.hu",
  "org.hu",
  "priv.hu",
  "sport.hu",
  "tm.hu",
  "2000.hu",
  "agrar.hu",
  "bolt.hu",
  "casino.hu",
  "city.hu",
  "erotica.hu",
  "erotika.hu",
  "film.hu",
  "forum.hu",
  "games.hu",
  "hotel.hu",
  "ingatlan.hu",
  "jogasz.hu",
  "konyvelo.hu",
  "lakas.hu",
  "media.hu",
  "news.hu",
  "reklam.hu",
  "sex.hu",
  "shop.hu",
  "suli.hu",
  "szex.hu",
  "tozsde.hu",
  "utazas.hu",
  "video.hu",
  "id",
  "ac.id",
  "biz.id",
  "co.id",
  "desa.id",
  "go.id",
  "mil.id",
  "my.id",
  "net.id",
  "or.id",
  "ponpes.id",
  "sch.id",
  "web.id",
  "ie",
  "gov.ie",
  "il",
  "ac.il",
  "co.il",
  "gov.il",
  "idf.il",
  "k12.il",
  "muni.il",
  "net.il",
  "org.il",
  "im",
  "ac.im",
  "co.im",
  "com.im",
  "ltd.co.im",
  "net.im",
  "org.im",
  "plc.co.im",
  "tt.im",
  "tv.im",
  "in",
  "co.in",
  "firm.in",
  "net.in",
  "org.in",
  "gen.in",
  "ind.in",
  "nic.in",
  "ac.in",
  "edu.in",
  "res.in",
  "gov.in",
  "mil.in",
  "info",
  "int",
  "eu.int",
  "io",
  "com.io",
  "iq",
  "gov.iq",
  "edu.iq",
  "mil.iq",
  "com.iq",
  "org.iq",
  "net.iq",
  "ir",
  "ac.ir",
  "co.ir",
  "gov.ir",
  "id.ir",
  "net.ir",
  "org.ir",
  "sch.ir",
  "ایران.ir",
  "ايران.ir",
  "is",
  "net.is",
  "com.is",
  "edu.is",
  "gov.is",
  "org.is",
  "int.is",
  "it",
  "gov.it",
  "edu.it",
  "abr.it",
  "abruzzo.it",
  "aosta-valley.it",
  "aostavalley.it",
  "bas.it",
  "basilicata.it",
  "cal.it",
  "calabria.it",
  "cam.it",
  "campania.it",
  "emilia-romagna.it",
  "emiliaromagna.it",
  "emr.it",
  "friuli-v-giulia.it",
  "friuli-ve-giulia.it",
  "friuli-vegiulia.it",
  "friuli-venezia-giulia.it",
  "friuli-veneziagiulia.it",
  "friuli-vgiulia.it",
  "friuliv-giulia.it",
  "friulive-giulia.it",
  "friulivegiulia.it",
  "friulivenezia-giulia.it",
  "friuliveneziagiulia.it",
  "friulivgiulia.it",
  "fvg.it",
  "laz.it",
  "lazio.it",
  "lig.it",
  "liguria.it",
  "lom.it",
  "lombardia.it",
  "lombardy.it",
  "lucania.it",
  "mar.it",
  "marche.it",
  "mol.it",
  "molise.it",
  "piedmont.it",
  "piemonte.it",
  "pmn.it",
  "pug.it",
  "puglia.it",
  "sar.it",
  "sardegna.it",
  "sardinia.it",
  "sic.it",
  "sicilia.it",
  "sicily.it",
  "taa.it",
  "tos.it",
  "toscana.it",
  "trentin-sud-tirol.it",
  "trentin-süd-tirol.it",
  "trentin-sudtirol.it",
  "trentin-südtirol.it",
  "trentin-sued-tirol.it",
  "trentin-suedtirol.it",
  "trentino-a-adige.it",
  "trentino-aadige.it",
  "trentino-alto-adige.it",
  "trentino-altoadige.it",
  "trentino-s-tirol.it",
  "trentino-stirol.it",
  "trentino-sud-tirol.it",
  "trentino-süd-tirol.it",
  "trentino-sudtirol.it",
  "trentino-südtirol.it",
  "trentino-sued-tirol.it",
  "trentino-suedtirol.it",
  "trentino.it",
  "trentinoa-adige.it",
  "trentinoaadige.it",
  "trentinoalto-adige.it",
  "trentinoaltoadige.it",
  "trentinos-tirol.it",
  "trentinostirol.it",
  "trentinosud-tirol.it",
  "trentinosüd-tirol.it",
  "trentinosudtirol.it",
  "trentinosüdtirol.it",
  "trentinosued-tirol.it",
  "trentinosuedtirol.it",
  "trentinsud-tirol.it",
  "trentinsüd-tirol.it",
  "trentinsudtirol.it",
  "trentinsüdtirol.it",
  "trentinsued-tirol.it",
  "trentinsuedtirol.it",
  "tuscany.it",
  "umb.it",
  "umbria.it",
  "val-d-aosta.it",
  "val-daosta.it",
  "vald-aosta.it",
  "valdaosta.it",
  "valle-aosta.it",
  "valle-d-aosta.it",
  "valle-daosta.it",
  "valleaosta.it",
  "valled-aosta.it",
  "valledaosta.it",
  "vallee-aoste.it",
  "vallée-aoste.it",
  "vallee-d-aoste.it",
  "vallée-d-aoste.it",
  "valleeaoste.it",
  "valléeaoste.it",
  "valleedaoste.it",
  "valléedaoste.it",
  "vao.it",
  "vda.it",
  "ven.it",
  "veneto.it",
  "ag.it",
  "agrigento.it",
  "al.it",
  "alessandria.it",
  "alto-adige.it",
  "altoadige.it",
  "an.it",
  "ancona.it",
  "andria-barletta-trani.it",
  "andria-trani-barletta.it",
  "andriabarlettatrani.it",
  "andriatranibarletta.it",
  "ao.it",
  "aosta.it",
  "aoste.it",
  "ap.it",
  "aq.it",
  "aquila.it",
  "ar.it",
  "arezzo.it",
  "ascoli-piceno.it",
  "ascolipiceno.it",
  "asti.it",
  "at.it",
  "av.it",
  "avellino.it",
  "ba.it",
  "balsan-sudtirol.it",
  "balsan-südtirol.it",
  "balsan-suedtirol.it",
  "balsan.it",
  "bari.it",
  "barletta-trani-andria.it",
  "barlettatraniandria.it",
  "belluno.it",
  "benevento.it",
  "bergamo.it",
  "bg.it",
  "bi.it",
  "biella.it",
  "bl.it",
  "bn.it",
  "bo.it",
  "bologna.it",
  "bolzano-altoadige.it",
  "bolzano.it",
  "bozen-sudtirol.it",
  "bozen-südtirol.it",
  "bozen-suedtirol.it",
  "bozen.it",
  "br.it",
  "brescia.it",
  "brindisi.it",
  "bs.it",
  "bt.it",
  "bulsan-sudtirol.it",
  "bulsan-südtirol.it",
  "bulsan-suedtirol.it",
  "bulsan.it",
  "bz.it",
  "ca.it",
  "cagliari.it",
  "caltanissetta.it",
  "campidano-medio.it",
  "campidanomedio.it",
  "campobasso.it",
  "carbonia-iglesias.it",
  "carboniaiglesias.it",
  "carrara-massa.it",
  "carraramassa.it",
  "caserta.it",
  "catania.it",
  "catanzaro.it",
  "cb.it",
  "ce.it",
  "cesena-forli.it",
  "cesena-forlì.it",
  "cesenaforli.it",
  "cesenaforlì.it",
  "ch.it",
  "chieti.it",
  "ci.it",
  "cl.it",
  "cn.it",
  "co.it",
  "como.it",
  "cosenza.it",
  "cr.it",
  "cremona.it",
  "crotone.it",
  "cs.it",
  "ct.it",
  "cuneo.it",
  "cz.it",
  "dell-ogliastra.it",
  "dellogliastra.it",
  "en.it",
  "enna.it",
  "fc.it",
  "fe.it",
  "fermo.it",
  "ferrara.it",
  "fg.it",
  "fi.it",
  "firenze.it",
  "florence.it",
  "fm.it",
  "foggia.it",
  "forli-cesena.it",
  "forlì-cesena.it",
  "forlicesena.it",
  "forlìcesena.it",
  "fr.it",
  "frosinone.it",
  "ge.it",
  "genoa.it",
  "genova.it",
  "go.it",
  "gorizia.it",
  "gr.it",
  "grosseto.it",
  "iglesias-carbonia.it",
  "iglesiascarbonia.it",
  "im.it",
  "imperia.it",
  "is.it",
  "isernia.it",
  "kr.it",
  "la-spezia.it",
  "laquila.it",
  "laspezia.it",
  "latina.it",
  "lc.it",
  "le.it",
  "lecce.it",
  "lecco.it",
  "li.it",
  "livorno.it",
  "lo.it",
  "lodi.it",
  "lt.it",
  "lu.it",
  "lucca.it",
  "macerata.it",
  "mantova.it",
  "massa-carrara.it",
  "massacarrara.it",
  "matera.it",
  "mb.it",
  "mc.it",
  "me.it",
  "medio-campidano.it",
  "mediocampidano.it",
  "messina.it",
  "mi.it",
  "milan.it",
  "milano.it",
  "mn.it",
  "mo.it",
  "modena.it",
  "monza-brianza.it",
  "monza-e-della-brianza.it",
  "monza.it",
  "monzabrianza.it",
  "monzaebrianza.it",
  "monzaedellabrianza.it",
  "ms.it",
  "mt.it",
  "na.it",
  "naples.it",
  "napoli.it",
  "no.it",
  "novara.it",
  "nu.it",
  "nuoro.it",
  "og.it",
  "ogliastra.it",
  "olbia-tempio.it",
  "olbiatempio.it",
  "or.it",
  "oristano.it",
  "ot.it",
  "pa.it",
  "padova.it",
  "padua.it",
  "palermo.it",
  "parma.it",
  "pavia.it",
  "pc.it",
  "pd.it",
  "pe.it",
  "perugia.it",
  "pesaro-urbino.it",
  "pesarourbino.it",
  "pescara.it",
  "pg.it",
  "pi.it",
  "piacenza.it",
  "pisa.it",
  "pistoia.it",
  "pn.it",
  "po.it",
  "pordenone.it",
  "potenza.it",
  "pr.it",
  "prato.it",
  "pt.it",
  "pu.it",
  "pv.it",
  "pz.it",
  "ra.it",
  "ragusa.it",
  "ravenna.it",
  "rc.it",
  "re.it",
  "reggio-calabria.it",
  "reggio-emilia.it",
  "reggiocalabria.it",
  "reggioemilia.it",
  "rg.it",
  "ri.it",
  "rieti.it",
  "rimini.it",
  "rm.it",
  "rn.it",
  "ro.it",
  "roma.it",
  "rome.it",
  "rovigo.it",
  "sa.it",
  "salerno.it",
  "sassari.it",
  "savona.it",
  "si.it",
  "siena.it",
  "siracusa.it",
  "so.it",
  "sondrio.it",
  "sp.it",
  "sr.it",
  "ss.it",
  "suedtirol.it",
  "südtirol.it",
  "sv.it",
  "ta.it",
  "taranto.it",
  "te.it",
  "tempio-olbia.it",
  "tempioolbia.it",
  "teramo.it",
  "terni.it",
  "tn.it",
  "to.it",
  "torino.it",
  "tp.it",
  "tr.it",
  "trani-andria-barletta.it",
  "trani-barletta-andria.it",
  "traniandriabarletta.it",
  "tranibarlettaandria.it",
  "trapani.it",
  "trento.it",
  "treviso.it",
  "trieste.it",
  "ts.it",
  "turin.it",
  "tv.it",
  "ud.it",
  "udine.it",
  "urbino-pesaro.it",
  "urbinopesaro.it",
  "va.it",
  "varese.it",
  "vb.it",
  "vc.it",
  "ve.it",
  "venezia.it",
  "venice.it",
  "verbania.it",
  "vercelli.it",
  "verona.it",
  "vi.it",
  "vibo-valentia.it",
  "vibovalentia.it",
  "vicenza.it",
  "viterbo.it",
  "vr.it",
  "vs.it",
  "vt.it",
  "vv.it",
  "je",
  "co.je",
  "net.je",
  "org.je",
  "*.jm",
  "jo",
  "com.jo",
  "org.jo",
  "net.jo",
  "edu.jo",
  "sch.jo",
  "gov.jo",
  "mil.jo",
  "name.jo",
  "jobs",
  "jp",
  "ac.jp",
  "ad.jp",
  "co.jp",
  "ed.jp",
  "go.jp",
  "gr.jp",
  "lg.jp",
  "ne.jp",
  "or.jp",
  "aichi.jp",
  "akita.jp",
  "aomori.jp",
  "chiba.jp",
  "ehime.jp",
  "fukui.jp",
  "fukuoka.jp",
  "fukushima.jp",
  "gifu.jp",
  "gunma.jp",
  "hiroshima.jp",
  "hokkaido.jp",
  "hyogo.jp",
  "ibaraki.jp",
  "ishikawa.jp",
  "iwate.jp",
  "kagawa.jp",
  "kagoshima.jp",
  "kanagawa.jp",
  "kochi.jp",
  "kumamoto.jp",
  "kyoto.jp",
  "mie.jp",
  "miyagi.jp",
  "miyazaki.jp",
  "nagano.jp",
  "nagasaki.jp",
  "nara.jp",
  "niigata.jp",
  "oita.jp",
  "okayama.jp",
  "okinawa.jp",
  "osaka.jp",
  "saga.jp",
  "saitama.jp",
  "shiga.jp",
  "shimane.jp",
  "shizuoka.jp",
  "tochigi.jp",
  "tokushima.jp",
  "tokyo.jp",
  "tottori.jp",
  "toyama.jp",
  "wakayama.jp",
  "yamagata.jp",
  "yamaguchi.jp",
  "yamanashi.jp",
  "栃木.jp",
  "愛知.jp",
  "愛媛.jp",
  "兵庫.jp",
  "熊本.jp",
  "茨城.jp",
  "北海道.jp",
  "千葉.jp",
  "和歌山.jp",
  "長崎.jp",
  "長野.jp",
  "新潟.jp",
  "青森.jp",
  "静岡.jp",
  "東京.jp",
  "石川.jp",
  "埼玉.jp",
  "三重.jp",
  "京都.jp",
  "佐賀.jp",
  "大分.jp",
  "大阪.jp",
  "奈良.jp",
  "宮城.jp",
  "宮崎.jp",
  "富山.jp",
  "山口.jp",
  "山形.jp",
  "山梨.jp",
  "岩手.jp",
  "岐阜.jp",
  "岡山.jp",
  "島根.jp",
  "広島.jp",
  "徳島.jp",
  "沖縄.jp",
  "滋賀.jp",
  "神奈川.jp",
  "福井.jp",
  "福岡.jp",
  "福島.jp",
  "秋田.jp",
  "群馬.jp",
  "香川.jp",
  "高知.jp",
  "鳥取.jp",
  "鹿児島.jp",
  "*.kawasaki.jp",
  "*.kitakyushu.jp",
  "*.kobe.jp",
  "*.nagoya.jp",
  "*.sapporo.jp",
  "*.sendai.jp",
  "*.yokohama.jp",
  "!city.kawasaki.jp",
  "!city.kitakyushu.jp",
  "!city.kobe.jp",
  "!city.nagoya.jp",
  "!city.sapporo.jp",
  "!city.sendai.jp",
  "!city.yokohama.jp",
  "aisai.aichi.jp",
  "ama.aichi.jp",
  "anjo.aichi.jp",
  "asuke.aichi.jp",
  "chiryu.aichi.jp",
  "chita.aichi.jp",
  "fuso.aichi.jp",
  "gamagori.aichi.jp",
  "handa.aichi.jp",
  "hazu.aichi.jp",
  "hekinan.aichi.jp",
  "higashiura.aichi.jp",
  "ichinomiya.aichi.jp",
  "inazawa.aichi.jp",
  "inuyama.aichi.jp",
  "isshiki.aichi.jp",
  "iwakura.aichi.jp",
  "kanie.aichi.jp",
  "kariya.aichi.jp",
  "kasugai.aichi.jp",
  "kira.aichi.jp",
  "kiyosu.aichi.jp",
  "komaki.aichi.jp",
  "konan.aichi.jp",
  "kota.aichi.jp",
  "mihama.aichi.jp",
  "miyoshi.aichi.jp",
  "nishio.aichi.jp",
  "nisshin.aichi.jp",
  "obu.aichi.jp",
  "oguchi.aichi.jp",
  "oharu.aichi.jp",
  "okazaki.aichi.jp",
  "owariasahi.aichi.jp",
  "seto.aichi.jp",
  "shikatsu.aichi.jp",
  "shinshiro.aichi.jp",
  "shitara.aichi.jp",
  "tahara.aichi.jp",
  "takahama.aichi.jp",
  "tobishima.aichi.jp",
  "toei.aichi.jp",
  "togo.aichi.jp",
  "tokai.aichi.jp",
  "tokoname.aichi.jp",
  "toyoake.aichi.jp",
  "toyohashi.aichi.jp",
  "toyokawa.aichi.jp",
  "toyone.aichi.jp",
  "toyota.aichi.jp",
  "tsushima.aichi.jp",
  "yatomi.aichi.jp",
  "akita.akita.jp",
  "daisen.akita.jp",
  "fujisato.akita.jp",
  "gojome.akita.jp",
  "hachirogata.akita.jp",
  "happou.akita.jp",
  "higashinaruse.akita.jp",
  "honjo.akita.jp",
  "honjyo.akita.jp",
  "ikawa.akita.jp",
  "kamikoani.akita.jp",
  "kamioka.akita.jp",
  "katagami.akita.jp",
  "kazuno.akita.jp",
  "kitaakita.akita.jp",
  "kosaka.akita.jp",
  "kyowa.akita.jp",
  "misato.akita.jp",
  "mitane.akita.jp",
  "moriyoshi.akita.jp",
  "nikaho.akita.jp",
  "noshiro.akita.jp",
  "odate.akita.jp",
  "oga.akita.jp",
  "ogata.akita.jp",
  "semboku.akita.jp",
  "yokote.akita.jp",
  "yurihonjo.akita.jp",
  "aomori.aomori.jp",
  "gonohe.aomori.jp",
  "hachinohe.aomori.jp",
  "hashikami.aomori.jp",
  "hiranai.aomori.jp",
  "hirosaki.aomori.jp",
  "itayanagi.aomori.jp",
  "kuroishi.aomori.jp",
  "misawa.aomori.jp",
  "mutsu.aomori.jp",
  "nakadomari.aomori.jp",
  "noheji.aomori.jp",
  "oirase.aomori.jp",
  "owani.aomori.jp",
  "rokunohe.aomori.jp",
  "sannohe.aomori.jp",
  "shichinohe.aomori.jp",
  "shingo.aomori.jp",
  "takko.aomori.jp",
  "towada.aomori.jp",
  "tsugaru.aomori.jp",
  "tsuruta.aomori.jp",
  "abiko.chiba.jp",
  "asahi.chiba.jp",
  "chonan.chiba.jp",
  "chosei.chiba.jp",
  "choshi.chiba.jp",
  "chuo.chiba.jp",
  "funabashi.chiba.jp",
  "futtsu.chiba.jp",
  "hanamigawa.chiba.jp",
  "ichihara.chiba.jp",
  "ichikawa.chiba.jp",
  "ichinomiya.chiba.jp",
  "inzai.chiba.jp",
  "isumi.chiba.jp",
  "kamagaya.chiba.jp",
  "kamogawa.chiba.jp",
  "kashiwa.chiba.jp",
  "katori.chiba.jp",
  "katsuura.chiba.jp",
  "kimitsu.chiba.jp",
  "kisarazu.chiba.jp",
  "kozaki.chiba.jp",
  "kujukuri.chiba.jp",
  "kyonan.chiba.jp",
  "matsudo.chiba.jp",
  "midori.chiba.jp",
  "mihama.chiba.jp",
  "minamiboso.chiba.jp",
  "mobara.chiba.jp",
  "mutsuzawa.chiba.jp",
  "nagara.chiba.jp",
  "nagareyama.chiba.jp",
  "narashino.chiba.jp",
  "narita.chiba.jp",
  "noda.chiba.jp",
  "oamishirasato.chiba.jp",
  "omigawa.chiba.jp",
  "onjuku.chiba.jp",
  "otaki.chiba.jp",
  "sakae.chiba.jp",
  "sakura.chiba.jp",
  "shimofusa.chiba.jp",
  "shirako.chiba.jp",
  "shiroi.chiba.jp",
  "shisui.chiba.jp",
  "sodegaura.chiba.jp",
  "sosa.chiba.jp",
  "tako.chiba.jp",
  "tateyama.chiba.jp",
  "togane.chiba.jp",
  "tohnosho.chiba.jp",
  "tomisato.chiba.jp",
  "urayasu.chiba.jp",
  "yachimata.chiba.jp",
  "yachiyo.chiba.jp",
  "yokaichiba.chiba.jp",
  "yokoshibahikari.chiba.jp",
  "yotsukaido.chiba.jp",
  "ainan.ehime.jp",
  "honai.ehime.jp",
  "ikata.ehime.jp",
  "imabari.ehime.jp",
  "iyo.ehime.jp",
  "kamijima.ehime.jp",
  "kihoku.ehime.jp",
  "kumakogen.ehime.jp",
  "masaki.ehime.jp",
  "matsuno.ehime.jp",
  "matsuyama.ehime.jp",
  "namikata.ehime.jp",
  "niihama.ehime.jp",
  "ozu.ehime.jp",
  "saijo.ehime.jp",
  "seiyo.ehime.jp",
  "shikokuchuo.ehime.jp",
  "tobe.ehime.jp",
  "toon.ehime.jp",
  "uchiko.ehime.jp",
  "uwajima.ehime.jp",
  "yawatahama.ehime.jp",
  "echizen.fukui.jp",
  "eiheiji.fukui.jp",
  "fukui.fukui.jp",
  "ikeda.fukui.jp",
  "katsuyama.fukui.jp",
  "mihama.fukui.jp",
  "minamiechizen.fukui.jp",
  "obama.fukui.jp",
  "ohi.fukui.jp",
  "ono.fukui.jp",
  "sabae.fukui.jp",
  "sakai.fukui.jp",
  "takahama.fukui.jp",
  "tsuruga.fukui.jp",
  "wakasa.fukui.jp",
  "ashiya.fukuoka.jp",
  "buzen.fukuoka.jp",
  "chikugo.fukuoka.jp",
  "chikuho.fukuoka.jp",
  "chikujo.fukuoka.jp",
  "chikushino.fukuoka.jp",
  "chikuzen.fukuoka.jp",
  "chuo.fukuoka.jp",
  "dazaifu.fukuoka.jp",
  "fukuchi.fukuoka.jp",
  "hakata.fukuoka.jp",
  "higashi.fukuoka.jp",
  "hirokawa.fukuoka.jp",
  "hisayama.fukuoka.jp",
  "iizuka.fukuoka.jp",
  "inatsuki.fukuoka.jp",
  "kaho.fukuoka.jp",
  "kasuga.fukuoka.jp",
  "kasuya.fukuoka.jp",
  "kawara.fukuoka.jp",
  "keisen.fukuoka.jp",
  "koga.fukuoka.jp",
  "kurate.fukuoka.jp",
  "kurogi.fukuoka.jp",
  "kurume.fukuoka.jp",
  "minami.fukuoka.jp",
  "miyako.fukuoka.jp",
  "miyama.fukuoka.jp",
  "miyawaka.fukuoka.jp",
  "mizumaki.fukuoka.jp",
  "munakata.fukuoka.jp",
  "nakagawa.fukuoka.jp",
  "nakama.fukuoka.jp",
  "nishi.fukuoka.jp",
  "nogata.fukuoka.jp",
  "ogori.fukuoka.jp",
  "okagaki.fukuoka.jp",
  "okawa.fukuoka.jp",
  "oki.fukuoka.jp",
  "omuta.fukuoka.jp",
  "onga.fukuoka.jp",
  "onojo.fukuoka.jp",
  "oto.fukuoka.jp",
  "saigawa.fukuoka.jp",
  "sasaguri.fukuoka.jp",
  "shingu.fukuoka.jp",
  "shinyoshitomi.fukuoka.jp",
  "shonai.fukuoka.jp",
  "soeda.fukuoka.jp",
  "sue.fukuoka.jp",
  "tachiarai.fukuoka.jp",
  "tagawa.fukuoka.jp",
  "takata.fukuoka.jp",
  "toho.fukuoka.jp",
  "toyotsu.fukuoka.jp",
  "tsuiki.fukuoka.jp",
  "ukiha.fukuoka.jp",
  "umi.fukuoka.jp",
  "usui.fukuoka.jp",
  "yamada.fukuoka.jp",
  "yame.fukuoka.jp",
  "yanagawa.fukuoka.jp",
  "yukuhashi.fukuoka.jp",
  "aizubange.fukushima.jp",
  "aizumisato.fukushima.jp",
  "aizuwakamatsu.fukushima.jp",
  "asakawa.fukushima.jp",
  "bandai.fukushima.jp",
  "date.fukushima.jp",
  "fukushima.fukushima.jp",
  "furudono.fukushima.jp",
  "futaba.fukushima.jp",
  "hanawa.fukushima.jp",
  "higashi.fukushima.jp",
  "hirata.fukushima.jp",
  "hirono.fukushima.jp",
  "iitate.fukushima.jp",
  "inawashiro.fukushima.jp",
  "ishikawa.fukushima.jp",
  "iwaki.fukushima.jp",
  "izumizaki.fukushima.jp",
  "kagamiishi.fukushima.jp",
  "kaneyama.fukushima.jp",
  "kawamata.fukushima.jp",
  "kitakata.fukushima.jp",
  "kitashiobara.fukushima.jp",
  "koori.fukushima.jp",
  "koriyama.fukushima.jp",
  "kunimi.fukushima.jp",
  "miharu.fukushima.jp",
  "mishima.fukushima.jp",
  "namie.fukushima.jp",
  "nango.fukushima.jp",
  "nishiaizu.fukushima.jp",
  "nishigo.fukushima.jp",
  "okuma.fukushima.jp",
  "omotego.fukushima.jp",
  "ono.fukushima.jp",
  "otama.fukushima.jp",
  "samegawa.fukushima.jp",
  "shimogo.fukushima.jp",
  "shirakawa.fukushima.jp",
  "showa.fukushima.jp",
  "soma.fukushima.jp",
  "sukagawa.fukushima.jp",
  "taishin.fukushima.jp",
  "tamakawa.fukushima.jp",
  "tanagura.fukushima.jp",
  "tenei.fukushima.jp",
  "yabuki.fukushima.jp",
  "yamato.fukushima.jp",
  "yamatsuri.fukushima.jp",
  "yanaizu.fukushima.jp",
  "yugawa.fukushima.jp",
  "anpachi.gifu.jp",
  "ena.gifu.jp",
  "gifu.gifu.jp",
  "ginan.gifu.jp",
  "godo.gifu.jp",
  "gujo.gifu.jp",
  "hashima.gifu.jp",
  "hichiso.gifu.jp",
  "hida.gifu.jp",
  "higashishirakawa.gifu.jp",
  "ibigawa.gifu.jp",
  "ikeda.gifu.jp",
  "kakamigahara.gifu.jp",
  "kani.gifu.jp",
  "kasahara.gifu.jp",
  "kasamatsu.gifu.jp",
  "kawaue.gifu.jp",
  "kitagata.gifu.jp",
  "mino.gifu.jp",
  "minokamo.gifu.jp",
  "mitake.gifu.jp",
  "mizunami.gifu.jp",
  "motosu.gifu.jp",
  "nakatsugawa.gifu.jp",
  "ogaki.gifu.jp",
  "sakahogi.gifu.jp",
  "seki.gifu.jp",
  "sekigahara.gifu.jp",
  "shirakawa.gifu.jp",
  "tajimi.gifu.jp",
  "takayama.gifu.jp",
  "tarui.gifu.jp",
  "toki.gifu.jp",
  "tomika.gifu.jp",
  "wanouchi.gifu.jp",
  "yamagata.gifu.jp",
  "yaotsu.gifu.jp",
  "yoro.gifu.jp",
  "annaka.gunma.jp",
  "chiyoda.gunma.jp",
  "fujioka.gunma.jp",
  "higashiagatsuma.gunma.jp",
  "isesaki.gunma.jp",
  "itakura.gunma.jp",
  "kanna.gunma.jp",
  "kanra.gunma.jp",
  "katashina.gunma.jp",
  "kawaba.gunma.jp",
  "kiryu.gunma.jp",
  "kusatsu.gunma.jp",
  "maebashi.gunma.jp",
  "meiwa.gunma.jp",
  "midori.gunma.jp",
  "minakami.gunma.jp",
  "naganohara.gunma.jp",
  "nakanojo.gunma.jp",
  "nanmoku.gunma.jp",
  "numata.gunma.jp",
  "oizumi.gunma.jp",
  "ora.gunma.jp",
  "ota.gunma.jp",
  "shibukawa.gunma.jp",
  "shimonita.gunma.jp",
  "shinto.gunma.jp",
  "showa.gunma.jp",
  "takasaki.gunma.jp",
  "takayama.gunma.jp",
  "tamamura.gunma.jp",
  "tatebayashi.gunma.jp",
  "tomioka.gunma.jp",
  "tsukiyono.gunma.jp",
  "tsumagoi.gunma.jp",
  "ueno.gunma.jp",
  "yoshioka.gunma.jp",
  "asaminami.hiroshima.jp",
  "daiwa.hiroshima.jp",
  "etajima.hiroshima.jp",
  "fuchu.hiroshima.jp",
  "fukuyama.hiroshima.jp",
  "hatsukaichi.hiroshima.jp",
  "higashihiroshima.hiroshima.jp",
  "hongo.hiroshima.jp",
  "jinsekikogen.hiroshima.jp",
  "kaita.hiroshima.jp",
  "kui.hiroshima.jp",
  "kumano.hiroshima.jp",
  "kure.hiroshima.jp",
  "mihara.hiroshima.jp",
  "miyoshi.hiroshima.jp",
  "naka.hiroshima.jp",
  "onomichi.hiroshima.jp",
  "osakikamijima.hiroshima.jp",
  "otake.hiroshima.jp",
  "saka.hiroshima.jp",
  "sera.hiroshima.jp",
  "seranishi.hiroshima.jp",
  "shinichi.hiroshima.jp",
  "shobara.hiroshima.jp",
  "takehara.hiroshima.jp",
  "abashiri.hokkaido.jp",
  "abira.hokkaido.jp",
  "aibetsu.hokkaido.jp",
  "akabira.hokkaido.jp",
  "akkeshi.hokkaido.jp",
  "asahikawa.hokkaido.jp",
  "ashibetsu.hokkaido.jp",
  "ashoro.hokkaido.jp",
  "assabu.hokkaido.jp",
  "atsuma.hokkaido.jp",
  "bibai.hokkaido.jp",
  "biei.hokkaido.jp",
  "bifuka.hokkaido.jp",
  "bihoro.hokkaido.jp",
  "biratori.hokkaido.jp",
  "chippubetsu.hokkaido.jp",
  "chitose.hokkaido.jp",
  "date.hokkaido.jp",
  "ebetsu.hokkaido.jp",
  "embetsu.hokkaido.jp",
  "eniwa.hokkaido.jp",
  "erimo.hokkaido.jp",
  "esan.hokkaido.jp",
  "esashi.hokkaido.jp",
  "fukagawa.hokkaido.jp",
  "fukushima.hokkaido.jp",
  "furano.hokkaido.jp",
  "furubira.hokkaido.jp",
  "haboro.hokkaido.jp",
  "hakodate.hokkaido.jp",
  "hamatonbetsu.hokkaido.jp",
  "hidaka.hokkaido.jp",
  "higashikagura.hokkaido.jp",
  "higashikawa.hokkaido.jp",
  "hiroo.hokkaido.jp",
  "hokuryu.hokkaido.jp",
  "hokuto.hokkaido.jp",
  "honbetsu.hokkaido.jp",
  "horokanai.hokkaido.jp",
  "horonobe.hokkaido.jp",
  "ikeda.hokkaido.jp",
  "imakane.hokkaido.jp",
  "ishikari.hokkaido.jp",
  "iwamizawa.hokkaido.jp",
  "iwanai.hokkaido.jp",
  "kamifurano.hokkaido.jp",
  "kamikawa.hokkaido.jp",
  "kamishihoro.hokkaido.jp",
  "kamisunagawa.hokkaido.jp",
  "kamoenai.hokkaido.jp",
  "kayabe.hokkaido.jp",
  "kembuchi.hokkaido.jp",
  "kikonai.hokkaido.jp",
  "kimobetsu.hokkaido.jp",
  "kitahiroshima.hokkaido.jp",
  "kitami.hokkaido.jp",
  "kiyosato.hokkaido.jp",
  "koshimizu.hokkaido.jp",
  "kunneppu.hokkaido.jp",
  "kuriyama.hokkaido.jp",
  "kuromatsunai.hokkaido.jp",
  "kushiro.hokkaido.jp",
  "kutchan.hokkaido.jp",
  "kyowa.hokkaido.jp",
  "mashike.hokkaido.jp",
  "matsumae.hokkaido.jp",
  "mikasa.hokkaido.jp",
  "minamifurano.hokkaido.jp",
  "mombetsu.hokkaido.jp",
  "moseushi.hokkaido.jp",
  "mukawa.hokkaido.jp",
  "muroran.hokkaido.jp",
  "naie.hokkaido.jp",
  "nakagawa.hokkaido.jp",
  "nakasatsunai.hokkaido.jp",
  "nakatombetsu.hokkaido.jp",
  "nanae.hokkaido.jp",
  "nanporo.hokkaido.jp",
  "nayoro.hokkaido.jp",
  "nemuro.hokkaido.jp",
  "niikappu.hokkaido.jp",
  "niki.hokkaido.jp",
  "nishiokoppe.hokkaido.jp",
  "noboribetsu.hokkaido.jp",
  "numata.hokkaido.jp",
  "obihiro.hokkaido.jp",
  "obira.hokkaido.jp",
  "oketo.hokkaido.jp",
  "okoppe.hokkaido.jp",
  "otaru.hokkaido.jp",
  "otobe.hokkaido.jp",
  "otofuke.hokkaido.jp",
  "otoineppu.hokkaido.jp",
  "oumu.hokkaido.jp",
  "ozora.hokkaido.jp",
  "pippu.hokkaido.jp",
  "rankoshi.hokkaido.jp",
  "rebun.hokkaido.jp",
  "rikubetsu.hokkaido.jp",
  "rishiri.hokkaido.jp",
  "rishirifuji.hokkaido.jp",
  "saroma.hokkaido.jp",
  "sarufutsu.hokkaido.jp",
  "shakotan.hokkaido.jp",
  "shari.hokkaido.jp",
  "shibecha.hokkaido.jp",
  "shibetsu.hokkaido.jp",
  "shikabe.hokkaido.jp",
  "shikaoi.hokkaido.jp",
  "shimamaki.hokkaido.jp",
  "shimizu.hokkaido.jp",
  "shimokawa.hokkaido.jp",
  "shinshinotsu.hokkaido.jp",
  "shintoku.hokkaido.jp",
  "shiranuka.hokkaido.jp",
  "shiraoi.hokkaido.jp",
  "shiriuchi.hokkaido.jp",
  "sobetsu.hokkaido.jp",
  "sunagawa.hokkaido.jp",
  "taiki.hokkaido.jp",
  "takasu.hokkaido.jp",
  "takikawa.hokkaido.jp",
  "takinoue.hokkaido.jp",
  "teshikaga.hokkaido.jp",
  "tobetsu.hokkaido.jp",
  "tohma.hokkaido.jp",
  "tomakomai.hokkaido.jp",
  "tomari.hokkaido.jp",
  "toya.hokkaido.jp",
  "toyako.hokkaido.jp",
  "toyotomi.hokkaido.jp",
  "toyoura.hokkaido.jp",
  "tsubetsu.hokkaido.jp",
  "tsukigata.hokkaido.jp",
  "urakawa.hokkaido.jp",
  "urausu.hokkaido.jp",
  "uryu.hokkaido.jp",
  "utashinai.hokkaido.jp",
  "wakkanai.hokkaido.jp",
  "wassamu.hokkaido.jp",
  "yakumo.hokkaido.jp",
  "yoichi.hokkaido.jp",
  "aioi.hyogo.jp",
  "akashi.hyogo.jp",
  "ako.hyogo.jp",
  "amagasaki.hyogo.jp",
  "aogaki.hyogo.jp",
  "asago.hyogo.jp",
  "ashiya.hyogo.jp",
  "awaji.hyogo.jp",
  "fukusaki.hyogo.jp",
  "goshiki.hyogo.jp",
  "harima.hyogo.jp",
  "himeji.hyogo.jp",
  "ichikawa.hyogo.jp",
  "inagawa.hyogo.jp",
  "itami.hyogo.jp",
  "kakogawa.hyogo.jp",
  "kamigori.hyogo.jp",
  "kamikawa.hyogo.jp",
  "kasai.hyogo.jp",
  "kasuga.hyogo.jp",
  "kawanishi.hyogo.jp",
  "miki.hyogo.jp",
  "minamiawaji.hyogo.jp",
  "nishinomiya.hyogo.jp",
  "nishiwaki.hyogo.jp",
  "ono.hyogo.jp",
  "sanda.hyogo.jp",
  "sannan.hyogo.jp",
  "sasayama.hyogo.jp",
  "sayo.hyogo.jp",
  "shingu.hyogo.jp",
  "shinonsen.hyogo.jp",
  "shiso.hyogo.jp",
  "sumoto.hyogo.jp",
  "taishi.hyogo.jp",
  "taka.hyogo.jp",
  "takarazuka.hyogo.jp",
  "takasago.hyogo.jp",
  "takino.hyogo.jp",
  "tamba.hyogo.jp",
  "tatsuno.hyogo.jp",
  "toyooka.hyogo.jp",
  "yabu.hyogo.jp",
  "yashiro.hyogo.jp",
  "yoka.hyogo.jp",
  "yokawa.hyogo.jp",
  "ami.ibaraki.jp",
  "asahi.ibaraki.jp",
  "bando.ibaraki.jp",
  "chikusei.ibaraki.jp",
  "daigo.ibaraki.jp",
  "fujishiro.ibaraki.jp",
  "hitachi.ibaraki.jp",
  "hitachinaka.ibaraki.jp",
  "hitachiomiya.ibaraki.jp",
  "hitachiota.ibaraki.jp",
  "ibaraki.ibaraki.jp",
  "ina.ibaraki.jp",
  "inashiki.ibaraki.jp",
  "itako.ibaraki.jp",
  "iwama.ibaraki.jp",
  "joso.ibaraki.jp",
  "kamisu.ibaraki.jp",
  "kasama.ibaraki.jp",
  "kashima.ibaraki.jp",
  "kasumigaura.ibaraki.jp",
  "koga.ibaraki.jp",
  "miho.ibaraki.jp",
  "mito.ibaraki.jp",
  "moriya.ibaraki.jp",
  "naka.ibaraki.jp",
  "namegata.ibaraki.jp",
  "oarai.ibaraki.jp",
  "ogawa.ibaraki.jp",
  "omitama.ibaraki.jp",
  "ryugasaki.ibaraki.jp",
  "sakai.ibaraki.jp",
  "sakuragawa.ibaraki.jp",
  "shimodate.ibaraki.jp",
  "shimotsuma.ibaraki.jp",
  "shirosato.ibaraki.jp",
  "sowa.ibaraki.jp",
  "suifu.ibaraki.jp",
  "takahagi.ibaraki.jp",
  "tamatsukuri.ibaraki.jp",
  "tokai.ibaraki.jp",
  "tomobe.ibaraki.jp",
  "tone.ibaraki.jp",
  "toride.ibaraki.jp",
  "tsuchiura.ibaraki.jp",
  "tsukuba.ibaraki.jp",
  "uchihara.ibaraki.jp",
  "ushiku.ibaraki.jp",
  "yachiyo.ibaraki.jp",
  "yamagata.ibaraki.jp",
  "yawara.ibaraki.jp",
  "yuki.ibaraki.jp",
  "anamizu.ishikawa.jp",
  "hakui.ishikawa.jp",
  "hakusan.ishikawa.jp",
  "kaga.ishikawa.jp",
  "kahoku.ishikawa.jp",
  "kanazawa.ishikawa.jp",
  "kawakita.ishikawa.jp",
  "komatsu.ishikawa.jp",
  "nakanoto.ishikawa.jp",
  "nanao.ishikawa.jp",
  "nomi.ishikawa.jp",
  "nonoichi.ishikawa.jp",
  "noto.ishikawa.jp",
  "shika.ishikawa.jp",
  "suzu.ishikawa.jp",
  "tsubata.ishikawa.jp",
  "tsurugi.ishikawa.jp",
  "uchinada.ishikawa.jp",
  "wajima.ishikawa.jp",
  "fudai.iwate.jp",
  "fujisawa.iwate.jp",
  "hanamaki.iwate.jp",
  "hiraizumi.iwate.jp",
  "hirono.iwate.jp",
  "ichinohe.iwate.jp",
  "ichinoseki.iwate.jp",
  "iwaizumi.iwate.jp",
  "iwate.iwate.jp",
  "joboji.iwate.jp",
  "kamaishi.iwate.jp",
  "kanegasaki.iwate.jp",
  "karumai.iwate.jp",
  "kawai.iwate.jp",
  "kitakami.iwate.jp",
  "kuji.iwate.jp",
  "kunohe.iwate.jp",
  "kuzumaki.iwate.jp",
  "miyako.iwate.jp",
  "mizusawa.iwate.jp",
  "morioka.iwate.jp",
  "ninohe.iwate.jp",
  "noda.iwate.jp",
  "ofunato.iwate.jp",
  "oshu.iwate.jp",
  "otsuchi.iwate.jp",
  "rikuzentakata.iwate.jp",
  "shiwa.iwate.jp",
  "shizukuishi.iwate.jp",
  "sumita.iwate.jp",
  "tanohata.iwate.jp",
  "tono.iwate.jp",
  "yahaba.iwate.jp",
  "yamada.iwate.jp",
  "ayagawa.kagawa.jp",
  "higashikagawa.kagawa.jp",
  "kanonji.kagawa.jp",
  "kotohira.kagawa.jp",
  "manno.kagawa.jp",
  "marugame.kagawa.jp",
  "mitoyo.kagawa.jp",
  "naoshima.kagawa.jp",
  "sanuki.kagawa.jp",
  "tadotsu.kagawa.jp",
  "takamatsu.kagawa.jp",
  "tonosho.kagawa.jp",
  "uchinomi.kagawa.jp",
  "utazu.kagawa.jp",
  "zentsuji.kagawa.jp",
  "akune.kagoshima.jp",
  "amami.kagoshima.jp",
  "hioki.kagoshima.jp",
  "isa.kagoshima.jp",
  "isen.kagoshima.jp",
  "izumi.kagoshima.jp",
  "kagoshima.kagoshima.jp",
  "kanoya.kagoshima.jp",
  "kawanabe.kagoshima.jp",
  "kinko.kagoshima.jp",
  "kouyama.kagoshima.jp",
  "makurazaki.kagoshima.jp",
  "matsumoto.kagoshima.jp",
  "minamitane.kagoshima.jp",
  "nakatane.kagoshima.jp",
  "nishinoomote.kagoshima.jp",
  "satsumasendai.kagoshima.jp",
  "soo.kagoshima.jp",
  "tarumizu.kagoshima.jp",
  "yusui.kagoshima.jp",
  "aikawa.kanagawa.jp",
  "atsugi.kanagawa.jp",
  "ayase.kanagawa.jp",
  "chigasaki.kanagawa.jp",
  "ebina.kanagawa.jp",
  "fujisawa.kanagawa.jp",
  "hadano.kanagawa.jp",
  "hakone.kanagawa.jp",
  "hiratsuka.kanagawa.jp",
  "isehara.kanagawa.jp",
  "kaisei.kanagawa.jp",
  "kamakura.kanagawa.jp",
  "kiyokawa.kanagawa.jp",
  "matsuda.kanagawa.jp",
  "minamiashigara.kanagawa.jp",
  "miura.kanagawa.jp",
  "nakai.kanagawa.jp",
  "ninomiya.kanagawa.jp",
  "odawara.kanagawa.jp",
  "oi.kanagawa.jp",
  "oiso.kanagawa.jp",
  "sagamihara.kanagawa.jp",
  "samukawa.kanagawa.jp",
  "tsukui.kanagawa.jp",
  "yamakita.kanagawa.jp",
  "yamato.kanagawa.jp",
  "yokosuka.kanagawa.jp",
  "yugawara.kanagawa.jp",
  "zama.kanagawa.jp",
  "zushi.kanagawa.jp",
  "aki.kochi.jp",
  "geisei.kochi.jp",
  "hidaka.kochi.jp",
  "higashitsuno.kochi.jp",
  "ino.kochi.jp",
  "kagami.kochi.jp",
  "kami.kochi.jp",
  "kitagawa.kochi.jp",
  "kochi.kochi.jp",
  "mihara.kochi.jp",
  "motoyama.kochi.jp",
  "muroto.kochi.jp",
  "nahari.kochi.jp",
  "nakamura.kochi.jp",
  "nankoku.kochi.jp",
  "nishitosa.kochi.jp",
  "niyodogawa.kochi.jp",
  "ochi.kochi.jp",
  "okawa.kochi.jp",
  "otoyo.kochi.jp",
  "otsuki.kochi.jp",
  "sakawa.kochi.jp",
  "sukumo.kochi.jp",
  "susaki.kochi.jp",
  "tosa.kochi.jp",
  "tosashimizu.kochi.jp",
  "toyo.kochi.jp",
  "tsuno.kochi.jp",
  "umaji.kochi.jp",
  "yasuda.kochi.jp",
  "yusuhara.kochi.jp",
  "amakusa.kumamoto.jp",
  "arao.kumamoto.jp",
  "aso.kumamoto.jp",
  "choyo.kumamoto.jp",
  "gyokuto.kumamoto.jp",
  "kamiamakusa.kumamoto.jp",
  "kikuchi.kumamoto.jp",
  "kumamoto.kumamoto.jp",
  "mashiki.kumamoto.jp",
  "mifune.kumamoto.jp",
  "minamata.kumamoto.jp",
  "minamioguni.kumamoto.jp",
  "nagasu.kumamoto.jp",
  "nishihara.kumamoto.jp",
  "oguni.kumamoto.jp",
  "ozu.kumamoto.jp",
  "sumoto.kumamoto.jp",
  "takamori.kumamoto.jp",
  "uki.kumamoto.jp",
  "uto.kumamoto.jp",
  "yamaga.kumamoto.jp",
  "yamato.kumamoto.jp",
  "yatsushiro.kumamoto.jp",
  "ayabe.kyoto.jp",
  "fukuchiyama.kyoto.jp",
  "higashiyama.kyoto.jp",
  "ide.kyoto.jp",
  "ine.kyoto.jp",
  "joyo.kyoto.jp",
  "kameoka.kyoto.jp",
  "kamo.kyoto.jp",
  "kita.kyoto.jp",
  "kizu.kyoto.jp",
  "kumiyama.kyoto.jp",
  "kyotamba.kyoto.jp",
  "kyotanabe.kyoto.jp",
  "kyotango.kyoto.jp",
  "maizuru.kyoto.jp",
  "minami.kyoto.jp",
  "minamiyamashiro.kyoto.jp",
  "miyazu.kyoto.jp",
  "muko.kyoto.jp",
  "nagaokakyo.kyoto.jp",
  "nakagyo.kyoto.jp",
  "nantan.kyoto.jp",
  "oyamazaki.kyoto.jp",
  "sakyo.kyoto.jp",
  "seika.kyoto.jp",
  "tanabe.kyoto.jp",
  "uji.kyoto.jp",
  "ujitawara.kyoto.jp",
  "wazuka.kyoto.jp",
  "yamashina.kyoto.jp",
  "yawata.kyoto.jp",
  "asahi.mie.jp",
  "inabe.mie.jp",
  "ise.mie.jp",
  "kameyama.mie.jp",
  "kawagoe.mie.jp",
  "kiho.mie.jp",
  "kisosaki.mie.jp",
  "kiwa.mie.jp",
  "komono.mie.jp",
  "kumano.mie.jp",
  "kuwana.mie.jp",
  "matsusaka.mie.jp",
  "meiwa.mie.jp",
  "mihama.mie.jp",
  "minamiise.mie.jp",
  "misugi.mie.jp",
  "miyama.mie.jp",
  "nabari.mie.jp",
  "shima.mie.jp",
  "suzuka.mie.jp",
  "tado.mie.jp",
  "taiki.mie.jp",
  "taki.mie.jp",
  "tamaki.mie.jp",
  "toba.mie.jp",
  "tsu.mie.jp",
  "udono.mie.jp",
  "ureshino.mie.jp",
  "watarai.mie.jp",
  "yokkaichi.mie.jp",
  "furukawa.miyagi.jp",
  "higashimatsushima.miyagi.jp",
  "ishinomaki.miyagi.jp",
  "iwanuma.miyagi.jp",
  "kakuda.miyagi.jp",
  "kami.miyagi.jp",
  "kawasaki.miyagi.jp",
  "marumori.miyagi.jp",
  "matsushima.miyagi.jp",
  "minamisanriku.miyagi.jp",
  "misato.miyagi.jp",
  "murata.miyagi.jp",
  "natori.miyagi.jp",
  "ogawara.miyagi.jp",
  "ohira.miyagi.jp",
  "onagawa.miyagi.jp",
  "osaki.miyagi.jp",
  "rifu.miyagi.jp",
  "semine.miyagi.jp",
  "shibata.miyagi.jp",
  "shichikashuku.miyagi.jp",
  "shikama.miyagi.jp",
  "shiogama.miyagi.jp",
  "shiroishi.miyagi.jp",
  "tagajo.miyagi.jp",
  "taiwa.miyagi.jp",
  "tome.miyagi.jp",
  "tomiya.miyagi.jp",
  "wakuya.miyagi.jp",
  "watari.miyagi.jp",
  "yamamoto.miyagi.jp",
  "zao.miyagi.jp",
  "aya.miyazaki.jp",
  "ebino.miyazaki.jp",
  "gokase.miyazaki.jp",
  "hyuga.miyazaki.jp",
  "kadogawa.miyazaki.jp",
  "kawaminami.miyazaki.jp",
  "kijo.miyazaki.jp",
  "kitagawa.miyazaki.jp",
  "kitakata.miyazaki.jp",
  "kitaura.miyazaki.jp",
  "kobayashi.miyazaki.jp",
  "kunitomi.miyazaki.jp",
  "kushima.miyazaki.jp",
  "mimata.miyazaki.jp",
  "miyakonojo.miyazaki.jp",
  "miyazaki.miyazaki.jp",
  "morotsuka.miyazaki.jp",
  "nichinan.miyazaki.jp",
  "nishimera.miyazaki.jp",
  "nobeoka.miyazaki.jp",
  "saito.miyazaki.jp",
  "shiiba.miyazaki.jp",
  "shintomi.miyazaki.jp",
  "takaharu.miyazaki.jp",
  "takanabe.miyazaki.jp",
  "takazaki.miyazaki.jp",
  "tsuno.miyazaki.jp",
  "achi.nagano.jp",
  "agematsu.nagano.jp",
  "anan.nagano.jp",
  "aoki.nagano.jp",
  "asahi.nagano.jp",
  "azumino.nagano.jp",
  "chikuhoku.nagano.jp",
  "chikuma.nagano.jp",
  "chino.nagano.jp",
  "fujimi.nagano.jp",
  "hakuba.nagano.jp",
  "hara.nagano.jp",
  "hiraya.nagano.jp",
  "iida.nagano.jp",
  "iijima.nagano.jp",
  "iiyama.nagano.jp",
  "iizuna.nagano.jp",
  "ikeda.nagano.jp",
  "ikusaka.nagano.jp",
  "ina.nagano.jp",
  "karuizawa.nagano.jp",
  "kawakami.nagano.jp",
  "kiso.nagano.jp",
  "kisofukushima.nagano.jp",
  "kitaaiki.nagano.jp",
  "komagane.nagano.jp",
  "komoro.nagano.jp",
  "matsukawa.nagano.jp",
  "matsumoto.nagano.jp",
  "miasa.nagano.jp",
  "minamiaiki.nagano.jp",
  "minamimaki.nagano.jp",
  "minamiminowa.nagano.jp",
  "minowa.nagano.jp",
  "miyada.nagano.jp",
  "miyota.nagano.jp",
  "mochizuki.nagano.jp",
  "nagano.nagano.jp",
  "nagawa.nagano.jp",
  "nagiso.nagano.jp",
  "nakagawa.nagano.jp",
  "nakano.nagano.jp",
  "nozawaonsen.nagano.jp",
  "obuse.nagano.jp",
  "ogawa.nagano.jp",
  "okaya.nagano.jp",
  "omachi.nagano.jp",
  "omi.nagano.jp",
  "ookuwa.nagano.jp",
  "ooshika.nagano.jp",
  "otaki.nagano.jp",
  "otari.nagano.jp",
  "sakae.nagano.jp",
  "sakaki.nagano.jp",
  "saku.nagano.jp",
  "sakuho.nagano.jp",
  "shimosuwa.nagano.jp",
  "shinanomachi.nagano.jp",
  "shiojiri.nagano.jp",
  "suwa.nagano.jp",
  "suzaka.nagano.jp",
  "takagi.nagano.jp",
  "takamori.nagano.jp",
  "takayama.nagano.jp",
  "tateshina.nagano.jp",
  "tatsuno.nagano.jp",
  "togakushi.nagano.jp",
  "togura.nagano.jp",
  "tomi.nagano.jp",
  "ueda.nagano.jp",
  "wada.nagano.jp",
  "yamagata.nagano.jp",
  "yamanouchi.nagano.jp",
  "yasaka.nagano.jp",
  "yasuoka.nagano.jp",
  "chijiwa.nagasaki.jp",
  "futsu.nagasaki.jp",
  "goto.nagasaki.jp",
  "hasami.nagasaki.jp",
  "hirado.nagasaki.jp",
  "iki.nagasaki.jp",
  "isahaya.nagasaki.jp",
  "kawatana.nagasaki.jp",
  "kuchinotsu.nagasaki.jp",
  "matsuura.nagasaki.jp",
  "nagasaki.nagasaki.jp",
  "obama.nagasaki.jp",
  "omura.nagasaki.jp",
  "oseto.nagasaki.jp",
  "saikai.nagasaki.jp",
  "sasebo.nagasaki.jp",
  "seihi.nagasaki.jp",
  "shimabara.nagasaki.jp",
  "shinkamigoto.nagasaki.jp",
  "togitsu.nagasaki.jp",
  "tsushima.nagasaki.jp",
  "unzen.nagasaki.jp",
  "ando.nara.jp",
  "gose.nara.jp",
  "heguri.nara.jp",
  "higashiyoshino.nara.jp",
  "ikaruga.nara.jp",
  "ikoma.nara.jp",
  "kamikitayama.nara.jp",
  "kanmaki.nara.jp",
  "kashiba.nara.jp",
  "kashihara.nara.jp",
  "katsuragi.nara.jp",
  "kawai.nara.jp",
  "kawakami.nara.jp",
  "kawanishi.nara.jp",
  "koryo.nara.jp",
  "kurotaki.nara.jp",
  "mitsue.nara.jp",
  "miyake.nara.jp",
  "nara.nara.jp",
  "nosegawa.nara.jp",
  "oji.nara.jp",
  "ouda.nara.jp",
  "oyodo.nara.jp",
  "sakurai.nara.jp",
  "sango.nara.jp",
  "shimoichi.nara.jp",
  "shimokitayama.nara.jp",
  "shinjo.nara.jp",
  "soni.nara.jp",
  "takatori.nara.jp",
  "tawaramoto.nara.jp",
  "tenkawa.nara.jp",
  "tenri.nara.jp",
  "uda.nara.jp",
  "yamatokoriyama.nara.jp",
  "yamatotakada.nara.jp",
  "yamazoe.nara.jp",
  "yoshino.nara.jp",
  "aga.niigata.jp",
  "agano.niigata.jp",
  "gosen.niigata.jp",
  "itoigawa.niigata.jp",
  "izumozaki.niigata.jp",
  "joetsu.niigata.jp",
  "kamo.niigata.jp",
  "kariwa.niigata.jp",
  "kashiwazaki.niigata.jp",
  "minamiuonuma.niigata.jp",
  "mitsuke.niigata.jp",
  "muika.niigata.jp",
  "murakami.niigata.jp",
  "myoko.niigata.jp",
  "nagaoka.niigata.jp",
  "niigata.niigata.jp",
  "ojiya.niigata.jp",
  "omi.niigata.jp",
  "sado.niigata.jp",
  "sanjo.niigata.jp",
  "seiro.niigata.jp",
  "seirou.niigata.jp",
  "sekikawa.niigata.jp",
  "shibata.niigata.jp",
  "tagami.niigata.jp",
  "tainai.niigata.jp",
  "tochio.niigata.jp",
  "tokamachi.niigata.jp",
  "tsubame.niigata.jp",
  "tsunan.niigata.jp",
  "uonuma.niigata.jp",
  "yahiko.niigata.jp",
  "yoita.niigata.jp",
  "yuzawa.niigata.jp",
  "beppu.oita.jp",
  "bungoono.oita.jp",
  "bungotakada.oita.jp",
  "hasama.oita.jp",
  "hiji.oita.jp",
  "himeshima.oita.jp",
  "hita.oita.jp",
  "kamitsue.oita.jp",
  "kokonoe.oita.jp",
  "kuju.oita.jp",
  "kunisaki.oita.jp",
  "kusu.oita.jp",
  "oita.oita.jp",
  "saiki.oita.jp",
  "taketa.oita.jp",
  "tsukumi.oita.jp",
  "usa.oita.jp",
  "usuki.oita.jp",
  "yufu.oita.jp",
  "akaiwa.okayama.jp",
  "asakuchi.okayama.jp",
  "bizen.okayama.jp",
  "hayashima.okayama.jp",
  "ibara.okayama.jp",
  "kagamino.okayama.jp",
  "kasaoka.okayama.jp",
  "kibichuo.okayama.jp",
  "kumenan.okayama.jp",
  "kurashiki.okayama.jp",
  "maniwa.okayama.jp",
  "misaki.okayama.jp",
  "nagi.okayama.jp",
  "niimi.okayama.jp",
  "nishiawakura.okayama.jp",
  "okayama.okayama.jp",
  "satosho.okayama.jp",
  "setouchi.okayama.jp",
  "shinjo.okayama.jp",
  "shoo.okayama.jp",
  "soja.okayama.jp",
  "takahashi.okayama.jp",
  "tamano.okayama.jp",
  "tsuyama.okayama.jp",
  "wake.okayama.jp",
  "yakage.okayama.jp",
  "aguni.okinawa.jp",
  "ginowan.okinawa.jp",
  "ginoza.okinawa.jp",
  "gushikami.okinawa.jp",
  "haebaru.okinawa.jp",
  "higashi.okinawa.jp",
  "hirara.okinawa.jp",
  "iheya.okinawa.jp",
  "ishigaki.okinawa.jp",
  "ishikawa.okinawa.jp",
  "itoman.okinawa.jp",
  "izena.okinawa.jp",
  "kadena.okinawa.jp",
  "kin.okinawa.jp",
  "kitadaito.okinawa.jp",
  "kitanakagusuku.okinawa.jp",
  "kumejima.okinawa.jp",
  "kunigami.okinawa.jp",
  "minamidaito.okinawa.jp",
  "motobu.okinawa.jp",
  "nago.okinawa.jp",
  "naha.okinawa.jp",
  "nakagusuku.okinawa.jp",
  "nakijin.okinawa.jp",
  "nanjo.okinawa.jp",
  "nishihara.okinawa.jp",
  "ogimi.okinawa.jp",
  "okinawa.okinawa.jp",
  "onna.okinawa.jp",
  "shimoji.okinawa.jp",
  "taketomi.okinawa.jp",
  "tarama.okinawa.jp",
  "tokashiki.okinawa.jp",
  "tomigusuku.okinawa.jp",
  "tonaki.okinawa.jp",
  "urasoe.okinawa.jp",
  "uruma.okinawa.jp",
  "yaese.okinawa.jp",
  "yomitan.okinawa.jp",
  "yonabaru.okinawa.jp",
  "yonaguni.okinawa.jp",
  "zamami.okinawa.jp",
  "abeno.osaka.jp",
  "chihayaakasaka.osaka.jp",
  "chuo.osaka.jp",
  "daito.osaka.jp",
  "fujiidera.osaka.jp",
  "habikino.osaka.jp",
  "hannan.osaka.jp",
  "higashiosaka.osaka.jp",
  "higashisumiyoshi.osaka.jp",
  "higashiyodogawa.osaka.jp",
  "hirakata.osaka.jp",
  "ibaraki.osaka.jp",
  "ikeda.osaka.jp",
  "izumi.osaka.jp",
  "izumiotsu.osaka.jp",
  "izumisano.osaka.jp",
  "kadoma.osaka.jp",
  "kaizuka.osaka.jp",
  "kanan.osaka.jp",
  "kashiwara.osaka.jp",
  "katano.osaka.jp",
  "kawachinagano.osaka.jp",
  "kishiwada.osaka.jp",
  "kita.osaka.jp",
  "kumatori.osaka.jp",
  "matsubara.osaka.jp",
  "minato.osaka.jp",
  "minoh.osaka.jp",
  "misaki.osaka.jp",
  "moriguchi.osaka.jp",
  "neyagawa.osaka.jp",
  "nishi.osaka.jp",
  "nose.osaka.jp",
  "osakasayama.osaka.jp",
  "sakai.osaka.jp",
  "sayama.osaka.jp",
  "sennan.osaka.jp",
  "settsu.osaka.jp",
  "shijonawate.osaka.jp",
  "shimamoto.osaka.jp",
  "suita.osaka.jp",
  "tadaoka.osaka.jp",
  "taishi.osaka.jp",
  "tajiri.osaka.jp",
  "takaishi.osaka.jp",
  "takatsuki.osaka.jp",
  "tondabayashi.osaka.jp",
  "toyonaka.osaka.jp",
  "toyono.osaka.jp",
  "yao.osaka.jp",
  "ariake.saga.jp",
  "arita.saga.jp",
  "fukudomi.saga.jp",
  "genkai.saga.jp",
  "hamatama.saga.jp",
  "hizen.saga.jp",
  "imari.saga.jp",
  "kamimine.saga.jp",
  "kanzaki.saga.jp",
  "karatsu.saga.jp",
  "kashima.saga.jp",
  "kitagata.saga.jp",
  "kitahata.saga.jp",
  "kiyama.saga.jp",
  "kouhoku.saga.jp",
  "kyuragi.saga.jp",
  "nishiarita.saga.jp",
  "ogi.saga.jp",
  "omachi.saga.jp",
  "ouchi.saga.jp",
  "saga.saga.jp",
  "shiroishi.saga.jp",
  "taku.saga.jp",
  "tara.saga.jp",
  "tosu.saga.jp",
  "yoshinogari.saga.jp",
  "arakawa.saitama.jp",
  "asaka.saitama.jp",
  "chichibu.saitama.jp",
  "fujimi.saitama.jp",
  "fujimino.saitama.jp",
  "fukaya.saitama.jp",
  "hanno.saitama.jp",
  "hanyu.saitama.jp",
  "hasuda.saitama.jp",
  "hatogaya.saitama.jp",
  "hatoyama.saitama.jp",
  "hidaka.saitama.jp",
  "higashichichibu.saitama.jp",
  "higashimatsuyama.saitama.jp",
  "honjo.saitama.jp",
  "ina.saitama.jp",
  "iruma.saitama.jp",
  "iwatsuki.saitama.jp",
  "kamiizumi.saitama.jp",
  "kamikawa.saitama.jp",
  "kamisato.saitama.jp",
  "kasukabe.saitama.jp",
  "kawagoe.saitama.jp",
  "kawaguchi.saitama.jp",
  "kawajima.saitama.jp",
  "kazo.saitama.jp",
  "kitamoto.saitama.jp",
  "koshigaya.saitama.jp",
  "kounosu.saitama.jp",
  "kuki.saitama.jp",
  "kumagaya.saitama.jp",
  "matsubushi.saitama.jp",
  "minano.saitama.jp",
  "misato.saitama.jp",
  "miyashiro.saitama.jp",
  "miyoshi.saitama.jp",
  "moroyama.saitama.jp",
  "nagatoro.saitama.jp",
  "namegawa.saitama.jp",
  "niiza.saitama.jp",
  "ogano.saitama.jp",
  "ogawa.saitama.jp",
  "ogose.saitama.jp",
  "okegawa.saitama.jp",
  "omiya.saitama.jp",
  "otaki.saitama.jp",
  "ranzan.saitama.jp",
  "ryokami.saitama.jp",
  "saitama.saitama.jp",
  "sakado.saitama.jp",
  "satte.saitama.jp",
  "sayama.saitama.jp",
  "shiki.saitama.jp",
  "shiraoka.saitama.jp",
  "soka.saitama.jp",
  "sugito.saitama.jp",
  "toda.saitama.jp",
  "tokigawa.saitama.jp",
  "tokorozawa.saitama.jp",
  "tsurugashima.saitama.jp",
  "urawa.saitama.jp",
  "warabi.saitama.jp",
  "yashio.saitama.jp",
  "yokoze.saitama.jp",
  "yono.saitama.jp",
  "yorii.saitama.jp",
  "yoshida.saitama.jp",
  "yoshikawa.saitama.jp",
  "yoshimi.saitama.jp",
  "aisho.shiga.jp",
  "gamo.shiga.jp",
  "higashiomi.shiga.jp",
  "hikone.shiga.jp",
  "koka.shiga.jp",
  "konan.shiga.jp",
  "kosei.shiga.jp",
  "koto.shiga.jp",
  "kusatsu.shiga.jp",
  "maibara.shiga.jp",
  "moriyama.shiga.jp",
  "nagahama.shiga.jp",
  "nishiazai.shiga.jp",
  "notogawa.shiga.jp",
  "omihachiman.shiga.jp",
  "otsu.shiga.jp",
  "ritto.shiga.jp",
  "ryuoh.shiga.jp",
  "takashima.shiga.jp",
  "takatsuki.shiga.jp",
  "torahime.shiga.jp",
  "toyosato.shiga.jp",
  "yasu.shiga.jp",
  "akagi.shimane.jp",
  "ama.shimane.jp",
  "gotsu.shimane.jp",
  "hamada.shimane.jp",
  "higashiizumo.shimane.jp",
  "hikawa.shimane.jp",
  "hikimi.shimane.jp",
  "izumo.shimane.jp",
  "kakinoki.shimane.jp",
  "masuda.shimane.jp",
  "matsue.shimane.jp",
  "misato.shimane.jp",
  "nishinoshima.shimane.jp",
  "ohda.shimane.jp",
  "okinoshima.shimane.jp",
  "okuizumo.shimane.jp",
  "shimane.shimane.jp",
  "tamayu.shimane.jp",
  "tsuwano.shimane.jp",
  "unnan.shimane.jp",
  "yakumo.shimane.jp",
  "yasugi.shimane.jp",
  "yatsuka.shimane.jp",
  "arai.shizuoka.jp",
  "atami.shizuoka.jp",
  "fuji.shizuoka.jp",
  "fujieda.shizuoka.jp",
  "fujikawa.shizuoka.jp",
  "fujinomiya.shizuoka.jp",
  "fukuroi.shizuoka.jp",
  "gotemba.shizuoka.jp",
  "haibara.shizuoka.jp",
  "hamamatsu.shizuoka.jp",
  "higashiizu.shizuoka.jp",
  "ito.shizuoka.jp",
  "iwata.shizuoka.jp",
  "izu.shizuoka.jp",
  "izunokuni.shizuoka.jp",
  "kakegawa.shizuoka.jp",
  "kannami.shizuoka.jp",
  "kawanehon.shizuoka.jp",
  "kawazu.shizuoka.jp",
  "kikugawa.shizuoka.jp",
  "kosai.shizuoka.jp",
  "makinohara.shizuoka.jp",
  "matsuzaki.shizuoka.jp",
  "minamiizu.shizuoka.jp",
  "mishima.shizuoka.jp",
  "morimachi.shizuoka.jp",
  "nishiizu.shizuoka.jp",
  "numazu.shizuoka.jp",
  "omaezaki.shizuoka.jp",
  "shimada.shizuoka.jp",
  "shimizu.shizuoka.jp",
  "shimoda.shizuoka.jp",
  "shizuoka.shizuoka.jp",
  "susono.shizuoka.jp",
  "yaizu.shizuoka.jp",
  "yoshida.shizuoka.jp",
  "ashikaga.tochigi.jp",
  "bato.tochigi.jp",
  "haga.tochigi.jp",
  "ichikai.tochigi.jp",
  "iwafune.tochigi.jp",
  "kaminokawa.tochigi.jp",
  "kanuma.tochigi.jp",
  "karasuyama.tochigi.jp",
  "kuroiso.tochigi.jp",
  "mashiko.tochigi.jp",
  "mibu.tochigi.jp",
  "moka.tochigi.jp",
  "motegi.tochigi.jp",
  "nasu.tochigi.jp",
  "nasushiobara.tochigi.jp",
  "nikko.tochigi.jp",
  "nishikata.tochigi.jp",
  "nogi.tochigi.jp",
  "ohira.tochigi.jp",
  "ohtawara.tochigi.jp",
  "oyama.tochigi.jp",
  "sakura.tochigi.jp",
  "sano.tochigi.jp",
  "shimotsuke.tochigi.jp",
  "shioya.tochigi.jp",
  "takanezawa.tochigi.jp",
  "tochigi.tochigi.jp",
  "tsuga.tochigi.jp",
  "ujiie.tochigi.jp",
  "utsunomiya.tochigi.jp",
  "yaita.tochigi.jp",
  "aizumi.tokushima.jp",
  "anan.tokushima.jp",
  "ichiba.tokushima.jp",
  "itano.tokushima.jp",
  "kainan.tokushima.jp",
  "komatsushima.tokushima.jp",
  "matsushige.tokushima.jp",
  "mima.tokushima.jp",
  "minami.tokushima.jp",
  "miyoshi.tokushima.jp",
  "mugi.tokushima.jp",
  "nakagawa.tokushima.jp",
  "naruto.tokushima.jp",
  "sanagochi.tokushima.jp",
  "shishikui.tokushima.jp",
  "tokushima.tokushima.jp",
  "wajiki.tokushima.jp",
  "adachi.tokyo.jp",
  "akiruno.tokyo.jp",
  "akishima.tokyo.jp",
  "aogashima.tokyo.jp",
  "arakawa.tokyo.jp",
  "bunkyo.tokyo.jp",
  "chiyoda.tokyo.jp",
  "chofu.tokyo.jp",
  "chuo.tokyo.jp",
  "edogawa.tokyo.jp",
  "fuchu.tokyo.jp",
  "fussa.tokyo.jp",
  "hachijo.tokyo.jp",
  "hachioji.tokyo.jp",
  "hamura.tokyo.jp",
  "higashikurume.tokyo.jp",
  "higashimurayama.tokyo.jp",
  "higashiyamato.tokyo.jp",
  "hino.tokyo.jp",
  "hinode.tokyo.jp",
  "hinohara.tokyo.jp",
  "inagi.tokyo.jp",
  "itabashi.tokyo.jp",
  "katsushika.tokyo.jp",
  "kita.tokyo.jp",
  "kiyose.tokyo.jp",
  "kodaira.tokyo.jp",
  "koganei.tokyo.jp",
  "kokubunji.tokyo.jp",
  "komae.tokyo.jp",
  "koto.tokyo.jp",
  "kouzushima.tokyo.jp",
  "kunitachi.tokyo.jp",
  "machida.tokyo.jp",
  "meguro.tokyo.jp",
  "minato.tokyo.jp",
  "mitaka.tokyo.jp",
  "mizuho.tokyo.jp",
  "musashimurayama.tokyo.jp",
  "musashino.tokyo.jp",
  "nakano.tokyo.jp",
  "nerima.tokyo.jp",
  "ogasawara.tokyo.jp",
  "okutama.tokyo.jp",
  "ome.tokyo.jp",
  "oshima.tokyo.jp",
  "ota.tokyo.jp",
  "setagaya.tokyo.jp",
  "shibuya.tokyo.jp",
  "shinagawa.tokyo.jp",
  "shinjuku.tokyo.jp",
  "suginami.tokyo.jp",
  "sumida.tokyo.jp",
  "tachikawa.tokyo.jp",
  "taito.tokyo.jp",
  "tama.tokyo.jp",
  "toshima.tokyo.jp",
  "chizu.tottori.jp",
  "hino.tottori.jp",
  "kawahara.tottori.jp",
  "koge.tottori.jp",
  "kotoura.tottori.jp",
  "misasa.tottori.jp",
  "nanbu.tottori.jp",
  "nichinan.tottori.jp",
  "sakaiminato.tottori.jp",
  "tottori.tottori.jp",
  "wakasa.tottori.jp",
  "yazu.tottori.jp",
  "yonago.tottori.jp",
  "asahi.toyama.jp",
  "fuchu.toyama.jp",
  "fukumitsu.toyama.jp",
  "funahashi.toyama.jp",
  "himi.toyama.jp",
  "imizu.toyama.jp",
  "inami.toyama.jp",
  "johana.toyama.jp",
  "kamiichi.toyama.jp",
  "kurobe.toyama.jp",
  "nakaniikawa.toyama.jp",
  "namerikawa.toyama.jp",
  "nanto.toyama.jp",
  "nyuzen.toyama.jp",
  "oyabe.toyama.jp",
  "taira.toyama.jp",
  "takaoka.toyama.jp",
  "tateyama.toyama.jp",
  "toga.toyama.jp",
  "tonami.toyama.jp",
  "toyama.toyama.jp",
  "unazuki.toyama.jp",
  "uozu.toyama.jp",
  "yamada.toyama.jp",
  "arida.wakayama.jp",
  "aridagawa.wakayama.jp",
  "gobo.wakayama.jp",
  "hashimoto.wakayama.jp",
  "hidaka.wakayama.jp",
  "hirogawa.wakayama.jp",
  "inami.wakayama.jp",
  "iwade.wakayama.jp",
  "kainan.wakayama.jp",
  "kamitonda.wakayama.jp",
  "katsuragi.wakayama.jp",
  "kimino.wakayama.jp",
  "kinokawa.wakayama.jp",
  "kitayama.wakayama.jp",
  "koya.wakayama.jp",
  "koza.wakayama.jp",
  "kozagawa.wakayama.jp",
  "kudoyama.wakayama.jp",
  "kushimoto.wakayama.jp",
  "mihama.wakayama.jp",
  "misato.wakayama.jp",
  "nachikatsuura.wakayama.jp",
  "shingu.wakayama.jp",
  "shirahama.wakayama.jp",
  "taiji.wakayama.jp",
  "tanabe.wakayama.jp",
  "wakayama.wakayama.jp",
  "yuasa.wakayama.jp",
  "yura.wakayama.jp",
  "asahi.yamagata.jp",
  "funagata.yamagata.jp",
  "higashine.yamagata.jp",
  "iide.yamagata.jp",
  "kahoku.yamagata.jp",
  "kaminoyama.yamagata.jp",
  "kaneyama.yamagata.jp",
  "kawanishi.yamagata.jp",
  "mamurogawa.yamagata.jp",
  "mikawa.yamagata.jp",
  "murayama.yamagata.jp",
  "nagai.yamagata.jp",
  "nakayama.yamagata.jp",
  "nanyo.yamagata.jp",
  "nishikawa.yamagata.jp",
  "obanazawa.yamagata.jp",
  "oe.yamagata.jp",
  "oguni.yamagata.jp",
  "ohkura.yamagata.jp",
  "oishida.yamagata.jp",
  "sagae.yamagata.jp",
  "sakata.yamagata.jp",
  "sakegawa.yamagata.jp",
  "shinjo.yamagata.jp",
  "shirataka.yamagata.jp",
  "shonai.yamagata.jp",
  "takahata.yamagata.jp",
  "tendo.yamagata.jp",
  "tozawa.yamagata.jp",
  "tsuruoka.yamagata.jp",
  "yamagata.yamagata.jp",
  "yamanobe.yamagata.jp",
  "yonezawa.yamagata.jp",
  "yuza.yamagata.jp",
  "abu.yamaguchi.jp",
  "hagi.yamaguchi.jp",
  "hikari.yamaguchi.jp",
  "hofu.yamaguchi.jp",
  "iwakuni.yamaguchi.jp",
  "kudamatsu.yamaguchi.jp",
  "mitou.yamaguchi.jp",
  "nagato.yamaguchi.jp",
  "oshima.yamaguchi.jp",
  "shimonoseki.yamaguchi.jp",
  "shunan.yamaguchi.jp",
  "tabuse.yamaguchi.jp",
  "tokuyama.yamaguchi.jp",
  "toyota.yamaguchi.jp",
  "ube.yamaguchi.jp",
  "yuu.yamaguchi.jp",
  "chuo.yamanashi.jp",
  "doshi.yamanashi.jp",
  "fuefuki.yamanashi.jp",
  "fujikawa.yamanashi.jp",
  "fujikawaguchiko.yamanashi.jp",
  "fujiyoshida.yamanashi.jp",
  "hayakawa.yamanashi.jp",
  "hokuto.yamanashi.jp",
  "ichikawamisato.yamanashi.jp",
  "kai.yamanashi.jp",
  "kofu.yamanashi.jp",
  "koshu.yamanashi.jp",
  "kosuge.yamanashi.jp",
  "minami-alps.yamanashi.jp",
  "minobu.yamanashi.jp",
  "nakamichi.yamanashi.jp",
  "nanbu.yamanashi.jp",
  "narusawa.yamanashi.jp",
  "nirasaki.yamanashi.jp",
  "nishikatsura.yamanashi.jp",
  "oshino.yamanashi.jp",
  "otsuki.yamanashi.jp",
  "showa.yamanashi.jp",
  "tabayama.yamanashi.jp",
  "tsuru.yamanashi.jp",
  "uenohara.yamanashi.jp",
  "yamanakako.yamanashi.jp",
  "yamanashi.yamanashi.jp",
  "ke",
  "ac.ke",
  "co.ke",
  "go.ke",
  "info.ke",
  "me.ke",
  "mobi.ke",
  "ne.ke",
  "or.ke",
  "sc.ke",
  "kg",
  "org.kg",
  "net.kg",
  "com.kg",
  "edu.kg",
  "gov.kg",
  "mil.kg",
  "*.kh",
  "ki",
  "edu.ki",
  "biz.ki",
  "net.ki",
  "org.ki",
  "gov.ki",
  "info.ki",
  "com.ki",
  "km",
  "org.km",
  "nom.km",
  "gov.km",
  "prd.km",
  "tm.km",
  "edu.km",
  "mil.km",
  "ass.km",
  "com.km",
  "coop.km",
  "asso.km",
  "presse.km",
  "medecin.km",
  "notaires.km",
  "pharmaciens.km",
  "veterinaire.km",
  "gouv.km",
  "kn",
  "net.kn",
  "org.kn",
  "edu.kn",
  "gov.kn",
  "kp",
  "com.kp",
  "edu.kp",
  "gov.kp",
  "org.kp",
  "rep.kp",
  "tra.kp",
  "kr",
  "ac.kr",
  "co.kr",
  "es.kr",
  "go.kr",
  "hs.kr",
  "kg.kr",
  "mil.kr",
  "ms.kr",
  "ne.kr",
  "or.kr",
  "pe.kr",
  "re.kr",
  "sc.kr",
  "busan.kr",
  "chungbuk.kr",
  "chungnam.kr",
  "daegu.kr",
  "daejeon.kr",
  "gangwon.kr",
  "gwangju.kr",
  "gyeongbuk.kr",
  "gyeonggi.kr",
  "gyeongnam.kr",
  "incheon.kr",
  "jeju.kr",
  "jeonbuk.kr",
  "jeonnam.kr",
  "seoul.kr",
  "ulsan.kr",
  "kw",
  "com.kw",
  "edu.kw",
  "emb.kw",
  "gov.kw",
  "ind.kw",
  "net.kw",
  "org.kw",
  "ky",
  "com.ky",
  "edu.ky",
  "net.ky",
  "org.ky",
  "kz",
  "org.kz",
  "edu.kz",
  "net.kz",
  "gov.kz",
  "mil.kz",
  "com.kz",
  "la",
  "int.la",
  "net.la",
  "info.la",
  "edu.la",
  "gov.la",
  "per.la",
  "com.la",
  "org.la",
  "lb",
  "com.lb",
  "edu.lb",
  "gov.lb",
  "net.lb",
  "org.lb",
  "lc",
  "com.lc",
  "net.lc",
  "co.lc",
  "org.lc",
  "edu.lc",
  "gov.lc",
  "li",
  "lk",
  "gov.lk",
  "sch.lk",
  "net.lk",
  "int.lk",
  "com.lk",
  "org.lk",
  "edu.lk",
  "ngo.lk",
  "soc.lk",
  "web.lk",
  "ltd.lk",
  "assn.lk",
  "grp.lk",
  "hotel.lk",
  "ac.lk",
  "lr",
  "com.lr",
  "edu.lr",
  "gov.lr",
  "org.lr",
  "net.lr",
  "ls",
  "ac.ls",
  "biz.ls",
  "co.ls",
  "edu.ls",
  "gov.ls",
  "info.ls",
  "net.ls",
  "org.ls",
  "sc.ls",
  "lt",
  "gov.lt",
  "lu",
  "lv",
  "com.lv",
  "edu.lv",
  "gov.lv",
  "org.lv",
  "mil.lv",
  "id.lv",
  "net.lv",
  "asn.lv",
  "conf.lv",
  "ly",
  "com.ly",
  "net.ly",
  "gov.ly",
  "plc.ly",
  "edu.ly",
  "sch.ly",
  "med.ly",
  "org.ly",
  "id.ly",
  "ma",
  "co.ma",
  "net.ma",
  "gov.ma",
  "org.ma",
  "ac.ma",
  "press.ma",
  "mc",
  "tm.mc",
  "asso.mc",
  "md",
  "me",
  "co.me",
  "net.me",
  "org.me",
  "edu.me",
  "ac.me",
  "gov.me",
  "its.me",
  "priv.me",
  "mg",
  "org.mg",
  "nom.mg",
  "gov.mg",
  "prd.mg",
  "tm.mg",
  "edu.mg",
  "mil.mg",
  "com.mg",
  "co.mg",
  "mh",
  "mil",
  "mk",
  "com.mk",
  "org.mk",
  "net.mk",
  "edu.mk",
  "gov.mk",
  "inf.mk",
  "name.mk",
  "ml",
  "com.ml",
  "edu.ml",
  "gouv.ml",
  "gov.ml",
  "net.ml",
  "org.ml",
  "presse.ml",
  "*.mm",
  "mn",
  "gov.mn",
  "edu.mn",
  "org.mn",
  "mo",
  "com.mo",
  "net.mo",
  "org.mo",
  "edu.mo",
  "gov.mo",
  "mobi",
  "mp",
  "mq",
  "mr",
  "gov.mr",
  "ms",
  "com.ms",
  "edu.ms",
  "gov.ms",
  "net.ms",
  "org.ms",
  "mt",
  "com.mt",
  "edu.mt",
  "net.mt",
  "org.mt",
  "mu",
  "com.mu",
  "net.mu",
  "org.mu",
  "gov.mu",
  "ac.mu",
  "co.mu",
  "or.mu",
  "museum",
  "academy.museum",
  "agriculture.museum",
  "air.museum",
  "airguard.museum",
  "alabama.museum",
  "alaska.museum",
  "amber.museum",
  "ambulance.museum",
  "american.museum",
  "americana.museum",
  "americanantiques.museum",
  "americanart.museum",
  "amsterdam.museum",
  "and.museum",
  "annefrank.museum",
  "anthro.museum",
  "anthropology.museum",
  "antiques.museum",
  "aquarium.museum",
  "arboretum.museum",
  "archaeological.museum",
  "archaeology.museum",
  "architecture.museum",
  "art.museum",
  "artanddesign.museum",
  "artcenter.museum",
  "artdeco.museum",
  "arteducation.museum",
  "artgallery.museum",
  "arts.museum",
  "artsandcrafts.museum",
  "asmatart.museum",
  "assassination.museum",
  "assisi.museum",
  "association.museum",
  "astronomy.museum",
  "atlanta.museum",
  "austin.museum",
  "australia.museum",
  "automotive.museum",
  "aviation.museum",
  "axis.museum",
  "badajoz.museum",
  "baghdad.museum",
  "bahn.museum",
  "bale.museum",
  "baltimore.museum",
  "barcelona.museum",
  "baseball.museum",
  "basel.museum",
  "baths.museum",
  "bauern.museum",
  "beauxarts.museum",
  "beeldengeluid.museum",
  "bellevue.museum",
  "bergbau.museum",
  "berkeley.museum",
  "berlin.museum",
  "bern.museum",
  "bible.museum",
  "bilbao.museum",
  "bill.museum",
  "birdart.museum",
  "birthplace.museum",
  "bonn.museum",
  "boston.museum",
  "botanical.museum",
  "botanicalgarden.museum",
  "botanicgarden.museum",
  "botany.museum",
  "brandywinevalley.museum",
  "brasil.museum",
  "bristol.museum",
  "british.museum",
  "britishcolumbia.museum",
  "broadcast.museum",
  "brunel.museum",
  "brussel.museum",
  "brussels.museum",
  "bruxelles.museum",
  "building.museum",
  "burghof.museum",
  "bus.museum",
  "bushey.museum",
  "cadaques.museum",
  "california.museum",
  "cambridge.museum",
  "can.museum",
  "canada.museum",
  "capebreton.museum",
  "carrier.museum",
  "cartoonart.museum",
  "casadelamoneda.museum",
  "castle.museum",
  "castres.museum",
  "celtic.museum",
  "center.museum",
  "chattanooga.museum",
  "cheltenham.museum",
  "chesapeakebay.museum",
  "chicago.museum",
  "children.museum",
  "childrens.museum",
  "childrensgarden.museum",
  "chiropractic.museum",
  "chocolate.museum",
  "christiansburg.museum",
  "cincinnati.museum",
  "cinema.museum",
  "circus.museum",
  "civilisation.museum",
  "civilization.museum",
  "civilwar.museum",
  "clinton.museum",
  "clock.museum",
  "coal.museum",
  "coastaldefence.museum",
  "cody.museum",
  "coldwar.museum",
  "collection.museum",
  "colonialwilliamsburg.museum",
  "coloradoplateau.museum",
  "columbia.museum",
  "columbus.museum",
  "communication.museum",
  "communications.museum",
  "community.museum",
  "computer.museum",
  "computerhistory.museum",
  "comunicações.museum",
  "contemporary.museum",
  "contemporaryart.museum",
  "convent.museum",
  "copenhagen.museum",
  "corporation.museum",
  "correios-e-telecomunicações.museum",
  "corvette.museum",
  "costume.museum",
  "countryestate.museum",
  "county.museum",
  "crafts.museum",
  "cranbrook.museum",
  "creation.museum",
  "cultural.museum",
  "culturalcenter.museum",
  "culture.museum",
  "cyber.museum",
  "cymru.museum",
  "dali.museum",
  "dallas.museum",
  "database.museum",
  "ddr.museum",
  "decorativearts.museum",
  "delaware.museum",
  "delmenhorst.museum",
  "denmark.museum",
  "depot.museum",
  "design.museum",
  "detroit.museum",
  "dinosaur.museum",
  "discovery.museum",
  "dolls.museum",
  "donostia.museum",
  "durham.museum",
  "eastafrica.museum",
  "eastcoast.museum",
  "education.museum",
  "educational.museum",
  "egyptian.museum",
  "eisenbahn.museum",
  "elburg.museum",
  "elvendrell.museum",
  "embroidery.museum",
  "encyclopedic.museum",
  "england.museum",
  "entomology.museum",
  "environment.museum",
  "environmentalconservation.museum",
  "epilepsy.museum",
  "essex.museum",
  "estate.museum",
  "ethnology.museum",
  "exeter.museum",
  "exhibition.museum",
  "family.museum",
  "farm.museum",
  "farmequipment.museum",
  "farmers.museum",
  "farmstead.museum",
  "field.museum",
  "figueres.museum",
  "filatelia.museum",
  "film.museum",
  "fineart.museum",
  "finearts.museum",
  "finland.museum",
  "flanders.museum",
  "florida.museum",
  "force.museum",
  "fortmissoula.museum",
  "fortworth.museum",
  "foundation.museum",
  "francaise.museum",
  "frankfurt.museum",
  "franziskaner.museum",
  "freemasonry.museum",
  "freiburg.museum",
  "fribourg.museum",
  "frog.museum",
  "fundacio.museum",
  "furniture.museum",
  "gallery.museum",
  "garden.museum",
  "gateway.museum",
  "geelvinck.museum",
  "gemological.museum",
  "geology.museum",
  "georgia.museum",
  "giessen.museum",
  "glas.museum",
  "glass.museum",
  "gorge.museum",
  "grandrapids.museum",
  "graz.museum",
  "guernsey.museum",
  "halloffame.museum",
  "hamburg.museum",
  "handson.museum",
  "harvestcelebration.museum",
  "hawaii.museum",
  "health.museum",
  "heimatunduhren.museum",
  "hellas.museum",
  "helsinki.museum",
  "hembygdsforbund.museum",
  "heritage.museum",
  "histoire.museum",
  "historical.museum",
  "historicalsociety.museum",
  "historichouses.museum",
  "historisch.museum",
  "historisches.museum",
  "history.museum",
  "historyofscience.museum",
  "horology.museum",
  "house.museum",
  "humanities.museum",
  "illustration.museum",
  "imageandsound.museum",
  "indian.museum",
  "indiana.museum",
  "indianapolis.museum",
  "indianmarket.museum",
  "intelligence.museum",
  "interactive.museum",
  "iraq.museum",
  "iron.museum",
  "isleofman.museum",
  "jamison.museum",
  "jefferson.museum",
  "jerusalem.museum",
  "jewelry.museum",
  "jewish.museum",
  "jewishart.museum",
  "jfk.museum",
  "journalism.museum",
  "judaica.museum",
  "judygarland.museum",
  "juedisches.museum",
  "juif.museum",
  "karate.museum",
  "karikatur.museum",
  "kids.museum",
  "koebenhavn.museum",
  "koeln.museum",
  "kunst.museum",
  "kunstsammlung.museum",
  "kunstunddesign.museum",
  "labor.museum",
  "labour.museum",
  "lajolla.museum",
  "lancashire.museum",
  "landes.museum",
  "lans.museum",
  "läns.museum",
  "larsson.museum",
  "lewismiller.museum",
  "lincoln.museum",
  "linz.museum",
  "living.museum",
  "livinghistory.museum",
  "localhistory.museum",
  "london.museum",
  "losangeles.museum",
  "louvre.museum",
  "loyalist.museum",
  "lucerne.museum",
  "luxembourg.museum",
  "luzern.museum",
  "mad.museum",
  "madrid.museum",
  "mallorca.museum",
  "manchester.museum",
  "mansion.museum",
  "mansions.museum",
  "manx.museum",
  "marburg.museum",
  "maritime.museum",
  "maritimo.museum",
  "maryland.museum",
  "marylhurst.museum",
  "media.museum",
  "medical.museum",
  "medizinhistorisches.museum",
  "meeres.museum",
  "memorial.museum",
  "mesaverde.museum",
  "michigan.museum",
  "midatlantic.museum",
  "military.museum",
  "mill.museum",
  "miners.museum",
  "mining.museum",
  "minnesota.museum",
  "missile.museum",
  "missoula.museum",
  "modern.museum",
  "moma.museum",
  "money.museum",
  "monmouth.museum",
  "monticello.museum",
  "montreal.museum",
  "moscow.museum",
  "motorcycle.museum",
  "muenchen.museum",
  "muenster.museum",
  "mulhouse.museum",
  "muncie.museum",
  "museet.museum",
  "museumcenter.museum",
  "museumvereniging.museum",
  "music.museum",
  "national.museum",
  "nationalfirearms.museum",
  "nationalheritage.museum",
  "nativeamerican.museum",
  "naturalhistory.museum",
  "naturalhistorymuseum.museum",
  "naturalsciences.museum",
  "nature.museum",
  "naturhistorisches.museum",
  "natuurwetenschappen.museum",
  "naumburg.museum",
  "naval.museum",
  "nebraska.museum",
  "neues.museum",
  "newhampshire.museum",
  "newjersey.museum",
  "newmexico.museum",
  "newport.museum",
  "newspaper.museum",
  "newyork.museum",
  "niepce.museum",
  "norfolk.museum",
  "north.museum",
  "nrw.museum",
  "nyc.museum",
  "nyny.museum",
  "oceanographic.museum",
  "oceanographique.museum",
  "omaha.museum",
  "online.museum",
  "ontario.museum",
  "openair.museum",
  "oregon.museum",
  "oregontrail.museum",
  "otago.museum",
  "oxford.museum",
  "pacific.museum",
  "paderborn.museum",
  "palace.museum",
  "paleo.museum",
  "palmsprings.museum",
  "panama.museum",
  "paris.museum",
  "pasadena.museum",
  "pharmacy.museum",
  "philadelphia.museum",
  "philadelphiaarea.museum",
  "philately.museum",
  "phoenix.museum",
  "photography.museum",
  "pilots.museum",
  "pittsburgh.museum",
  "planetarium.museum",
  "plantation.museum",
  "plants.museum",
  "plaza.museum",
  "portal.museum",
  "portland.museum",
  "portlligat.museum",
  "posts-and-telecommunications.museum",
  "preservation.museum",
  "presidio.museum",
  "press.museum",
  "project.museum",
  "public.museum",
  "pubol.museum",
  "quebec.museum",
  "railroad.museum",
  "railway.museum",
  "research.museum",
  "resistance.museum",
  "riodejaneiro.museum",
  "rochester.museum",
  "rockart.museum",
  "roma.museum",
  "russia.museum",
  "saintlouis.museum",
  "salem.museum",
  "salvadordali.museum",
  "salzburg.museum",
  "sandiego.museum",
  "sanfrancisco.museum",
  "santabarbara.museum",
  "santacruz.museum",
  "santafe.museum",
  "saskatchewan.museum",
  "satx.museum",
  "savannahga.museum",
  "schlesisches.museum",
  "schoenbrunn.museum",
  "schokoladen.museum",
  "school.museum",
  "schweiz.museum",
  "science.museum",
  "scienceandhistory.museum",
  "scienceandindustry.museum",
  "sciencecenter.museum",
  "sciencecenters.museum",
  "science-fiction.museum",
  "sciencehistory.museum",
  "sciences.museum",
  "sciencesnaturelles.museum",
  "scotland.museum",
  "seaport.museum",
  "settlement.museum",
  "settlers.museum",
  "shell.museum",
  "sherbrooke.museum",
  "sibenik.museum",
  "silk.museum",
  "ski.museum",
  "skole.museum",
  "society.museum",
  "sologne.museum",
  "soundandvision.museum",
  "southcarolina.museum",
  "southwest.museum",
  "space.museum",
  "spy.museum",
  "square.museum",
  "stadt.museum",
  "stalbans.museum",
  "starnberg.museum",
  "state.museum",
  "stateofdelaware.museum",
  "station.museum",
  "steam.museum",
  "steiermark.museum",
  "stjohn.museum",
  "stockholm.museum",
  "stpetersburg.museum",
  "stuttgart.museum",
  "suisse.museum",
  "surgeonshall.museum",
  "surrey.museum",
  "svizzera.museum",
  "sweden.museum",
  "sydney.museum",
  "tank.museum",
  "tcm.museum",
  "technology.museum",
  "telekommunikation.museum",
  "television.museum",
  "texas.museum",
  "textile.museum",
  "theater.museum",
  "time.museum",
  "timekeeping.museum",
  "topology.museum",
  "torino.museum",
  "touch.museum",
  "town.museum",
  "transport.museum",
  "tree.museum",
  "trolley.museum",
  "trust.museum",
  "trustee.museum",
  "uhren.museum",
  "ulm.museum",
  "undersea.museum",
  "university.museum",
  "usa.museum",
  "usantiques.museum",
  "usarts.museum",
  "uscountryestate.museum",
  "usculture.museum",
  "usdecorativearts.museum",
  "usgarden.museum",
  "ushistory.museum",
  "ushuaia.museum",
  "uslivinghistory.museum",
  "utah.museum",
  "uvic.museum",
  "valley.museum",
  "vantaa.museum",
  "versailles.museum",
  "viking.museum",
  "village.museum",
  "virginia.museum",
  "virtual.museum",
  "virtuel.museum",
  "vlaanderen.museum",
  "volkenkunde.museum",
  "wales.museum",
  "wallonie.museum",
  "war.museum",
  "washingtondc.museum",
  "watchandclock.museum",
  "watch-and-clock.museum",
  "western.museum",
  "westfalen.museum",
  "whaling.museum",
  "wildlife.museum",
  "williamsburg.museum",
  "windmill.museum",
  "workshop.museum",
  "york.museum",
  "yorkshire.museum",
  "yosemite.museum",
  "youth.museum",
  "zoological.museum",
  "zoology.museum",
  "ירושלים.museum",
  "иком.museum",
  "mv",
  "aero.mv",
  "biz.mv",
  "com.mv",
  "coop.mv",
  "edu.mv",
  "gov.mv",
  "info.mv",
  "int.mv",
  "mil.mv",
  "museum.mv",
  "name.mv",
  "net.mv",
  "org.mv",
  "pro.mv",
  "mw",
  "ac.mw",
  "biz.mw",
  "co.mw",
  "com.mw",
  "coop.mw",
  "edu.mw",
  "gov.mw",
  "int.mw",
  "museum.mw",
  "net.mw",
  "org.mw",
  "mx",
  "com.mx",
  "org.mx",
  "gob.mx",
  "edu.mx",
  "net.mx",
  "my",
  "biz.my",
  "com.my",
  "edu.my",
  "gov.my",
  "mil.my",
  "name.my",
  "net.my",
  "org.my",
  "mz",
  "ac.mz",
  "adv.mz",
  "co.mz",
  "edu.mz",
  "gov.mz",
  "mil.mz",
  "net.mz",
  "org.mz",
  "na",
  "info.na",
  "pro.na",
  "name.na",
  "school.na",
  "or.na",
  "dr.na",
  "us.na",
  "mx.na",
  "ca.na",
  "in.na",
  "cc.na",
  "tv.na",
  "ws.na",
  "mobi.na",
  "co.na",
  "com.na",
  "org.na",
  "name",
  "nc",
  "asso.nc",
  "nom.nc",
  "ne",
  "net",
  "nf",
  "com.nf",
  "net.nf",
  "per.nf",
  "rec.nf",
  "web.nf",
  "arts.nf",
  "firm.nf",
  "info.nf",
  "other.nf",
  "store.nf",
  "ng",
  "com.ng",
  "edu.ng",
  "gov.ng",
  "i.ng",
  "mil.ng",
  "mobi.ng",
  "name.ng",
  "net.ng",
  "org.ng",
  "sch.ng",
  "ni",
  "ac.ni",
  "biz.ni",
  "co.ni",
  "com.ni",
  "edu.ni",
  "gob.ni",
  "in.ni",
  "info.ni",
  "int.ni",
  "mil.ni",
  "net.ni",
  "nom.ni",
  "org.ni",
  "web.ni",
  "nl",
  "no",
  "fhs.no",
  "vgs.no",
  "fylkesbibl.no",
  "folkebibl.no",
  "museum.no",
  "idrett.no",
  "priv.no",
  "mil.no",
  "stat.no",
  "dep.no",
  "kommune.no",
  "herad.no",
  "aa.no",
  "ah.no",
  "bu.no",
  "fm.no",
  "hl.no",
  "hm.no",
  "jan-mayen.no",
  "mr.no",
  "nl.no",
  "nt.no",
  "of.no",
  "ol.no",
  "oslo.no",
  "rl.no",
  "sf.no",
  "st.no",
  "svalbard.no",
  "tm.no",
  "tr.no",
  "va.no",
  "vf.no",
  "gs.aa.no",
  "gs.ah.no",
  "gs.bu.no",
  "gs.fm.no",
  "gs.hl.no",
  "gs.hm.no",
  "gs.jan-mayen.no",
  "gs.mr.no",
  "gs.nl.no",
  "gs.nt.no",
  "gs.of.no",
  "gs.ol.no",
  "gs.oslo.no",
  "gs.rl.no",
  "gs.sf.no",
  "gs.st.no",
  "gs.svalbard.no",
  "gs.tm.no",
  "gs.tr.no",
  "gs.va.no",
  "gs.vf.no",
  "akrehamn.no",
  "åkrehamn.no",
  "algard.no",
  "ålgård.no",
  "arna.no",
  "brumunddal.no",
  "bryne.no",
  "bronnoysund.no",
  "brønnøysund.no",
  "drobak.no",
  "drøbak.no",
  "egersund.no",
  "fetsund.no",
  "floro.no",
  "florø.no",
  "fredrikstad.no",
  "hokksund.no",
  "honefoss.no",
  "hønefoss.no",
  "jessheim.no",
  "jorpeland.no",
  "jørpeland.no",
  "kirkenes.no",
  "kopervik.no",
  "krokstadelva.no",
  "langevag.no",
  "langevåg.no",
  "leirvik.no",
  "mjondalen.no",
  "mjøndalen.no",
  "mo-i-rana.no",
  "mosjoen.no",
  "mosjøen.no",
  "nesoddtangen.no",
  "orkanger.no",
  "osoyro.no",
  "osøyro.no",
  "raholt.no",
  "råholt.no",
  "sandnessjoen.no",
  "sandnessjøen.no",
  "skedsmokorset.no",
  "slattum.no",
  "spjelkavik.no",
  "stathelle.no",
  "stavern.no",
  "stjordalshalsen.no",
  "stjørdalshalsen.no",
  "tananger.no",
  "tranby.no",
  "vossevangen.no",
  "afjord.no",
  "åfjord.no",
  "agdenes.no",
  "al.no",
  "ål.no",
  "alesund.no",
  "ålesund.no",
  "alstahaug.no",
  "alta.no",
  "áltá.no",
  "alaheadju.no",
  "álaheadju.no",
  "alvdal.no",
  "amli.no",
  "åmli.no",
  "amot.no",
  "åmot.no",
  "andebu.no",
  "andoy.no",
  "andøy.no",
  "andasuolo.no",
  "ardal.no",
  "årdal.no",
  "aremark.no",
  "arendal.no",
  "ås.no",
  "aseral.no",
  "åseral.no",
  "asker.no",
  "askim.no",
  "askvoll.no",
  "askoy.no",
  "askøy.no",
  "asnes.no",
  "åsnes.no",
  "audnedaln.no",
  "aukra.no",
  "aure.no",
  "aurland.no",
  "aurskog-holand.no",
  "aurskog-høland.no",
  "austevoll.no",
  "austrheim.no",
  "averoy.no",
  "averøy.no",
  "balestrand.no",
  "ballangen.no",
  "balat.no",
  "bálát.no",
  "balsfjord.no",
  "bahccavuotna.no",
  "báhccavuotna.no",
  "bamble.no",
  "bardu.no",
  "beardu.no",
  "beiarn.no",
  "bajddar.no",
  "bájddar.no",
  "baidar.no",
  "báidár.no",
  "berg.no",
  "bergen.no",
  "berlevag.no",
  "berlevåg.no",
  "bearalvahki.no",
  "bearalváhki.no",
  "bindal.no",
  "birkenes.no",
  "bjarkoy.no",
  "bjarkøy.no",
  "bjerkreim.no",
  "bjugn.no",
  "bodo.no",
  "bodø.no",
  "badaddja.no",
  "bådåddjå.no",
  "budejju.no",
  "bokn.no",
  "bremanger.no",
  "bronnoy.no",
  "brønnøy.no",
  "bygland.no",
  "bykle.no",
  "barum.no",
  "bærum.no",
  "bo.telemark.no",
  "bø.telemark.no",
  "bo.nordland.no",
  "bø.nordland.no",
  "bievat.no",
  "bievát.no",
  "bomlo.no",
  "bømlo.no",
  "batsfjord.no",
  "båtsfjord.no",
  "bahcavuotna.no",
  "báhcavuotna.no",
  "dovre.no",
  "drammen.no",
  "drangedal.no",
  "dyroy.no",
  "dyrøy.no",
  "donna.no",
  "dønna.no",
  "eid.no",
  "eidfjord.no",
  "eidsberg.no",
  "eidskog.no",
  "eidsvoll.no",
  "eigersund.no",
  "elverum.no",
  "enebakk.no",
  "engerdal.no",
  "etne.no",
  "etnedal.no",
  "evenes.no",
  "evenassi.no",
  "evenášši.no",
  "evje-og-hornnes.no",
  "farsund.no",
  "fauske.no",
  "fuossko.no",
  "fuoisku.no",
  "fedje.no",
  "fet.no",
  "finnoy.no",
  "finnøy.no",
  "fitjar.no",
  "fjaler.no",
  "fjell.no",
  "flakstad.no",
  "flatanger.no",
  "flekkefjord.no",
  "flesberg.no",
  "flora.no",
  "fla.no",
  "flå.no",
  "folldal.no",
  "forsand.no",
  "fosnes.no",
  "frei.no",
  "frogn.no",
  "froland.no",
  "frosta.no",
  "frana.no",
  "fræna.no",
  "froya.no",
  "frøya.no",
  "fusa.no",
  "fyresdal.no",
  "forde.no",
  "førde.no",
  "gamvik.no",
  "gangaviika.no",
  "gáŋgaviika.no",
  "gaular.no",
  "gausdal.no",
  "gildeskal.no",
  "gildeskål.no",
  "giske.no",
  "gjemnes.no",
  "gjerdrum.no",
  "gjerstad.no",
  "gjesdal.no",
  "gjovik.no",
  "gjøvik.no",
  "gloppen.no",
  "gol.no",
  "gran.no",
  "grane.no",
  "granvin.no",
  "gratangen.no",
  "grimstad.no",
  "grong.no",
  "kraanghke.no",
  "kråanghke.no",
  "grue.no",
  "gulen.no",
  "hadsel.no",
  "halden.no",
  "halsa.no",
  "hamar.no",
  "hamaroy.no",
  "habmer.no",
  "hábmer.no",
  "hapmir.no",
  "hápmir.no",
  "hammerfest.no",
  "hammarfeasta.no",
  "hámmárfeasta.no",
  "haram.no",
  "hareid.no",
  "harstad.no",
  "hasvik.no",
  "aknoluokta.no",
  "ákŋoluokta.no",
  "hattfjelldal.no",
  "aarborte.no",
  "haugesund.no",
  "hemne.no",
  "hemnes.no",
  "hemsedal.no",
  "heroy.more-og-romsdal.no",
  "herøy.møre-og-romsdal.no",
  "heroy.nordland.no",
  "herøy.nordland.no",
  "hitra.no",
  "hjartdal.no",
  "hjelmeland.no",
  "hobol.no",
  "hobøl.no",
  "hof.no",
  "hol.no",
  "hole.no",
  "holmestrand.no",
  "holtalen.no",
  "holtålen.no",
  "hornindal.no",
  "horten.no",
  "hurdal.no",
  "hurum.no",
  "hvaler.no",
  "hyllestad.no",
  "hagebostad.no",
  "hægebostad.no",
  "hoyanger.no",
  "høyanger.no",
  "hoylandet.no",
  "høylandet.no",
  "ha.no",
  "hå.no",
  "ibestad.no",
  "inderoy.no",
  "inderøy.no",
  "iveland.no",
  "jevnaker.no",
  "jondal.no",
  "jolster.no",
  "jølster.no",
  "karasjok.no",
  "karasjohka.no",
  "kárášjohka.no",
  "karlsoy.no",
  "galsa.no",
  "gálsá.no",
  "karmoy.no",
  "karmøy.no",
  "kautokeino.no",
  "guovdageaidnu.no",
  "klepp.no",
  "klabu.no",
  "klæbu.no",
  "kongsberg.no",
  "kongsvinger.no",
  "kragero.no",
  "kragerø.no",
  "kristiansand.no",
  "kristiansund.no",
  "krodsherad.no",
  "krødsherad.no",
  "kvalsund.no",
  "rahkkeravju.no",
  "ráhkkerávju.no",
  "kvam.no",
  "kvinesdal.no",
  "kvinnherad.no",
  "kviteseid.no",
  "kvitsoy.no",
  "kvitsøy.no",
  "kvafjord.no",
  "kvæfjord.no",
  "giehtavuoatna.no",
  "kvanangen.no",
  "kvænangen.no",
  "navuotna.no",
  "návuotna.no",
  "kafjord.no",
  "kåfjord.no",
  "gaivuotna.no",
  "gáivuotna.no",
  "larvik.no",
  "lavangen.no",
  "lavagis.no",
  "loabat.no",
  "loabát.no",
  "lebesby.no",
  "davvesiida.no",
  "leikanger.no",
  "leirfjord.no",
  "leka.no",
  "leksvik.no",
  "lenvik.no",
  "leangaviika.no",
  "leaŋgaviika.no",
  "lesja.no",
  "levanger.no",
  "lier.no",
  "lierne.no",
  "lillehammer.no",
  "lillesand.no",
  "lindesnes.no",
  "lindas.no",
  "lindås.no",
  "lom.no",
  "loppa.no",
  "lahppi.no",
  "láhppi.no",
  "lund.no",
  "lunner.no",
  "luroy.no",
  "lurøy.no",
  "luster.no",
  "lyngdal.no",
  "lyngen.no",
  "ivgu.no",
  "lardal.no",
  "lerdal.no",
  "lærdal.no",
  "lodingen.no",
  "lødingen.no",
  "lorenskog.no",
  "lørenskog.no",
  "loten.no",
  "løten.no",
  "malvik.no",
  "masoy.no",
  "måsøy.no",
  "muosat.no",
  "muosát.no",
  "mandal.no",
  "marker.no",
  "marnardal.no",
  "masfjorden.no",
  "meland.no",
  "meldal.no",
  "melhus.no",
  "meloy.no",
  "meløy.no",
  "meraker.no",
  "meråker.no",
  "moareke.no",
  "moåreke.no",
  "midsund.no",
  "midtre-gauldal.no",
  "modalen.no",
  "modum.no",
  "molde.no",
  "moskenes.no",
  "moss.no",
  "mosvik.no",
  "malselv.no",
  "målselv.no",
  "malatvuopmi.no",
  "málatvuopmi.no",
  "namdalseid.no",
  "aejrie.no",
  "namsos.no",
  "namsskogan.no",
  "naamesjevuemie.no",
  "nååmesjevuemie.no",
  "laakesvuemie.no",
  "nannestad.no",
  "narvik.no",
  "narviika.no",
  "naustdal.no",
  "nedre-eiker.no",
  "nes.akershus.no",
  "nes.buskerud.no",
  "nesna.no",
  "nesodden.no",
  "nesseby.no",
  "unjarga.no",
  "unjárga.no",
  "nesset.no",
  "nissedal.no",
  "nittedal.no",
  "nord-aurdal.no",
  "nord-fron.no",
  "nord-odal.no",
  "norddal.no",
  "nordkapp.no",
  "davvenjarga.no",
  "davvenjárga.no",
  "nordre-land.no",
  "nordreisa.no",
  "raisa.no",
  "ráisa.no",
  "nore-og-uvdal.no",
  "notodden.no",
  "naroy.no",
  "nærøy.no",
  "notteroy.no",
  "nøtterøy.no",
  "odda.no",
  "oksnes.no",
  "øksnes.no",
  "oppdal.no",
  "oppegard.no",
  "oppegård.no",
  "orkdal.no",
  "orland.no",
  "ørland.no",
  "orskog.no",
  "ørskog.no",
  "orsta.no",
  "ørsta.no",
  "os.hedmark.no",
  "os.hordaland.no",
  "osen.no",
  "osteroy.no",
  "osterøy.no",
  "ostre-toten.no",
  "østre-toten.no",
  "overhalla.no",
  "ovre-eiker.no",
  "øvre-eiker.no",
  "oyer.no",
  "øyer.no",
  "oygarden.no",
  "øygarden.no",
  "oystre-slidre.no",
  "øystre-slidre.no",
  "porsanger.no",
  "porsangu.no",
  "porsáŋgu.no",
  "porsgrunn.no",
  "radoy.no",
  "radøy.no",
  "rakkestad.no",
  "rana.no",
  "ruovat.no",
  "randaberg.no",
  "rauma.no",
  "rendalen.no",
  "rennebu.no",
  "rennesoy.no",
  "rennesøy.no",
  "rindal.no",
  "ringebu.no",
  "ringerike.no",
  "ringsaker.no",
  "rissa.no",
  "risor.no",
  "risør.no",
  "roan.no",
  "rollag.no",
  "rygge.no",
  "ralingen.no",
  "rælingen.no",
  "rodoy.no",
  "rødøy.no",
  "romskog.no",
  "rømskog.no",
  "roros.no",
  "røros.no",
  "rost.no",
  "røst.no",
  "royken.no",
  "røyken.no",
  "royrvik.no",
  "røyrvik.no",
  "rade.no",
  "råde.no",
  "salangen.no",
  "siellak.no",
  "saltdal.no",
  "salat.no",
  "sálát.no",
  "sálat.no",
  "samnanger.no",
  "sande.more-og-romsdal.no",
  "sande.møre-og-romsdal.no",
  "sande.vestfold.no",
  "sandefjord.no",
  "sandnes.no",
  "sandoy.no",
  "sandøy.no",
  "sarpsborg.no",
  "sauda.no",
  "sauherad.no",
  "sel.no",
  "selbu.no",
  "selje.no",
  "seljord.no",
  "sigdal.no",
  "siljan.no",
  "sirdal.no",
  "skaun.no",
  "skedsmo.no",
  "ski.no",
  "skien.no",
  "skiptvet.no",
  "skjervoy.no",
  "skjervøy.no",
  "skierva.no",
  "skiervá.no",
  "skjak.no",
  "skjåk.no",
  "skodje.no",
  "skanland.no",
  "skånland.no",
  "skanit.no",
  "skánit.no",
  "smola.no",
  "smøla.no",
  "snillfjord.no",
  "snasa.no",
  "snåsa.no",
  "snoasa.no",
  "snaase.no",
  "snåase.no",
  "sogndal.no",
  "sokndal.no",
  "sola.no",
  "solund.no",
  "songdalen.no",
  "sortland.no",
  "spydeberg.no",
  "stange.no",
  "stavanger.no",
  "steigen.no",
  "steinkjer.no",
  "stjordal.no",
  "stjørdal.no",
  "stokke.no",
  "stor-elvdal.no",
  "stord.no",
  "stordal.no",
  "storfjord.no",
  "omasvuotna.no",
  "strand.no",
  "stranda.no",
  "stryn.no",
  "sula.no",
  "suldal.no",
  "sund.no",
  "sunndal.no",
  "surnadal.no",
  "sveio.no",
  "svelvik.no",
  "sykkylven.no",
  "sogne.no",
  "søgne.no",
  "somna.no",
  "sømna.no",
  "sondre-land.no",
  "søndre-land.no",
  "sor-aurdal.no",
  "sør-aurdal.no",
  "sor-fron.no",
  "sør-fron.no",
  "sor-odal.no",
  "sør-odal.no",
  "sor-varanger.no",
  "sør-varanger.no",
  "matta-varjjat.no",
  "mátta-várjjat.no",
  "sorfold.no",
  "sørfold.no",
  "sorreisa.no",
  "sørreisa.no",
  "sorum.no",
  "sørum.no",
  "tana.no",
  "deatnu.no",
  "time.no",
  "tingvoll.no",
  "tinn.no",
  "tjeldsund.no",
  "dielddanuorri.no",
  "tjome.no",
  "tjøme.no",
  "tokke.no",
  "tolga.no",
  "torsken.no",
  "tranoy.no",
  "tranøy.no",
  "tromso.no",
  "tromsø.no",
  "tromsa.no",
  "romsa.no",
  "trondheim.no",
  "troandin.no",
  "trysil.no",
  "trana.no",
  "træna.no",
  "trogstad.no",
  "trøgstad.no",
  "tvedestrand.no",
  "tydal.no",
  "tynset.no",
  "tysfjord.no",
  "divtasvuodna.no",
  "divttasvuotna.no",
  "tysnes.no",
  "tysvar.no",
  "tysvær.no",
  "tonsberg.no",
  "tønsberg.no",
  "ullensaker.no",
  "ullensvang.no",
  "ulvik.no",
  "utsira.no",
  "vadso.no",
  "vadsø.no",
  "cahcesuolo.no",
  "čáhcesuolo.no",
  "vaksdal.no",
  "valle.no",
  "vang.no",
  "vanylven.no",
  "vardo.no",
  "vardø.no",
  "varggat.no",
  "várggát.no",
  "vefsn.no",
  "vaapste.no",
  "vega.no",
  "vegarshei.no",
  "vegårshei.no",
  "vennesla.no",
  "verdal.no",
  "verran.no",
  "vestby.no",
  "vestnes.no",
  "vestre-slidre.no",
  "vestre-toten.no",
  "vestvagoy.no",
  "vestvågøy.no",
  "vevelstad.no",
  "vik.no",
  "vikna.no",
  "vindafjord.no",
  "volda.no",
  "voss.no",
  "varoy.no",
  "værøy.no",
  "vagan.no",
  "vågan.no",
  "voagat.no",
  "vagsoy.no",
  "vågsøy.no",
  "vaga.no",
  "vågå.no",
  "valer.ostfold.no",
  "våler.østfold.no",
  "valer.hedmark.no",
  "våler.hedmark.no",
  "*.np",
  "nr",
  "biz.nr",
  "info.nr",
  "gov.nr",
  "edu.nr",
  "org.nr",
  "net.nr",
  "com.nr",
  "nu",
  "nz",
  "ac.nz",
  "co.nz",
  "cri.nz",
  "geek.nz",
  "gen.nz",
  "govt.nz",
  "health.nz",
  "iwi.nz",
  "kiwi.nz",
  "maori.nz",
  "mil.nz",
  "māori.nz",
  "net.nz",
  "org.nz",
  "parliament.nz",
  "school.nz",
  "om",
  "co.om",
  "com.om",
  "edu.om",
  "gov.om",
  "med.om",
  "museum.om",
  "net.om",
  "org.om",
  "pro.om",
  "onion",
  "org",
  "pa",
  "ac.pa",
  "gob.pa",
  "com.pa",
  "org.pa",
  "sld.pa",
  "edu.pa",
  "net.pa",
  "ing.pa",
  "abo.pa",
  "med.pa",
  "nom.pa",
  "pe",
  "edu.pe",
  "gob.pe",
  "nom.pe",
  "mil.pe",
  "org.pe",
  "com.pe",
  "net.pe",
  "pf",
  "com.pf",
  "org.pf",
  "edu.pf",
  "*.pg",
  "ph",
  "com.ph",
  "net.ph",
  "org.ph",
  "gov.ph",
  "edu.ph",
  "ngo.ph",
  "mil.ph",
  "i.ph",
  "pk",
  "com.pk",
  "net.pk",
  "edu.pk",
  "org.pk",
  "fam.pk",
  "biz.pk",
  "web.pk",
  "gov.pk",
  "gob.pk",
  "gok.pk",
  "gon.pk",
  "gop.pk",
  "gos.pk",
  "info.pk",
  "pl",
  "com.pl",
  "net.pl",
  "org.pl",
  "aid.pl",
  "agro.pl",
  "atm.pl",
  "auto.pl",
  "biz.pl",
  "edu.pl",
  "gmina.pl",
  "gsm.pl",
  "info.pl",
  "mail.pl",
  "miasta.pl",
  "media.pl",
  "mil.pl",
  "nieruchomosci.pl",
  "nom.pl",
  "pc.pl",
  "powiat.pl",
  "priv.pl",
  "realestate.pl",
  "rel.pl",
  "sex.pl",
  "shop.pl",
  "sklep.pl",
  "sos.pl",
  "szkola.pl",
  "targi.pl",
  "tm.pl",
  "tourism.pl",
  "travel.pl",
  "turystyka.pl",
  "gov.pl",
  "ap.gov.pl",
  "ic.gov.pl",
  "is.gov.pl",
  "us.gov.pl",
  "kmpsp.gov.pl",
  "kppsp.gov.pl",
  "kwpsp.gov.pl",
  "psp.gov.pl",
  "wskr.gov.pl",
  "kwp.gov.pl",
  "mw.gov.pl",
  "ug.gov.pl",
  "um.gov.pl",
  "umig.gov.pl",
  "ugim.gov.pl",
  "upow.gov.pl",
  "uw.gov.pl",
  "starostwo.gov.pl",
  "pa.gov.pl",
  "po.gov.pl",
  "psse.gov.pl",
  "pup.gov.pl",
  "rzgw.gov.pl",
  "sa.gov.pl",
  "so.gov.pl",
  "sr.gov.pl",
  "wsa.gov.pl",
  "sko.gov.pl",
  "uzs.gov.pl",
  "wiih.gov.pl",
  "winb.gov.pl",
  "pinb.gov.pl",
  "wios.gov.pl",
  "witd.gov.pl",
  "wzmiuw.gov.pl",
  "piw.gov.pl",
  "wiw.gov.pl",
  "griw.gov.pl",
  "wif.gov.pl",
  "oum.gov.pl",
  "sdn.gov.pl",
  "zp.gov.pl",
  "uppo.gov.pl",
  "mup.gov.pl",
  "wuoz.gov.pl",
  "konsulat.gov.pl",
  "oirm.gov.pl",
  "augustow.pl",
  "babia-gora.pl",
  "bedzin.pl",
  "beskidy.pl",
  "bialowieza.pl",
  "bialystok.pl",
  "bielawa.pl",
  "bieszczady.pl",
  "boleslawiec.pl",
  "bydgoszcz.pl",
  "bytom.pl",
  "cieszyn.pl",
  "czeladz.pl",
  "czest.pl",
  "dlugoleka.pl",
  "elblag.pl",
  "elk.pl",
  "glogow.pl",
  "gniezno.pl",
  "gorlice.pl",
  "grajewo.pl",
  "ilawa.pl",
  "jaworzno.pl",
  "jelenia-gora.pl",
  "jgora.pl",
  "kalisz.pl",
  "kazimierz-dolny.pl",
  "karpacz.pl",
  "kartuzy.pl",
  "kaszuby.pl",
  "katowice.pl",
  "kepno.pl",
  "ketrzyn.pl",
  "klodzko.pl",
  "kobierzyce.pl",
  "kolobrzeg.pl",
  "konin.pl",
  "konskowola.pl",
  "kutno.pl",
  "lapy.pl",
  "lebork.pl",
  "legnica.pl",
  "lezajsk.pl",
  "limanowa.pl",
  "lomza.pl",
  "lowicz.pl",
  "lubin.pl",
  "lukow.pl",
  "malbork.pl",
  "malopolska.pl",
  "mazowsze.pl",
  "mazury.pl",
  "mielec.pl",
  "mielno.pl",
  "mragowo.pl",
  "naklo.pl",
  "nowaruda.pl",
  "nysa.pl",
  "olawa.pl",
  "olecko.pl",
  "olkusz.pl",
  "olsztyn.pl",
  "opoczno.pl",
  "opole.pl",
  "ostroda.pl",
  "ostroleka.pl",
  "ostrowiec.pl",
  "ostrowwlkp.pl",
  "pila.pl",
  "pisz.pl",
  "podhale.pl",
  "podlasie.pl",
  "polkowice.pl",
  "pomorze.pl",
  "pomorskie.pl",
  "prochowice.pl",
  "pruszkow.pl",
  "przeworsk.pl",
  "pulawy.pl",
  "radom.pl",
  "rawa-maz.pl",
  "rybnik.pl",
  "rzeszow.pl",
  "sanok.pl",
  "sejny.pl",
  "slask.pl",
  "slupsk.pl",
  "sosnowiec.pl",
  "stalowa-wola.pl",
  "skoczow.pl",
  "starachowice.pl",
  "stargard.pl",
  "suwalki.pl",
  "swidnica.pl",
  "swiebodzin.pl",
  "swinoujscie.pl",
  "szczecin.pl",
  "szczytno.pl",
  "tarnobrzeg.pl",
  "tgory.pl",
  "turek.pl",
  "tychy.pl",
  "ustka.pl",
  "walbrzych.pl",
  "warmia.pl",
  "warszawa.pl",
  "waw.pl",
  "wegrow.pl",
  "wielun.pl",
  "wlocl.pl",
  "wloclawek.pl",
  "wodzislaw.pl",
  "wolomin.pl",
  "wroclaw.pl",
  "zachpomor.pl",
  "zagan.pl",
  "zarow.pl",
  "zgora.pl",
  "zgorzelec.pl",
  "pm",
  "pn",
  "gov.pn",
  "co.pn",
  "org.pn",
  "edu.pn",
  "net.pn",
  "post",
  "pr",
  "com.pr",
  "net.pr",
  "org.pr",
  "gov.pr",
  "edu.pr",
  "isla.pr",
  "pro.pr",
  "biz.pr",
  "info.pr",
  "name.pr",
  "est.pr",
  "prof.pr",
  "ac.pr",
  "pro",
  "aaa.pro",
  "aca.pro",
  "acct.pro",
  "avocat.pro",
  "bar.pro",
  "cpa.pro",
  "eng.pro",
  "jur.pro",
  "law.pro",
  "med.pro",
  "recht.pro",
  "ps",
  "edu.ps",
  "gov.ps",
  "sec.ps",
  "plo.ps",
  "com.ps",
  "org.ps",
  "net.ps",
  "pt",
  "net.pt",
  "gov.pt",
  "org.pt",
  "edu.pt",
  "int.pt",
  "publ.pt",
  "com.pt",
  "nome.pt",
  "pw",
  "co.pw",
  "ne.pw",
  "or.pw",
  "ed.pw",
  "go.pw",
  "belau.pw",
  "py",
  "com.py",
  "coop.py",
  "edu.py",
  "gov.py",
  "mil.py",
  "net.py",
  "org.py",
  "qa",
  "com.qa",
  "edu.qa",
  "gov.qa",
  "mil.qa",
  "name.qa",
  "net.qa",
  "org.qa",
  "sch.qa",
  "re",
  "asso.re",
  "com.re",
  "nom.re",
  "ro",
  "arts.ro",
  "com.ro",
  "firm.ro",
  "info.ro",
  "nom.ro",
  "nt.ro",
  "org.ro",
  "rec.ro",
  "store.ro",
  "tm.ro",
  "www.ro",
  "rs",
  "ac.rs",
  "co.rs",
  "edu.rs",
  "gov.rs",
  "in.rs",
  "org.rs",
  "ru",
  "rw",
  "ac.rw",
  "co.rw",
  "coop.rw",
  "gov.rw",
  "mil.rw",
  "net.rw",
  "org.rw",
  "sa",
  "com.sa",
  "net.sa",
  "org.sa",
  "gov.sa",
  "med.sa",
  "pub.sa",
  "edu.sa",
  "sch.sa",
  "sb",
  "com.sb",
  "edu.sb",
  "gov.sb",
  "net.sb",
  "org.sb",
  "sc",
  "com.sc",
  "gov.sc",
  "net.sc",
  "org.sc",
  "edu.sc",
  "sd",
  "com.sd",
  "net.sd",
  "org.sd",
  "edu.sd",
  "med.sd",
  "tv.sd",
  "gov.sd",
  "info.sd",
  "se",
  "a.se",
  "ac.se",
  "b.se",
  "bd.se",
  "brand.se",
  "c.se",
  "d.se",
  "e.se",
  "f.se",
  "fh.se",
  "fhsk.se",
  "fhv.se",
  "g.se",
  "h.se",
  "i.se",
  "k.se",
  "komforb.se",
  "kommunalforbund.se",
  "komvux.se",
  "l.se",
  "lanbib.se",
  "m.se",
  "n.se",
  "naturbruksgymn.se",
  "o.se",
  "org.se",
  "p.se",
  "parti.se",
  "pp.se",
  "press.se",
  "r.se",
  "s.se",
  "t.se",
  "tm.se",
  "u.se",
  "w.se",
  "x.se",
  "y.se",
  "z.se",
  "sg",
  "com.sg",
  "net.sg",
  "org.sg",
  "gov.sg",
  "edu.sg",
  "per.sg",
  "sh",
  "com.sh",
  "net.sh",
  "gov.sh",
  "org.sh",
  "mil.sh",
  "si",
  "sj",
  "sk",
  "sl",
  "com.sl",
  "net.sl",
  "edu.sl",
  "gov.sl",
  "org.sl",
  "sm",
  "sn",
  "art.sn",
  "com.sn",
  "edu.sn",
  "gouv.sn",
  "org.sn",
  "perso.sn",
  "univ.sn",
  "so",
  "com.so",
  "edu.so",
  "gov.so",
  "me.so",
  "net.so",
  "org.so",
  "sr",
  "ss",
  "biz.ss",
  "com.ss",
  "edu.ss",
  "gov.ss",
  "me.ss",
  "net.ss",
  "org.ss",
  "sch.ss",
  "st",
  "co.st",
  "com.st",
  "consulado.st",
  "edu.st",
  "embaixada.st",
  "mil.st",
  "net.st",
  "org.st",
  "principe.st",
  "saotome.st",
  "store.st",
  "su",
  "sv",
  "com.sv",
  "edu.sv",
  "gob.sv",
  "org.sv",
  "red.sv",
  "sx",
  "gov.sx",
  "sy",
  "edu.sy",
  "gov.sy",
  "net.sy",
  "mil.sy",
  "com.sy",
  "org.sy",
  "sz",
  "co.sz",
  "ac.sz",
  "org.sz",
  "tc",
  "td",
  "tel",
  "tf",
  "tg",
  "th",
  "ac.th",
  "co.th",
  "go.th",
  "in.th",
  "mi.th",
  "net.th",
  "or.th",
  "tj",
  "ac.tj",
  "biz.tj",
  "co.tj",
  "com.tj",
  "edu.tj",
  "go.tj",
  "gov.tj",
  "int.tj",
  "mil.tj",
  "name.tj",
  "net.tj",
  "nic.tj",
  "org.tj",
  "test.tj",
  "web.tj",
  "tk",
  "tl",
  "gov.tl",
  "tm",
  "com.tm",
  "co.tm",
  "org.tm",
  "net.tm",
  "nom.tm",
  "gov.tm",
  "mil.tm",
  "edu.tm",
  "tn",
  "com.tn",
  "ens.tn",
  "fin.tn",
  "gov.tn",
  "ind.tn",
  "info.tn",
  "intl.tn",
  "mincom.tn",
  "nat.tn",
  "net.tn",
  "org.tn",
  "perso.tn",
  "tourism.tn",
  "to",
  "com.to",
  "gov.to",
  "net.to",
  "org.to",
  "edu.to",
  "mil.to",
  "tr",
  "av.tr",
  "bbs.tr",
  "bel.tr",
  "biz.tr",
  "com.tr",
  "dr.tr",
  "edu.tr",
  "gen.tr",
  "gov.tr",
  "info.tr",
  "mil.tr",
  "k12.tr",
  "kep.tr",
  "name.tr",
  "net.tr",
  "org.tr",
  "pol.tr",
  "tel.tr",
  "tsk.tr",
  "tv.tr",
  "web.tr",
  "nc.tr",
  "gov.nc.tr",
  "tt",
  "co.tt",
  "com.tt",
  "org.tt",
  "net.tt",
  "biz.tt",
  "info.tt",
  "pro.tt",
  "int.tt",
  "coop.tt",
  "jobs.tt",
  "mobi.tt",
  "travel.tt",
  "museum.tt",
  "aero.tt",
  "name.tt",
  "gov.tt",
  "edu.tt",
  "tv",
  "tw",
  "edu.tw",
  "gov.tw",
  "mil.tw",
  "com.tw",
  "net.tw",
  "org.tw",
  "idv.tw",
  "game.tw",
  "ebiz.tw",
  "club.tw",
  "網路.tw",
  "組織.tw",
  "商業.tw",
  "tz",
  "ac.tz",
  "co.tz",
  "go.tz",
  "hotel.tz",
  "info.tz",
  "me.tz",
  "mil.tz",
  "mobi.tz",
  "ne.tz",
  "or.tz",
  "sc.tz",
  "tv.tz",
  "ua",
  "com.ua",
  "edu.ua",
  "gov.ua",
  "in.ua",
  "net.ua",
  "org.ua",
  "cherkassy.ua",
  "cherkasy.ua",
  "chernigov.ua",
  "chernihiv.ua",
  "chernivtsi.ua",
  "chernovtsy.ua",
  "ck.ua",
  "cn.ua",
  "cr.ua",
  "crimea.ua",
  "cv.ua",
  "dn.ua",
  "dnepropetrovsk.ua",
  "dnipropetrovsk.ua",
  "donetsk.ua",
  "dp.ua",
  "if.ua",
  "ivano-frankivsk.ua",
  "kh.ua",
  "kharkiv.ua",
  "kharkov.ua",
  "kherson.ua",
  "khmelnitskiy.ua",
  "khmelnytskyi.ua",
  "kiev.ua",
  "kirovograd.ua",
  "km.ua",
  "kr.ua",
  "krym.ua",
  "ks.ua",
  "kv.ua",
  "kyiv.ua",
  "lg.ua",
  "lt.ua",
  "lugansk.ua",
  "lutsk.ua",
  "lv.ua",
  "lviv.ua",
  "mk.ua",
  "mykolaiv.ua",
  "nikolaev.ua",
  "od.ua",
  "odesa.ua",
  "odessa.ua",
  "pl.ua",
  "poltava.ua",
  "rivne.ua",
  "rovno.ua",
  "rv.ua",
  "sb.ua",
  "sebastopol.ua",
  "sevastopol.ua",
  "sm.ua",
  "sumy.ua",
  "te.ua",
  "ternopil.ua",
  "uz.ua",
  "uzhgorod.ua",
  "vinnica.ua",
  "vinnytsia.ua",
  "vn.ua",
  "volyn.ua",
  "yalta.ua",
  "zaporizhzhe.ua",
  "zaporizhzhia.ua",
  "zhitomir.ua",
  "zhytomyr.ua",
  "zp.ua",
  "zt.ua",
  "ug",
  "co.ug",
  "or.ug",
  "ac.ug",
  "sc.ug",
  "go.ug",
  "ne.ug",
  "com.ug",
  "org.ug",
  "uk",
  "ac.uk",
  "co.uk",
  "gov.uk",
  "ltd.uk",
  "me.uk",
  "net.uk",
  "nhs.uk",
  "org.uk",
  "plc.uk",
  "police.uk",
  "*.sch.uk",
  "us",
  "dni.us",
  "fed.us",
  "isa.us",
  "kids.us",
  "nsn.us",
  "ak.us",
  "al.us",
  "ar.us",
  "as.us",
  "az.us",
  "ca.us",
  "co.us",
  "ct.us",
  "dc.us",
  "de.us",
  "fl.us",
  "ga.us",
  "gu.us",
  "hi.us",
  "ia.us",
  "id.us",
  "il.us",
  "in.us",
  "ks.us",
  "ky.us",
  "la.us",
  "ma.us",
  "md.us",
  "me.us",
  "mi.us",
  "mn.us",
  "mo.us",
  "ms.us",
  "mt.us",
  "nc.us",
  "nd.us",
  "ne.us",
  "nh.us",
  "nj.us",
  "nm.us",
  "nv.us",
  "ny.us",
  "oh.us",
  "ok.us",
  "or.us",
  "pa.us",
  "pr.us",
  "ri.us",
  "sc.us",
  "sd.us",
  "tn.us",
  "tx.us",
  "ut.us",
  "vi.us",
  "vt.us",
  "va.us",
  "wa.us",
  "wi.us",
  "wv.us",
  "wy.us",
  "k12.ak.us",
  "k12.al.us",
  "k12.ar.us",
  "k12.as.us",
  "k12.az.us",
  "k12.ca.us",
  "k12.co.us",
  "k12.ct.us",
  "k12.dc.us",
  "k12.de.us",
  "k12.fl.us",
  "k12.ga.us",
  "k12.gu.us",
  "k12.ia.us",
  "k12.id.us",
  "k12.il.us",
  "k12.in.us",
  "k12.ks.us",
  "k12.ky.us",
  "k12.la.us",
  "k12.ma.us",
  "k12.md.us",
  "k12.me.us",
  "k12.mi.us",
  "k12.mn.us",
  "k12.mo.us",
  "k12.ms.us",
  "k12.mt.us",
  "k12.nc.us",
  "k12.ne.us",
  "k12.nh.us",
  "k12.nj.us",
  "k12.nm.us",
  "k12.nv.us",
  "k12.ny.us",
  "k12.oh.us",
  "k12.ok.us",
  "k12.or.us",
  "k12.pa.us",
  "k12.pr.us",
  "k12.sc.us",
  "k12.tn.us",
  "k12.tx.us",
  "k12.ut.us",
  "k12.vi.us",
  "k12.vt.us",
  "k12.va.us",
  "k12.wa.us",
  "k12.wi.us",
  "k12.wy.us",
  "cc.ak.us",
  "cc.al.us",
  "cc.ar.us",
  "cc.as.us",
  "cc.az.us",
  "cc.ca.us",
  "cc.co.us",
  "cc.ct.us",
  "cc.dc.us",
  "cc.de.us",
  "cc.fl.us",
  "cc.ga.us",
  "cc.gu.us",
  "cc.hi.us",
  "cc.ia.us",
  "cc.id.us",
  "cc.il.us",
  "cc.in.us",
  "cc.ks.us",
  "cc.ky.us",
  "cc.la.us",
  "cc.ma.us",
  "cc.md.us",
  "cc.me.us",
  "cc.mi.us",
  "cc.mn.us",
  "cc.mo.us",
  "cc.ms.us",
  "cc.mt.us",
  "cc.nc.us",
  "cc.nd.us",
  "cc.ne.us",
  "cc.nh.us",
  "cc.nj.us",
  "cc.nm.us",
  "cc.nv.us",
  "cc.ny.us",
  "cc.oh.us",
  "cc.ok.us",
  "cc.or.us",
  "cc.pa.us",
  "cc.pr.us",
  "cc.ri.us",
  "cc.sc.us",
  "cc.sd.us",
  "cc.tn.us",
  "cc.tx.us",
  "cc.ut.us",
  "cc.vi.us",
  "cc.vt.us",
  "cc.va.us",
  "cc.wa.us",
  "cc.wi.us",
  "cc.wv.us",
  "cc.wy.us",
  "lib.ak.us",
  "lib.al.us",
  "lib.ar.us",
  "lib.as.us",
  "lib.az.us",
  "lib.ca.us",
  "lib.co.us",
  "lib.ct.us",
  "lib.dc.us",
  "lib.fl.us",
  "lib.ga.us",
  "lib.gu.us",
  "lib.hi.us",
  "lib.ia.us",
  "lib.id.us",
  "lib.il.us",
  "lib.in.us",
  "lib.ks.us",
  "lib.ky.us",
  "lib.la.us",
  "lib.ma.us",
  "lib.md.us",
  "lib.me.us",
  "lib.mi.us",
  "lib.mn.us",
  "lib.mo.us",
  "lib.ms.us",
  "lib.mt.us",
  "lib.nc.us",
  "lib.nd.us",
  "lib.ne.us",
  "lib.nh.us",
  "lib.nj.us",
  "lib.nm.us",
  "lib.nv.us",
  "lib.ny.us",
  "lib.oh.us",
  "lib.ok.us",
  "lib.or.us",
  "lib.pa.us",
  "lib.pr.us",
  "lib.ri.us",
  "lib.sc.us",
  "lib.sd.us",
  "lib.tn.us",
  "lib.tx.us",
  "lib.ut.us",
  "lib.vi.us",
  "lib.vt.us",
  "lib.va.us",
  "lib.wa.us",
  "lib.wi.us",
  "lib.wy.us",
  "pvt.k12.ma.us",
  "chtr.k12.ma.us",
  "paroch.k12.ma.us",
  "ann-arbor.mi.us",
  "cog.mi.us",
  "dst.mi.us",
  "eaton.mi.us",
  "gen.mi.us",
  "mus.mi.us",
  "tec.mi.us",
  "washtenaw.mi.us",
  "uy",
  "com.uy",
  "edu.uy",
  "gub.uy",
  "mil.uy",
  "net.uy",
  "org.uy",
  "uz",
  "co.uz",
  "com.uz",
  "net.uz",
  "org.uz",
  "va",
  "vc",
  "com.vc",
  "net.vc",
  "org.vc",
  "gov.vc",
  "mil.vc",
  "edu.vc",
  "ve",
  "arts.ve",
  "bib.ve",
  "co.ve",
  "com.ve",
  "e12.ve",
  "edu.ve",
  "firm.ve",
  "gob.ve",
  "gov.ve",
  "info.ve",
  "int.ve",
  "mil.ve",
  "net.ve",
  "nom.ve",
  "org.ve",
  "rar.ve",
  "rec.ve",
  "store.ve",
  "tec.ve",
  "web.ve",
  "vg",
  "vi",
  "co.vi",
  "com.vi",
  "k12.vi",
  "net.vi",
  "org.vi",
  "vn",
  "com.vn",
  "net.vn",
  "org.vn",
  "edu.vn",
  "gov.vn",
  "int.vn",
  "ac.vn",
  "biz.vn",
  "info.vn",
  "name.vn",
  "pro.vn",
  "health.vn",
  "vu",
  "com.vu",
  "edu.vu",
  "net.vu",
  "org.vu",
  "wf",
  "ws",
  "com.ws",
  "net.ws",
  "org.ws",
  "gov.ws",
  "edu.ws",
  "yt",
  "امارات",
  "հայ",
  "বাংলা",
  "бг",
  "البحرين",
  "бел",
  "中国",
  "中國",
  "الجزائر",
  "مصر",
  "ею",
  "ευ",
  "موريتانيا",
  "გე",
  "ελ",
  "香港",
  "公司.香港",
  "教育.香港",
  "政府.香港",
  "個人.香港",
  "網絡.香港",
  "組織.香港",
  "ಭಾರತ",
  "ଭାରତ",
  "ভাৰত",
  "भारतम्",
  "भारोत",
  "ڀارت",
  "ഭാരതം",
  "भारत",
  "بارت",
  "بھارت",
  "భారత్",
  "ભારત",
  "ਭਾਰਤ",
  "ভারত",
  "இந்தியா",
  "ایران",
  "ايران",
  "عراق",
  "الاردن",
  "한국",
  "қаз",
  "ລາວ",
  "ලංකා",
  "இலங்கை",
  "المغرب",
  "мкд",
  "мон",
  "澳門",
  "澳门",
  "مليسيا",
  "عمان",
  "پاکستان",
  "پاكستان",
  "فلسطين",
  "срб",
  "пр.срб",
  "орг.срб",
  "обр.срб",
  "од.срб",
  "упр.срб",
  "ак.срб",
  "рф",
  "قطر",
  "السعودية",
  "السعودیة",
  "السعودیۃ",
  "السعوديه",
  "سودان",
  "新加坡",
  "சிங்கப்பூர்",
  "سورية",
  "سوريا",
  "ไทย",
  "ศึกษา.ไทย",
  "ธุรกิจ.ไทย",
  "รัฐบาล.ไทย",
  "ทหาร.ไทย",
  "เน็ต.ไทย",
  "องค์กร.ไทย",
  "تونس",
  "台灣",
  "台湾",
  "臺灣",
  "укр",
  "اليمن",
  "xxx",
  "ye",
  "com.ye",
  "edu.ye",
  "gov.ye",
  "net.ye",
  "mil.ye",
  "org.ye",
  "ac.za",
  "agric.za",
  "alt.za",
  "co.za",
  "edu.za",
  "gov.za",
  "grondar.za",
  "law.za",
  "mil.za",
  "net.za",
  "ngo.za",
  "nic.za",
  "nis.za",
  "nom.za",
  "org.za",
  "school.za",
  "tm.za",
  "web.za",
  "zm",
  "ac.zm",
  "biz.zm",
  "co.zm",
  "com.zm",
  "edu.zm",
  "gov.zm",
  "info.zm",
  "mil.zm",
  "net.zm",
  "org.zm",
  "sch.zm",
  "zw",
  "ac.zw",
  "co.zw",
  "gov.zw",
  "mil.zw",
  "org.zw",
  "aaa",
  "aarp",
  "abarth",
  "abb",
  "abbott",
  "abbvie",
  "abc",
  "able",
  "abogado",
  "abudhabi",
  "academy",
  "accenture",
  "accountant",
  "accountants",
  "aco",
  "actor",
  "adac",
  "ads",
  "adult",
  "aeg",
  "aetna",
  "afl",
  "africa",
  "agakhan",
  "agency",
  "aig",
  "airbus",
  "airforce",
  "airtel",
  "akdn",
  "alfaromeo",
  "alibaba",
  "alipay",
  "allfinanz",
  "allstate",
  "ally",
  "alsace",
  "alstom",
  "amazon",
  "americanexpress",
  "americanfamily",
  "amex",
  "amfam",
  "amica",
  "amsterdam",
  "analytics",
  "android",
  "anquan",
  "anz",
  "aol",
  "apartments",
  "app",
  "apple",
  "aquarelle",
  "arab",
  "aramco",
  "archi",
  "army",
  "art",
  "arte",
  "asda",
  "associates",
  "athleta",
  "attorney",
  "auction",
  "audi",
  "audible",
  "audio",
  "auspost",
  "author",
  "auto",
  "autos",
  "avianca",
  "aws",
  "axa",
  "azure",
  "baby",
  "baidu",
  "banamex",
  "bananarepublic",
  "band",
  "bank",
  "bar",
  "barcelona",
  "barclaycard",
  "barclays",
  "barefoot",
  "bargains",
  "baseball",
  "basketball",
  "bauhaus",
  "bayern",
  "bbc",
  "bbt",
  "bbva",
  "bcg",
  "bcn",
  "beats",
  "beauty",
  "beer",
  "bentley",
  "berlin",
  "best",
  "bestbuy",
  "bet",
  "bharti",
  "bible",
  "bid",
  "bike",
  "bing",
  "bingo",
  "bio",
  "black",
  "blackfriday",
  "blockbuster",
  "blog",
  "bloomberg",
  "blue",
  "bms",
  "bmw",
  "bnpparibas",
  "boats",
  "boehringer",
  "bofa",
  "bom",
  "bond",
  "boo",
  "book",
  "booking",
  "bosch",
  "bostik",
  "boston",
  "bot",
  "boutique",
  "box",
  "bradesco",
  "bridgestone",
  "broadway",
  "broker",
  "brother",
  "brussels",
  "bugatti",
  "build",
  "builders",
  "business",
  "buy",
  "buzz",
  "bzh",
  "cab",
  "cafe",
  "cal",
  "call",
  "calvinklein",
  "cam",
  "camera",
  "camp",
  "cancerresearch",
  "canon",
  "capetown",
  "capital",
  "capitalone",
  "car",
  "caravan",
  "cards",
  "care",
  "career",
  "careers",
  "cars",
  "casa",
  "case",
  "cash",
  "casino",
  "catering",
  "catholic",
  "cba",
  "cbn",
  "cbre",
  "cbs",
  "center",
  "ceo",
  "cern",
  "cfa",
  "cfd",
  "chanel",
  "channel",
  "charity",
  "chase",
  "chat",
  "cheap",
  "chintai",
  "christmas",
  "chrome",
  "church",
  "cipriani",
  "circle",
  "cisco",
  "citadel",
  "citi",
  "citic",
  "city",
  "cityeats",
  "claims",
  "cleaning",
  "click",
  "clinic",
  "clinique",
  "clothing",
  "cloud",
  "club",
  "clubmed",
  "coach",
  "codes",
  "coffee",
  "college",
  "cologne",
  "comcast",
  "commbank",
  "community",
  "company",
  "compare",
  "computer",
  "comsec",
  "condos",
  "construction",
  "consulting",
  "contact",
  "contractors",
  "cooking",
  "cookingchannel",
  "cool",
  "corsica",
  "country",
  "coupon",
  "coupons",
  "courses",
  "cpa",
  "credit",
  "creditcard",
  "creditunion",
  "cricket",
  "crown",
  "crs",
  "cruise",
  "cruises",
  "cuisinella",
  "cymru",
  "cyou",
  "dabur",
  "dad",
  "dance",
  "data",
  "date",
  "dating",
  "datsun",
  "day",
  "dclk",
  "dds",
  "deal",
  "dealer",
  "deals",
  "degree",
  "delivery",
  "dell",
  "deloitte",
  "delta",
  "democrat",
  "dental",
  "dentist",
  "desi",
  "design",
  "dev",
  "dhl",
  "diamonds",
  "diet",
  "digital",
  "direct",
  "directory",
  "discount",
  "discover",
  "dish",
  "diy",
  "dnp",
  "docs",
  "doctor",
  "dog",
  "domains",
  "dot",
  "download",
  "drive",
  "dtv",
  "dubai",
  "dunlop",
  "dupont",
  "durban",
  "dvag",
  "dvr",
  "earth",
  "eat",
  "eco",
  "edeka",
  "education",
  "email",
  "emerck",
  "energy",
  "engineer",
  "engineering",
  "enterprises",
  "epson",
  "equipment",
  "ericsson",
  "erni",
  "esq",
  "estate",
  "etisalat",
  "eurovision",
  "eus",
  "events",
  "exchange",
  "expert",
  "exposed",
  "express",
  "extraspace",
  "fage",
  "fail",
  "fairwinds",
  "faith",
  "family",
  "fan",
  "fans",
  "farm",
  "farmers",
  "fashion",
  "fast",
  "fedex",
  "feedback",
  "ferrari",
  "ferrero",
  "fiat",
  "fidelity",
  "fido",
  "film",
  "final",
  "finance",
  "financial",
  "fire",
  "firestone",
  "firmdale",
  "fish",
  "fishing",
  "fit",
  "fitness",
  "flickr",
  "flights",
  "flir",
  "florist",
  "flowers",
  "fly",
  "foo",
  "food",
  "foodnetwork",
  "football",
  "ford",
  "forex",
  "forsale",
  "forum",
  "foundation",
  "fox",
  "free",
  "fresenius",
  "frl",
  "frogans",
  "frontdoor",
  "frontier",
  "ftr",
  "fujitsu",
  "fun",
  "fund",
  "furniture",
  "futbol",
  "fyi",
  "gal",
  "gallery",
  "gallo",
  "gallup",
  "game",
  "games",
  "gap",
  "garden",
  "gay",
  "gbiz",
  "gdn",
  "gea",
  "gent",
  "genting",
  "george",
  "ggee",
  "gift",
  "gifts",
  "gives",
  "giving",
  "glass",
  "gle",
  "global",
  "globo",
  "gmail",
  "gmbh",
  "gmo",
  "gmx",
  "godaddy",
  "gold",
  "goldpoint",
  "golf",
  "goo",
  "goodyear",
  "goog",
  "google",
  "gop",
  "got",
  "grainger",
  "graphics",
  "gratis",
  "green",
  "gripe",
  "grocery",
  "group",
  "guardian",
  "gucci",
  "guge",
  "guide",
  "guitars",
  "guru",
  "hair",
  "hamburg",
  "hangout",
  "haus",
  "hbo",
  "hdfc",
  "hdfcbank",
  "health",
  "healthcare",
  "help",
  "helsinki",
  "here",
  "hermes",
  "hgtv",
  "hiphop",
  "hisamitsu",
  "hitachi",
  "hiv",
  "hkt",
  "hockey",
  "holdings",
  "holiday",
  "homedepot",
  "homegoods",
  "homes",
  "homesense",
  "honda",
  "horse",
  "hospital",
  "host",
  "hosting",
  "hot",
  "hoteles",
  "hotels",
  "hotmail",
  "house",
  "how",
  "hsbc",
  "hughes",
  "hyatt",
  "hyundai",
  "ibm",
  "icbc",
  "ice",
  "icu",
  "ieee",
  "ifm",
  "ikano",
  "imamat",
  "imdb",
  "immo",
  "immobilien",
  "inc",
  "industries",
  "infiniti",
  "ing",
  "ink",
  "institute",
  "insurance",
  "insure",
  "international",
  "intuit",
  "investments",
  "ipiranga",
  "irish",
  "ismaili",
  "ist",
  "istanbul",
  "itau",
  "itv",
  "jaguar",
  "java",
  "jcb",
  "jeep",
  "jetzt",
  "jewelry",
  "jio",
  "jll",
  "jmp",
  "jnj",
  "joburg",
  "jot",
  "joy",
  "jpmorgan",
  "jprs",
  "juegos",
  "juniper",
  "kaufen",
  "kddi",
  "kerryhotels",
  "kerrylogistics",
  "kerryproperties",
  "kfh",
  "kia",
  "kids",
  "kim",
  "kinder",
  "kindle",
  "kitchen",
  "kiwi",
  "koeln",
  "komatsu",
  "kosher",
  "kpmg",
  "kpn",
  "krd",
  "kred",
  "kuokgroup",
  "kyoto",
  "lacaixa",
  "lamborghini",
  "lamer",
  "lancaster",
  "lancia",
  "land",
  "landrover",
  "lanxess",
  "lasalle",
  "lat",
  "latino",
  "latrobe",
  "law",
  "lawyer",
  "lds",
  "lease",
  "leclerc",
  "lefrak",
  "legal",
  "lego",
  "lexus",
  "lgbt",
  "lidl",
  "life",
  "lifeinsurance",
  "lifestyle",
  "lighting",
  "like",
  "lilly",
  "limited",
  "limo",
  "lincoln",
  "linde",
  "link",
  "lipsy",
  "live",
  "living",
  "llc",
  "llp",
  "loan",
  "loans",
  "locker",
  "locus",
  "loft",
  "lol",
  "london",
  "lotte",
  "lotto",
  "love",
  "lpl",
  "lplfinancial",
  "ltd",
  "ltda",
  "lundbeck",
  "luxe",
  "luxury",
  "macys",
  "madrid",
  "maif",
  "maison",
  "makeup",
  "man",
  "management",
  "mango",
  "map",
  "market",
  "marketing",
  "markets",
  "marriott",
  "marshalls",
  "maserati",
  "mattel",
  "mba",
  "mckinsey",
  "med",
  "media",
  "meet",
  "melbourne",
  "meme",
  "memorial",
  "men",
  "menu",
  "merckmsd",
  "miami",
  "microsoft",
  "mini",
  "mint",
  "mit",
  "mitsubishi",
  "mlb",
  "mls",
  "mma",
  "mobile",
  "moda",
  "moe",
  "moi",
  "mom",
  "monash",
  "money",
  "monster",
  "mormon",
  "mortgage",
  "moscow",
  "moto",
  "motorcycles",
  "mov",
  "movie",
  "msd",
  "mtn",
  "mtr",
  "music",
  "mutual",
  "nab",
  "nagoya",
  "natura",
  "navy",
  "nba",
  "nec",
  "netbank",
  "netflix",
  "network",
  "neustar",
  "new",
  "news",
  "next",
  "nextdirect",
  "nexus",
  "nfl",
  "ngo",
  "nhk",
  "nico",
  "nike",
  "nikon",
  "ninja",
  "nissan",
  "nissay",
  "nokia",
  "northwesternmutual",
  "norton",
  "now",
  "nowruz",
  "nowtv",
  "nra",
  "nrw",
  "ntt",
  "nyc",
  "obi",
  "observer",
  "office",
  "okinawa",
  "olayan",
  "olayangroup",
  "oldnavy",
  "ollo",
  "omega",
  "one",
  "ong",
  "onl",
  "online",
  "ooo",
  "open",
  "oracle",
  "orange",
  "organic",
  "origins",
  "osaka",
  "otsuka",
  "ott",
  "ovh",
  "page",
  "panasonic",
  "paris",
  "pars",
  "partners",
  "parts",
  "party",
  "passagens",
  "pay",
  "pccw",
  "pet",
  "pfizer",
  "pharmacy",
  "phd",
  "philips",
  "phone",
  "photo",
  "photography",
  "photos",
  "physio",
  "pics",
  "pictet",
  "pictures",
  "pid",
  "pin",
  "ping",
  "pink",
  "pioneer",
  "pizza",
  "place",
  "play",
  "playstation",
  "plumbing",
  "plus",
  "pnc",
  "pohl",
  "poker",
  "politie",
  "porn",
  "pramerica",
  "praxi",
  "press",
  "prime",
  "prod",
  "productions",
  "prof",
  "progressive",
  "promo",
  "properties",
  "property",
  "protection",
  "pru",
  "prudential",
  "pub",
  "pwc",
  "qpon",
  "quebec",
  "quest",
  "racing",
  "radio",
  "read",
  "realestate",
  "realtor",
  "realty",
  "recipes",
  "red",
  "redstone",
  "redumbrella",
  "rehab",
  "reise",
  "reisen",
  "reit",
  "reliance",
  "ren",
  "rent",
  "rentals",
  "repair",
  "report",
  "republican",
  "rest",
  "restaurant",
  "review",
  "reviews",
  "rexroth",
  "rich",
  "richardli",
  "ricoh",
  "ril",
  "rio",
  "rip",
  "rocher",
  "rocks",
  "rodeo",
  "rogers",
  "room",
  "rsvp",
  "rugby",
  "ruhr",
  "run",
  "rwe",
  "ryukyu",
  "saarland",
  "safe",
  "safety",
  "sakura",
  "sale",
  "salon",
  "samsclub",
  "samsung",
  "sandvik",
  "sandvikcoromant",
  "sanofi",
  "sap",
  "sarl",
  "sas",
  "save",
  "saxo",
  "sbi",
  "sbs",
  "sca",
  "scb",
  "schaeffler",
  "schmidt",
  "scholarships",
  "school",
  "schule",
  "schwarz",
  "science",
  "scot",
  "search",
  "seat",
  "secure",
  "security",
  "seek",
  "select",
  "sener",
  "services",
  "ses",
  "seven",
  "sew",
  "sex",
  "sexy",
  "sfr",
  "shangrila",
  "sharp",
  "shaw",
  "shell",
  "shia",
  "shiksha",
  "shoes",
  "shop",
  "shopping",
  "shouji",
  "show",
  "showtime",
  "silk",
  "sina",
  "singles",
  "site",
  "ski",
  "skin",
  "sky",
  "skype",
  "sling",
  "smart",
  "smile",
  "sncf",
  "soccer",
  "social",
  "softbank",
  "software",
  "sohu",
  "solar",
  "solutions",
  "song",
  "sony",
  "soy",
  "spa",
  "space",
  "sport",
  "spot",
  "srl",
  "stada",
  "staples",
  "star",
  "statebank",
  "statefarm",
  "stc",
  "stcgroup",
  "stockholm",
  "storage",
  "store",
  "stream",
  "studio",
  "study",
  "style",
  "sucks",
  "supplies",
  "supply",
  "support",
  "surf",
  "surgery",
  "suzuki",
  "swatch",
  "swiss",
  "sydney",
  "systems",
  "tab",
  "taipei",
  "talk",
  "taobao",
  "target",
  "tatamotors",
  "tatar",
  "tattoo",
  "tax",
  "taxi",
  "tci",
  "tdk",
  "team",
  "tech",
  "technology",
  "temasek",
  "tennis",
  "teva",
  "thd",
  "theater",
  "theatre",
  "tiaa",
  "tickets",
  "tienda",
  "tiffany",
  "tips",
  "tires",
  "tirol",
  "tjmaxx",
  "tjx",
  "tkmaxx",
  "tmall",
  "today",
  "tokyo",
  "tools",
  "top",
  "toray",
  "toshiba",
  "total",
  "tours",
  "town",
  "toyota",
  "toys",
  "trade",
  "trading",
  "training",
  "travel",
  "travelchannel",
  "travelers",
  "travelersinsurance",
  "trust",
  "trv",
  "tube",
  "tui",
  "tunes",
  "tushu",
  "tvs",
  "ubank",
  "ubs",
  "unicom",
  "university",
  "uno",
  "uol",
  "ups",
  "vacations",
  "vana",
  "vanguard",
  "vegas",
  "ventures",
  "verisign",
  "versicherung",
  "vet",
  "viajes",
  "video",
  "vig",
  "viking",
  "villas",
  "vin",
  "vip",
  "virgin",
  "visa",
  "vision",
  "viva",
  "vivo",
  "vlaanderen",
  "vodka",
  "volkswagen",
  "volvo",
  "vote",
  "voting",
  "voto",
  "voyage",
  "vuelos",
  "wales",
  "walmart",
  "walter",
  "wang",
  "wanggou",
  "watch",
  "watches",
  "weather",
  "weatherchannel",
  "webcam",
  "weber",
  "website",
  "wedding",
  "weibo",
  "weir",
  "whoswho",
  "wien",
  "wiki",
  "williamhill",
  "win",
  "windows",
  "wine",
  "winners",
  "wme",
  "wolterskluwer",
  "woodside",
  "work",
  "works",
  "world",
  "wow",
  "wtc",
  "wtf",
  "xbox",
  "xerox",
  "xfinity",
  "xihuan",
  "xin",
  "कॉम",
  "セール",
  "佛山",
  "慈善",
  "集团",
  "在线",
  "点看",
  "คอม",
  "八卦",
  "موقع",
  "公益",
  "公司",
  "香格里拉",
  "网站",
  "移动",
  "我爱你",
  "москва",
  "католик",
  "онлайн",
  "сайт",
  "联通",
  "קום",
  "时尚",
  "微博",
  "淡马锡",
  "ファッション",
  "орг",
  "नेट",
  "ストア",
  "アマゾン",
  "삼성",
  "商标",
  "商店",
  "商城",
  "дети",
  "ポイント",
  "新闻",
  "家電",
  "كوم",
  "中文网",
  "中信",
  "娱乐",
  "谷歌",
  "電訊盈科",
  "购物",
  "クラウド",
  "通販",
  "网店",
  "संगठन",
  "餐厅",
  "网络",
  "ком",
  "亚马逊",
  "诺基亚",
  "食品",
  "飞利浦",
  "手机",
  "ارامكو",
  "العليان",
  "اتصالات",
  "بازار",
  "ابوظبي",
  "كاثوليك",
  "همراه",
  "닷컴",
  "政府",
  "شبكة",
  "بيتك",
  "عرب",
  "机构",
  "组织机构",
  "健康",
  "招聘",
  "рус",
  "大拿",
  "みんな",
  "グーグル",
  "世界",
  "書籍",
  "网址",
  "닷넷",
  "コム",
  "天主教",
  "游戏",
  "vermögensberater",
  "vermögensberatung",
  "企业",
  "信息",
  "嘉里大酒店",
  "嘉里",
  "广东",
  "政务",
  "xyz",
  "yachts",
  "yahoo",
  "yamaxun",
  "yandex",
  "yodobashi",
  "yoga",
  "yokohama",
  "you",
  "youtube",
  "yun",
  "zappos",
  "zara",
  "zero",
  "zip",
  "zone",
  "zuerich",
  "cc.ua",
  "inf.ua",
  "ltd.ua",
  "611.to",
  "graphox.us",
  "*.devcdnaccesso.com",
  "adobeaemcloud.com",
  "*.dev.adobeaemcloud.com",
  "hlx.live",
  "adobeaemcloud.net",
  "hlx.page",
  "hlx3.page",
  "beep.pl",
  "airkitapps.com",
  "airkitapps-au.com",
  "airkitapps.eu",
  "aivencloud.com",
  "barsy.ca",
  "*.compute.estate",
  "*.alces.network",
  "kasserver.com",
  "altervista.org",
  "alwaysdata.net",
  "cloudfront.net",
  "*.compute.amazonaws.com",
  "*.compute-1.amazonaws.com",
  "*.compute.amazonaws.com.cn",
  "us-east-1.amazonaws.com",
  "cn-north-1.eb.amazonaws.com.cn",
  "cn-northwest-1.eb.amazonaws.com.cn",
  "elasticbeanstalk.com",
  "ap-northeast-1.elasticbeanstalk.com",
  "ap-northeast-2.elasticbeanstalk.com",
  "ap-northeast-3.elasticbeanstalk.com",
  "ap-south-1.elasticbeanstalk.com",
  "ap-southeast-1.elasticbeanstalk.com",
  "ap-southeast-2.elasticbeanstalk.com",
  "ca-central-1.elasticbeanstalk.com",
  "eu-central-1.elasticbeanstalk.com",
  "eu-west-1.elasticbeanstalk.com",
  "eu-west-2.elasticbeanstalk.com",
  "eu-west-3.elasticbeanstalk.com",
  "sa-east-1.elasticbeanstalk.com",
  "us-east-1.elasticbeanstalk.com",
  "us-east-2.elasticbeanstalk.com",
  "us-gov-west-1.elasticbeanstalk.com",
  "us-west-1.elasticbeanstalk.com",
  "us-west-2.elasticbeanstalk.com",
  "*.elb.amazonaws.com",
  "*.elb.amazonaws.com.cn",
  "awsglobalaccelerator.com",
  "s3.amazonaws.com",
  "s3-ap-northeast-1.amazonaws.com",
  "s3-ap-northeast-2.amazonaws.com",
  "s3-ap-south-1.amazonaws.com",
  "s3-ap-southeast-1.amazonaws.com",
  "s3-ap-southeast-2.amazonaws.com",
  "s3-ca-central-1.amazonaws.com",
  "s3-eu-central-1.amazonaws.com",
  "s3-eu-west-1.amazonaws.com",
  "s3-eu-west-2.amazonaws.com",
  "s3-eu-west-3.amazonaws.com",
  "s3-external-1.amazonaws.com",
  "s3-fips-us-gov-west-1.amazonaws.com",
  "s3-sa-east-1.amazonaws.com",
  "s3-us-gov-west-1.amazonaws.com",
  "s3-us-east-2.amazonaws.com",
  "s3-us-west-1.amazonaws.com",
  "s3-us-west-2.amazonaws.com",
  "s3.ap-northeast-2.amazonaws.com",
  "s3.ap-south-1.amazonaws.com",
  "s3.cn-north-1.amazonaws.com.cn",
  "s3.ca-central-1.amazonaws.com",
  "s3.eu-central-1.amazonaws.com",
  "s3.eu-west-2.amazonaws.com",
  "s3.eu-west-3.amazonaws.com",
  "s3.us-east-2.amazonaws.com",
  "s3.dualstack.ap-northeast-1.amazonaws.com",
  "s3.dualstack.ap-northeast-2.amazonaws.com",
  "s3.dualstack.ap-south-1.amazonaws.com",
  "s3.dualstack.ap-southeast-1.amazonaws.com",
  "s3.dualstack.ap-southeast-2.amazonaws.com",
  "s3.dualstack.ca-central-1.amazonaws.com",
  "s3.dualstack.eu-central-1.amazonaws.com",
  "s3.dualstack.eu-west-1.amazonaws.com",
  "s3.dualstack.eu-west-2.amazonaws.com",
  "s3.dualstack.eu-west-3.amazonaws.com",
  "s3.dualstack.sa-east-1.amazonaws.com",
  "s3.dualstack.us-east-1.amazonaws.com",
  "s3.dualstack.us-east-2.amazonaws.com",
  "s3-website-us-east-1.amazonaws.com",
  "s3-website-us-west-1.amazonaws.com",
  "s3-website-us-west-2.amazonaws.com",
  "s3-website-ap-northeast-1.amazonaws.com",
  "s3-website-ap-southeast-1.amazonaws.com",
  "s3-website-ap-southeast-2.amazonaws.com",
  "s3-website-eu-west-1.amazonaws.com",
  "s3-website-sa-east-1.amazonaws.com",
  "s3-website.ap-northeast-2.amazonaws.com",
  "s3-website.ap-south-1.amazonaws.com",
  "s3-website.ca-central-1.amazonaws.com",
  "s3-website.eu-central-1.amazonaws.com",
  "s3-website.eu-west-2.amazonaws.com",
  "s3-website.eu-west-3.amazonaws.com",
  "s3-website.us-east-2.amazonaws.com",
  "t3l3p0rt.net",
  "tele.amune.org",
  "apigee.io",
  "siiites.com",
  "appspacehosted.com",
  "appspaceusercontent.com",
  "appudo.net",
  "on-aptible.com",
  "user.aseinet.ne.jp",
  "gv.vc",
  "d.gv.vc",
  "user.party.eus",
  "pimienta.org",
  "poivron.org",
  "potager.org",
  "sweetpepper.org",
  "myasustor.com",
  "cdn.prod.atlassian-dev.net",
  "translated.page",
  "myfritz.net",
  "onavstack.net",
  "*.awdev.ca",
  "*.advisor.ws",
  "ecommerce-shop.pl",
  "b-data.io",
  "backplaneapp.io",
  "balena-devices.com",
  "rs.ba",
  "*.banzai.cloud",
  "app.banzaicloud.io",
  "*.backyards.banzaicloud.io",
  "base.ec",
  "official.ec",
  "buyshop.jp",
  "fashionstore.jp",
  "handcrafted.jp",
  "kawaiishop.jp",
  "supersale.jp",
  "theshop.jp",
  "shopselect.net",
  "base.shop",
  "*.beget.app",
  "betainabox.com",
  "bnr.la",
  "bitbucket.io",
  "blackbaudcdn.net",
  "of.je",
  "bluebite.io",
  "boomla.net",
  "boutir.com",
  "boxfuse.io",
  "square7.ch",
  "bplaced.com",
  "bplaced.de",
  "square7.de",
  "bplaced.net",
  "square7.net",
  "shop.brendly.rs",
  "browsersafetymark.io",
  "uk0.bigv.io",
  "dh.bytemark.co.uk",
  "vm.bytemark.co.uk",
  "cafjs.com",
  "mycd.eu",
  "drr.ac",
  "uwu.ai",
  "carrd.co",
  "crd.co",
  "ju.mp",
  "ae.org",
  "br.com",
  "cn.com",
  "com.de",
  "com.se",
  "de.com",
  "eu.com",
  "gb.net",
  "hu.net",
  "jp.net",
  "jpn.com",
  "mex.com",
  "ru.com",
  "sa.com",
  "se.net",
  "uk.com",
  "uk.net",
  "us.com",
  "za.bz",
  "za.com",
  "ar.com",
  "hu.com",
  "kr.com",
  "no.com",
  "qc.com",
  "uy.com",
  "africa.com",
  "gr.com",
  "in.net",
  "web.in",
  "us.org",
  "co.com",
  "aus.basketball",
  "nz.basketball",
  "radio.am",
  "radio.fm",
  "c.la",
  "certmgr.org",
  "cx.ua",
  "discourse.group",
  "discourse.team",
  "cleverapps.io",
  "clerk.app",
  "clerkstage.app",
  "*.lcl.dev",
  "*.lclstage.dev",
  "*.stg.dev",
  "*.stgstage.dev",
  "clickrising.net",
  "c66.me",
  "cloud66.ws",
  "cloud66.zone",
  "jdevcloud.com",
  "wpdevcloud.com",
  "cloudaccess.host",
  "freesite.host",
  "cloudaccess.net",
  "cloudcontrolled.com",
  "cloudcontrolapp.com",
  "*.cloudera.site",
  "pages.dev",
  "trycloudflare.com",
  "workers.dev",
  "wnext.app",
  "co.ca",
  "*.otap.co",
  "co.cz",
  "c.cdn77.org",
  "cdn77-ssl.net",
  "r.cdn77.net",
  "rsc.cdn77.org",
  "ssl.origin.cdn77-secure.org",
  "cloudns.asia",
  "cloudns.biz",
  "cloudns.club",
  "cloudns.cc",
  "cloudns.eu",
  "cloudns.in",
  "cloudns.info",
  "cloudns.org",
  "cloudns.pro",
  "cloudns.pw",
  "cloudns.us",
  "cnpy.gdn",
  "codeberg.page",
  "co.nl",
  "co.no",
  "webhosting.be",
  "hosting-cluster.nl",
  "ac.ru",
  "edu.ru",
  "gov.ru",
  "int.ru",
  "mil.ru",
  "test.ru",
  "dyn.cosidns.de",
  "dynamisches-dns.de",
  "dnsupdater.de",
  "internet-dns.de",
  "l-o-g-i-n.de",
  "dynamic-dns.info",
  "feste-ip.net",
  "knx-server.net",
  "static-access.net",
  "realm.cz",
  "*.cryptonomic.net",
  "cupcake.is",
  "curv.dev",
  "*.customer-oci.com",
  "*.oci.customer-oci.com",
  "*.ocp.customer-oci.com",
  "*.ocs.customer-oci.com",
  "cyon.link",
  "cyon.site",
  "fnwk.site",
  "folionetwork.site",
  "platform0.app",
  "daplie.me",
  "localhost.daplie.me",
  "dattolocal.com",
  "dattorelay.com",
  "dattoweb.com",
  "mydatto.com",
  "dattolocal.net",
  "mydatto.net",
  "biz.dk",
  "co.dk",
  "firm.dk",
  "reg.dk",
  "store.dk",
  "dyndns.dappnode.io",
  "*.dapps.earth",
  "*.bzz.dapps.earth",
  "builtwithdark.com",
  "demo.datadetect.com",
  "instance.datadetect.com",
  "edgestack.me",
  "ddns5.com",
  "debian.net",
  "deno.dev",
  "deno-staging.dev",
  "dedyn.io",
  "deta.app",
  "deta.dev",
  "*.rss.my.id",
  "*.diher.solutions",
  "discordsays.com",
  "discordsez.com",
  "jozi.biz",
  "dnshome.de",
  "online.th",
  "shop.th",
  "drayddns.com",
  "shoparena.pl",
  "dreamhosters.com",
  "mydrobo.com",
  "drud.io",
  "drud.us",
  "duckdns.org",
  "bip.sh",
  "bitbridge.net",
  "dy.fi",
  "tunk.org",
  "dyndns-at-home.com",
  "dyndns-at-work.com",
  "dyndns-blog.com",
  "dyndns-free.com",
  "dyndns-home.com",
  "dyndns-ip.com",
  "dyndns-mail.com",
  "dyndns-office.com",
  "dyndns-pics.com",
  "dyndns-remote.com",
  "dyndns-server.com",
  "dyndns-web.com",
  "dyndns-wiki.com",
  "dyndns-work.com",
  "dyndns.biz",
  "dyndns.info",
  "dyndns.org",
  "dyndns.tv",
  "at-band-camp.net",
  "ath.cx",
  "barrel-of-knowledge.info",
  "barrell-of-knowledge.info",
  "better-than.tv",
  "blogdns.com",
  "blogdns.net",
  "blogdns.org",
  "blogsite.org",
  "boldlygoingnowhere.org",
  "broke-it.net",
  "buyshouses.net",
  "cechire.com",
  "dnsalias.com",
  "dnsalias.net",
  "dnsalias.org",
  "dnsdojo.com",
  "dnsdojo.net",
  "dnsdojo.org",
  "does-it.net",
  "doesntexist.com",
  "doesntexist.org",
  "dontexist.com",
  "dontexist.net",
  "dontexist.org",
  "doomdns.com",
  "doomdns.org",
  "dvrdns.org",
  "dyn-o-saur.com",
  "dynalias.com",
  "dynalias.net",
  "dynalias.org",
  "dynathome.net",
  "dyndns.ws",
  "endofinternet.net",
  "endofinternet.org",
  "endoftheinternet.org",
  "est-a-la-maison.com",
  "est-a-la-masion.com",
  "est-le-patron.com",
  "est-mon-blogueur.com",
  "for-better.biz",
  "for-more.biz",
  "for-our.info",
  "for-some.biz",
  "for-the.biz",
  "forgot.her.name",
  "forgot.his.name",
  "from-ak.com",
  "from-al.com",
  "from-ar.com",
  "from-az.net",
  "from-ca.com",
  "from-co.net",
  "from-ct.com",
  "from-dc.com",
  "from-de.com",
  "from-fl.com",
  "from-ga.com",
  "from-hi.com",
  "from-ia.com",
  "from-id.com",
  "from-il.com",
  "from-in.com",
  "from-ks.com",
  "from-ky.com",
  "from-la.net",
  "from-ma.com",
  "from-md.com",
  "from-me.org",
  "from-mi.com",
  "from-mn.com",
  "from-mo.com",
  "from-ms.com",
  "from-mt.com",
  "from-nc.com",
  "from-nd.com",
  "from-ne.com",
  "from-nh.com",
  "from-nj.com",
  "from-nm.com",
  "from-nv.com",
  "from-ny.net",
  "from-oh.com",
  "from-ok.com",
  "from-or.com",
  "from-pa.com",
  "from-pr.com",
  "from-ri.com",
  "from-sc.com",
  "from-sd.com",
  "from-tn.com",
  "from-tx.com",
  "from-ut.com",
  "from-va.com",
  "from-vt.com",
  "from-wa.com",
  "from-wi.com",
  "from-wv.com",
  "from-wy.com",
  "ftpaccess.cc",
  "fuettertdasnetz.de",
  "game-host.org",
  "game-server.cc",
  "getmyip.com",
  "gets-it.net",
  "go.dyndns.org",
  "gotdns.com",
  "gotdns.org",
  "groks-the.info",
  "groks-this.info",
  "ham-radio-op.net",
  "here-for-more.info",
  "hobby-site.com",
  "hobby-site.org",
  "home.dyndns.org",
  "homedns.org",
  "homeftp.net",
  "homeftp.org",
  "homeip.net",
  "homelinux.com",
  "homelinux.net",
  "homelinux.org",
  "homeunix.com",
  "homeunix.net",
  "homeunix.org",
  "iamallama.com",
  "in-the-band.net",
  "is-a-anarchist.com",
  "is-a-blogger.com",
  "is-a-bookkeeper.com",
  "is-a-bruinsfan.org",
  "is-a-bulls-fan.com",
  "is-a-candidate.org",
  "is-a-caterer.com",
  "is-a-celticsfan.org",
  "is-a-chef.com",
  "is-a-chef.net",
  "is-a-chef.org",
  "is-a-conservative.com",
  "is-a-cpa.com",
  "is-a-cubicle-slave.com",
  "is-a-democrat.com",
  "is-a-designer.com",
  "is-a-doctor.com",
  "is-a-financialadvisor.com",
  "is-a-geek.com",
  "is-a-geek.net",
  "is-a-geek.org",
  "is-a-green.com",
  "is-a-guru.com",
  "is-a-hard-worker.com",
  "is-a-hunter.com",
  "is-a-knight.org",
  "is-a-landscaper.com",
  "is-a-lawyer.com",
  "is-a-liberal.com",
  "is-a-libertarian.com",
  "is-a-linux-user.org",
  "is-a-llama.com",
  "is-a-musician.com",
  "is-a-nascarfan.com",
  "is-a-nurse.com",
  "is-a-painter.com",
  "is-a-patsfan.org",
  "is-a-personaltrainer.com",
  "is-a-photographer.com",
  "is-a-player.com",
  "is-a-republican.com",
  "is-a-rockstar.com",
  "is-a-socialist.com",
  "is-a-soxfan.org",
  "is-a-student.com",
  "is-a-teacher.com",
  "is-a-techie.com",
  "is-a-therapist.com",
  "is-an-accountant.com",
  "is-an-actor.com",
  "is-an-actress.com",
  "is-an-anarchist.com",
  "is-an-artist.com",
  "is-an-engineer.com",
  "is-an-entertainer.com",
  "is-by.us",
  "is-certified.com",
  "is-found.org",
  "is-gone.com",
  "is-into-anime.com",
  "is-into-cars.com",
  "is-into-cartoons.com",
  "is-into-games.com",
  "is-leet.com",
  "is-lost.org",
  "is-not-certified.com",
  "is-saved.org",
  "is-slick.com",
  "is-uberleet.com",
  "is-very-bad.org",
  "is-very-evil.org",
  "is-very-good.org",
  "is-very-nice.org",
  "is-very-sweet.org",
  "is-with-theband.com",
  "isa-geek.com",
  "isa-geek.net",
  "isa-geek.org",
  "isa-hockeynut.com",
  "issmarterthanyou.com",
  "isteingeek.de",
  "istmein.de",
  "kicks-ass.net",
  "kicks-ass.org",
  "knowsitall.info",
  "land-4-sale.us",
  "lebtimnetz.de",
  "leitungsen.de",
  "likes-pie.com",
  "likescandy.com",
  "merseine.nu",
  "mine.nu",
  "misconfused.org",
  "mypets.ws",
  "myphotos.cc",
  "neat-url.com",
  "office-on-the.net",
  "on-the-web.tv",
  "podzone.net",
  "podzone.org",
  "readmyblog.org",
  "saves-the-whales.com",
  "scrapper-site.net",
  "scrapping.cc",
  "selfip.biz",
  "selfip.com",
  "selfip.info",
  "selfip.net",
  "selfip.org",
  "sells-for-less.com",
  "sells-for-u.com",
  "sells-it.net",
  "sellsyourhome.org",
  "servebbs.com",
  "servebbs.net",
  "servebbs.org",
  "serveftp.net",
  "serveftp.org",
  "servegame.org",
  "shacknet.nu",
  "simple-url.com",
  "space-to-rent.com",
  "stuff-4-sale.org",
  "stuff-4-sale.us",
  "teaches-yoga.com",
  "thruhere.net",
  "traeumtgerade.de",
  "webhop.biz",
  "webhop.info",
  "webhop.net",
  "webhop.org",
  "worse-than.tv",
  "writesthisblog.com",
  "ddnss.de",
  "dyn.ddnss.de",
  "dyndns.ddnss.de",
  "dyndns1.de",
  "dyn-ip24.de",
  "home-webserver.de",
  "dyn.home-webserver.de",
  "myhome-server.de",
  "ddnss.org",
  "definima.net",
  "definima.io",
  "ondigitalocean.app",
  "*.digitaloceanspaces.com",
  "bci.dnstrace.pro",
  "ddnsfree.com",
  "ddnsgeek.com",
  "giize.com",
  "gleeze.com",
  "kozow.com",
  "loseyourip.com",
  "ooguy.com",
  "theworkpc.com",
  "casacam.net",
  "dynu.net",
  "accesscam.org",
  "camdvr.org",
  "freeddns.org",
  "mywire.org",
  "webredirect.org",
  "myddns.rocks",
  "blogsite.xyz",
  "dynv6.net",
  "e4.cz",
  "eero.online",
  "eero-stage.online",
  "elementor.cloud",
  "elementor.cool",
  "en-root.fr",
  "mytuleap.com",
  "tuleap-partners.com",
  "encr.app",
  "encoreapi.com",
  "onred.one",
  "staging.onred.one",
  "eu.encoway.cloud",
  "eu.org",
  "al.eu.org",
  "asso.eu.org",
  "at.eu.org",
  "au.eu.org",
  "be.eu.org",
  "bg.eu.org",
  "ca.eu.org",
  "cd.eu.org",
  "ch.eu.org",
  "cn.eu.org",
  "cy.eu.org",
  "cz.eu.org",
  "de.eu.org",
  "dk.eu.org",
  "edu.eu.org",
  "ee.eu.org",
  "es.eu.org",
  "fi.eu.org",
  "fr.eu.org",
  "gr.eu.org",
  "hr.eu.org",
  "hu.eu.org",
  "ie.eu.org",
  "il.eu.org",
  "in.eu.org",
  "int.eu.org",
  "is.eu.org",
  "it.eu.org",
  "jp.eu.org",
  "kr.eu.org",
  "lt.eu.org",
  "lu.eu.org",
  "lv.eu.org",
  "mc.eu.org",
  "me.eu.org",
  "mk.eu.org",
  "mt.eu.org",
  "my.eu.org",
  "net.eu.org",
  "ng.eu.org",
  "nl.eu.org",
  "no.eu.org",
  "nz.eu.org",
  "paris.eu.org",
  "pl.eu.org",
  "pt.eu.org",
  "q-a.eu.org",
  "ro.eu.org",
  "ru.eu.org",
  "se.eu.org",
  "si.eu.org",
  "sk.eu.org",
  "tr.eu.org",
  "uk.eu.org",
  "us.eu.org",
  "eurodir.ru",
  "eu-1.evennode.com",
  "eu-2.evennode.com",
  "eu-3.evennode.com",
  "eu-4.evennode.com",
  "us-1.evennode.com",
  "us-2.evennode.com",
  "us-3.evennode.com",
  "us-4.evennode.com",
  "twmail.cc",
  "twmail.net",
  "twmail.org",
  "mymailer.com.tw",
  "url.tw",
  "onfabrica.com",
  "apps.fbsbx.com",
  "ru.net",
  "adygeya.ru",
  "bashkiria.ru",
  "bir.ru",
  "cbg.ru",
  "com.ru",
  "dagestan.ru",
  "grozny.ru",
  "kalmykia.ru",
  "kustanai.ru",
  "marine.ru",
  "mordovia.ru",
  "msk.ru",
  "mytis.ru",
  "nalchik.ru",
  "nov.ru",
  "pyatigorsk.ru",
  "spb.ru",
  "vladikavkaz.ru",
  "vladimir.ru",
  "abkhazia.su",
  "adygeya.su",
  "aktyubinsk.su",
  "arkhangelsk.su",
  "armenia.su",
  "ashgabad.su",
  "azerbaijan.su",
  "balashov.su",
  "bashkiria.su",
  "bryansk.su",
  "bukhara.su",
  "chimkent.su",
  "dagestan.su",
  "east-kazakhstan.su",
  "exnet.su",
  "georgia.su",
  "grozny.su",
  "ivanovo.su",
  "jambyl.su",
  "kalmykia.su",
  "kaluga.su",
  "karacol.su",
  "karaganda.su",
  "karelia.su",
  "khakassia.su",
  "krasnodar.su",
  "kurgan.su",
  "kustanai.su",
  "lenug.su",
  "mangyshlak.su",
  "mordovia.su",
  "msk.su",
  "murmansk.su",
  "nalchik.su",
  "navoi.su",
  "north-kazakhstan.su",
  "nov.su",
  "obninsk.su",
  "penza.su",
  "pokrovsk.su",
  "sochi.su",
  "spb.su",
  "tashkent.su",
  "termez.su",
  "togliatti.su",
  "troitsk.su",
  "tselinograd.su",
  "tula.su",
  "tuva.su",
  "vladikavkaz.su",
  "vladimir.su",
  "vologda.su",
  "channelsdvr.net",
  "u.channelsdvr.net",
  "edgecompute.app",
  "fastly-terrarium.com",
  "fastlylb.net",
  "map.fastlylb.net",
  "freetls.fastly.net",
  "map.fastly.net",
  "a.prod.fastly.net",
  "global.prod.fastly.net",
  "a.ssl.fastly.net",
  "b.ssl.fastly.net",
  "global.ssl.fastly.net",
  "fastvps-server.com",
  "fastvps.host",
  "myfast.host",
  "fastvps.site",
  "myfast.space",
  "fedorainfracloud.org",
  "fedorapeople.org",
  "cloud.fedoraproject.org",
  "app.os.fedoraproject.org",
  "app.os.stg.fedoraproject.org",
  "conn.uk",
  "copro.uk",
  "hosp.uk",
  "mydobiss.com",
  "fh-muenster.io",
  "filegear.me",
  "filegear-au.me",
  "filegear-de.me",
  "filegear-gb.me",
  "filegear-ie.me",
  "filegear-jp.me",
  "filegear-sg.me",
  "firebaseapp.com",
  "fireweb.app",
  "flap.id",
  "onflashdrive.app",
  "fldrv.com",
  "fly.dev",
  "edgeapp.net",
  "shw.io",
  "flynnhosting.net",
  "forgeblocks.com",
  "id.forgerock.io",
  "framer.app",
  "framercanvas.com",
  "*.frusky.de",
  "ravpage.co.il",
  "0e.vc",
  "freebox-os.com",
  "freeboxos.com",
  "fbx-os.fr",
  "fbxos.fr",
  "freebox-os.fr",
  "freeboxos.fr",
  "freedesktop.org",
  "freemyip.com",
  "wien.funkfeuer.at",
  "*.futurecms.at",
  "*.ex.futurecms.at",
  "*.in.futurecms.at",
  "futurehosting.at",
  "futuremailing.at",
  "*.ex.ortsinfo.at",
  "*.kunden.ortsinfo.at",
  "*.statics.cloud",
  "independent-commission.uk",
  "independent-inquest.uk",
  "independent-inquiry.uk",
  "independent-panel.uk",
  "independent-review.uk",
  "public-inquiry.uk",
  "royal-commission.uk",
  "campaign.gov.uk",
  "service.gov.uk",
  "api.gov.uk",
  "gehirn.ne.jp",
  "usercontent.jp",
  "gentapps.com",
  "gentlentapis.com",
  "lab.ms",
  "cdn-edges.net",
  "ghost.io",
  "gsj.bz",
  "githubusercontent.com",
  "githubpreview.dev",
  "github.io",
  "gitlab.io",
  "gitapp.si",
  "gitpage.si",
  "glitch.me",
  "nog.community",
  "co.ro",
  "shop.ro",
  "lolipop.io",
  "angry.jp",
  "babyblue.jp",
  "babymilk.jp",
  "backdrop.jp",
  "bambina.jp",
  "bitter.jp",
  "blush.jp",
  "boo.jp",
  "boy.jp",
  "boyfriend.jp",
  "but.jp",
  "candypop.jp",
  "capoo.jp",
  "catfood.jp",
  "cheap.jp",
  "chicappa.jp",
  "chillout.jp",
  "chips.jp",
  "chowder.jp",
  "chu.jp",
  "ciao.jp",
  "cocotte.jp",
  "coolblog.jp",
  "cranky.jp",
  "cutegirl.jp",
  "daa.jp",
  "deca.jp",
  "deci.jp",
  "digick.jp",
  "egoism.jp",
  "fakefur.jp",
  "fem.jp",
  "flier.jp",
  "floppy.jp",
  "fool.jp",
  "frenchkiss.jp",
  "girlfriend.jp",
  "girly.jp",
  "gloomy.jp",
  "gonna.jp",
  "greater.jp",
  "hacca.jp",
  "heavy.jp",
  "her.jp",
  "hiho.jp",
  "hippy.jp",
  "holy.jp",
  "hungry.jp",
  "icurus.jp",
  "itigo.jp",
  "jellybean.jp",
  "kikirara.jp",
  "kill.jp",
  "kilo.jp",
  "kuron.jp",
  "littlestar.jp",
  "lolipopmc.jp",
  "lolitapunk.jp",
  "lomo.jp",
  "lovepop.jp",
  "lovesick.jp",
  "main.jp",
  "mods.jp",
  "mond.jp",
  "mongolian.jp",
  "moo.jp",
  "namaste.jp",
  "nikita.jp",
  "nobushi.jp",
  "noor.jp",
  "oops.jp",
  "parallel.jp",
  "parasite.jp",
  "pecori.jp",
  "peewee.jp",
  "penne.jp",
  "pepper.jp",
  "perma.jp",
  "pigboat.jp",
  "pinoko.jp",
  "punyu.jp",
  "pupu.jp",
  "pussycat.jp",
  "pya.jp",
  "raindrop.jp",
  "readymade.jp",
  "sadist.jp",
  "schoolbus.jp",
  "secret.jp",
  "staba.jp",
  "stripper.jp",
  "sub.jp",
  "sunnyday.jp",
  "thick.jp",
  "tonkotsu.jp",
  "under.jp",
  "upper.jp",
  "velvet.jp",
  "verse.jp",
  "versus.jp",
  "vivian.jp",
  "watson.jp",
  "weblike.jp",
  "whitesnow.jp",
  "zombie.jp",
  "heteml.net",
  "cloudapps.digital",
  "london.cloudapps.digital",
  "pymnt.uk",
  "homeoffice.gov.uk",
  "ro.im",
  "goip.de",
  "run.app",
  "a.run.app",
  "web.app",
  "*.0emm.com",
  "appspot.com",
  "*.r.appspot.com",
  "codespot.com",
  "googleapis.com",
  "googlecode.com",
  "pagespeedmobilizer.com",
  "publishproxy.com",
  "withgoogle.com",
  "withyoutube.com",
  "*.gateway.dev",
  "cloud.goog",
  "translate.goog",
  "*.usercontent.goog",
  "cloudfunctions.net",
  "blogspot.ae",
  "blogspot.al",
  "blogspot.am",
  "blogspot.ba",
  "blogspot.be",
  "blogspot.bg",
  "blogspot.bj",
  "blogspot.ca",
  "blogspot.cf",
  "blogspot.ch",
  "blogspot.cl",
  "blogspot.co.at",
  "blogspot.co.id",
  "blogspot.co.il",
  "blogspot.co.ke",
  "blogspot.co.nz",
  "blogspot.co.uk",
  "blogspot.co.za",
  "blogspot.com",
  "blogspot.com.ar",
  "blogspot.com.au",
  "blogspot.com.br",
  "blogspot.com.by",
  "blogspot.com.co",
  "blogspot.com.cy",
  "blogspot.com.ee",
  "blogspot.com.eg",
  "blogspot.com.es",
  "blogspot.com.mt",
  "blogspot.com.ng",
  "blogspot.com.tr",
  "blogspot.com.uy",
  "blogspot.cv",
  "blogspot.cz",
  "blogspot.de",
  "blogspot.dk",
  "blogspot.fi",
  "blogspot.fr",
  "blogspot.gr",
  "blogspot.hk",
  "blogspot.hr",
  "blogspot.hu",
  "blogspot.ie",
  "blogspot.in",
  "blogspot.is",
  "blogspot.it",
  "blogspot.jp",
  "blogspot.kr",
  "blogspot.li",
  "blogspot.lt",
  "blogspot.lu",
  "blogspot.md",
  "blogspot.mk",
  "blogspot.mr",
  "blogspot.mx",
  "blogspot.my",
  "blogspot.nl",
  "blogspot.no",
  "blogspot.pe",
  "blogspot.pt",
  "blogspot.qa",
  "blogspot.re",
  "blogspot.ro",
  "blogspot.rs",
  "blogspot.ru",
  "blogspot.se",
  "blogspot.sg",
  "blogspot.si",
  "blogspot.sk",
  "blogspot.sn",
  "blogspot.td",
  "blogspot.tw",
  "blogspot.ug",
  "blogspot.vn",
  "goupile.fr",
  "gov.nl",
  "awsmppl.com",
  "günstigbestellen.de",
  "günstigliefern.de",
  "fin.ci",
  "free.hr",
  "caa.li",
  "ua.rs",
  "conf.se",
  "hs.zone",
  "hs.run",
  "hashbang.sh",
  "hasura.app",
  "hasura-app.io",
  "pages.it.hs-heilbronn.de",
  "hepforge.org",
  "herokuapp.com",
  "herokussl.com",
  "ravendb.cloud",
  "myravendb.com",
  "ravendb.community",
  "ravendb.me",
  "development.run",
  "ravendb.run",
  "homesklep.pl",
  "secaas.hk",
  "hoplix.shop",
  "orx.biz",
  "biz.gl",
  "col.ng",
  "firm.ng",
  "gen.ng",
  "ltd.ng",
  "ngo.ng",
  "edu.scot",
  "sch.so",
  "hostyhosting.io",
  "häkkinen.fi",
  "*.moonscale.io",
  "moonscale.net",
  "iki.fi",
  "ibxos.it",
  "iliadboxos.it",
  "impertrixcdn.com",
  "impertrix.com",
  "smushcdn.com",
  "wphostedmail.com",
  "wpmucdn.com",
  "tempurl.host",
  "wpmudev.host",
  "dyn-berlin.de",
  "in-berlin.de",
  "in-brb.de",
  "in-butter.de",
  "in-dsl.de",
  "in-dsl.net",
  "in-dsl.org",
  "in-vpn.de",
  "in-vpn.net",
  "in-vpn.org",
  "biz.at",
  "info.at",
  "info.cx",
  "ac.leg.br",
  "al.leg.br",
  "am.leg.br",
  "ap.leg.br",
  "ba.leg.br",
  "ce.leg.br",
  "df.leg.br",
  "es.leg.br",
  "go.leg.br",
  "ma.leg.br",
  "mg.leg.br",
  "ms.leg.br",
  "mt.leg.br",
  "pa.leg.br",
  "pb.leg.br",
  "pe.leg.br",
  "pi.leg.br",
  "pr.leg.br",
  "rj.leg.br",
  "rn.leg.br",
  "ro.leg.br",
  "rr.leg.br",
  "rs.leg.br",
  "sc.leg.br",
  "se.leg.br",
  "sp.leg.br",
  "to.leg.br",
  "pixolino.com",
  "na4u.ru",
  "iopsys.se",
  "ipifony.net",
  "iservschule.de",
  "mein-iserv.de",
  "schulplattform.de",
  "schulserver.de",
  "test-iserv.de",
  "iserv.dev",
  "iobb.net",
  "mel.cloudlets.com.au",
  "cloud.interhostsolutions.be",
  "users.scale.virtualcloud.com.br",
  "mycloud.by",
  "alp1.ae.flow.ch",
  "appengine.flow.ch",
  "es-1.axarnet.cloud",
  "diadem.cloud",
  "vip.jelastic.cloud",
  "jele.cloud",
  "it1.eur.aruba.jenv-aruba.cloud",
  "it1.jenv-aruba.cloud",
  "keliweb.cloud",
  "cs.keliweb.cloud",
  "oxa.cloud",
  "tn.oxa.cloud",
  "uk.oxa.cloud",
  "primetel.cloud",
  "uk.primetel.cloud",
  "ca.reclaim.cloud",
  "uk.reclaim.cloud",
  "us.reclaim.cloud",
  "ch.trendhosting.cloud",
  "de.trendhosting.cloud",
  "jele.club",
  "amscompute.com",
  "clicketcloud.com",
  "dopaas.com",
  "hidora.com",
  "paas.hosted-by-previder.com",
  "rag-cloud.hosteur.com",
  "rag-cloud-ch.hosteur.com",
  "jcloud.ik-server.com",
  "jcloud-ver-jpc.ik-server.com",
  "demo.jelastic.com",
  "kilatiron.com",
  "paas.massivegrid.com",
  "jed.wafaicloud.com",
  "lon.wafaicloud.com",
  "ryd.wafaicloud.com",
  "j.scaleforce.com.cy",
  "jelastic.dogado.eu",
  "fi.cloudplatform.fi",
  "demo.datacenter.fi",
  "paas.datacenter.fi",
  "jele.host",
  "mircloud.host",
  "paas.beebyte.io",
  "sekd1.beebyteapp.io",
  "jele.io",
  "cloud-fr1.unispace.io",
  "jc.neen.it",
  "cloud.jelastic.open.tim.it",
  "jcloud.kz",
  "upaas.kazteleport.kz",
  "cloudjiffy.net",
  "fra1-de.cloudjiffy.net",
  "west1-us.cloudjiffy.net",
  "jls-sto1.elastx.net",
  "jls-sto2.elastx.net",
  "jls-sto3.elastx.net",
  "faststacks.net",
  "fr-1.paas.massivegrid.net",
  "lon-1.paas.massivegrid.net",
  "lon-2.paas.massivegrid.net",
  "ny-1.paas.massivegrid.net",
  "ny-2.paas.massivegrid.net",
  "sg-1.paas.massivegrid.net",
  "jelastic.saveincloud.net",
  "nordeste-idc.saveincloud.net",
  "j.scaleforce.net",
  "jelastic.tsukaeru.net",
  "sdscloud.pl",
  "unicloud.pl",
  "mircloud.ru",
  "jelastic.regruhosting.ru",
  "enscaled.sg",
  "jele.site",
  "jelastic.team",
  "orangecloud.tn",
  "j.layershift.co.uk",
  "phx.enscaled.us",
  "mircloud.us",
  "myjino.ru",
  "*.hosting.myjino.ru",
  "*.landing.myjino.ru",
  "*.spectrum.myjino.ru",
  "*.vps.myjino.ru",
  "jotelulu.cloud",
  "*.triton.zone",
  "*.cns.joyent.com",
  "js.org",
  "kaas.gg",
  "khplay.nl",
  "ktistory.com",
  "kapsi.fi",
  "keymachine.de",
  "kinghost.net",
  "uni5.net",
  "knightpoint.systems",
  "koobin.events",
  "oya.to",
  "kuleuven.cloud",
  "ezproxy.kuleuven.be",
  "co.krd",
  "edu.krd",
  "krellian.net",
  "webthings.io",
  "git-repos.de",
  "lcube-server.de",
  "svn-repos.de",
  "leadpages.co",
  "lpages.co",
  "lpusercontent.com",
  "lelux.site",
  "co.business",
  "co.education",
  "co.events",
  "co.financial",
  "co.network",
  "co.place",
  "co.technology",
  "app.lmpm.com",
  "linkyard.cloud",
  "linkyard-cloud.ch",
  "members.linode.com",
  "*.nodebalancer.linode.com",
  "*.linodeobjects.com",
  "ip.linodeusercontent.com",
  "we.bs",
  "*.user.localcert.dev",
  "localzone.xyz",
  "loginline.app",
  "loginline.dev",
  "loginline.io",
  "loginline.services",
  "loginline.site",
  "servers.run",
  "lohmus.me",
  "krasnik.pl",
  "leczna.pl",
  "lubartow.pl",
  "lublin.pl",
  "poniatowa.pl",
  "swidnik.pl",
  "glug.org.uk",
  "lug.org.uk",
  "lugs.org.uk",
  "barsy.bg",
  "barsy.co.uk",
  "barsyonline.co.uk",
  "barsycenter.com",
  "barsyonline.com",
  "barsy.club",
  "barsy.de",
  "barsy.eu",
  "barsy.in",
  "barsy.info",
  "barsy.io",
  "barsy.me",
  "barsy.menu",
  "barsy.mobi",
  "barsy.net",
  "barsy.online",
  "barsy.org",
  "barsy.pro",
  "barsy.pub",
  "barsy.ro",
  "barsy.shop",
  "barsy.site",
  "barsy.support",
  "barsy.uk",
  "*.magentosite.cloud",
  "mayfirst.info",
  "mayfirst.org",
  "hb.cldmail.ru",
  "cn.vu",
  "mazeplay.com",
  "mcpe.me",
  "mcdir.me",
  "mcdir.ru",
  "mcpre.ru",
  "vps.mcdir.ru",
  "mediatech.by",
  "mediatech.dev",
  "hra.health",
  "miniserver.com",
  "memset.net",
  "messerli.app",
  "*.cloud.metacentrum.cz",
  "custom.metacentrum.cz",
  "flt.cloud.muni.cz",
  "usr.cloud.muni.cz",
  "meteorapp.com",
  "eu.meteorapp.com",
  "co.pl",
  "*.azurecontainer.io",
  "azurewebsites.net",
  "azure-mobile.net",
  "cloudapp.net",
  "azurestaticapps.net",
  "1.azurestaticapps.net",
  "centralus.azurestaticapps.net",
  "eastasia.azurestaticapps.net",
  "eastus2.azurestaticapps.net",
  "westeurope.azurestaticapps.net",
  "westus2.azurestaticapps.net",
  "csx.cc",
  "mintere.site",
  "forte.id",
  "mozilla-iot.org",
  "bmoattachments.org",
  "net.ru",
  "org.ru",
  "pp.ru",
  "hostedpi.com",
  "customer.mythic-beasts.com",
  "caracal.mythic-beasts.com",
  "fentiger.mythic-beasts.com",
  "lynx.mythic-beasts.com",
  "ocelot.mythic-beasts.com",
  "oncilla.mythic-beasts.com",
  "onza.mythic-beasts.com",
  "sphinx.mythic-beasts.com",
  "vs.mythic-beasts.com",
  "x.mythic-beasts.com",
  "yali.mythic-beasts.com",
  "cust.retrosnub.co.uk",
  "ui.nabu.casa",
  "pony.club",
  "of.fashion",
  "in.london",
  "of.london",
  "from.marketing",
  "with.marketing",
  "for.men",
  "repair.men",
  "and.mom",
  "for.mom",
  "for.one",
  "under.one",
  "for.sale",
  "that.win",
  "from.work",
  "to.work",
  "cloud.nospamproxy.com",
  "netlify.app",
  "4u.com",
  "ngrok.io",
  "nh-serv.co.uk",
  "nfshost.com",
  "*.developer.app",
  "noop.app",
  "*.northflank.app",
  "*.build.run",
  "*.code.run",
  "*.database.run",
  "*.migration.run",
  "noticeable.news",
  "dnsking.ch",
  "mypi.co",
  "n4t.co",
  "001www.com",
  "ddnslive.com",
  "myiphost.com",
  "forumz.info",
  "16-b.it",
  "32-b.it",
  "64-b.it",
  "soundcast.me",
  "tcp4.me",
  "dnsup.net",
  "hicam.net",
  "now-dns.net",
  "ownip.net",
  "vpndns.net",
  "dynserv.org",
  "now-dns.org",
  "x443.pw",
  "now-dns.top",
  "ntdll.top",
  "freeddns.us",
  "crafting.xyz",
  "zapto.xyz",
  "nsupdate.info",
  "nerdpol.ovh",
  "blogsyte.com",
  "brasilia.me",
  "cable-modem.org",
  "ciscofreak.com",
  "collegefan.org",
  "couchpotatofries.org",
  "damnserver.com",
  "ddns.me",
  "ditchyourip.com",
  "dnsfor.me",
  "dnsiskinky.com",
  "dvrcam.info",
  "dynns.com",
  "eating-organic.net",
  "fantasyleague.cc",
  "geekgalaxy.com",
  "golffan.us",
  "health-carereform.com",
  "homesecuritymac.com",
  "homesecuritypc.com",
  "hopto.me",
  "ilovecollege.info",
  "loginto.me",
  "mlbfan.org",
  "mmafan.biz",
  "myactivedirectory.com",
  "mydissent.net",
  "myeffect.net",
  "mymediapc.net",
  "mypsx.net",
  "mysecuritycamera.com",
  "mysecuritycamera.net",
  "mysecuritycamera.org",
  "net-freaks.com",
  "nflfan.org",
  "nhlfan.net",
  "no-ip.ca",
  "no-ip.co.uk",
  "no-ip.net",
  "noip.us",
  "onthewifi.com",
  "pgafan.net",
  "point2this.com",
  "pointto.us",
  "privatizehealthinsurance.net",
  "quicksytes.com",
  "read-books.org",
  "securitytactics.com",
  "serveexchange.com",
  "servehumour.com",
  "servep2p.com",
  "servesarcasm.com",
  "stufftoread.com",
  "ufcfan.org",
  "unusualperson.com",
  "workisboring.com",
  "3utilities.com",
  "bounceme.net",
  "ddns.net",
  "ddnsking.com",
  "gotdns.ch",
  "hopto.org",
  "myftp.biz",
  "myftp.org",
  "myvnc.com",
  "no-ip.biz",
  "no-ip.info",
  "no-ip.org",
  "noip.me",
  "redirectme.net",
  "servebeer.com",
  "serveblog.net",
  "servecounterstrike.com",
  "serveftp.com",
  "servegame.com",
  "servehalflife.com",
  "servehttp.com",
  "serveirc.com",
  "serveminecraft.net",
  "servemp3.com",
  "servepics.com",
  "servequake.com",
  "sytes.net",
  "webhop.me",
  "zapto.org",
  "stage.nodeart.io",
  "pcloud.host",
  "nyc.mn",
  "static.observableusercontent.com",
  "cya.gg",
  "omg.lol",
  "cloudycluster.net",
  "omniwe.site",
  "service.one",
  "nid.io",
  "opensocial.site",
  "opencraft.hosting",
  "orsites.com",
  "operaunite.com",
  "tech.orange",
  "authgear-staging.com",
  "authgearapps.com",
  "skygearapp.com",
  "outsystemscloud.com",
  "*.webpaas.ovh.net",
  "*.hosting.ovh.net",
  "ownprovider.com",
  "own.pm",
  "*.owo.codes",
  "ox.rs",
  "oy.lc",
  "pgfog.com",
  "pagefrontapp.com",
  "pagexl.com",
  "*.paywhirl.com",
  "bar0.net",
  "bar1.net",
  "bar2.net",
  "rdv.to",
  "art.pl",
  "gliwice.pl",
  "krakow.pl",
  "poznan.pl",
  "wroc.pl",
  "zakopane.pl",
  "pantheonsite.io",
  "gotpantheon.com",
  "mypep.link",
  "perspecta.cloud",
  "lk3.ru",
  "on-web.fr",
  "bc.platform.sh",
  "ent.platform.sh",
  "eu.platform.sh",
  "us.platform.sh",
  "*.platformsh.site",
  "*.tst.site",
  "platter-app.com",
  "platter-app.dev",
  "platterp.us",
  "pdns.page",
  "plesk.page",
  "pleskns.com",
  "dyn53.io",
  "onporter.run",
  "co.bn",
  "postman-echo.com",
  "pstmn.io",
  "mock.pstmn.io",
  "httpbin.org",
  "prequalifyme.today",
  "xen.prgmr.com",
  "priv.at",
  "prvcy.page",
  "*.dweb.link",
  "protonet.io",
  "chirurgiens-dentistes-en-france.fr",
  "byen.site",
  "pubtls.org",
  "pythonanywhere.com",
  "eu.pythonanywhere.com",
  "qoto.io",
  "qualifioapp.com",
  "qbuser.com",
  "cloudsite.builders",
  "instances.spawn.cc",
  "instantcloud.cn",
  "ras.ru",
  "qa2.com",
  "qcx.io",
  "*.sys.qcx.io",
  "dev-myqnapcloud.com",
  "alpha-myqnapcloud.com",
  "myqnapcloud.com",
  "*.quipelements.com",
  "vapor.cloud",
  "vaporcloud.io",
  "rackmaze.com",
  "rackmaze.net",
  "g.vbrplsbx.io",
  "*.on-k3s.io",
  "*.on-rancher.cloud",
  "*.on-rio.io",
  "readthedocs.io",
  "rhcloud.com",
  "app.render.com",
  "onrender.com",
  "repl.co",
  "id.repl.co",
  "repl.run",
  "resindevice.io",
  "devices.resinstaging.io",
  "hzc.io",
  "wellbeingzone.eu",
  "wellbeingzone.co.uk",
  "adimo.co.uk",
  "itcouldbewor.se",
  "git-pages.rit.edu",
  "rocky.page",
  "биз.рус",
  "ком.рус",
  "крым.рус",
  "мир.рус",
  "мск.рус",
  "орг.рус",
  "самара.рус",
  "сочи.рус",
  "спб.рус",
  "я.рус",
  "*.builder.code.com",
  "*.dev-builder.code.com",
  "*.stg-builder.code.com",
  "sandcats.io",
  "logoip.de",
  "logoip.com",
  "fr-par-1.baremetal.scw.cloud",
  "fr-par-2.baremetal.scw.cloud",
  "nl-ams-1.baremetal.scw.cloud",
  "fnc.fr-par.scw.cloud",
  "functions.fnc.fr-par.scw.cloud",
  "k8s.fr-par.scw.cloud",
  "nodes.k8s.fr-par.scw.cloud",
  "s3.fr-par.scw.cloud",
  "s3-website.fr-par.scw.cloud",
  "whm.fr-par.scw.cloud",
  "priv.instances.scw.cloud",
  "pub.instances.scw.cloud",
  "k8s.scw.cloud",
  "k8s.nl-ams.scw.cloud",
  "nodes.k8s.nl-ams.scw.cloud",
  "s3.nl-ams.scw.cloud",
  "s3-website.nl-ams.scw.cloud",
  "whm.nl-ams.scw.cloud",
  "k8s.pl-waw.scw.cloud",
  "nodes.k8s.pl-waw.scw.cloud",
  "s3.pl-waw.scw.cloud",
  "s3-website.pl-waw.scw.cloud",
  "scalebook.scw.cloud",
  "smartlabeling.scw.cloud",
  "dedibox.fr",
  "schokokeks.net",
  "gov.scot",
  "service.gov.scot",
  "scrysec.com",
  "firewall-gateway.com",
  "firewall-gateway.de",
  "my-gateway.de",
  "my-router.de",
  "spdns.de",
  "spdns.eu",
  "firewall-gateway.net",
  "my-firewall.org",
  "myfirewall.org",
  "spdns.org",
  "seidat.net",
  "sellfy.store",
  "senseering.net",
  "minisite.ms",
  "magnet.page",
  "biz.ua",
  "co.ua",
  "pp.ua",
  "shiftcrypto.dev",
  "shiftcrypto.io",
  "shiftedit.io",
  "myshopblocks.com",
  "myshopify.com",
  "shopitsite.com",
  "shopware.store",
  "mo-siemens.io",
  "1kapp.com",
  "appchizi.com",
  "applinzi.com",
  "sinaapp.com",
  "vipsinaapp.com",
  "siteleaf.net",
  "bounty-full.com",
  "alpha.bounty-full.com",
  "beta.bounty-full.com",
  "small-web.org",
  "vp4.me",
  "try-snowplow.com",
  "srht.site",
  "stackhero-network.com",
  "musician.io",
  "novecore.site",
  "static.land",
  "dev.static.land",
  "sites.static.land",
  "storebase.store",
  "vps-host.net",
  "atl.jelastic.vps-host.net",
  "njs.jelastic.vps-host.net",
  "ric.jelastic.vps-host.net",
  "playstation-cloud.com",
  "apps.lair.io",
  "*.stolos.io",
  "spacekit.io",
  "customer.speedpartner.de",
  "myspreadshop.at",
  "myspreadshop.com.au",
  "myspreadshop.be",
  "myspreadshop.ca",
  "myspreadshop.ch",
  "myspreadshop.com",
  "myspreadshop.de",
  "myspreadshop.dk",
  "myspreadshop.es",
  "myspreadshop.fi",
  "myspreadshop.fr",
  "myspreadshop.ie",
  "myspreadshop.it",
  "myspreadshop.net",
  "myspreadshop.nl",
  "myspreadshop.no",
  "myspreadshop.pl",
  "myspreadshop.se",
  "myspreadshop.co.uk",
  "api.stdlib.com",
  "storj.farm",
  "utwente.io",
  "soc.srcf.net",
  "user.srcf.net",
  "temp-dns.com",
  "supabase.co",
  "supabase.in",
  "supabase.net",
  "su.paba.se",
  "*.s5y.io",
  "*.sensiosite.cloud",
  "syncloud.it",
  "dscloud.biz",
  "direct.quickconnect.cn",
  "dsmynas.com",
  "familyds.com",
  "diskstation.me",
  "dscloud.me",
  "i234.me",
  "myds.me",
  "synology.me",
  "dscloud.mobi",
  "dsmynas.net",
  "familyds.net",
  "dsmynas.org",
  "familyds.org",
  "vpnplus.to",
  "direct.quickconnect.to",
  "tabitorder.co.il",
  "taifun-dns.de",
  "beta.tailscale.net",
  "ts.net",
  "gda.pl",
  "gdansk.pl",
  "gdynia.pl",
  "med.pl",
  "sopot.pl",
  "site.tb-hosting.com",
  "edugit.io",
  "s3.teckids.org",
  "telebit.app",
  "telebit.io",
  "*.telebit.xyz",
  "gwiddle.co.uk",
  "*.firenet.ch",
  "*.svc.firenet.ch",
  "reservd.com",
  "thingdustdata.com",
  "cust.dev.thingdust.io",
  "cust.disrec.thingdust.io",
  "cust.prod.thingdust.io",
  "cust.testing.thingdust.io",
  "reservd.dev.thingdust.io",
  "reservd.disrec.thingdust.io",
  "reservd.testing.thingdust.io",
  "tickets.io",
  "arvo.network",
  "azimuth.network",
  "tlon.network",
  "torproject.net",
  "pages.torproject.net",
  "bloxcms.com",
  "townnews-staging.com",
  "tbits.me",
  "12hp.at",
  "2ix.at",
  "4lima.at",
  "lima-city.at",
  "12hp.ch",
  "2ix.ch",
  "4lima.ch",
  "lima-city.ch",
  "trafficplex.cloud",
  "de.cool",
  "12hp.de",
  "2ix.de",
  "4lima.de",
  "lima-city.de",
  "1337.pictures",
  "clan.rip",
  "lima-city.rocks",
  "webspace.rocks",
  "lima.zone",
  "*.transurl.be",
  "*.transurl.eu",
  "*.transurl.nl",
  "site.transip.me",
  "tuxfamily.org",
  "dd-dns.de",
  "diskstation.eu",
  "diskstation.org",
  "dray-dns.de",
  "draydns.de",
  "dyn-vpn.de",
  "dynvpn.de",
  "mein-vigor.de",
  "my-vigor.de",
  "my-wan.de",
  "syno-ds.de",
  "synology-diskstation.de",
  "synology-ds.de",
  "typedream.app",
  "pro.typeform.com",
  "uber.space",
  "*.uberspace.de",
  "hk.com",
  "hk.org",
  "ltd.hk",
  "inc.hk",
  "name.pm",
  "sch.tf",
  "biz.wf",
  "sch.wf",
  "org.yt",
  "virtualuser.de",
  "virtual-user.de",
  "upli.io",
  "urown.cloud",
  "dnsupdate.info",
  "lib.de.us",
  "2038.io",
  "vercel.app",
  "vercel.dev",
  "now.sh",
  "router.management",
  "v-info.info",
  "voorloper.cloud",
  "neko.am",
  "nyaa.am",
  "be.ax",
  "cat.ax",
  "es.ax",
  "eu.ax",
  "gg.ax",
  "mc.ax",
  "us.ax",
  "xy.ax",
  "nl.ci",
  "xx.gl",
  "app.gp",
  "blog.gt",
  "de.gt",
  "to.gt",
  "be.gy",
  "cc.hn",
  "blog.kg",
  "io.kg",
  "jp.kg",
  "tv.kg",
  "uk.kg",
  "us.kg",
  "de.ls",
  "at.md",
  "de.md",
  "jp.md",
  "to.md",
  "indie.porn",
  "vxl.sh",
  "ch.tc",
  "me.tc",
  "we.tc",
  "nyan.to",
  "at.vg",
  "blog.vu",
  "dev.vu",
  "me.vu",
  "v.ua",
  "*.vultrobjects.com",
  "wafflecell.com",
  "*.webhare.dev",
  "reserve-online.net",
  "reserve-online.com",
  "bookonline.app",
  "hotelwithflight.com",
  "wedeploy.io",
  "wedeploy.me",
  "wedeploy.sh",
  "remotewd.com",
  "pages.wiardweb.com",
  "wmflabs.org",
  "toolforge.org",
  "wmcloud.org",
  "panel.gg",
  "daemon.panel.gg",
  "messwithdns.com",
  "woltlab-demo.com",
  "myforum.community",
  "community-pro.de",
  "diskussionsbereich.de",
  "community-pro.net",
  "meinforum.net",
  "affinitylottery.org.uk",
  "raffleentry.org.uk",
  "weeklylottery.org.uk",
  "wpenginepowered.com",
  "js.wpenginepowered.com",
  "wixsite.com",
  "editorx.io",
  "half.host",
  "xnbay.com",
  "u2.xnbay.com",
  "u2-local.xnbay.com",
  "cistron.nl",
  "demon.nl",
  "xs4all.space",
  "yandexcloud.net",
  "storage.yandexcloud.net",
  "website.yandexcloud.net",
  "official.academy",
  "yolasite.com",
  "ybo.faith",
  "yombo.me",
  "homelink.one",
  "ybo.party",
  "ybo.review",
  "ybo.science",
  "ybo.trade",
  "ynh.fr",
  "nohost.me",
  "noho.st",
  "za.net",
  "za.org",
  "bss.design",
  "basicserver.io",
  "virtualserver.io",
  "enterprisecloud.nu"
];
(function(exports2) {
  var Punycode = require$$0;
  var internals = {};
  internals.rules = require$$1.map(function(rule) {
    return {
      rule,
      suffix: rule.replace(/^(\*\.|\!)/, ""),
      punySuffix: -1,
      wildcard: rule.charAt(0) === "*",
      exception: rule.charAt(0) === "!"
    };
  });
  internals.endsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };
  internals.findRule = function(domain) {
    var punyDomain = Punycode.toASCII(domain);
    return internals.rules.reduce(function(memo, rule) {
      if (rule.punySuffix === -1) {
        rule.punySuffix = Punycode.toASCII(rule.suffix);
      }
      if (!internals.endsWith(punyDomain, "." + rule.punySuffix) && punyDomain !== rule.punySuffix) {
        return memo;
      }
      return rule;
    }, null);
  };
  exports2.errorCodes = {
    DOMAIN_TOO_SHORT: "Domain name too short.",
    DOMAIN_TOO_LONG: "Domain name too long. It should be no more than 255 chars.",
    LABEL_STARTS_WITH_DASH: "Domain name label can not start with a dash.",
    LABEL_ENDS_WITH_DASH: "Domain name label can not end with a dash.",
    LABEL_TOO_LONG: "Domain name label should be at most 63 chars long.",
    LABEL_TOO_SHORT: "Domain name label should be at least 1 character long.",
    LABEL_INVALID_CHARS: "Domain name label can only contain alphanumeric characters or dashes."
  };
  internals.validate = function(input) {
    var ascii = Punycode.toASCII(input);
    if (ascii.length < 1) {
      return "DOMAIN_TOO_SHORT";
    }
    if (ascii.length > 255) {
      return "DOMAIN_TOO_LONG";
    }
    var labels = ascii.split(".");
    var label;
    for (var i = 0; i < labels.length; ++i) {
      label = labels[i];
      if (!label.length) {
        return "LABEL_TOO_SHORT";
      }
      if (label.length > 63) {
        return "LABEL_TOO_LONG";
      }
      if (label.charAt(0) === "-") {
        return "LABEL_STARTS_WITH_DASH";
      }
      if (label.charAt(label.length - 1) === "-") {
        return "LABEL_ENDS_WITH_DASH";
      }
      if (!/^[a-z0-9\-]+$/.test(label)) {
        return "LABEL_INVALID_CHARS";
      }
    }
  };
  exports2.parse = function(input) {
    if (typeof input !== "string") {
      throw new TypeError("Domain name must be a string.");
    }
    var domain = input.slice(0).toLowerCase();
    if (domain.charAt(domain.length - 1) === ".") {
      domain = domain.slice(0, domain.length - 1);
    }
    var error2 = internals.validate(domain);
    if (error2) {
      return {
        input,
        error: {
          message: exports2.errorCodes[error2],
          code: error2
        }
      };
    }
    var parsed = {
      input,
      tld: null,
      sld: null,
      domain: null,
      subdomain: null,
      listed: false
    };
    var domainParts = domain.split(".");
    if (domainParts[domainParts.length - 1] === "local") {
      return parsed;
    }
    var handlePunycode = function() {
      if (!/xn--/.test(domain)) {
        return parsed;
      }
      if (parsed.domain) {
        parsed.domain = Punycode.toASCII(parsed.domain);
      }
      if (parsed.subdomain) {
        parsed.subdomain = Punycode.toASCII(parsed.subdomain);
      }
      return parsed;
    };
    var rule = internals.findRule(domain);
    if (!rule) {
      if (domainParts.length < 2) {
        return parsed;
      }
      parsed.tld = domainParts.pop();
      parsed.sld = domainParts.pop();
      parsed.domain = [parsed.sld, parsed.tld].join(".");
      if (domainParts.length) {
        parsed.subdomain = domainParts.pop();
      }
      return handlePunycode();
    }
    parsed.listed = true;
    var tldParts = rule.suffix.split(".");
    var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);
    if (rule.exception) {
      privateParts.push(tldParts.shift());
    }
    parsed.tld = tldParts.join(".");
    if (!privateParts.length) {
      return handlePunycode();
    }
    if (rule.wildcard) {
      tldParts.unshift(privateParts.pop());
      parsed.tld = tldParts.join(".");
    }
    if (!privateParts.length) {
      return handlePunycode();
    }
    parsed.sld = privateParts.pop();
    parsed.domain = [parsed.sld, parsed.tld].join(".");
    if (privateParts.length) {
      parsed.subdomain = privateParts.join(".");
    }
    return handlePunycode();
  };
  exports2.get = function(domain) {
    if (!domain) {
      return null;
    }
    return exports2.parse(domain).domain || null;
  };
  exports2.isValid = function(domain) {
    var parsed = exports2.parse(domain);
    return Boolean(parsed.domain && parsed.listed);
  };
})(psl$1);
const psl = /* @__PURE__ */ getDefaultExportFromCjs(psl$1);
var util$2;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys3 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys3.push(key);
      }
    }
    return keys3;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util$2 || (util$2 = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util$2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util$2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el2 = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util$2.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util$2.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util$2.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util$2.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util$2.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util$2.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a2;
    const ctx = {
      common: {
        issues: [],
        async: (_a2 = params === null || params === void 0 ? void 0 : params.async) !== null && _a2 !== void 0 ? _a2 : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[a-z][a-z0-9]*$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip2, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip2)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip2)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a2) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex2 = datetimeRegex(check);
        if (!regex2.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex2, validation, message) {
    return this.refinement((data) => regex2.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a2;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex2, message) {
    return this._addCheck({
      kind: "regex",
      regex: regex2,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a2;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util$2.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util$2.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a2;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a2 = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a2 !== void 0 ? _a2 : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util$2.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min === null || ch2.value > min)
          min = ch2.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys3 = util$2.objectKeys(shape);
    return this._cached = { shape, keys: keys3 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a2, _b, _c2, _d;
          const defaultError = (_c2 = (_b = (_a2 = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util$2.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util$2.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util$2.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util$2.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util$2.objectKeys(b2);
    const sharedKeys = util$2.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error2 = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error2.addIssue(makeArgsIssue(args, e2));
          throw error2;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error2.addIssue(makeReturnsIssue(result, e2));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util$2.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util$2.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util$2.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base2 = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base2))
          return base2;
        const result = effect.transform(base2.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {
          if (!isValid(base2))
            return base2;
          return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util$2.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
const custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a2 = p2.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util$2;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var naclFast = { exports: {} };
(function(module2) {
  (function(nacl) {
    var gf2 = function(init3) {
      var i, r2 = new Float64Array(16);
      if (init3)
        for (i = 0; i < init3.length; i++)
          r2[i] = init3[i];
      return r2;
    };
    var randombytes = function() {
      throw new Error("no PRNG");
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf2(), gf1 = gf2([1]), _121665 = gf2([56129, 1]), D2 = gf2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function ts64(x, i, h2, l2) {
      x[i] = h2 >> 24 & 255;
      x[i + 1] = h2 >> 16 & 255;
      x[i + 2] = h2 >> 8 & 255;
      x[i + 3] = h2 & 255;
      x[i + 4] = l2 >> 24 & 255;
      x[i + 5] = l2 >> 16 & 255;
      x[i + 6] = l2 >> 8 & 255;
      x[i + 7] = l2 & 255;
    }
    function vn(x, xi2, y2, yi2, n2) {
      var i, d2 = 0;
      for (i = 0; i < n2; i++)
        d2 |= x[xi2 + i] ^ y2[yi2 + i];
      return (1 & d2 - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi2, y2, yi2) {
      return vn(x, xi2, y2, yi2, 16);
    }
    function crypto_verify_32(x, xi2, y2, yi2) {
      return vn(x, xi2, y2, yi2, 32);
    }
    function core_salsa20(o2, p2, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i = 0; i < 20; i += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      x0 = x0 + j0 | 0;
      x1 = x1 + j1 | 0;
      x2 = x2 + j2 | 0;
      x3 = x3 + j3 | 0;
      x4 = x4 + j4 | 0;
      x5 = x5 + j5 | 0;
      x6 = x6 + j6 | 0;
      x7 = x7 + j7 | 0;
      x8 = x8 + j8 | 0;
      x9 = x9 + j9 | 0;
      x10 = x10 + j10 | 0;
      x11 = x11 + j11 | 0;
      x12 = x12 + j12 | 0;
      x13 = x13 + j13 | 0;
      x14 = x14 + j14 | 0;
      x15 = x15 + j15 | 0;
      o2[0] = x0 >>> 0 & 255;
      o2[1] = x0 >>> 8 & 255;
      o2[2] = x0 >>> 16 & 255;
      o2[3] = x0 >>> 24 & 255;
      o2[4] = x1 >>> 0 & 255;
      o2[5] = x1 >>> 8 & 255;
      o2[6] = x1 >>> 16 & 255;
      o2[7] = x1 >>> 24 & 255;
      o2[8] = x2 >>> 0 & 255;
      o2[9] = x2 >>> 8 & 255;
      o2[10] = x2 >>> 16 & 255;
      o2[11] = x2 >>> 24 & 255;
      o2[12] = x3 >>> 0 & 255;
      o2[13] = x3 >>> 8 & 255;
      o2[14] = x3 >>> 16 & 255;
      o2[15] = x3 >>> 24 & 255;
      o2[16] = x4 >>> 0 & 255;
      o2[17] = x4 >>> 8 & 255;
      o2[18] = x4 >>> 16 & 255;
      o2[19] = x4 >>> 24 & 255;
      o2[20] = x5 >>> 0 & 255;
      o2[21] = x5 >>> 8 & 255;
      o2[22] = x5 >>> 16 & 255;
      o2[23] = x5 >>> 24 & 255;
      o2[24] = x6 >>> 0 & 255;
      o2[25] = x6 >>> 8 & 255;
      o2[26] = x6 >>> 16 & 255;
      o2[27] = x6 >>> 24 & 255;
      o2[28] = x7 >>> 0 & 255;
      o2[29] = x7 >>> 8 & 255;
      o2[30] = x7 >>> 16 & 255;
      o2[31] = x7 >>> 24 & 255;
      o2[32] = x8 >>> 0 & 255;
      o2[33] = x8 >>> 8 & 255;
      o2[34] = x8 >>> 16 & 255;
      o2[35] = x8 >>> 24 & 255;
      o2[36] = x9 >>> 0 & 255;
      o2[37] = x9 >>> 8 & 255;
      o2[38] = x9 >>> 16 & 255;
      o2[39] = x9 >>> 24 & 255;
      o2[40] = x10 >>> 0 & 255;
      o2[41] = x10 >>> 8 & 255;
      o2[42] = x10 >>> 16 & 255;
      o2[43] = x10 >>> 24 & 255;
      o2[44] = x11 >>> 0 & 255;
      o2[45] = x11 >>> 8 & 255;
      o2[46] = x11 >>> 16 & 255;
      o2[47] = x11 >>> 24 & 255;
      o2[48] = x12 >>> 0 & 255;
      o2[49] = x12 >>> 8 & 255;
      o2[50] = x12 >>> 16 & 255;
      o2[51] = x12 >>> 24 & 255;
      o2[52] = x13 >>> 0 & 255;
      o2[53] = x13 >>> 8 & 255;
      o2[54] = x13 >>> 16 & 255;
      o2[55] = x13 >>> 24 & 255;
      o2[56] = x14 >>> 0 & 255;
      o2[57] = x14 >>> 8 & 255;
      o2[58] = x14 >>> 16 & 255;
      o2[59] = x14 >>> 24 & 255;
      o2[60] = x15 >>> 0 & 255;
      o2[61] = x15 >>> 8 & 255;
      o2[62] = x15 >>> 16 & 255;
      o2[63] = x15 >>> 24 & 255;
    }
    function core_hsalsa20(o2, p2, k2, c2) {
      var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
      var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
      for (var i = 0; i < 20; i += 2) {
        u2 = x0 + x12 | 0;
        x4 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x4 + x0 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x4 | 0;
        x12 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x12 + x8 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x1 | 0;
        x9 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x9 + x5 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x9 | 0;
        x1 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x1 + x13 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x6 | 0;
        x14 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x14 + x10 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x14 | 0;
        x6 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x6 + x2 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x11 | 0;
        x3 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x3 + x15 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x3 | 0;
        x11 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x11 + x7 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x0 + x3 | 0;
        x1 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x1 + x0 | 0;
        x2 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x2 + x1 | 0;
        x3 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x3 + x2 | 0;
        x0 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x5 + x4 | 0;
        x6 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x6 + x5 | 0;
        x7 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x7 + x6 | 0;
        x4 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x4 + x7 | 0;
        x5 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x10 + x9 | 0;
        x11 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x11 + x10 | 0;
        x8 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x8 + x11 | 0;
        x9 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x9 + x8 | 0;
        x10 ^= u2 << 18 | u2 >>> 32 - 18;
        u2 = x15 + x14 | 0;
        x12 ^= u2 << 7 | u2 >>> 32 - 7;
        u2 = x12 + x15 | 0;
        x13 ^= u2 << 9 | u2 >>> 32 - 9;
        u2 = x13 + x12 | 0;
        x14 ^= u2 << 13 | u2 >>> 32 - 13;
        u2 = x14 + x13 | 0;
        x15 ^= u2 << 18 | u2 >>> 32 - 18;
      }
      o2[0] = x0 >>> 0 & 255;
      o2[1] = x0 >>> 8 & 255;
      o2[2] = x0 >>> 16 & 255;
      o2[3] = x0 >>> 24 & 255;
      o2[4] = x5 >>> 0 & 255;
      o2[5] = x5 >>> 8 & 255;
      o2[6] = x5 >>> 16 & 255;
      o2[7] = x5 >>> 24 & 255;
      o2[8] = x10 >>> 0 & 255;
      o2[9] = x10 >>> 8 & 255;
      o2[10] = x10 >>> 16 & 255;
      o2[11] = x10 >>> 24 & 255;
      o2[12] = x15 >>> 0 & 255;
      o2[13] = x15 >>> 8 & 255;
      o2[14] = x15 >>> 16 & 255;
      o2[15] = x15 >>> 24 & 255;
      o2[16] = x6 >>> 0 & 255;
      o2[17] = x6 >>> 8 & 255;
      o2[18] = x6 >>> 16 & 255;
      o2[19] = x6 >>> 24 & 255;
      o2[20] = x7 >>> 0 & 255;
      o2[21] = x7 >>> 8 & 255;
      o2[22] = x7 >>> 16 & 255;
      o2[23] = x7 >>> 24 & 255;
      o2[24] = x8 >>> 0 & 255;
      o2[25] = x8 >>> 8 & 255;
      o2[26] = x8 >>> 16 & 255;
      o2[27] = x8 >>> 24 & 255;
      o2[28] = x9 >>> 0 & 255;
      o2[29] = x9 >>> 8 & 255;
      o2[30] = x9 >>> 16 & 255;
      o2[31] = x9 >>> 24 & 255;
    }
    function crypto_core_salsa20(out, inp, k2, c2) {
      core_salsa20(out, inp, k2, c2);
    }
    function crypto_core_hsalsa20(out, inp, k2, c2) {
      core_hsalsa20(out, inp, k2, c2);
    }
    var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function crypto_stream_salsa20_xor(c2, cpos, m2, mpos, b2, n2, k2) {
      var z2 = new Uint8Array(16), x = new Uint8Array(64);
      var u2, i;
      for (i = 0; i < 16; i++)
        z2[i] = 0;
      for (i = 0; i < 8; i++)
        z2[i] = n2[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x, z2, k2, sigma);
        for (i = 0; i < 64; i++)
          c2[cpos + i] = m2[mpos + i] ^ x[i];
        u2 = 1;
        for (i = 8; i < 16; i++) {
          u2 = u2 + (z2[i] & 255) | 0;
          z2[i] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x, z2, k2, sigma);
        for (i = 0; i < b2; i++)
          c2[cpos + i] = m2[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c2, cpos, b2, n2, k2) {
      var z2 = new Uint8Array(16), x = new Uint8Array(64);
      var u2, i;
      for (i = 0; i < 16; i++)
        z2[i] = 0;
      for (i = 0; i < 8; i++)
        z2[i] = n2[i];
      while (b2 >= 64) {
        crypto_core_salsa20(x, z2, k2, sigma);
        for (i = 0; i < 64; i++)
          c2[cpos + i] = x[i];
        u2 = 1;
        for (i = 8; i < 16; i++) {
          u2 = u2 + (z2[i] & 255) | 0;
          z2[i] = u2 & 255;
          u2 >>>= 8;
        }
        b2 -= 64;
        cpos += 64;
      }
      if (b2 > 0) {
        crypto_core_salsa20(x, z2, k2, sigma);
        for (i = 0; i < b2; i++)
          c2[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c2, cpos, d2, n2, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n2, k2, sigma);
      var sn2 = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn2[i] = n2[i + 16];
      return crypto_stream_salsa20(c2, cpos, d2, sn2, s2);
    }
    function crypto_stream_xor(c2, cpos, m2, mpos, d2, n2, k2) {
      var s2 = new Uint8Array(32);
      crypto_core_hsalsa20(s2, n2, k2, sigma);
      var sn2 = new Uint8Array(8);
      for (var i = 0; i < 8; i++)
        sn2[i] = n2[i + 16];
      return crypto_stream_salsa20_xor(c2, cpos, m2, mpos, d2, sn2, s2);
    }
    var poly1305 = function(key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = key[0] & 255 | (key[1] & 255) << 8;
      this.r[0] = t0 & 8191;
      t1 = key[2] & 255 | (key[3] & 255) << 8;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      t2 = key[4] & 255 | (key[5] & 255) << 8;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      t3 = key[6] & 255 | (key[7] & 255) << 8;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      t4 = key[8] & 255 | (key[9] & 255) << 8;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      t5 = key[10] & 255 | (key[11] & 255) << 8;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      t6 = key[12] & 255 | (key[13] & 255) << 8;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      t7 = key[14] & 255 | (key[15] & 255) << 8;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
      this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
      this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
      this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
      this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
      this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
      this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
      this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
    };
    poly1305.prototype.blocks = function(m2, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c2;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
      var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
      while (bytes >= 16) {
        t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
        h0 += t0 & 8191;
        t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
        h1 += (t0 >>> 13 | t1 << 3) & 8191;
        t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
        h2 += (t1 >>> 10 | t2 << 6) & 8191;
        t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
        h3 += (t2 >>> 7 | t3 << 9) & 8191;
        t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
        h4 += (t3 >>> 4 | t4 << 12) & 8191;
        h5 += t4 >>> 1 & 8191;
        t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
        h6 += (t4 >>> 14 | t5 << 2) & 8191;
        t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
        h7 += (t5 >>> 11 | t6 << 5) & 8191;
        t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
        h8 += (t6 >>> 8 | t7 << 8) & 8191;
        h9 += t7 >>> 5 | hibit;
        c2 = 0;
        d0 = c2;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c2 = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c2 += d0 >>> 13;
        d0 &= 8191;
        d1 = c2;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c2 = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c2 += d1 >>> 13;
        d1 &= 8191;
        d2 = c2;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c2 = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c2 += d2 >>> 13;
        d2 &= 8191;
        d3 = c2;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c2 = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c2 += d3 >>> 13;
        d3 &= 8191;
        d4 = c2;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c2 = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c2 += d4 >>> 13;
        d4 &= 8191;
        d5 = c2;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c2 = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c2 += d5 >>> 13;
        d5 &= 8191;
        d6 = c2;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c2 = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c2 += d6 >>> 13;
        d6 &= 8191;
        d7 = c2;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c2 = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c2 += d7 >>> 13;
        d7 &= 8191;
        d8 = c2;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c2 = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c2 += d8 >>> 13;
        d8 &= 8191;
        d9 = c2;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c2 = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c2 += d9 >>> 13;
        d9 &= 8191;
        c2 = (c2 << 2) + c2 | 0;
        c2 = c2 + d0 | 0;
        d0 = c2 & 8191;
        c2 = c2 >>> 13;
        d1 += c2;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
      var g2 = new Uint16Array(10);
      var c2, mask, f2, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c2;
        c2 = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c2 * 5;
      c2 = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c2;
      c2 = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c2;
      g2[0] = this.h[0] + 5;
      c2 = g2[0] >>> 13;
      g2[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g2[i] = this.h[i] + c2;
        c2 = g2[i] >>> 13;
        g2[i] &= 8191;
      }
      g2[9] -= 1 << 13;
      mask = (c2 ^ 1) - 1;
      for (i = 0; i < 10; i++)
        g2[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g2[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      f2 = this.h[0] + this.pad[0];
      this.h[0] = f2 & 65535;
      for (i = 1; i < 8; i++) {
        f2 = (this.h[i] + this.pad[i] | 0) + (f2 >>> 16) | 0;
        this.h[i] = f2 & 65535;
      }
      mac[macpos + 0] = this.h[0] >>> 0 & 255;
      mac[macpos + 1] = this.h[0] >>> 8 & 255;
      mac[macpos + 2] = this.h[1] >>> 0 & 255;
      mac[macpos + 3] = this.h[1] >>> 8 & 255;
      mac[macpos + 4] = this.h[2] >>> 0 & 255;
      mac[macpos + 5] = this.h[2] >>> 8 & 255;
      mac[macpos + 6] = this.h[3] >>> 0 & 255;
      mac[macpos + 7] = this.h[3] >>> 8 & 255;
      mac[macpos + 8] = this.h[4] >>> 0 & 255;
      mac[macpos + 9] = this.h[4] >>> 8 & 255;
      mac[macpos + 10] = this.h[5] >>> 0 & 255;
      mac[macpos + 11] = this.h[5] >>> 8 & 255;
      mac[macpos + 12] = this.h[6] >>> 0 & 255;
      mac[macpos + 13] = this.h[6] >>> 8 & 255;
      mac[macpos + 14] = this.h[7] >>> 0 & 255;
      mac[macpos + 15] = this.h[7] >>> 8 & 255;
    };
    poly1305.prototype.update = function(m2, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (i = 0; i < want; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - bytes % 16;
        this.blocks(m2, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m2[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m2, mpos, n2, k2) {
      var s2 = new poly1305(k2);
      s2.update(m2, mpos, n2);
      s2.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n2, k2) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m2, mpos, n2, k2);
      return crypto_verify_16(h2, hpos, x, 0);
    }
    function crypto_secretbox(c2, m2, d2, n2, k2) {
      var i;
      if (d2 < 32)
        return -1;
      crypto_stream_xor(c2, 0, m2, 0, d2, n2, k2);
      crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
      for (i = 0; i < 16; i++)
        c2[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m2, c2, d2, n2, k2) {
      var i;
      var x = new Uint8Array(32);
      if (d2 < 32)
        return -1;
      crypto_stream(x, 0, 32, n2, k2);
      if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x) !== 0)
        return -1;
      crypto_stream_xor(m2, 0, c2, 0, d2, n2, k2);
      for (i = 0; i < 32; i++)
        m2[i] = 0;
      return 0;
    }
    function set25519(r2, a2) {
      var i;
      for (i = 0; i < 16; i++)
        r2[i] = a2[i] | 0;
    }
    function car25519(o2) {
      var i, v2, c2 = 1;
      for (i = 0; i < 16; i++) {
        v2 = o2[i] + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        o2[i] = v2 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q2, b2) {
      var t2, c2 = ~(b2 - 1);
      for (var i = 0; i < 16; i++) {
        t2 = c2 & (p2[i] ^ q2[i]);
        p2[i] ^= t2;
        q2[i] ^= t2;
      }
    }
    function pack25519(o2, n2) {
      var i, j, b2;
      var m2 = gf2(), t2 = gf2();
      for (i = 0; i < 16; i++)
        t2[i] = n2[i];
      car25519(t2);
      car25519(t2);
      car25519(t2);
      for (j = 0; j < 2; j++) {
        m2[0] = t2[0] - 65517;
        for (i = 1; i < 15; i++) {
          m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
          m2[i - 1] &= 65535;
        }
        m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t2, m2, 1 - b2);
      }
      for (i = 0; i < 16; i++) {
        o2[2 * i] = t2[i] & 255;
        o2[2 * i + 1] = t2[i] >> 8;
      }
    }
    function neq25519(a2, b2) {
      var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
      pack25519(c2, a2);
      pack25519(d2, b2);
      return crypto_verify_32(c2, 0, d2, 0);
    }
    function par25519(a2) {
      var d2 = new Uint8Array(32);
      pack25519(d2, a2);
      return d2[0] & 1;
    }
    function unpack25519(o2, n2) {
      var i;
      for (i = 0; i < 16; i++)
        o2[i] = n2[2 * i] + (n2[2 * i + 1] << 8);
      o2[15] &= 32767;
    }
    function A2(o2, a2, b2) {
      for (var i = 0; i < 16; i++)
        o2[i] = a2[i] + b2[i];
    }
    function Z2(o2, a2, b2) {
      for (var i = 0; i < 16; i++)
        o2[i] = a2[i] - b2[i];
    }
    function M2(o2, a2, b2) {
      var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t0;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
    function S2(o2, a2) {
      M2(o2, a2, a2);
    }
    function inv25519(o2, i) {
      var c2 = gf2();
      var a2;
      for (a2 = 0; a2 < 16; a2++)
        c2[a2] = i[a2];
      for (a2 = 253; a2 >= 0; a2--) {
        S2(c2, c2);
        if (a2 !== 2 && a2 !== 4)
          M2(c2, c2, i);
      }
      for (a2 = 0; a2 < 16; a2++)
        o2[a2] = c2[a2];
    }
    function pow2523(o2, i) {
      var c2 = gf2();
      var a2;
      for (a2 = 0; a2 < 16; a2++)
        c2[a2] = i[a2];
      for (a2 = 250; a2 >= 0; a2--) {
        S2(c2, c2);
        if (a2 !== 1)
          M2(c2, c2, i);
      }
      for (a2 = 0; a2 < 16; a2++)
        o2[a2] = c2[a2];
    }
    function crypto_scalarmult(q2, n2, p2) {
      var z2 = new Uint8Array(32);
      var x = new Float64Array(80), r2, i;
      var a2 = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2();
      for (i = 0; i < 31; i++)
        z2[i] = n2[i];
      z2[31] = n2[31] & 127 | 64;
      z2[0] &= 248;
      unpack25519(x, p2);
      for (i = 0; i < 16; i++) {
        b2[i] = x[i];
        d2[i] = a2[i] = c2[i] = 0;
      }
      a2[0] = d2[0] = 1;
      for (i = 254; i >= 0; --i) {
        r2 = z2[i >>> 3] >>> (i & 7) & 1;
        sel25519(a2, b2, r2);
        sel25519(c2, d2, r2);
        A2(e2, a2, c2);
        Z2(a2, a2, c2);
        A2(c2, b2, d2);
        Z2(b2, b2, d2);
        S2(d2, e2);
        S2(f2, a2);
        M2(a2, c2, a2);
        M2(c2, b2, e2);
        A2(e2, a2, c2);
        Z2(a2, a2, c2);
        S2(b2, a2);
        Z2(c2, d2, f2);
        M2(a2, c2, _121665);
        A2(a2, a2, d2);
        M2(c2, c2, a2);
        M2(a2, d2, f2);
        M2(d2, b2, x);
        S2(b2, e2);
        sel25519(a2, b2, r2);
        sel25519(c2, d2, r2);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a2[i];
        x[i + 32] = c2[i];
        x[i + 48] = b2[i];
        x[i + 64] = d2[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M2(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n2) {
      return crypto_scalarmult(q2, n2, _9);
    }
    function crypto_box_keypair(y2, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y2, x);
    }
    function crypto_box_beforenm(k2, y2, x) {
      var s2 = new Uint8Array(32);
      crypto_scalarmult(s2, x, y2);
      return crypto_core_hsalsa20(k2, _0, s2, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c2, m2, d2, n2, y2, x) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x);
      return crypto_box_afternm(c2, m2, d2, n2, k2);
    }
    function crypto_box_open(m2, c2, d2, n2, y2, x) {
      var k2 = new Uint8Array(32);
      crypto_box_beforenm(k2, y2, x);
      return crypto_box_open_afternm(m2, c2, d2, n2, k2);
    }
    var K2 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function crypto_hashblocks_hl(hh2, hl2, m2, n2) {
      var wh2 = new Int32Array(16), wl2 = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th2, tl2, i, j, h2, l2, a2, b2, c2, d2;
      var ah0 = hh2[0], ah1 = hh2[1], ah2 = hh2[2], ah3 = hh2[3], ah4 = hh2[4], ah5 = hh2[5], ah6 = hh2[6], ah7 = hh2[7], al0 = hl2[0], al1 = hl2[1], al2 = hl2[2], al3 = hl2[3], al4 = hl2[4], al5 = hl2[5], al6 = hl2[6], al7 = hl2[7];
      var pos = 0;
      while (n2 >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh2[i] = m2[j + 0] << 24 | m2[j + 1] << 16 | m2[j + 2] << 8 | m2[j + 3];
          wl2[i] = m2[j + 4] << 24 | m2[j + 5] << 16 | m2[j + 6] << 8 | m2[j + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h2 = ah7;
          l2 = al7;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah4 & ah5 ^ ~ah4 & ah6;
          l2 = al4 & al5 ^ ~al4 & al6;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = K2[i * 2];
          l2 = K2[i * 2 + 1];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = wh2[i % 16];
          l2 = wl2[i % 16];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          th2 = c2 & 65535 | d2 << 16;
          tl2 = a2 & 65535 | b2 << 16;
          h2 = th2;
          l2 = tl2;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          bh7 = c2 & 65535 | d2 << 16;
          bl7 = a2 & 65535 | b2 << 16;
          h2 = bh3;
          l2 = bl3;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = th2;
          l2 = tl2;
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          bh3 = c2 & 65535 | d2 << 16;
          bl3 = a2 & 65535 | b2 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0; j < 16; j++) {
              h2 = wh2[j];
              l2 = wl2[j];
              a2 = l2 & 65535;
              b2 = l2 >>> 16;
              c2 = h2 & 65535;
              d2 = h2 >>> 16;
              h2 = wh2[(j + 9) % 16];
              l2 = wl2[(j + 9) % 16];
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j + 1) % 16];
              tl2 = wl2[(j + 1) % 16];
              h2 = (th2 >>> 1 | tl2 << 32 - 1) ^ (th2 >>> 8 | tl2 << 32 - 8) ^ th2 >>> 7;
              l2 = (tl2 >>> 1 | th2 << 32 - 1) ^ (tl2 >>> 8 | th2 << 32 - 8) ^ (tl2 >>> 7 | th2 << 32 - 7);
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              th2 = wh2[(j + 14) % 16];
              tl2 = wl2[(j + 14) % 16];
              h2 = (th2 >>> 19 | tl2 << 32 - 19) ^ (tl2 >>> 61 - 32 | th2 << 32 - (61 - 32)) ^ th2 >>> 6;
              l2 = (tl2 >>> 19 | th2 << 32 - 19) ^ (th2 >>> 61 - 32 | tl2 << 32 - (61 - 32)) ^ (tl2 >>> 6 | th2 << 32 - 6);
              a2 += l2 & 65535;
              b2 += l2 >>> 16;
              c2 += h2 & 65535;
              d2 += h2 >>> 16;
              b2 += a2 >>> 16;
              c2 += b2 >>> 16;
              d2 += c2 >>> 16;
              wh2[j] = c2 & 65535 | d2 << 16;
              wl2[j] = a2 & 65535 | b2 << 16;
            }
          }
        }
        h2 = ah0;
        l2 = al0;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[0];
        l2 = hl2[0];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[0] = ah0 = c2 & 65535 | d2 << 16;
        hl2[0] = al0 = a2 & 65535 | b2 << 16;
        h2 = ah1;
        l2 = al1;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[1];
        l2 = hl2[1];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[1] = ah1 = c2 & 65535 | d2 << 16;
        hl2[1] = al1 = a2 & 65535 | b2 << 16;
        h2 = ah2;
        l2 = al2;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[2];
        l2 = hl2[2];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[2] = ah2 = c2 & 65535 | d2 << 16;
        hl2[2] = al2 = a2 & 65535 | b2 << 16;
        h2 = ah3;
        l2 = al3;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[3];
        l2 = hl2[3];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[3] = ah3 = c2 & 65535 | d2 << 16;
        hl2[3] = al3 = a2 & 65535 | b2 << 16;
        h2 = ah4;
        l2 = al4;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[4];
        l2 = hl2[4];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[4] = ah4 = c2 & 65535 | d2 << 16;
        hl2[4] = al4 = a2 & 65535 | b2 << 16;
        h2 = ah5;
        l2 = al5;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[5];
        l2 = hl2[5];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[5] = ah5 = c2 & 65535 | d2 << 16;
        hl2[5] = al5 = a2 & 65535 | b2 << 16;
        h2 = ah6;
        l2 = al6;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[6];
        l2 = hl2[6];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[6] = ah6 = c2 & 65535 | d2 << 16;
        hl2[6] = al6 = a2 & 65535 | b2 << 16;
        h2 = ah7;
        l2 = al7;
        a2 = l2 & 65535;
        b2 = l2 >>> 16;
        c2 = h2 & 65535;
        d2 = h2 >>> 16;
        h2 = hh2[7];
        l2 = hl2[7];
        a2 += l2 & 65535;
        b2 += l2 >>> 16;
        c2 += h2 & 65535;
        d2 += h2 >>> 16;
        b2 += a2 >>> 16;
        c2 += b2 >>> 16;
        d2 += c2 >>> 16;
        hh2[7] = ah7 = c2 & 65535 | d2 << 16;
        hl2[7] = al7 = a2 & 65535 | b2 << 16;
        pos += 128;
        n2 -= 128;
      }
      return n2;
    }
    function crypto_hash(out, m2, n2) {
      var hh2 = new Int32Array(8), hl2 = new Int32Array(8), x = new Uint8Array(256), i, b2 = n2;
      hh2[0] = 1779033703;
      hh2[1] = 3144134277;
      hh2[2] = 1013904242;
      hh2[3] = 2773480762;
      hh2[4] = 1359893119;
      hh2[5] = 2600822924;
      hh2[6] = 528734635;
      hh2[7] = 1541459225;
      hl2[0] = 4089235720;
      hl2[1] = 2227873595;
      hl2[2] = 4271175723;
      hl2[3] = 1595750129;
      hl2[4] = 2917565137;
      hl2[5] = 725511199;
      hl2[6] = 4215389547;
      hl2[7] = 327033209;
      crypto_hashblocks_hl(hh2, hl2, m2, n2);
      n2 %= 128;
      for (i = 0; i < n2; i++)
        x[i] = m2[b2 - n2 + i];
      x[n2] = 128;
      n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
      x[n2 - 9] = 0;
      ts64(x, n2 - 8, b2 / 536870912 | 0, b2 << 3);
      crypto_hashblocks_hl(hh2, hl2, x, n2);
      for (i = 0; i < 8; i++)
        ts64(out, 8 * i, hh2[i], hl2[i]);
      return 0;
    }
    function add(p2, q2) {
      var a2 = gf2(), b2 = gf2(), c2 = gf2(), d2 = gf2(), e2 = gf2(), f2 = gf2(), g2 = gf2(), h2 = gf2(), t2 = gf2();
      Z2(a2, p2[1], p2[0]);
      Z2(t2, q2[1], q2[0]);
      M2(a2, a2, t2);
      A2(b2, p2[0], p2[1]);
      A2(t2, q2[0], q2[1]);
      M2(b2, b2, t2);
      M2(c2, p2[3], q2[3]);
      M2(c2, c2, D22);
      M2(d2, p2[2], q2[2]);
      A2(d2, d2, d2);
      Z2(e2, b2, a2);
      Z2(f2, d2, c2);
      A2(g2, d2, c2);
      A2(h2, b2, a2);
      M2(p2[0], e2, f2);
      M2(p2[1], h2, g2);
      M2(p2[2], g2, f2);
      M2(p2[3], e2, h2);
    }
    function cswap(p2, q2, b2) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p2[i], q2[i], b2);
      }
    }
    function pack(r2, p2) {
      var tx = gf2(), ty = gf2(), zi2 = gf2();
      inv25519(zi2, p2[2]);
      M2(tx, p2[0], zi2);
      M2(ty, p2[1], zi2);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p2, q2, s2) {
      var b2, i;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i = 255; i >= 0; --i) {
        b2 = s2[i / 8 | 0] >> (i & 7) & 1;
        cswap(p2, q2, b2);
        add(q2, p2);
        add(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s2) {
      var q2 = [gf2(), gf2(), gf2(), gf2()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p2, q2, s2);
    }
    function crypto_sign_keypair(pk2, sk2, seeded) {
      var d2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      var i;
      if (!seeded)
        randombytes(sk2, 32);
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk2, p2);
      for (i = 0; i < 32; i++)
        sk2[i + 32] = pk2[i];
      return 0;
    }
    var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function modL(r2, x) {
      var carry, i, j, k2;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k2 = i - 12; j < k2; ++j) {
          x[j] += carry - 16 * x[i] * L2[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L2[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++)
        x[j] -= carry * L2[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r2[i] = x[i] & 255;
      }
    }
    function reduce(r2) {
      var x = new Float64Array(64), i;
      for (i = 0; i < 64; i++)
        x[i] = r2[i];
      for (i = 0; i < 64; i++)
        r2[i] = 0;
      modL(r2, x);
    }
    function crypto_sign(sm, m2, n2, sk2) {
      var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r2 = new Uint8Array(64);
      var i, j, x = new Float64Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()];
      crypto_hash(d2, sk2, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n2 + 64;
      for (i = 0; i < n2; i++)
        sm[64 + i] = m2[i];
      for (i = 0; i < 32; i++)
        sm[32 + i] = d2[32 + i];
      crypto_hash(r2, sm.subarray(32), n2 + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack(sm, p2);
      for (i = 32; i < 64; i++)
        sm[i] = sk2[i];
      crypto_hash(h2, sm, n2 + 64);
      reduce(h2);
      for (i = 0; i < 64; i++)
        x[i] = 0;
      for (i = 0; i < 32; i++)
        x[i] = r2[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h2[i] * d2[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r2, p2) {
      var t2 = gf2(), chk = gf2(), num = gf2(), den = gf2(), den2 = gf2(), den4 = gf2(), den6 = gf2();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S2(num, r2[1]);
      M2(den, num, D2);
      Z2(num, num, r2[2]);
      A2(den, r2[2], den);
      S2(den2, den);
      S2(den4, den2);
      M2(den6, den4, den2);
      M2(t2, den6, num);
      M2(t2, t2, den);
      pow2523(t2, t2);
      M2(t2, t2, num);
      M2(t2, t2, den);
      M2(t2, t2, den);
      M2(r2[0], t2, den);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        M2(r2[0], r2[0], I2);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num))
        return -1;
      if (par25519(r2[0]) === p2[31] >> 7)
        Z2(r2[0], gf0, r2[0]);
      M2(r2[3], r2[0], r2[1]);
      return 0;
    }
    function crypto_sign_open(m2, sm, n2, pk2) {
      var i;
      var t2 = new Uint8Array(32), h2 = new Uint8Array(64);
      var p2 = [gf2(), gf2(), gf2(), gf2()], q2 = [gf2(), gf2(), gf2(), gf2()];
      if (n2 < 64)
        return -1;
      if (unpackneg(q2, pk2))
        return -1;
      for (i = 0; i < n2; i++)
        m2[i] = sm[i];
      for (i = 0; i < 32; i++)
        m2[i + 32] = pk2[i];
      crypto_hash(h2, m2, n2);
      reduce(h2);
      scalarmult(p2, q2, h2);
      scalarbase(q2, sm.subarray(32));
      add(p2, q2);
      pack(t2, p2);
      n2 -= 64;
      if (crypto_verify_32(sm, 0, t2, 0)) {
        for (i = 0; i < n2; i++)
          m2[i] = 0;
        return -1;
      }
      for (i = 0; i < n2; i++)
        m2[i] = sm[i + 64];
      return n2;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
      gf: gf2,
      D: D2,
      L: L2,
      pack25519,
      unpack25519,
      M: M2,
      A: A2,
      S: S2,
      Z: Z2,
      pow2523,
      add,
      set25519,
      modL,
      scalarmult,
      scalarbase
    };
    function checkLengths(k2, n2) {
      if (k2.length !== crypto_secretbox_KEYBYTES)
        throw new Error("bad key size");
      if (n2.length !== crypto_secretbox_NONCEBYTES)
        throw new Error("bad nonce size");
    }
    function checkBoxLengths(pk2, sk2) {
      if (pk2.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      if (sk2.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
    }
    function checkArrayTypes() {
      for (var i = 0; i < arguments.length; i++) {
        if (!(arguments[i] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++)
        arr[i] = 0;
    }
    nacl.randomBytes = function(n2) {
      var b2 = new Uint8Array(n2);
      randombytes(b2, n2);
      return b2;
    };
    nacl.secretbox = function(msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c2 = new Uint8Array(m2.length);
      for (var i = 0; i < msg.length; i++)
        m2[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c2, m2, m2.length, nonce, key);
      return c2.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m2 = new Uint8Array(c2.length);
      for (var i = 0; i < box.length; i++)
        c2[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c2.length < 32)
        return null;
      if (crypto_secretbox_open(m2, c2, c2.length, nonce, key) !== 0)
        return null;
      return m2.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n2, p2) {
      checkArrayTypes(n2, p2);
      if (n2.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      if (p2.length !== crypto_scalarmult_BYTES)
        throw new Error("bad p size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n2, p2);
      return q2;
    };
    nacl.scalarMult.base = function(n2) {
      checkArrayTypes(n2);
      if (n2.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error("bad n size");
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n2);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k2);
    };
    nacl.box.before = function(publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k2, publicKey, secretKey);
      return k2;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
      var k2 = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k2);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk2, secretKey);
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0)
        return null;
      var m2 = new Uint8Array(mlen);
      for (var i = 0; i < m2.length; i++)
        m2[i] = tmp[i];
      return m2;
    };
    nacl.sign.detached = function(msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++)
        sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error("bad signature size");
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error("bad public key size");
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++)
        sm[i] = sig[i];
      for (i = 0; i < msg.length; i++)
        sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk2, sk2);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error("bad secret key size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk2.length; i++)
        pk2[i] = secretKey[32 + i];
      return { publicKey: pk2, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error("bad seed size");
      var pk2 = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk2 = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++)
        sk2[i] = seed[i];
      crypto_sign_keypair(pk2, sk2, true);
      return { publicKey: pk2, secretKey: sk2 };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
      checkArrayTypes(msg);
      var h2 = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h2, msg, msg.length);
      return h2;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y2) {
      checkArrayTypes(x, y2);
      if (x.length === 0 || y2.length === 0)
        return false;
      if (x.length !== y2.length)
        return false;
      return vn(x, 0, y2, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
      randombytes = fn;
    };
    (function() {
      var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
      if (crypto2 && crypto2.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function(x, n2) {
          var i, v2 = new Uint8Array(n2);
          for (i = 0; i < n2; i += QUOTA) {
            crypto2.getRandomValues(v2.subarray(i, i + Math.min(n2 - i, QUOTA)));
          }
          for (i = 0; i < n2; i++)
            x[i] = v2[i];
          cleanup(v2);
        });
      } else if (typeof commonjsRequire !== "undefined") {
        crypto2 = require$$0$1;
        if (crypto2 && crypto2.randomBytes) {
          nacl.setPRNG(function(x, n2) {
            var i, v2 = crypto2.randomBytes(n2);
            for (i = 0; i < n2; i++)
              x[i] = v2[i];
            cleanup(v2);
          });
        }
      }
    })();
  })(module2.exports ? module2.exports : self.nacl = self.nacl || {});
})(naclFast);
var naclFastExports = naclFast.exports;
const SALT_SYMMETRIC = "salt-key-symmetric-";
const SALT_SIGNING = "salt-key-signing-";
const SALT_ENCRYPTION = "salt-key-encryption-";
const SALT_SHARED = "salt-shared-";
const SALT_SIG_SIGNING = "salt-sig-signing-";
const SALT_SIG_ENCRYPTION = "salt-sig-encryption-";
const SALT_SIG_HASH = "salt-sig-hash-";
var naclUtil = { exports: {} };
(function(module2) {
  (function(root2, f2) {
    if (module2.exports)
      module2.exports = f2();
    else if (root2.nacl)
      root2.nacl.util = f2();
    else {
      root2.nacl = {};
      root2.nacl.util = f2();
    }
  })(commonjsGlobal, function() {
    var util2 = {};
    function validateBase64(s2) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s2)) {
        throw new TypeError("invalid encoding");
      }
    }
    util2.decodeUTF8 = function(s2) {
      if (typeof s2 !== "string")
        throw new TypeError("expected string");
      var i, d2 = unescape(encodeURIComponent(s2)), b2 = new Uint8Array(d2.length);
      for (i = 0; i < d2.length; i++)
        b2[i] = d2.charCodeAt(i);
      return b2;
    };
    util2.encodeUTF8 = function(arr) {
      var i, s2 = [];
      for (i = 0; i < arr.length; i++)
        s2.push(String.fromCharCode(arr[i]));
      return decodeURIComponent(escape(s2.join("")));
    };
    if (typeof atob === "undefined") {
      if (typeof Buffer.from !== "undefined") {
        util2.encodeBase64 = function(arr) {
          return Buffer.from(arr).toString("base64");
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          return new Uint8Array(Array.prototype.slice.call(Buffer.from(s2, "base64"), 0));
        };
      } else {
        util2.encodeBase64 = function(arr) {
          return new Buffer(arr).toString("base64");
        };
        util2.decodeBase64 = function(s2) {
          validateBase64(s2);
          return new Uint8Array(Array.prototype.slice.call(new Buffer(s2, "base64"), 0));
        };
      }
    } else {
      util2.encodeBase64 = function(arr) {
        var i, s2 = [], len = arr.length;
        for (i = 0; i < len; i++)
          s2.push(String.fromCharCode(arr[i]));
        return btoa(s2.join(""));
      };
      util2.decodeBase64 = function(s2) {
        validateBase64(s2);
        var i, d2 = atob(s2), b2 = new Uint8Array(d2.length);
        for (i = 0; i < d2.length; i++)
          b2[i] = d2.charCodeAt(i);
        return b2;
      };
    }
    return util2;
  });
})(naclUtil);
var naclUtilExports = naclUtil.exports;
var LvcErrorCode;
(function(LvcErrorCode2) {
  LvcErrorCode2[LvcErrorCode2["Undefined"] = 0] = "Undefined";
  LvcErrorCode2[LvcErrorCode2["CouldNotDecrypt"] = 3000500] = "CouldNotDecrypt";
  LvcErrorCode2[LvcErrorCode2["InvalidLength"] = 3000400] = "InvalidLength";
  LvcErrorCode2[LvcErrorCode2["LoadingFromUnknownType"] = 3000401] = "LoadingFromUnknownType";
  LvcErrorCode2[LvcErrorCode2["InvalidSeedLength"] = 3000410] = "InvalidSeedLength";
  LvcErrorCode2[LvcErrorCode2["InvalidSecondarySeedLength"] = 3000411] = "InvalidSecondarySeedLength";
  LvcErrorCode2[LvcErrorCode2["InvalidSaltLength"] = 3000412] = "InvalidSaltLength";
  LvcErrorCode2[LvcErrorCode2["InvalidSecretLength"] = 3000413] = "InvalidSecretLength";
  LvcErrorCode2[LvcErrorCode2["InvalidTotpSecret"] = 3000414] = "InvalidTotpSecret";
  LvcErrorCode2[LvcErrorCode2["UnknownTotpAlgorithmError"] = 3000415] = "UnknownTotpAlgorithmError";
})(LvcErrorCode || (LvcErrorCode = {}));
const pleaseUpdate$2 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
class LvcDomainError extends DomainError {
  constructor(code, short, userTitle, userDetail) {
    super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$2);
  }
}
class CouldNotDecryptError extends LvcDomainError {
  constructor() {
    super(LvcErrorCode.CouldNotDecrypt, "could not decrypt message", "Could not decrypt", "The client tried to decrypt data using the wrong key.");
  }
}
class InvalidLengthError extends LvcDomainError {
  constructor(got, want) {
    super(LvcErrorCode.InvalidLength, `Found data of length ${got}, expected ${want}.`);
  }
}
class LoadingFromUnknownTypeError extends LvcDomainError {
  constructor(type) {
    super(LvcErrorCode.LoadingFromUnknownType, `Loading failed from unknown type ${type}}`);
  }
}
class InvalidSeedLengthError extends LvcDomainError {
  constructor() {
    super(LvcErrorCode.InvalidSeedLength, "Seed for derived key must be 32 bytes in length!");
  }
}
class InvalidSecondarySeedLengthError extends LvcDomainError {
  constructor() {
    super(LvcErrorCode.InvalidSecondarySeedLength, "Secondary seed for derived key must be 32 bytes in length!");
  }
}
class InvalidSaltLengthError extends LvcDomainError {
  constructor() {
    super(LvcErrorCode.InvalidSaltLength, "Salt for a derived key must be at least 8 bytes in length!");
  }
}
class InvalidSecretLengthError extends LvcDomainError {
  constructor() {
    super(LvcErrorCode.InvalidSecretLength, "Length of derived secret must be 32 or 64 bytes!");
  }
}
class InvalidTotpSecretError extends LvcDomainError {
  constructor() {
    super(LvcErrorCode.InvalidTotpSecret, "TOTP secret could not be decoded.");
  }
}
class UnknownTotpAlgorithmError extends LvcDomainError {
  constructor() {
    super(LvcErrorCode.UnknownTotpAlgorithmError, "TOTP algorithm unknown.", "Unknown TOTP algorithm", "Your client does not support the requested algorithm. Make sure you are using the latest version of our software then try again");
  }
}
function loadArrayOrBase64(data, expectedLength) {
  if (expectedLength !== void 0) {
    const array = loadArrayOrBase64(data);
    if (array.length !== expectedLength) {
      throw new InvalidLengthError(array.length, expectedLength);
    }
    return array;
  }
  if (data instanceof Uint8Array) {
    return data;
  }
  if (typeof data === "string") {
    return naclUtilExports.decodeBase64(data);
  }
  if (data.constructor.name === "ArrayBuffer" || data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  }
  throw new LoadingFromUnknownTypeError(typeof data);
}
function concatArrays(...inputs) {
  const totalLength = inputs.map((a2) => a2.length).reduce((a2, b2) => a2 + b2, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const input of inputs) {
    result.set(input, offset);
    offset += input.length;
  }
  return result;
}
function deriveSecretFromSeed(seed, secondarySeed, salt, length = 32) {
  if (seed.length !== 32) {
    throw new InvalidSeedLengthError();
  }
  if (secondarySeed !== null && secondarySeed.length !== 32) {
    throw new InvalidSecondarySeedLengthError();
  }
  if (salt.length < 8) {
    throw new InvalidSaltLengthError();
  }
  if (length !== 32 && length !== 64) {
    throw new InvalidSecretLengthError();
  }
  let hashedSeed;
  if (secondarySeed === null) {
    hashedSeed = naclFastExports.hash(seed);
  } else {
    hashedSeed = naclFastExports.hash(concatArrays(seed, secondarySeed));
  }
  const hashedData = naclFastExports.hash(concatArrays(naclUtilExports.decodeUTF8(salt), hashedSeed));
  return hashedData.slice(0, length);
}
function randomSeed() {
  return naclFastExports.randomBytes(32);
}
function loadSymEncryptedBlob(data) {
  return loadArrayOrBase64(data);
}
function loadSymEncryptionKey(data) {
  return loadArrayOrBase64(data, naclFastExports.secretbox.keyLength);
}
function deriveSymEncryptionKey(seed, secondarySeed, salt) {
  return loadSymEncryptionKey(deriveSecretFromSeed(seed, secondarySeed, SALT_SYMMETRIC + salt, naclFastExports.secretbox.keyLength));
}
function newSymmetricSecret() {
  return naclFastExports.randomBytes(naclFastExports.secretbox.keyLength);
}
function symEncrypt(symKey, data) {
  const nonce = naclFastExports.randomBytes(naclFastExports.secretbox.nonceLength);
  const box = naclFastExports.secretbox(data, nonce, symKey);
  const fullMessage = new Uint8Array(nonce.length + box.length);
  fullMessage.set(nonce);
  fullMessage.set(box, nonce.length);
  return loadSymEncryptedBlob(fullMessage);
}
function symDecrypt(symKey, data) {
  const messageWithNonceAsUint8Array = data;
  const nonce = messageWithNonceAsUint8Array.slice(0, naclFastExports.secretbox.nonceLength);
  const message = messageWithNonceAsUint8Array.slice(naclFastExports.secretbox.nonceLength, messageWithNonceAsUint8Array.length);
  const decrypted = naclFastExports.secretbox.open(message, nonce, symKey);
  if (!decrypted) {
    throw new CouldNotDecryptError();
  }
  return decrypted;
}
function symKeyToSas(symEncryptionKey) {
  const keyHash = naclFastExports.hash(symEncryptionKey);
  return keyHash.slice(0, 4).reduce((sas, value) => sas.concat((value % 10).toString()), "");
}
function loadSharedSecretPrivKey(data) {
  return loadArrayOrBase64(data, naclFastExports.scalarMult.scalarLength);
}
function loadSharedSecretPubKey(data) {
  return loadArrayOrBase64(data, naclFastExports.scalarMult.groupElementLength);
}
function newSharedSecretKeyPair() {
  const scalar = naclFastExports.randomBytes(naclFastExports.scalarMult.scalarLength);
  const sharedPrivKey = loadSharedSecretPrivKey(scalar);
  const sharedPubKey = loadSharedSecretPubKey(naclFastExports.scalarMult.base(sharedPrivKey));
  return { sharedPubKey, sharedPrivKey };
}
function combineSharedSecret(sharedPrivKey, sharedPubKey, salt) {
  const keyData = naclFastExports.scalarMult(sharedPrivKey, sharedPubKey);
  return deriveSymEncryptionKey(keyData, null, SALT_SHARED + salt);
}
function loadEncryptionPublicKey(data) {
  return loadArrayOrBase64(data, naclFastExports.box.publicKeyLength);
}
function loadEncryptionPrivateKey(data) {
  return loadArrayOrBase64(data, naclFastExports.box.secretKeyLength);
}
function loadAsymEncryptedBlob(data) {
  return loadArrayOrBase64(data);
}
function loadAsymEncryptedEncryptionPrivateKey(data) {
  return loadArrayOrBase64(data);
}
function deriveEncryptionKeyPair(seed, secondarySeed, salt) {
  const keyPair = naclFastExports.box.keyPair.fromSecretKey(deriveSecretFromSeed(seed, secondarySeed, SALT_ENCRYPTION + salt, naclFastExports.box.secretKeyLength));
  const encPrivKey = loadEncryptionPrivateKey(keyPair.secretKey);
  const encPubKey = loadEncryptionPublicKey(keyPair.publicKey);
  return { encPrivKey, encPubKey };
}
function newEncryptionKeyPair() {
  const keyPair = naclFastExports.box.keyPair();
  const encPrivKey = loadEncryptionPrivateKey(keyPair.secretKey);
  const encPubKey = loadEncryptionPublicKey(keyPair.publicKey);
  return { encPrivKey, encPubKey };
}
function asymEncrypt(encPubKey, data) {
  const ephemeralKeyPair = naclFastExports.box.keyPair();
  const nonce = naclFastExports.randomBytes(naclFastExports.box.nonceLength);
  const encryptedMessage = naclFastExports.box(data, nonce, encPubKey, ephemeralKeyPair.secretKey);
  const fullMessage = new Uint8Array(nonce.length + ephemeralKeyPair.publicKey.length + encryptedMessage.length);
  fullMessage.set(nonce);
  fullMessage.set(ephemeralKeyPair.publicKey, nonce.length);
  fullMessage.set(encryptedMessage, nonce.length + ephemeralKeyPair.publicKey.length);
  return loadAsymEncryptedBlob(fullMessage);
}
function asymDecrypt(encPrivKey, encryptedBlob) {
  const nonce = encryptedBlob.slice(0, naclFastExports.box.nonceLength);
  const publicKey = encryptedBlob.slice(naclFastExports.box.nonceLength, naclFastExports.box.nonceLength + naclFastExports.box.publicKeyLength);
  const message = encryptedBlob.slice(naclFastExports.box.nonceLength + naclFastExports.box.publicKeyLength, encryptedBlob.length);
  const decryptedMessage = naclFastExports.box.open(message, nonce, publicKey, encPrivKey);
  if (!decryptedMessage) {
    throw new CouldNotDecryptError();
  }
  return decryptedMessage;
}
function loadSigningPublicKey(data) {
  return loadArrayOrBase64(data, naclFastExports.sign.publicKeyLength);
}
function loadSigningPrivateKey(data) {
  return loadArrayOrBase64(data, naclFastExports.sign.secretKeyLength);
}
function loadSignature(data) {
  return loadArrayOrBase64(data, naclFastExports.sign.signatureLength);
}
function deriveSigningKeyPair(seed, secondarySeed, salt) {
  const keyPair = naclFastExports.sign.keyPair.fromSeed(deriveSecretFromSeed(seed, secondarySeed, SALT_SIGNING + salt, naclFastExports.sign.seedLength));
  const sigPrivKey = loadSigningPrivateKey(keyPair.secretKey);
  const sigPubKey = loadSigningPublicKey(keyPair.publicKey);
  return { sigPrivKey, sigPubKey };
}
function sign(sigPrivKey, data, salt) {
  const signedData = salt ? concatArrays(naclUtilExports.decodeUTF8(salt), data) : data;
  const signature = naclFastExports.sign.detached(signedData, sigPrivKey);
  return loadSignature(signature);
}
function verifySignature(sigPubKey, signature, data, salt) {
  const signedData = salt ? concatArrays(naclUtilExports.decodeUTF8(salt), data) : data;
  return naclFastExports.sign.detached.verify(signedData, signature, sigPubKey);
}
function signString(key, data, salt) {
  return sign(key, naclUtilExports.decodeUTF8(data), salt);
}
function signingPublicKeyEqual(sigPubKey1, sigPubKey2) {
  return naclFastExports.verify(sigPubKey1, sigPubKey2);
}
const HASH_LENGTH = 32;
function loadHash(data) {
  return loadArrayOrBase64(data, HASH_LENGTH);
}
function hashData(blob) {
  return loadHash(naclFastExports.hash(blob).slice(0, HASH_LENGTH));
}
function hashEqual(hash1, hash2) {
  return naclFastExports.verify(hash1, hash2);
}
function verifyHash(hash2, blob) {
  return hashEqual(hash2, hashData(blob));
}
function loadEncryptionPublicKeySignature(data) {
  return loadSignature(data);
}
function loadSigningPublicKeySignature(data) {
  return loadSignature(data);
}
function loadAsymEncryptedSymmetricKey(data) {
  return loadAsymEncryptedBlob(data);
}
function symEncryptSymmetricEncryptionKey(symKey, symKeyToEncrypt) {
  const symKeyEncrypted = symEncrypt(symKey, symKeyToEncrypt);
  return symKeyEncrypted;
}
function asymCreateKek(asymKey, symKey) {
  const asymEncryptedBlob = asymEncrypt(asymKey, symKey);
  return loadAsymEncryptedSymmetricKey(asymEncryptedBlob);
}
function asymDecryptKek(asymKey, kek) {
  const symKey = asymDecrypt(asymKey, kek);
  return loadSymEncryptionKey(symKey);
}
function asymEncryptEncryptionPrivateKey(encryptionKey, payloadKey) {
  const asymEncryptedBlob = asymEncrypt(encryptionKey, payloadKey);
  return loadAsymEncryptedEncryptionPrivateKey(asymEncryptedBlob);
}
function asymDecryptEncryptionPrivateKey(decryptionKey, encryptedKey) {
  const decryptedKey = asymDecrypt(decryptionKey, encryptedKey);
  return loadEncryptionPrivateKey(decryptedKey);
}
function signEncryptionPublicKey(sigPrivKey, encPubKey, salt) {
  const encPubKeySignature = sign(sigPrivKey, encPubKey, SALT_SIG_ENCRYPTION + salt);
  return encPubKeySignature;
}
function verifySignedEncryptionPublicKey(verifyingKey, encPubKey, encPubKeySignature, salt) {
  return verifySignature(verifyingKey, encPubKeySignature, encPubKey, SALT_SIG_ENCRYPTION + salt);
}
function signSigningPublicKey(sigPrivKey, sigPubKey, salt) {
  const sigPubKeySignature = sign(sigPrivKey, sigPubKey, SALT_SIG_SIGNING + salt);
  return sigPubKeySignature;
}
function verifySignedSigningPublicKey(verifyingSigPubKey, sigPubKey, sigPubKeySignature, salt) {
  return verifySignature(verifyingSigPubKey, sigPubKeySignature, sigPubKey, SALT_SIG_SIGNING + salt);
}
function signHash(signKey, hash2) {
  const hashSig = sign(signKey, hash2, SALT_SIG_HASH);
  return hashSig;
}
function hashAndSign(signKey, data) {
  const hash2 = hashData(data);
  return signHash(signKey, hash2);
}
function verifyHashSignature(verifyingKey, signature, hash2) {
  return verifySignature(verifyingKey, signature, hash2, SALT_SIG_HASH);
}
var hash$2 = {};
var utils$9 = {};
var minimalisticAssert = assert$5;
function assert$5(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$5.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;
var assert$4 = minimalisticAssert;
var inherits = inherits_browserExports;
utils$9.inherits = inherits;
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 64512) !== 55296) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 64512) === 56320;
}
function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i = 0; i < msg.length; i++) {
        var c2 = msg.charCodeAt(i);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils$9.toArray = toArray;
function toHex(msg) {
  var res = "";
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils$9.toHex = toHex;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$9.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i = 0; i < msg.length; i++) {
    var w2 = msg[i];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$9.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1)
    return "0" + word;
  else
    return word;
}
utils$9.zero2 = zero2;
function zero8(word) {
  if (word.length === 7)
    return "0" + word;
  else if (word.length === 6)
    return "00" + word;
  else if (word.length === 5)
    return "000" + word;
  else if (word.length === 4)
    return "0000" + word;
  else if (word.length === 3)
    return "00000" + word;
  else if (word.length === 2)
    return "000000" + word;
  else if (word.length === 1)
    return "0000000" + word;
  else
    return word;
}
utils$9.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert$4(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k2 = start; i < res.length; i++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i] = w2 >>> 0;
  }
  return res;
}
utils$9.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k2 = 0; i < msg.length; i++, k2 += 4) {
    var m2 = msg[i];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$9.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$9.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$9.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$9.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$9.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$9.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e2) {
  return a2 + b2 + c2 + d2 + e2 >>> 0;
}
utils$9.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah2, al2) {
  var bh2 = buf[pos];
  var bl2 = buf[pos + 1];
  var lo2 = al2 + bl2 >>> 0;
  var hi2 = (lo2 < al2 ? 1 : 0) + ah2 + bh2;
  buf[pos] = hi2 >>> 0;
  buf[pos + 1] = lo2;
}
utils$9.sum64 = sum64$1;
function sum64_hi$1(ah2, al2, bh2, bl2) {
  var lo2 = al2 + bl2 >>> 0;
  var hi2 = (lo2 < al2 ? 1 : 0) + ah2 + bh2;
  return hi2 >>> 0;
}
utils$9.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah2, al2, bh2, bl2) {
  var lo2 = al2 + bl2;
  return lo2 >>> 0;
}
utils$9.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var carry = 0;
  var lo2 = al2;
  lo2 = lo2 + bl2 >>> 0;
  carry += lo2 < al2 ? 1 : 0;
  lo2 = lo2 + cl2 >>> 0;
  carry += lo2 < cl2 ? 1 : 0;
  lo2 = lo2 + dl2 >>> 0;
  carry += lo2 < dl2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + carry;
  return hi2 >>> 0;
}
utils$9.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2) {
  var lo2 = al2 + bl2 + cl2 + dl2;
  return lo2 >>> 0;
}
utils$9.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var carry = 0;
  var lo2 = al2;
  lo2 = lo2 + bl2 >>> 0;
  carry += lo2 < al2 ? 1 : 0;
  lo2 = lo2 + cl2 >>> 0;
  carry += lo2 < cl2 ? 1 : 0;
  lo2 = lo2 + dl2 >>> 0;
  carry += lo2 < dl2 ? 1 : 0;
  lo2 = lo2 + el2 >>> 0;
  carry += lo2 < el2 ? 1 : 0;
  var hi2 = ah2 + bh2 + ch2 + dh2 + eh2 + carry;
  return hi2 >>> 0;
}
utils$9.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah2, al2, bh2, bl2, ch2, cl2, dh2, dl2, eh2, el2) {
  var lo2 = al2 + bl2 + cl2 + dl2 + el2;
  return lo2 >>> 0;
}
utils$9.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah2, al2, num) {
  var r2 = al2 << 32 - num | ah2 >>> num;
  return r2 >>> 0;
}
utils$9.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$9.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah2, al2, num) {
  return ah2 >>> num;
}
utils$9.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah2, al2, num) {
  var r2 = ah2 << 32 - num | al2 >>> num;
  return r2 >>> 0;
}
utils$9.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$8 = utils$9;
var assert$3 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$8.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$8.join32(msg, 0, msg.length - r2, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$3(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k2 = bytes - (len + this.padLength) % bytes;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i = 1; i < k2; i++)
    res[i] = 0;
  len <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len & 255;
  } else {
    res[i++] = len & 255;
    res[i++] = len >>> 8 & 255;
    res[i++] = len >>> 16 & 255;
    res[i++] = len >>> 24 & 255;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i++] = 0;
  }
  return res;
};
var sha = {};
var common$4 = {};
var utils$7 = utils$9;
var rotr32 = utils$7.rotr32;
function ft_1$1(s2, x, y2, z2) {
  if (s2 === 0)
    return ch32$1(x, y2, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x, y2, z2);
  if (s2 === 2)
    return maj32$1(x, y2, z2);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x, y2, z2) {
  return x & y2 ^ ~x & z2;
}
common$4.ch32 = ch32$1;
function maj32$1(x, y2, z2) {
  return x & y2 ^ x & z2 ^ y2 & z2;
}
common$4.maj32 = maj32$1;
function p32(x, y2, z2) {
  return x ^ y2 ^ z2;
}
common$4.p32 = p32;
function s0_256$1(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$6 = utils$9;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$6.rotl32;
var sum32$2 = utils$6.sum32;
var sum32_5$1 = utils$6.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$6.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = rotl32$1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i = 0; i < W2.length; i++) {
    var s2 = ~~(i / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$6.toHex32(this.h, "big");
  else
    return utils$6.split32(this.h, "big");
};
var utils$5 = utils$9;
var common$2 = common$5;
var shaCommon = common$4;
var assert$2 = minimalisticAssert;
var sum32$1 = utils$5.sum32;
var sum32_4$1 = utils$5.sum32_4;
var sum32_5 = utils$5.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$5.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 16; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i++)
    W2[i] = sum32_4$1(g1_256(W2[i - 2]), W2[i - 7], g0_256(W2[i - 15]), W2[i - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$2(this.k.length === W2.length);
  for (i = 0; i < W2.length; i++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i], W2[i]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$5.toHex32(this.h, "big");
  else
    return utils$5.split32(this.h, "big");
};
var utils$4 = utils$9;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$4.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$4.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$4.split32(this.h.slice(0, 7), "big");
};
var utils$3 = utils$9;
var common$1 = common$5;
var assert$1 = minimalisticAssert;
var rotr64_hi = utils$3.rotr64_hi;
var rotr64_lo = utils$3.rotr64_lo;
var shr64_hi = utils$3.shr64_hi;
var shr64_lo = utils$3.shr64_lo;
var sum64 = utils$3.sum64;
var sum64_hi = utils$3.sum64_hi;
var sum64_lo = utils$3.sum64_lo;
var sum64_4_hi = utils$3.sum64_4_hi;
var sum64_4_lo = utils$3.sum64_4_lo;
var sum64_5_hi = utils$3.sum64_5_hi;
var sum64_5_lo = utils$3.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$3.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i = 0; i < 32; i++)
    W2[i] = msg[start + i];
  for (; i < W2.length; i += 2) {
    var c0_hi = g1_512_hi(W2[i - 4], W2[i - 3]);
    var c0_lo = g1_512_lo(W2[i - 4], W2[i - 3]);
    var c1_hi = W2[i - 14];
    var c1_lo = W2[i - 13];
    var c2_hi = g0_512_hi(W2[i - 30], W2[i - 29]);
    var c2_lo = g0_512_lo(W2[i - 30], W2[i - 29]);
    var c3_hi = W2[i - 32];
    var c3_lo = W2[i - 31];
    W2[i] = sum64_4_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
    W2[i + 1] = sum64_4_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo
    );
  }
};
SHA512$1.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah2 = this.h[0];
  var al2 = this.h[1];
  var bh2 = this.h[2];
  var bl2 = this.h[3];
  var ch2 = this.h[4];
  var cl2 = this.h[5];
  var dh2 = this.h[6];
  var dl2 = this.h[7];
  var eh2 = this.h[8];
  var el2 = this.h[9];
  var fh2 = this.h[10];
  var fl2 = this.h[11];
  var gh2 = this.h[12];
  var gl2 = this.h[13];
  var hh2 = this.h[14];
  var hl2 = this.h[15];
  assert$1(this.k.length === W2.length);
  for (var i = 0; i < W2.length; i += 2) {
    var c0_hi = hh2;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh2, el2);
    var c1_lo = s1_512_lo(eh2, el2);
    var c2_hi = ch64_hi(eh2, el2, fh2, fl2, gh2);
    var c2_lo = ch64_lo(eh2, el2, fh2, fl2, gh2, gl2);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W2[i];
    var c4_lo = W2[i + 1];
    var T1_hi = sum64_5_hi(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    var T1_lo = sum64_5_lo(
      c0_hi,
      c0_lo,
      c1_hi,
      c1_lo,
      c2_hi,
      c2_lo,
      c3_hi,
      c3_lo,
      c4_hi,
      c4_lo
    );
    c0_hi = s0_512_hi(ah2, al2);
    c0_lo = s0_512_lo(ah2, al2);
    c1_hi = maj64_hi(ah2, al2, bh2, bl2, ch2);
    c1_lo = maj64_lo(ah2, al2, bh2, bl2, ch2, cl2);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh2 = gh2;
    hl2 = gl2;
    gh2 = fh2;
    gl2 = fl2;
    fh2 = eh2;
    fl2 = el2;
    eh2 = sum64_hi(dh2, dl2, T1_hi, T1_lo);
    el2 = sum64_lo(dl2, dl2, T1_hi, T1_lo);
    dh2 = ch2;
    dl2 = cl2;
    ch2 = bh2;
    cl2 = bl2;
    bh2 = ah2;
    bl2 = al2;
    ah2 = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al2 = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah2, al2);
  sum64(this.h, 2, bh2, bl2);
  sum64(this.h, 4, ch2, cl2);
  sum64(this.h, 6, dh2, dl2);
  sum64(this.h, 8, eh2, el2);
  sum64(this.h, 10, fh2, fl2);
  sum64(this.h, 12, gh2, gl2);
  sum64(this.h, 14, hh2, hl2);
};
SHA512$1.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$3.toHex32(this.h, "big");
  else
    return utils$3.split32(this.h, "big");
};
function ch64_hi(xh2, xl2, yh2, yl2, zh2) {
  var r2 = xh2 & yh2 ^ ~xh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
  var r2 = xl2 & yl2 ^ ~xl2 & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh2, xl2, yh2, yl2, zh2) {
  var r2 = xh2 & yh2 ^ xh2 & zh2 ^ yh2 & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh2, xl2, yh2, yl2, zh2, zl2) {
  var r2 = xl2 & yl2 ^ xl2 & zl2 ^ yl2 & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh2, xl2) {
  var c0_hi = rotr64_hi(xh2, xl2, 28);
  var c1_hi = rotr64_hi(xl2, xh2, 2);
  var c2_hi = rotr64_hi(xl2, xh2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh2, xl2) {
  var c0_lo = rotr64_lo(xh2, xl2, 28);
  var c1_lo = rotr64_lo(xl2, xh2, 2);
  var c2_lo = rotr64_lo(xl2, xh2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh2, xl2) {
  var c0_hi = rotr64_hi(xh2, xl2, 14);
  var c1_hi = rotr64_hi(xh2, xl2, 18);
  var c2_hi = rotr64_hi(xl2, xh2, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh2, xl2) {
  var c0_lo = rotr64_lo(xh2, xl2, 14);
  var c1_lo = rotr64_lo(xh2, xl2, 18);
  var c2_lo = rotr64_lo(xl2, xh2, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh2, xl2) {
  var c0_hi = rotr64_hi(xh2, xl2, 1);
  var c1_hi = rotr64_hi(xh2, xl2, 8);
  var c2_hi = shr64_hi(xh2, xl2, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh2, xl2) {
  var c0_lo = rotr64_lo(xh2, xl2, 1);
  var c1_lo = rotr64_lo(xh2, xl2, 8);
  var c2_lo = shr64_lo(xh2, xl2, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh2, xl2) {
  var c0_hi = rotr64_hi(xh2, xl2, 19);
  var c1_hi = rotr64_hi(xl2, xh2, 29);
  var c2_hi = shr64_hi(xh2, xl2, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh2, xl2) {
  var c0_lo = rotr64_lo(xh2, xl2, 19);
  var c1_lo = rotr64_lo(xl2, xh2, 29);
  var c2_lo = shr64_lo(xh2, xl2, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$2 = utils$9;
var SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$2.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$2.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$2.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {};
var utils$1 = utils$9;
var common = common$5;
var rotl32 = utils$1.rotl32;
var sum32 = utils$1.sum32;
var sum32_3 = utils$1.sum32_3;
var sum32_4 = utils$1.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$1.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah2 = A2;
  var Bh2 = B2;
  var Ch2 = C2;
  var Dh2 = D2;
  var Eh2 = E2;
  for (var j = 0; j < 80; j++) {
    var T2 = sum32(
      rotl32(
        sum32_4(A2, f$4(j, B2, C2, D2), msg[r$3[j] + start], K(j)),
        s$1[j]
      ),
      E2
    );
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(
      rotl32(
        sum32_4(Ah2, f$4(79 - j, Bh2, Ch2, Dh2), msg[rh[j] + start], Kh(j)),
        sh[j]
      ),
      Eh2
    );
    Ah2 = Eh2;
    Eh2 = Dh2;
    Dh2 = rotl32(Ch2, 10);
    Ch2 = Bh2;
    Bh2 = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh2);
  this.h[1] = sum32_3(this.h[2], D2, Eh2);
  this.h[2] = sum32_3(this.h[3], E2, Ah2);
  this.h[3] = sum32_3(this.h[4], A2, Bh2);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$1.toHex32(this.h, "little");
  else
    return utils$1.split32(this.h, "little");
};
function f$4(j, x, y2, z2) {
  if (j <= 15)
    return x ^ y2 ^ z2;
  else if (j <= 31)
    return x & y2 | ~x & z2;
  else if (j <= 47)
    return (x | ~y2) ^ z2;
  else if (j <= 63)
    return x & z2 | y2 & ~z2;
  else
    return x ^ (y2 | ~z2);
}
function K(j) {
  if (j <= 15)
    return 0;
  else if (j <= 31)
    return 1518500249;
  else if (j <= 47)
    return 1859775393;
  else if (j <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j) {
  if (j <= 15)
    return 1352829926;
  else if (j <= 31)
    return 1548603684;
  else if (j <= 47)
    return 1836072691;
  else if (j <= 63)
    return 2053994217;
  else
    return 0;
}
var r$3 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils = utils$9;
var assert = minimalisticAssert;
function Hmac(hash2, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash2, key, enc);
  this.Hash = hash2;
  this.blockSize = hash2.blockSize / 8;
  this.outSize = hash2.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils.toArray(key, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init(key) {
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);
  for (i = 0; i < key.length; i++)
    key[i] ^= 54;
  this.inner = new this.Hash().update(key);
  for (i = 0; i < key.length; i++)
    key[i] ^= 106;
  this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports2) {
  var hash2 = exports2;
  hash2.utils = utils$9;
  hash2.common = common$5;
  hash2.sha = sha;
  hash2.ripemd = ripemd;
  hash2.hmac = hmac;
  hash2.sha1 = hash2.sha.sha1;
  hash2.sha256 = hash2.sha.sha256;
  hash2.sha224 = hash2.sha.sha224;
  hash2.sha384 = hash2.sha.sha384;
  hash2.sha512 = hash2.sha.sha512;
  hash2.ripemd160 = hash2.ripemd.ripemd160;
})(hash$2);
const hash$1 = /* @__PURE__ */ getDefaultExportFromCjs(hash$2);
var TotpAlgorithm;
(function(TotpAlgorithm2) {
  TotpAlgorithm2["unknown"] = "unknown";
  TotpAlgorithm2["sha1"] = "sha1";
  TotpAlgorithm2["sha256"] = "sha256";
  TotpAlgorithm2["sha512"] = "sha512";
})(TotpAlgorithm || (TotpAlgorithm = {}));
const DEFAULT_TOTP_ALGORITHM = TotpAlgorithm.sha1;
const DEFAULT_TOTP_DIGITS = 6;
const DEFAULT_TOTP_PERIOD = 30;
const B32_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
function calculateTotp(secretBase32, algorithm, digits, period, now = Date.now()) {
  const epoch = Math.round(now / 1e3);
  const counter = Math.floor(epoch / period);
  const epochStart = counter * period * 1e3;
  const epochEnd = (counter + 1) * period * 1e3;
  const epochLeftMs = epochEnd - now;
  const totp = calculateHotp(secretBase32, algorithm, digits, counter);
  return { totp, epochStart, epochEnd, epochLeftMs };
}
function calculateHotp(secretBase32, algorithm, digits, counter) {
  const secret = base32tohex(secretBase32);
  const hexCounter = zeropad(counter.toString(16), 16);
  let hashAlgorithm;
  switch (algorithm) {
    case TotpAlgorithm.sha1:
      hashAlgorithm = hash$1.sha1;
      break;
    case TotpAlgorithm.sha256:
      hashAlgorithm = hash$1.sha256;
      break;
    case TotpAlgorithm.sha512:
      hashAlgorithm = hash$1.sha512;
      break;
    default:
      throw new UnknownTotpAlgorithmError();
  }
  const hmac2 = hash$1.hmac(hashAlgorithm, secret, "hex").update(hexCounter, "hex").digest("hex");
  const offset = parseInt(hmac2.substring(hmac2.length - 1), 16);
  const otpFull = (parseInt(hmac2.substring(offset * 2, offset * 2 + 8), 16) & 2147483647).toString();
  const otp = otpFull.substring(otpFull.length - digits, otpFull.length);
  return otp;
}
function base32tohex(base32) {
  base32 = base32.toUpperCase();
  const missingPaddingCharacters = 8 - base32.length % 8;
  if (missingPaddingCharacters !== 8) {
    base32 += "=".repeat(missingPaddingCharacters);
  }
  let bits = "";
  for (let i = 0; i < base32.length; i += 1) {
    const c2 = base32.charAt(i);
    const val = B32_CHARS.indexOf(c2);
    if (val === -1) {
      if (c2 === "=") {
        const pad2 = base32.slice(i, base32.length);
        if (pad2 === "=") {
          bits = bits.slice(0, -3);
        } else if (pad2 === "===") {
          bits = bits.slice(0, -1);
        } else if (pad2 === "====") {
          bits = bits.slice(0, -4);
        } else if (pad2 === "======") {
          bits = bits.slice(0, -2);
        } else {
          throw new InvalidTotpSecretError();
        }
        break;
      }
      throw new InvalidTotpSecretError();
    }
    bits += zeropad(val.toString(2), 5);
  }
  let hex = "";
  for (let i = 0; i + 4 <= bits.length; i += 4) {
    const chunk = bits.substr(i, 4);
    hex += parseInt(chunk, 2).toString(16);
  }
  return hex;
}
function zeropad(str, len) {
  if (len <= str.length) {
    return str;
  }
  return Array(len + 1 - str.length).join("0") + str;
}
function canonicalize(obj) {
  var buffer = "";
  serialize(obj);
  return buffer;
  function serialize(object) {
    if (object === null || typeof object !== "object" || object.toJSON != null) {
      buffer += JSON.stringify(object);
    } else if (Array.isArray(object)) {
      buffer += "[";
      var next_1 = false;
      object.forEach(function(element) {
        if (next_1) {
          buffer += ",";
        }
        next_1 = true;
        serialize(element);
      });
      buffer += "]";
    } else {
      buffer += "{";
      var vKeys = Object.keys(object).sort();
      vKeys.forEach(function(property, index2) {
        return addProp(object, property, index2);
      });
      buffer += "}";
    }
  }
  function addProp(object, property, index2) {
    if (index2 > 0) {
      buffer += ",";
    }
    buffer += JSON.stringify(property);
    buffer += ":";
    serialize(object[property]);
  }
}
function brandedUint8Array(loader) {
  return z$2.instanceof(Uint8Array).transform((arr) => loader(arr));
}
function makeProtobufEnumSchema(protobufEnum) {
  const enumValues = Object.values(protobufEnum);
  return z$2.number().transform((value, ctx) => {
    if (enumValues.includes(value)) {
      return value;
    }
    ctx.addIssue({
      code: z$2.ZodIssueCode.custom,
      message: `Invalid protobuf enum value: ${value}`
    });
    return z$2.NEVER;
  });
}
function makeTypescriptEnumSchema(typescriptEnum) {
  const enumValues = Object.values(typescriptEnum);
  return z$2.number().or(z$2.string()).transform((value, ctx) => {
    if (enumValues.includes(value)) {
      return value;
    }
    ctx.addIssue({
      code: z$2.ZodIssueCode.custom,
      message: `Invalid typescript enum value: ${value}`
    });
    return z$2.NEVER;
  });
}
function makeExcludeValuesTransform(...excludeValues) {
  return (v2, ctx) => {
    if (excludeValues.includes(v2)) {
      ctx.addIssue({
        code: z$2.ZodIssueCode.custom,
        message: `Unexpected value ${v2}`
      });
      return z$2.NEVER;
    }
    return v2;
  };
}
var __rest$M = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const AuthenticatorWebauthn = z$2.object({
  webauthnId: z$2.string(),
  prfSalt: z$2.instanceof(Uint8Array)
});
function deviceTypeToAuthenticatorType(deviceType) {
  switch (deviceType) {
    case "push":
      return AuthenticatorType.PUSH;
    case "recovery":
      return AuthenticatorType.BACKUP_CODE;
    case "backup":
      return AuthenticatorType.BACKUP_OS;
    case "dummy":
      return AuthenticatorType.DUMMY;
    case "organization":
      return AuthenticatorType.ORGANIZATION_ADMIN;
    default:
      return AuthenticatorType.UNKNOWN;
  }
}
const schemaAuthenticatorType = makeProtobufEnumSchema(AuthenticatorType);
const AuthenticatorKeyNamesV3 = z$2.object({
  id: z$2.string().uuid(),
  authenticatorType: schemaAuthenticatorType,
  highSecurityLoginSigPubKey: brandedUint8Array(loadSigningPublicKey),
  highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
  highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
  storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
  storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  secretInfo: z$2.string(),
  secretSalt: z$2.instanceof(Uint8Array),
  webauthn: AuthenticatorWebauthn.optional()
});
const AuthenticatorKeyNamesV2 = z$2.object({
  id: z$2.string().uuid(),
  deviceType: z$2.string(),
  highSecurityLoginSigPubKey: brandedUint8Array(loadSigningPublicKey),
  highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
  highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
  storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
  storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  secretInfo: z$2.string(),
  secretSalt: z$2.instanceof(Uint8Array)
}).transform((_a2) => {
  var { deviceType } = _a2, rest = __rest$M(_a2, ["deviceType"]);
  return Object.assign({ authenticatorType: deviceTypeToAuthenticatorType(deviceType) }, rest);
});
const AuthenticatorKeyNamesV1 = z$2.object({
  id: z$2.string().uuid(),
  deviceType: z$2.string(),
  loginSigPubKey: brandedUint8Array(loadSigningPublicKey),
  highSecuritySigPubKey: brandedUint8Array(loadSigningPublicKey),
  highSecurityEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  highSecurityEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  sigPubKey: brandedUint8Array(loadSigningPublicKey),
  sigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
  encPubKey: brandedUint8Array(loadEncryptionPublicKey),
  encPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  secretInfo: z$2.string(),
  secretSalt: z$2.instanceof(Uint8Array)
}).transform((_a2) => {
  var { deviceType, loginSigPubKey, highSecuritySigPubKey, highSecurityEncPubKey, highSecurityEncPubKeySignature, sigPubKey, sigPubKeySignature, encPubKey, encPubKeySignature } = _a2, rest = __rest$M(_a2, ["deviceType", "loginSigPubKey", "highSecuritySigPubKey", "highSecurityEncPubKey", "highSecurityEncPubKeySignature", "sigPubKey", "sigPubKeySignature", "encPubKey", "encPubKeySignature"]);
  return Object.assign({ authenticatorType: deviceTypeToAuthenticatorType(deviceType), highSecurityLoginSigPubKey: loginSigPubKey, highSecurityIdentitySigPubKey: highSecuritySigPubKey, highSecurityVaultKeyEncPubKey: highSecurityEncPubKey, highSecurityVaultKeyEncPubKeySignature: highSecurityEncPubKeySignature, storableSigPubKey: sigPubKey, storableSigPubKeySignature: sigPubKeySignature, storableVaultKeyEncPubKey: encPubKey, storableVaultKeyEncPubKeySignature: encPubKeySignature }, rest);
});
const Authenticator = z$2.union([
  AuthenticatorKeyNamesV1,
  AuthenticatorKeyNamesV2,
  AuthenticatorKeyNamesV3
]);
var __rest$L = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const UnlockedAuthenticatorNewKeyNames = z$2.object({
  authenticator: Authenticator,
  storableSigPrivKey: brandedUint8Array(loadSigningPrivateKey),
  storableVaultKeyEncPrivKey: brandedUint8Array(loadEncryptionPrivateKey)
});
const UnlockedAuthenticatorOldKeyNames = z$2.object({
  authenticator: Authenticator,
  sigPrivKey: brandedUint8Array(loadSigningPrivateKey),
  encPrivKey: brandedUint8Array(loadEncryptionPrivateKey)
}).transform((_a2) => {
  var { sigPrivKey, encPrivKey } = _a2, rest = __rest$L(_a2, ["sigPrivKey", "encPrivKey"]);
  return Object.assign({ storableSigPrivKey: sigPrivKey, storableVaultKeyEncPrivKey: encPrivKey }, rest);
});
const UnlockedAuthenticator$1 = z$2.union([
  UnlockedAuthenticatorOldKeyNames,
  UnlockedAuthenticatorNewKeyNames
]);
const schemaLoginData = z$2.object({
  userId: z$2.string().uuid(),
  sessionId: z$2.string().uuid(),
  token: z$2.string()
});
const SessionKeys$1 = z$2.object({
  encPrivKey: brandedUint8Array(loadEncryptionPrivateKey),
  encPubKey: brandedUint8Array(loadEncryptionPublicKey),
  encPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  signingAuthId: z$2.string().uuid()
});
z$2.object({
  loginData: schemaLoginData,
  unlockedAuthenticator: UnlockedAuthenticator$1,
  sessionKeys: SessionKeys$1
});
var isISO8601$1 = { exports: {} };
var assertString = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = assertString2;
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof2 = function _typeof3(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof2 = function _typeof3(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof2(obj);
  }
  function assertString2(input) {
    var isString4 = typeof input === "string" || input instanceof String;
    if (!isString4) {
      var invalidType = _typeof2(input);
      if (input === null)
        invalidType = "null";
      else if (invalidType === "object")
        invalidType = input.constructor.name;
      throw new TypeError("Expected a string but received a ".concat(invalidType));
    }
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
})(assertString, assertString.exports);
var assertStringExports = assertString.exports;
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isISO86012;
  var _assertString = _interopRequireDefault(assertStringExports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var isValidDate = function isValidDate2(str) {
    var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
    if (ordinalMatch) {
      var oYear = Number(ordinalMatch[1]);
      var oDay = Number(ordinalMatch[2]);
      if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
        return oDay <= 366;
      return oDay <= 365;
    }
    var match2 = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
    var year = match2[1];
    var month = match2[2];
    var day = match2[3];
    var monthString = month ? "0".concat(month).slice(-2) : month;
    var dayString = day ? "0".concat(day).slice(-2) : day;
    var d2 = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
    if (month && day) {
      return d2.getUTCFullYear() === year && d2.getUTCMonth() + 1 === month && d2.getUTCDate() === day;
    }
    return true;
  };
  function isISO86012(str) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    (0, _assertString.default)(str);
    var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
    if (check && options.strict)
      return isValidDate(str);
    return check;
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
})(isISO8601$1, isISO8601$1.exports);
var isISO8601Exports = isISO8601$1.exports;
const isISO8601 = /* @__PURE__ */ getDefaultExportFromCjs(isISO8601Exports);
function objectPassthrough(x) {
  const result = z$2.object(x);
  return result.passthrough();
}
const unknownValuePlaceholderMarker = "fa9fc083-53f0-4616-a4da-2ca792b8f4f8";
const fallbackValueKey = Symbol("fallbackValueKey");
const schemaSerializedUnknownValuePlaceholder = z$2.object({
  marker: z$2.literal(unknownValuePlaceholderMarker),
  unknownValueJson: z$2.string()
});
function isUnknownValuePlaceholder(value) {
  if (typeof value !== "object") {
    return false;
  }
  return schemaSerializedUnknownValuePlaceholder.safeParse(value).success;
}
function getValueWithPlaceholder(value) {
  if (isUnknownValuePlaceholder(value)) {
    return value[fallbackValueKey];
  }
  return value;
}
function makeUnknownValuePlaceholderSchema(schema, fallbackValue) {
  return z$2.union([
    schema,
    schemaSerializedUnknownValuePlaceholder.transform((placeholder) => {
      try {
        const result = schema.safeParse(JSON.parse(placeholder.unknownValueJson));
        if (result.success) {
          return result.data;
        }
      } catch (e2) {
      }
      return Object.assign(Object.assign({}, placeholder), { [fallbackValueKey]: fallbackValue });
    })
  ]).catch((ctx) => ({
    marker: unknownValuePlaceholderMarker,
    // We store the original value as JSON serialized so we can deal with a consistent string type when parsing
    unknownValueJson: JSON.stringify(ctx.input),
    [fallbackValueKey]: fallbackValue
  }));
}
var isBase64$1 = { exports: {} };
var merge = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = merge2;
  function merge2() {
    var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults = arguments.length > 1 ? arguments[1] : void 0;
    for (var key in defaults) {
      if (typeof obj[key] === "undefined") {
        obj[key] = defaults[key];
      }
    }
    return obj;
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
})(merge, merge.exports);
var mergeExports = merge.exports;
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isBase642;
  var _assertString = _interopRequireDefault(assertStringExports);
  var _merge = _interopRequireDefault(mergeExports);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var notBase64 = /[^A-Z0-9+\/=]/i;
  var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
  var defaultBase64Options = {
    urlSafe: false
  };
  function isBase642(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, defaultBase64Options);
    var len = str.length;
    if (options.urlSafe) {
      return urlSafeBase64.test(str);
    }
    if (len % 4 !== 0 || notBase64.test(str)) {
      return false;
    }
    var firstPaddingChar = str.indexOf("=");
    return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
})(isBase64$1, isBase64$1.exports);
var isBase64Exports = isBase64$1.exports;
const isBase64 = /* @__PURE__ */ getDefaultExportFromCjs(isBase64Exports);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1) {
  byteToHex.push((i$1 + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
const nullUuid = "00000000-0000-0000-0000-000000000000";
function newUuid$1() {
  return v4();
}
function uuidEqual(id1, id2) {
  return id1.toLowerCase() === id2.toLowerCase();
}
const ProtectedValue = objectPassthrough({
  // Content identity only changes on user edits. The field should be set most of the time, since
  // it was set for all ProtectedValues during the automerge migration. However contentId-less
  // fields may have been re-introduced after the heymerge migration. In this case we generate an
  // id during parsing.
  contentId: z$2.string().uuid().default(newUuid$1),
  encrypted: z$2.string().refine(isBase64),
  isEmpty: z$2.boolean().optional()
});
const UnprotectedValue = objectPassthrough({
  // See ProtectedValue.contentId. Note that this field was previously `UUID | null` and therefore
  // uses a different transformation here.
  contentId: z$2.union([z$2.string().uuid(), z$2.null()]).transform((arg) => arg === null ? newUuid$1() : arg),
  unencrypted: z$2.string()
});
const ProtectedCustomField = objectPassthrough({
  // Id should be set most of the time, since it was set for all CustomFields during the automerge
  // migration. However at that time not all importers set the id correctly, so performed in
  // heymerge accounts may have re-introduced id-less CustomFields. In this case we generate an id
  // during parsing.
  id: z$2.string().uuid().default(newUuid$1),
  name: z$2.string(),
  protected: z$2.literal(true),
  value: ProtectedValue
});
const UnprotectedProtectedCustomField = objectPassthrough({
  // see ProtectedCustomField.id
  id: z$2.string().uuid().default(newUuid$1),
  name: z$2.string(),
  protected: z$2.literal(true),
  value: UnprotectedValue
});
const PlainCustomField = objectPassthrough({
  // see ProtectedCustomField.id
  id: z$2.string().uuid().default(newUuid$1),
  name: z$2.string(),
  protected: z$2.literal(false),
  value: z$2.string()
});
const CustomField = z$2.union([ProtectedCustomField, PlainCustomField]);
const UnprotectedCustomField = z$2.union([UnprotectedProtectedCustomField, PlainCustomField]);
const LoginAndroidApp = objectPassthrough({
  // TODO make id non optional after migration to heymerge
  id: z$2.string().uuid().optional(),
  appId: z$2.string(),
  signature: z$2.string().refine(isBase64),
  displayName: z$2.string(),
  iconDataUri: z$2.string().optional()
});
const LoginCreditCard = objectPassthrough({
  number: z$2.string(),
  cardHolder: z$2.string(),
  expiration: z$2.string(),
  securityCode: ProtectedValue,
  pin: ProtectedValue,
  displayType: z$2.string(),
  displayMaskedNumber: z$2.string()
});
const LOGIN_CREDIT_CARD_KEYS = [
  "number",
  "cardHolder",
  "expiration",
  "securityCode",
  "pin",
  "displayType",
  "displayMaskedNumber"
];
var __rest$K = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var LoginWebsiteProtocol;
(function(LoginWebsiteProtocol2) {
  LoginWebsiteProtocol2["http"] = "http";
  LoginWebsiteProtocol2["https"] = "https";
})(LoginWebsiteProtocol || (LoginWebsiteProtocol = {}));
const schemaLoginWebsiteProtocol = makeTypescriptEnumSchema(LoginWebsiteProtocol);
const LoginWebsiteAttributesEntry = objectPassthrough({
  protocol: makeUnknownValuePlaceholderSchema(schemaLoginWebsiteProtocol, void 0).optional()
});
const LoginWebsiteAttributes = z$2.record(LoginWebsiteAttributesEntry);
var LoginUiType;
(function(LoginUiType2) {
  LoginUiType2["login"] = "login";
  LoginUiType2["creditCard"] = "creditCard";
  LoginUiType2["note"] = "note";
  LoginUiType2["wifi"] = "wifi";
})(LoginUiType || (LoginUiType = {}));
const schemaLoginUiType = makeTypescriptEnumSchema(LoginUiType);
const LoginSender = objectPassthrough({
  name: z$2.string(),
  company: z$2.string().optional()
});
var LoginSource;
(function(LoginSource2) {
  LoginSource2["manual"] = "manual";
  LoginSource2["autosave"] = "autosave";
  LoginSource2["registrationPasswordGeneration"] = "registrationPasswordGeneration";
  LoginSource2["addTotpFromOverlay"] = "addTotpFromOverlay";
  LoginSource2["updateLoginFromOverlay"] = "updateLoginFromOverlay";
  LoginSource2["menuDragDrop"] = "menuDragDrop";
  LoginSource2["import"] = "import";
  LoginSource2["shareLink"] = "shareLink";
  LoginSource2["undo"] = "undo";
})(LoginSource || (LoginSource = {}));
const schemaLoginSource = makeTypescriptEnumSchema(LoginSource);
const ShareLink = objectPassthrough({
  id: z$2.string(),
  createdAt: z$2.string().refine((str) => isISO8601(str)),
  openedAt: z$2.string().refine((str) => isISO8601(str)).optional(),
  secret: ProtectedValue
});
const schemaTotpAlgorithm = makeTypescriptEnumSchema(TotpAlgorithm);
const LeakedPasswordCheckInfo = objectPassthrough({
  leakCount: z$2.number(),
  checkedAt: z$2.string().refine((str) => isISO8601(str)),
  checkedPasswordContentId: z$2.string().uuid()
});
const LoginWithoutHistory = objectPassthrough({
  uiType: z$2.undefined().transform((_2) => LoginUiType.login).or(makeUnknownValuePlaceholderSchema(schemaLoginUiType, LoginUiType.login)),
  title: z$2.string(),
  websites: z$2.array(z$2.string()),
  websiteAttributes: LoginWebsiteAttributes.optional(),
  androidApps: z$2.array(LoginAndroidApp).optional(),
  username: z$2.string(),
  password: ProtectedValue,
  note: z$2.string(),
  creationTime: z$2.string().refine((str) => isISO8601(str)),
  changeTime: z$2.string().refine((str) => isISO8601(str)).optional(),
  editTime: z$2.string().refine((str) => isISO8601(str)),
  creationSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional(),
  editSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional(),
  creationProfileId: z$2.string().uuid().optional(),
  editProfileId: z$2.string().uuid().optional(),
  customFields: z$2.array(CustomField),
  totp: ProtectedValue.optional(),
  totpAlgorithm: makeUnknownValuePlaceholderSchema(schemaTotpAlgorithm, TotpAlgorithm.unknown).optional(),
  totpDigits: z$2.number().int().gte(1).optional(),
  totpPeriod: z$2.number().int().gte(1).optional(),
  tags: z$2.array(z$2.string()).optional(),
  creditCard: LoginCreditCard.optional(),
  wifiSsid: z$2.string().optional(),
  sender: LoginSender.optional(),
  pendingInboxConfirmation: z$2.boolean().optional(),
  linkedViewSecrets: z$2.boolean().optional(),
  linkedFrom: z$2.object({
    linkedByProfileId: z$2.string().uuid(),
    originPersonalProfileId: z$2.string().uuid().nullable(),
    originVaultId: z$2.string().uuid()
  }).optional(),
  linkedTo: z$2.array(z$2.object({
    linkedByProfileId: z$2.string().uuid(),
    targetPersonalProfileId: z$2.string().uuid().nullable(),
    targetVaultId: z$2.string().uuid(),
    addTime: z$2.string().refine((str) => isISO8601(str)),
    removeTime: z$2.string().refine((str) => isISO8601(str)).nullable()
  })).optional(),
  shareLinks: z$2.array(ShareLink).optional(),
  // This field is dropped as a transform. See LoginRevision below, and LoginListElement in
  // LoginVaultContentV2.ts
  internal: z$2.unknown(),
  archiveInfo: z$2.object({
    archivedByProfileId: z$2.string().uuid().optional(),
    archiveTime: z$2.string().refine((str) => isISO8601(str))
  }).optional(),
  leakedPasswordCheck: LeakedPasswordCheckInfo.optional()
  // deprecated fields
  // icon: z.string().optional(),
});
const LoginRevision = LoginWithoutHistory.merge(objectPassthrough({
  baseRevisionId: z$2.string().uuid().optional()
})).transform((_a2) => {
  var l2 = __rest$K(_a2, ["internal"]);
  return l2;
});
const LoginRevisionHistory = z$2.object({
  currentRevisionId: z$2.string().uuid(),
  revisions: z$2.record(LoginRevision)
});
const Login = LoginWithoutHistory.merge(objectPassthrough({
  history: LoginRevisionHistory.optional()
}));
const LOGIN_WITHOUT_HISTORY_KEYS = [
  "uiType",
  "title",
  "websites",
  "websiteAttributes",
  "androidApps",
  "username",
  "password",
  "note",
  "creationTime",
  "changeTime",
  "editTime",
  "creationProfileId",
  "editProfileId",
  "creationSource",
  "editSource",
  "customFields",
  "totp",
  "totpAlgorithm",
  "totpDigits",
  "totpPeriod",
  "tags",
  "creditCard",
  "wifiSsid",
  "sender",
  "pendingInboxConfirmation",
  "linkedViewSecrets",
  "linkedFrom",
  "linkedTo",
  "shareLinks",
  "archiveInfo",
  "leakedPasswordCheck"
];
const LOGIN_KEYS = [...LOGIN_WITHOUT_HISTORY_KEYS, "history"];
const LOGIN_REVISION_KEYS = [...LOGIN_WITHOUT_HISTORY_KEYS, "baseRevisionId"];
const emptyUnprotectedLogin = {
  uiType: LoginUiType.login,
  creationTime: "",
  editTime: "",
  title: "",
  username: "",
  password: "",
  note: "",
  customFields: [],
  websites: [],
  totp: ""
};
const ActiveElement = objectPassthrough({
  updateTime: z$2.string().refine((str) => isISO8601(str)),
  isDeleted: z$2.literal(false)
});
const Tombstone = objectPassthrough({
  updateTime: z$2.string().refine((str) => isISO8601(str)),
  isDeleted: z$2.literal(true),
  isArchived: z$2.literal(false).optional()
});
const ArchivedElement = objectPassthrough({
  updateTime: z$2.string().refine((str) => isISO8601(str)),
  isDeleted: z$2.literal(true),
  isArchived: z$2.literal(true)
});
z$2.union([ActiveElement, ArchivedElement]);
const UnprotectedShareLink = ShareLink.merge(objectPassthrough({ secret: UnprotectedValue }));
const UnprotectedLoginWithoutHistory = Login.merge(objectPassthrough({
  password: UnprotectedValue,
  totp: UnprotectedValue.optional(),
  customFields: z$2.array(UnprotectedCustomField),
  creditCard: LoginCreditCard.merge(z$2.object({
    pin: UnprotectedValue,
    securityCode: UnprotectedValue
  })).optional(),
  shareLinks: z$2.array(UnprotectedShareLink).optional()
}));
const UnprotectedLoginRevision = UnprotectedLoginWithoutHistory.merge(objectPassthrough({
  baseRevisionId: z$2.string().uuid().optional()
}));
const UnprotectedLogin = UnprotectedLoginWithoutHistory.merge(objectPassthrough({
  history: z$2.object({
    currentRevisionId: z$2.string().uuid(),
    revisions: z$2.record(UnprotectedLoginRevision)
  }).optional()
}));
const UnprotectedLoginListElement = z$2.union([
  UnprotectedLogin.merge(ActiveElement),
  UnprotectedLogin.merge(ArchivedElement),
  Tombstone
]);
var __rest$J = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const LoginListElement = z$2.union([
  // This is a hack. We would rather apply the transformation to Login directly, but can't because
  // the resulting ZodEffects type would no longer allow us to `.merge` here. So we apply this
  // transformation here, instead of in Login.ts
  // see https://github.com/colinhacks/zod/issues/2474
  Login.merge(ActiveElement).transform((_a2) => {
    var l2 = __rest$J(_a2, ["internal"]);
    return l2;
  }),
  // As archived elements are only written by newer client versions, they will never have the internal field
  Login.merge(ArchivedElement),
  Tombstone
]);
const LoginVaultContentV2 = objectPassthrough({ logins: z$2.record(LoginListElement) });
objectPassthrough({ logins: z$2.record(Login) });
const SessionMetadata = objectPassthrough({
  description: z$2.string().optional(),
  iconType: z$2.string().optional(),
  isSelfUnlocking: z$2.boolean().optional(),
  encPubKey: z$2.string().refine((str) => isBase64(str)),
  encPubKeySignature: z$2.string().refine((str) => isBase64(str)),
  signingAuthId: z$2.string().uuid(),
  creationTime: z$2.string().refine((str) => isISO8601(str)),
  editTime: z$2.string().refine((str) => isISO8601(str)),
  autosnatchTarget: z$2.string().uuid().optional(),
  autosnatchDisabled: z$2.boolean().optional()
});
const SiteSettings = objectPassthrough({
  extensionDisabled: z$2.boolean().optional()
  // extensionLoginAutosnatchDisabled: z.boolean().optional(), // deprecated
});
const PasswordGeneratorSettings = z$2.object({
  length: z$2.number().default(16),
  letters: z$2.boolean().default(true),
  numbers: z$2.boolean().default(true),
  special: z$2.boolean().default(true)
});
const HideHints = z$2.object({
  personalLoginsInfoBox: z$2.boolean().optional(),
  newFeatureOrganizationMonitoring: z$2.boolean().optional()
});
z$2.object({
  passwordGenerator: PasswordGeneratorSettings.optional(),
  backupCode: ProtectedValue.optional(),
  hideHints: HideHints.optional()
});
const SessionMetadataListElement = z$2.union([
  SessionMetadata.merge(ActiveElement),
  SessionMetadata.merge(ArchivedElement),
  Tombstone
]);
const SiteSettingsListElement = z$2.union([
  SiteSettings.merge(ActiveElement),
  SiteSettings.merge(ArchivedElement),
  Tombstone
]);
const MetaVaultContentV2 = objectPassthrough({
  sessions: z$2.record(SessionMetadataListElement),
  siteSettings: z$2.record(SiteSettingsListElement).optional()
});
objectPassthrough({
  sessions: z$2.record(SessionMetadata),
  siteSettings: z$2.record(SiteSettings).optional()
});
var __rest$I = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var PermissionLevel$1;
(function(PermissionLevel2) {
  PermissionLevel2["admin"] = "admin";
  PermissionLevel2["member"] = "member";
  PermissionLevel2["restricted"] = "restricted";
})(PermissionLevel$1 || (PermissionLevel$1 = {}));
const schemaPermissionLevel = makeTypescriptEnumSchema(PermissionLevel$1);
const TeamVaultPendingUserRegistration = objectPassthrough({
  email: z$2.string(),
  // fall back to most restrictive permission level
  permissionLevel: makeUnknownValuePlaceholderSchema(schemaPermissionLevel, PermissionLevel$1.restricted).optional()
});
const TeamVaultInfo = objectPassthrough({
  name: z$2.string(),
  icon: z$2.string().optional(),
  description: z$2.string().optional(),
  hideSecretsForRestrictedUsers: z$2.boolean().optional(),
  hideOnMobile: z$2.boolean().optional(),
  isSyncOrganizationMembers: z$2.boolean().optional(),
  /**
   * @deprecated Replaced by backend maintained email invites. Only present for migration purposes.
   */
  pendingUserRegistrations: z$2.array(TeamVaultPendingUserRegistration).optional()
});
const TeamVaultUser = objectPassthrough({
  joinedAt: z$2.string().refine((str) => isISO8601(str)),
  email: z$2.string().nullish().transform((_2) => null),
  newlyJoined: objectPassthrough({
    addedByUserId: z$2.string().uuid().optional(),
    addedByEmail: z$2.string()
  }).optional(),
  pendingInvite: objectPassthrough({
    invitedByUserId: z$2.string().uuid(),
    invitedByEmail: z$2.string()
  }).optional().transform((pendingInvite) => pendingInvite ? {
    addedByUserId: pendingInvite.invitedByUserId,
    addedByEmail: pendingInvite.invitedByEmail
  } : void 0).optional(),
  // fall back to most restrictive permission level
  permissionLevel: makeUnknownValuePlaceholderSchema(schemaPermissionLevel, PermissionLevel$1.restricted).optional()
}).transform((_a2) => {
  var { pendingInvite } = _a2, rest = __rest$I(_a2, ["pendingInvite"]);
  return pendingInvite ? Object.assign(Object.assign({}, rest), { newlyJoined: pendingInvite }) : Object.assign({}, rest);
});
const MetadataListElement = z$2.union([
  TeamVaultInfo.merge(ActiveElement),
  TeamVaultInfo.merge(ArchivedElement),
  Tombstone
]);
const UserListElement = z$2.union([
  z$2.intersection(TeamVaultUser, ArchivedElement.strip()),
  z$2.intersection(TeamVaultUser, ActiveElement.strip()),
  Tombstone
]);
const TeamMetaVaultContentV2 = objectPassthrough({
  info: z$2.record(MetadataListElement),
  users: z$2.record(UserListElement)
});
const TeamMetaVaultContentExternalV2 = objectPassthrough({
  info: z$2.record(TeamVaultInfo),
  users: z$2.record(TeamVaultUser)
});
const GV2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get PermissionLevel() {
    return PermissionLevel$1;
  },
  TeamMetaVaultContentExternalV2,
  TeamMetaVaultContentV2,
  TeamVaultInfo,
  TeamVaultPendingUserRegistration,
  TeamVaultUser
}, Symbol.toStringTag, { value: "Module" }));
const OrganizationPendingUserRegistration = objectPassthrough({
  email: z$2.string()
});
const LegacyOrganizationAdminVaultInfo = objectPassthrough({
  authenticatorSecret: objectPassthrough({
    // authenticatorId: z.string().uuid(),
    seed: ProtectedValue
  }).optional(),
  profileSecret: objectPassthrough({
    seed: ProtectedValue
  }).optional(),
  /**
   * @deprecated Replaced by backend maintained email invites. Only present for migration purposes.
   */
  pendingUserRegistrations: OrganizationPendingUserRegistration.array().optional(),
  unsafeStoredVaultContents: z$2.record(objectPassthrough({
    logins: z$2.record(UnprotectedLogin),
    archivedLogins: z$2.record(UnprotectedLogin)
  })).optional()
});
const InfoListElement$1 = z$2.union([
  LegacyOrganizationAdminVaultInfo.merge(ActiveElement),
  LegacyOrganizationAdminVaultInfo.merge(ArchivedElement),
  Tombstone
]);
const LegacyOrganizationAdminVaultContent$1 = objectPassthrough({
  info: z$2.record(InfoListElement$1)
});
const LegacyOrganizationAdminVaultContentExternal = objectPassthrough({
  info: z$2.record(LegacyOrganizationAdminVaultInfo)
});
const LOAV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LegacyOrganizationAdminVaultContent: LegacyOrganizationAdminVaultContent$1,
  LegacyOrganizationAdminVaultContentExternal,
  LegacyOrganizationAdminVaultInfo,
  OrganizationPendingUserRegistration
}, Symbol.toStringTag, { value: "Module" }));
const OrganizationAdminVaultInfo = objectPassthrough({
  unsafeStoredVaultContents: z$2.record(objectPassthrough({
    logins: z$2.record(UnprotectedLogin),
    archivedLogins: z$2.record(UnprotectedLogin)
  })).optional()
});
const InfoListElement = z$2.union([
  OrganizationAdminVaultInfo.merge(ActiveElement),
  OrganizationAdminVaultInfo.merge(ArchivedElement),
  Tombstone
]);
const OrganizationAdminVaultContent$1 = objectPassthrough({
  info: z$2.record(InfoListElement)
});
const OrganizationAdminVaultContentExternal = objectPassthrough({
  info: z$2.record(OrganizationAdminVaultInfo)
});
const OAV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OrganizationAdminVaultContent: OrganizationAdminVaultContent$1,
  OrganizationAdminVaultContentExternal,
  OrganizationAdminVaultInfo
}, Symbol.toStringTag, { value: "Module" }));
const RelatedProfile = z$2.object({
  id: z$2.string().uuid(),
  email: z$2.string().nullable()
});
const schemaGroups = objectPassthrough({
  enable: z$2.boolean()
});
const schemaEventNotifications = objectPassthrough({
  enable: z$2.boolean()
});
const schemaSubscriptionErrorKnownValue$1 = makeProtobufEnumSchema(SubscriptionError).transform(makeExcludeValuesTransform(SubscriptionError.OK));
const ServerSideSettings = objectPassthrough({
  groups: schemaGroups.optional(),
  eventNotifications: schemaEventNotifications.optional(),
  persistLastKnownSyncVersion: z$2.boolean().optional(),
  migrateToProfiles: z$2.boolean().optional(),
  migrateRedundantPrivateProfile: z$2.boolean().optional(),
  injectSubscriptionError: z$2.record(schemaSubscriptionErrorKnownValue$1).optional(),
  preferLongPollForProtoClientTypes: z$2.array(z$2.number()).optional(),
  allowLoginInbox: z$2.boolean().optional(),
  lfdAdmin: z$2.boolean().optional(),
  showInternalBetas: z$2.boolean().optional()
});
const SessionClientProfileSettings = z$2.object({
  enabled: z$2.boolean()
});
const SessionClientSettings = z$2.object({
  enableAllProfiles: z$2.boolean().default(true),
  profileSettings: z$2.record(SessionClientProfileSettings).default({})
});
const unlockTimeLimitSchema = z$2.object({
  enabled: z$2.boolean(),
  minutes: z$2.number()
});
const schemaSessionType = makeProtobufEnumSchema(SessionType);
const Session = z$2.object({
  id: z$2.string().uuid(),
  createdAt: z$2.instanceof(Date),
  lastUsedAt: z$2.instanceof(Date),
  unlockedAt: z$2.instanceof(Date).optional(),
  unlockedUntil: z$2.instanceof(Date).optional(),
  unlockRequestedAt: z$2.instanceof(Date).optional(),
  unlockExtendAt: z$2.instanceof(Date).optional(),
  clientSettings: SessionClientSettings.default({ enableAllProfiles: true, profileSettings: {} }),
  sessionType: schemaSessionType.default(SessionType.UNKNOWN),
  enabledProfileIds: z$2.string().uuid().array().default([]),
  unlockTimeLimit: unlockTimeLimitSchema.default({ enabled: false, minutes: 60 })
});
const UserClientSettings = objectPassthrough({
  enableBetaOrganizationUserManagement: z$2.boolean().optional(),
  enableBetaHeyloginMe: z$2.boolean().optional(),
  enableBetaLeakedPasswordCheck: z$2.boolean().optional(),
  enableBetaPasswordPolicy: z$2.boolean().optional(),
  enableBetaShowPersonalLoginsOnMobile: z$2.boolean().optional()
});
var decode;
var encode;
(function() {
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
    for (i2 = 0; i2 < len; i2 += 3) {
      base64 += chars[bytes[i2] >> 2];
      base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
      base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
      base64 += chars[bytes[i2 + 2] & 63];
    }
    if (len % 3 === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }
    return base64;
  };
  decode = function(base64) {
    var bufferLength = base64.length * 0.75, len = base64.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }
    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
    for (i2 = 0; i2 < len; i2 += 4) {
      encoded1 = lookup[base64.charCodeAt(i2)];
      encoded2 = lookup[base64.charCodeAt(i2 + 1)];
      encoded3 = lookup[base64.charCodeAt(i2 + 2)];
      encoded4 = lookup[base64.charCodeAt(i2 + 3)];
      bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return arraybuffer;
  };
})();
const FLAG_UINT8_ARRAY = "FLAG_UINT8_ARRAY";
const FLAG_DATE = "FLAG_DATE";
const FLAG_UNDEFINED = "FLAG_UNDEFINED";
function jsonThaw(_key, value) {
  if (value instanceof Object && "flag" in value) {
    switch (value.flag) {
      case FLAG_UINT8_ARRAY:
        return new Uint8Array(decode(value.data));
      case FLAG_DATE:
        return new Date(value.data);
      case FLAG_UNDEFINED:
        return void 0;
      default:
        return value;
    }
  }
  return value;
}
function jsonFreeze(key) {
  const value = this[key];
  if (value instanceof Uint8Array) {
    return {
      flag: FLAG_UINT8_ARRAY,
      data: encode(value)
    };
  }
  if (value instanceof Date) {
    return {
      flag: FLAG_DATE,
      data: value.toISOString()
    };
  }
  if (value === void 0) {
    return {
      flag: FLAG_UNDEFINED
    };
  }
  return value;
}
function jsonStringifyFreeze(value, space) {
  return JSON.stringify(value, jsonFreeze, space);
}
function jsonParseThaw(text) {
  return JSON.parse(text, jsonThaw);
}
const OrganizationClientSettings = objectPassthrough({
  hidePersonalLoginsOnMobile: z$2.boolean().optional()
});
const ContactInfo = z$2.object({
  name: z$2.string().optional(),
  icon: z$2.string().optional(),
  addressLine1: z$2.string().optional(),
  addressLine2: z$2.string().optional()
});
const ParentOrganizationMetadata = z$2.object({
  contact: ContactInfo.optional()
});
const PasswordRules = z$2.object({
  length: z$2.number(),
  upper: z$2.boolean(),
  numbers: z$2.boolean(),
  special: z$2.boolean()
});
const PasswordPolicy = makeUnknownValuePlaceholderSchema(z$2.discriminatedUnion("type", [
  z$2.object({ type: z$2.literal("default") }),
  z$2.object({ type: z$2.literal("custom"), rules: PasswordRules })
]), { type: "default" });
const schemaProfileAuthenticatorLock = z$2.object({
  authenticatorId: z$2.string().uuid(),
  encryptedHighSecurityProfileSeed: z$2.instanceof(Uint8Array),
  encryptedStorableProfileSeed: z$2.instanceof(Uint8Array)
});
const schemaProfileProfileLock = z$2.object({
  lockingProfileId: z$2.string().uuid(),
  lockingProfileKeyGenerationId: z$2.string().uuid(),
  encryptedHighSecurityProfileSeed: z$2.instanceof(Uint8Array),
  encryptedStorableProfileSeed: z$2.instanceof(Uint8Array)
});
const schemaProfileType = makeProtobufEnumSchema(ProfileType);
const PersistableProfile = z$2.object({
  id: z$2.string().uuid(),
  profileType: schemaProfileType,
  keyGenerationId: z$2.string().uuid(),
  email: z$2.string().nullable(),
  unverifiedEmail: z$2.string().nullable().default(null),
  organizationId: z$2.string().uuid().nullable(),
  highSecurityIdentitySigPubKey: brandedUint8Array(loadSigningPublicKey),
  highSecurityVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  highSecurityVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  highSecurityProfileSeedEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  highSecurityProfileSeedEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  storableSigPubKey: brandedUint8Array(loadSigningPublicKey),
  storableSigPubKeySignature: brandedUint8Array(loadSigningPublicKeySignature),
  storableVaultKeyEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  storableVaultKeyEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  storableProfileSeedEncPubKey: brandedUint8Array(loadEncryptionPublicKey),
  storableProfileSeedEncPubKeySignature: brandedUint8Array(loadEncryptionPublicKeySignature),
  authenticatorLocks: z$2.array(schemaProfileAuthenticatorLock),
  profileLock: schemaProfileProfileLock.nullable().default(null),
  localEncryptedStorableSeed: brandedUint8Array(loadAsymEncryptedBlob).optional()
});
var __rest$H = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const PersistableOrganizationAdminInfo = z$2.object({
  vaultId: z$2.string().uuid().nullable().default(null),
  legacyAdminVaultId: z$2.string().uuid().nullable().default(null),
  authenticator: Authenticator.optional(),
  adminProfile: PersistableProfile.optional(),
  entraTenantId: z$2.string().optional(),
  csvIntegrationActive: z$2.boolean().default(false),
  googleWorkspaceIntegrationActive: z$2.boolean().default(false),
  trialEndDate: z$2.date().optional(),
  licenseType: makeProtobufEnumSchema(LicenseType).default(LicenseType.NONE)
}).transform((_a2) => {
  var { vaultId, legacyAdminVaultId } = _a2, remainingAdminInfo = __rest$H(_a2, ["vaultId", "legacyAdminVaultId"]);
  return Object.assign(Object.assign({}, remainingAdminInfo), { legacyAdminVaultId: legacyAdminVaultId !== null && legacyAdminVaultId !== void 0 ? legacyAdminVaultId : vaultId });
});
const PersistableOrganizationProfile = z$2.object({
  profileId: z$2.string().uuid(),
  isAdmin: z$2.boolean().default(false),
  isManager: z$2.boolean().default(false),
  isService: z$2.boolean().default(false),
  isNotConnected: z$2.boolean().default(false),
  personalVaultId: z$2.string().uuid().optional(),
  invitedAt: z$2.date().optional(),
  preliminaryUserId: z$2.string().uuid().optional(),
  startCode: z$2.string().optional(),
  startCodeGeneratedAt: z$2.date().optional(),
  startCodeEmailSentAt: z$2.date().optional(),
  lastActiveAt: z$2.date().optional(),
  primaryLoginDevice: makeProtobufEnumSchema(PrimaryLoginDevice).optional()
});
const ParentOrganizationInfo = z$2.object({
  id: z$2.string().uuid(),
  name: z$2.string(),
  icon: z$2.string().optional(),
  metadata: ParentOrganizationMetadata.optional()
});
const schemaSubscriptionErrorKnownValue = makeProtobufEnumSchema(SubscriptionError).transform(makeExcludeValuesTransform(SubscriptionError.OK));
const passwordPolicyFallback = z$2.string().nullable().transform((oldValue) => {
  if (oldValue === null) {
    return void 0;
  }
  try {
    return PasswordPolicy.parse(jsonParseThaw(oldValue));
  } catch (e2) {
    return void 0;
  }
});
const passwordPolicyWithFallback = z$2.union([
  passwordPolicyFallback,
  PasswordPolicy.optional()
]);
const PersistableOrganization = z$2.object({
  id: z$2.string().uuid(),
  name: z$2.string(),
  icon: z$2.string().nullable(),
  organizationType: makeProtobufEnumSchema(OrganizationType).default(OrganizationType.UNKNOWN),
  restrictCreateTeam: z$2.boolean().default(false),
  restrictPersonalLogins: z$2.boolean().default(false),
  auditlogEnable: z$2.boolean().default(false),
  childOrganizationManagementEnable: z$2.boolean().default(false),
  superUserId: z$2.string().uuid(),
  adminProfileId: z$2.string().uuid().nullable().default(null),
  isAdmin: z$2.boolean().default(false),
  isManager: z$2.boolean().default(false),
  isPreliminary: z$2.boolean().default(false),
  profiles: z$2.array(PersistableOrganizationProfile).default([]),
  adminInfo: PersistableOrganizationAdminInfo.optional(),
  subscriptionError: schemaSubscriptionErrorKnownValue.nullable(),
  verifiedDomain: z$2.string().nullable().default(null),
  passwordPolicy: passwordPolicyWithFallback,
  unlockTimeLimit: unlockTimeLimitSchema.default({ enabled: false, minutes: 60 }),
  clientSettings: OrganizationClientSettings.nullable(),
  parentOrganizationInfo: ParentOrganizationInfo.optional()
});
const WebauthnCredential = z$2.object({
  // this field was added late, so we default to a random id if it was missing. this will fix itself
  // on the next sync update, and operations that work on this value will fail reasonably gracefully
  // until then.
  // TODO remove this fallback when minimum version hits 2023-09-28
  webauthnId: z$2.string().default(() => (
    // b64 urlsafe encoding
    naclUtilExports.encodeBase64(randomSeed()).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "")
  )),
  credentialType: makeProtobufEnumSchema(CredentialType).default(CredentialType.UNKNOWN),
  aaguid: z$2.string().nullable(),
  sessionId: z$2.string().nullable().default(null),
  createdAt: z$2.date(),
  lastUsedAt: z$2.date(),
  prfSupportStatus: makeProtobufEnumSchema(WebauthnPrfSupportStatus).default(WebauthnPrfSupportStatus.UNKNOWN)
});
const PersistableAccountState = z$2.object({
  userId: z$2.string().uuid(),
  emails: z$2.array(z$2.object({
    email: z$2.string(),
    primary: z$2.boolean(),
    verificationPending: z$2.boolean()
  })).optional(),
  preferredLocale: z$2.string().nullable().optional(),
  serverSideSettings: ServerSideSettings.optional(),
  userClientSettings: UserClientSettings.optional(),
  authenticators: z$2.array(Authenticator),
  sessions: z$2.array(Session),
  achievements: z$2.number().array().optional(),
  localAchievements: z$2.number().array().optional(),
  authenticatorBlockHash: brandedUint8Array(loadHash).optional(),
  organizations: z$2.array(PersistableOrganization).optional(),
  relatedProfiles: z$2.record(RelatedProfile).optional(),
  webauthnCredentials: z$2.array(WebauthnCredential).default([]),
  // deprecated
  email: z$2.string().nullable().optional(),
  unverifiedEmail: z$2.string().nullable().optional(),
  fullName: z$2.string().nullable().optional()
});
const LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS = ["displayMaskedNumber", "displayType"];
const LOGIN_DIFFERENCE_IGNORED_KEYS = [
  "creationProfileId",
  "editProfileId",
  "editTime",
  "creationTime",
  "creationSource",
  "editSource",
  "linkedFrom",
  "linkedTo",
  "linkedViewSecrets",
  "sender",
  "pendingInboxConfirmation",
  "shareLinks",
  "history",
  "archiveInfo",
  "changeTime",
  "websiteAttributes",
  "baseRevisionId",
  "uiType",
  "leakedPasswordCheck"
];
function makeLoginDifferenceIncludedKeysSchema(keys3) {
  const includedKeys = keys3.filter((k2) => !LOGIN_DIFFERENCE_IGNORED_KEYS.includes(k2));
  return z$2.string().refine((s2) => includedKeys.includes(s2));
}
function makeLoginDifferenceCreditCardIncludedKeysSchema() {
  const includedKeys = LOGIN_CREDIT_CARD_KEYS.filter((k2) => !LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS.includes(k2));
  return z$2.string().refine((s2) => includedKeys.includes(s2));
}
function makeGenericLoginDifferenceSchema(keys3) {
  return makeUnknownValuePlaceholderSchema(z$2.discriminatedUnion("type", [
    z$2.object({
      type: z$2.literal("login"),
      key: makeLoginDifferenceIncludedKeysSchema(keys3)
    }),
    z$2.object({
      type: z$2.literal("creditCard"),
      key: makeLoginDifferenceCreditCardIncludedKeysSchema()
    }),
    z$2.object({
      type: z$2.literal("customField"),
      id: z$2.string().uuid(),
      name: z$2.string()
    })
  ]), { type: "unknown" });
}
const LoginDifference = makeGenericLoginDifferenceSchema(LOGIN_KEYS);
makeGenericLoginDifferenceSchema(LOGIN_REVISION_KEYS);
const schemaEventType = makeProtobufEnumSchema(AuditlogEventType);
const AuditlogEventTargetProfile = z$2.object({
  id: z$2.string().uuid(),
  email: z$2.string()
});
const AuditlogEvent = z$2.object({
  type: schemaEventType,
  vaultId: z$2.string().uuid().optional(),
  loginId: z$2.string().uuid().optional(),
  customFieldId: z$2.string().uuid().optional(),
  loginRevisionId: z$2.string().uuid().optional(),
  loginEditTime: z$2.string().refine((str) => isISO8601(str)).optional(),
  loginDifferences: z$2.array(LoginDifference).optional(),
  targetProfile: AuditlogEventTargetProfile.optional()
});
const AuditlogEventEnvelope = z$2.object({
  id: z$2.string().uuid(),
  profileId: z$2.string().uuid(),
  time: z$2.string().refine((str) => isISO8601(str)),
  clientIp: z$2.string().optional(),
  event: AuditlogEvent
});
const QueuedAuditlogEvent = z$2.object({
  organizationId: z$2.string().uuid(),
  clientTime: z$2.date(),
  lastKnownServerTime: z$2.date(),
  event: AuditlogEvent
});
const PersistableForeignVaultSyncPredicate = z$2.object({
  organizationTeamVaults: z$2.boolean().optional(),
  organizationAllVaults: z$2.array(z$2.string().uuid()).optional(),
  organizationPersonalVaultsForUsers: z$2.record(z$2.array(z$2.string().uuid())).optional(),
  organizationPersonalVaultsForProfiles: z$2.record(z$2.array(z$2.string().uuid())).optional(),
  profileAllVaults: z$2.array(z$2.string().uuid()).optional()
});
const PersistableProfileRepo = z$2.object({
  profiles: z$2.array(PersistableProfile),
  orgAdminProfiles: z$2.array(PersistableProfile).default([]),
  disabledProfiles: z$2.array(PersistableProfile).default([])
});
const LinkedLoginUpdateMessageV1 = z$2.array(z$2.union([
  z$2.object({
    type: z$2.literal("originUpdated"),
    loginId: z$2.string().uuid(),
    content: UnprotectedLoginListElement
  }),
  z$2.object({
    type: z$2.literal("targetDeleted"),
    loginId: z$2.string().uuid(),
    removeTime: z$2.string().refine((str) => isISO8601(str))
  })
]));
var __rest$G = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const schemaLockDtoNewKeyNames = z$2.object({
  authenticatorId: z$2.string().uuid(),
  encryptedStorableVaultKey: z$2.instanceof(Uint8Array),
  encryptedHighSecurityVaultKey: z$2.instanceof(Uint8Array),
  encryptedVaultMessagePrivateKey: z$2.instanceof(Uint8Array).nullable().default(null)
});
const schemaLockDtoOldKeyNames = z$2.object({
  authenticatorId: z$2.string().uuid(),
  vaultKek: z$2.instanceof(Uint8Array),
  protectedKek: z$2.instanceof(Uint8Array)
}).transform((_a2) => {
  var { vaultKek, protectedKek } = _a2, rest = __rest$G(_a2, ["vaultKek", "protectedKek"]);
  return Object.assign({ encryptedStorableVaultKey: vaultKek, encryptedHighSecurityVaultKey: protectedKek, encryptedVaultMessagePrivateKey: null }, rest);
});
const schemaVaultAuthenticatorLockDto = z$2.union([
  schemaLockDtoOldKeyNames,
  schemaLockDtoNewKeyNames
]);
const schemaVaultProfileLockDtoOldKeyNames = z$2.object({
  profileId: z$2.string().uuid(),
  profileKeyGenerationId: z$2.string().uuid(),
  encryptedStorableVaultKey: z$2.instanceof(Uint8Array),
  encryptedHighSecurityVaultKey: z$2.instanceof(Uint8Array),
  encryptedVaultMessagePrivateKey: z$2.instanceof(Uint8Array).nullable().default(null)
}).transform((_a2) => {
  var { profileId, profileKeyGenerationId } = _a2, rest = __rest$G(_a2, ["profileId", "profileKeyGenerationId"]);
  return Object.assign({ lockingProfileId: profileId, lockingProfileKeyGenerationId: profileKeyGenerationId }, rest);
});
const schemaVaultProfileLockDtoNewKeyNames = z$2.object({
  lockingProfileId: z$2.string().uuid(),
  lockingProfileKeyGenerationId: z$2.string().uuid(),
  encryptedStorableVaultKey: z$2.instanceof(Uint8Array),
  encryptedHighSecurityVaultKey: z$2.instanceof(Uint8Array),
  encryptedVaultMessagePrivateKey: z$2.instanceof(Uint8Array).nullable().default(null)
});
const schemaVaultProfileLockDto = z$2.union([
  schemaVaultProfileLockDtoOldKeyNames,
  schemaVaultProfileLockDtoNewKeyNames
]);
const schemaLinkedUpdateMessage = z$2.object({
  vaultId: z$2.string().uuid(),
  type: z$2.literal(VaultMessageType.LINKED_LOGIN_UPDATE_V1),
  message: LinkedLoginUpdateMessageV1
});
const PersistableVault = z$2.object({
  id: z$2.string().uuid(),
  type: makeProtobufEnumSchema(VaultType),
  associatedVaultId: z$2.string().uuid().optional().nullable(),
  generationId: z$2.string().uuid(),
  firstCommitId: z$2.string().uuid().optional(),
  commitId: z$2.string().uuid(),
  userIds: z$2.array(z$2.string().uuid()),
  profileIds: z$2.array(z$2.string().uuid()).optional(),
  organizationId: z$2.string().uuid().optional().nullable(),
  locks: z$2.array(schemaVaultAuthenticatorLockDto),
  profileLock: schemaVaultProfileLockDto.optional(),
  adminProfileLock: schemaVaultProfileLockDto.optional(),
  dirty: z$2.boolean().optional(),
  vaultState: z$2.instanceof(Uint8Array),
  stagedDiff: z$2.union([z$2.instanceof(Uint8Array), z$2.null()]).optional(),
  messagePublicKey: z$2.instanceof(Uint8Array).nullable().default(null),
  inboxSlug: z$2.string().nullable().default(null),
  linkedUpdateMessages: z$2.array(schemaLinkedUpdateMessage).default([])
});
const PersistableVaultRepo = z$2.object({
  vaults: z$2.array(PersistableVault)
});
z$2.object({
  accountState: PersistableAccountState,
  profileRepo: PersistableProfileRepo.default({ profiles: [] }),
  vaultRepo: PersistableVaultRepo,
  lastKnownSyncVersion: z$2.number().optional(),
  superUserUnlockedAuthenticators: z$2.record(UnlockedAuthenticator$1).optional(),
  foreignVaultSyncPredicate: PersistableForeignVaultSyncPredicate.optional(),
  ignoredUnlock: z$2.date().optional(),
  auditlogEventQueue: z$2.array(QueuedAuditlogEvent).default([])
});
z$2.object({
  streetAndNumber: z$2.string().optional(),
  streetAdditional: z$2.string().optional(),
  postalCode: z$2.string().optional(),
  city: z$2.string().optional(),
  region: z$2.string().optional(),
  country: z$2.string().optional()
});
const PersistableAuthenticatorBlockContent = objectType({
  parent: stringType().refine(isBase64, "could not parse base64 parent hash"),
  keys: arrayType(stringType().refine(isBase64, "could not parse base64 key"))
});
const VaultStateInternalStructure = objectPassthrough({
  type: z$2.string(),
  version: z$2.number(),
  content: z$2.unknown()
});
const AutosnatchUndoCreate = z$2.object({
  id: z$2.string().uuid(),
  type: z$2.literal("create"),
  editTime: z$2.string().refine((str) => isISO8601(str)),
  loginId: z$2.string().uuid(),
  vaultId: z$2.string().uuid().optional(),
  applied: z$2.boolean().optional(),
  seen: z$2.boolean().optional()
});
const AutosnatchUndoUpdate = z$2.object({
  id: z$2.string().uuid(),
  type: z$2.literal("update"),
  editTime: z$2.string().refine((str) => isISO8601(str)),
  loginId: z$2.string().uuid(),
  vaultId: z$2.string().uuid().optional(),
  applied: z$2.boolean().optional(),
  seen: z$2.boolean().optional(),
  oldEditTime: z$2.string().refine((str) => isISO8601(str)),
  oldPassword: UnprotectedValue.optional(),
  oldUsername: z$2.string().optional(),
  oldEditProfile: z$2.string().uuid().optional(),
  newRevisionId: z$2.string().uuid().optional(),
  oldEditSource: makeUnknownValuePlaceholderSchema(schemaLoginSource, void 0).optional()
});
const AutosnatchUndo = z$2.union([AutosnatchUndoCreate, AutosnatchUndoUpdate]);
const ContentScriptAddress = z$2.object({
  tabId: z$2.number(),
  frameId: z$2.number().optional()
});
const AutosnatchSource = z$2.union([
  z$2.literal(LoginSource.addTotpFromOverlay),
  z$2.literal(LoginSource.updateLoginFromOverlay),
  z$2.literal(LoginSource.autosave),
  z$2.literal(LoginSource.registrationPasswordGeneration)
]);
const EnqueuedAutosnatch = z$2.object({
  id: z$2.string().uuid(),
  date: z$2.string().refine((str) => isISO8601(str)),
  url: z$2.string(),
  username: z$2.string(),
  password: z$2.string(),
  seen: z$2.boolean().optional(),
  forceCreate: z$2.boolean().optional(),
  targetLoginId: z$2.string().uuid().optional(),
  targetVaultId: z$2.string().uuid().optional(),
  waitForContentScript: ContentScriptAddress.optional(),
  hideUntilCompletion: z$2.boolean().optional(),
  addTldPlus1: z$2.boolean().optional(),
  source: AutosnatchSource.optional().catch(void 0)
});
z$2.object({
  userId: z$2.string().uuid(),
  undos: z$2.array(AutosnatchUndo),
  queue: z$2.array(EnqueuedAutosnatch)
});
z$2.object({
  contact: ContactInfo.optional()
});
const LoginInboxMessageV1 = z$2.object({
  sender: z$2.object({
    name: z$2.string(),
    company: z$2.string().optional()
  }),
  website: z$2.string(),
  username: z$2.string(),
  password: z$2.string(),
  creationTime: z$2.string().refine((str) => isISO8601(str))
});
const CsvIntegrationDataUser = z$2.object({
  email: z$2.string(),
  filterColumnData: z$2.record(z$2.array(z$2.string()).optional())
});
const CsvFilterColumn = z$2.object({
  name: z$2.string(),
  multiValue: z$2.boolean(),
  values: z$2.array(z$2.string())
});
const CsvIntegrationData = z$2.object({
  users: z$2.array(CsvIntegrationDataUser),
  filterColumns: z$2.array(CsvFilterColumn),
  originalCsv: z$2.string()
});
const ShareLinkOpenedBackendMessageV1 = z$2.object({
  shareLinkId: z$2.string(),
  openedAt: z$2.string().refine((str) => isISO8601(str))
});
const LoginFormElementSelectors = z$2.object({
  passwordElement: z$2.string().nullable(),
  usernameElement: z$2.string().nullable(),
  totpElements: z$2.string().or(z$2.array(z$2.string())).nullable(),
  submitElement: z$2.string().nullable(),
  stayLoggedInElement: z$2.string().nullable(),
  formElement: z$2.string().nullable()
}).nullable();
const AndPredicate = z$2.object({
  type: z$2.literal("all"),
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  predicates: z$2.array(z$2.lazy(() => OverridePredicate))
});
const OrPredicate = z$2.object({
  type: z$2.literal("atLeastOne"),
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  predicates: z$2.array(z$2.lazy(() => OverridePredicate))
});
const ElementExistsPredicate = z$2.object({
  type: z$2.literal("elementExists"),
  selector: z$2.string(),
  requireVisible: z$2.boolean().optional()
});
const OverridePredicate = z$2.intersection(z$2.discriminatedUnion("type", [AndPredicate, OrPredicate, ElementExistsPredicate]), z$2.object({ negated: z$2.boolean().optional() }));
const RegistrationFormElementSelectors = z$2.object({
  formElement: z$2.string().nullable(),
  passwordElement: z$2.string().nullable(),
  repeatPasswordElement: z$2.string().nullable(),
  usernameElement: z$2.string().nullable(),
  submitElement: z$2.string().nullable()
}).nullable();
const LoginOverrideRule = z$2.object({
  type: z$2.literal("loginForm"),
  selectors: LoginFormElementSelectors
});
const RegistrationOverrideRule = z$2.object({
  type: z$2.literal("registrationForm"),
  selectors: RegistrationFormElementSelectors
});
const NoFormOverrideRule = z$2.object({
  type: z$2.literal("noForm")
});
const FormKindHintOverrideRule = z$2.object({
  type: z$2.literal("formKindHint"),
  kind: z$2.union([z$2.literal("login"), z$2.literal("registration")])
});
const OverrideRule = z$2.intersection(z$2.discriminatedUnion("type", [
  LoginOverrideRule,
  RegistrationOverrideRule,
  NoFormOverrideRule,
  FormKindHintOverrideRule
]), z$2.object({ predicate: OverridePredicate.optional() }));
var WebpageOverrideStatus;
(function(WebpageOverrideStatus2) {
  WebpageOverrideStatus2["hotfix"] = "hotfix";
})(WebpageOverrideStatus || (WebpageOverrideStatus = {}));
const WebpageOverride = z$2.intersection(z$2.object({
  id: z$2.string().uuid(),
  status: makeTypescriptEnumSchema(WebpageOverrideStatus).optional(),
  comment: z$2.string().optional(),
  rules: z$2.array(OverrideRule)
}), z$2.union([
  z$2.object({ hostnameContains: z$2.string(), predicate: OverridePredicate.optional() }),
  z$2.object({ predicate: OverridePredicate })
]));
z$2.array(WebpageOverride);
const ExtensionAvailableInfoMessage = objectPassthrough({
  type: z$2.literal("extensionAvailableInfo"),
  globalSearch: z$2.object({ shortcut: z$2.string().optional() }).optional(),
  isSimulated: z$2.boolean().optional()
});
const GetClientCoreParametersRequestMessage = objectPassthrough({
  type: z$2.literal("getClientCoreParametersRequest")
});
const SetClientCoreParametersMessage = objectPassthrough({
  type: z$2.literal("setClientCoreParameters"),
  clientCoreParametersJSON: z$2.string()
});
z$2.union([
  ExtensionAvailableInfoMessage,
  GetClientCoreParametersRequestMessage,
  SetClientCoreParametersMessage
]);
const IsExtensionAvailableMessage = objectPassthrough({
  type: z$2.literal("isExtensionAvailable")
});
const ClientCoreParametersChangeMessage = objectPassthrough({
  type: z$2.literal("clientCoreParametersChange")
});
const OpenShortcutSettingsMessage = objectPassthrough({
  type: z$2.literal("openShortcutSettings")
});
const GetClientCoreParametersResponseMessage = objectPassthrough({
  type: z$2.literal("getClientCoreParametersResponse"),
  clientCoreParametersJSON: z$2.string().optional()
});
const SetClearValueFromClipboardAfterTimeoutMessage = objectPassthrough({
  type: z$2.literal("setClearValueFromClipboardAfterTimeout"),
  clearAfterTimeout: z$2.boolean(),
  value: z$2.string()
});
z$2.union([
  IsExtensionAvailableMessage,
  ClientCoreParametersChangeMessage,
  OpenShortcutSettingsMessage,
  GetClientCoreParametersResponseMessage,
  SetClearValueFromClipboardAfterTimeoutMessage
]);
function isActiveWebauthnAuthenticator(a2) {
  return a2.authenticatorType === AuthenticatorType.WEBAUTHN && a2.webauthn !== void 0;
}
const SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY = "salt-authenticator-login-signing-key-";
const SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY = "salt-authenticator-signing-key-";
const SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY = "salt-authenticator-encryption-key-";
const SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY = "salt-authenticator-signing-key-";
const SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY = "salt-authenticator-encryption-key-";
const SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-authenticator-encryption-key-signature-";
const SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE = "salt-authenticator-signing-key-signature-";
const SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-authenticator-encryption-key-signature-";
const SALT_AUTHENTICATOR_WEBAUTHN_SEED = "salt-authenticator-webauthn-seed-";
function verifyAuthenticator(a2) {
  if (!verifySignedEncryptionPublicKey(a2.highSecurityIdentitySigPubKey, a2.highSecurityVaultKeyEncPubKey, a2.highSecurityVaultKeyEncPubKeySignature, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE)) {
    return false;
  }
  if (!verifySignedEncryptionPublicKey(a2.highSecurityIdentitySigPubKey, a2.storableVaultKeyEncPubKey, a2.storableVaultKeyEncPubKeySignature, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE)) {
    return false;
  }
  if (!verifySignedSigningPublicKey(a2.highSecurityIdentitySigPubKey, a2.storableSigPubKey, a2.storableSigPubKeySignature, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE)) {
    return false;
  }
  return true;
}
var ClientCoreErrorGroup;
(function(ClientCoreErrorGroup2) {
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Generic"] = 1e4] = "Generic";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Vault"] = 2e4] = "Vault";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Authenticator"] = 3e4] = "Authenticator";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Syncing"] = 4e4] = "Syncing";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Core"] = 5e4] = "Core";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Login"] = 6e4] = "Login";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Protected"] = 7e4] = "Protected";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Organization"] = 8e4] = "Organization";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Profile"] = 9e4] = "Profile";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["Webauthn"] = 1e5] = "Webauthn";
  ClientCoreErrorGroup2[ClientCoreErrorGroup2["ShareLink"] = 11e4] = "ShareLink";
})(ClientCoreErrorGroup || (ClientCoreErrorGroup = {}));
var ClientCoreErrorCode;
(function(ClientCoreErrorCode2) {
  ClientCoreErrorCode2[ClientCoreErrorCode2["NotImplemented"] = 2010500] = "NotImplemented";
  ClientCoreErrorCode2[ClientCoreErrorCode2["Internal"] = 2010501] = "Internal";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ParentIdDoesntMatch"] = 2020401] = "ParentIdDoesntMatch";
  ClientCoreErrorCode2[ClientCoreErrorCode2["CannotOverrideCommitId"] = 2020402] = "CannotOverrideCommitId";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidSessionModification"] = 2020410] = "InvalidSessionModification";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidVaultContentDescriptorName"] = 2020411] = "InvalidVaultContentDescriptorName";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LoginNotFound"] = 2020412] = "LoginNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["CannotRegenerateLockedVault"] = 2020420] = "CannotRegenerateLockedVault";
  ClientCoreErrorCode2[ClientCoreErrorCode2["UserAuthenticatorsMissingForRegenerate"] = 2020421] = "UserAuthenticatorsMissingForRegenerate";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileMissingForRegenerate"] = 2020422] = "ProfileMissingForRegenerate";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NoCommits"] = 2020430] = "NoCommits";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NeedLocks"] = 2020431] = "NeedLocks";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NeedFullHistory"] = 2020432] = "NeedFullHistory";
  ClientCoreErrorCode2[ClientCoreErrorCode2["VaultIsLocked"] = 2020440] = "VaultIsLocked";
  ClientCoreErrorCode2[ClientCoreErrorCode2["MetaVaultIdDoesntMatch"] = 2020450] = "MetaVaultIdDoesntMatch";
  ClientCoreErrorCode2[ClientCoreErrorCode2["MetaVaultNotFound"] = 2020451] = "MetaVaultNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["VaultNotFound"] = 2020452] = "VaultNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["PrivateLoginVaultNotFound"] = 2020456] = "PrivateLoginVaultNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["IncorrectVaultTypeError"] = 2020459] = "IncorrectVaultTypeError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidCommitStructure"] = 2020460] = "InvalidCommitStructure";
  ClientCoreErrorCode2[ClientCoreErrorCode2["VaultContentTooNew"] = 2020461] = "VaultContentTooNew";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidCommitContent"] = 2020462] = "InvalidCommitContent";
  ClientCoreErrorCode2[ClientCoreErrorCode2["MergeConflict"] = 2020463] = "MergeConflict";
  ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedCompression"] = 2020464] = "UnsupportedCompression";
  ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedVaultVersion"] = 2020465] = "UnsupportedVaultVersion";
  ClientCoreErrorCode2[ClientCoreErrorCode2["TeamVaultMissingAssociatedMetaVault"] = 2020470] = "TeamVaultMissingAssociatedMetaVault";
  ClientCoreErrorCode2[ClientCoreErrorCode2["VaultPermissionDenied"] = 2020471] = "VaultPermissionDenied";
  ClientCoreErrorCode2[ClientCoreErrorCode2["UnsupportedLoginVaultType"] = 2020472] = "UnsupportedLoginVaultType";
  ClientCoreErrorCode2[ClientCoreErrorCode2["OrganizationPersonalVaultNotFound"] = 2020473] = "OrganizationPersonalVaultNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["VaultLinkingNotSupported"] = 2020480] = "VaultLinkingNotSupported";
  ClientCoreErrorCode2[ClientCoreErrorCode2["VaultMessageEncryptedDataNotFound"] = 2020490] = "VaultMessageEncryptedDataNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LockAuthenticatorNotFound"] = 2030400] = "LockAuthenticatorNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["UnlockedAuthenticatorNotFound"] = 2030420] = "UnlockedAuthenticatorNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LoginWithRecovery"] = 2030430] = "LoginWithRecovery";
  ClientCoreErrorCode2[ClientCoreErrorCode2["RemoveLocalAuthenticator"] = 2030440] = "RemoveLocalAuthenticator";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LazyWithoutGetter"] = 2030450] = "LazyWithoutGetter";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LazyWithSetter"] = 2030451] = "LazyWithSetter";
  ClientCoreErrorCode2[ClientCoreErrorCode2["WrongAuthenticatorSecret"] = 2030452] = "WrongAuthenticatorSecret";
  ClientCoreErrorCode2[ClientCoreErrorCode2["SecretReuse"] = 2030460] = "SecretReuse";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidRecoveryCode"] = 2030461] = "InvalidRecoveryCode";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidAuthenticatorSeedLength"] = 2030462] = "InvalidAuthenticatorSeedLength";
  ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorSecreMissingId"] = 2030470] = "AuthenticatorSecreMissingId";
  ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorNotFound"] = 2030471] = "AuthenticatorNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockNotInitial"] = 2030480] = "AuthenticatorBlockNotInitial";
  ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockNotChild"] = 2030481] = "AuthenticatorBlockNotChild";
  ClientCoreErrorCode2[ClientCoreErrorCode2["AuthenticatorBlockInvalidSigningKey"] = 2030482] = "AuthenticatorBlockInvalidSigningKey";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NoMatchingSigningKeyFound"] = 2030490] = "NoMatchingSigningKeyFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NoAuthenticatorIdReceived"] = 2030500] = "NoAuthenticatorIdReceived";
  ClientCoreErrorCode2[ClientCoreErrorCode2["UnlockRejected"] = 2040401] = "UnlockRejected";
  ClientCoreErrorCode2[ClientCoreErrorCode2["FailedPushingCommit"] = 2040410] = "FailedPushingCommit";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LoginDataMissing"] = 2050400] = "LoginDataMissing";
  ClientCoreErrorCode2[ClientCoreErrorCode2["OwnSessionMissing"] = 2050401] = "OwnSessionMissing";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ClientCoreIsLocked"] = 2050440] = "ClientCoreIsLocked";
  ClientCoreErrorCode2[ClientCoreErrorCode2["PersistableMismatchError"] = 2050500] = "PersistableMismatchError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LoginNotInitiated"] = 2060400] = "LoginNotInitiated";
  ClientCoreErrorCode2[ClientCoreErrorCode2["PushFlowRunning"] = 2060410] = "PushFlowRunning";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ChannelIdMissing"] = 2060411] = "ChannelIdMissing";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidHashCommitment"] = 2060420] = "InvalidHashCommitment";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LoginCancelled"] = 2060421] = "LoginCancelled";
  ClientCoreErrorCode2[ClientCoreErrorCode2["UnknownAuthenticatorReply"] = 2060430] = "UnknownAuthenticatorReply";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ProtectInternalError"] = 2070500] = "ProtectInternalError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["CantProtect"] = 2070401] = "CantProtect";
  ClientCoreErrorCode2[ClientCoreErrorCode2["CantUnprotect"] = 2070402] = "CantUnprotect";
  ClientCoreErrorCode2[ClientCoreErrorCode2["CantCreateLock"] = 2070403] = "CantCreateLock";
  ClientCoreErrorCode2[ClientCoreErrorCode2["CantDecryptVaultMessage"] = 2070404] = "CantDecryptVaultMessage";
  ClientCoreErrorCode2[ClientCoreErrorCode2["VaultProtectedSecretNotFound"] = 2070405] = "VaultProtectedSecretNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["OrganizationNotFoundError"] = 2080400] = "OrganizationNotFoundError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NoOrganizationMemberError"] = 2080401] = "NoOrganizationMemberError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NoOrganizationAdminError"] = 2080402] = "NoOrganizationAdminError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["AdminVaultNotFoundError"] = 2080403] = "AdminVaultNotFoundError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["LockProfileNotFound"] = 2090400] = "LockProfileNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileKeyGenerationMismatch"] = 2090401] = "ProfileKeyGenerationMismatch";
  ClientCoreErrorCode2[ClientCoreErrorCode2["NoMatchingProfileFound"] = 2090402] = "NoMatchingProfileFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ProfileNotFoundError"] = 2090404] = "ProfileNotFoundError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["PrfNotSupportedError"] = 2100501] = "PrfNotSupportedError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["PrfInitError"] = 2100502] = "PrfInitError";
  ClientCoreErrorCode2[ClientCoreErrorCode2["ShareLinkNotFound"] = 2110400] = "ShareLinkNotFound";
  ClientCoreErrorCode2[ClientCoreErrorCode2["InvalidShareLink"] = 2110401] = "InvalidShareLink";
})(ClientCoreErrorCode || (ClientCoreErrorCode = {}));
const pleaseUpdate$1 = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
class ClientCoreDomainError extends DomainError {
  constructor(code, short, userTitle, userDetail) {
    super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate$1);
  }
}
class NotImplementedError extends ClientCoreDomainError {
  constructor(featureName) {
    super(ClientCoreErrorCode.NotImplemented, `The feature "${featureName}" is not implemented yet`);
  }
}
class ClientCoreInternalError extends ClientCoreDomainError {
  constructor(message) {
    super(ClientCoreErrorCode.Internal, `Internal error: ${message}`);
  }
}
class PersistableMismatchError extends ClientCoreDomainError {
  constructor(persistableUserId, ccpUserId) {
    super(ClientCoreErrorCode.PersistableMismatchError, `Persisted user did not match login parameters! (persistable: ${persistableUserId}, ccp: ${ccpUserId})`);
  }
}
class ParentIdDoesntMatchError extends ClientCoreDomainError {
  constructor(want, got) {
    super(ClientCoreErrorCode.ParentIdDoesntMatch, `Commit parentId doesn't match: expected ${want}, got ${got}`, `Commit parentId doesn't match: expected ${want}, got ${got}`, `The vault data loaded seems to be inconsistent. Try to re-login. ${pleaseUpdate$1}`);
  }
}
class CannotOverrideCommitIdError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.CannotOverrideCommitId, "Cannot override commitId if not in staging state!", "", "");
  }
}
class CannotProtectError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.CantProtect, "Can't protect while locked!", "Can't protect while locked!", `Tried to access a protected value while not logged in. Log in using the app, then try again. ${pleaseUpdate$1}`);
  }
}
class CannotUnprotectError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.CantUnprotect, "Can't unprotect while locked!", "Can't unprotect while locked!", `Tried to access a protected value while not logged in. Log in using the app, then try again. ${pleaseUpdate$1}`);
  }
}
class CannotCreateLockError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.CantCreateLock, "Can't create lock while locked!");
  }
}
class ProtectInternalError extends ClientCoreDomainError {
  constructor(detail) {
    super(ClientCoreErrorCode.ProtectInternalError, detail, detail, `The client produced an internal error while trying to access a protected value. ${pleaseUpdate$1}`);
  }
}
class CannotDecryptVaultMessageError extends ClientCoreDomainError {
  constructor(detail = "Cannot decrypt vault message") {
    super(ClientCoreErrorCode.CantDecryptVaultMessage, detail);
  }
}
class VaultProtectedSecretNotFoundError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.VaultProtectedSecretNotFound, "Vault secret not found", "Vault secret not found", `The client is trying to access protected values of a vault with no present protected secret. ${pleaseUpdate$1}`);
  }
}
class InvalidSessionModificationError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.InvalidSessionModification, "Session modification led to invalid vault content!");
  }
}
class InvalidVaultContentDescriptorNameError extends ClientCoreDomainError {
  constructor(typeName) {
    super(ClientCoreErrorCode.InvalidVaultContentDescriptorName, `Unknown type descriptor ${typeName}`);
  }
}
class LoginNotFoundError extends ClientCoreDomainError {
  constructor(id2) {
    super(ClientCoreErrorCode.LoginNotFound, `No login with id "${id2}"!`);
  }
}
class UserAuthenticatorsMissingForRegenerateError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.UserAuthenticatorsMissingForRegenerate, "Can't regenerate, authenticators are not presents for all users of the vault!");
  }
}
class ProfileMissingForRegenerateError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.ProfileMissingForRegenerate, "Can't regenerate, not all profiles present for the vault!");
  }
}
class LockAuthenticatorNotFoundError extends ClientCoreDomainError {
  constructor(authId, locks) {
    super(ClientCoreErrorCode.LockAuthenticatorNotFound, `Found no matching lock for available authenticator! Locally available authenticator id ${authId}, lock authenticator ids: ${locks.map((l2) => l2.authenticatorId)}`);
  }
}
class LockProfileNotFoundError extends ClientCoreDomainError {
  constructor(profileId) {
    super(ClientCoreErrorCode.LockProfileNotFound, `Got no matching lock for available profiles! Lock profile id: ${profileId}`);
  }
}
class ProfileKeyGenerationMismatchError extends ClientCoreDomainError {
  constructor(profileId, profileGenId, lockGenId) {
    super(ClientCoreErrorCode.ProfileKeyGenerationMismatch, `Mismatched keyGenerationId, profileId: ${profileId}, profile keyGenId: ${profileGenId}, lock keyGenId: ${lockGenId}
        (p) => p.profile.id,
      )}`);
  }
}
class ProfileNotFoundError extends ClientCoreDomainError {
  constructor(profileId) {
    super(ClientCoreErrorCode.ProfileNotFoundError, `Profile ${profileId} unexpectedly not loaded`);
  }
}
class NeedLocksError extends ClientCoreDomainError {
  constructor(vaultId, oldGenId, newGenId) {
    super(ClientCoreErrorCode.NeedLocks, `Unexpectedly didn't receive locks (vault ${vaultId}, local gen ${oldGenId}, new gen ${newGenId})`);
  }
}
class NeedFullHistoryError extends ClientCoreDomainError {
  constructor(vaultId, oldGenId, newGenId) {
    super(ClientCoreErrorCode.NeedFullHistory, `Unexpectedly didn't receive full history (vault ${vaultId}, local gen ${oldGenId}, new gen ${newGenId})`);
  }
}
class UnlockedAuthenticatorNotFoundError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.UnlockedAuthenticatorNotFound, "Provided unlock does not match any known authenticator");
  }
}
class UnlockRejectedError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.UnlockRejected, "Unlock request rejected");
  }
}
class LoginWithRecoveryError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.LoginWithRecovery, "Can't perform a regular login with recovery authenticator!");
  }
}
class LoginDataMissingError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.LoginDataMissing, "Login Data is missing!");
  }
}
class OwnSessionMissingError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.OwnSessionMissing, "Missing our own session. This should never happen, expected DomainError!");
  }
}
class ClientCoreIsLockedError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.ClientCoreIsLocked, "Tried to modify a locked ClientCore");
  }
}
class VaultIsLockedError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.VaultIsLocked, "StagedDiff can't be re-encrypted while vault is locked");
  }
}
class RemoveLocalAuthenticatorError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.RemoveLocalAuthenticator, "Cannot remove local unlocked authenticator!");
  }
}
class LazyWithoutGetterError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.LazyWithoutGetter, "Lazy is only applicable for getters!");
  }
}
class LazyWithSetterError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.LazyWithSetter, "Lazy is only applicable if no setter is specified!");
  }
}
class WrongAuthenticatorSecretError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.WrongAuthenticatorSecret, "Tried to unlock authenticator with wrong authenticator secret!");
  }
}
class SecretReuseError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.SecretReuse, "Can't reuse secret that is already associated with an authenticator");
  }
}
class InvalidAuthenticatorSeedLengthError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.InvalidAuthenticatorSeedLength, "Authenticator seed length must be 32 bytes!");
  }
}
class MetaVaultNotFoundError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.MetaVaultNotFound, "No initialized meta vault!");
  }
}
class VaultNotFoundError extends ClientCoreDomainError {
  constructor(vaultId) {
    super(ClientCoreErrorCode.VaultNotFound, `No Vault with id ${vaultId} in VaultRepo`);
  }
}
class VaultLinkingNotSupportedError extends ClientCoreDomainError {
  constructor(vaultId) {
    super(ClientCoreErrorCode.VaultLinkingNotSupported, `Linking logins not supported for vault ${vaultId}`);
  }
}
class VaultMessageEncryptedDataNotFoundError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.VaultMessageEncryptedDataNotFound, "Encrypted vault message not found");
  }
}
class IncorrectVaultTypeError extends ClientCoreDomainError {
  constructor(vaultId, expected, actual) {
    super(ClientCoreErrorCode.IncorrectVaultTypeError, `Expected vault of type ${expected} for id ${vaultId}, got ${actual} instead.`);
  }
}
class TeamVaultMissingAssociatedMetaVaultError extends ClientCoreDomainError {
  constructor(vaultId) {
    super(ClientCoreErrorCode.TeamVaultMissingAssociatedMetaVault, `Team vault with id ${vaultId} is missing its associated meta vault.`);
  }
}
class VaultPermissionDeniedError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.VaultPermissionDenied, `Account is missing permissions to perform vault operation.`);
  }
}
class UnsupportedLoginVaultTypeError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.UnsupportedLoginVaultType, `Client encountered a login vault with an unsupported type.`);
  }
}
class InvalidCommitStructureError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.InvalidCommitStructure, "Structure of commit to apply is not valid");
  }
}
class VaultContentTooNewError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.VaultContentTooNew, "VaultContent too new, update client!");
  }
}
class InvalidCommitContentError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.InvalidCommitContent, "Content of commit to apply is not valid");
  }
}
class UnsupportedCompressionError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.UnsupportedCompression, "Commit uses unsupported compression algorithm!");
  }
}
class UnsupportedVaultVersionError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.UnsupportedVaultVersion, "Vault version is not supported!");
  }
}
class AuthenticatorNotFoundError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.AuthenticatorNotFound, "Authenticator not found");
  }
}
class AuthenticatorBlockNotInitialError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.AuthenticatorBlockNotInitial, "cannot verify a child AuthenticatorBlock as initial");
  }
}
class AuthenticatorBlockNotChildError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.AuthenticatorBlockNotChild, "cannot verify initial AuthenticatorBlock against a parent");
  }
}
class NoMatchingSigningKeyFoundError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.NoMatchingSigningKeyFound, "No key matching the signature");
  }
}
class NoAuthenticatorIdReceivedError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.NoAuthenticatorIdReceived, "no authenticator id received");
  }
}
class InvalidHashCommitmentError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.InvalidHashCommitment, "Client public key does not match the hash commitment");
  }
}
class LoginCancelledError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.LoginCancelled, "Operation was cancelled!");
  }
}
class OrganizationNotFoundError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.OrganizationNotFoundError, "organization not found", "Organization not found!", `Tried to perform an operation on an unknown organization. ${pleaseUpdate$1}`);
  }
}
class NoOrganizationAdminError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.NoOrganizationAdminError, "no organization admin", "No organization admin!", `Tried to manipulate an organization without admin rights. ${pleaseUpdate$1}`);
  }
}
class PrfNotSupportedError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.PrfNotSupportedError, "prf not supported", "Webauthn PRF extension not supported", `Your browser does not support the required PRF extension to perform this operation.`);
  }
}
class PrfInitError extends ClientCoreDomainError {
  constructor() {
    super(ClientCoreErrorCode.PrfInitError, "prf init error", "PRF initialization failed", `Enabling session pairing for this login device failed.`);
  }
}
class ShareLinkNotFoundError extends ClientCoreDomainError {
  constructor(shareLinkId) {
    super(ClientCoreErrorCode.ShareLinkNotFound, `No ShareLink with id ${shareLinkId} found`);
  }
}
const initialParentHash = hashData(naclUtilExports.decodeUTF8("INITIAL_AUTHENTICATOR_BLOCK"));
const initialParentHashB64 = naclUtilExports.encodeBase64(initialParentHash);
class AuthenticatorBlock {
  constructor(parentHash, keys3, signature) {
    this.parentHash = parentHash;
    this.keys = keys3;
    this.signature = signature;
    this.blob = AuthenticatorBlock.serialize(parentHash, keys3);
    this.hash = hashData(this.blob);
  }
  static serialize(parentHash, keys3) {
    const obj = {
      parent: naclUtilExports.encodeBase64(parentHash !== null && parentHash !== void 0 ? parentHash : initialParentHash),
      keys: keys3.map(naclUtilExports.encodeBase64).sort()
    };
    const serializedObj = canonicalize(obj);
    return naclUtilExports.decodeUTF8(serializedObj);
  }
  static parse(serialized, signature) {
    const jsonString = naclUtilExports.encodeUTF8(serialized);
    const { parent: parentB64, keys: b64keys } = PersistableAuthenticatorBlockContent.parse(JSON.parse(jsonString));
    const parent = parentB64 === initialParentHashB64 ? null : naclUtilExports.decodeBase64(parentB64);
    const keys3 = b64keys.map(loadSigningPublicKey);
    return new AuthenticatorBlock(parent, keys3, signature);
  }
  static signBlock(signingKey, previousHash, keys3) {
    const serialized = AuthenticatorBlock.serialize(previousHash, keys3);
    return hashAndSign(signingKey, serialized);
  }
  verifyInitial(fingerPrint) {
    if (this.parentHash) {
      throw new AuthenticatorBlockNotInitialError();
    }
    const hashValid = hashEqual(this.hash, fingerPrint);
    const signatureValid = this.keys.some((key) => verifyHashSignature(key, this.signature, this.hash));
    return hashValid && signatureValid;
  }
  verify(parentBlock) {
    if (!this.parentHash) {
      throw new AuthenticatorBlockNotChildError();
    }
    const signatureValid = parentBlock.keys.some((key) => verifyHashSignature(key, this.signature, this.hash));
    const parentHashValid = hashEqual(parentBlock.hash, this.parentHash);
    return signatureValid && parentHashValid;
  }
  static verifyChain(fingerPrint, [initialBlock, ...childBlocks]) {
    if (!initialBlock.verifyInitial(fingerPrint)) {
      return false;
    }
    return AuthenticatorBlock.verifyChainPart(initialBlock, childBlocks);
  }
  static verifyChainPart(validBlocks, childBlocks) {
    let parentBlock = validBlocks;
    for (const childBlock of childBlocks) {
      if (!childBlock.verify(parentBlock)) {
        return false;
      }
      parentBlock = childBlock;
    }
    return true;
  }
  containsKey(key) {
    return this.keys.some((tmpKey) => signingPublicKeyEqual(tmpKey, key));
  }
  static create(privateKey, publicKeys, parent) {
    const signature = AuthenticatorBlock.signBlock(privateKey, parent !== null && parent !== void 0 ? parent : null, publicKeys);
    return new AuthenticatorBlock(parent !== null && parent !== void 0 ? parent : null, publicKeys, signature);
  }
  static fromUnsyncedAuthenticators(mainUa, extraUas) {
    const allAuthenticators = [mainUa, ...extraUas];
    const keys3 = allAuthenticators.map((ua2) => ua2.highSecurityIdentitySigPubKey);
    const signature = AuthenticatorBlock.signBlock(mainUa.highSecurityIdentitySigPrivKey, null, keys3);
    return new AuthenticatorBlock(null, keys3, signature);
  }
  static load(parentHash, keys3, signature) {
    return new AuthenticatorBlock(parentHash, keys3, signature);
  }
}
function loadAuthenticator(dto) {
  const { id: id2, authenticatorType, secretInfo, secretSalt, webauthn } = dto;
  const highSecurityLoginSigPubKey = loadSigningPublicKey(dto.highSecurityLoginSigPubKey);
  const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
  const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
  const highSecurityVaultKeyEncPubKeySignature = loadSigningPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
  const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
  const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
  const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
  const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
  return {
    id: id2,
    authenticatorType,
    highSecurityLoginSigPubKey,
    highSecurityIdentitySigPubKey,
    highSecurityVaultKeyEncPubKey,
    highSecurityVaultKeyEncPubKeySignature,
    storableSigPubKey,
    storableSigPubKeySignature,
    storableVaultKeyEncPubKey,
    storableVaultKeyEncPubKeySignature,
    secretInfo,
    secretSalt,
    webauthn
  };
}
function loadForeignAuthenticator(dto) {
  const { id: id2 } = dto;
  const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
  const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
  const highSecurityVaultKeyEncPubKeySignature = loadSigningPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
  const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
  const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
  const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
  const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
  return {
    id: id2,
    highSecurityIdentitySigPubKey,
    highSecurityVaultKeyEncPubKey,
    highSecurityVaultKeyEncPubKeySignature,
    storableSigPubKey,
    storableSigPubKeySignature,
    storableVaultKeyEncPubKey,
    storableVaultKeyEncPubKeySignature
  };
}
function Lazy(_target, _propertyKey, descriptor) {
  if (!descriptor.get) {
    throw new LazyWithoutGetterError();
  }
  if (descriptor.set) {
    throw new LazyWithSetterError();
  }
  const originalGetter = descriptor.get;
  const { enumerable, configurable } = descriptor;
  const cache2 = /* @__PURE__ */ new WeakMap();
  return {
    enumerable,
    configurable,
    get: function get() {
      const cached = cache2.get(this);
      if (cached !== void 0) {
        return cached;
      }
      const originalResult = originalGetter.call(this);
      cache2.set(this, originalResult);
      return originalResult;
    }
  };
}
const SALT_PROFILE_STORABLE_SEED = "salt-profile-storable-seed-";
const SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY = "salt-profile-high-security-identity-signing-key-";
const SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY = "salt-profile-high-security-vault-key-encryption-key-";
const SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY = "salt-profile-high-security-profile-key-encryption-key-";
const SALT_PROFILE_STORABLE_SIGNING_KEY = "salt-profile-storable-signing-key-";
const SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY = "salt-profile-storable-vault-key-encryption-key-";
const SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY = "salt-profile-storable-profile-key-encryption-key-";
const SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-high-security-vault-key-encryption-key-signature-";
const SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-high-security-profile-key-encryption-key-signature-";
const SALT_PROFILE_STORABLE_SIGNING_KEY_SIGNATURE = "salt-profile-storable-signing-key-signature-";
const SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-storable-vault-key-encryption-key-signature-";
const SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE = "salt-profile-storable-profile-key-encryption-key-signature-";
var __decorate$5 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
class UnlockedProfile {
  constructor(profile, storableSeed) {
    this.profile = profile;
    this.storableSeed = storableSeed;
  }
  static fromSeed(profile, storableSeed) {
    return new UnlockedProfile(profile, storableSeed);
  }
  static load(dto, unlockedAuthenticator, unlockedUpstreamProfile) {
    const profile = loadProfile(dto);
    if ("localEncryptedStorableSeed" in dto && dto.localEncryptedStorableSeed) {
      const storableSeed2 = asymDecrypt(unlockedAuthenticator.storableVaultKeyEncPrivKey, dto.localEncryptedStorableSeed);
      return new UnlockedProfile(profile, storableSeed2);
    }
    if (unlockedUpstreamProfile && profile.profileLock) {
      const storableSeed2 = asymDecrypt(unlockedUpstreamProfile.storableProfileSeedEncPrivKey, profile.profileLock.encryptedStorableProfileSeed);
      return new UnlockedProfile(profile, storableSeed2);
    }
    const candidateLock = profile.authenticatorLocks.find((lock) => lock.authenticatorId === unlockedAuthenticator.authenticator.id);
    if (!candidateLock) {
      throw new LockAuthenticatorNotFoundError(unlockedAuthenticator.authenticator.id, profile.authenticatorLocks);
    }
    const storableSeed = asymDecrypt(unlockedAuthenticator.storableVaultKeyEncPrivKey, candidateLock.encryptedStorableProfileSeed);
    return new UnlockedProfile(profile, storableSeed);
  }
  getPersistable(ua2) {
    if (ua2) {
      const localEncryptedStorableSeed = asymEncrypt(ua2.authenticator.storableVaultKeyEncPubKey, this.storableSeed);
      return Object.assign(Object.assign({}, this.profile), { localEncryptedStorableSeed });
    }
    return this.profile;
  }
  get storableSigPrivKey() {
    return deriveSigningKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_SIGNING_KEY).sigPrivKey;
  }
  get storableVaultKeyEncPrivKey() {
    return deriveEncryptionKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
  }
  get storableProfileSeedEncPrivKey() {
    return deriveEncryptionKeyPair(this.storableSeed, null, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY).encPrivKey;
  }
}
__decorate$5([
  Lazy
], UnlockedProfile.prototype, "storableSigPrivKey", null);
__decorate$5([
  Lazy
], UnlockedProfile.prototype, "storableVaultKeyEncPrivKey", null);
__decorate$5([
  Lazy
], UnlockedProfile.prototype, "storableProfileSeedEncPrivKey", null);
function requireOrgAdminProfile(up2) {
  if (up2.profile.profileType !== ProfileType.ORGANIZATION_ADMIN) {
    throw new Error(`required org admin profile (${ProfileType.ORGANIZATION_ADMIN}), got ${up2.profile.profileType}`);
  }
  if (!up2.profile.organizationId) {
    throw new Error("required organizationId in org admin profile, got null");
  }
  return up2;
}
class UnlockedAuthenticator {
  constructor(authenticator, storableSigPrivKey, storableVaultKeyEncPrivKey) {
    this.authenticator = authenticator;
    this.storableSigPrivKey = storableSigPrivKey;
    this.storableVaultKeyEncPrivKey = storableVaultKeyEncPrivKey;
  }
}
var __decorate$4 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
class HighSecurityUnlockedAuthenticator {
  constructor(authenticator, secret) {
    this.authenticator = authenticator;
    this.secret = secret;
  }
  static fromAuthenticatorSecret(a2, secret) {
    if (a2.id !== secret.authenticatorId) {
      throw new WrongAuthenticatorSecretError();
    }
    return new HighSecurityUnlockedAuthenticator(a2, secret);
  }
  createEncryptedSecret(encPubKey) {
    return asymEncrypt(encPubKey, this.secret.seed);
  }
  get highSecurityLoginSigPrivKey() {
    const { sigPrivKey: loginSigPrivKey } = deriveSigningKeyPair(this.secret.seed, null, SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY);
    return loginSigPrivKey;
  }
  get highSecurityIdentitySigPrivKey() {
    return deriveSigningKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
  }
  get highSecurityVaultKeyEncPrivKey() {
    return deriveEncryptionKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
  }
  get storableSigPrivKey() {
    return deriveSigningKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY).sigPrivKey;
  }
  get storableVaultKeyEncPrivKey() {
    return deriveEncryptionKeyPair(this.secret.seed, this.authenticator.secretSalt, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
  }
  getUnlockedAuthenticator() {
    return new UnlockedAuthenticator(this.authenticator, this.storableSigPrivKey, this.storableVaultKeyEncPrivKey);
  }
}
__decorate$4([
  Lazy
], HighSecurityUnlockedAuthenticator.prototype, "highSecurityLoginSigPrivKey", null);
__decorate$4([
  Lazy
], HighSecurityUnlockedAuthenticator.prototype, "highSecurityIdentitySigPrivKey", null);
__decorate$4([
  Lazy
], HighSecurityUnlockedAuthenticator.prototype, "highSecurityVaultKeyEncPrivKey", null);
__decorate$4([
  Lazy
], HighSecurityUnlockedAuthenticator.prototype, "storableSigPrivKey", null);
__decorate$4([
  Lazy
], HighSecurityUnlockedAuthenticator.prototype, "storableVaultKeyEncPrivKey", null);
class UnsyncedAuthenticator {
  constructor(authenticatorType, highSecurityLoginSigPubKey, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, secretInfo, secretSalt, webauthnCreationData, secret) {
    this.authenticatorType = authenticatorType;
    this.highSecurityLoginSigPubKey = highSecurityLoginSigPubKey;
    this.highSecurityIdentitySigPubKey = highSecurityIdentitySigPubKey;
    this.highSecurityIdentitySigPrivKey = highSecurityIdentitySigPrivKey;
    this.highSecurityVaultKeyEncPubKey = highSecurityVaultKeyEncPubKey;
    this.highSecurityVaultKeyEncPubKeySignature = highSecurityVaultKeyEncPubKeySignature;
    this.storableSigPubKey = storableSigPubKey;
    this.storableSigPubKeySignature = storableSigPubKeySignature;
    this.storableVaultKeyEncPubKey = storableVaultKeyEncPubKey;
    this.storableVaultKeyEncPubKeySignature = storableVaultKeyEncPubKeySignature;
    this.secretInfo = secretInfo;
    this.secretSalt = secretSalt;
    this.webauthnCreationData = webauthnCreationData;
    this.secret = secret;
  }
  static create(authenticatorType, secretInfo, secret) {
    const secretSalt = randomSeed();
    return this.createWithSalt(authenticatorType, secretInfo, secret, secretSalt);
  }
  static createWebauthn(secret, webauthnData) {
    const secretSalt = randomSeed();
    return this.createWithSalt(AuthenticatorType.WEBAUTHN, "", secret, secretSalt, webauthnData);
  }
  static createWithSalt(authenticatorType, secretInfo, secret, secretSalt, webauthnData) {
    if (secret.authenticatorId != null) {
      throw new SecretReuseError();
    }
    const { sigPubKey: highSecurityLoginSigPubKey } = deriveSigningKeyPair(secret.seed, null, SALT_AUTHENTICATOR_HIGH_SECURITY_LOGIN_SIGNING_KEY);
    const { sigPubKey: storableSigPubKey } = deriveSigningKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY);
    const { encPubKey: storableVaultKeyEncPubKey } = deriveEncryptionKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY);
    const { sigPubKey: highSecurityIdentitySigPubKey, sigPrivKey: highSecurityIdentitySigPrivKey } = deriveSigningKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_IDENTITY_SIGNING_KEY);
    const { encPubKey: highSecurityVaultKeyEncPubKey } = deriveEncryptionKeyPair(secret.seed, secretSalt, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY);
    const highSecurityVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, SALT_AUTHENTICATOR_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
    const storableVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableVaultKeyEncPubKey, SALT_AUTHENTICATOR_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
    const storableSigPubKeySignature = signSigningPublicKey(highSecurityIdentitySigPrivKey, storableSigPubKey, SALT_AUTHENTICATOR_STORABLE_SIGNING_KEY_SIGNATURE);
    return new UnsyncedAuthenticator(authenticatorType, highSecurityLoginSigPubKey, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, secretInfo, secretSalt, webauthnData, secret);
  }
  serializeForCreation(profileRepo, hsc) {
    const data = Object.assign(Object.assign({}, this), { id: nullUuid });
    const profileLocks = profileRepo.profiles.map((p2) => {
      const hsup = hsc.getHighSecurityUnlockedProfile(p2, profileRepo);
      if (!hsup) {
        throw new ClientCoreInternalError("Failed to unlock one of our profiles, can't regenerate!");
      }
      return hsup.createAuthenticatorLock(data);
    });
    if (profileRepo.disabledProfiles.length) {
      const hsua = hsc.getHighSecurityUnlockedAuthenticator();
      const ua2 = hsua.getUnlockedAuthenticator();
      profileRepo.disabledProfiles.forEach((p2) => {
        const up2 = UnlockedProfile.load(p2, ua2);
        const hsup = hsc.getHighSecurityUnlockedProfile(up2, profileRepo);
        const profileLock = hsup.createAuthenticatorLock(this);
        profileLocks.push(profileLock);
      });
    }
    return { data, profileLocks, webauthn: this.webauthnCreationData };
  }
  serializeForRegistration() {
    return this.serializeWithLocks([]);
  }
  serializeWithLocks(profileLocks) {
    const data = Object.assign(Object.assign({}, this), { id: nullUuid });
    return { data, profileLocks, webauthn: this.webauthnCreationData };
  }
  withId(id2) {
    const auth = {
      id: id2,
      authenticatorType: this.authenticatorType,
      highSecurityLoginSigPubKey: this.highSecurityLoginSigPubKey,
      highSecurityIdentitySigPubKey: this.highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey: this.highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature: this.highSecurityVaultKeyEncPubKeySignature,
      storableSigPubKey: this.storableSigPubKey,
      storableSigPubKeySignature: this.storableSigPubKeySignature,
      storableVaultKeyEncPubKey: this.storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature: this.storableVaultKeyEncPubKeySignature,
      secretInfo: this.secretInfo,
      secretSalt: this.secretSalt,
      webauthn: this.webauthnCreationData
    };
    const secret = Object.assign(Object.assign({}, this.secret), { authenticatorId: id2 });
    return HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(auth, secret);
  }
}
class ProfileAuthenticatorLock {
  constructor(authenticatorId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed) {
    this.authenticatorId = authenticatorId;
    this.encryptedHighSecurityProfileSeed = encryptedHighSecurityProfileSeed;
    this.encryptedStorableProfileSeed = encryptedStorableProfileSeed;
  }
  static create(authenticator, highSecuritySeed, storableSeed) {
    const authenticatorId = authenticator instanceof UnsyncedAuthenticator ? nullUuid : authenticator.id;
    const encryptedHighSecurityProfileSeed = asymEncrypt(authenticator.highSecurityVaultKeyEncPubKey, highSecuritySeed);
    const encryptedStorableProfileSeed = asymEncrypt(authenticator.storableVaultKeyEncPubKey, storableSeed);
    return new ProfileAuthenticatorLock(authenticatorId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed);
  }
  static load({ authenticatorId, encryptedHighSecurityProfileSeed: encryptedHighSecurityProfileKeyData, encryptedStorableProfileSeed: encryptedStorableProfileKeyData }) {
    const encryptedHighSecurityProfileKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityProfileKeyData);
    const encryptedStorableProfileKey = loadAsymEncryptedSymmetricKey(encryptedStorableProfileKeyData);
    return new ProfileAuthenticatorLock(authenticatorId, encryptedHighSecurityProfileKey, encryptedStorableProfileKey);
  }
}
class UnsyncedProfile {
  constructor(profileType, organizationId, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, highSecurityProfileSeedEncPubKey, highSecurityProfileSeedEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, storableProfileSeedEncPubKey, storableProfileSeedEncPubKeySignature, authenticatorLocks, upstreamProfileLocks, highSecuritySeed, storableSeed) {
    this.profileType = profileType;
    this.organizationId = organizationId;
    this.highSecurityIdentitySigPubKey = highSecurityIdentitySigPubKey;
    this.highSecurityIdentitySigPrivKey = highSecurityIdentitySigPrivKey;
    this.highSecurityVaultKeyEncPubKey = highSecurityVaultKeyEncPubKey;
    this.highSecurityVaultKeyEncPubKeySignature = highSecurityVaultKeyEncPubKeySignature;
    this.highSecurityProfileSeedEncPubKey = highSecurityProfileSeedEncPubKey;
    this.highSecurityProfileSeedEncPubKeySignature = highSecurityProfileSeedEncPubKeySignature;
    this.storableSigPubKey = storableSigPubKey;
    this.storableSigPubKeySignature = storableSigPubKeySignature;
    this.storableVaultKeyEncPubKey = storableVaultKeyEncPubKey;
    this.storableVaultKeyEncPubKeySignature = storableVaultKeyEncPubKeySignature;
    this.storableProfileSeedEncPubKey = storableProfileSeedEncPubKey;
    this.storableProfileSeedEncPubKeySignature = storableProfileSeedEncPubKeySignature;
    this.authenticatorLocks = authenticatorLocks;
    this.upstreamProfileLocks = upstreamProfileLocks;
    this.highSecuritySeed = highSecuritySeed;
    this.storableSeed = storableSeed;
  }
  static getStorableSeedFromHighSecuritySeed(highSecuritySeed) {
    return deriveSecretFromSeed(highSecuritySeed, null, SALT_PROFILE_STORABLE_SEED);
  }
  static getHighSecurityIdentitySigPrivKey(highSecuritySeed) {
    return deriveSigningKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
  }
  static create(profileType, organizationId, authenticators) {
    return UnsyncedProfile.createWithSeed(profileType, organizationId, authenticators, []).unsyncedProfile;
  }
  static createWithSeed(profileType, organizationId, lockingAuthenticators, lockingProfiles) {
    if (profileType === ProfileType.ORGANIZATION_ADMIN && lockingProfiles.length === 0) {
      throw new Error("org admin profile must have lockingProfiles");
    }
    if (profileType === ProfileType.ORGANIZATION_ADMIN && lockingAuthenticators.length !== 0) {
      throw new Error("org admin profile must not have lockingAuthenticators");
    }
    const highSecuritySeed = randomSeed();
    const storableSeed = UnsyncedProfile.getStorableSeedFromHighSecuritySeed(highSecuritySeed);
    const { sigPubKey: storableSigPubKey } = deriveSigningKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_SIGNING_KEY);
    const { encPubKey: storableVaultKeyEncPubKey } = deriveEncryptionKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY);
    const { encPubKey: storableProfileSeedEncPubKey } = deriveEncryptionKeyPair(storableSeed, null, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY);
    const { sigPubKey: highSecurityIdentitySigPubKey, sigPrivKey: highSecurityIdentitySigPrivKey } = deriveSigningKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY);
    const { encPubKey: highSecurityVaultKeyEncPubKey } = deriveEncryptionKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY);
    const { encPubKey: highSecurityProfileSeedEncPubKey } = deriveEncryptionKeyPair(highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY);
    const highSecurityVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
    const highSecurityProfileSeedEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, highSecurityProfileSeedEncPubKey, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE);
    const storableVaultKeyEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableVaultKeyEncPubKey, SALT_PROFILE_STORABLE_VAULT_KEY_ENCRYPTION_KEY_SIGNATURE);
    const storableProfileSeedEncPubKeySignature = signEncryptionPublicKey(highSecurityIdentitySigPrivKey, storableProfileSeedEncPubKey, SALT_PROFILE_STORABLE_PROFILE_KEY_ENCRYPTION_KEY_SIGNATURE);
    const storableSigPubKeySignature = signSigningPublicKey(highSecurityIdentitySigPrivKey, storableSigPubKey, SALT_PROFILE_STORABLE_SIGNING_KEY_SIGNATURE);
    const authenticatorLocks = lockingAuthenticators.map((a2) => ProfileAuthenticatorLock.create(a2, highSecuritySeed, storableSeed));
    const profileLocks = lockingProfiles.map((p2) => ProfileProfileLock.create(p2, highSecuritySeed, storableSeed));
    const unsyncedProfile = new UnsyncedProfile(profileType, organizationId, highSecurityIdentitySigPubKey, highSecurityIdentitySigPrivKey, highSecurityVaultKeyEncPubKey, highSecurityVaultKeyEncPubKeySignature, highSecurityProfileSeedEncPubKey, highSecurityProfileSeedEncPubKeySignature, storableSigPubKey, storableSigPubKeySignature, storableVaultKeyEncPubKey, storableVaultKeyEncPubKeySignature, storableProfileSeedEncPubKey, storableProfileSeedEncPubKeySignature, authenticatorLocks, profileLocks, highSecuritySeed, storableSeed);
    return { unsyncedProfile, highSecuritySeed, storableSeed };
  }
  intoUnlockedProfile(id2, keyGenerationId, email) {
    const profile = {
      id: id2,
      keyGenerationId,
      email,
      unverifiedEmail: null,
      profileType: this.profileType,
      organizationId: this.organizationId,
      highSecurityIdentitySigPubKey: this.highSecurityIdentitySigPubKey,
      highSecurityVaultKeyEncPubKey: this.highSecurityVaultKeyEncPubKey,
      highSecurityVaultKeyEncPubKeySignature: this.highSecurityVaultKeyEncPubKeySignature,
      highSecurityProfileSeedEncPubKey: this.highSecurityProfileSeedEncPubKey,
      highSecurityProfileSeedEncPubKeySignature: this.highSecurityProfileSeedEncPubKeySignature,
      storableSigPubKey: this.storableSigPubKey,
      storableSigPubKeySignature: this.storableSigPubKeySignature,
      storableVaultKeyEncPubKey: this.storableVaultKeyEncPubKey,
      storableVaultKeyEncPubKeySignature: this.storableVaultKeyEncPubKeySignature,
      storableProfileSeedEncPubKey: this.storableProfileSeedEncPubKey,
      storableProfileSeedEncPubKeySignature: this.storableProfileSeedEncPubKeySignature,
      authenticatorLocks: this.authenticatorLocks,
      profileLock: null
    };
    return new UnlockedProfile(profile, this.storableSeed);
  }
  createExtraLock(unsyncedAuthenticator) {
    return ProfileAuthenticatorLock.create(unsyncedAuthenticator, this.highSecuritySeed, this.storableSeed);
  }
  serialize(id2 = nullUuid, keyGenerationId = nullUuid) {
    return Object.assign(Object.assign({}, this), { id: id2, keyGenerationId });
  }
}
class ProfileProfileLock {
  constructor(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed) {
    this.lockingProfileId = lockingProfileId;
    this.lockingProfileKeyGenerationId = lockingProfileKeyGenerationId;
    this.encryptedHighSecurityProfileSeed = encryptedHighSecurityProfileSeed;
    this.encryptedStorableProfileSeed = encryptedStorableProfileSeed;
  }
  static create(lockingProfile, highSecuritySeed, storableSeed) {
    const lockingProfileId = lockingProfile instanceof UnsyncedProfile ? nullUuid : lockingProfile.id;
    const lockingProfileKeyGenerationId = lockingProfile instanceof UnsyncedProfile ? nullUuid : lockingProfile.keyGenerationId;
    const encryptedHighSecurityProfileSeed = asymEncrypt(lockingProfile.highSecurityProfileSeedEncPubKey, highSecuritySeed);
    const encryptedStorableProfileSeed = asymEncrypt(lockingProfile.storableProfileSeedEncPubKey, storableSeed);
    return new ProfileProfileLock(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed, encryptedStorableProfileSeed);
  }
  static load({ lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileSeed: encryptedHighSecurityProfileKeyData, encryptedStorableProfileSeed: encryptedStorableProfileKeyData }) {
    const encryptedHighSecurityProfileKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityProfileKeyData);
    const encryptedStorableProfileKey = loadAsymEncryptedSymmetricKey(encryptedStorableProfileKeyData);
    return new ProfileProfileLock(lockingProfileId, lockingProfileKeyGenerationId, encryptedHighSecurityProfileKey, encryptedStorableProfileKey);
  }
}
function loadProfile(dto) {
  const { id: id2, profileType, keyGenerationId, organizationId, email, unverifiedEmail } = dto;
  const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
  const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
  const highSecurityVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
  const highSecurityProfileSeedEncPubKey = loadEncryptionPublicKey(dto.highSecurityProfileSeedEncPubKey);
  const highSecurityProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityProfileSeedEncPubKeySignature);
  const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
  const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
  const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
  const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
  const storableProfileSeedEncPubKey = loadEncryptionPublicKey(dto.storableProfileSeedEncPubKey);
  const storableProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableProfileSeedEncPubKeySignature);
  const authenticatorLocks = dto.authenticatorLocks.map(ProfileAuthenticatorLock.load);
  const profileLock = dto.profileLock ? ProfileProfileLock.load(dto.profileLock) : null;
  return {
    id: id2,
    profileType,
    keyGenerationId,
    email,
    unverifiedEmail,
    organizationId,
    highSecurityIdentitySigPubKey,
    highSecurityVaultKeyEncPubKey,
    highSecurityVaultKeyEncPubKeySignature,
    highSecurityProfileSeedEncPubKey,
    highSecurityProfileSeedEncPubKeySignature,
    storableSigPubKey,
    storableSigPubKeySignature,
    storableVaultKeyEncPubKey,
    storableVaultKeyEncPubKeySignature,
    storableProfileSeedEncPubKey,
    storableProfileSeedEncPubKeySignature,
    authenticatorLocks,
    profileLock
  };
}
class AccountState {
  constructor(state) {
    this.userId = state.userId;
    this.preferredLocale = state.preferredLocale;
    this.emails = state.emails;
    this.preliminaryEmail = state.preliminaryEmail;
    this.serverSideSettings = state.serverSideSettings;
    this.userClientSettings = state.userClientSettings;
    this.authenticators = state.authenticators;
    this.sessions = state.sessions;
    this.channels = state.channels;
    this.achievements = state.achievements;
    this.localAchievements = state.localAchievements;
    this.authenticatorBlockHash = state.authenticatorBlockHash;
    this.organizations = state.organizations;
    this.relatedProfiles = state.relatedProfiles;
    this.preliminaryProfiles = state.preliminaryProfiles;
    this.webauthnCredentials = state.webauthnCredentials;
    this.openUserConfirmationIds = state.openUserConfirmationIds;
  }
  static fromSyncUpdate(userId, update4) {
    return new AccountState({
      userId,
      preferredLocale: null,
      emails: [],
      preliminaryEmail: null,
      serverSideSettings: {},
      userClientSettings: {},
      authenticators: [],
      sessions: [],
      channels: [],
      achievements: /* @__PURE__ */ new Set(),
      localAchievements: /* @__PURE__ */ new Set(),
      authenticatorBlockHash: null,
      organizations: [],
      relatedProfiles: {},
      preliminaryProfiles: [],
      webauthnCredentials: [],
      openUserConfirmationIds: []
    }).withSyncUpdate(update4);
  }
  static fromPersistable(persistable) {
    var _a2, _b, _c2, _d, _e, _f;
    const authenticators = persistable.authenticators.map((a2) => loadAuthenticator(a2));
    const achievements = persistable.achievements ? new Set(persistable.achievements) : /* @__PURE__ */ new Set();
    const localAchievements = persistable.localAchievements ? new Set(persistable.localAchievements) : /* @__PURE__ */ new Set();
    const serverSideSettings = (_a2 = persistable.serverSideSettings) !== null && _a2 !== void 0 ? _a2 : {};
    const userClientSettings = (_b = persistable.userClientSettings) !== null && _b !== void 0 ? _b : {};
    const organizations = (_c2 = persistable.organizations) !== null && _c2 !== void 0 ? _c2 : [];
    const relatedProfiles = (_d = persistable.relatedProfiles) !== null && _d !== void 0 ? _d : {};
    const preliminaryEmail = null;
    const preliminaryProfiles = [];
    let emails;
    if (persistable.emails) {
      emails = persistable.emails;
    } else {
      emails = [];
      if (persistable.email) {
        emails.push({
          email: persistable.email,
          verificationPending: false,
          primary: true
        });
      }
      if (persistable.unverifiedEmail) {
        emails.push({
          email: persistable.unverifiedEmail,
          verificationPending: true,
          primary: false
        });
      }
    }
    for (const s2 of persistable.sessions) {
      if (s2.enabledProfileIds.length === 0 && !s2.clientSettings.enableAllProfiles) {
        s2.enabledProfileIds = Object.entries(s2.clientSettings.profileSettings).flatMap(([k2, v2]) => {
          return v2.enabled ? k2 : [];
        });
      }
    }
    return new AccountState({
      userId: persistable.userId,
      preferredLocale: (_e = persistable.preferredLocale) !== null && _e !== void 0 ? _e : null,
      emails,
      preliminaryEmail,
      serverSideSettings,
      userClientSettings,
      authenticators,
      sessions: persistable.sessions,
      channels: [],
      achievements,
      localAchievements,
      authenticatorBlockHash: (_f = persistable.authenticatorBlockHash) !== null && _f !== void 0 ? _f : null,
      organizations,
      relatedProfiles,
      preliminaryProfiles,
      webauthnCredentials: persistable.webauthnCredentials,
      openUserConfirmationIds: []
    });
  }
  getPersistable() {
    var _a2;
    const sessions = this.sessions.map((s2) => Object.assign(Object.assign({}, s2), { unlockRequestedAt: void 0 }));
    return {
      userId: this.userId,
      preferredLocale: this.preferredLocale,
      serverSideSettings: this.serverSideSettings,
      userClientSettings: this.userClientSettings,
      authenticators: this.authenticators,
      sessions,
      achievements: [...this.achievements],
      localAchievements: [...this.localAchievements],
      authenticatorBlockHash: (_a2 = this.authenticatorBlockHash) !== null && _a2 !== void 0 ? _a2 : void 0,
      organizations: this.organizations,
      relatedProfiles: this.relatedProfiles,
      webauthnCredentials: this.webauthnCredentials,
      emails: [...this.emails]
    };
  }
  hasLocalAchievements() {
    return this.localAchievements.size > 0;
  }
  getLocalAchievements() {
    return [...this.localAchievements];
  }
  hasAchievement(a2) {
    return this.achievements.has(a2) || this.localAchievements.has(a2);
  }
  withLocalAchievements(achievements) {
    const localAchievements = new Set(this.localAchievements);
    for (const a2 of achievements) {
      if (!this.achievements.has(a2)) {
        localAchievements.add(a2);
      }
    }
    return new AccountState(Object.assign(Object.assign({}, this), { localAchievements }));
  }
  getProfileEmail(profileId) {
    var _a2, _b;
    return (_b = (_a2 = this.relatedProfiles[profileId]) === null || _a2 === void 0 ? void 0 : _a2.email) !== null && _b !== void 0 ? _b : null;
  }
  getPrimaryEmail() {
    var _a2, _b, _c2, _d;
    return (_d = (_b = (_a2 = this.emails.find((e2) => e2.primary)) === null || _a2 === void 0 ? void 0 : _a2.email) !== null && _b !== void 0 ? _b : (_c2 = this.emails[0]) === null || _c2 === void 0 ? void 0 : _c2.email) !== null && _d !== void 0 ? _d : null;
  }
  getUnverifiedEmail() {
    var _a2, _b;
    return (_b = (_a2 = this.emails.find((e2) => e2.verificationPending)) === null || _a2 === void 0 ? void 0 : _a2.email) !== null && _b !== void 0 ? _b : null;
  }
  getOrganization(orgId) {
    return this.organizations.find((o2) => o2.id === orgId);
  }
  isWebauthnPossibleForSession(sessionId) {
    return this.webauthnCredentials.some((c2) => !c2.sessionId || c2.sessionId === sessionId) || this.authenticators.some((auth) => isActiveWebauthnAuthenticator(auth) && this.webauthnCredentials.some((wc2) => wc2.webauthnId === auth.webauthn.webauthnId));
  }
  hasPushAuthenticator() {
    return this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.PUSH);
  }
  getPrimaryLoginDevice() {
    if (this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.PUSH || a2.authenticatorType === AuthenticatorType.DUMMY)) {
      return PrimaryLoginDevice.PHONE;
    }
    if (this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.SESSION_UNLOCK)) {
      return PrimaryLoginDevice.SECURITY_KEY;
    }
    if (this.authenticators.some((a2) => a2.authenticatorType === AuthenticatorType.ORGANIZATION_SERVICE)) {
      return PrimaryLoginDevice.SERVICE;
    }
    return PrimaryLoginDevice.NONE;
  }
  withSyncUpdate(update4) {
    let { sessions, channels, achievements, localAchievements, emails, preliminaryEmail, preferredLocale, serverSideSettings, userClientSettings, organizations, relatedProfiles, preliminaryProfiles, webauthnCredentials, openUserConfirmationIds } = this;
    if (update4.user !== void 0) {
      emails = update4.user.emails;
      preliminaryEmail = update4.user.preliminaryEmail;
      preferredLocale = update4.user.preferredLocale;
      serverSideSettings = parseFromJsonIgnoringError(ServerSideSettings, update4.user.serverSideSettings, {});
      userClientSettings = parseFromJsonIgnoringError(UserClientSettings, update4.user.userClientSettings, {});
      webauthnCredentials = update4.user.webauthnCredentials;
      openUserConfirmationIds = update4.user.openUserConfirmationIds;
    }
    if (update4.sessions !== void 0) {
      sessions = update4.sessions.map((sus) => {
        const clientSettings = parseFromJsonIgnoringError(SessionClientSettings, sus.clientSettings, {
          enableAllProfiles: true,
          profileSettings: {}
        });
        return Object.assign(Object.assign({}, sus), { clientSettings });
      });
    }
    if (update4.channels !== void 0) {
      channels = update4.channels;
    }
    if (update4.achievementIds !== void 0) {
      achievements = new Set(update4.achievementIds);
      localAchievements = new Set(localAchievements);
      for (const a2 of localAchievements) {
        if (achievements.has(a2)) {
          localAchievements.delete(a2);
        }
      }
    }
    if (update4.organizations !== void 0) {
      organizations = update4.organizations.flatMap((o2) => {
        var _a2;
        try {
          const persistableOrganization = Object.assign(Object.assign({}, o2), { adminInfo: o2.adminInfo ? Object.assign(Object.assign({}, o2.adminInfo), { authenticator: o2.adminInfo.authenticator ? loadAuthenticator(o2.adminInfo.authenticator) : o2.adminInfo.authenticator, adminProfile: o2.adminInfo.adminProfile ? loadProfile(o2.adminInfo.adminProfile) : o2.adminInfo.adminProfile, legacyAdminVaultId: (_a2 = o2.adminInfo.legacyAdminVaultId) !== null && _a2 !== void 0 ? _a2 : null }) : o2.adminInfo, clientSettings: parseFromJsonIgnoringError(OrganizationClientSettings, o2.clientSettings, null), parentOrganizationInfo: o2.parentOrganizationInfo ? Object.assign(Object.assign({}, o2.parentOrganizationInfo), { metadata: parseFromJsonIgnoringError(ParentOrganizationMetadata, o2.parentOrganizationInfo.metadata, void 0) }) : void 0, passwordPolicy: parseFromJsonIgnoringError(PasswordPolicy, o2.passwordPolicy, void 0) });
          return PersistableOrganization.parse(persistableOrganization);
        } catch (e2) {
          trackError(e2);
          return [];
        }
      });
    }
    if (update4.relatedProfiles !== void 0) {
      relatedProfiles = {};
      for (const p2 of update4.relatedProfiles) {
        relatedProfiles[p2.id] = p2;
      }
    }
    if (update4.preliminaryProfiles !== void 0) {
      preliminaryProfiles = update4.preliminaryProfiles;
    }
    return new AccountState(Object.assign(Object.assign({}, this), {
      preferredLocale,
      emails,
      preliminaryEmail,
      serverSideSettings,
      userClientSettings,
      sessions,
      channels,
      achievements,
      localAchievements,
      organizations,
      relatedProfiles,
      preliminaryProfiles,
      webauthnCredentials,
      openUserConfirmationIds
    }));
  }
  withAuthenticatorList(list) {
    const authenticators = list.authenticators.map(loadAuthenticator);
    if (!authenticators.every((a2) => verifyAuthenticator(a2))) {
      trackError(new Error(`an authenticator key had no proper signature`));
    }
    const blocks = list.blocks.map((ab2) => AuthenticatorBlock.parse(ab2.blob, ab2.signature));
    if (!blocks.length) {
      if (this.authenticatorBlockHash) {
        trackError(new Error("missing authenticator block"));
      }
      return new AccountState(Object.assign(Object.assign({}, this), { authenticators, authenticatorBlockHash: null }));
    }
    const latestBlock = blocks[blocks.length - 1];
    try {
      if (this.authenticatorBlockHash) {
        const [knownBlock, ...newBlocks] = blocks;
        if (!hashEqual(knownBlock.hash, this.authenticatorBlockHash)) {
          throw new Error("first authenticator block hash does not match");
        }
        if (!AuthenticatorBlock.verifyChainPart(knownBlock, newBlocks)) {
          throw new Error("invalid authenticator block detected");
        }
      } else if (!AuthenticatorBlock.verifyChain(blocks[0].hash, blocks)) {
        throw new Error("invalid init authenticator block detected");
      }
      if (authenticators.some((a2) => latestBlock.keys.every((k2) => !signingPublicKeyEqual(k2, a2.highSecurityIdentitySigPubKey)))) {
        throw new Error("authenticator is not in the authenticator block");
      }
    } catch (e2) {
      trackError(e2);
    }
    return new AccountState(Object.assign(Object.assign({}, this), { authenticators, authenticatorBlockHash: latestBlock.hash }));
  }
}
function parseFromJsonIgnoringError(type, inputJson, fallback) {
  if (inputJson === void 0 || inputJson === null) {
    return fallback;
  }
  try {
    const input = jsonParseThaw(inputJson);
    const parsed = type.safeParse(input);
    if (parsed.success) {
      return parsed.data;
    }
  } catch (e2) {
    trackError(e2);
    return fallback;
  }
}
var __awaiter$Q = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Semaphore {
  constructor(_value) {
    this._value = _value;
    this._queue = [];
    if (_value <= 0) {
      throw new Error("semaphore must be initialized to a positive value");
    }
  }
  acquire() {
    const locked = this.isLocked();
    const ticket = new Promise((r2) => this._queue.push(r2));
    if (!locked)
      this._dispatch();
    return ticket;
  }
  runExclusive(callback) {
    return __awaiter$Q(this, void 0, void 0, function* () {
      const [value, release] = yield this.acquire();
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  release() {
    if (this._currentReleaser) {
      this._currentReleaser();
      this._currentReleaser = void 0;
    }
  }
  _dispatch() {
    const nextConsumer = this._queue.shift();
    if (!nextConsumer)
      return;
    let released = false;
    this._currentReleaser = () => {
      if (released)
        return;
      released = true;
      this._value++;
      this._dispatch();
    };
    nextConsumer([this._value--, this._currentReleaser]);
  }
}
var __awaiter$1$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Mutex {
  constructor() {
    this._semaphore = new Semaphore(1);
  }
  acquire() {
    return __awaiter$1$1(this, void 0, void 0, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  release() {
    this._semaphore.release();
  }
}
var hasToStringTag$4 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var toStr$3 = Object.prototype.toString;
var isStandardArguments = function isArguments2(value) {
  if (hasToStringTag$4 && value && typeof value === "object" && Symbol.toStringTag in value) {
    return false;
  }
  return toStr$3.call(value) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value) {
  if (isStandardArguments(value)) {
    return true;
  }
  return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr$3.call(value) !== "[object Array]" && toStr$3.call(value.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$4 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var numberIsNaN = function(value) {
  return value !== value;
};
var implementation$8 = function is(a2, b2) {
  if (a2 === 0 && b2 === 0) {
    return 1 / a2 === 1 / b2;
  }
  if (a2 === b2) {
    return true;
  }
  if (numberIsNaN(a2) && numberIsNaN(b2)) {
    return true;
  }
  return false;
};
var implementation$7 = implementation$8;
var polyfill$4 = function getPolyfill2() {
  return typeof Object.is === "function" ? Object.is : implementation$7;
};
var getPolyfill$5 = polyfill$4;
var define$3 = defineProperties_1;
var shim$5 = function shimObjectIs() {
  var polyfill2 = getPolyfill$5();
  define$3(Object, { is: polyfill2 }, {
    is: function testObjectIs() {
      return Object.is !== polyfill2;
    }
  });
  return polyfill2;
};
var define$2 = defineProperties_1;
var callBind$6 = callBindExports$1;
var implementation$6 = implementation$8;
var getPolyfill$4 = polyfill$4;
var shim$4 = shim$5;
var polyfill$3 = callBind$6(getPolyfill$4(), Object);
define$2(polyfill$3, {
  getPolyfill: getPolyfill$4,
  implementation: implementation$6,
  shim: shim$4
});
var objectIs = polyfill$3;
var $Object = Object;
var $TypeError$3 = TypeError;
var implementation$5 = function flags() {
  if (this != null && this !== $Object(this)) {
    throw new $TypeError$3("RegExp.prototype.flags getter called on non-object");
  }
  var result = "";
  if (this.global) {
    result += "g";
  }
  if (this.ignoreCase) {
    result += "i";
  }
  if (this.multiline) {
    result += "m";
  }
  if (this.dotAll) {
    result += "s";
  }
  if (this.unicode) {
    result += "u";
  }
  if (this.sticky) {
    result += "y";
  }
  return result;
};
var implementation$4 = implementation$5;
var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
var $gOPD$1 = Object.getOwnPropertyDescriptor;
var $TypeError$2 = TypeError;
var polyfill$2 = function getPolyfill3() {
  if (!supportsDescriptors$1) {
    throw new $TypeError$2("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  if (/a/mig.flags === "gim") {
    var descriptor = $gOPD$1(RegExp.prototype, "flags");
    if (descriptor && typeof descriptor.get === "function" && typeof /a/.dotAll === "boolean") {
      return descriptor.get;
    }
  }
  return implementation$4;
};
var supportsDescriptors = defineProperties_1.supportsDescriptors;
var getPolyfill$3 = polyfill$2;
var gOPD$1 = Object.getOwnPropertyDescriptor;
var defineProperty$3 = Object.defineProperty;
var TypeErr = TypeError;
var getProto$1 = Object.getPrototypeOf;
var regex = /a/;
var shim$3 = function shimFlags() {
  if (!supportsDescriptors || !getProto$1) {
    throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
  }
  var polyfill2 = getPolyfill$3();
  var proto2 = getProto$1(regex);
  var descriptor = gOPD$1(proto2, "flags");
  if (!descriptor || descriptor.get !== polyfill2) {
    defineProperty$3(proto2, "flags", {
      configurable: true,
      enumerable: false,
      get: polyfill2
    });
  }
  return polyfill2;
};
var define$1 = defineProperties_1;
var callBind$5 = callBindExports$1;
var implementation$3 = implementation$5;
var getPolyfill$2 = polyfill$2;
var shim$2 = shim$3;
var flagsBound = callBind$5(implementation$3);
define$1(flagsBound, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$3,
  shim: shim$2
});
var regexp_prototype_flags = flagsBound;
var toString$2 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$2.call(arr) == "[object Array]";
};
var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject2(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$2 = Object.prototype.toString;
var strClass = "[object String]";
var hasToStringTag$3 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var isString$4 = function isString(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$3 ? tryStringObject(value) : toStr$2.call(value) === strClass;
};
var numToStr = Number.prototype.toString;
var tryNumberObject = function tryNumberObject2(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr$1 = Object.prototype.toString;
var numClass = "[object Number]";
var hasToStringTag$2 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var isNumberObject = function isNumberObject2(value) {
  if (typeof value === "number") {
    return true;
  }
  if (typeof value !== "object") {
    return false;
  }
  return hasToStringTag$2 ? tryNumberObject(value) : toStr$1.call(value) === numClass;
};
var boolToStr = Boolean.prototype.toString;
var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    boolToStr.call(value);
    return true;
  } catch (e2) {
    return false;
  }
};
var toStr = Object.prototype.toString;
var boolClass = "[object Boolean]";
var hasToStringTag$1 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var isBooleanObject = function isBoolean(value) {
  if (typeof value === "boolean") {
    return true;
  }
  if (value === null || typeof value !== "object") {
    return false;
  }
  return hasToStringTag$1 && Symbol.toStringTag in value ? tryBooleanObject(value) : toStr.call(value) === boolClass;
};
var isBigint = { exports: {} };
if (typeof BigInt === "function") {
  var bigIntValueOf = BigInt.prototype.valueOf;
  var tryBigInt = function tryBigIntObject(value) {
    try {
      bigIntValueOf.call(value);
      return true;
    } catch (e2) {
    }
    return false;
  };
  isBigint.exports = function isBigInt2(value) {
    if (value === null || typeof value === "undefined" || typeof value === "boolean" || typeof value === "string" || typeof value === "number" || typeof value === "symbol" || typeof value === "function") {
      return false;
    }
    if (typeof value === "bigint") {
      return true;
    }
    return tryBigInt(value);
  };
} else {
  isBigint.exports = function isBigInt2(value) {
    return false;
  };
}
var isBigintExports = isBigint.exports;
var isString$3 = isString$4;
var isNumber = isNumberObject;
var isBoolean2 = isBooleanObject;
var isSymbol$1 = isSymbolExports;
var isBigInt = isBigintExports;
var whichBoxedPrimitive$1 = function whichBoxedPrimitive(value) {
  if (value == null || typeof value !== "object" && typeof value !== "function") {
    return null;
  }
  if (isString$3(value)) {
    return "String";
  }
  if (isNumber(value)) {
    return "Number";
  }
  if (isBoolean2(value)) {
    return "Boolean";
  }
  if (isSymbol$1(value)) {
    return "Symbol";
  }
  if (isBigInt(value)) {
    return "BigInt";
  }
};
var $Map$3 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$3 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$3;
if (!$Map$3) {
  exported$3 = function isMap3(x) {
    return false;
  };
}
var $mapHas$5 = $Map$3 ? Map.prototype.has : null;
var $setHas$4 = $Set$3 ? Set.prototype.has : null;
if (!exported$3 && !$mapHas$5) {
  exported$3 = function isMap3(x) {
    return false;
  };
}
var isMap$4 = exported$3 || function isMap(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $mapHas$5.call(x);
    if ($setHas$4) {
      try {
        $setHas$4.call(x);
      } catch (e2) {
        return true;
      }
    }
    return x instanceof $Map$3;
  } catch (e2) {
  }
  return false;
};
var $Map$2 = typeof Map === "function" && Map.prototype ? Map : null;
var $Set$2 = typeof Set === "function" && Set.prototype ? Set : null;
var exported$2;
if (!$Set$2) {
  exported$2 = function isSet3(x) {
    return false;
  };
}
var $mapHas$4 = $Map$2 ? Map.prototype.has : null;
var $setHas$3 = $Set$2 ? Set.prototype.has : null;
if (!exported$2 && !$setHas$3) {
  exported$2 = function isSet3(x) {
    return false;
  };
}
var isSet$4 = exported$2 || function isSet(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $setHas$3.call(x);
    if ($mapHas$4) {
      try {
        $mapHas$4.call(x);
      } catch (e2) {
        return true;
      }
    }
    return x instanceof $Set$2;
  } catch (e2) {
  }
  return false;
};
var $WeakMap$2 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet$1 = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported$1;
if (!$WeakMap$2) {
  exported$1 = function isWeakMap3(x) {
    return false;
  };
}
var $mapHas$3 = $WeakMap$2 ? $WeakMap$2.prototype.has : null;
var $setHas$2 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
if (!exported$1 && !$mapHas$3) {
  exported$1 = function isWeakMap3(x) {
    return false;
  };
}
var isWeakmap = exported$1 || function isWeakMap(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $mapHas$3.call(x, $mapHas$3);
    if ($setHas$2) {
      try {
        $setHas$2.call(x, $setHas$2);
      } catch (e2) {
        return true;
      }
    }
    return x instanceof $WeakMap$2;
  } catch (e2) {
  }
  return false;
};
var $WeakMap$1 = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
var exported;
if (!$WeakMap$1) {
  exported = function isWeakSet3(x) {
    return false;
  };
}
var $mapHas$2 = $WeakMap$1 ? $WeakMap$1.prototype.has : null;
var $setHas$1 = $WeakSet ? $WeakSet.prototype.has : null;
if (!exported && !$setHas$1) {
  isWeakset = function isWeakSet3(x) {
    return false;
  };
}
var isWeakset = exported || function isWeakSet(x) {
  if (!x || typeof x !== "object") {
    return false;
  }
  try {
    $setHas$1.call(x, $setHas$1);
    if ($mapHas$2) {
      try {
        $mapHas$2.call(x, $mapHas$2);
      } catch (e2) {
        return true;
      }
    }
    return x instanceof $WeakSet;
  } catch (e2) {
  }
  return false;
};
var isMap$3 = isMap$4;
var isSet$3 = isSet$4;
var isWeakMap2 = isWeakmap;
var isWeakSet2 = isWeakset;
var whichCollection$1 = function whichCollection(value) {
  if (value && typeof value === "object") {
    if (isMap$3(value)) {
      return "Map";
    }
    if (isSet$3(value)) {
      return "Set";
    }
    if (isWeakMap2(value)) {
      return "WeakMap";
    }
    if (isWeakSet2(value)) {
      return "WeakSet";
    }
  }
  return false;
};
var esGetIterator = { exports: {} };
var GetIntrinsic$5;
var hasRequiredGetIntrinsic$1;
function requireGetIntrinsic$1() {
  if (hasRequiredGetIntrinsic$1)
    return GetIntrinsic$5;
  hasRequiredGetIntrinsic$1 = 1;
  var undefined$12;
  var $TypeError2 = TypeError;
  var $gOPD2 = Object.getOwnPropertyDescriptor;
  if ($gOPD2) {
    try {
      $gOPD2({}, "");
    } catch (e2) {
      $gOPD2 = null;
    }
  }
  var throwTypeError2 = function() {
    throw new $TypeError2();
  };
  var ThrowTypeError2 = $gOPD2 ? function() {
    try {
      arguments.callee;
      return throwTypeError2;
    } catch (calleeThrows) {
      try {
        return $gOPD2(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError2;
      }
    }
  }() : throwTypeError2;
  var hasSymbols3 = hasSymbols$7();
  var getProto2 = Object.getPrototypeOf || function(x) {
    return x.__proto__;
  };
  var generatorFunction2 = undefined$12;
  var asyncFunction2 = undefined$12;
  var asyncGenFunction2 = undefined$12;
  var TypedArray2 = typeof Uint8Array === "undefined" ? undefined$12 : getProto2(Uint8Array);
  var INTRINSICS2 = {
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer,
    "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer.prototype,
    "%ArrayIteratorPrototype%": hasSymbols3 ? getProto2([][Symbol.iterator]()) : undefined$12,
    "%ArrayPrototype%": Array.prototype,
    "%ArrayProto_entries%": Array.prototype.entries,
    "%ArrayProto_forEach%": Array.prototype.forEach,
    "%ArrayProto_keys%": Array.prototype.keys,
    "%ArrayProto_values%": Array.prototype.values,
    "%AsyncFromSyncIteratorPrototype%": undefined$12,
    "%AsyncFunction%": asyncFunction2,
    "%AsyncFunctionPrototype%": undefined$12,
    "%AsyncGenerator%": undefined$12,
    "%AsyncGeneratorFunction%": asyncGenFunction2,
    "%AsyncGeneratorPrototype%": undefined$12,
    "%AsyncIteratorPrototype%": undefined$12,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$12 : Atomics,
    "%Boolean%": Boolean,
    "%BooleanPrototype%": Boolean.prototype,
    "%DataView%": typeof DataView === "undefined" ? undefined$12 : DataView,
    "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$12 : DataView.prototype,
    "%Date%": Date,
    "%DatePrototype%": Date.prototype,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%ErrorPrototype%": Error.prototype,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%EvalErrorPrototype%": EvalError.prototype,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array,
    "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array.prototype,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array,
    "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array.prototype,
    "%Function%": Function,
    "%FunctionPrototype%": Function.prototype,
    "%Generator%": undefined$12,
    "%GeneratorFunction%": generatorFunction2,
    "%GeneratorPrototype%": undefined$12,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array,
    "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array.prototype,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$12 : Int16Array,
    "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$12 : Int8Array.prototype,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array,
    "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array.prototype,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols3 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$12,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$12,
    "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$12,
    "%Map%": typeof Map === "undefined" ? undefined$12 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols3 ? undefined$12 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%MapPrototype%": typeof Map === "undefined" ? undefined$12 : Map.prototype,
    "%Math%": Math,
    "%Number%": Number,
    "%NumberPrototype%": Number.prototype,
    "%Object%": Object,
    "%ObjectPrototype%": Object.prototype,
    "%ObjProto_toString%": Object.prototype.toString,
    "%ObjProto_valueOf%": Object.prototype.valueOf,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$12 : Promise,
    "%PromisePrototype%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype,
    "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype.then,
    "%Promise_all%": typeof Promise === "undefined" ? undefined$12 : Promise.all,
    "%Promise_reject%": typeof Promise === "undefined" ? undefined$12 : Promise.reject,
    "%Promise_resolve%": typeof Promise === "undefined" ? undefined$12 : Promise.resolve,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$12 : Proxy,
    "%RangeError%": RangeError,
    "%RangeErrorPrototype%": RangeError.prototype,
    "%ReferenceError%": ReferenceError,
    "%ReferenceErrorPrototype%": ReferenceError.prototype,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$12 : Reflect,
    "%RegExp%": RegExp,
    "%RegExpPrototype%": RegExp.prototype,
    "%Set%": typeof Set === "undefined" ? undefined$12 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols3 ? undefined$12 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SetPrototype%": typeof Set === "undefined" ? undefined$12 : Set.prototype,
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer,
    "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer.prototype,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols3 ? getProto2(""[Symbol.iterator]()) : undefined$12,
    "%StringPrototype%": String.prototype,
    "%Symbol%": hasSymbols3 ? Symbol : undefined$12,
    "%SymbolPrototype%": hasSymbols3 ? Symbol.prototype : undefined$12,
    "%SyntaxError%": SyntaxError,
    "%SyntaxErrorPrototype%": SyntaxError.prototype,
    "%ThrowTypeError%": ThrowTypeError2,
    "%TypedArray%": TypedArray2,
    "%TypedArrayPrototype%": TypedArray2 ? TypedArray2.prototype : undefined$12,
    "%TypeError%": $TypeError2,
    "%TypeErrorPrototype%": $TypeError2.prototype,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array,
    "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array.prototype,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray,
    "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray.prototype,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array,
    "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array.prototype,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array,
    "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array.prototype,
    "%URIError%": URIError,
    "%URIErrorPrototype%": URIError.prototype,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap,
    "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap.prototype,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet,
    "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet.prototype
  };
  var bind3 = functionBind;
  var $replace2 = bind3.call(Function.call, String.prototype.replace);
  var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar2 = /\\(\\)?/g;
  var stringToPath4 = function stringToPath5(string) {
    var result = [];
    $replace2(string, rePropName2, function(match2, number2, quote2, subString) {
      result[result.length] = quote2 ? $replace2(subString, reEscapeChar2, "$1") : number2 || match2;
    });
    return result;
  };
  var getBaseIntrinsic4 = function getBaseIntrinsic5(name, allowMissing) {
    if (!(name in INTRINSICS2)) {
      throw new SyntaxError("intrinsic " + name + " does not exist!");
    }
    if (typeof INTRINSICS2[name] === "undefined" && !allowMissing) {
      throw new $TypeError2("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return INTRINSICS2[name];
  };
  GetIntrinsic$5 = function GetIntrinsic4(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new TypeError('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath4(name);
    var value = getBaseIntrinsic4("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
    for (var i = 1; i < parts.length; i += 1) {
      if (value != null) {
        if ($gOPD2 && i + 1 >= parts.length) {
          var desc = $gOPD2(value, parts[i]);
          if (!allowMissing && !(parts[i] in value)) {
            throw new $TypeError2("base intrinsic for " + name + " exists, but the property is not available.");
          }
          value = desc ? desc.get || desc.value : value[parts[i]];
        } else {
          value = value[parts[i]];
        }
      }
    }
    return value;
  };
  return GetIntrinsic$5;
}
var callBind$4 = { exports: {} };
var hasRequiredCallBind$1;
function requireCallBind$1() {
  if (hasRequiredCallBind$1)
    return callBind$4.exports;
  hasRequiredCallBind$1 = 1;
  var bind3 = functionBind;
  var GetIntrinsic4 = requireGetIntrinsic$1();
  var $Function2 = GetIntrinsic4("%Function%");
  var $apply = $Function2.apply;
  var $call = $Function2.call;
  callBind$4.exports = function callBind2() {
    return bind3.apply($call, arguments);
  };
  callBind$4.exports.apply = function applyBind() {
    return bind3.apply($apply, arguments);
  };
  return callBind$4.exports;
}
var callBound$7;
var hasRequiredCallBound$1;
function requireCallBound$1() {
  if (hasRequiredCallBound$1)
    return callBound$7;
  hasRequiredCallBound$1 = 1;
  var GetIntrinsic4 = requireGetIntrinsic$1();
  var callBind2 = requireCallBind$1();
  var $indexOf2 = callBind2(GetIntrinsic4("String.prototype.indexOf"));
  callBound$7 = function callBoundIntrinsic3(name, allowMissing) {
    var intrinsic = GetIntrinsic4(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf2(name, ".prototype.")) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound$7;
}
var isArguments$3 = isArguments$4;
if (hasSymbols$7() || shams()) {
  var $iterator = Symbol.iterator;
  esGetIterator.exports = function getIterator2(iterable) {
    if (iterable != null && typeof iterable[$iterator] !== "undefined") {
      return iterable[$iterator]();
    }
    if (isArguments$3(iterable)) {
      return Array.prototype[$iterator].call(iterable);
    }
  };
} else {
  var isArray$5 = isarray;
  var isString$2 = isString$4;
  var GetIntrinsic$4 = requireGetIntrinsic$1();
  var $Map$1 = GetIntrinsic$4("%Map%", true);
  var $Set$1 = GetIntrinsic$4("%Set%", true);
  var callBound$6 = requireCallBound$1();
  var $arrayPush = callBound$6("Array.prototype.push");
  var $charCodeAt = callBound$6("String.prototype.charCodeAt");
  var $stringSlice = callBound$6("String.prototype.slice");
  var advanceStringIndex = function advanceStringIndex2(S2, index2) {
    var length = S2.length;
    if (index2 + 1 >= length) {
      return index2 + 1;
    }
    var first = $charCodeAt(S2, index2);
    if (first < 55296 || first > 56319) {
      return index2 + 1;
    }
    var second = $charCodeAt(S2, index2 + 1);
    if (second < 56320 || second > 57343) {
      return index2 + 1;
    }
    return index2 + 2;
  };
  var getArrayIterator = function getArrayIterator2(arraylike) {
    var i = 0;
    return {
      next: function next() {
        var done = i >= arraylike.length;
        var value;
        if (!done) {
          value = arraylike[i];
          i += 1;
        }
        return {
          done,
          value
        };
      }
    };
  };
  var getNonCollectionIterator = function getNonCollectionIterator2(iterable) {
    if (isArray$5(iterable) || isArguments$3(iterable)) {
      return getArrayIterator(iterable);
    }
    if (isString$2(iterable)) {
      var i = 0;
      return {
        next: function next() {
          var nextIndex = advanceStringIndex(iterable, i);
          var value = $stringSlice(iterable, i, nextIndex);
          i = nextIndex;
          return {
            done: nextIndex > iterable.length,
            value
          };
        }
      };
    }
  };
  if (!$Map$1 && !$Set$1) {
    esGetIterator.exports = getNonCollectionIterator;
  } else {
    var isMap$2 = isMap$4;
    var isSet$2 = isSet$4;
    var $mapForEach = callBound$6("Map.prototype.forEach", true);
    var $setForEach = callBound$6("Set.prototype.forEach", true);
    if (typeof process === "undefined" || !process.versions || !process.versions.node) {
      var $mapIterator = callBound$6("Map.prototype.iterator", true);
      var $setIterator = callBound$6("Set.prototype.iterator", true);
      var getStopIterationIterator = function(iterator2) {
        var done = false;
        return {
          next: function next() {
            try {
              return {
                done,
                value: done ? void 0 : iterator2.next()
              };
            } catch (e2) {
              done = true;
              return {
                done: true,
                value: void 0
              };
            }
          }
        };
      };
    }
    var $mapAtAtIterator = callBound$6("Map.prototype.@@iterator", true) || callBound$6("Map.prototype._es6-shim iterator_", true);
    var $setAtAtIterator = callBound$6("Set.prototype.@@iterator", true) || callBound$6("Set.prototype._es6-shim iterator_", true);
    var getCollectionIterator = function getCollectionIterator2(iterable) {
      if (isMap$2(iterable)) {
        if ($mapIterator) {
          return getStopIterationIterator($mapIterator(iterable));
        }
        if ($mapAtAtIterator) {
          return $mapAtAtIterator(iterable);
        }
        if ($mapForEach) {
          var entries = [];
          $mapForEach(iterable, function(v2, k2) {
            $arrayPush(entries, [k2, v2]);
          });
          return getArrayIterator(entries);
        }
      }
      if (isSet$2(iterable)) {
        if ($setIterator) {
          return getStopIterationIterator($setIterator(iterable));
        }
        if ($setAtAtIterator) {
          return $setAtAtIterator(iterable);
        }
        if ($setForEach) {
          var values2 = [];
          $setForEach(iterable, function(v2) {
            $arrayPush(values2, v2);
          });
          return getArrayIterator(values2);
        }
      }
    };
    esGetIterator.exports = function getIterator2(iterable) {
      return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
    };
  }
}
var esGetIteratorExports = esGetIterator.exports;
var GetIntrinsic$3 = GetIntrinsic$d;
var callBound$5 = callBound$8;
var inspect = objectInspect;
var $TypeError$1 = GetIntrinsic$3("%TypeError%");
var $WeakMap = GetIntrinsic$3("%WeakMap%", true);
var $Map = GetIntrinsic$3("%Map%", true);
var $push$1 = callBound$5("Array.prototype.push");
var $weakMapGet = callBound$5("WeakMap.prototype.get", true);
var $weakMapSet = callBound$5("WeakMap.prototype.set", true);
var $weakMapHas = callBound$5("WeakMap.prototype.has", true);
var $mapGet$1 = callBound$5("Map.prototype.get", true);
var $mapSet = callBound$5("Map.prototype.set", true);
var $mapHas$1 = callBound$5("Map.prototype.has", true);
var objectGet = function(objects, key) {
  for (var i = 0; i < objects.length; i += 1) {
    if (objects[i].key === key) {
      return objects[i].value;
    }
  }
};
var objectSet = function(objects, key, value) {
  for (var i = 0; i < objects.length; i += 1) {
    if (objects[i].key === key) {
      objects[i].value = value;
      return;
    }
  }
  $push$1(objects, {
    key,
    value
  });
};
var objectHas = function(objects, key) {
  for (var i = 0; i < objects.length; i += 1) {
    if (objects[i].key === key) {
      return true;
    }
  }
  return false;
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError$1("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet$1($m, key);
        }
      } else {
        if ($o) {
          return objectGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas$1($m, key);
        }
      } else {
        if ($o) {
          return objectHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      } else {
        if (!$o) {
          $o = [];
        }
        objectSet($o, key, value);
      }
    }
  };
  return channel;
};
var hasOwn$2 = Object.prototype.hasOwnProperty;
var toString$1 = Object.prototype.toString;
var foreach = function forEach(obj, fn, ctx) {
  if (toString$1.call(fn) !== "[object Function]") {
    throw new TypeError("iterator must be a function");
  }
  var l2 = obj.length;
  if (l2 === +l2) {
    for (var i = 0; i < l2; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k2 in obj) {
      if (hasOwn$2.call(obj, k2)) {
        fn.call(ctx, obj[k2], k2, obj);
      }
    }
  }
};
var arrayFilter$1 = function(arr, fn, self2) {
  if (arr.filter)
    return arr.filter(fn, self2);
  if (void 0 === arr || null === arr)
    throw new TypeError();
  if ("function" != typeof fn)
    throw new TypeError();
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn$1.call(arr, i))
      continue;
    var val = arr[i];
    if (fn.call(self2, val, i, arr))
      ret.push(val);
  }
  return ret;
};
var hasOwn$1 = Object.prototype.hasOwnProperty;
var filter = arrayFilter$1;
var availableTypedArrays$1 = function availableTypedArrays() {
  return filter([
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ], function(typedArray) {
    return typeof commonjsGlobal[typedArray] === "function";
  });
};
var GetIntrinsic$2;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return GetIntrinsic$2;
  hasRequiredGetIntrinsic = 1;
  var undefined$12;
  var $TypeError2 = TypeError;
  var $gOPD2 = Object.getOwnPropertyDescriptor;
  if ($gOPD2) {
    try {
      $gOPD2({}, "");
    } catch (e2) {
      $gOPD2 = null;
    }
  }
  var throwTypeError2 = function() {
    throw new $TypeError2();
  };
  var ThrowTypeError2 = $gOPD2 ? function() {
    try {
      arguments.callee;
      return throwTypeError2;
    } catch (calleeThrows) {
      try {
        return $gOPD2(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError2;
      }
    }
  }() : throwTypeError2;
  var hasSymbols3 = hasSymbols$7();
  var getProto2 = Object.getPrototypeOf || function(x) {
    return x.__proto__;
  };
  var generatorFunction2 = undefined$12;
  var asyncFunction2 = undefined$12;
  var asyncGenFunction2 = undefined$12;
  var TypedArray2 = typeof Uint8Array === "undefined" ? undefined$12 : getProto2(Uint8Array);
  var INTRINSICS2 = {
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer,
    "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer.prototype,
    "%ArrayIteratorPrototype%": hasSymbols3 ? getProto2([][Symbol.iterator]()) : undefined$12,
    "%ArrayPrototype%": Array.prototype,
    "%ArrayProto_entries%": Array.prototype.entries,
    "%ArrayProto_forEach%": Array.prototype.forEach,
    "%ArrayProto_keys%": Array.prototype.keys,
    "%ArrayProto_values%": Array.prototype.values,
    "%AsyncFromSyncIteratorPrototype%": undefined$12,
    "%AsyncFunction%": asyncFunction2,
    "%AsyncFunctionPrototype%": undefined$12,
    "%AsyncGenerator%": undefined$12,
    "%AsyncGeneratorFunction%": asyncGenFunction2,
    "%AsyncGeneratorPrototype%": undefined$12,
    "%AsyncIteratorPrototype%": undefined$12,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$12 : Atomics,
    "%Boolean%": Boolean,
    "%BooleanPrototype%": Boolean.prototype,
    "%DataView%": typeof DataView === "undefined" ? undefined$12 : DataView,
    "%DataViewPrototype%": typeof DataView === "undefined" ? undefined$12 : DataView.prototype,
    "%Date%": Date,
    "%DatePrototype%": Date.prototype,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%ErrorPrototype%": Error.prototype,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%EvalErrorPrototype%": EvalError.prototype,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array,
    "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array.prototype,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array,
    "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array.prototype,
    "%Function%": Function,
    "%FunctionPrototype%": Function.prototype,
    "%Generator%": undefined$12,
    "%GeneratorFunction%": generatorFunction2,
    "%GeneratorPrototype%": undefined$12,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array,
    "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array.prototype,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$12 : Int16Array,
    "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined$12 : Int8Array.prototype,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array,
    "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array.prototype,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols3 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$12,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$12,
    "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined$12,
    "%Map%": typeof Map === "undefined" ? undefined$12 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols3 ? undefined$12 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%MapPrototype%": typeof Map === "undefined" ? undefined$12 : Map.prototype,
    "%Math%": Math,
    "%Number%": Number,
    "%NumberPrototype%": Number.prototype,
    "%Object%": Object,
    "%ObjectPrototype%": Object.prototype,
    "%ObjProto_toString%": Object.prototype.toString,
    "%ObjProto_valueOf%": Object.prototype.valueOf,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$12 : Promise,
    "%PromisePrototype%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype,
    "%PromiseProto_then%": typeof Promise === "undefined" ? undefined$12 : Promise.prototype.then,
    "%Promise_all%": typeof Promise === "undefined" ? undefined$12 : Promise.all,
    "%Promise_reject%": typeof Promise === "undefined" ? undefined$12 : Promise.reject,
    "%Promise_resolve%": typeof Promise === "undefined" ? undefined$12 : Promise.resolve,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$12 : Proxy,
    "%RangeError%": RangeError,
    "%RangeErrorPrototype%": RangeError.prototype,
    "%ReferenceError%": ReferenceError,
    "%ReferenceErrorPrototype%": ReferenceError.prototype,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$12 : Reflect,
    "%RegExp%": RegExp,
    "%RegExpPrototype%": RegExp.prototype,
    "%Set%": typeof Set === "undefined" ? undefined$12 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols3 ? undefined$12 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SetPrototype%": typeof Set === "undefined" ? undefined$12 : Set.prototype,
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer,
    "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer.prototype,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols3 ? getProto2(""[Symbol.iterator]()) : undefined$12,
    "%StringPrototype%": String.prototype,
    "%Symbol%": hasSymbols3 ? Symbol : undefined$12,
    "%SymbolPrototype%": hasSymbols3 ? Symbol.prototype : undefined$12,
    "%SyntaxError%": SyntaxError,
    "%SyntaxErrorPrototype%": SyntaxError.prototype,
    "%ThrowTypeError%": ThrowTypeError2,
    "%TypedArray%": TypedArray2,
    "%TypedArrayPrototype%": TypedArray2 ? TypedArray2.prototype : undefined$12,
    "%TypeError%": $TypeError2,
    "%TypeErrorPrototype%": $TypeError2.prototype,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array,
    "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array.prototype,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray,
    "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray.prototype,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array,
    "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array.prototype,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array,
    "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array.prototype,
    "%URIError%": URIError,
    "%URIErrorPrototype%": URIError.prototype,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap,
    "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap.prototype,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet,
    "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet.prototype
  };
  var bind3 = functionBind;
  var $replace2 = bind3.call(Function.call, String.prototype.replace);
  var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar2 = /\\(\\)?/g;
  var stringToPath4 = function stringToPath5(string) {
    var result = [];
    $replace2(string, rePropName2, function(match2, number2, quote2, subString) {
      result[result.length] = quote2 ? $replace2(subString, reEscapeChar2, "$1") : number2 || match2;
    });
    return result;
  };
  var getBaseIntrinsic4 = function getBaseIntrinsic5(name, allowMissing) {
    if (!(name in INTRINSICS2)) {
      throw new SyntaxError("intrinsic " + name + " does not exist!");
    }
    if (typeof INTRINSICS2[name] === "undefined" && !allowMissing) {
      throw new $TypeError2("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return INTRINSICS2[name];
  };
  GetIntrinsic$2 = function GetIntrinsic4(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new TypeError('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath4(name);
    var value = getBaseIntrinsic4("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
    for (var i = 1; i < parts.length; i += 1) {
      if (value != null) {
        if ($gOPD2 && i + 1 >= parts.length) {
          var desc = $gOPD2(value, parts[i]);
          if (!allowMissing && !(parts[i] in value)) {
            throw new $TypeError2("base intrinsic for " + name + " exists, but the property is not available.");
          }
          value = desc ? desc.get || desc.value : value[parts[i]];
        } else {
          value = value[parts[i]];
        }
      }
    }
    return value;
  };
  return GetIntrinsic$2;
}
var callBind$3 = { exports: {} };
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind)
    return callBind$3.exports;
  hasRequiredCallBind = 1;
  var bind3 = functionBind;
  var GetIntrinsic4 = requireGetIntrinsic();
  var $Function2 = GetIntrinsic4("%Function%");
  var $apply = $Function2.apply;
  var $call = $Function2.call;
  callBind$3.exports = function callBind2() {
    return bind3.apply($call, arguments);
  };
  callBind$3.exports.apply = function applyBind() {
    return bind3.apply($apply, arguments);
  };
  return callBind$3.exports;
}
var callBound$4;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound$4;
  hasRequiredCallBound = 1;
  var GetIntrinsic4 = requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf2 = callBind2(GetIntrinsic4("String.prototype.indexOf"));
  callBound$4 = function callBoundIntrinsic3(name, allowMissing) {
    var intrinsic = GetIntrinsic4(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf2(name, ".prototype.")) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound$4;
}
var getOwnPropertyDescriptor$1;
var hasRequiredGetOwnPropertyDescriptor;
function requireGetOwnPropertyDescriptor() {
  if (hasRequiredGetOwnPropertyDescriptor)
    return getOwnPropertyDescriptor$1;
  hasRequiredGetOwnPropertyDescriptor = 1;
  var GetIntrinsic4 = requireGetIntrinsic();
  var $gOPD2 = GetIntrinsic4("%Object.getOwnPropertyDescriptor%");
  if ($gOPD2) {
    try {
      $gOPD2([], "length");
    } catch (e2) {
      $gOPD2 = null;
    }
  }
  getOwnPropertyDescriptor$1 = $gOPD2;
  return getOwnPropertyDescriptor$1;
}
var isTypedArray$3;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray$3;
  hasRequiredIsTypedArray = 1;
  var forEach3 = foreach;
  var availableTypedArrays3 = availableTypedArrays$1;
  var callBound2 = requireCallBound();
  var $toString2 = callBound2("Object.prototype.toString");
  var hasSymbols3 = hasSymbols$7();
  var hasToStringTag2 = hasSymbols3 && typeof Symbol.toStringTag === "symbol";
  var typedArrays2 = availableTypedArrays3();
  var $indexOf2 = callBound2("Array.prototype.indexOf", true) || function indexOf2(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var $slice2 = callBound2("String.prototype.slice");
  var toStrTags2 = {};
  var gOPD2 = requireGetOwnPropertyDescriptor();
  var getPrototypeOf2 = Object.getPrototypeOf;
  if (hasToStringTag2 && gOPD2 && getPrototypeOf2) {
    forEach3(typedArrays2, function(typedArray) {
      var arr = new commonjsGlobal[typedArray]();
      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
      }
      var proto2 = getPrototypeOf2(arr);
      var descriptor = gOPD2(proto2, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf2(proto2);
        descriptor = gOPD2(superProto, Symbol.toStringTag);
      }
      toStrTags2[typedArray] = descriptor.get;
    });
  }
  var tryTypedArrays2 = function tryAllTypedArrays2(value) {
    var anyTrue = false;
    forEach3(toStrTags2, function(getter, typedArray) {
      if (!anyTrue) {
        try {
          anyTrue = getter.call(value) === typedArray;
        } catch (e2) {
        }
      }
    });
    return anyTrue;
  };
  isTypedArray$3 = function isTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag2) {
      var tag = $slice2($toString2(value), 8, -1);
      return $indexOf2(typedArrays2, tag) > -1;
    }
    if (!gOPD2) {
      return false;
    }
    return tryTypedArrays2(value);
  };
  return isTypedArray$3;
}
var forEach2 = foreach;
var availableTypedArrays2 = availableTypedArrays$1;
var callBound$3 = callBound$8;
var $toString = callBound$3("Object.prototype.toString");
var hasSymbols$2 = hasSymbols$7();
var hasToStringTag = hasSymbols$2 && typeof Symbol.toStringTag === "symbol";
var typedArrays = availableTypedArrays2();
var $slice = callBound$3("String.prototype.slice");
var toStrTags = {};
var gOPD = requireGetOwnPropertyDescriptor$1();
var getPrototypeOf$1 = Object.getPrototypeOf;
if (hasToStringTag && gOPD && getPrototypeOf$1) {
  forEach2(typedArrays, function(typedArray) {
    if (typeof commonjsGlobal[typedArray] === "function") {
      var arr = new commonjsGlobal[typedArray]();
      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
      }
      var proto2 = getPrototypeOf$1(arr);
      var descriptor = gOPD(proto2, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf$1(proto2);
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      toStrTags[typedArray] = descriptor.get;
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  forEach2(toStrTags, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);
        if (name === typedArray) {
          foundName = name;
        }
      } catch (e2) {
      }
    }
  });
  return foundName;
};
var isTypedArray$2 = requireIsTypedArray();
var whichTypedArray$1 = function whichTypedArray(value) {
  if (!isTypedArray$2(value)) {
    return false;
  }
  if (!hasToStringTag) {
    return $slice($toString(value), 8, -1);
  }
  return tryTypedArrays(value);
};
var callBind$2 = { exports: {} };
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return window["notthere"];
  } catch (e2) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e2) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$1 = hasSymbols$7();
var getProto = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var asyncGenFunction = getEvalledConstructor();
var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined$1;
var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined$1;
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": getEvalledConstructor(),
  "%AsyncGenerator%": asyncGenFunctionPrototype,
  "%AsyncGeneratorFunction%": asyncGenFunction,
  "%AsyncIteratorPrototype%": asyncGenPrototype ? getProto(asyncGenPrototype) : undefined$1,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": getEvalledConstructor(),
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn = src;
var $concat = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace = bind2.call(Function.call, String.prototype.replace);
var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$2 = function stringToPath2(string) {
  var result = [];
  $replace(string, rePropName$1, function(match2, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar$1, "$1") : number2 || match2;
  });
  return result;
};
var getBaseIntrinsic2 = function getBaseIntrinsic3(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (typeof value === "undefined" && !allowMissing) {
      throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath$2(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic2("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;
        if (!allowMissing && !(part in value)) {
          throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
        }
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic4 = getIntrinsic;
  var $apply = GetIntrinsic4("%Function.prototype.apply%");
  var $call = GetIntrinsic4("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic4("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $defineProperty = GetIntrinsic4("%Object.defineProperty%", true);
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2() {
    return $reflectApply(bind3, $call, arguments);
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$2);
var callBindExports = callBind$2.exports;
var GetIntrinsic$1 = getIntrinsic;
var callBind$1 = callBindExports;
var $indexOf = callBind$1(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$2 = function callBoundIntrinsic2(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
    return callBind$1(intrinsic);
  }
  return intrinsic;
};
var keys$1 = objectKeys$1;
var canBeObject = function(obj) {
  return typeof obj !== "undefined" && obj !== null;
};
var hasSymbols2 = shams();
var callBound$1 = callBound$2;
var toObject = Object;
var $push = callBound$1("Array.prototype.push");
var $propIsEnumerable = callBound$1("Object.prototype.propertyIsEnumerable");
var originalGetSymbols = hasSymbols2 ? Object.getOwnPropertySymbols : null;
var implementation$2 = function assign2(target, source1) {
  if (!canBeObject(target)) {
    throw new TypeError("target must be an object");
  }
  var objTarget = toObject(target);
  var s2, source, i, props, syms, value, key;
  for (s2 = 1; s2 < arguments.length; ++s2) {
    source = toObject(arguments[s2]);
    props = keys$1(source);
    var getSymbols2 = hasSymbols2 && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols2) {
      syms = getSymbols2(source);
      for (i = 0; i < syms.length; ++i) {
        key = syms[i];
        if ($propIsEnumerable(source, key)) {
          $push(props, key);
        }
      }
    }
    for (i = 0; i < props.length; ++i) {
      key = props[i];
      value = source[key];
      if ($propIsEnumerable(source, key)) {
        objTarget[key] = value;
      }
    }
  }
  return objTarget;
};
var implementation$1 = implementation$2;
var lacksProperEnumerationOrder = function() {
  if (!Object.assign) {
    return false;
  }
  var str = "abcdefghijklmnopqrst";
  var letters = str.split("");
  var map2 = {};
  for (var i = 0; i < letters.length; ++i) {
    map2[letters[i]] = letters[i];
  }
  var obj = Object.assign({}, map2);
  var actual = "";
  for (var k2 in obj) {
    actual += k2;
  }
  return str !== actual;
};
var assignHasPendingExceptions = function() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  var thrower = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(thrower, "xy");
  } catch (e2) {
    return thrower[1] === "y";
  }
  return false;
};
var polyfill$1 = function getPolyfill4() {
  if (!Object.assign) {
    return implementation$1;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation$1;
  }
  if (assignHasPendingExceptions()) {
    return implementation$1;
  }
  return Object.assign;
};
var define = defineProperties_1;
var getPolyfill$1 = polyfill$1;
var shim$1 = function shimAssign() {
  var polyfill2 = getPolyfill$1();
  define(
    Object,
    { assign: polyfill2 },
    { assign: function() {
      return Object.assign !== polyfill2;
    } }
  );
  return polyfill2;
};
var defineProperties = defineProperties_1;
var callBind = callBindExports;
var implementation = implementation$2;
var getPolyfill5 = polyfill$1;
var shim = shim$1;
var polyfill = callBind.apply(getPolyfill5());
var bound = function assign3(target, source1) {
  return polyfill(Object, arguments);
};
defineProperties(bound, {
  getPolyfill: getPolyfill5,
  implementation,
  shim
});
var object_assign = bound;
var objectKeys = objectKeys$1;
var isArguments$2 = isArguments$4;
var is$1 = objectIs;
var isRegex3 = isRegex$1;
var flags2 = regexp_prototype_flags;
var isArray$4 = isarray;
var isDate = isDateObject;
var whichBoxedPrimitive2 = whichBoxedPrimitive$1;
var GetIntrinsic3 = GetIntrinsic$d;
var callBound = callBound$8;
var whichCollection2 = whichCollection$1;
var getIterator = esGetIteratorExports;
var getSideChannel2 = sideChannel;
var whichTypedArray2 = whichTypedArray$1;
var assign4 = object_assign;
var $getTime = callBound("Date.prototype.getTime");
var gPO = Object.getPrototypeOf;
var $objToString = callBound("Object.prototype.toString");
var $Set = GetIntrinsic3("%Set%", true);
var $mapHas = callBound("Map.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSize = callBound("Map.prototype.size", true);
var $setAdd = callBound("Set.prototype.add", true);
var $setDelete = callBound("Set.prototype.delete", true);
var $setHas = callBound("Set.prototype.has", true);
var $setSize = callBound("Set.prototype.size", true);
function setHasEqualElement(set, val1, opts, channel) {
  var i = getIterator(set);
  var result;
  while ((result = i.next()) && !result.done) {
    if (internalDeepEqual(val1, result.value, opts, channel)) {
      $setDelete(set, result.value);
      return true;
    }
  }
  return false;
}
function findLooseMatchingPrimitives(prim) {
  if (typeof prim === "undefined") {
    return null;
  }
  if (typeof prim === "object") {
    return void 0;
  }
  if (typeof prim === "symbol") {
    return false;
  }
  if (typeof prim === "string" || typeof prim === "number") {
    return +prim === +prim;
  }
  return true;
}
function mapMightHaveLoosePrim(a2, b2, prim, item, opts, channel) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = $mapGet(b2, altValue);
  var looseOpts = assign4({}, opts, { strict: false });
  if (typeof curB === "undefined" && !$mapHas(b2, altValue) || !internalDeepEqual(item, curB, looseOpts, channel)) {
    return false;
  }
  return !$mapHas(a2, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
}
function setMightHaveLoosePrim(a2, b2, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  return $setHas(b2, altValue) && !$setHas(a2, altValue);
}
function mapHasEqualEntry(set, map2, key1, item1, opts, channel) {
  var i = getIterator(set);
  var result;
  var key2;
  while ((result = i.next()) && !result.done) {
    key2 = result.value;
    if (
      // eslint-disable-next-line no-use-before-define
      internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet(map2, key2), opts, channel)
    ) {
      $setDelete(set, key2);
      return true;
    }
  }
  return false;
}
function internalDeepEqual(actual, expected, options, channel) {
  var opts = options || {};
  if (opts.strict ? is$1(actual, expected) : actual === expected) {
    return true;
  }
  var actualBoxed = whichBoxedPrimitive2(actual);
  var expectedBoxed = whichBoxedPrimitive2(expected);
  if (actualBoxed !== expectedBoxed) {
    return false;
  }
  if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
    return opts.strict ? is$1(actual, expected) : actual == expected;
  }
  var hasActual = channel.has(actual);
  var hasExpected = channel.has(expected);
  var sentinel;
  if (hasActual && hasExpected) {
    if (channel.get(actual) === channel.get(expected)) {
      return true;
    }
  } else {
    sentinel = {};
  }
  if (!hasActual) {
    channel.set(actual, sentinel);
  }
  if (!hasExpected) {
    channel.set(expected, sentinel);
  }
  return objEquiv(actual, expected, opts, channel);
}
function isBuffer$3(x) {
  if (!x || typeof x !== "object" || typeof x.length !== "number") {
    return false;
  }
  if (typeof x.copy !== "function" || typeof x.slice !== "function") {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== "number") {
    return false;
  }
  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
}
function setEquiv(a2, b2, opts, channel) {
  if ($setSize(a2) !== $setSize(b2)) {
    return false;
  }
  var iA = getIterator(a2);
  var iB = getIterator(b2);
  var resultA;
  var resultB;
  var set;
  while ((resultA = iA.next()) && !resultA.done) {
    if (resultA.value && typeof resultA.value === "object") {
      if (!set) {
        set = new $Set();
      }
      $setAdd(set, resultA.value);
    } else if (!$setHas(b2, resultA.value)) {
      if (opts.strict) {
        return false;
      }
      if (!setMightHaveLoosePrim(a2, b2, resultA.value)) {
        return false;
      }
      if (!set) {
        set = new $Set();
      }
      $setAdd(set, resultA.value);
    }
  }
  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      if (resultB.value && typeof resultB.value === "object") {
        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
          return false;
        }
      } else if (!opts.strict && !$setHas(a2, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
        return false;
      }
    }
    return $setSize(set) === 0;
  }
  return true;
}
function mapEquiv(a2, b2, opts, channel) {
  if ($mapSize(a2) !== $mapSize(b2)) {
    return false;
  }
  var iA = getIterator(a2);
  var iB = getIterator(b2);
  var resultA;
  var resultB;
  var set;
  var key;
  var item1;
  var item2;
  while ((resultA = iA.next()) && !resultA.done) {
    key = resultA.value[0];
    item1 = resultA.value[1];
    if (key && typeof key === "object") {
      if (!set) {
        set = new $Set();
      }
      $setAdd(set, key);
    } else {
      item2 = $mapGet(b2, key);
      if (typeof item2 === "undefined" && !$mapHas(b2, key) || !internalDeepEqual(item1, item2, opts, channel)) {
        if (opts.strict) {
          return false;
        }
        if (!mapMightHaveLoosePrim(a2, b2, key, item1, opts, channel)) {
          return false;
        }
        if (!set) {
          set = new $Set();
        }
        $setAdd(set, key);
      }
    }
  }
  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      key = resultB.value[0];
      item2 = resultB.value[1];
      if (key && typeof key === "object") {
        if (!mapHasEqualEntry(set, a2, key, item2, opts, channel)) {
          return false;
        }
      } else if (!opts.strict && (!a2.has(key) || !internalDeepEqual($mapGet(a2, key), item2, opts, channel)) && !mapHasEqualEntry(set, a2, key, item2, assign4({}, opts, { strict: false }), channel)) {
        return false;
      }
    }
    return $setSize(set) === 0;
  }
  return true;
}
function objEquiv(a2, b2, opts, channel) {
  var i, key;
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 == null || b2 == null) {
    return false;
  }
  if ($objToString(a2) !== $objToString(b2)) {
    return false;
  }
  if (isArguments$2(a2) !== isArguments$2(b2)) {
    return false;
  }
  var aIsArray = isArray$4(a2);
  var bIsArray = isArray$4(b2);
  if (aIsArray !== bIsArray) {
    return false;
  }
  var aIsError = a2 instanceof Error;
  var bIsError = b2 instanceof Error;
  if (aIsError !== bIsError) {
    return false;
  }
  if (aIsError || bIsError) {
    if (a2.name !== b2.name || a2.message !== b2.message) {
      return false;
    }
  }
  var aIsRegex = isRegex3(a2);
  var bIsRegex = isRegex3(b2);
  if (aIsRegex !== bIsRegex) {
    return false;
  }
  if ((aIsRegex || bIsRegex) && (a2.source !== b2.source || flags2(a2) !== flags2(b2))) {
    return false;
  }
  var aIsDate = isDate(a2);
  var bIsDate = isDate(b2);
  if (aIsDate !== bIsDate) {
    return false;
  }
  if (aIsDate || bIsDate) {
    if ($getTime(a2) !== $getTime(b2)) {
      return false;
    }
  }
  if (opts.strict && gPO && gPO(a2) !== gPO(b2)) {
    return false;
  }
  if (whichTypedArray2(a2) !== whichTypedArray2(b2)) {
    return false;
  }
  var aIsBuffer = isBuffer$3(a2);
  var bIsBuffer = isBuffer$3(b2);
  if (aIsBuffer !== bIsBuffer) {
    return false;
  }
  if (aIsBuffer || bIsBuffer) {
    if (a2.length !== b2.length) {
      return false;
    }
    for (i = 0; i < a2.length; i++) {
      if (a2[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  var ka2 = objectKeys(a2);
  var kb2 = objectKeys(b2);
  if (ka2.length !== kb2.length) {
    return false;
  }
  ka2.sort();
  kb2.sort();
  for (i = ka2.length - 1; i >= 0; i--) {
    if (ka2[i] != kb2[i]) {
      return false;
    }
  }
  for (i = ka2.length - 1; i >= 0; i--) {
    key = ka2[i];
    if (!internalDeepEqual(a2[key], b2[key], opts, channel)) {
      return false;
    }
  }
  var aCollection = whichCollection2(a2);
  var bCollection = whichCollection2(b2);
  if (aCollection !== bCollection) {
    return false;
  }
  if (aCollection === "Set" || bCollection === "Set") {
    return setEquiv(a2, b2, opts, channel);
  }
  if (aCollection === "Map") {
    return mapEquiv(a2, b2, opts, channel);
  }
  return true;
}
var deepEqual = function deepEqual2(a2, b2, opts) {
  return internalDeepEqual(a2, b2, opts, getSideChannel2());
};
const deepEqual$1 = /* @__PURE__ */ getDefaultExportFromCjs(deepEqual);
const anyMap = /* @__PURE__ */ new WeakMap();
const eventsMap = /* @__PURE__ */ new WeakMap();
const producersMap = /* @__PURE__ */ new WeakMap();
const anyProducer = Symbol("anyProducer");
const resolvedPromise = Promise.resolve();
const listenerAdded = Symbol("listenerAdded");
const listenerRemoved = Symbol("listenerRemoved");
function assertEventName(eventName) {
  if (typeof eventName !== "string" && typeof eventName !== "symbol") {
    throw new TypeError("eventName must be a string or a symbol");
  }
}
function assertListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError("listener must be a function");
  }
}
function getListeners(instance, eventName) {
  const events = eventsMap.get(instance);
  if (!events.has(eventName)) {
    events.set(eventName, /* @__PURE__ */ new Set());
  }
  return events.get(eventName);
}
function getEventProducers(instance, eventName) {
  const key = typeof eventName === "string" ? eventName : anyProducer;
  const producers = producersMap.get(instance);
  if (!producers.has(key)) {
    producers.set(key, /* @__PURE__ */ new Set());
  }
  return producers.get(key);
}
function enqueueProducers(instance, eventName, eventData) {
  const producers = producersMap.get(instance);
  if (producers.has(eventName)) {
    for (const producer of producers.get(eventName)) {
      producer.enqueue(eventData);
    }
  }
  if (producers.has(anyProducer)) {
    const item = Promise.all([eventName, eventData]);
    for (const producer of producers.get(anyProducer)) {
      producer.enqueue(item);
    }
  }
}
function iterator(instance, eventName) {
  let isFinished = false;
  let flush = () => {
  };
  let queue = [];
  const producer = {
    enqueue(item) {
      queue.push(item);
      flush();
    },
    finish() {
      isFinished = true;
      flush();
    }
  };
  getEventProducers(instance, eventName).add(producer);
  return {
    async next() {
      if (!queue) {
        return { done: true };
      }
      if (queue.length === 0) {
        if (isFinished) {
          queue = void 0;
          return this.next();
        }
        await new Promise((resolve) => {
          flush = resolve;
        });
        return this.next();
      }
      return {
        done: false,
        value: await queue.shift()
      };
    },
    async return(value) {
      queue = void 0;
      getEventProducers(instance, eventName).delete(producer);
      flush();
      return arguments.length > 0 ? { done: true, value: await value } : { done: true };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function defaultMethodNamesOrAssert(methodNames) {
  if (methodNames === void 0) {
    return allEmitteryMethods;
  }
  if (!Array.isArray(methodNames)) {
    throw new TypeError("`methodNames` must be an array of strings");
  }
  for (const methodName of methodNames) {
    if (!allEmitteryMethods.includes(methodName)) {
      if (typeof methodName !== "string") {
        throw new TypeError("`methodNames` element must be a string");
      }
      throw new Error(`${methodName} is not Emittery method`);
    }
  }
  return methodNames;
}
const isListenerSymbol = (symbol) => symbol === listenerAdded || symbol === listenerRemoved;
class Emittery {
  static mixin(emitteryPropertyName, methodNames) {
    methodNames = defaultMethodNamesOrAssert(methodNames);
    return (target) => {
      if (typeof target !== "function") {
        throw new TypeError("`target` must be function");
      }
      for (const methodName of methodNames) {
        if (target.prototype[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
      }
      function getEmitteryProperty() {
        Object.defineProperty(this, emitteryPropertyName, {
          enumerable: false,
          value: new Emittery()
        });
        return this[emitteryPropertyName];
      }
      Object.defineProperty(target.prototype, emitteryPropertyName, {
        enumerable: false,
        get: getEmitteryProperty
      });
      const emitteryMethodCaller = (methodName) => function(...args) {
        return this[emitteryPropertyName][methodName](...args);
      };
      for (const methodName of methodNames) {
        Object.defineProperty(target.prototype, methodName, {
          enumerable: false,
          value: emitteryMethodCaller(methodName)
        });
      }
      return target;
    };
  }
  constructor() {
    anyMap.set(this, /* @__PURE__ */ new Set());
    eventsMap.set(this, /* @__PURE__ */ new Map());
    producersMap.set(this, /* @__PURE__ */ new Map());
  }
  on(eventName, listener) {
    assertEventName(eventName);
    assertListener(listener);
    getListeners(this, eventName).add(listener);
    if (!isListenerSymbol(eventName)) {
      this.emit(listenerAdded, { eventName, listener });
    }
    return this.off.bind(this, eventName, listener);
  }
  off(eventName, listener) {
    assertEventName(eventName);
    assertListener(listener);
    if (!isListenerSymbol(eventName)) {
      this.emit(listenerRemoved, { eventName, listener });
    }
    getListeners(this, eventName).delete(listener);
  }
  once(eventName) {
    return new Promise((resolve) => {
      assertEventName(eventName);
      const off = this.on(eventName, (data) => {
        off();
        resolve(data);
      });
    });
  }
  events(eventName) {
    assertEventName(eventName);
    return iterator(this, eventName);
  }
  async emit(eventName, eventData) {
    assertEventName(eventName);
    enqueueProducers(this, eventName, eventData);
    const listeners = getListeners(this, eventName);
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];
    await resolvedPromise;
    return Promise.all([
      ...staticListeners.map(async (listener) => {
        if (listeners.has(listener)) {
          return listener(eventData);
        }
      }),
      ...staticAnyListeners.map(async (listener) => {
        if (anyListeners.has(listener)) {
          return listener(eventName, eventData);
        }
      })
    ]);
  }
  async emitSerial(eventName, eventData) {
    assertEventName(eventName);
    const listeners = getListeners(this, eventName);
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = [...anyListeners];
    await resolvedPromise;
    for (const listener of staticListeners) {
      if (listeners.has(listener)) {
        await listener(eventData);
      }
    }
    for (const listener of staticAnyListeners) {
      if (anyListeners.has(listener)) {
        await listener(eventName, eventData);
      }
    }
  }
  onAny(listener) {
    assertListener(listener);
    anyMap.get(this).add(listener);
    this.emit(listenerAdded, { listener });
    return this.offAny.bind(this, listener);
  }
  anyEvent() {
    return iterator(this);
  }
  offAny(listener) {
    assertListener(listener);
    this.emit(listenerRemoved, { listener });
    anyMap.get(this).delete(listener);
  }
  clearListeners(eventName) {
    if (typeof eventName === "string") {
      getListeners(this, eventName).clear();
      const producers = getEventProducers(this, eventName);
      for (const producer of producers) {
        producer.finish();
      }
      producers.clear();
    } else {
      anyMap.get(this).clear();
      for (const listeners of eventsMap.get(this).values()) {
        listeners.clear();
      }
      for (const producers of producersMap.get(this).values()) {
        for (const producer of producers) {
          producer.finish();
        }
        producers.clear();
      }
    }
  }
  listenerCount(eventName) {
    if (typeof eventName === "string") {
      return anyMap.get(this).size + getListeners(this, eventName).size + getEventProducers(this, eventName).size + getEventProducers(this).size;
    }
    if (typeof eventName !== "undefined") {
      assertEventName(eventName);
    }
    let count = anyMap.get(this).size;
    for (const value of eventsMap.get(this).values()) {
      count += value.size;
    }
    for (const value of producersMap.get(this).values()) {
      count += value.size;
    }
    return count;
  }
  bindMethods(target, methodNames) {
    if (typeof target !== "object" || target === null) {
      throw new TypeError("`target` must be an object");
    }
    methodNames = defaultMethodNamesOrAssert(methodNames);
    for (const methodName of methodNames) {
      if (target[methodName] !== void 0) {
        throw new Error(`The property \`${methodName}\` already exists on \`target\``);
      }
      Object.defineProperty(target, methodName, {
        enumerable: false,
        value: this[methodName].bind(this)
      });
    }
  }
}
const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v2) => v2 !== "constructor");
Emittery.Typed = class extends Emittery {
};
Object.defineProperty(Emittery.Typed, "Typed", {
  enumerable: false,
  value: void 0
});
Object.defineProperty(Emittery, "listenerAdded", {
  value: listenerAdded,
  writable: false,
  enumerable: true,
  configurable: false
});
Object.defineProperty(Emittery, "listenerRemoved", {
  value: listenerRemoved,
  writable: false,
  enumerable: true,
  configurable: false
});
var emittery = Emittery;
const Emittery$1 = /* @__PURE__ */ getDefaultExportFromCjs(emittery);
function getRecentRevisionIds(history, cutoffDate) {
  const recentRevisionIds = /* @__PURE__ */ new Set();
  for (const [id2, revision] of Object.entries(history.revisions)) {
    if (new Date(revision.editTime).getTime() < cutoffDate.getTime()) {
      continue;
    }
    recentRevisionIds.add(id2);
  }
  while (true) {
    let changed = false;
    for (const [id2, revision] of Object.entries(history.revisions)) {
      if (!recentRevisionIds.has(id2) && revision.baseRevisionId && recentRevisionIds.has(revision.baseRevisionId)) {
        recentRevisionIds.add(id2);
        changed = true;
      }
    }
    if (!changed) {
      break;
    }
  }
  const baseRevisionIds = [];
  for (const id2 of recentRevisionIds) {
    const baseRevisionId = history.revisions[id2].baseRevisionId;
    if (baseRevisionId && !recentRevisionIds.has(baseRevisionId)) {
      baseRevisionIds.push(baseRevisionId);
    }
  }
  for (const id2 of baseRevisionIds) {
    recentRevisionIds.add(id2);
  }
  recentRevisionIds.add(history.currentRevisionId);
  return recentRevisionIds;
}
function modifyProtectedValues(content, timestamp, transform) {
  let modifiedContent = content;
  for (const [listKey, list] of Object.entries(content)) {
    for (const [elementKey, current] of Object.entries(list)) {
      const modifiedElement = Object.assign(Object.assign({}, recursivelyTransformProtectedValues(current, transform)), { updateTime: timestamp });
      modifiedContent = Object.assign(Object.assign({}, modifiedContent), { [listKey]: Object.assign(Object.assign({}, modifiedContent[listKey]), { [elementKey]: modifiedElement }) });
    }
  }
  return modifiedContent;
}
function recursivelyTransformProtectedValues(element, transform) {
  return recursivelyTransformValues(element, isProtectedValue$1, transform);
}
function recursivelyTransformUnprotectedValues(element, transform) {
  return recursivelyTransformValues(element, isUnprotectedValue, transform);
}
function recursivelyTransformValues(element, predicate, transform) {
  if (Array.isArray(element)) {
    return element.map((el2) => recursivelyTransformValues(el2, predicate, transform));
  }
  if (typeof element === "object" && element !== null) {
    if (predicate(element)) {
      return transform(element);
    }
    const transformedElement = {};
    for (const [key, value] of Object.entries(element)) {
      transformedElement[key] = recursivelyTransformValues(value, predicate, transform);
    }
    return transformedElement;
  }
  return element;
}
function isProtectedValue$1(obj) {
  return ProtectedValue.safeParse(obj).success;
}
function isUnprotectedValue(obj) {
  return UnprotectedValue.safeParse(obj).success;
}
var __rest$F = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function extractLinkedUpdateMessages(vaultId, originPersonalProfileId, preChangeContent, protectedSecretFunctions, vaultContentDiff) {
  var _a2;
  const result = [];
  for (const [loginId, modifiedLogin] of Object.entries(vaultContentDiff.logins)) {
    const preChangeLogin = preChangeContent.logins[loginId];
    if (!modifiedLogin.isDeleted && ((_a2 = modifiedLogin.linkedTo) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      const redactedLogin = __rest$F(modifiedLogin, ["history", "shareLinks"]);
      const newValues = recursivelyTransformProtectedValues(redactedLogin, (pv) => protectedSecretFunctions.unprotectWithContentId(pv));
      for (const { targetVaultId, removeTime, linkedByProfileId } of modifiedLogin.linkedTo) {
        if (targetVaultId === vaultId) {
          continue;
        }
        const removedInThisChange = removeTime === modifiedLogin.updateTime;
        let update4 = null;
        if (removedInThisChange) {
          update4 = {
            type: "originUpdated",
            loginId,
            content: { isDeleted: true, isArchived: false, updateTime: modifiedLogin.updateTime }
          };
        } else if (!removeTime) {
          update4 = {
            type: "originUpdated",
            loginId,
            content: Object.assign(Object.assign({}, newValues), { linkedTo: void 0, linkedFrom: { originVaultId: vaultId, originPersonalProfileId, linkedByProfileId }, isDeleted: false, updateTime: modifiedLogin.updateTime })
          };
        }
        if (update4) {
          result.push({
            vaultId: targetVaultId,
            type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
            message: [update4]
          });
        }
      }
    } else if (modifiedLogin.isDeleted && !!preChangeLogin) {
      if (preChangeLogin.linkedTo) {
        const update4 = {
          type: "originUpdated",
          loginId,
          content: { isDeleted: true, isArchived: false, updateTime: modifiedLogin.updateTime }
        };
        for (const { targetVaultId } of preChangeLogin.linkedTo) {
          if (targetVaultId === vaultId) {
            continue;
          }
          result.push({
            vaultId: targetVaultId,
            type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
            message: [update4]
          });
        }
      } else if (preChangeLogin.linkedFrom) {
        if (preChangeLogin.linkedFrom.originVaultId !== vaultId) {
          const update4 = {
            type: "targetDeleted",
            loginId,
            removeTime: modifiedLogin.updateTime
          };
          result.push({
            vaultId: preChangeLogin.linkedFrom.originVaultId,
            type: VaultMessageType.LINKED_LOGIN_UPDATE_V1,
            message: [update4]
          });
        }
      }
    }
  }
  return result;
}
var HeymergeErrorCode;
(function(HeymergeErrorCode2) {
  HeymergeErrorCode2[HeymergeErrorCode2["NotImplemented"] = 6000500] = "NotImplemented";
  HeymergeErrorCode2[HeymergeErrorCode2["ElementNotFound"] = 6000401] = "ElementNotFound";
  HeymergeErrorCode2[HeymergeErrorCode2["InvalidHeymergeList"] = 6000402] = "InvalidHeymergeList";
  HeymergeErrorCode2[HeymergeErrorCode2["InvalidHeymergeVaultContent"] = 6000403] = "InvalidHeymergeVaultContent";
  HeymergeErrorCode2[HeymergeErrorCode2["ElementDeleted"] = 6000404] = "ElementDeleted";
  HeymergeErrorCode2[HeymergeErrorCode2["ElementArchived"] = 6000405] = "ElementArchived";
})(HeymergeErrorCode || (HeymergeErrorCode = {}));
const pleaseUpdate = "We are investigating. In the meantime, make sure you are using the latest version of our software then try again.";
class HeymergeDomainError extends DomainError {
  constructor(code, short, userTitle, userDetail) {
    super(code, short, userTitle !== null && userTitle !== void 0 ? userTitle : short, userDetail !== null && userDetail !== void 0 ? userDetail : pleaseUpdate);
  }
}
class ElementNotFoundError extends HeymergeDomainError {
  constructor(id2) {
    super(HeymergeErrorCode.ElementNotFound, `No element with id "${id2}"!`);
  }
}
class InvalidHeymergeListError extends HeymergeDomainError {
  constructor(description) {
    super(HeymergeErrorCode.InvalidHeymergeList, `Invalid HeymergeList: "${description}"!`);
  }
}
class InvalidHeymergeVaultContentError extends HeymergeDomainError {
  constructor(description) {
    super(HeymergeErrorCode.InvalidHeymergeVaultContent, `Invalid HeymergeVaultContent: "${description}"!`);
  }
}
class ElementDeletedError extends HeymergeDomainError {
  constructor(id2) {
    super(HeymergeErrorCode.ElementDeleted, `Element with id "${id2}" has been deleted and cannot be archived or restored!`);
  }
}
class ElementArchivedError extends HeymergeDomainError {
  constructor(id2) {
    super(HeymergeErrorCode.ElementArchived, `Element with id "${id2}" has been archived and cannot be modified!`);
  }
}
var object_hash = { exports: {} };
(function(module2, exports2) {
  !function(e2) {
    module2.exports = e2();
  }(function() {
    return function o2(i, u2, a2) {
      function s2(n2, e3) {
        if (!u2[n2]) {
          if (!i[n2]) {
            var t2 = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e3 && t2)
              return t2(n2, true);
            if (f2)
              return f2(n2, true);
            throw new Error("Cannot find module '" + n2 + "'");
          }
          var r2 = u2[n2] = { exports: {} };
          i[n2][0].call(r2.exports, function(e4) {
            var t3 = i[n2][1][e4];
            return s2(t3 || e4);
          }, r2, r2.exports, o2, i, u2, a2);
        }
        return u2[n2].exports;
      }
      for (var f2 = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < a2.length; e2++)
        s2(a2[e2]);
      return s2;
    }({ 1: [function(w2, b2, m2) {
      (function(e2, t2, f2, n2, r2, o2, i, u2, a2) {
        var s2 = w2("crypto");
        function l2(e3, t3) {
          return function(e4, t4) {
            var n3;
            n3 = "passthrough" !== t4.algorithm ? s2.createHash(t4.algorithm) : new y2();
            void 0 === n3.write && (n3.write = n3.update, n3.end = n3.update);
            g2(t4, n3).dispatch(e4), n3.update || n3.end("");
            if (n3.digest)
              return n3.digest("buffer" === t4.encoding ? void 0 : t4.encoding);
            var r3 = n3.read();
            return "buffer" !== t4.encoding ? r3.toString(t4.encoding) : r3;
          }(e3, t3 = h2(e3, t3));
        }
        (m2 = b2.exports = l2).sha1 = function(e3) {
          return l2(e3);
        }, m2.keys = function(e3) {
          return l2(e3, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, m2.MD5 = function(e3) {
          return l2(e3, { algorithm: "md5", encoding: "hex" });
        }, m2.keysMD5 = function(e3) {
          return l2(e3, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var c2 = s2.getHashes ? s2.getHashes().slice() : ["sha1", "md5"];
        c2.push("passthrough");
        var d2 = ["buffer", "hex", "binary", "base64"];
        function h2(e3, t3) {
          t3 = t3 || {};
          var n3 = {};
          if (n3.algorithm = t3.algorithm || "sha1", n3.encoding = t3.encoding || "hex", n3.excludeValues = !!t3.excludeValues, n3.algorithm = n3.algorithm.toLowerCase(), n3.encoding = n3.encoding.toLowerCase(), n3.ignoreUnknown = true === t3.ignoreUnknown, n3.respectType = false !== t3.respectType, n3.respectFunctionNames = false !== t3.respectFunctionNames, n3.respectFunctionProperties = false !== t3.respectFunctionProperties, n3.unorderedArrays = true === t3.unorderedArrays, n3.unorderedSets = false !== t3.unorderedSets, n3.unorderedObjects = false !== t3.unorderedObjects, n3.replacer = t3.replacer || void 0, n3.excludeKeys = t3.excludeKeys || void 0, void 0 === e3)
            throw new Error("Object argument required.");
          for (var r3 = 0; r3 < c2.length; ++r3)
            c2[r3].toLowerCase() === n3.algorithm.toLowerCase() && (n3.algorithm = c2[r3]);
          if (-1 === c2.indexOf(n3.algorithm))
            throw new Error('Algorithm "' + n3.algorithm + '"  not supported. supported values: ' + c2.join(", "));
          if (-1 === d2.indexOf(n3.encoding) && "passthrough" !== n3.algorithm)
            throw new Error('Encoding "' + n3.encoding + '"  not supported. supported values: ' + d2.join(", "));
          return n3;
        }
        function p2(e3) {
          if ("function" == typeof e3) {
            return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e3));
          }
        }
        function g2(u3, t3, a3) {
          a3 = a3 || [];
          function s3(e3) {
            return t3.update ? t3.update(e3, "utf8") : t3.write(e3, "utf8");
          }
          return { dispatch: function(e3) {
            return u3.replacer && (e3 = u3.replacer(e3)), this["_" + (null === e3 ? "null" : typeof e3)](e3);
          }, _object: function(t4) {
            var e3 = Object.prototype.toString.call(t4), n3 = /\[object (.*)\]/i.exec(e3);
            n3 = (n3 = n3 ? n3[1] : "unknown:[" + e3 + "]").toLowerCase();
            var r3;
            if (0 <= (r3 = a3.indexOf(t4)))
              return this.dispatch("[CIRCULAR:" + r3 + "]");
            if (a3.push(t4), void 0 !== f2 && f2.isBuffer && f2.isBuffer(t4))
              return s3("buffer:"), s3(t4);
            if ("object" === n3 || "function" === n3 || "asyncfunction" === n3) {
              var o3 = Object.keys(t4);
              u3.unorderedObjects && (o3 = o3.sort()), false === u3.respectType || p2(t4) || o3.splice(0, 0, "prototype", "__proto__", "constructor"), u3.excludeKeys && (o3 = o3.filter(function(e4) {
                return !u3.excludeKeys(e4);
              })), s3("object:" + o3.length + ":");
              var i2 = this;
              return o3.forEach(function(e4) {
                i2.dispatch(e4), s3(":"), u3.excludeValues || i2.dispatch(t4[e4]), s3(",");
              });
            }
            if (!this["_" + n3]) {
              if (u3.ignoreUnknown)
                return s3("[" + n3 + "]");
              throw new Error('Unknown object type "' + n3 + '"');
            }
            this["_" + n3](t4);
          }, _array: function(e3, t4) {
            t4 = void 0 !== t4 ? t4 : false !== u3.unorderedArrays;
            var n3 = this;
            if (s3("array:" + e3.length + ":"), !t4 || e3.length <= 1)
              return e3.forEach(function(e4) {
                return n3.dispatch(e4);
              });
            var r3 = [], o3 = e3.map(function(e4) {
              var t5 = new y2(), n4 = a3.slice();
              return g2(u3, t5, n4).dispatch(e4), r3 = r3.concat(n4.slice(a3.length)), t5.read().toString();
            });
            return a3 = a3.concat(r3), o3.sort(), this._array(o3, false);
          }, _date: function(e3) {
            return s3("date:" + e3.toJSON());
          }, _symbol: function(e3) {
            return s3("symbol:" + e3.toString());
          }, _error: function(e3) {
            return s3("error:" + e3.toString());
          }, _boolean: function(e3) {
            return s3("bool:" + e3.toString());
          }, _string: function(e3) {
            s3("string:" + e3.length + ":"), s3(e3.toString());
          }, _function: function(e3) {
            s3("fn:"), p2(e3) ? this.dispatch("[native]") : this.dispatch(e3.toString()), false !== u3.respectFunctionNames && this.dispatch("function-name:" + String(e3.name)), u3.respectFunctionProperties && this._object(e3);
          }, _number: function(e3) {
            return s3("number:" + e3.toString());
          }, _xml: function(e3) {
            return s3("xml:" + e3.toString());
          }, _null: function() {
            return s3("Null");
          }, _undefined: function() {
            return s3("Undefined");
          }, _regexp: function(e3) {
            return s3("regex:" + e3.toString());
          }, _uint8array: function(e3) {
            return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _uint8clampedarray: function(e3) {
            return s3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _int8array: function(e3) {
            return s3("uint8array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _uint16array: function(e3) {
            return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _int16array: function(e3) {
            return s3("uint16array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _uint32array: function(e3) {
            return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _int32array: function(e3) {
            return s3("uint32array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _float32array: function(e3) {
            return s3("float32array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _float64array: function(e3) {
            return s3("float64array:"), this.dispatch(Array.prototype.slice.call(e3));
          }, _arraybuffer: function(e3) {
            return s3("arraybuffer:"), this.dispatch(new Uint8Array(e3));
          }, _url: function(e3) {
            return s3("url:" + e3.toString());
          }, _map: function(e3) {
            s3("map:");
            var t4 = Array.from(e3);
            return this._array(t4, false !== u3.unorderedSets);
          }, _set: function(e3) {
            s3("set:");
            var t4 = Array.from(e3);
            return this._array(t4, false !== u3.unorderedSets);
          }, _file: function(e3) {
            return s3("file:"), this.dispatch([e3.name, e3.size, e3.type, e3.lastModfied]);
          }, _blob: function() {
            if (u3.ignoreUnknown)
              return s3("[blob]");
            throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
          }, _domwindow: function() {
            return s3("domwindow");
          }, _process: function() {
            return s3("process");
          }, _timer: function() {
            return s3("timer");
          }, _pipe: function() {
            return s3("pipe");
          }, _tcp: function() {
            return s3("tcp");
          }, _udp: function() {
            return s3("udp");
          }, _tty: function() {
            return s3("tty");
          }, _statwatcher: function() {
            return s3("statwatcher");
          }, _securecontext: function() {
            return s3("securecontext");
          }, _connection: function() {
            return s3("connection");
          }, _zlib: function() {
            return s3("zlib");
          }, _context: function() {
            return s3("context");
          }, _nodescript: function() {
            return s3("nodescript");
          }, _httpparser: function() {
            return s3("httpparser");
          }, _dataview: function() {
            return s3("dataview");
          }, _signal: function() {
            return s3("signal");
          }, _fsevent: function() {
            return s3("fsevent");
          }, _tlswrap: function() {
            return s3("tlswrap");
          } };
        }
        function y2() {
          return { buf: "", write: function(e3) {
            this.buf += e3;
          }, end: function(e3) {
            this.buf += e3;
          }, read: function() {
            return this.buf;
          } };
        }
        m2.writeToStream = function(e3, t3, n3) {
          return void 0 === n3 && (n3 = t3, t3 = {}), g2(t3 = h2(e3, t3), n3).dispatch(e3);
        };
      }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_5812b7fb.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 10 }], 2: [function(e2, t2, f2) {
      (function(e3, t3, n2, r2, o2, i, u2, a2, s2) {
        !function(e4) {
          var f3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, n3 = "+".charCodeAt(0), r3 = "/".charCodeAt(0), o3 = "0".charCodeAt(0), i2 = "a".charCodeAt(0), u3 = "A".charCodeAt(0), a3 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
          function l2(e5) {
            var t4 = e5.charCodeAt(0);
            return t4 === n3 || t4 === a3 ? 62 : t4 === r3 || t4 === s3 ? 63 : t4 < o3 ? -1 : t4 < o3 + 10 ? t4 - o3 + 26 + 26 : t4 < u3 + 26 ? t4 - u3 : t4 < i2 + 26 ? t4 - i2 + 26 : void 0;
          }
          e4.toByteArray = function(e5) {
            var t4, n4;
            if (0 < e5.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r4 = e5.length, o4 = "=" === e5.charAt(r4 - 2) ? 2 : "=" === e5.charAt(r4 - 1) ? 1 : 0, i3 = new f3(3 * e5.length / 4 - o4), u4 = 0 < o4 ? e5.length - 4 : e5.length, a4 = 0;
            function s4(e6) {
              i3[a4++] = e6;
            }
            for (t4 = 0; t4 < u4; t4 += 4, 0)
              s4((16711680 & (n4 = l2(e5.charAt(t4)) << 18 | l2(e5.charAt(t4 + 1)) << 12 | l2(e5.charAt(t4 + 2)) << 6 | l2(e5.charAt(t4 + 3)))) >> 16), s4((65280 & n4) >> 8), s4(255 & n4);
            return 2 == o4 ? s4(255 & (n4 = l2(e5.charAt(t4)) << 2 | l2(e5.charAt(t4 + 1)) >> 4)) : 1 == o4 && (s4((n4 = l2(e5.charAt(t4)) << 10 | l2(e5.charAt(t4 + 1)) << 4 | l2(e5.charAt(t4 + 2)) >> 2) >> 8 & 255), s4(255 & n4)), i3;
          }, e4.fromByteArray = function(e5) {
            var t4, n4, r4, o4, i3 = e5.length % 3, u4 = "";
            function a4(e6) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e6);
            }
            for (t4 = 0, r4 = e5.length - i3; t4 < r4; t4 += 3)
              n4 = (e5[t4] << 16) + (e5[t4 + 1] << 8) + e5[t4 + 2], u4 += a4((o4 = n4) >> 18 & 63) + a4(o4 >> 12 & 63) + a4(o4 >> 6 & 63) + a4(63 & o4);
            switch (i3) {
              case 1:
                u4 += a4((n4 = e5[e5.length - 1]) >> 2), u4 += a4(n4 << 4 & 63), u4 += "==";
                break;
              case 2:
                u4 += a4((n4 = (e5[e5.length - 2] << 8) + e5[e5.length - 1]) >> 10), u4 += a4(n4 >> 4 & 63), u4 += a4(n4 << 2 & 63), u4 += "=";
            }
            return u4;
          };
        }(void 0 === f2 ? this.base64js = {} : f2);
      }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 10 }], 3: [function(O2, e2, H2) {
      (function(e3, t2, g2, n2, r2, o2, i, u2, a2) {
        var s2 = O2("base64-js"), f2 = O2("ieee754");
        function g2(e4, t3, n3) {
          if (!(this instanceof g2))
            return new g2(e4, t3, n3);
          var r3, o3, i2, u3, a3, s3 = typeof e4;
          if ("base64" === t3 && "string" == s3)
            for (e4 = (r3 = e4).trim ? r3.trim() : r3.replace(/^\s+|\s+$/g, ""); e4.length % 4 != 0; )
              e4 += "=";
          if ("number" == s3)
            o3 = x(e4);
          else if ("string" == s3)
            o3 = g2.byteLength(e4, t3);
          else {
            if ("object" != s3)
              throw new Error("First argument needs to be a number, array or string.");
            o3 = x(e4.length);
          }
          if (g2._useTypedArrays ? i2 = g2._augment(new Uint8Array(o3)) : ((i2 = this).length = o3, i2._isBuffer = true), g2._useTypedArrays && "number" == typeof e4.byteLength)
            i2._set(e4);
          else if (S2(a3 = e4) || g2.isBuffer(a3) || a3 && "object" == typeof a3 && "number" == typeof a3.length)
            for (u3 = 0; u3 < o3; u3++)
              g2.isBuffer(e4) ? i2[u3] = e4.readUInt8(u3) : i2[u3] = e4[u3];
          else if ("string" == s3)
            i2.write(e4, 0, t3);
          else if ("number" == s3 && !g2._useTypedArrays && !n3)
            for (u3 = 0; u3 < o3; u3++)
              i2[u3] = 0;
          return i2;
        }
        function y2(e4, t3, n3, r3) {
          return g2._charsWritten = T2(function(e5) {
            for (var t4 = [], n4 = 0; n4 < e5.length; n4++)
              t4.push(255 & e5.charCodeAt(n4));
            return t4;
          }(t3), e4, n3, r3);
        }
        function w2(e4, t3, n3, r3) {
          return g2._charsWritten = T2(function(e5) {
            for (var t4, n4, r4, o3 = [], i2 = 0; i2 < e5.length; i2++)
              t4 = e5.charCodeAt(i2), n4 = t4 >> 8, r4 = t4 % 256, o3.push(r4), o3.push(n4);
            return o3;
          }(t3), e4, n3, r3);
        }
        function l2(e4, t3, n3) {
          var r3 = "";
          n3 = Math.min(e4.length, n3);
          for (var o3 = t3; o3 < n3; o3++)
            r3 += String.fromCharCode(e4[o3]);
          return r3;
        }
        function c2(e4, t3, n3, r3) {
          r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 1 < e4.length, "Trying to read beyond buffer length"));
          var o3, i2 = e4.length;
          if (!(i2 <= t3))
            return n3 ? (o3 = e4[t3], t3 + 1 < i2 && (o3 |= e4[t3 + 1] << 8)) : (o3 = e4[t3] << 8, t3 + 1 < i2 && (o3 |= e4[t3 + 1])), o3;
        }
        function d2(e4, t3, n3, r3) {
          r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 3 < e4.length, "Trying to read beyond buffer length"));
          var o3, i2 = e4.length;
          if (!(i2 <= t3))
            return n3 ? (t3 + 2 < i2 && (o3 = e4[t3 + 2] << 16), t3 + 1 < i2 && (o3 |= e4[t3 + 1] << 8), o3 |= e4[t3], t3 + 3 < i2 && (o3 += e4[t3 + 3] << 24 >>> 0)) : (t3 + 1 < i2 && (o3 = e4[t3 + 1] << 16), t3 + 2 < i2 && (o3 |= e4[t3 + 2] << 8), t3 + 3 < i2 && (o3 |= e4[t3 + 3]), o3 += e4[t3] << 24 >>> 0), o3;
        }
        function h2(e4, t3, n3, r3) {
          if (r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 1 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) {
            var o3 = c2(e4, t3, n3, true);
            return 32768 & o3 ? -1 * (65535 - o3 + 1) : o3;
          }
        }
        function p2(e4, t3, n3, r3) {
          if (r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(null != t3, "missing offset"), D2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), !(e4.length <= t3)) {
            var o3 = d2(e4, t3, n3, true);
            return 2147483648 & o3 ? -1 * (4294967295 - o3 + 1) : o3;
          }
        }
        function b2(e4, t3, n3, r3) {
          return r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(t3 + 3 < e4.length, "Trying to read beyond buffer length")), f2.read(e4, t3, n3, 23, 4);
        }
        function m2(e4, t3, n3, r3) {
          return r3 || (D2("boolean" == typeof n3, "missing or invalid endian"), D2(t3 + 7 < e4.length, "Trying to read beyond buffer length")), f2.read(e4, t3, n3, 52, 8);
        }
        function v2(e4, t3, n3, r3, o3) {
          o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 1 < e4.length, "trying to write beyond buffer length"), N2(t3, 65535));
          var i2 = e4.length;
          if (!(i2 <= n3))
            for (var u3 = 0, a3 = Math.min(i2 - n3, 2); u3 < a3; u3++)
              e4[n3 + u3] = (t3 & 255 << 8 * (r3 ? u3 : 1 - u3)) >>> 8 * (r3 ? u3 : 1 - u3);
        }
        function _2(e4, t3, n3, r3, o3) {
          o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 3 < e4.length, "trying to write beyond buffer length"), N2(t3, 4294967295));
          var i2 = e4.length;
          if (!(i2 <= n3))
            for (var u3 = 0, a3 = Math.min(i2 - n3, 4); u3 < a3; u3++)
              e4[n3 + u3] = t3 >>> 8 * (r3 ? u3 : 3 - u3) & 255;
        }
        function E2(e4, t3, n3, r3, o3) {
          o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 1 < e4.length, "Trying to write beyond buffer length"), Y2(t3, 32767, -32768)), e4.length <= n3 || v2(e4, 0 <= t3 ? t3 : 65535 + t3 + 1, n3, r3, o3);
        }
        function I2(e4, t3, n3, r3, o3) {
          o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 3 < e4.length, "Trying to write beyond buffer length"), Y2(t3, 2147483647, -2147483648)), e4.length <= n3 || _2(e4, 0 <= t3 ? t3 : 4294967295 + t3 + 1, n3, r3, o3);
        }
        function A2(e4, t3, n3, r3, o3) {
          o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 3 < e4.length, "Trying to write beyond buffer length"), F2(t3, 34028234663852886e22, -34028234663852886e22)), e4.length <= n3 || f2.write(e4, t3, n3, r3, 23, 4);
        }
        function B2(e4, t3, n3, r3, o3) {
          o3 || (D2(null != t3, "missing value"), D2("boolean" == typeof r3, "missing or invalid endian"), D2(null != n3, "missing offset"), D2(n3 + 7 < e4.length, "Trying to write beyond buffer length"), F2(t3, 17976931348623157e292, -17976931348623157e292)), e4.length <= n3 || f2.write(e4, t3, n3, r3, 52, 8);
        }
        H2.Buffer = g2, H2.SlowBuffer = g2, H2.INSPECT_MAX_BYTES = 50, g2.poolSize = 8192, g2._useTypedArrays = function() {
          try {
            var e4 = new ArrayBuffer(0), t3 = new Uint8Array(e4);
            return t3.foo = function() {
              return 42;
            }, 42 === t3.foo() && "function" == typeof t3.subarray;
          } catch (e5) {
            return false;
          }
        }(), g2.isEncoding = function(e4) {
          switch (String(e4).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, g2.isBuffer = function(e4) {
          return !(null == e4 || !e4._isBuffer);
        }, g2.byteLength = function(e4, t3) {
          var n3;
          switch (e4 += "", t3 || "utf8") {
            case "hex":
              n3 = e4.length / 2;
              break;
            case "utf8":
            case "utf-8":
              n3 = C2(e4).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              n3 = e4.length;
              break;
            case "base64":
              n3 = k2(e4).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              n3 = 2 * e4.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return n3;
        }, g2.concat = function(e4, t3) {
          if (D2(S2(e4), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e4.length)
            return new g2(0);
          if (1 === e4.length)
            return e4[0];
          if ("number" != typeof t3)
            for (o3 = t3 = 0; o3 < e4.length; o3++)
              t3 += e4[o3].length;
          for (var n3 = new g2(t3), r3 = 0, o3 = 0; o3 < e4.length; o3++) {
            var i2 = e4[o3];
            i2.copy(n3, r3), r3 += i2.length;
          }
          return n3;
        }, g2.prototype.write = function(e4, t3, n3, r3) {
          var o3;
          isFinite(t3) ? isFinite(n3) || (r3 = n3, n3 = void 0) : (o3 = r3, r3 = t3, t3 = n3, n3 = o3), t3 = Number(t3) || 0;
          var i2, u3, a3, s3, f3, l3, c3, d3, h3, p3 = this.length - t3;
          switch ((!n3 || p3 < (n3 = Number(n3))) && (n3 = p3), r3 = String(r3 || "utf8").toLowerCase()) {
            case "hex":
              i2 = function(e5, t4, n4, r4) {
                n4 = Number(n4) || 0;
                var o4 = e5.length - n4;
                (!r4 || o4 < (r4 = Number(r4))) && (r4 = o4);
                var i3 = t4.length;
                D2(i3 % 2 == 0, "Invalid hex string"), i3 / 2 < r4 && (r4 = i3 / 2);
                for (var u4 = 0; u4 < r4; u4++) {
                  var a4 = parseInt(t4.substr(2 * u4, 2), 16);
                  D2(!isNaN(a4), "Invalid hex string"), e5[n4 + u4] = a4;
                }
                return g2._charsWritten = 2 * u4, u4;
              }(this, e4, t3, n3);
              break;
            case "utf8":
            case "utf-8":
              l3 = this, c3 = e4, d3 = t3, h3 = n3, i2 = g2._charsWritten = T2(C2(c3), l3, d3, h3);
              break;
            case "ascii":
            case "binary":
              i2 = y2(this, e4, t3, n3);
              break;
            case "base64":
              u3 = this, a3 = e4, s3 = t3, f3 = n3, i2 = g2._charsWritten = T2(k2(a3), u3, s3, f3);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              i2 = w2(this, e4, t3, n3);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return i2;
        }, g2.prototype.toString = function(e4, t3, n3) {
          var r3, o3, i2, u3, a3 = this;
          if (e4 = String(e4 || "utf8").toLowerCase(), t3 = Number(t3) || 0, (n3 = void 0 !== n3 ? Number(n3) : n3 = a3.length) === t3)
            return "";
          switch (e4) {
            case "hex":
              r3 = function(e5, t4, n4) {
                var r4 = e5.length;
                (!t4 || t4 < 0) && (t4 = 0);
                (!n4 || n4 < 0 || r4 < n4) && (n4 = r4);
                for (var o4 = "", i3 = t4; i3 < n4; i3++)
                  o4 += j(e5[i3]);
                return o4;
              }(a3, t3, n3);
              break;
            case "utf8":
            case "utf-8":
              r3 = function(e5, t4, n4) {
                var r4 = "", o4 = "";
                n4 = Math.min(e5.length, n4);
                for (var i3 = t4; i3 < n4; i3++)
                  e5[i3] <= 127 ? (r4 += M2(o4) + String.fromCharCode(e5[i3]), o4 = "") : o4 += "%" + e5[i3].toString(16);
                return r4 + M2(o4);
              }(a3, t3, n3);
              break;
            case "ascii":
            case "binary":
              r3 = l2(a3, t3, n3);
              break;
            case "base64":
              o3 = a3, u3 = n3, r3 = 0 === (i2 = t3) && u3 === o3.length ? s2.fromByteArray(o3) : s2.fromByteArray(o3.slice(i2, u3));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              r3 = function(e5, t4, n4) {
                for (var r4 = e5.slice(t4, n4), o4 = "", i3 = 0; i3 < r4.length; i3 += 2)
                  o4 += String.fromCharCode(r4[i3] + 256 * r4[i3 + 1]);
                return o4;
              }(a3, t3, n3);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return r3;
        }, g2.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, g2.prototype.copy = function(e4, t3, n3, r3) {
          if (n3 = n3 || 0, r3 || 0 === r3 || (r3 = this.length), t3 = t3 || 0, r3 !== n3 && 0 !== e4.length && 0 !== this.length) {
            D2(n3 <= r3, "sourceEnd < sourceStart"), D2(0 <= t3 && t3 < e4.length, "targetStart out of bounds"), D2(0 <= n3 && n3 < this.length, "sourceStart out of bounds"), D2(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length), e4.length - t3 < r3 - n3 && (r3 = e4.length - t3 + n3);
            var o3 = r3 - n3;
            if (o3 < 100 || !g2._useTypedArrays)
              for (var i2 = 0; i2 < o3; i2++)
                e4[i2 + t3] = this[i2 + n3];
            else
              e4._set(this.subarray(n3, n3 + o3), t3);
          }
        }, g2.prototype.slice = function(e4, t3) {
          var n3 = this.length;
          if (e4 = U2(e4, n3, 0), t3 = U2(t3, n3, n3), g2._useTypedArrays)
            return g2._augment(this.subarray(e4, t3));
          for (var r3 = t3 - e4, o3 = new g2(r3, void 0, true), i2 = 0; i2 < r3; i2++)
            o3[i2] = this[i2 + e4];
          return o3;
        }, g2.prototype.get = function(e4) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e4);
        }, g2.prototype.set = function(e4, t3) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e4, t3);
        }, g2.prototype.readUInt8 = function(e4, t3) {
          if (t3 || (D2(null != e4, "missing offset"), D2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length))
            return this[e4];
        }, g2.prototype.readUInt16LE = function(e4, t3) {
          return c2(this, e4, true, t3);
        }, g2.prototype.readUInt16BE = function(e4, t3) {
          return c2(this, e4, false, t3);
        }, g2.prototype.readUInt32LE = function(e4, t3) {
          return d2(this, e4, true, t3);
        }, g2.prototype.readUInt32BE = function(e4, t3) {
          return d2(this, e4, false, t3);
        }, g2.prototype.readInt8 = function(e4, t3) {
          if (t3 || (D2(null != e4, "missing offset"), D2(e4 < this.length, "Trying to read beyond buffer length")), !(e4 >= this.length))
            return 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
        }, g2.prototype.readInt16LE = function(e4, t3) {
          return h2(this, e4, true, t3);
        }, g2.prototype.readInt16BE = function(e4, t3) {
          return h2(this, e4, false, t3);
        }, g2.prototype.readInt32LE = function(e4, t3) {
          return p2(this, e4, true, t3);
        }, g2.prototype.readInt32BE = function(e4, t3) {
          return p2(this, e4, false, t3);
        }, g2.prototype.readFloatLE = function(e4, t3) {
          return b2(this, e4, true, t3);
        }, g2.prototype.readFloatBE = function(e4, t3) {
          return b2(this, e4, false, t3);
        }, g2.prototype.readDoubleLE = function(e4, t3) {
          return m2(this, e4, true, t3);
        }, g2.prototype.readDoubleBE = function(e4, t3) {
          return m2(this, e4, false, t3);
        }, g2.prototype.writeUInt8 = function(e4, t3, n3) {
          n3 || (D2(null != e4, "missing value"), D2(null != t3, "missing offset"), D2(t3 < this.length, "trying to write beyond buffer length"), N2(e4, 255)), t3 >= this.length || (this[t3] = e4);
        }, g2.prototype.writeUInt16LE = function(e4, t3, n3) {
          v2(this, e4, t3, true, n3);
        }, g2.prototype.writeUInt16BE = function(e4, t3, n3) {
          v2(this, e4, t3, false, n3);
        }, g2.prototype.writeUInt32LE = function(e4, t3, n3) {
          _2(this, e4, t3, true, n3);
        }, g2.prototype.writeUInt32BE = function(e4, t3, n3) {
          _2(this, e4, t3, false, n3);
        }, g2.prototype.writeInt8 = function(e4, t3, n3) {
          n3 || (D2(null != e4, "missing value"), D2(null != t3, "missing offset"), D2(t3 < this.length, "Trying to write beyond buffer length"), Y2(e4, 127, -128)), t3 >= this.length || (0 <= e4 ? this.writeUInt8(e4, t3, n3) : this.writeUInt8(255 + e4 + 1, t3, n3));
        }, g2.prototype.writeInt16LE = function(e4, t3, n3) {
          E2(this, e4, t3, true, n3);
        }, g2.prototype.writeInt16BE = function(e4, t3, n3) {
          E2(this, e4, t3, false, n3);
        }, g2.prototype.writeInt32LE = function(e4, t3, n3) {
          I2(this, e4, t3, true, n3);
        }, g2.prototype.writeInt32BE = function(e4, t3, n3) {
          I2(this, e4, t3, false, n3);
        }, g2.prototype.writeFloatLE = function(e4, t3, n3) {
          A2(this, e4, t3, true, n3);
        }, g2.prototype.writeFloatBE = function(e4, t3, n3) {
          A2(this, e4, t3, false, n3);
        }, g2.prototype.writeDoubleLE = function(e4, t3, n3) {
          B2(this, e4, t3, true, n3);
        }, g2.prototype.writeDoubleBE = function(e4, t3, n3) {
          B2(this, e4, t3, false, n3);
        }, g2.prototype.fill = function(e4, t3, n3) {
          if (e4 = e4 || 0, t3 = t3 || 0, n3 = n3 || this.length, "string" == typeof e4 && (e4 = e4.charCodeAt(0)), D2("number" == typeof e4 && !isNaN(e4), "value is not a number"), D2(t3 <= n3, "end < start"), n3 !== t3 && 0 !== this.length) {
            D2(0 <= t3 && t3 < this.length, "start out of bounds"), D2(0 <= n3 && n3 <= this.length, "end out of bounds");
            for (var r3 = t3; r3 < n3; r3++)
              this[r3] = e4;
          }
        }, g2.prototype.inspect = function() {
          for (var e4 = [], t3 = this.length, n3 = 0; n3 < t3; n3++)
            if (e4[n3] = j(this[n3]), n3 === H2.INSPECT_MAX_BYTES) {
              e4[n3 + 1] = "...";
              break;
            }
          return "<Buffer " + e4.join(" ") + ">";
        }, g2.prototype.toArrayBuffer = function() {
          if ("undefined" == typeof Uint8Array)
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (g2._useTypedArrays)
            return new g2(this).buffer;
          for (var e4 = new Uint8Array(this.length), t3 = 0, n3 = e4.length; t3 < n3; t3 += 1)
            e4[t3] = this[t3];
          return e4.buffer;
        };
        var L2 = g2.prototype;
        function U2(e4, t3, n3) {
          return "number" != typeof e4 ? n3 : t3 <= (e4 = ~~e4) ? t3 : 0 <= e4 || 0 <= (e4 += t3) ? e4 : 0;
        }
        function x(e4) {
          return (e4 = ~~Math.ceil(+e4)) < 0 ? 0 : e4;
        }
        function S2(e4) {
          return (Array.isArray || function(e5) {
            return "[object Array]" === Object.prototype.toString.call(e5);
          })(e4);
        }
        function j(e4) {
          return e4 < 16 ? "0" + e4.toString(16) : e4.toString(16);
        }
        function C2(e4) {
          for (var t3 = [], n3 = 0; n3 < e4.length; n3++) {
            var r3 = e4.charCodeAt(n3);
            if (r3 <= 127)
              t3.push(e4.charCodeAt(n3));
            else {
              var o3 = n3;
              55296 <= r3 && r3 <= 57343 && n3++;
              for (var i2 = encodeURIComponent(e4.slice(o3, n3 + 1)).substr(1).split("%"), u3 = 0; u3 < i2.length; u3++)
                t3.push(parseInt(i2[u3], 16));
            }
          }
          return t3;
        }
        function k2(e4) {
          return s2.toByteArray(e4);
        }
        function T2(e4, t3, n3, r3) {
          for (var o3 = 0; o3 < r3 && !(o3 + n3 >= t3.length || o3 >= e4.length); o3++)
            t3[o3 + n3] = e4[o3];
          return o3;
        }
        function M2(e4) {
          try {
            return decodeURIComponent(e4);
          } catch (e5) {
            return String.fromCharCode(65533);
          }
        }
        function N2(e4, t3) {
          D2("number" == typeof e4, "cannot write a non-number as a number"), D2(0 <= e4, "specified a negative value for writing an unsigned value"), D2(e4 <= t3, "value is larger than maximum value for type"), D2(Math.floor(e4) === e4, "value has a fractional component");
        }
        function Y2(e4, t3, n3) {
          D2("number" == typeof e4, "cannot write a non-number as a number"), D2(e4 <= t3, "value larger than maximum allowed value"), D2(n3 <= e4, "value smaller than minimum allowed value"), D2(Math.floor(e4) === e4, "value has a fractional component");
        }
        function F2(e4, t3, n3) {
          D2("number" == typeof e4, "cannot write a non-number as a number"), D2(e4 <= t3, "value larger than maximum allowed value"), D2(n3 <= e4, "value smaller than minimum allowed value");
        }
        function D2(e4, t3) {
          if (!e4)
            throw new Error(t3 || "Failed assertion");
        }
        g2._augment = function(e4) {
          return e4._isBuffer = true, e4._get = e4.get, e4._set = e4.set, e4.get = L2.get, e4.set = L2.set, e4.write = L2.write, e4.toString = L2.toString, e4.toLocaleString = L2.toString, e4.toJSON = L2.toJSON, e4.copy = L2.copy, e4.slice = L2.slice, e4.readUInt8 = L2.readUInt8, e4.readUInt16LE = L2.readUInt16LE, e4.readUInt16BE = L2.readUInt16BE, e4.readUInt32LE = L2.readUInt32LE, e4.readUInt32BE = L2.readUInt32BE, e4.readInt8 = L2.readInt8, e4.readInt16LE = L2.readInt16LE, e4.readInt16BE = L2.readInt16BE, e4.readInt32LE = L2.readInt32LE, e4.readInt32BE = L2.readInt32BE, e4.readFloatLE = L2.readFloatLE, e4.readFloatBE = L2.readFloatBE, e4.readDoubleLE = L2.readDoubleLE, e4.readDoubleBE = L2.readDoubleBE, e4.writeUInt8 = L2.writeUInt8, e4.writeUInt16LE = L2.writeUInt16LE, e4.writeUInt16BE = L2.writeUInt16BE, e4.writeUInt32LE = L2.writeUInt32LE, e4.writeUInt32BE = L2.writeUInt32BE, e4.writeInt8 = L2.writeInt8, e4.writeInt16LE = L2.writeInt16LE, e4.writeInt16BE = L2.writeInt16BE, e4.writeInt32LE = L2.writeInt32LE, e4.writeInt32BE = L2.writeInt32BE, e4.writeFloatLE = L2.writeFloatLE, e4.writeFloatBE = L2.writeFloatBE, e4.writeDoubleLE = L2.writeDoubleLE, e4.writeDoubleBE = L2.writeDoubleBE, e4.fill = L2.fill, e4.inspect = L2.inspect, e4.toArrayBuffer = L2.toArrayBuffer, e4;
        };
      }).call(this, O2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 11, lYpoI2: 10 }], 4: [function(c2, d2, e2) {
      (function(e3, t2, u2, n2, r2, o2, i, a2, s2) {
        var u2 = c2("buffer").Buffer, f2 = 4, l2 = new u2(f2);
        l2.fill(0);
        d2.exports = { hash: function(e4, t3, n3, r3) {
          return u2.isBuffer(e4) || (e4 = new u2(e4)), function(e5, t4, n4) {
            for (var r4 = new u2(t4), o3 = n4 ? r4.writeInt32BE : r4.writeInt32LE, i2 = 0; i2 < e5.length; i2++)
              o3.call(r4, e5[i2], 4 * i2, true);
            return r4;
          }(t3(function(e5, t4) {
            var n4;
            e5.length % f2 != 0 && (n4 = e5.length + (f2 - e5.length % f2), e5 = u2.concat([e5, l2], n4));
            for (var r4 = [], o3 = t4 ? e5.readInt32BE : e5.readInt32LE, i2 = 0; i2 < e5.length; i2 += f2)
              r4.push(o3.call(e5, i2));
            return r4;
          }(e4, r3), 8 * e4.length), n3, r3);
        } };
      }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 10 }], 5: [function(w2, e2, b2) {
      (function(e3, t2, a2, n2, r2, o2, i, u2, s2) {
        var a2 = w2("buffer").Buffer, f2 = w2("./sha"), l2 = w2("./sha256"), c2 = w2("./rng"), d2 = { sha1: f2, sha256: l2, md5: w2("./md5") }, h2 = 64, p2 = new a2(h2);
        function g2(e4, r3) {
          var o3 = d2[e4 = e4 || "sha1"], i2 = [];
          return o3 || y2("algorithm:", e4, "is not yet supported"), { update: function(e5) {
            return a2.isBuffer(e5) || (e5 = new a2(e5)), i2.push(e5), e5.length, this;
          }, digest: function(e5) {
            var t3 = a2.concat(i2), n3 = r3 ? function(e6, t4, n4) {
              a2.isBuffer(t4) || (t4 = new a2(t4)), a2.isBuffer(n4) || (n4 = new a2(n4)), t4.length > h2 ? t4 = e6(t4) : t4.length < h2 && (t4 = a2.concat([t4, p2], h2));
              for (var r4 = new a2(h2), o4 = new a2(h2), i3 = 0; i3 < h2; i3++)
                r4[i3] = 54 ^ t4[i3], o4[i3] = 92 ^ t4[i3];
              var u3 = e6(a2.concat([r4, n4]));
              return e6(a2.concat([o4, u3]));
            }(o3, r3, t3) : o3(t3);
            return i2 = null, e5 ? n3.toString(e5) : n3;
          } };
        }
        function y2() {
          var e4 = [].slice.call(arguments).join(" ");
          throw new Error([e4, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
        }
        p2.fill(0), b2.createHash = function(e4) {
          return g2(e4);
        }, b2.createHmac = g2, b2.randomBytes = function(e4, t3) {
          if (!t3 || !t3.call)
            return new a2(c2(e4));
          try {
            t3.call(this, void 0, new a2(c2(e4)));
          } catch (e5) {
            t3(e5);
          }
        }, function(e4, t3) {
          for (var n3 in e4)
            t3(e4[n3], n3);
        }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function(e4) {
          b2[e4] = function() {
            y2("sorry,", e4, "is not implemented yet");
          };
        });
      }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 10 }], 6: [function(w2, b2, e2) {
      (function(e3, t2, n2, r2, o2, i, u2, a2, s2) {
        var f2 = w2("./helpers");
        function l2(e4, t3) {
          e4[t3 >> 5] |= 128 << t3 % 32, e4[14 + (t3 + 64 >>> 9 << 4)] = t3;
          for (var n3 = 1732584193, r3 = -271733879, o3 = -1732584194, i2 = 271733878, u3 = 0; u3 < e4.length; u3 += 16) {
            var a3 = n3, s3 = r3, f3 = o3, l3 = i2, n3 = d2(n3, r3, o3, i2, e4[u3 + 0], 7, -680876936), i2 = d2(i2, n3, r3, o3, e4[u3 + 1], 12, -389564586), o3 = d2(o3, i2, n3, r3, e4[u3 + 2], 17, 606105819), r3 = d2(r3, o3, i2, n3, e4[u3 + 3], 22, -1044525330);
            n3 = d2(n3, r3, o3, i2, e4[u3 + 4], 7, -176418897), i2 = d2(i2, n3, r3, o3, e4[u3 + 5], 12, 1200080426), o3 = d2(o3, i2, n3, r3, e4[u3 + 6], 17, -1473231341), r3 = d2(r3, o3, i2, n3, e4[u3 + 7], 22, -45705983), n3 = d2(n3, r3, o3, i2, e4[u3 + 8], 7, 1770035416), i2 = d2(i2, n3, r3, o3, e4[u3 + 9], 12, -1958414417), o3 = d2(o3, i2, n3, r3, e4[u3 + 10], 17, -42063), r3 = d2(r3, o3, i2, n3, e4[u3 + 11], 22, -1990404162), n3 = d2(n3, r3, o3, i2, e4[u3 + 12], 7, 1804603682), i2 = d2(i2, n3, r3, o3, e4[u3 + 13], 12, -40341101), o3 = d2(o3, i2, n3, r3, e4[u3 + 14], 17, -1502002290), n3 = h2(n3, r3 = d2(r3, o3, i2, n3, e4[u3 + 15], 22, 1236535329), o3, i2, e4[u3 + 1], 5, -165796510), i2 = h2(i2, n3, r3, o3, e4[u3 + 6], 9, -1069501632), o3 = h2(o3, i2, n3, r3, e4[u3 + 11], 14, 643717713), r3 = h2(r3, o3, i2, n3, e4[u3 + 0], 20, -373897302), n3 = h2(n3, r3, o3, i2, e4[u3 + 5], 5, -701558691), i2 = h2(i2, n3, r3, o3, e4[u3 + 10], 9, 38016083), o3 = h2(o3, i2, n3, r3, e4[u3 + 15], 14, -660478335), r3 = h2(r3, o3, i2, n3, e4[u3 + 4], 20, -405537848), n3 = h2(n3, r3, o3, i2, e4[u3 + 9], 5, 568446438), i2 = h2(i2, n3, r3, o3, e4[u3 + 14], 9, -1019803690), o3 = h2(o3, i2, n3, r3, e4[u3 + 3], 14, -187363961), r3 = h2(r3, o3, i2, n3, e4[u3 + 8], 20, 1163531501), n3 = h2(n3, r3, o3, i2, e4[u3 + 13], 5, -1444681467), i2 = h2(i2, n3, r3, o3, e4[u3 + 2], 9, -51403784), o3 = h2(o3, i2, n3, r3, e4[u3 + 7], 14, 1735328473), n3 = p2(n3, r3 = h2(r3, o3, i2, n3, e4[u3 + 12], 20, -1926607734), o3, i2, e4[u3 + 5], 4, -378558), i2 = p2(i2, n3, r3, o3, e4[u3 + 8], 11, -2022574463), o3 = p2(o3, i2, n3, r3, e4[u3 + 11], 16, 1839030562), r3 = p2(r3, o3, i2, n3, e4[u3 + 14], 23, -35309556), n3 = p2(n3, r3, o3, i2, e4[u3 + 1], 4, -1530992060), i2 = p2(i2, n3, r3, o3, e4[u3 + 4], 11, 1272893353), o3 = p2(o3, i2, n3, r3, e4[u3 + 7], 16, -155497632), r3 = p2(r3, o3, i2, n3, e4[u3 + 10], 23, -1094730640), n3 = p2(n3, r3, o3, i2, e4[u3 + 13], 4, 681279174), i2 = p2(i2, n3, r3, o3, e4[u3 + 0], 11, -358537222), o3 = p2(o3, i2, n3, r3, e4[u3 + 3], 16, -722521979), r3 = p2(r3, o3, i2, n3, e4[u3 + 6], 23, 76029189), n3 = p2(n3, r3, o3, i2, e4[u3 + 9], 4, -640364487), i2 = p2(i2, n3, r3, o3, e4[u3 + 12], 11, -421815835), o3 = p2(o3, i2, n3, r3, e4[u3 + 15], 16, 530742520), n3 = g2(n3, r3 = p2(r3, o3, i2, n3, e4[u3 + 2], 23, -995338651), o3, i2, e4[u3 + 0], 6, -198630844), i2 = g2(i2, n3, r3, o3, e4[u3 + 7], 10, 1126891415), o3 = g2(o3, i2, n3, r3, e4[u3 + 14], 15, -1416354905), r3 = g2(r3, o3, i2, n3, e4[u3 + 5], 21, -57434055), n3 = g2(n3, r3, o3, i2, e4[u3 + 12], 6, 1700485571), i2 = g2(i2, n3, r3, o3, e4[u3 + 3], 10, -1894986606), o3 = g2(o3, i2, n3, r3, e4[u3 + 10], 15, -1051523), r3 = g2(r3, o3, i2, n3, e4[u3 + 1], 21, -2054922799), n3 = g2(n3, r3, o3, i2, e4[u3 + 8], 6, 1873313359), i2 = g2(i2, n3, r3, o3, e4[u3 + 15], 10, -30611744), o3 = g2(o3, i2, n3, r3, e4[u3 + 6], 15, -1560198380), r3 = g2(r3, o3, i2, n3, e4[u3 + 13], 21, 1309151649), n3 = g2(n3, r3, o3, i2, e4[u3 + 4], 6, -145523070), i2 = g2(i2, n3, r3, o3, e4[u3 + 11], 10, -1120210379), o3 = g2(o3, i2, n3, r3, e4[u3 + 2], 15, 718787259), r3 = g2(r3, o3, i2, n3, e4[u3 + 9], 21, -343485551), n3 = y2(n3, a3), r3 = y2(r3, s3), o3 = y2(o3, f3), i2 = y2(i2, l3);
          }
          return Array(n3, r3, o3, i2);
        }
        function c2(e4, t3, n3, r3, o3, i2) {
          return y2((u3 = y2(y2(t3, e4), y2(r3, i2))) << (a3 = o3) | u3 >>> 32 - a3, n3);
          var u3, a3;
        }
        function d2(e4, t3, n3, r3, o3, i2, u3) {
          return c2(t3 & n3 | ~t3 & r3, e4, t3, o3, i2, u3);
        }
        function h2(e4, t3, n3, r3, o3, i2, u3) {
          return c2(t3 & r3 | n3 & ~r3, e4, t3, o3, i2, u3);
        }
        function p2(e4, t3, n3, r3, o3, i2, u3) {
          return c2(t3 ^ n3 ^ r3, e4, t3, o3, i2, u3);
        }
        function g2(e4, t3, n3, r3, o3, i2, u3) {
          return c2(n3 ^ (t3 | ~r3), e4, t3, o3, i2, u3);
        }
        function y2(e4, t3) {
          var n3 = (65535 & e4) + (65535 & t3);
          return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        b2.exports = function(e4) {
          return f2.hash(e4, l2, 16);
        };
      }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 7: [function(e2, c2, t2) {
      (function(e3, t3, n2, r2, o2, i, u2, a2, s2) {
        var l2;
        l2 = function(e4) {
          for (var t4, n3 = new Array(e4), r3 = 0; r3 < e4; r3++)
            0 == (3 & r3) && (t4 = 4294967296 * Math.random()), n3[r3] = t4 >>> ((3 & r3) << 3) & 255;
          return n3;
        }, c2.exports = l2;
      }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 10 }], 8: [function(c2, d2, e2) {
      (function(e3, t2, n2, r2, o2, i, u2, a2, s2) {
        var f2 = c2("./helpers");
        function l2(e4, t3) {
          e4[t3 >> 5] |= 128 << 24 - t3 % 32, e4[15 + (t3 + 64 >> 9 << 4)] = t3;
          for (var n3, r3, o3, i2, u3, a3 = Array(80), s3 = 1732584193, f3 = -271733879, l3 = -1732584194, c3 = 271733878, d3 = -1009589776, h2 = 0; h2 < e4.length; h2 += 16) {
            for (var p2 = s3, g2 = f3, y2 = l3, w2 = c3, b2 = d3, m2 = 0; m2 < 80; m2++) {
              a3[m2] = m2 < 16 ? e4[h2 + m2] : E2(a3[m2 - 3] ^ a3[m2 - 8] ^ a3[m2 - 14] ^ a3[m2 - 16], 1);
              var v2 = _2(_2(E2(s3, 5), (o3 = f3, i2 = l3, u3 = c3, (r3 = m2) < 20 ? o3 & i2 | ~o3 & u3 : !(r3 < 40) && r3 < 60 ? o3 & i2 | o3 & u3 | i2 & u3 : o3 ^ i2 ^ u3)), _2(_2(d3, a3[m2]), (n3 = m2) < 20 ? 1518500249 : n3 < 40 ? 1859775393 : n3 < 60 ? -1894007588 : -899497514)), d3 = c3, c3 = l3, l3 = E2(f3, 30), f3 = s3, s3 = v2;
            }
            s3 = _2(s3, p2), f3 = _2(f3, g2), l3 = _2(l3, y2), c3 = _2(c3, w2), d3 = _2(d3, b2);
          }
          return Array(s3, f3, l3, c3, d3);
        }
        function _2(e4, t3) {
          var n3 = (65535 & e4) + (65535 & t3);
          return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        function E2(e4, t3) {
          return e4 << t3 | e4 >>> 32 - t3;
        }
        d2.exports = function(e4) {
          return f2.hash(e4, l2, 20, true);
        };
      }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 9: [function(c2, d2, e2) {
      (function(e3, t2, n2, r2, o2, i, u2, a2, s2) {
        function B2(e4, t3) {
          var n3 = (65535 & e4) + (65535 & t3);
          return (e4 >> 16) + (t3 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        function L2(e4, t3) {
          return e4 >>> t3 | e4 << 32 - t3;
        }
        function f2(e4, t3) {
          var n3, r3, o3, i2, u3, a3, s3, f3, l3, c3, d3 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), h2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), p2 = new Array(64);
          e4[t3 >> 5] |= 128 << 24 - t3 % 32, e4[15 + (t3 + 64 >> 9 << 4)] = t3;
          for (var g2, y2, w2, b2, m2, v2, _2, E2, I2 = 0; I2 < e4.length; I2 += 16) {
            n3 = h2[0], r3 = h2[1], o3 = h2[2], i2 = h2[3], u3 = h2[4], a3 = h2[5], s3 = h2[6], f3 = h2[7];
            for (var A2 = 0; A2 < 64; A2++)
              p2[A2] = A2 < 16 ? e4[A2 + I2] : B2(B2(B2((E2 = p2[A2 - 2], L2(E2, 17) ^ L2(E2, 19) ^ E2 >>> 10), p2[A2 - 7]), (_2 = p2[A2 - 15], L2(_2, 7) ^ L2(_2, 18) ^ _2 >>> 3)), p2[A2 - 16]), l3 = B2(B2(B2(B2(f3, L2(v2 = u3, 6) ^ L2(v2, 11) ^ L2(v2, 25)), (m2 = u3) & a3 ^ ~m2 & s3), d3[A2]), p2[A2]), c3 = B2(L2(b2 = n3, 2) ^ L2(b2, 13) ^ L2(b2, 22), (g2 = n3) & (y2 = r3) ^ g2 & (w2 = o3) ^ y2 & w2), f3 = s3, s3 = a3, a3 = u3, u3 = B2(i2, l3), i2 = o3, o3 = r3, r3 = n3, n3 = B2(l3, c3);
            h2[0] = B2(n3, h2[0]), h2[1] = B2(r3, h2[1]), h2[2] = B2(o3, h2[2]), h2[3] = B2(i2, h2[3]), h2[4] = B2(u3, h2[4]), h2[5] = B2(a3, h2[5]), h2[6] = B2(s3, h2[6]), h2[7] = B2(f3, h2[7]);
          }
          return h2;
        }
        var l2 = c2("./helpers");
        d2.exports = function(e4) {
          return l2.hash(e4, f2, 32, true);
        };
      }).call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 10 }], 10: [function(e2, l2, t2) {
      (function(e3, t3, n2, r2, o2, i, u2, a2, s2) {
        function f2() {
        }
        (e3 = l2.exports = {}).nextTick = function() {
          var e4 = "undefined" != typeof window && window.setImmediate, t4 = "undefined" != typeof window && window.postMessage && window.addEventListener;
          if (e4)
            return function(e5) {
              return window.setImmediate(e5);
            };
          if (t4) {
            var n3 = [];
            return window.addEventListener("message", function(e5) {
              var t5 = e5.source;
              t5 !== window && null !== t5 || "process-tick" !== e5.data || (e5.stopPropagation(), 0 < n3.length && n3.shift()());
            }, true), function(e5) {
              n3.push(e5), window.postMessage("process-tick", "*");
            };
          }
          return function(e5) {
            setTimeout(e5, 0);
          };
        }(), e3.title = "browser", e3.browser = true, e3.env = {}, e3.argv = [], e3.on = f2, e3.addListener = f2, e3.once = f2, e3.off = f2, e3.removeListener = f2, e3.removeAllListeners = f2, e3.emit = f2, e3.binding = function(e4) {
          throw new Error("process.binding is not supported");
        }, e3.cwd = function() {
          return "/";
        }, e3.chdir = function(e4) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 10 }], 11: [function(e2, t2, f2) {
      (function(e3, t3, n2, r2, o2, i, u2, a2, s2) {
        f2.read = function(e4, t4, n3, r3, o3) {
          var i2, u3, a3 = 8 * o3 - r3 - 1, s3 = (1 << a3) - 1, f3 = s3 >> 1, l2 = -7, c2 = n3 ? o3 - 1 : 0, d2 = n3 ? -1 : 1, h2 = e4[t4 + c2];
          for (c2 += d2, i2 = h2 & (1 << -l2) - 1, h2 >>= -l2, l2 += a3; 0 < l2; i2 = 256 * i2 + e4[t4 + c2], c2 += d2, l2 -= 8)
            ;
          for (u3 = i2 & (1 << -l2) - 1, i2 >>= -l2, l2 += r3; 0 < l2; u3 = 256 * u3 + e4[t4 + c2], c2 += d2, l2 -= 8)
            ;
          if (0 === i2)
            i2 = 1 - f3;
          else {
            if (i2 === s3)
              return u3 ? NaN : 1 / 0 * (h2 ? -1 : 1);
            u3 += Math.pow(2, r3), i2 -= f3;
          }
          return (h2 ? -1 : 1) * u3 * Math.pow(2, i2 - r3);
        }, f2.write = function(e4, t4, n3, r3, o3, i2) {
          var u3, a3, s3, f3 = 8 * i2 - o3 - 1, l2 = (1 << f3) - 1, c2 = l2 >> 1, d2 = 23 === o3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h2 = r3 ? 0 : i2 - 1, p2 = r3 ? 1 : -1, g2 = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
          for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (a3 = isNaN(t4) ? 1 : 0, u3 = l2) : (u3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (s3 = Math.pow(2, -u3)) < 1 && (u3--, s3 *= 2), 2 <= (t4 += 1 <= u3 + c2 ? d2 / s3 : d2 * Math.pow(2, 1 - c2)) * s3 && (u3++, s3 /= 2), l2 <= u3 + c2 ? (a3 = 0, u3 = l2) : 1 <= u3 + c2 ? (a3 = (t4 * s3 - 1) * Math.pow(2, o3), u3 += c2) : (a3 = t4 * Math.pow(2, c2 - 1) * Math.pow(2, o3), u3 = 0)); 8 <= o3; e4[n3 + h2] = 255 & a3, h2 += p2, a3 /= 256, o3 -= 8)
            ;
          for (u3 = u3 << o3 | a3, f3 += o3; 0 < f3; e4[n3 + h2] = 255 & u3, h2 += p2, u3 /= 256, f3 -= 8)
            ;
          e4[n3 + h2 - p2] |= 128 * g2;
        };
      }).call(this, e2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 10 }] }, {}, [1])(1);
  });
})(object_hash);
var object_hashExports = object_hash.exports;
const hash = /* @__PURE__ */ getDefaultExportFromCjs(object_hashExports);
function chooseByUpdateTime(left, right, leftUpdateTime, rightUpdateTime) {
  if (leftUpdateTime === rightUpdateTime) {
    return hash(left) < hash(right) ? left : right;
  }
  return leftUpdateTime > rightUpdateTime ? left : right;
}
function newUuid() {
  return v4();
}
var __rest$E = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function isTombstone(element) {
  return element.isDeleted && !element.isArchived;
}
function isHeymergeArchivedListValue(element) {
  return element.isDeleted && !!element.isArchived;
}
function isHeymergeListValue(element) {
  return !element.isDeleted;
}
function unpackHeymergeList(list) {
  const output = {};
  for (const index2 of Object.keys(list)) {
    const item = Object.assign({}, list[index2]);
    const unpacked = unpackHeymergeListElement(item);
    if (unpacked !== void 0) {
      output[index2] = unpacked;
    }
  }
  return output;
}
function unpackHeymergeListElement(el2) {
  if (!isHeymergeListValue(el2)) {
    return void 0;
  }
  return unpackHeymergeListValue(el2);
}
function unpackHeymergeListValue(val) {
  const stripped = __rest$E(val, ["isDeleted", "updateTime"]);
  return stripped;
}
function unpackHeymergeListArchive(list) {
  const output = {};
  for (const index2 of Object.keys(list)) {
    const item = Object.assign({}, list[index2]);
    const unpacked = unpackHeymergeArchivedListElement(item);
    if (unpacked !== void 0) {
      output[index2] = unpacked;
    }
  }
  return output;
}
function unpackHeymergeArchivedListElement(el2) {
  if (!isHeymergeArchivedListValue(el2)) {
    return void 0;
  }
  return unpackHeymergeArchivedListValue(el2);
}
function unpackHeymergeArchivedListValue(val) {
  const stripped = __rest$E(val, ["isDeleted", "isArchived", "updateTime"]);
  return stripped;
}
function unpackHeymergeListElementContent(el2) {
  return isHeymergeArchivedListValue(el2) ? unpackHeymergeArchivedListValue(el2) : unpackHeymergeListValue(el2);
}
function addElement(list, timestamp, element) {
  const uuid = newUuid();
  const newElement = Object.assign(Object.assign({}, element), { isDeleted: false, updateTime: timestamp });
  return {
    newList: Object.assign(Object.assign({}, list), { [uuid]: newElement }),
    result: uuid
  };
}
function removeElement(list, timestamp, id2) {
  if (!list[id2]) {
    throw new ElementNotFoundError(id2);
  }
  const tombstone = {
    isDeleted: true,
    isArchived: false,
    updateTime: guardMinUpdateTime(list[id2].updateTime, timestamp)
  };
  return {
    newList: Object.assign(Object.assign({}, list), { [id2]: tombstone }),
    result: void 0
  };
}
function archiveElement(list, timestamp, id2) {
  const el2 = list[id2];
  if (!el2) {
    throw new ElementNotFoundError(id2);
  }
  if (isTombstone(el2)) {
    throw new ElementDeletedError(id2);
  }
  const archivedElement = Object.assign(Object.assign({}, unpackHeymergeListElementContent(el2)), { isDeleted: true, isArchived: true, updateTime: guardMinUpdateTime(el2.updateTime, timestamp) });
  return {
    newList: Object.assign(Object.assign({}, list), { [id2]: archivedElement }),
    result: void 0
  };
}
function restoreArchivedElement(list, timestamp, id2) {
  const el2 = list[id2];
  if (!el2) {
    throw new ElementNotFoundError(id2);
  }
  if (isTombstone(el2)) {
    throw new ElementDeletedError(id2);
  }
  const restoredElement = Object.assign(Object.assign({}, unpackHeymergeListElementContent(el2)), { isDeleted: false, updateTime: guardMinUpdateTime(el2.updateTime, timestamp) });
  return {
    newList: Object.assign(Object.assign({}, list), { [id2]: restoredElement }),
    result: void 0
  };
}
function modifyElement(list, timestamp, id2, listElement) {
  const oldElement = list[id2];
  if (!oldElement || isTombstone(oldElement)) {
    throw new ElementNotFoundError(id2);
  }
  if (isHeymergeArchivedListValue(oldElement)) {
    throw new ElementArchivedError(id2);
  }
  const modifiedElement = Object.assign(Object.assign(Object.assign({}, oldElement), listElement), { updateTime: guardMinUpdateTime(list[id2].updateTime, timestamp), isDeleted: false });
  return {
    newList: Object.assign(Object.assign({}, list), { [id2]: modifiedElement }),
    result: void 0
  };
}
function addOrModifyElement(list, timestamp, id2, listElement) {
  var _a2;
  const oldElement = list[id2];
  if (oldElement !== void 0 && isHeymergeArchivedListValue(oldElement)) {
    throw new ElementArchivedError(id2);
  }
  const oldContent = oldElement === void 0 || isTombstone(oldElement) ? {} : unpackHeymergeListValue(oldElement);
  return {
    newList: Object.assign(Object.assign({}, list), { [id2]: Object.assign(Object.assign(Object.assign({}, oldContent), listElement), { updateTime: guardMinUpdateTime((_a2 = oldElement === null || oldElement === void 0 ? void 0 : oldElement.updateTime) !== null && _a2 !== void 0 ? _a2 : "", timestamp), isDeleted: false }) }),
    result: void 0
  };
}
function mergeListsByTimestamp(left, right, postMergeHook) {
  const indices = /* @__PURE__ */ new Set([...Object.keys(left), ...Object.keys(right)]);
  const outputList = {};
  for (const index2 of indices) {
    if (index2 in left && index2 in right) {
      outputList[index2] = chooseByUpdateTimeWithHook(left[index2], right[index2], postMergeHook);
    } else if (index2 in left) {
      outputList[index2] = left[index2];
    } else {
      outputList[index2] = right[index2];
    }
  }
  return {
    newList: outputList,
    result: void 0
  };
}
function diffListsByTimestamp(base2, changed, postMergeHook) {
  const outputList = {};
  const indices = /* @__PURE__ */ new Set([...Object.keys(base2), ...Object.keys(changed)]);
  for (const index2 of indices) {
    if (index2 in base2 && index2 in changed) {
      const chosen = chooseByUpdateTimeWithHook(base2[index2], changed[index2], postMergeHook);
      if (chosen !== base2[index2]) {
        outputList[index2] = chosen;
      }
    } else if (index2 in changed) {
      outputList[index2] = changed[index2];
    } else {
      throw new InvalidHeymergeListError("Base contains Element not existing in changed List");
    }
  }
  return {
    newList: outputList,
    result: void 0
  };
}
function setMaxUpdateTime(list, timestamp) {
  const outputList = {};
  for (const index2 of Object.keys(list)) {
    const time = timestamp < list[index2].updateTime ? timestamp : list[index2].updateTime;
    outputList[index2] = Object.assign(Object.assign({}, list[index2]), { updateTime: time });
  }
  return { newList: outputList, result: true };
}
function getMaxUpdateTime(list) {
  let timestamp = (/* @__PURE__ */ new Date(0)).toISOString();
  for (const index2 of Object.keys(list)) {
    if (list[index2].updateTime > timestamp) {
      timestamp = list[index2].updateTime;
    }
  }
  return timestamp;
}
function guardMinUpdateTime(oldTime, newTime) {
  if (newTime > oldTime) {
    return newTime;
  }
  const shiftedTime = new Date(oldTime).getTime() + 1e3;
  return new Date(shiftedTime).toISOString();
}
function chooseByUpdateTimeWithHook(leftElement, rightElement, postMergeHook) {
  const chosenElement = chooseByUpdateTime(leftElement, rightElement, leftElement.updateTime, rightElement.updateTime);
  if (postMergeHook) {
    return postMergeHook(leftElement, rightElement, chosenElement);
  }
  return chosenElement;
}
function unpackHeymergeVaultContent(vaultContent) {
  let external = {};
  for (const [k2, v2] of Object.entries(vaultContent)) {
    external = Object.assign(Object.assign({}, external), { [k2]: unpackHeymergeList(v2) });
  }
  return external;
}
function unpackHeymergeVaultContentArchive(vaultContent) {
  let external = {};
  for (const [k2, v2] of Object.entries(vaultContent)) {
    external = Object.assign(Object.assign({}, external), { [k2]: unpackHeymergeListArchive(v2) });
  }
  return external;
}
function modifyVault$1(vaultContent, listKey, modification) {
  var _a2;
  const list = (_a2 = vaultContent[listKey]) !== null && _a2 !== void 0 ? _a2 : {};
  const { newList, result } = modification(list);
  return { newVaultContent: Object.assign(Object.assign({}, vaultContent), { [listKey]: newList }), result };
}
function diffVaults(base2, changed, postMergeHooks) {
  const keys3 = /* @__PURE__ */ new Set([...getObjectKeys$1(base2), ...getObjectKeys$1(changed)]);
  const outputContent = Object.assign({}, changed);
  for (const key of keys3) {
    if (key in base2 && key in changed) {
      const postMergeHook = postMergeHooks === null || postMergeHooks === void 0 ? void 0 : postMergeHooks[key];
      const { newList: diffList } = diffListsByTimestamp(base2[key], changed[key], postMergeHook);
      outputContent[key] = diffList;
    } else if (!(key in changed)) {
      throw new InvalidHeymergeVaultContentError("Key not present in changed Object");
    }
  }
  const newVaultContent = outputContent;
  return { newVaultContent, result: void 0 };
}
function mergeVaults(left, right, postMergeHooks) {
  const keys3 = /* @__PURE__ */ new Set([...getObjectKeys$1(left), ...getObjectKeys$1(right)]);
  const outputContent = Object.assign(Object.assign({}, left), right);
  for (const key of keys3) {
    if (key in left && key in right) {
      const postMergeHook = postMergeHooks === null || postMergeHooks === void 0 ? void 0 : postMergeHooks[key];
      const { newList: mergedList } = mergeListsByTimestamp(left[key], right[key], postMergeHook);
      outputContent[key] = mergedList;
    }
  }
  const newVaultContent = outputContent;
  return { newVaultContent, result: void 0 };
}
function getObjectKeys$1(obj) {
  return Object.keys(obj);
}
function getMaxVaultUpdateTime(vault) {
  let timestamp = (/* @__PURE__ */ new Date(0)).toISOString();
  for (const index2 of getObjectKeys$1(vault)) {
    const listMaxUpdateTime = getMaxUpdateTime(vault[index2]);
    if (listMaxUpdateTime > timestamp) {
      timestamp = listMaxUpdateTime;
    }
  }
  return timestamp;
}
const DESCRIPTOR_VERSION_HEYMERGE = 2;
const TEAM_META_VAULT_INFO_ID = nullUuid;
const ORGANIZATION_ADMIN_VAULT_INFO_ID = nullUuid;
const META_VAULT_ACCOUNT_SETTINGS_ID = nullUuid;
const TeamMetaVaultContent = TeamMetaVaultContentV2;
const { PermissionLevel } = GV2;
const TEAM_USER_DEFAULT_PERMISSION_LEVEL = PermissionLevel.restricted;
function getTeamMetaVaultInfo(content) {
  var _a2;
  return (_a2 = content.info) === null || _a2 === void 0 ? void 0 : _a2[TEAM_META_VAULT_INFO_ID];
}
const NEWLY_JOINED_RECENT_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
function getNewlyJoinedInfo(content, profileId) {
  const user = content.users[profileId];
  if (!(user === null || user === void 0 ? void 0 : user.newlyJoined)) {
    return void 0;
  }
  const recent = Date.now() - new Date(user.joinedAt).getTime() < NEWLY_JOINED_RECENT_AGE_MS;
  return Object.assign(Object.assign({}, user.newlyJoined), { recent });
}
function getPermissionLevel(content, profileId) {
  var _a2;
  const user = content.users[profileId];
  return (_a2 = getValueWithPlaceholder(user === null || user === void 0 ? void 0 : user.permissionLevel)) !== null && _a2 !== void 0 ? _a2 : PermissionLevel.admin;
}
function createInitialVaultContent$3() {
  return { users: {}, info: {} };
}
const teamMetaVaultContentDescriptor = {
  version: 2,
  // "groupMeta" for compatibility, renamed to team later
  contentTypeName: "groupMeta",
  vaultTypes: [VaultType.TEAM_META, VaultType.INBOX_META],
  parseVaultContent: TeamMetaVaultContent.parse.bind(TeamMetaVaultContent),
  createInitialVaultContent: createInitialVaultContent$3
};
function modifyTeamVaultInfo(content, timestamp, info) {
  return modifyVault$1(content, "info", (list) => {
    if (!list[TEAM_META_VAULT_INFO_ID]) {
      return addOrModifyElement(list, timestamp, TEAM_META_VAULT_INFO_ID, Object.assign({
        // Default values
        name: ""
      }, info));
    }
    return modifyElement(list, timestamp, TEAM_META_VAULT_INFO_ID, info);
  });
}
function addOrModifyTeamVaultUser(content, timestamp, profileId, user) {
  return modifyVault$1(content, "users", (list) => {
    return addOrModifyElement(list, timestamp, profileId, Object.assign(Object.assign({ email: null, joinedAt: timestamp }, list[profileId]), user));
  });
}
function deleteTeamVaultUser(content, timestamp, profileId) {
  return modifyVault$1(content, "users", (list) => {
    try {
      return removeElement(list, timestamp, profileId);
    } catch (e2) {
      if (e2 instanceof ElementNotFoundError) {
        return { newList: list, result: void 0 };
      }
      throw e2;
    }
  });
}
function getLoggedInUserTeamPermissionLevel(accountState, meta) {
  var _a2;
  const isTeamOrgAdmin = meta.organizationId && ((_a2 = accountState.getOrganization(meta.organizationId)) === null || _a2 === void 0 ? void 0 : _a2.isAdmin);
  if (isTeamOrgAdmin) {
    return PermissionLevel.admin;
  }
  const profileId = meta.getProfileId();
  if (!profileId) {
    throw new Error("called getLoggedInUserTeamPermissionLevel on a foreign vault");
  }
  return getPermissionLevel(meta.getContent(), profileId);
}
class VaultAuthenticatorLock {
  constructor(authenticatorId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey) {
    this.authenticatorId = authenticatorId;
    this.encryptedStorableVaultKey = encryptedStorableVaultKey;
    this.encryptedHighSecurityVaultKey = encryptedHighSecurityVaultKey;
    this.encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKey;
  }
  static create(authenticator, vaultSecret, protectedSecret, messagePrivateKey) {
    const encryptedStorableVaultKey = asymCreateKek(authenticator.storableVaultKeyEncPubKey, vaultSecret);
    const encryptedHighSecurityVaultKey = asymCreateKek(authenticator.highSecurityVaultKeyEncPubKey, protectedSecret);
    const encryptedVaultMessagePrivateKey = messagePrivateKey === null ? null : asymEncryptEncryptionPrivateKey(authenticator.highSecurityVaultKeyEncPubKey, messagePrivateKey);
    return new VaultAuthenticatorLock(authenticator.id, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
  }
  static load({ authenticatorId, encryptedStorableVaultKey: encryptedStorableVaultKeyData, encryptedHighSecurityVaultKey: encryptedHighSecurityVaultKeyData, encryptedVaultMessagePrivateKey: encryptedVaultMessagePrivateKeyData }) {
    const encryptedStorableVaultKey = loadAsymEncryptedSymmetricKey(encryptedStorableVaultKeyData);
    const encryptedHighSecurityVaultKey = loadAsymEncryptedSymmetricKey(encryptedHighSecurityVaultKeyData);
    const encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKeyData === null ? null : loadAsymEncryptedEncryptionPrivateKey(encryptedVaultMessagePrivateKeyData);
    return new VaultAuthenticatorLock(authenticatorId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
  }
}
class VaultProfileLock {
  constructor(lockingProfileId, lockingProfileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey) {
    this.lockingProfileId = lockingProfileId;
    this.lockingProfileKeyGenerationId = lockingProfileKeyGenerationId;
    this.encryptedStorableVaultKey = encryptedStorableVaultKey;
    this.encryptedHighSecurityVaultKey = encryptedHighSecurityVaultKey;
    this.encryptedVaultMessagePrivateKey = encryptedVaultMessagePrivateKey;
  }
  static create(profile, vaultSecret, protectedSecret, messagePrivateKey) {
    const encryptedStorableVaultKey = asymCreateKek(profile.storableVaultKeyEncPubKey, vaultSecret);
    const encryptedHighSecurityVaultKey = asymCreateKek(profile.highSecurityVaultKeyEncPubKey, protectedSecret);
    const encryptedVaultMessagePrivateKey = messagePrivateKey === null ? null : asymEncryptEncryptionPrivateKey(profile.highSecurityVaultKeyEncPubKey, messagePrivateKey);
    const profileId = profile instanceof UnsyncedProfile ? nullUuid : profile.id;
    const profileKeyGenerationId = profile instanceof UnsyncedProfile ? nullUuid : profile.keyGenerationId;
    return new VaultProfileLock(profileId, profileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey);
  }
  static load({ lockingProfileId, lockingProfileKeyGenerationId, encryptedStorableVaultKey, encryptedHighSecurityVaultKey, encryptedVaultMessagePrivateKey }) {
    return new VaultProfileLock(lockingProfileId, lockingProfileKeyGenerationId, loadAsymEncryptedSymmetricKey(encryptedStorableVaultKey), loadAsymEncryptedSymmetricKey(encryptedHighSecurityVaultKey), encryptedVaultMessagePrivateKey !== null ? loadAsymEncryptedEncryptionPrivateKey(encryptedVaultMessagePrivateKey) : null);
  }
}
function protect(protectedSecret, value) {
  const encoder2 = new TextEncoder();
  const encrypted = encode(symEncrypt(protectedSecret, encoder2.encode(value.unencrypted)));
  return {
    contentId: value.contentId,
    encrypted,
    isEmpty: value.unencrypted === ""
  };
}
function unlockLockProtectedSecret(vaultAccess, locks, profileLock, adminProfileLock, profileRepo, hsc) {
  if (vaultAccess.type === "profile") {
    const { unlockedProfile: up2, hsup: vaultHsup } = vaultAccess;
    if (!profileLock) {
      throw new LockProfileNotFoundError(up2.profile.id);
    }
    if (up2.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
      throw new ProfileKeyGenerationMismatchError(up2.profile.id, up2.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
    }
    const hsup = vaultHsup !== null && vaultHsup !== void 0 ? vaultHsup : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(up2, profileRepo);
    if (!hsup) {
      throw new LockProfileNotFoundError(profileLock.lockingProfileId);
    }
    const messagePrivateKey = profileLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsup.highSecurityVaultKeyEncPrivKey, profileLock.encryptedVaultMessagePrivateKey) : null;
    return {
      protectedSecret: asymDecryptKek(hsup.highSecurityVaultKeyEncPrivKey, profileLock.encryptedHighSecurityVaultKey),
      messagePrivateKey
    };
  } else if (vaultAccess.type === "admin-profile") {
    const { unlockedProfile: up2, hsup: vaultHsup } = vaultAccess;
    if (!adminProfileLock) {
      throw new LockProfileNotFoundError(up2.profile.id);
    }
    if (up2.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
      throw new ProfileKeyGenerationMismatchError(up2.profile.id, up2.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
    }
    const hsup = vaultHsup !== null && vaultHsup !== void 0 ? vaultHsup : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(up2, profileRepo);
    if (!hsup) {
      throw new LockProfileNotFoundError(adminProfileLock.lockingProfileId);
    }
    const messagePrivateKey = adminProfileLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsup.highSecurityVaultKeyEncPrivKey, adminProfileLock.encryptedVaultMessagePrivateKey) : null;
    return {
      protectedSecret: asymDecryptKek(hsup.highSecurityVaultKeyEncPrivKey, adminProfileLock.encryptedHighSecurityVaultKey),
      messagePrivateKey
    };
  } else {
    const { unlockedAuthenticator, hsua: vaultHsua } = vaultAccess;
    const hsua = vaultHsua !== null && vaultHsua !== void 0 ? vaultHsua : hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedAuthenticator();
    if (!hsua) {
      throw new LockAuthenticatorNotFoundError(unlockedAuthenticator.authenticator.id, locks);
    }
    const candidateLock = locks.find((lock) => lock.authenticatorId === hsua.authenticator.id);
    if (!candidateLock) {
      throw new LockAuthenticatorNotFoundError(hsua.authenticator.id, locks);
    }
    const messagePrivateKey = candidateLock.encryptedVaultMessagePrivateKey !== null ? asymDecryptEncryptionPrivateKey(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedVaultMessagePrivateKey) : null;
    return {
      protectedSecret: asymDecryptKek(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedHighSecurityVaultKey),
      messagePrivateKey
    };
  }
}
function unprotect(protectedSecret, value) {
  const decoder2 = new TextDecoder();
  return decoder2.decode(symDecrypt(protectedSecret, loadSymEncryptedBlob(value.encrypted)));
}
function unprotectWithContentId(protectedSecret, value) {
  var _a2;
  return {
    contentId: (_a2 = value.contentId) !== null && _a2 !== void 0 ? _a2 : null,
    unencrypted: unprotect(protectedSecret, value)
  };
}
var __awaiter$P = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getProfileInVault(profileRepo, v2) {
  var _a2, _b, _c2, _d;
  if ("profiles" in v2) {
    return (_b = (_a2 = v2.profiles.find(({ id: id2 }) => profileRepo.hasProfile(id2))) === null || _a2 === void 0 ? void 0 : _a2.id) !== null && _b !== void 0 ? _b : null;
  } else {
    return (_d = (_c2 = v2.profileIds) === null || _c2 === void 0 ? void 0 : _c2.find((id2) => profileRepo.hasProfile(id2))) !== null && _d !== void 0 ? _d : null;
  }
}
function findPersonalVaultId(accountState, vaultRepo, orgId, profileId) {
  const org = accountState.getOrganization(orgId);
  if (!org) {
    throw new OrganizationNotFoundError();
  }
  const personalVault = vaultRepo.getOrganizationPersonalLoginVault(orgId);
  if ((personalVault === null || personalVault === void 0 ? void 0 : personalVault.getPersonalProfileId()) === profileId) {
    return personalVault.id;
  }
  const toOrgProfile = org.profiles.find((op2) => op2.profileId === profileId);
  if (!toOrgProfile) {
    throw new Error("tried to link to non-existing org profile");
  }
  if (!toOrgProfile.personalVaultId) {
    throw new Error("tried to link to profile with no known personal vault");
  }
  return toOrgProfile.personalVaultId;
}
function onlineCheckCanLinkToVault(backendClient, orgId, vaultId) {
  return __awaiter$P(this, void 0, void 0, function* () {
    const { messagePublicKeys } = yield backendClient.vault.listMessagePublicKeys(orgId, [vaultId]);
    if (messagePublicKeys[0].key.length === 0) {
      throw new VaultLinkingNotSupportedError(vaultId);
    }
  });
}
const { LegacyOrganizationAdminVaultContent } = LOAV;
function getLegacyOrganizationAdminVaultInfo(content) {
  var _a2;
  return (_a2 = content.info) === null || _a2 === void 0 ? void 0 : _a2[ORGANIZATION_ADMIN_VAULT_INFO_ID];
}
function createInitialVaultContent$2() {
  return { info: {} };
}
const legacyOrganizationAdminVaultContentDescriptor = {
  version: 2,
  // 'organizationAdmin' for compatibility, this vault type will be removed later
  contentTypeName: "organizationAdmin",
  vaultTypes: [VaultType.LEGACY_ORGANIZATION_ADMIN],
  parseVaultContent: LegacyOrganizationAdminVaultContent.parse.bind(LegacyOrganizationAdminVaultContent),
  createInitialVaultContent: createInitialVaultContent$2
};
function replaceLegacyOrganizationAdminVaultInfo(content, timestamp, info) {
  return modifyVault$1(content, "info", (list) => {
    return addOrModifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
  });
}
function modifyLegacyOrganizationAdminVaultInfo(content, timestamp, info) {
  return modifyVault$1(content, "info", (list) => {
    return modifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
  });
}
function getBackendClientForVault(ccs, v2) {
  if (getProfileInVault(ccs.profileRepo, v2)) {
    return ccs.backendClient;
  }
  const org = v2.organizationId ? ccs.accountState.getOrganization(v2.organizationId) : void 0;
  if (org === null || org === void 0 ? void 0 : org.adminInfo) {
    if (org.adminProfileId) {
      return ccs.backendClient;
    }
    return ccs.backendClient.withPermissionUserId(org.superUserId);
  }
  throw new NoOrganizationAdminError();
}
function getSuperUserHighSecurityUnlockedAuthenticator(protectedSecretRepo, adminVault, authenticator) {
  const info = getLegacyOrganizationAdminVaultInfo(adminVault.getContent());
  if (!info.authenticatorSecret) {
    return null;
  }
  const seed = protectedSecretRepo.unprotect(adminVault, info.authenticatorSecret.seed);
  const pinnedSecret = {
    authenticatorId: authenticator.id,
    seed: naclUtilExports.decodeBase64(seed)
  };
  const auth = loadAuthenticator(authenticator);
  const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(auth, pinnedSecret);
  return hsua;
}
var __decorate$3 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
class HighSecurityUnlockedProfile {
  constructor(up2, highSecuritySeed) {
    this.up = up2;
    this.highSecuritySeed = highSecuritySeed;
  }
  static fromSeed(up2, highSecuritySeed) {
    return new HighSecurityUnlockedProfile(up2, highSecuritySeed);
  }
  static fromAuthenticatorLocks(up2, hsua) {
    const locks = up2.profile.authenticatorLocks;
    const candidateLock = locks.find((lock) => lock.authenticatorId === hsua.authenticator.id);
    if (!candidateLock) {
      throw new LockAuthenticatorNotFoundError(hsua.authenticator.id, locks);
    }
    const highSecuritySeed = asymDecrypt(hsua.highSecurityVaultKeyEncPrivKey, candidateLock.encryptedHighSecurityProfileSeed);
    return new HighSecurityUnlockedProfile(up2, highSecuritySeed);
  }
  static fromProfileLock(up2, parentHsup) {
    var _a2;
    if (((_a2 = up2.profile.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) !== parentHsup.up.profile.id) {
      throw new LockProfileNotFoundError(up2.profile.profileLock.lockingProfileId);
    }
    const highSecuritySeed = asymDecrypt(parentHsup.highSecurityProfileSeedEncPrivKey, up2.profile.profileLock.encryptedHighSecurityProfileSeed);
    return new HighSecurityUnlockedProfile(up2, highSecuritySeed);
  }
  createAuthenticatorLock(authenticator) {
    return Object.assign(Object.assign({}, ProfileAuthenticatorLock.create(authenticator, this.highSecuritySeed, this.up.storableSeed)), { profileId: this.up.profile.id, profileKeyGenerationId: this.up.profile.keyGenerationId });
  }
  createProfileLock(profile) {
    return Object.assign(Object.assign({}, ProfileProfileLock.create(profile, this.highSecuritySeed, this.up.storableSeed)), { profileId: this.up.profile.id, profileKeyGenerationId: this.up.profile.keyGenerationId });
  }
  get highSecurityIdentitySigPrivKey() {
    return deriveSigningKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_IDENTITY_SIGNING_KEY).sigPrivKey;
  }
  get highSecurityVaultKeyEncPrivKey() {
    return deriveEncryptionKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_VAULT_KEY_ENCRYPTION_KEY).encPrivKey;
  }
  get highSecurityProfileSeedEncPrivKey() {
    return deriveEncryptionKeyPair(this.highSecuritySeed, null, SALT_PROFILE_HIGH_SECURITY_PROFILE_KEY_ENCRYPTION_KEY).encPrivKey;
  }
}
__decorate$3([
  Lazy
], HighSecurityUnlockedProfile.prototype, "highSecurityIdentitySigPrivKey", null);
__decorate$3([
  Lazy
], HighSecurityUnlockedProfile.prototype, "highSecurityVaultKeyEncPrivKey", null);
__decorate$3([
  Lazy
], HighSecurityUnlockedProfile.prototype, "highSecurityProfileSeedEncPrivKey", null);
function isHighSecurityOrgAdminProfile(hsup) {
  const { up: up2 } = hsup;
  return up2.profile.profileType === ProfileType.ORGANIZATION_ADMIN && !!up2.profile.organizationId;
}
function getDirectVaultAccess(profileRepo, hsc, v2) {
  var _a2;
  const vaultProfileId = getProfileInVault(profileRepo, v2);
  if (vaultProfileId) {
    const unlockedProfile = profileRepo.getUnlocked(vaultProfileId);
    if (!unlockedProfile) {
      throw new ProfileNotFoundError(vaultProfileId);
    }
    return {
      type: "profile",
      unlockedProfile,
      hsup: (_a2 = hsc === null || hsc === void 0 ? void 0 : hsc.getHighSecurityUnlockedProfile(unlockedProfile, profileRepo)) !== null && _a2 !== void 0 ? _a2 : null
    };
  }
  return null;
}
function getVaultAccess(ccs, hsc, v2) {
  const directVaultAccess = getDirectVaultAccess(ccs.profileRepo, hsc, v2);
  if (directVaultAccess) {
    return directVaultAccess;
  }
  const org = v2.organizationId ? ccs.accountState.getOrganization(v2.organizationId) : void 0;
  if (!(org === null || org === void 0 ? void 0 : org.adminInfo)) {
    throw new NoOrganizationAdminError();
  }
  if (!ccs.protectedSecretRepo) {
    const unlockedProfile = ccs.profileRepo.getOrgAdminProfile(org.id);
    if (unlockedProfile) {
      return {
        type: "admin-profile",
        unlockedProfile,
        hsup: null,
        orgId: org.id
      };
    }
    const unlockedAuthenticator = ccs.superUserUnlockedAuthenticators[org.id];
    if (unlockedAuthenticator) {
      return {
        type: "admin-authenticator",
        unlockedAuthenticator,
        hsua: null,
        orgId: org.id
      };
    }
    throw new NoOrganizationAdminError();
  }
  const orgVaultAccess = getOrgAdminVaultAccess(ccs.protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, hsc, org);
  if (orgVaultAccess) {
    return orgVaultAccess;
  }
  throw new NoOrganizationAdminError();
}
function getOrgAdminVaultAccess(protectedSecretRepo, vaultRepo, profileRepo, hsc, org) {
  var _a2, _b;
  if (!org.adminInfo) {
    return null;
  }
  if ((_a2 = org.adminInfo) === null || _a2 === void 0 ? void 0 : _a2.authenticator) {
    if (!org.adminInfo.legacyAdminVaultId) {
      throw new Error("no admin vault for legacy org, this should never happen!");
    }
    const adminVault = vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
    if (!adminVault) {
      return null;
    }
    const orgHsua = getSuperUserHighSecurityUnlockedAuthenticator(protectedSecretRepo, adminVault, org.adminInfo.authenticator);
    if (!orgHsua) {
      return null;
    }
    return {
      type: "admin-authenticator",
      unlockedAuthenticator: orgHsua.getUnlockedAuthenticator(),
      hsua: orgHsua,
      orgId: org.id
    };
  } else if ((_b = org.adminInfo) === null || _b === void 0 ? void 0 : _b.adminProfile) {
    if (!hsc) {
      return null;
    }
    const up2 = profileRepo.getOrgAdminProfile(org.id);
    if (!up2) {
      return null;
    }
    const orgHsup = hsc.getHighSecurityUnlockedProfile(up2, profileRepo);
    if (!isHighSecurityOrgAdminProfile(orgHsup)) {
      throw new Error(`expected org admin profile (${ProfileType.ORGANIZATION_ADMIN}), got ${up2.profile.profileType}`);
    }
    return {
      type: "admin-profile",
      unlockedProfile: up2,
      hsup: orgHsup,
      orgId: org.id
    };
  }
  return null;
}
class ProtectedSecretRepo {
  constructor(protectedSecrets, unlockedUntil, cachedOrganizations) {
    this.protectedSecrets = protectedSecrets;
    this.unlockedUntil = unlockedUntil;
    this.cachedOrganizations = cachedOrganizations;
  }
  static create(ccs, hsc, unlockedUntil) {
    const protectedSecrets = {};
    ccs.vaultRepo.getAllVaults().forEach((vault) => {
      if (vault.isUserJoined) {
        try {
          const vaultAccess = getVaultAccess(ccs, hsc, vault);
          const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(vaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo);
          protectedSecrets[vault.id] = {
            generationId: vault.generationId,
            protectedSecret,
            messagePrivateKey
          };
        } catch (e2) {
          if (e2 instanceof DomainError && e2.code === ClientCoreErrorCode.ProfileKeyGenerationMismatch) {
            return;
          }
          throw e2;
        }
      }
    });
    return new ProtectedSecretRepo(protectedSecrets, unlockedUntil, /* @__PURE__ */ new Set());
  }
  withOrganization(orgId, orgProtectedSecrets) {
    const protectedSecrets = Object.assign(Object.assign({}, this.protectedSecrets), orgProtectedSecrets);
    const cachedOrganizations = /* @__PURE__ */ new Set([...this.cachedOrganizations, orgId]);
    return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, cachedOrganizations);
  }
  withUnlockedUntil(unlockedUntil) {
    return new ProtectedSecretRepo(this.protectedSecrets, unlockedUntil, this.cachedOrganizations);
  }
  withProtectedSecret({ id: vaultId, generationId }, protectedSecret, messagePrivateKey) {
    const protectedSecrets = Object.assign({}, this.protectedSecrets);
    protectedSecrets[vaultId] = { generationId, protectedSecret, messagePrivateKey };
    return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, this.cachedOrganizations);
  }
  withDeleteProtectedSecret(vaultId) {
    const protectedSecrets = Object.assign({}, this.protectedSecrets);
    delete protectedSecrets[vaultId];
    return new ProtectedSecretRepo(protectedSecrets, this.unlockedUntil, this.cachedOrganizations);
  }
  isUnlocked() {
    if (this.unlockedUntil === null) {
      return true;
    }
    const now = /* @__PURE__ */ new Date();
    return this.unlockedUntil.getTime() >= now.getTime();
  }
  protect(vault, value) {
    const secret = this.getSecret(vault, CannotProtectError);
    return protect(secret, value);
  }
  unprotect(vault, value) {
    const secret = this.getSecret(vault, CannotUnprotectError);
    return unprotect(secret, value);
  }
  unprotectWithContentId(vault, value) {
    const secret = this.getSecret(vault, CannotUnprotectError);
    return unprotectWithContentId(secret, value);
  }
  decryptVaultMessage(vault, message) {
    var _a2;
    if (!((_a2 = message.encryptedData) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return void 0;
    }
    const privateKey = this.getVaultMessagePrivateKey(vault, CannotDecryptVaultMessageError);
    if (!privateKey) {
      throw new CannotDecryptVaultMessageError("no vault message private key");
    }
    return asymDecrypt(privateKey, loadAsymEncryptedBlob(message.encryptedData));
  }
  createLock(vault, authenticator) {
    const protectedSecret = this.getSecret(vault, CannotCreateLockError);
    const messagePrivateKey = this.getVaultMessagePrivateKey(vault, CannotCreateLockError);
    return VaultAuthenticatorLock.create(authenticator, vault.vaultSecret, protectedSecret, messagePrivateKey);
  }
  createProfileLock(vault, profile) {
    const protectedSecret = this.getSecret(vault, CannotCreateLockError);
    const messagePrivateKey = this.getVaultMessagePrivateKey(vault, CannotCreateLockError);
    return VaultProfileLock.create(profile, vault.vaultSecret, protectedSecret, messagePrivateKey);
  }
  getProtectedSecretFunctions(vault) {
    this.getSecret(vault, VaultProtectedSecretNotFoundError);
    const decryptVaultMessage = vault.messagePublicKey ? (msg) => this.decryptVaultMessage(vault, msg) : null;
    return {
      protect: (v2) => this.protect(vault, v2),
      unprotect: (v2) => this.unprotect(vault, v2),
      unprotectWithContentId: (v2) => this.unprotectWithContentId(vault, v2),
      decryptVaultMessage
    };
  }
  hasVault(vaultId) {
    return !!this.protectedSecrets[vaultId];
  }
  getSecret(vault, ErrorConstructor) {
    this.checkProtectedSecretPrecondition(ErrorConstructor);
    const entry = this.protectedSecrets[vault.id];
    if (!entry) {
      throw new ProtectInternalError(`No protected secret for vault: ${vault.id}}!`);
    }
    if (entry.generationId !== vault.generationId) {
      throw new ProtectInternalError(`Incorrect vault generation: got ${vault.generationId}, expected ${entry.generationId}`);
    }
    return entry.protectedSecret;
  }
  getVaultMessagePrivateKey(vault, ErrorConstructor) {
    this.checkProtectedSecretPrecondition(ErrorConstructor);
    const entry = this.protectedSecrets[vault.id];
    if (!entry) {
      throw new ProtectInternalError(`No protected secret for vault: ${vault.id}}!`);
    }
    if (entry.generationId !== vault.generationId) {
      throw new ProtectInternalError(`Incorrect vault generation: got ${vault.generationId}, expected ${entry.generationId}`);
    }
    return entry.messagePrivateKey;
  }
  checkProtectedSecretPrecondition(ErrorConstructor) {
    if (!this.isUnlocked()) {
      const msg = `Vault protectedSecret expired at ${this.unlockedUntil} but was still present at ${/* @__PURE__ */ new Date()}.`;
      trackError(new Error(msg));
      throw new ErrorConstructor();
    }
  }
}
var __rest$D = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function internalCheckLoginAchievements(_a2) {
  var ccs = __rest$D(_a2, []);
  const achievements = [];
  const privateLoginVault = ccs.vaultRepo.getPrivateLoginVault();
  if (privateLoginVault) {
    const numLogins = Object.keys(privateLoginVault.getContent().logins).length;
    if (numLogins >= 1024)
      achievements.push(Achievement.COR_LOGINS_TOTAL_1024);
    if (numLogins >= 512)
      achievements.push(Achievement.COR_LOGINS_TOTAL_512);
    if (numLogins >= 256)
      achievements.push(Achievement.COR_LOGINS_TOTAL_256);
    if (numLogins >= 128)
      achievements.push(Achievement.COR_LOGINS_TOTAL_128);
    if (numLogins >= 64)
      achievements.push(Achievement.COR_LOGINS_TOTAL_64);
    if (numLogins >= 32)
      achievements.push(Achievement.COR_LOGINS_TOTAL_32);
    if (numLogins >= 16)
      achievements.push(Achievement.COR_LOGINS_TOTAL_16);
    if (numLogins >= 8)
      achievements.push(Achievement.COR_LOGINS_TOTAL_8);
    if (numLogins >= 4)
      achievements.push(Achievement.COR_LOGINS_TOTAL_4);
    if (numLogins >= 2)
      achievements.push(Achievement.COR_LOGINS_TOTAL_2);
    if (numLogins >= 1)
      achievements.push(Achievement.COR_LOGINS_TOTAL_1);
    ccs.accountState = ccs.accountState.withLocalAchievements(achievements);
  }
  return ccs;
}
function internalWriteAuditlogEvent(ccs, organizationId, ...events) {
  if (!organizationId) {
    return ccs;
  }
  const queuedEvents = events.map((event) => {
    var _a2;
    return {
      clientTime: /* @__PURE__ */ new Date(),
      organizationId,
      lastKnownServerTime: (_a2 = ccs.lastKnownServerTime) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Date(0),
      event
    };
  });
  return Object.assign(Object.assign({}, ccs), { auditlogEventQueue: [...ccs.auditlogEventQueue, ...queuedEvents] });
}
var __rest$C = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function modifyVault(_a2, vault, mod, requireUnlock, hsc) {
  var ccs = __rest$C(_a2, []);
  let modifiedVault;
  let returnResult;
  if (requireUnlock) {
    const protectedSecretFunctions = getProtectedSecretFunctions(ccs, vault, hsc);
    ({ vault: modifiedVault, result: returnResult } = vault.withModification((c2, t2, operation) => mod(c2, t2, Object.assign(Object.assign({}, operation), protectedSecretFunctions))));
  } else {
    ({ vault: modifiedVault, result: returnResult } = vault.withModification((c2, t2, operation) => mod(c2, t2, operation)));
  }
  ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
  return Object.assign(Object.assign({}, ccs), { returnResult, modifiedVault });
}
function modifyLoginVault(_a2, vault, mod, hsc) {
  var ccs = __rest$C(_a2, []);
  if (vault.type === VaultType.TEAM) {
    const pair = ccs.vaultRepo.getTeamVaultPairById(vault.id);
    if (!pair) {
      throw new VaultNotFoundError(vault.id);
    }
    const permissionLevel = getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta);
    if (permissionLevel !== PermissionLevel.admin && permissionLevel !== PermissionLevel.member) {
      throw new VaultPermissionDeniedError();
    }
  }
  const protectedSecretFunctions = getProtectedSecretFunctions(ccs, vault, hsc);
  let auditlogEvents;
  const { vault: postChangeVault, result: returnResult, vaultContentDiff } = vault.withModification((c2, t2, operation) => {
    const result = mod(c2, t2, Object.assign(Object.assign({}, operation), protectedSecretFunctions));
    auditlogEvents = result.auditlogEvents;
    return result;
  });
  let modifiedVault = postChangeVault;
  const messages2 = extractLinkedUpdateMessages(vault.id, vault.getPersonalProfileId(), vault.getContent(), protectedSecretFunctions, vaultContentDiff);
  if (messages2.length) {
    modifiedVault = modifiedVault.withAddLinkedUpdateMessage(...messages2);
  }
  ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
  if (vault.type === VaultType.PRIVATE) {
    ccs = internalCheckLoginAchievements(ccs);
  }
  if (auditlogEvents) {
    ccs = internalWriteAuditlogEvent(ccs, vault.organizationId, ...auditlogEvents);
  }
  return Object.assign(Object.assign({}, ccs), { returnResult, modifiedVault });
}
function getProtectedSecretFunctions(ccs, vault, hsc) {
  var _a2;
  if ((_a2 = ccs.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.isUnlocked()) {
    return ccs.protectedSecretRepo.getProtectedSecretFunctions(vault);
  }
  if (hsc) {
    return ProtectedSecretRepo.create(ccs, hsc, null).getProtectedSecretFunctions(vault);
  }
  throw new ClientCoreIsLockedError();
}
var __awaiter$O = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$B = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const MAX_REVISION_AGE_MS = 90 * 24 * 60 * 60 * 1e3;
function internalDeleteOutdatedLoginHistory(_a2, vaultId, loginId) {
  var ccs = __rest$B(_a2, []);
  return __awaiter$O(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    const lastKnownServerTime = ccs.lastKnownServerTime;
    if (!lastKnownServerTime) {
      return ccs;
    }
    const cutoffDate = new Date(lastKnownServerTime.getTime() - MAX_REVISION_AGE_MS);
    const previousLogin = vault.getContent().logins[loginId];
    if (!previousLogin) {
      throw new LoginNotFoundError(loginId);
    }
    if (!hasHistory(previousLogin)) {
      return ccs;
    }
    const recentRevisionIds = getRecentRevisionIds(previousLogin.history, cutoffDate);
    const baseRevisionIds = /* @__PURE__ */ new Set();
    for (const id2 of recentRevisionIds) {
      const baseRevisionId = previousLogin.history.revisions[id2].baseRevisionId;
      if (baseRevisionId && !recentRevisionIds.has(baseRevisionId)) {
        baseRevisionIds.add(baseRevisionId);
      }
    }
    const keptRevisionCount = recentRevisionIds.size + baseRevisionIds.size;
    if (keptRevisionCount === Object.keys(previousLogin.history.revisions).length) {
      return ccs;
    }
    const revisions = {};
    for (const [id2, revision] of Object.entries(previousLogin.history.revisions)) {
      if (recentRevisionIds.has(id2) || baseRevisionIds.has(id2)) {
        revisions[id2] = revision;
      }
    }
    return modifyLoginVault(ccs, vault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
      const result = modifyLoginInternal2(c2, t2, loginId, {
        history: Object.assign(Object.assign({}, previousLogin.history), { revisions })
      });
      return Object.assign(Object.assign({}, result), { auditlogEvents: [] });
    });
  });
}
function hasHistory(login) {
  return !!login.history;
}
var __awaiter$N = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$A = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const MAX_OPENED_SHARE_LINK_AGE_MS = 7 * 24 * 60 * 60 * 1e3;
function internalDeleteOutdatedShareLinks(_a2, vaultId, loginId) {
  var ccs = __rest$A(_a2, []);
  return __awaiter$N(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    const lastKnownServerTime = ccs.lastKnownServerTime;
    if (!lastKnownServerTime) {
      return ccs;
    }
    const previousLogin = vault.getContent().logins[loginId];
    if (!previousLogin) {
      throw new LoginNotFoundError(loginId);
    }
    if (!previousLogin.shareLinks) {
      return ccs;
    }
    const cutoffDate = new Date(lastKnownServerTime.getTime() - MAX_OPENED_SHARE_LINK_AGE_MS);
    const newShareLinks = previousLogin.shareLinks.filter((sl2) => {
      if (!sl2.openedAt) {
        return true;
      }
      const openedAtDate = new Date(sl2.openedAt);
      return openedAtDate.getTime() > cutoffDate.getTime();
    });
    if (newShareLinks.length === previousLogin.shareLinks.length) {
      return ccs;
    }
    return modifyLoginVault(ccs, vault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
      const result = modifyLoginInternal2(c2, t2, loginId, {
        shareLinks: newShareLinks
      });
      return Object.assign(Object.assign({}, result), { auditlogEvents: [] });
    });
  });
}
var __rest$z = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function internalLoginSetConfirmed(_a2, vaultId, loginId) {
  var ccs = __rest$z(_a2, []);
  const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
  if (!vault) {
    throw new VaultNotFoundError(vaultId);
  }
  const { vault: updatedVault } = vault.withModification((c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => modifyLoginInternal2(c2, t2, loginId, { pendingInboxConfirmation: false }));
  ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(updatedVault);
  return ccs;
}
var __rest$y = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function internalTeamClearNewlyJoined(_a2, teamId) {
  var ccs = __rest$y(_a2, []);
  const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
  if (!pair) {
    throw new VaultNotFoundError(teamId);
  }
  const profileId = pair.meta.getProfileId();
  if (!profileId) {
    throw new Error("tried to call internalTeamClearNewlyJoined on a foreign vault");
  }
  const { vault } = pair.meta.withModification((c2, t2, { addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => addOrModifyTeamVaultUser2(c2, t2, profileId, { newlyJoined: void 0 }));
  ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
  return ccs;
}
var __rest$x = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function internalTeamSetUserPermissionLevels(_a2, teamId, ...profiles) {
  var ccs = __rest$x(_a2, []);
  const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
  if (!pair) {
    throw new VaultNotFoundError(teamId);
  }
  if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== "admin") {
    throw new VaultPermissionDeniedError();
  }
  const updatesMetaVault = pair.meta.withModification((c2, t2, { addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => {
    let newVaultContent = c2;
    for (const { profileId, permissionLevel } of profiles) {
      newVaultContent = addOrModifyTeamVaultUser2(newVaultContent, t2, profileId, {
        permissionLevel
      }).newVaultContent;
    }
    return { newVaultContent, result: void 0 };
  }).vault;
  ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(updatesMetaVault);
  return ccs;
}
var __rest$w = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function internalUpdateMetaSession(_a2, sessionId, session) {
  var ccs = __rest$w(_a2, []);
  const vault = ccs.vaultRepo.getMetaVault();
  if (!vault) {
    throw new MetaVaultNotFoundError();
  }
  const { vault: modifiedVault } = vault.withModification((contents, t2, { replaceSession: replaceSession2 }) => {
    return replaceSession2(contents, t2, sessionId, session);
  });
  ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(modifiedVault);
  return ccs;
}
function groupBy(list, key) {
  if (list.length === 0) {
    return {};
  }
  list.sort((a2, b2) => {
    const k1 = key(a2);
    const k2 = key(b2);
    if (k1 === k2) {
      return 0;
    }
    return k1 < k2 ? -1 : 1;
  });
  const result = {};
  let currentStart = 0;
  let currentKey = key(list[0]);
  for (let i = 0; i < list.length; i++) {
    const k2 = key(list[i]);
    result[currentKey] = list.slice(currentStart, i);
    if (k2 !== currentKey) {
      result[currentKey] = list.slice(currentStart, i);
      currentKey = k2;
      currentStart = i;
    }
  }
  result[currentKey] = list.slice(currentStart, list.length);
  return result;
}
function getLoginDifferences(left, right) {
  return genericGetLoginDifferences(left, right, LOGIN_KEYS);
}
function genericGetLoginDifferences(left, right, keys3) {
  const result = [];
  for (const key of keys3) {
    if (!isLoginDifferenceIncludedKey(key)) {
      continue;
    }
    if (key === "creditCard") {
      result.push(...getCreditCardDifference(left.creditCard, right.creditCard));
    } else if (key === "customFields") {
      result.push(...getCustomFieldDifference(left.customFields, right.customFields));
    } else if (!isEqual$1(left[key], right[key])) {
      result.push({ type: "login", key });
    }
  }
  return result;
}
function getCreditCardDifference(left, right) {
  const result = [];
  for (const key of LOGIN_CREDIT_CARD_KEYS) {
    if (!isLoginDifferenceCreditCardIncludedKey(key)) {
      continue;
    }
    if (!isEqual$1(left === null || left === void 0 ? void 0 : left[key], right === null || right === void 0 ? void 0 : right[key]) || // Always report all fields as changed if CreditCard switches from set to unset or vice versa.
    left === void 0 && right !== void 0 || left !== void 0 && right === void 0) {
      result.push({ type: "creditCard", key });
    }
  }
  return result;
}
function getCustomFieldDifference(left, right) {
  var _a2;
  const leftFieldsById = groupBy(left, (cf2) => cf2.id);
  const rightFieldsById = groupBy(right, (cf2) => cf2.id);
  const ids = /* @__PURE__ */ new Set([...Object.keys(leftFieldsById), ...Object.keys(rightFieldsById)]);
  const result = [];
  for (const id2 of ids) {
    const leftValues = leftFieldsById[id2];
    const rightValues = rightFieldsById[id2];
    const leftValue = leftValues === null || leftValues === void 0 ? void 0 : leftValues[0];
    const rightValue = rightValues === null || rightValues === void 0 ? void 0 : rightValues[0];
    if (!isEqual$1(leftValue === null || leftValue === void 0 ? void 0 : leftValue.value, rightValue === null || rightValue === void 0 ? void 0 : rightValue.value)) {
      const name = (_a2 = leftValue === null || leftValue === void 0 ? void 0 : leftValue.name) !== null && _a2 !== void 0 ? _a2 : rightValue === null || rightValue === void 0 ? void 0 : rightValue.name;
      if (name !== void 0) {
        result.push({ type: "customField", id: id2, name });
      }
    }
  }
  return result;
}
function isLoginDifferenceIncludedKey(k2) {
  return typeof k2 === "string" && !LOGIN_DIFFERENCE_IGNORED_KEYS.includes(k2);
}
function isLoginDifferenceCreditCardIncludedKey(k2) {
  return typeof k2 === "string" && !LOGIN_DIFFERENCE_CREDIT_CARD_IGNORED_KEYS.includes(k2);
}
function isEqual$1(leftValue, rightValue) {
  if (isProtectedValue(leftValue) && isProtectedValue(rightValue)) {
    return leftValue.contentId === rightValue.contentId;
  }
  if (leftValue === void 0 && isEmptyValue(rightValue) || isEmptyValue(leftValue) && rightValue === void 0) {
    return true;
  }
  return deepEqual$1(leftValue, rightValue, { strict: true });
}
function isProtectedValue(obj) {
  return typeof obj === "object" && obj !== null && Object.keys(obj).length === 2 && "contentId" in obj && typeof obj.contentId === "string" && "encrypted" in obj && typeof obj.encrypted === "string";
}
function isEmptyValue(value) {
  return (Array.isArray(value) || typeof value === "string") && value.length === 0;
}
function getWebsiteAttributesEntry(unnormalizedWebsite) {
  const websiteAttributesEntry = {};
  const protocol = getProtocol(unnormalizedWebsite);
  if (protocol) {
    websiteAttributesEntry.protocol = protocol;
  }
  return websiteAttributesEntry;
}
function getProtocol(website) {
  let url;
  try {
    url = new URL(website);
  } catch (_a2) {
    return null;
  }
  switch (url.protocol) {
    case "http:":
      return LoginWebsiteProtocol.http;
    case "https:":
      return LoginWebsiteProtocol.https;
    default:
      return null;
  }
}
var cardTypes$1 = {
  visa: {
    niceType: "Visa",
    type: "visa",
    patterns: [4],
    gaps: [4, 8, 12],
    lengths: [16, 18, 19],
    code: {
      name: "CVV",
      size: 3
    }
  },
  mastercard: {
    niceType: "Mastercard",
    type: "mastercard",
    patterns: [[51, 55], [2221, 2229], [223, 229], [23, 26], [270, 271], 2720],
    gaps: [4, 8, 12],
    lengths: [16],
    code: {
      name: "CVC",
      size: 3
    }
  },
  "american-express": {
    niceType: "American Express",
    type: "american-express",
    patterns: [34, 37],
    gaps: [4, 10],
    lengths: [15],
    code: {
      name: "CID",
      size: 4
    }
  },
  "diners-club": {
    niceType: "Diners Club",
    type: "diners-club",
    patterns: [[300, 305], 36, 38, 39],
    gaps: [4, 10],
    lengths: [14, 16, 19],
    code: {
      name: "CVV",
      size: 3
    }
  },
  discover: {
    niceType: "Discover",
    type: "discover",
    patterns: [6011, [644, 649], 65],
    gaps: [4, 8, 12],
    lengths: [16, 19],
    code: {
      name: "CID",
      size: 3
    }
  },
  jcb: {
    niceType: "JCB",
    type: "jcb",
    patterns: [2131, 1800, [3528, 3589]],
    gaps: [4, 8, 12],
    lengths: [16, 17, 18, 19],
    code: {
      name: "CVV",
      size: 3
    }
  },
  unionpay: {
    niceType: "UnionPay",
    type: "unionpay",
    patterns: [
      620,
      [624, 626],
      [62100, 62182],
      [62184, 62187],
      [62185, 62197],
      [62200, 62205],
      [622010, 622999],
      622018,
      [622019, 622999],
      [62207, 62209],
      [622126, 622925],
      [623, 626],
      6270,
      6272,
      6276,
      [627700, 627779],
      [627781, 627799],
      [6282, 6289],
      6291,
      6292,
      810,
      [8110, 8131],
      [8132, 8151],
      [8152, 8163],
      [8164, 8171]
    ],
    gaps: [4, 8, 12],
    lengths: [14, 15, 16, 17, 18, 19],
    code: {
      name: "CVN",
      size: 3
    }
  },
  maestro: {
    niceType: "Maestro",
    type: "maestro",
    patterns: [
      493698,
      [5e5, 504174],
      [504176, 506698],
      [506779, 508999],
      [56, 59],
      63,
      67,
      6
    ],
    gaps: [4, 8, 12],
    lengths: [12, 13, 14, 15, 16, 17, 18, 19],
    code: {
      name: "CVC",
      size: 3
    }
  },
  elo: {
    niceType: "Elo",
    type: "elo",
    patterns: [
      401178,
      401179,
      438935,
      457631,
      457632,
      431274,
      451416,
      457393,
      504175,
      [506699, 506778],
      [509e3, 509999],
      627780,
      636297,
      636368,
      [650031, 650033],
      [650035, 650051],
      [650405, 650439],
      [650485, 650538],
      [650541, 650598],
      [650700, 650718],
      [650720, 650727],
      [650901, 650978],
      [651652, 651679],
      [655e3, 655019],
      [655021, 655058]
    ],
    gaps: [4, 8, 12],
    lengths: [16],
    code: {
      name: "CVE",
      size: 3
    }
  },
  mir: {
    niceType: "Mir",
    type: "mir",
    patterns: [[2200, 2204]],
    gaps: [4, 8, 12],
    lengths: [16, 17, 18, 19],
    code: {
      name: "CVP2",
      size: 3
    }
  },
  hiper: {
    niceType: "Hiper",
    type: "hiper",
    patterns: [637095, 63737423, 63743358, 637568, 637599, 637609, 637612],
    gaps: [4, 8, 12],
    lengths: [16],
    code: {
      name: "CVC",
      size: 3
    }
  },
  hipercard: {
    niceType: "Hipercard",
    type: "hipercard",
    patterns: [606282],
    gaps: [4, 8, 12],
    lengths: [16],
    code: {
      name: "CVC",
      size: 3
    }
  }
};
var cardTypes_1 = cardTypes$1;
var addMatchingCardsToResults$1 = {};
var clone$2 = {};
Object.defineProperty(clone$2, "__esModule", { value: true });
clone$2.clone = void 0;
function clone$1(originalObject) {
  if (!originalObject) {
    return null;
  }
  return JSON.parse(JSON.stringify(originalObject));
}
clone$2.clone = clone$1;
var matches$1 = {};
Object.defineProperty(matches$1, "__esModule", { value: true });
matches$1.matches = void 0;
function matchesRange(cardNumber2, min, max2) {
  var maxLengthToCheck = String(min).length;
  var substr = cardNumber2.substr(0, maxLengthToCheck);
  var integerRepresentationOfCardNumber = parseInt(substr, 10);
  min = parseInt(String(min).substr(0, substr.length), 10);
  max2 = parseInt(String(max2).substr(0, substr.length), 10);
  return integerRepresentationOfCardNumber >= min && integerRepresentationOfCardNumber <= max2;
}
function matchesPattern(cardNumber2, pattern) {
  pattern = String(pattern);
  return pattern.substring(0, cardNumber2.length) === cardNumber2.substring(0, pattern.length);
}
function matches(cardNumber2, pattern) {
  if (Array.isArray(pattern)) {
    return matchesRange(cardNumber2, pattern[0], pattern[1]);
  }
  return matchesPattern(cardNumber2, pattern);
}
matches$1.matches = matches;
Object.defineProperty(addMatchingCardsToResults$1, "__esModule", { value: true });
addMatchingCardsToResults$1.addMatchingCardsToResults = void 0;
var clone_1$1 = clone$2;
var matches_1 = matches$1;
function addMatchingCardsToResults(cardNumber2, cardConfiguration, results) {
  var i, patternLength;
  for (i = 0; i < cardConfiguration.patterns.length; i++) {
    var pattern = cardConfiguration.patterns[i];
    if (!matches_1.matches(cardNumber2, pattern)) {
      continue;
    }
    var clonedCardConfiguration = clone_1$1.clone(cardConfiguration);
    if (Array.isArray(pattern)) {
      patternLength = String(pattern[0]).length;
    } else {
      patternLength = String(pattern).length;
    }
    if (cardNumber2.length >= patternLength) {
      clonedCardConfiguration.matchStrength = patternLength;
    }
    results.push(clonedCardConfiguration);
    break;
  }
}
addMatchingCardsToResults$1.addMatchingCardsToResults = addMatchingCardsToResults;
var isValidInputType$1 = {};
Object.defineProperty(isValidInputType$1, "__esModule", { value: true });
isValidInputType$1.isValidInputType = void 0;
function isValidInputType(cardNumber2) {
  return typeof cardNumber2 === "string" || cardNumber2 instanceof String;
}
isValidInputType$1.isValidInputType = isValidInputType;
var findBestMatch$1 = {};
Object.defineProperty(findBestMatch$1, "__esModule", { value: true });
findBestMatch$1.findBestMatch = void 0;
function hasEnoughResultsToDetermineBestMatch(results) {
  var numberOfResultsWithMaxStrengthProperty = results.filter(function(result) {
    return result.matchStrength;
  }).length;
  return numberOfResultsWithMaxStrengthProperty > 0 && numberOfResultsWithMaxStrengthProperty === results.length;
}
function findBestMatch(results) {
  if (!hasEnoughResultsToDetermineBestMatch(results)) {
    return null;
  }
  return results.reduce(function(bestMatch, result) {
    if (!bestMatch) {
      return result;
    }
    if (Number(bestMatch.matchStrength) < Number(result.matchStrength)) {
      return result;
    }
    return bestMatch;
  });
}
findBestMatch$1.findBestMatch = findBestMatch;
var __assign$3 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var cardTypes = cardTypes_1;
var add_matching_cards_to_results_1 = addMatchingCardsToResults$1;
var is_valid_input_type_1 = isValidInputType$1;
var find_best_match_1 = findBestMatch$1;
var clone_1 = clone$2;
var customCards = {};
var cardNames = {
  VISA: "visa",
  MASTERCARD: "mastercard",
  AMERICAN_EXPRESS: "american-express",
  DINERS_CLUB: "diners-club",
  DISCOVER: "discover",
  JCB: "jcb",
  UNIONPAY: "unionpay",
  MAESTRO: "maestro",
  ELO: "elo",
  MIR: "mir",
  HIPER: "hiper",
  HIPERCARD: "hipercard"
};
var ORIGINAL_TEST_ORDER = [
  cardNames.VISA,
  cardNames.MASTERCARD,
  cardNames.AMERICAN_EXPRESS,
  cardNames.DINERS_CLUB,
  cardNames.DISCOVER,
  cardNames.JCB,
  cardNames.UNIONPAY,
  cardNames.MAESTRO,
  cardNames.ELO,
  cardNames.MIR,
  cardNames.HIPER,
  cardNames.HIPERCARD
];
var testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
function findType(cardType) {
  return customCards[cardType] || cardTypes[cardType];
}
function getAllCardTypes() {
  return testOrder.map(function(cardType) {
    return clone_1.clone(findType(cardType));
  });
}
function getCardPosition(name, ignoreErrorForNotExisting) {
  if (ignoreErrorForNotExisting === void 0) {
    ignoreErrorForNotExisting = false;
  }
  var position = testOrder.indexOf(name);
  if (!ignoreErrorForNotExisting && position === -1) {
    throw new Error('"' + name + '" is not a supported card type.');
  }
  return position;
}
function creditCardType$1(cardNumber2) {
  var results = [];
  if (!is_valid_input_type_1.isValidInputType(cardNumber2)) {
    return results;
  }
  if (cardNumber2.length === 0) {
    return getAllCardTypes();
  }
  testOrder.forEach(function(cardType) {
    var cardConfiguration = findType(cardType);
    add_matching_cards_to_results_1.addMatchingCardsToResults(cardNumber2, cardConfiguration, results);
  });
  var bestMatch = find_best_match_1.findBestMatch(results);
  if (bestMatch) {
    return [bestMatch];
  }
  return results;
}
creditCardType$1.getTypeInfo = function(cardType) {
  return clone_1.clone(findType(cardType));
};
creditCardType$1.removeCard = function(name) {
  var position = getCardPosition(name);
  testOrder.splice(position, 1);
};
creditCardType$1.addCard = function(config2) {
  var existingCardPosition = getCardPosition(config2.type, true);
  customCards[config2.type] = config2;
  if (existingCardPosition === -1) {
    testOrder.push(config2.type);
  }
};
creditCardType$1.updateCard = function(cardType, updates) {
  var originalObject = customCards[cardType] || cardTypes[cardType];
  if (!originalObject) {
    throw new Error('"' + cardType + "\" is not a recognized type. Use `addCard` instead.'");
  }
  if (updates.type && originalObject.type !== updates.type) {
    throw new Error("Cannot overwrite type parameter.");
  }
  var clonedCard = clone_1.clone(originalObject);
  clonedCard = __assign$3(__assign$3({}, clonedCard), updates);
  customCards[clonedCard.type] = clonedCard;
};
creditCardType$1.changeOrder = function(name, position) {
  var currentPosition = getCardPosition(name);
  testOrder.splice(currentPosition, 1);
  testOrder.splice(position, 0, name);
};
creditCardType$1.resetModifications = function() {
  testOrder = clone_1.clone(ORIGINAL_TEST_ORDER);
  customCards = {};
};
creditCardType$1.types = cardNames;
var dist$1 = creditCardType$1;
var cardholderName$1 = {};
Object.defineProperty(cardholderName$1, "__esModule", { value: true });
cardholderName$1.cardholderName = void 0;
var CARD_NUMBER_REGEX = /^[\d\s-]*$/;
var MAX_LENGTH = 255;
function verification$6(isValid2, isPotentiallyValid) {
  return { isValid: isValid2, isPotentiallyValid };
}
function cardholderName(value) {
  if (typeof value !== "string") {
    return verification$6(false, false);
  }
  if (value.length === 0) {
    return verification$6(false, true);
  }
  if (value.length > MAX_LENGTH) {
    return verification$6(false, false);
  }
  if (CARD_NUMBER_REGEX.test(value)) {
    return verification$6(false, true);
  }
  return verification$6(true, true);
}
cardholderName$1.cardholderName = cardholderName;
var cardNumber$1 = {};
function luhn10$1(identifier) {
  var sum = 0;
  var alt = false;
  var i = identifier.length - 1;
  var num;
  while (i >= 0) {
    num = parseInt(identifier.charAt(i), 10);
    if (alt) {
      num *= 2;
      if (num > 9) {
        num = num % 10 + 1;
      }
    }
    alt = !alt;
    sum += num;
    i--;
  }
  return sum % 10 === 0;
}
var luhn10_1 = luhn10$1;
Object.defineProperty(cardNumber$1, "__esModule", { value: true });
cardNumber$1.cardNumber = void 0;
var luhn10 = luhn10_1;
var getCardTypes = dist$1;
function verification$5(card, isPotentiallyValid, isValid2) {
  return {
    card,
    isPotentiallyValid,
    isValid: isValid2
  };
}
function cardNumber(value, options) {
  if (options === void 0) {
    options = {};
  }
  var isPotentiallyValid, isValid2, maxLength;
  if (typeof value !== "string" && typeof value !== "number") {
    return verification$5(null, false, false);
  }
  var testCardValue = String(value).replace(/-|\s/g, "");
  if (!/^\d*$/.test(testCardValue)) {
    return verification$5(null, false, false);
  }
  var potentialTypes = getCardTypes(testCardValue);
  if (potentialTypes.length === 0) {
    return verification$5(null, false, false);
  } else if (potentialTypes.length !== 1) {
    return verification$5(null, true, false);
  }
  var cardType = potentialTypes[0];
  if (options.maxLength && testCardValue.length > options.maxLength) {
    return verification$5(cardType, false, false);
  }
  if (cardType.type === getCardTypes.types.UNIONPAY && options.luhnValidateUnionPay !== true) {
    isValid2 = true;
  } else {
    isValid2 = luhn10(testCardValue);
  }
  maxLength = Math.max.apply(null, cardType.lengths);
  if (options.maxLength) {
    maxLength = Math.min(options.maxLength, maxLength);
  }
  for (var i = 0; i < cardType.lengths.length; i++) {
    if (cardType.lengths[i] === testCardValue.length) {
      isPotentiallyValid = testCardValue.length < maxLength || isValid2;
      return verification$5(cardType, isPotentiallyValid, isValid2);
    }
  }
  return verification$5(cardType, testCardValue.length < maxLength, false);
}
cardNumber$1.cardNumber = cardNumber;
var expirationDate$1 = {};
var parseDate$1 = {};
var expirationYear$1 = {};
Object.defineProperty(expirationYear$1, "__esModule", { value: true });
expirationYear$1.expirationYear = void 0;
var DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE = 19;
function verification$4(isValid2, isPotentiallyValid, isCurrentYear) {
  return {
    isValid: isValid2,
    isPotentiallyValid,
    isCurrentYear: isCurrentYear || false
  };
}
function expirationYear(value, maxElapsedYear) {
  if (maxElapsedYear === void 0) {
    maxElapsedYear = DEFAULT_VALID_NUMBER_OF_YEARS_IN_THE_FUTURE;
  }
  var isCurrentYear;
  if (typeof value !== "string") {
    return verification$4(false, false);
  }
  if (value.replace(/\s/g, "") === "") {
    return verification$4(false, true);
  }
  if (!/^\d*$/.test(value)) {
    return verification$4(false, false);
  }
  var len = value.length;
  if (len < 2) {
    return verification$4(false, true);
  }
  var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  if (len === 3) {
    var firstTwo = value.slice(0, 2);
    var currentFirstTwo = String(currentYear).slice(0, 2);
    return verification$4(false, firstTwo === currentFirstTwo);
  }
  if (len > 4) {
    return verification$4(false, false);
  }
  var numericValue = parseInt(value, 10);
  var twoDigitYear = Number(String(currentYear).substr(2, 2));
  var valid = false;
  if (len === 2) {
    if (String(currentYear).substr(0, 2) === value) {
      return verification$4(false, true);
    }
    isCurrentYear = twoDigitYear === numericValue;
    valid = numericValue >= twoDigitYear && numericValue <= twoDigitYear + maxElapsedYear;
  } else if (len === 4) {
    isCurrentYear = currentYear === numericValue;
    valid = numericValue >= currentYear && numericValue <= currentYear + maxElapsedYear;
  }
  return verification$4(valid, valid, isCurrentYear);
}
expirationYear$1.expirationYear = expirationYear;
var isArray$3 = {};
Object.defineProperty(isArray$3, "__esModule", { value: true });
isArray$3.isArray = void 0;
isArray$3.isArray = Array.isArray || function(arg) {
  return Object.prototype.toString.call(arg) === "[object Array]";
};
Object.defineProperty(parseDate$1, "__esModule", { value: true });
parseDate$1.parseDate = void 0;
var expiration_year_1$2 = expirationYear$1;
var is_array_1 = isArray$3;
function getNumberOfMonthDigitsInDateString(dateString) {
  var firstCharacter = Number(dateString[0]);
  var assumedYear;
  if (firstCharacter === 0) {
    return 2;
  }
  if (firstCharacter > 1) {
    return 1;
  }
  if (firstCharacter === 1 && Number(dateString[1]) > 2) {
    return 1;
  }
  if (firstCharacter === 1) {
    assumedYear = dateString.substr(1);
    return expiration_year_1$2.expirationYear(assumedYear).isPotentiallyValid ? 1 : 2;
  }
  if (dateString.length === 5) {
    return 1;
  }
  if (dateString.length > 5) {
    return 2;
  }
  return 1;
}
function parseDate(datestring) {
  var date2;
  if (/^\d{4}-\d{1,2}$/.test(datestring)) {
    date2 = datestring.split("-").reverse();
  } else if (/\//.test(datestring)) {
    date2 = datestring.split(/\s*\/\s*/g);
  } else if (/\s/.test(datestring)) {
    date2 = datestring.split(/ +/g);
  }
  if (is_array_1.isArray(date2)) {
    return {
      month: date2[0] || "",
      year: date2.slice(1).join()
    };
  }
  var numberOfDigitsInMonth = getNumberOfMonthDigitsInDateString(datestring);
  var month = datestring.substr(0, numberOfDigitsInMonth);
  return {
    month,
    year: datestring.substr(month.length)
  };
}
parseDate$1.parseDate = parseDate;
var expirationMonth$1 = {};
Object.defineProperty(expirationMonth$1, "__esModule", { value: true });
expirationMonth$1.expirationMonth = void 0;
function verification$3(isValid2, isPotentiallyValid, isValidForThisYear) {
  return {
    isValid: isValid2,
    isPotentiallyValid,
    isValidForThisYear: isValidForThisYear || false
  };
}
function expirationMonth(value) {
  var currentMonth = (/* @__PURE__ */ new Date()).getMonth() + 1;
  if (typeof value !== "string") {
    return verification$3(false, false);
  }
  if (value.replace(/\s/g, "") === "" || value === "0") {
    return verification$3(false, true);
  }
  if (!/^\d*$/.test(value)) {
    return verification$3(false, false);
  }
  var month = parseInt(value, 10);
  if (isNaN(Number(value))) {
    return verification$3(false, false);
  }
  var result = month > 0 && month < 13;
  return verification$3(result, result, result && month >= currentMonth);
}
expirationMonth$1.expirationMonth = expirationMonth;
var __assign$2 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
Object.defineProperty(expirationDate$1, "__esModule", { value: true });
expirationDate$1.expirationDate = void 0;
var parse_date_1 = parseDate$1;
var expiration_month_1$1 = expirationMonth$1;
var expiration_year_1$1 = expirationYear$1;
function verification$2(isValid2, isPotentiallyValid, month, year) {
  return {
    isValid: isValid2,
    isPotentiallyValid,
    month,
    year
  };
}
function expirationDate(value, maxElapsedYear) {
  var date2;
  if (typeof value === "string") {
    value = value.replace(/^(\d\d) (\d\d(\d\d)?)$/, "$1/$2");
    date2 = parse_date_1.parseDate(String(value));
  } else if (value !== null && typeof value === "object") {
    var fullDate = __assign$2({}, value);
    date2 = {
      month: String(fullDate.month),
      year: String(fullDate.year)
    };
  } else {
    return verification$2(false, false, null, null);
  }
  var monthValid = expiration_month_1$1.expirationMonth(date2.month);
  var yearValid = expiration_year_1$1.expirationYear(date2.year, maxElapsedYear);
  if (monthValid.isValid) {
    if (yearValid.isCurrentYear) {
      var isValidForThisYear = monthValid.isValidForThisYear;
      return verification$2(isValidForThisYear, isValidForThisYear, date2.month, date2.year);
    }
    if (yearValid.isValid) {
      return verification$2(true, true, date2.month, date2.year);
    }
  }
  if (monthValid.isPotentiallyValid && yearValid.isPotentiallyValid) {
    return verification$2(false, true, null, null);
  }
  return verification$2(false, false, null, null);
}
expirationDate$1.expirationDate = expirationDate;
var cvv$1 = {};
Object.defineProperty(cvv$1, "__esModule", { value: true });
cvv$1.cvv = void 0;
var DEFAULT_LENGTH = 3;
function includes(array, thing) {
  for (var i = 0; i < array.length; i++) {
    if (thing === array[i]) {
      return true;
    }
  }
  return false;
}
function max(array) {
  var maximum = DEFAULT_LENGTH;
  var i = 0;
  for (; i < array.length; i++) {
    maximum = array[i] > maximum ? array[i] : maximum;
  }
  return maximum;
}
function verification$1(isValid2, isPotentiallyValid) {
  return { isValid: isValid2, isPotentiallyValid };
}
function cvv(value, maxLength) {
  if (maxLength === void 0) {
    maxLength = DEFAULT_LENGTH;
  }
  maxLength = maxLength instanceof Array ? maxLength : [maxLength];
  if (typeof value !== "string") {
    return verification$1(false, false);
  }
  if (!/^\d*$/.test(value)) {
    return verification$1(false, false);
  }
  if (includes(maxLength, value.length)) {
    return verification$1(true, true);
  }
  if (value.length < Math.min.apply(null, maxLength)) {
    return verification$1(false, true);
  }
  if (value.length > max(maxLength)) {
    return verification$1(false, false);
  }
  return verification$1(true, true);
}
cvv$1.cvv = cvv;
var postalCode$1 = {};
Object.defineProperty(postalCode$1, "__esModule", { value: true });
postalCode$1.postalCode = void 0;
var DEFAULT_MIN_POSTAL_CODE_LENGTH = 3;
function verification(isValid2, isPotentiallyValid) {
  return { isValid: isValid2, isPotentiallyValid };
}
function postalCode(value, options) {
  if (options === void 0) {
    options = {};
  }
  var minLength = options.minLength || DEFAULT_MIN_POSTAL_CODE_LENGTH;
  if (typeof value !== "string") {
    return verification(false, false);
  } else if (value.length < minLength) {
    return verification(false, true);
  }
  return verification(true, true);
}
postalCode$1.postalCode = postalCode;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  Object.defineProperty(o2, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
var creditCardType = __importStar(dist$1);
var cardholder_name_1 = cardholderName$1;
var card_number_1 = cardNumber$1;
var expiration_date_1 = expirationDate$1;
var expiration_month_1 = expirationMonth$1;
var expiration_year_1 = expirationYear$1;
var cvv_1 = cvv$1;
var postal_code_1 = postalCode$1;
var cardValidator = {
  creditCardType,
  cardholderName: cardholder_name_1.cardholderName,
  number: card_number_1.cardNumber,
  expirationDate: expiration_date_1.expirationDate,
  expirationMonth: expiration_month_1.expirationMonth,
  expirationYear: expiration_year_1.expirationYear,
  cvv: cvv_1.cvv,
  postalCode: postal_code_1.postalCode
};
var dist = cardValidator;
const At = /* @__PURE__ */ getDefaultExportFromCjs(dist);
function normalizeCreditCard(creditCard) {
  var _a2, _b, _c2, _d;
  const normalizedNumber = creditCard.number ? normalizeCreditCardNumber(creditCard.number) : { number: "", displayMaskedNumber: "", displayType: "" };
  const normalizedCreditCard = Object.assign(Object.assign({ pin: (_a2 = creditCard.pin) !== null && _a2 !== void 0 ? _a2 : "", securityCode: (_b = creditCard.securityCode) !== null && _b !== void 0 ? _b : "" }, normalizedNumber), { cardHolder: (_d = (_c2 = creditCard.cardHolder) === null || _c2 === void 0 ? void 0 : _c2.trim()) !== null && _d !== void 0 ? _d : "", expiration: creditCard.expiration ? normalizeCreditCardExpiration(creditCard.expiration) : "" });
  if (Object.values(normalizedCreditCard).every((v2) => v2 === "")) {
    return void 0;
  }
  return normalizedCreditCard;
}
function normalizeCreditCardNumber(inputNumber) {
  var _a2, _b;
  const cardNumberValidation = At.number(inputNumber);
  if (!cardNumberValidation.card || !cardNumberValidation.isValid) {
    const number3 = inputNumber.trim();
    const displayMaskedNumber2 = number3.replace(/\d/g, "*");
    return { number: number3, displayMaskedNumber: displayMaskedNumber2, displayType: (_b = (_a2 = cardNumberValidation.card) === null || _a2 === void 0 ? void 0 : _a2.niceType) !== null && _b !== void 0 ? _b : "" };
  }
  const { card } = cardNumberValidation;
  const cardNumberDigits = inputNumber.replace(/\D/g, "");
  const offsets = [0, ...card.gaps, cardNumberDigits.length];
  const components = [];
  for (let i = 0; offsets[i] < cardNumberDigits.length; i++) {
    const start = offsets[i];
    const end = Math.min(offsets[i + 1], cardNumberDigits.length);
    components.push(cardNumberDigits.substring(start, end));
  }
  const number2 = components.join(" ");
  const displayMaskedNumber = components.map((c2, i) => i === components.length - 1 ? c2 : c2.replace(/\d/g, "*")).join(" ");
  return { number: number2, displayMaskedNumber, displayType: cardNumberValidation.card.niceType };
}
function normalizeCreditCardExpiration(expiration) {
  var _a2, _b;
  const expirationValidation = At.expirationDate(expiration, Infinity);
  if (!expirationValidation.isValid || !expirationValidation.month || !expirationValidation.year) {
    const match2 = /^\s*(?<month>\d?\d)\s*\/\s*(?<year>(\d\d\d|\d)?\d)\s*$/.exec(expiration);
    if (match2) {
      return `${(_a2 = match2.groups) === null || _a2 === void 0 ? void 0 : _a2.month.padStart(2, "0")} / ${(_b = match2.groups) === null || _b === void 0 ? void 0 : _b.year.substring(match2.groups.year.length - 2).padStart(2, "0")}`;
    }
    return expiration.trim();
  }
  const twoDigitYear = expirationValidation.year.substring(expirationValidation.year.length - 2);
  return `${expirationValidation.month} / ${twoDigitYear}`;
}
function normalizeTag(tag) {
  return tag.replace(/^[\s/]*/, "").replace(/[\s/]*$/, "").replace(/\/+/g, "/");
}
function normalizeTotpSecret(value) {
  let result = value;
  const parameters = getTotpParametersFromOtpauthUrl(value);
  if (parameters) {
    result = parameters.secret;
  }
  const normalizedSecret = getNormalizedPlainTotpSecret(result);
  if (normalizedSecret) {
    result = normalizedSecret;
  }
  return result;
}
function getTotpParametersFromOtpauthUrl(value) {
  const parts = /otpauth:\/\/([A-Za-z]+)\/([^?]*)\??(.*)?/i.exec(value);
  if (parts === null || parts.length < 3) {
    return null;
  }
  const type = parts[1];
  if (type.toLowerCase() !== "totp") {
    return null;
  }
  const urlParams = new URLSearchParams(parts[3]);
  const secret = urlParams.get("secret");
  if (secret === null) {
    return null;
  }
  const params = {
    secret,
    algorithm: normalizeTotpAlgorithm(urlParams.get("algorithm")),
    digits: normalizeTotpDigits(urlParams.get("digits")),
    period: normalizeTotpPeriod(urlParams.get("period"))
  };
  return params;
}
function normalizeTotpAlgorithm(algorithm) {
  if (algorithm === null) {
    return void 0;
  }
  const algo = algorithm.toLowerCase().trim();
  switch (algo) {
    case "sha1":
      return TotpAlgorithm.sha1;
    case "sha256":
      return TotpAlgorithm.sha256;
    case "sha512":
      return TotpAlgorithm.sha512;
    default:
      return TotpAlgorithm.sha1;
  }
}
function normalizeTotpDigits(digitsString) {
  if (digitsString === null) {
    return void 0;
  }
  const digits = Number.parseInt(digitsString);
  if (Number.isNaN(digits) || !Number.isInteger(digits)) {
    return void 0;
  }
  if (digits <= 0) {
    return DEFAULT_TOTP_DIGITS;
  }
  return Math.min(8, digits);
}
function normalizeTotpPeriod(periodString) {
  if (periodString === null) {
    return void 0;
  }
  const period = Number.parseInt(periodString);
  if (Number.isNaN(period) || !Number.isInteger(period)) {
    return void 0;
  }
  if (period <= 0) {
    return DEFAULT_TOTP_PERIOD;
  }
  return period;
}
function getNormalizedPlainTotpSecret(value) {
  if (value === null) {
    return void 0;
  }
  const secret = value.toUpperCase().replace(/\s/g, "");
  try {
    base32tohex(secret);
    return secret;
  } catch (e2) {
    if (e2 instanceof InvalidTotpSecretError) {
      return void 0;
    }
  }
  return void 0;
}
function normalizeWebsitePattern(websitePatternString, options = {}) {
  const { hostname: host, port, pathname: path } = getNormalizedPatternParts(websitePatternString.trim(), options);
  return `${host}${port ? ":" : ""}${port}${path}`;
}
function getNormalizedPatternParts(inputWebsitePatternString, { usePunycode = false } = {}) {
  if (/^\d+$/.test(inputWebsitePatternString)) {
    return {
      hostname: inputWebsitePatternString.trim(),
      pathname: "",
      port: ""
    };
  }
  try {
    let websitePatternString = inputWebsitePatternString;
    const hasProtocol = /^([a-z]+:)?\/\//.exec(websitePatternString);
    if (!hasProtocol) {
      websitePatternString = `https://${websitePatternString}`;
    }
    const url = new URL(websitePatternString);
    const hostname = normalizePatternHostname(url.hostname, usePunycode);
    const pathname = normalizePatternPathname(url);
    const { port } = url;
    return {
      hostname,
      pathname,
      port
    };
  } catch (e2) {
    return {
      hostname: inputWebsitePatternString.trim(),
      pathname: "",
      port: ""
    };
  }
}
function normalizePatternHostname(hostname, usePunycode) {
  const hostnamePunycodedIfNeeded = usePunycode ? hostname : punycode.toUnicode(hostname);
  return hostnamePunycodedIfNeeded.toLowerCase();
}
function normalizePatternPathname(url) {
  const pathname = url.pathname.trim();
  if (pathname.match(/^\/+$/)) {
    return "";
  }
  return pathname;
}
var __rest$v = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function sanitizeLoginFromImport(login, profileId, now, emptyNameCustomFieldDefaultName) {
  var _a2, _b;
  const { creationTime, editTime, changeTime, websites, websiteAttributes, tags, creditCard, totp, customFields } = login, restLogin = __rest$v(login, ["creationTime", "editTime", "changeTime", "websites", "websiteAttributes", "tags", "creditCard", "totp", "customFields"]);
  const { normalizedWebsites, normalizedWebsiteAttributes } = getNormalizedWebsites(websites !== null && websites !== void 0 ? websites : [], websiteAttributes !== null && websiteAttributes !== void 0 ? websiteAttributes : {});
  const sanitizedLogin = Object.assign({
    // static defaults
    title: "",
    username: "",
    password: "",
    icon: "",
    note: "",
    creationSource: LoginSource.import,
    editSource: LoginSource.import,
    creationProfileId: profileId,
    editProfileId: profileId,
    // Default times to each other if not all are set
    creationTime: (_a2 = creationTime !== null && creationTime !== void 0 ? creationTime : editTime) !== null && _a2 !== void 0 ? _a2 : now,
    changeTime: (_b = changeTime !== null && changeTime !== void 0 ? changeTime : editTime) !== null && _b !== void 0 ? _b : now,
    editTime: editTime !== null && editTime !== void 0 ? editTime : now,
    // Normalize fields where possible
    websites: normalizedWebsites,
    websiteAttributes: normalizedWebsiteAttributes,
    tags: tags ? removeDuplicates(tags.map(normalizeTag)) : void 0,
    creditCard: creditCard ? normalizeCreditCard(creditCard) : void 0,
    totp: totp ? normalizeTotpSecret(totp) : void 0,
    customFields: customFields ? getNormalizedCustomFields(customFields, emptyNameCustomFieldDefaultName) : []
  }, deleteUndefinedKeys(restLogin));
  return deleteUndefinedKeys(Object.assign({
    // Guess uiType if not set
    uiType: guessUiType(sanitizedLogin)
  }, sanitizedLogin));
}
function deleteUndefinedKeys(obj) {
  const keys3 = Object.keys(obj);
  for (const k2 of keys3) {
    if (k2 in obj && obj[k2] === void 0) {
      delete obj[k2];
    }
  }
  return obj;
}
function guessUiType(login) {
  var _a2;
  if (login.creditCard) {
    return LoginUiType.creditCard;
  }
  if (((_a2 = login.websites) === null || _a2 === void 0 ? void 0 : _a2.length) || login.username || login.password || login.totp) {
    return LoginUiType.login;
  }
  if (login.note) {
    return LoginUiType.note;
  }
  return LoginUiType.login;
}
function removeDuplicates(arr) {
  return [...new Set(arr)];
}
function getNormalizedWebsites(websites, websiteAttributes) {
  const normalizedWebsitesSet = /* @__PURE__ */ new Set();
  const normalizedWebsiteAttributes = Object.assign({}, websiteAttributes);
  for (const unnormalizedWebsite of websites) {
    if (!unnormalizedWebsite) {
      continue;
    }
    const normalizedWebsite = normalizeWebsitePattern(unnormalizedWebsite);
    if (!normalizedWebsite || normalizedWebsitesSet.has(normalizedWebsite)) {
      continue;
    }
    normalizedWebsitesSet.add(normalizedWebsite);
    normalizedWebsiteAttributes[normalizedWebsite] = Object.assign(Object.assign({}, websiteAttributes[normalizedWebsite]), getWebsiteAttributesEntry(unnormalizedWebsite));
  }
  for (const key of Object.keys(normalizedWebsiteAttributes)) {
    if (!normalizedWebsitesSet.has(key)) {
      delete normalizedWebsiteAttributes[key];
    }
  }
  return { normalizedWebsites: [...normalizedWebsitesSet], normalizedWebsiteAttributes };
}
function getNormalizedCustomFields(customFields, emptyNameCustomFieldDefaultName) {
  const result = [];
  let index2 = 1;
  for (const cf2 of customFields) {
    if (cf2.name) {
      result.push(cf2);
    } else {
      while (
        // eslint-disable-next-line @typescript-eslint/no-loop-func
        customFields.find(({ name }) => name === `${emptyNameCustomFieldDefaultName} ${index2}`) || // eslint-disable-next-line @typescript-eslint/no-loop-func
        result.find(({ name }) => name === `${emptyNameCustomFieldDefaultName} ${index2}`)
      ) {
        index2++;
      }
      result.push(Object.assign(Object.assign({}, cf2), { name: `${emptyNameCustomFieldDefaultName} ${index2}` }));
    }
  }
  return result;
}
var __rest$u = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const LoginVaultContent = LoginVaultContentV2;
function transformLoginProtectedValues(l2, transform) {
  const { password, customFields, shareLinks, history, totp, creditCard } = l2, rest = __rest$u(l2, ["password", "customFields", "shareLinks", "history", "totp", "creditCard"]);
  let copy = Object.assign({}, rest);
  if ("password" in l2 && password !== void 0) {
    copy = Object.assign(Object.assign({}, copy), { password: transform(password) });
  }
  if ("totp" in l2) {
    copy = Object.assign(Object.assign({}, copy), { totp: totp ? transform(totp) : void 0 });
  }
  if ("customFields" in l2 && customFields !== void 0) {
    copy = Object.assign(Object.assign({}, copy), { customFields: customFields.map((cf2) => !cf2.protected ? cf2 : Object.assign(Object.assign({}, cf2), { value: transform(cf2.value) })) });
  }
  if ("creditCard" in l2) {
    copy = Object.assign(Object.assign({}, copy), { creditCard: creditCard ? Object.assign(Object.assign({}, creditCard), { securityCode: transform(creditCard.securityCode), pin: transform(creditCard.pin) }) : void 0 });
  }
  if ("history" in l2) {
    if (history == void 0) {
      copy = Object.assign(Object.assign({}, copy), { history: void 0 });
    } else {
      const revisions = {};
      for (const [id2, revision] of Object.entries(history.revisions)) {
        revisions[id2] = transformLoginProtectedValues(revision, transform);
      }
      copy = Object.assign(Object.assign({}, copy), { history: Object.assign(Object.assign({}, history), { revisions }) });
    }
  }
  if ("shareLinks" in l2) {
    copy = Object.assign(Object.assign({}, copy), { shareLinks: shareLinks ? shareLinks.map((sl2) => Object.assign(Object.assign({}, sl2), { secret: transform(sl2.secret) })) : void 0 });
  }
  return copy;
}
function createInitialVaultContent$1() {
  return { logins: {} };
}
function getActiveShareLinkIds(c2) {
  return Object.values(c2.logins).flatMap((l2) => {
    var _a2, _b;
    if (l2.isDeleted) {
      return [];
    }
    return (_b = (_a2 = l2.shareLinks) === null || _a2 === void 0 ? void 0 : _a2.flatMap((sl2) => sl2.openedAt ? [] : [sl2.id])) !== null && _b !== void 0 ? _b : [];
  });
}
const loginVaultContentDescriptor = {
  version: 2,
  contentTypeName: "login",
  vaultTypes: [VaultType.PRIVATE, VaultType.TEAM, VaultType.INBOX],
  parseVaultContent: LoginVaultContent.parse.bind(LoginVaultContent),
  createInitialVaultContent: createInitialVaultContent$1,
  postMergeHooks: {
    logins(left, right, chosen) {
      return loginMergeHistory(left, right, chosen);
    }
  },
  getActiveShareLinkIds
};
const organizationPersonalVaultContentDescriptor = {
  version: 2,
  contentTypeName: "organizationPersonal",
  vaultTypes: [VaultType.ORGANIZATION_PERSONAL],
  parseVaultContent: LoginVaultContent.parse.bind(LoginVaultContent),
  createInitialVaultContent: createInitialVaultContent$1,
  postMergeHooks: {
    logins(left, right, chosen) {
      return loginMergeHistory(left, right, chosen);
    }
  },
  getActiveShareLinkIds
};
function addLoginInternal(content, timestamp, login) {
  return modifyVault$1(content, "logins", (list) => {
    return addElement(list, timestamp, login);
  });
}
function addLoginInternalWithHistory(content, timestamp, login) {
  return modifyVault$1(content, "logins", (list) => {
    return addElement(list, timestamp, updateHistory(list, void 0, login));
  });
}
function modifyLoginInternal(content, timestamp, id2, login) {
  return modifyVault$1(content, "logins", (list) => {
    return modifyElement(list, timestamp, id2, login);
  });
}
function modifyLoginInternalWithHistory(content, timestamp, id2, login) {
  return modifyVault$1(content, "logins", (list) => {
    const fullLogin = unpackHeymergeListElement(modifyElement(list, timestamp, id2, login).newList[id2]);
    return modifyElement(list, timestamp, id2, updateHistory(list, id2, fullLogin));
  });
}
function addOrModifyLoginInternal(content, timestamp, id2, login) {
  return modifyVault$1(content, "logins", (list) => {
    return addOrModifyElement(list, timestamp, id2, login);
  });
}
function addOrModifyLoginInternalWithHistory(content, timestamp, id2, login) {
  return modifyVault$1(content, "logins", (list) => {
    return addOrModifyElement(list, timestamp, id2, updateHistory(list, id2, login));
  });
}
function deleteLoginInternal(content, timestamp, id2) {
  return modifyVault$1(content, "logins", (list) => {
    return removeElement(list, timestamp, id2);
  });
}
function archiveLoginInternal(content, timestamp, id2) {
  return modifyVault$1(content, "logins", (list) => {
    return archiveElement(list, timestamp, id2);
  });
}
function restoreArchivedLoginInternal(content, timestamp, id2) {
  return modifyVault$1(content, "logins", (list) => {
    return restoreArchivedElement(list, timestamp, id2);
  });
}
function updateHistory(previousList, id2, login) {
  let baseRevisionId;
  let previousRevisions;
  const previousElement = id2 ? previousList[id2] : void 0;
  const previousLogin = previousElement ? unpackHeymergeListElement(previousElement) : void 0;
  if (previousLogin) {
    if (previousLogin.history) {
      baseRevisionId = previousLogin.history.currentRevisionId;
      previousRevisions = previousLogin.history.revisions;
    } else {
      const backfillRevisionId = newUuid$1();
      previousRevisions = {
        [backfillRevisionId]: getLoginWithoutHistory(previousLogin)
      };
      baseRevisionId = backfillRevisionId;
    }
  } else {
    previousRevisions = void 0;
    baseRevisionId = void 0;
  }
  const currentRevisionId = newUuid$1();
  const loginWithoutHistory = getLoginWithoutHistory(login);
  const newRevision = Object.assign(Object.assign({}, loginWithoutHistory), { baseRevisionId });
  const loginWithHistory = Object.assign(Object.assign({}, login), {
    // History is merged from both sides with a post merge hook when a login is chosen on the
    // heymerge layer.
    history: {
      revisions: Object.assign(Object.assign({}, previousRevisions), { [currentRevisionId]: newRevision }),
      currentRevisionId
    }
  });
  return loginWithHistory;
}
function getLoginWithoutHistory(login) {
  const loginWithoutHistory = __rest$u(login, ["history"]);
  return loginWithoutHistory;
}
function loginMergeHistory(leftValue, rightValue, chosenValue) {
  var _a2, _b;
  const leftHistoryRevisions = leftValue.isDeleted ? void 0 : (_a2 = leftValue.history) === null || _a2 === void 0 ? void 0 : _a2.revisions;
  const rightHistoryRevisions = rightValue.isDeleted ? void 0 : (_b = rightValue.history) === null || _b === void 0 ? void 0 : _b.revisions;
  if (!chosenValue.isDeleted && chosenValue.history && (leftHistoryRevisions || rightHistoryRevisions) && !deepEqual$1(leftHistoryRevisions, rightHistoryRevisions)) {
    return Object.assign(Object.assign({}, chosenValue), { history: Object.assign(Object.assign({}, chosenValue.history), { revisions: Object.assign(Object.assign({}, leftHistoryRevisions), rightHistoryRevisions) }) });
  } else {
    return chosenValue;
  }
}
var __awaiter$M = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$t = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function addLogin(_a2, _b) {
  var ccs = __rest$t(_a2, []);
  var vaultId = _b.vaultId, login = _b.login, highSecurityCache = _b.highSecurityCache, source = _b.source, timesOverride = _b.timesOverride;
  return __awaiter$M(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    return modifyLoginVault(ccs, vault, (vaultContent, t2, { addLoginInternalWithHistory: addLoginInternalWithHistory2, protect: protect2 }) => {
      var _a3;
      const completedLogin = completeFullEditLogin(vault, ccs.profileRepo, t2, source, login, timesOverride);
      const { newVaultContent, result: loginId } = addLoginInternalWithHistory2(vaultContent, t2, recursivelyTransformUnprotectedValues(completedLogin, protect2));
      const modifiedLogin = newVaultContent.logins[loginId];
      return {
        newVaultContent,
        auditlogEvents: [
          {
            type: AuditlogEventType.LOGIN_W_CREATE,
            loginId,
            vaultId,
            loginEditTime: modifiedLogin.editTime,
            loginRevisionId: (_a3 = modifiedLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
            loginDifferences: getLoginDifferencesForChange(modifiedLogin, void 0, completedLogin)
          }
        ],
        result: loginId
      };
    }, highSecurityCache);
  });
}
function modifyLogin(_a2, _b) {
  var ccs = __rest$t(_a2, []);
  var vaultId = _b.vaultId, loginId = _b.loginId, login = _b.login, highSecurityCache = _b.highSecurityCache, timesOverride = _b.timesOverride, source = _b.source;
  return __awaiter$M(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    return modifyLoginVault(ccs, vault, (vaultContent, t2, { modifyLoginInternalWithHistory: modifyLoginInternalWithHistory2, protect: protect2 }) => {
      var _a3;
      const previousLogin = vaultContent.logins[loginId];
      const { newVaultContent } = modifyLoginInternalWithHistory2(vaultContent, t2, loginId, recursivelyTransformUnprotectedValues(completePartialEditLogin(vault, ccs.profileRepo, t2, source, login, timesOverride), protect2));
      const modifiedLogin = newVaultContent.logins[loginId];
      return {
        newVaultContent,
        auditlogEvents: [
          {
            type: AuditlogEventType.LOGIN_W_CHANGE,
            loginId,
            vaultId,
            loginEditTime: modifiedLogin.editTime,
            loginRevisionId: (_a3 = modifiedLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
            loginDifferences: getLoginDifferencesForChange(modifiedLogin, previousLogin)
          }
        ],
        result: void 0
      };
    }, highSecurityCache);
  });
}
function addOrModifyLogin(_a2, _b) {
  var ccs = __rest$t(_a2, []);
  var vaultId = _b.vaultId, loginId = _b.loginId, login = _b.login, highSecurityCache = _b.highSecurityCache, source = _b.source, timesOverride = _b.timesOverride;
  return __awaiter$M(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    const newCcs = modifyLoginVault(ccs, vault, (vaultContent, t2, { addOrModifyLoginInternalWithHistory: addOrModifyLoginInternalWithHistory2, protect: protect2 }) => {
      var _a3;
      const previousLogin = vaultContent.logins[loginId];
      const completedLogin = completeFullEditLogin(vault, ccs.profileRepo, t2, source, login, timesOverride, previousLogin);
      const { newVaultContent } = addOrModifyLoginInternalWithHistory2(vaultContent, t2, loginId, recursivelyTransformUnprotectedValues(completedLogin, protect2));
      const modifiedLogin = newVaultContent.logins[loginId];
      return {
        newVaultContent,
        auditlogEvents: [
          {
            type: previousLogin ? AuditlogEventType.LOGIN_W_CHANGE : AuditlogEventType.LOGIN_W_CREATE,
            loginId,
            vaultId,
            loginEditTime: modifiedLogin.editTime,
            loginRevisionId: (_a3 = modifiedLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
            loginDifferences: getLoginDifferencesForChange(modifiedLogin, previousLogin, completedLogin)
          }
        ],
        result: void 0
      };
    }, highSecurityCache);
    return Object.assign(Object.assign({}, newCcs), { returnResult: void 0 });
  });
}
function createInitialLoginHistoryEntryIfNecessary(_a2, _b) {
  var ccs = __rest$t(_a2, []);
  var vaultId = _b.vaultId, loginId = _b.loginId;
  return __awaiter$M(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    const previousLogin = vault.getContent().logins[loginId];
    if (!previousLogin) {
      throw new LoginNotFoundError(loginId);
    }
    if (previousLogin.history) {
      return Object.assign(Object.assign({}, ccs), { returnResult: previousLogin.history.currentRevisionId });
    }
    const newCcs = modifyLoginVault(ccs, vault, (vaultContent, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
      const initialRevisionId = newUuid$1();
      const loginWithoutHistory = __rest$t(previousLogin, ["history"]);
      const { newVaultContent } = modifyLoginInternal2(vaultContent, t2, loginId, {
        history: {
          currentRevisionId: initialRevisionId,
          revisions: {
            [initialRevisionId]: loginWithoutHistory
          }
        }
      });
      return { newVaultContent, auditlogEvents: [], result: initialRevisionId };
    });
    return newCcs;
  });
}
function copyLogins(_a2, toId, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    const logins = [];
    const { protectedSecretRepo } = ccs;
    if (!protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
      const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!fromVault) {
        throw new VaultNotFoundError(fromId);
      }
      const fromContent = fromVault.getContent();
      for (const loginId of loginIds) {
        const l2 = fromContent.logins[loginId];
        if (!l2) {
          throw new LoginNotFoundError(loginId);
        }
        if (l2.linkedFrom) {
          continue;
        }
        const redactedLogin = __rest$t(l2, ["shareLinks"]);
        const login = recursivelyTransformProtectedValues(redactedLogin, (pv) => protectedSecretRepo.unprotectWithContentId(fromVault, pv));
        logins.push(login);
      }
    }
    if (logins.length === 0) {
      return Object.assign(Object.assign({}, ccs), { returnResult: [] });
    }
    const toVault = ccs.vaultRepo.getLoginVaultById(toId);
    if (!toVault) {
      throw new VaultNotFoundError(toId);
    }
    return modifyLoginVault(ccs, toVault, (vaultContent, t2, { addLoginInternal: addLoginInternal2, protect: protect2 }) => {
      var _a3;
      const copiedLoginIds = [];
      const auditlogEvents = [];
      for (let _b of logins) {
        const login = __rest$t(_b, ["linkedTo"]);
        const { newVaultContent, result } = addLoginInternal2(vaultContent, t2, Object.assign(Object.assign({}, recursivelyTransformUnprotectedValues(login, protect2)), { editTime: t2, changeTime: t2 }));
        copiedLoginIds.push(result);
        auditlogEvents.push({
          type: AuditlogEventType.LOGIN_W_CREATE,
          vaultId: toId,
          loginId: result,
          loginEditTime: login.editTime,
          loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
          loginDifferences: getLoginDifferences(emptyUnprotectedLogin, recursivelyTransformUnprotectedValues(login, (upv) => upv.unencrypted))
        });
        vaultContent = newVaultContent;
      }
      return { newVaultContent: vaultContent, auditlogEvents, result: copiedLoginIds };
    });
  });
}
function deleteLogins(_a2, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
      const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!fromVault) {
        throw new VaultNotFoundError(fromId);
      }
      ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { deleteLoginInternal: deleteLoginInternal2 }) => {
        var _a3;
        const auditlogEvents = [];
        let newVaultContent = vaultContent;
        for (const loginId of loginIds) {
          const login = newVaultContent.logins[loginId];
          if (login === void 0) {
            throw new LoginNotFoundError(loginId);
          }
          if (login.isDeleted) {
            continue;
          }
          ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, loginId));
          auditlogEvents.push({
            type: AuditlogEventType.LOGIN_W_DELETE,
            loginId,
            vaultId: fromId,
            loginEditTime: login.editTime,
            loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
          });
        }
        return { newVaultContent, auditlogEvents, result: void 0 };
      });
    }
    return ccs;
  });
}
function isLoginTrashable(login) {
  return !login.linkedFrom;
}
function deleteOrArchiveLogins(_a2, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
      const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!fromVault) {
        throw new VaultNotFoundError(fromId);
      }
      const { profileRepo } = ccs;
      ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { deleteLoginInternal: deleteLoginInternal2, archiveLoginInternal: archiveLoginInternal2, modifyLoginInternal: modifyLoginInternal2 }) => {
        var _a3, _b;
        const auditlogEvents = [];
        const archivedByProfileId = getVaultEditProfileId(fromVault, profileRepo);
        let newVaultContent = vaultContent;
        for (const loginId of loginIds) {
          const login = newVaultContent.logins[loginId];
          if (!login) {
            throw new LoginNotFoundError(loginId);
          }
          if (login.isDeleted) {
            return { newVaultContent, auditlogEvents: [], result: void 0 };
          }
          if (!isLoginTrashable(login)) {
            ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, loginId));
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_DELETE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
            });
          } else {
            ({ newVaultContent } = modifyLoginInternal2(newVaultContent, t2, loginId, {
              shareLinks: void 0,
              linkedTo: void 0,
              archiveInfo: {
                archiveTime: t2,
                archivedByProfileId
              }
            }));
            ({ newVaultContent } = archiveLoginInternal2(newVaultContent, t2, loginId));
            auditlogEvents.push({
              type: AuditlogEventType.LOGIN_W_ARCHIVE,
              loginId,
              vaultId: fromId,
              loginEditTime: login.editTime,
              loginRevisionId: (_b = login.history) === null || _b === void 0 ? void 0 : _b.currentRevisionId
            });
          }
        }
        return { newVaultContent, auditlogEvents, result: void 0 };
      });
    }
    return ccs;
  });
}
function restoreArchivedLogins(_a2, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
      const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!fromVault) {
        throw new VaultNotFoundError(fromId);
      }
      ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { restoreArchivedLoginInternal: restoreArchivedLoginInternal2, modifyLoginInternal: modifyLoginInternal2 }) => {
        var _a3;
        const auditlogEvents = [];
        let newVaultContent = vaultContent;
        for (const loginId of loginIds) {
          const login = newVaultContent.logins[loginId];
          if (!login) {
            throw new LoginNotFoundError(loginId);
          }
          if (!login.isDeleted) {
            return { newVaultContent, auditlogEvents: [], result: void 0 };
          }
          if (!login.isArchived) {
            throw new LoginNotFoundError(loginId);
          }
          ({ newVaultContent } = restoreArchivedLoginInternal2(newVaultContent, t2, loginId));
          ({ newVaultContent } = modifyLoginInternal2(newVaultContent, t2, loginId, {
            archiveInfo: void 0,
            changeTime: t2
          }));
          auditlogEvents.push({
            type: AuditlogEventType.LOGIN_W_RESTORE_FROM_ARCHIVE,
            loginId,
            vaultId: fromId,
            loginEditTime: login.editTime,
            loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
          });
        }
        return { newVaultContent, auditlogEvents, result: void 0 };
      });
    }
    return ccs;
  });
}
function deleteArchivedLogins(_a2, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
      const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!fromVault) {
        throw new VaultNotFoundError(fromId);
      }
      ccs = modifyLoginVault(ccs, fromVault, (vaultContent, t2, { deleteLoginInternal: deleteLoginInternal2 }) => {
        var _a3;
        const auditlogEvents = [];
        let newVaultContent = vaultContent;
        for (const loginId of loginIds) {
          const login = newVaultContent.logins[loginId];
          if (!login || !login.isDeleted || !login.isArchived) {
            throw new LoginNotFoundError(loginId);
          }
          auditlogEvents.push({
            type: AuditlogEventType.LOGIN_W_DELETE,
            loginId,
            vaultId: fromId,
            loginEditTime: login.editTime,
            loginRevisionId: (_a3 = login.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId
          });
          ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, loginId));
        }
        return { newVaultContent, auditlogEvents, result: void 0 };
      });
    }
    return ccs;
  });
}
function moveLogins(_a2, toId, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    const copyResult = yield copyLogins(ccs, toId, from);
    ccs = yield deleteLogins(copyResult, from);
    return Object.assign(Object.assign({}, ccs), { returnResult: copyResult.returnResult });
  });
}
function modifyTagsForLogin(_a2, _b) {
  var ccs = __rest$t(_a2, []);
  var vaultId = _b.vaultId, loginIds = _b.loginIds, addTags = _b.addTags, removeTags = _b.removeTags, source = _b.source, highSecurityCache = _b.highSecurityCache;
  return __awaiter$M(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    return modifyLoginVault(ccs, vault, (content, t2, { modifyLoginInternalWithHistory: modifyLoginInternalWithHistory2 }) => {
      return loginIds.reduce((accumulator, loginId) => {
        var _a3;
        const login = accumulator.newVaultContent.logins[loginId];
        if (!login || !isHeymergeListValue(login)) {
          return accumulator;
        }
        const newTagsSet = new Set(login.tags);
        if (removeTags === null || removeTags === void 0 ? void 0 : removeTags.length) {
          removeTags.forEach((tag) => newTagsSet.delete(tag));
        }
        if (addTags === null || addTags === void 0 ? void 0 : addTags.length) {
          addTags.forEach((tag) => newTagsSet.add(tag));
        }
        const oldTags = (_a3 = login.tags) !== null && _a3 !== void 0 ? _a3 : [];
        if (newTagsSet.size == oldTags.length && oldTags.every((tag) => newTagsSet.has(tag))) {
          return accumulator;
        }
        return {
          newVaultContent: modifyLoginInternalWithHistory2(accumulator.newVaultContent, t2, loginId, completePartialEditLogin(vault, ccs.profileRepo, t2, source, {
            tags: [...newTagsSet]
          })).newVaultContent,
          auditlogEvents: [],
          result: accumulator.result + 1
        };
      }, { newVaultContent: content, auditlogEvents: [], result: 0 });
    }, highSecurityCache);
  });
}
function modifyLinkedViewSecretsForLogin(_a2, targetVaultId, loginId, linkedViewSecrets) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(targetVaultId);
    if (!vault) {
      throw new VaultNotFoundError(targetVaultId);
    }
    return modifyLoginVault(ccs, vault, (content, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
      const result = modifyLoginInternal2(content, t2, loginId, { linkedViewSecrets });
      return Object.assign(Object.assign({}, result), { auditlogEvents: [] });
    });
  });
}
function importLogins(_a2, targetVaultId, logins, emptyNameCustomFieldDefaultName) {
  var _b, _c2;
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    const targetVault = ccs.vaultRepo.getLoginVaultById(targetVaultId);
    if (!targetVault) {
      throw new VaultNotFoundError(targetVaultId);
    }
    const targetVaultOrgProfile = targetVault.organizationId ? ccs.profileRepo.getOrganizationProfile(targetVault.organizationId) : void 0;
    const profileId = (_c2 = (_b = targetVaultOrgProfile === null || targetVaultOrgProfile === void 0 ? void 0 : targetVaultOrgProfile.profile.id) !== null && _b !== void 0 ? _b : targetVault.getProfileId()) !== null && _c2 !== void 0 ? _c2 : void 0;
    return modifyLoginVault(ccs, targetVault, (c2, t2, { addLoginInternalWithHistory: addLoginInternalWithHistory2, protect: protect2 }) => {
      var _a3;
      const auditlogEvents = [];
      const existingLoginHashes = new Set(Object.values(c2.logins).filter((l2) => !l2.isDeleted).flatMap(getLoginHashes));
      let added = 0;
      let skippedDuplicate = 0;
      let skippedUnnamed = 0;
      let newVaultContent = c2;
      for (const unprotectedLogin of logins) {
        const fullUnprotectedLogin = sanitizeLoginFromImport(unprotectedLogin, profileId, t2, emptyNameCustomFieldDefaultName);
        const isLoginAndUnnamed = fullUnprotectedLogin.uiType === LoginUiType.login && fullUnprotectedLogin.username === "" && fullUnprotectedLogin.title === "" && fullUnprotectedLogin.websites.every((ws) => ws === "");
        if (isLoginAndUnnamed) {
          skippedUnnamed++;
          continue;
        }
        const hashes = getLoginHashes(fullUnprotectedLogin);
        const loginIsNew = hashes.some((h2) => !existingLoginHashes.has(h2));
        if (!loginIsNew) {
          skippedDuplicate++;
          continue;
        }
        let loginId;
        ({ newVaultContent, result: loginId } = addLoginInternalWithHistory2(newVaultContent, t2, transformLoginProtectedValues(fullUnprotectedLogin, (unencrypted) => protect2({ contentId: newUuid$1(), unencrypted }))));
        const newLogin = newVaultContent.logins[loginId];
        auditlogEvents.push({
          type: AuditlogEventType.LOGIN_W_CREATE,
          vaultId: targetVaultId,
          loginId,
          loginEditTime: newLogin.editTime,
          loginRevisionId: (_a3 = newLogin.history) === null || _a3 === void 0 ? void 0 : _a3.currentRevisionId,
          loginDifferences: getLoginDifferences(emptyUnprotectedLogin, fullUnprotectedLogin)
        });
        added++;
      }
      return {
        newVaultContent,
        auditlogEvents,
        result: { added, skippedDuplicate, skippedUnnamed }
      };
    });
  });
}
function linkLoginsToTeam(_a2, orgId, toVaultId, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    const toVault = ccs.vaultRepo.getLoginVaultById(toVaultId);
    if (!toVault) {
      throw new VaultNotFoundError(toVaultId);
    }
    if ((toVault === null || toVault === void 0 ? void 0 : toVault.type) !== VaultType.TEAM) {
      throw new Error("tried to link to non-team vault in linkLoginsToTeam");
    }
    if (toVault.organizationId !== orgId) {
      throw new Error("orgId mismatch for linking");
    }
    const org = ccs.accountState.getOrganization(toVault.organizationId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    ccs.accountState = ccs.accountState.withLocalAchievements([
      Achievement.COR_LINKED_LOGIN_CREATE_TEAM
    ]);
    return linkLoginsInternal(ccs, org.id, toVaultId, null, from);
  });
}
function linkLoginsToPersonalVault(_a2, orgId, toProfileId, from) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    ccs.accountState = ccs.accountState.withLocalAchievements([
      Achievement.COR_LINKED_LOGIN_CREATE_PERSONAL
    ]);
    const personalVaultId = findPersonalVaultId(ccs.accountState, ccs.vaultRepo, orgId, toProfileId);
    return linkLoginsInternal(ccs, orgId, personalVaultId, toProfileId, from);
  });
}
function linkLoginsInternal(ccs, orgId, targetVaultId, targetPersonalProfileId, from) {
  return __awaiter$M(this, void 0, void 0, function* () {
    const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
    if (!orgProfile) {
      throw new OrganizationNotFoundError();
    }
    const linkedByProfileId = orgProfile.profile.id;
    for (const [fromId, loginIds] of groupByVaultId(from).entries()) {
      const fromVault = ccs.vaultRepo.getLoginVaultById(fromId);
      if (!fromVault) {
        throw new VaultNotFoundError(fromId);
      }
      if (fromId === targetVaultId) {
        throw new Error("internal: can't link login to identical vault");
      }
      return modifyLoginVault(ccs, fromVault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
        let newVaultContent = c2;
        for (const loginId of loginIds) {
          const existingElement = newVaultContent.logins[loginId];
          if (!existingElement || existingElement.isDeleted) {
            throw new LoginNotFoundError(loginId);
          }
          const originalLinkedTo = existingElement === null || existingElement === void 0 ? void 0 : existingElement.linkedTo;
          const linkedTo = originalLinkedTo ? [...originalLinkedTo] : [];
          const existing = linkedTo.find((lt) => lt.targetVaultId === targetVaultId);
          if (existing) {
            existing.addTime = t2;
            existing.removeTime = null;
          } else {
            linkedTo.push({
              targetVaultId,
              // NOTE: this value is not checked here, it is up to the caller to make sure it is
              // correct!
              targetPersonalProfileId,
              addTime: t2,
              linkedByProfileId,
              removeTime: null
            });
          }
          newVaultContent = modifyLoginInternal2(newVaultContent, t2, loginId, {
            linkedTo
          }).newVaultContent;
        }
        return { newVaultContent, auditlogEvents: [], result: void 0 };
      });
    }
    return ccs;
  });
}
function unlinkLogins(_a2, fromId, toIds, loginIds) {
  var ccs = __rest$t(_a2, []);
  return __awaiter$M(this, void 0, void 0, function* () {
    const originalVault = ccs.vaultRepo.getLoginVaultById(fromId);
    if (!originalVault) {
      throw new VaultNotFoundError(fromId);
    }
    const fromContent = originalVault.getContent();
    return modifyLoginVault(ccs, originalVault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
      var _a3;
      let newVaultContent = c2;
      for (const loginId of loginIds) {
        const originalLinkedTo = (_a3 = fromContent.logins[loginId]) === null || _a3 === void 0 ? void 0 : _a3.linkedTo;
        if (!originalLinkedTo) {
          continue;
        }
        const linkedTo = originalLinkedTo.map((lt) => {
          const shouldBeDeleted = toIds.some((id2) => lt.targetVaultId === id2);
          return shouldBeDeleted ? Object.assign(Object.assign({}, lt), { removeTime: t2 }) : lt;
        });
        newVaultContent = modifyLoginInternal2(newVaultContent, t2, loginId, {
          linkedTo
        }).newVaultContent;
      }
      return { newVaultContent, auditlogEvents: [], result: void 0 };
    });
  });
}
function groupByVaultId(from) {
  const loginIdsByVault = /* @__PURE__ */ new Map();
  for (const { vaultId, loginId } of from) {
    if (!loginIdsByVault.has(vaultId)) {
      loginIdsByVault.set(vaultId, []);
    }
    loginIdsByVault.get(vaultId).push(loginId);
  }
  return loginIdsByVault;
}
function getLoginHashes(l2) {
  var _a2;
  if (l2.uiType === LoginUiType.creditCard) {
    return [canonicalize({ creditCardNumber: (_a2 = l2.creditCard) === null || _a2 === void 0 ? void 0 : _a2.number, title: l2.title })];
  }
  if (l2.uiType === LoginUiType.note) {
    return [canonicalize({ secureNote: l2.note, title: l2.title })];
  }
  if (l2.uiType === LoginUiType.wifi) {
    if (l2.username) {
      return [canonicalize({ wifiSsid: l2.wifiSsid, username: l2.username })];
    }
    return [canonicalize({ wifiSsid: l2.wifiSsid, title: l2.title })];
  }
  if (l2.websites.length) {
    return l2.websites.map((ws) => canonicalize(l2.username ? { username: l2.username, ws } : { title: l2.title, ws }));
  }
  return [canonicalize(l2.username ? { username: l2.username } : { title: l2.title })];
}
function completePartialEditLogin(vault, profileRepo, t2, source, editLogin, timesOverride) {
  const profileId = getVaultEditProfileId(vault, profileRepo);
  return Object.assign(Object.assign(Object.assign({}, editLogin), { editTime: t2, editProfileId: profileId, editSource: source, changeTime: t2 }), timesOverride);
}
function completeFullEditLogin(vault, profileRepo, t2, source, editLogin, timesOverride, previousLogin) {
  const profileId = getVaultEditProfileId(vault, profileRepo);
  return Object.assign(Object.assign(Object.assign({ creationTime: previousLogin ? previousLogin.creationTime : t2, creationProfileId: previousLogin ? previousLogin.creationProfileId : profileId, creationSource: previousLogin ? previousLogin.creationSource : source }, editLogin), { editTime: t2, editProfileId: profileId, editSource: source, changeTime: t2 }), timesOverride);
}
function getVaultEditProfileId(vault, profileRepo) {
  var _a2, _b;
  const organizationProfileId = vault.organizationId ? (_a2 = profileRepo.getOrganizationProfile(vault.organizationId)) === null || _a2 === void 0 ? void 0 : _a2.profile.id : void 0;
  const profileId = (_b = organizationProfileId !== null && organizationProfileId !== void 0 ? organizationProfileId : vault.getProfileId()) !== null && _b !== void 0 ? _b : void 0;
  return profileId;
}
function getLoginDifferencesForChange(modifiedLogin, previousLogin, completedLogin) {
  return previousLogin ? getLoginDifferences(previousLogin, modifiedLogin) : getLoginDifferences(emptyUnprotectedLogin, recursivelyTransformUnprotectedValues(completedLogin, (upv) => upv.unencrypted));
}
var __awaiter$L = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AuditlogWriteResult;
(function(AuditlogWriteResult2) {
  AuditlogWriteResult2["Ok"] = "ok";
  AuditlogWriteResult2["Failure"] = "failure";
  AuditlogWriteResult2["Retry"] = "retry";
})(AuditlogWriteResult || (AuditlogWriteResult = {}));
function onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, events) {
  return __awaiter$L(this, void 0, void 0, function* () {
    try {
      let auditlogWriteClient;
      ({ ccs, auditlogWriteClient } = yield onlineGetAuditlogWriteClient(ccs, orgId));
      yield auditlogWriteClient.writeEvents(events);
      return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Ok });
    } catch (e2) {
      if (e2 instanceof DomainError) {
        if (e2.code === BackendClientErrorCode.NoResponse) {
          return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Retry });
        }
        if (e2.code === BackendErrorCode.ORGANIZATION_NOT_FOUND) {
          return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Failure });
        }
        if (e2.code === BackendErrorCode.INTERNAL || e2.code === BackendClientErrorCode.InvalidGrpcResponse) {
          trackError(e2);
          return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Retry });
        }
      }
      trackError(e2);
      return Object.assign(Object.assign({}, ccs), { returnResult: AuditlogWriteResult.Failure });
    }
  });
}
function onlineGetAuditlogWriteClient(ccs, orgId) {
  return __awaiter$L(this, void 0, void 0, function* () {
    const cachedToken = ccs.auditlogWriteTokenCache.getToken(orgId);
    if (cachedToken) {
      const auditlogWriteClient2 = ccs.backendClient.getAuditlogWriteClient(cachedToken);
      return { ccs, auditlogWriteClient: auditlogWriteClient2 };
    }
    const token = yield ccs.backendClient.credential.createAuditlogWriteToken(orgId);
    ccs.auditlogWriteTokenCache = ccs.auditlogWriteTokenCache.withToken(orgId, token, token.expiresAt);
    const auditlogWriteClient = ccs.backendClient.getAuditlogWriteClient(token);
    return { ccs, auditlogWriteClient };
  });
}
function loadForeignProfile(dto) {
  const { id: id2, keyGenerationId } = dto;
  const highSecurityIdentitySigPubKey = loadSigningPublicKey(dto.highSecurityIdentitySigPubKey);
  const highSecurityVaultKeyEncPubKey = loadEncryptionPublicKey(dto.highSecurityVaultKeyEncPubKey);
  const highSecurityVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityVaultKeyEncPubKeySignature);
  const highSecurityProfileSeedEncPubKey = loadEncryptionPublicKey(dto.highSecurityProfileSeedEncPubKey);
  const highSecurityProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.highSecurityProfileSeedEncPubKeySignature);
  const storableSigPubKey = loadSigningPublicKey(dto.storableSigPubKey);
  const storableSigPubKeySignature = loadSigningPublicKeySignature(dto.storableSigPubKeySignature);
  const storableVaultKeyEncPubKey = loadEncryptionPublicKey(dto.storableVaultKeyEncPubKey);
  const storableVaultKeyEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableVaultKeyEncPubKeySignature);
  const storableProfileSeedEncPubKey = loadEncryptionPublicKey(dto.storableProfileSeedEncPubKey);
  const storableProfileSeedEncPubKeySignature = loadEncryptionPublicKeySignature(dto.storableProfileSeedEncPubKeySignature);
  return {
    id: id2,
    keyGenerationId,
    highSecurityIdentitySigPubKey,
    highSecurityVaultKeyEncPubKey,
    highSecurityVaultKeyEncPubKeySignature,
    highSecurityProfileSeedEncPubKey,
    highSecurityProfileSeedEncPubKeySignature,
    storableSigPubKey,
    storableSigPubKeySignature,
    storableVaultKeyEncPubKey,
    storableVaultKeyEncPubKeySignature,
    storableProfileSeedEncPubKey,
    storableProfileSeedEncPubKeySignature
  };
}
function serializeVaultProfileLock(lock) {
  return {
    lockingProfileId: lock.lockingProfileId,
    lockingProfileKeyGenerationId: lock.lockingProfileKeyGenerationId,
    encryptedStorableVaultKey: lock.encryptedStorableVaultKey,
    encryptedHighSecurityVaultKey: lock.encryptedHighSecurityVaultKey,
    encryptedVaultMessagePrivateKey: lock.encryptedVaultMessagePrivateKey
  };
}
class Commit {
  constructor(id2, parentId, blob) {
    this.id = id2;
    this.parentId = parentId;
    this.blob = blob;
  }
  static create(parentId, secret, state) {
    const blob = symEncrypt(secret, state);
    return new Commit(nullUuid, parentId, blob);
  }
  static load({ id: id2, parentId, blob }) {
    return new Commit(id2, parentId, loadSymEncryptedBlob(blob));
  }
  getContent(secret) {
    return symDecrypt(secret, this.blob);
  }
}
function serializeVaultAuthenticatorLock(lock) {
  return {
    authenticatorId: lock.authenticatorId,
    encryptedStorableVaultKey: lock.encryptedStorableVaultKey,
    encryptedHighSecurityVaultKey: lock.encryptedHighSecurityVaultKey,
    encryptedVaultMessagePrivateKey: lock.encryptedVaultMessagePrivateKey
  };
}
function unlockLockVaultSecret(vaultAccess, locks, profileLock, adminProfileLock) {
  if (vaultAccess.type === "admin-profile") {
    const { unlockedProfile: up2 } = vaultAccess;
    if (!adminProfileLock) {
      throw new LockProfileNotFoundError(up2.profile.id);
    }
    if (up2.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
      throw new ProfileKeyGenerationMismatchError(up2.profile.id, up2.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
    }
    return asymDecryptKek(up2.storableVaultKeyEncPrivKey, adminProfileLock.encryptedStorableVaultKey);
  } else if (vaultAccess.type === "profile") {
    const { unlockedProfile: up2 } = vaultAccess;
    if (!profileLock) {
      throw new LockProfileNotFoundError(up2.profile.id);
    }
    if (up2.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
      throw new ProfileKeyGenerationMismatchError(up2.profile.id, up2.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
    }
    return asymDecryptKek(up2.storableVaultKeyEncPrivKey, profileLock.encryptedStorableVaultKey);
  } else {
    const { unlockedAuthenticator: ua2 } = vaultAccess;
    const candidateLock = locks.find((lock) => lock.authenticatorId === ua2.authenticator.id);
    if (!candidateLock) {
      throw new LockAuthenticatorNotFoundError(ua2.authenticator.id, locks);
    }
    return asymDecryptKek(ua2.storableVaultKeyEncPrivKey, candidateLock.encryptedStorableVaultKey);
  }
}
var snappyjs = {};
var snappy_decompressor = {};
var WORD_MASK = [0, 255, 65535, 16777215, 4294967295];
function copyBytes$1(fromArray, fromPos, toArray2, toPos, length) {
  var i;
  for (i = 0; i < length; i++) {
    toArray2[toPos + i] = fromArray[fromPos + i];
  }
}
function selfCopyBytes(array, pos, offset, length) {
  var i;
  for (i = 0; i < length; i++) {
    array[pos + i] = array[pos - offset + i];
  }
}
function SnappyDecompressor$1(compressed) {
  this.array = compressed;
  this.pos = 0;
}
SnappyDecompressor$1.prototype.readUncompressedLength = function() {
  var result = 0;
  var shift = 0;
  var c2, val;
  while (shift < 32 && this.pos < this.array.length) {
    c2 = this.array[this.pos];
    this.pos += 1;
    val = c2 & 127;
    if (val << shift >>> shift !== val) {
      return -1;
    }
    result |= val << shift;
    if (c2 < 128) {
      return result;
    }
    shift += 7;
  }
  return -1;
};
SnappyDecompressor$1.prototype.uncompressToBuffer = function(outBuffer) {
  var array = this.array;
  var arrayLength = array.length;
  var pos = this.pos;
  var outPos = 0;
  var c2, len, smallLen;
  var offset;
  while (pos < array.length) {
    c2 = array[pos];
    pos += 1;
    if ((c2 & 3) === 0) {
      len = (c2 >>> 2) + 1;
      if (len > 60) {
        if (pos + 3 >= arrayLength) {
          return false;
        }
        smallLen = len - 60;
        len = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
        len = (len & WORD_MASK[smallLen]) + 1;
        pos += smallLen;
      }
      if (pos + len > arrayLength) {
        return false;
      }
      copyBytes$1(array, pos, outBuffer, outPos, len);
      pos += len;
      outPos += len;
    } else {
      switch (c2 & 3) {
        case 1:
          len = (c2 >>> 2 & 7) + 4;
          offset = array[pos] + (c2 >>> 5 << 8);
          pos += 1;
          break;
        case 2:
          if (pos + 1 >= arrayLength) {
            return false;
          }
          len = (c2 >>> 2) + 1;
          offset = array[pos] + (array[pos + 1] << 8);
          pos += 2;
          break;
        case 3:
          if (pos + 3 >= arrayLength) {
            return false;
          }
          len = (c2 >>> 2) + 1;
          offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
          pos += 4;
          break;
      }
      if (offset === 0 || offset > outPos) {
        return false;
      }
      selfCopyBytes(outBuffer, outPos, offset, len);
      outPos += len;
    }
  }
  return true;
};
snappy_decompressor.SnappyDecompressor = SnappyDecompressor$1;
var snappy_compressor = {};
var BLOCK_LOG = 16;
var BLOCK_SIZE = 1 << BLOCK_LOG;
var MAX_HASH_TABLE_BITS = 14;
var globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);
function hashFunc(key, hashFuncShift) {
  return key * 506832829 >>> hashFuncShift;
}
function load32(array, pos) {
  return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
}
function equals32(array, pos1, pos2) {
  return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];
}
function copyBytes(fromArray, fromPos, toArray2, toPos, length) {
  var i;
  for (i = 0; i < length; i++) {
    toArray2[toPos + i] = fromArray[fromPos + i];
  }
}
function emitLiteral(input, ip2, len, output, op2) {
  if (len <= 60) {
    output[op2] = len - 1 << 2;
    op2 += 1;
  } else if (len < 256) {
    output[op2] = 60 << 2;
    output[op2 + 1] = len - 1;
    op2 += 2;
  } else {
    output[op2] = 61 << 2;
    output[op2 + 1] = len - 1 & 255;
    output[op2 + 2] = len - 1 >>> 8;
    op2 += 3;
  }
  copyBytes(input, ip2, output, op2, len);
  return op2 + len;
}
function emitCopyLessThan64(output, op2, offset, len) {
  if (len < 12 && offset < 2048) {
    output[op2] = 1 + (len - 4 << 2) + (offset >>> 8 << 5);
    output[op2 + 1] = offset & 255;
    return op2 + 2;
  } else {
    output[op2] = 2 + (len - 1 << 2);
    output[op2 + 1] = offset & 255;
    output[op2 + 2] = offset >>> 8;
    return op2 + 3;
  }
}
function emitCopy(output, op2, offset, len) {
  while (len >= 68) {
    op2 = emitCopyLessThan64(output, op2, offset, 64);
    len -= 64;
  }
  if (len > 64) {
    op2 = emitCopyLessThan64(output, op2, offset, 60);
    len -= 60;
  }
  return emitCopyLessThan64(output, op2, offset, len);
}
function compressFragment(input, ip2, inputSize, output, op2) {
  var hashTableBits = 1;
  while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {
    hashTableBits += 1;
  }
  hashTableBits -= 1;
  var hashFuncShift = 32 - hashTableBits;
  if (typeof globalHashTables[hashTableBits] === "undefined") {
    globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);
  }
  var hashTable = globalHashTables[hashTableBits];
  var i;
  for (i = 0; i < hashTable.length; i++) {
    hashTable[i] = 0;
  }
  var ipEnd = ip2 + inputSize;
  var ipLimit;
  var baseIp = ip2;
  var nextEmit = ip2;
  var hash2, nextHash;
  var nextIp, candidate, skip;
  var bytesBetweenHashLookups;
  var base2, matched, offset;
  var prevHash, curHash;
  var flag = true;
  var INPUT_MARGIN = 15;
  if (inputSize >= INPUT_MARGIN) {
    ipLimit = ipEnd - INPUT_MARGIN;
    ip2 += 1;
    nextHash = hashFunc(load32(input, ip2), hashFuncShift);
    while (flag) {
      skip = 32;
      nextIp = ip2;
      do {
        ip2 = nextIp;
        hash2 = nextHash;
        bytesBetweenHashLookups = skip >>> 5;
        skip += 1;
        nextIp = ip2 + bytesBetweenHashLookups;
        if (ip2 > ipLimit) {
          flag = false;
          break;
        }
        nextHash = hashFunc(load32(input, nextIp), hashFuncShift);
        candidate = baseIp + hashTable[hash2];
        hashTable[hash2] = ip2 - baseIp;
      } while (!equals32(input, ip2, candidate));
      if (!flag) {
        break;
      }
      op2 = emitLiteral(input, nextEmit, ip2 - nextEmit, output, op2);
      do {
        base2 = ip2;
        matched = 4;
        while (ip2 + matched < ipEnd && input[ip2 + matched] === input[candidate + matched]) {
          matched += 1;
        }
        ip2 += matched;
        offset = base2 - candidate;
        op2 = emitCopy(output, op2, offset, matched);
        nextEmit = ip2;
        if (ip2 >= ipLimit) {
          flag = false;
          break;
        }
        prevHash = hashFunc(load32(input, ip2 - 1), hashFuncShift);
        hashTable[prevHash] = ip2 - 1 - baseIp;
        curHash = hashFunc(load32(input, ip2), hashFuncShift);
        candidate = baseIp + hashTable[curHash];
        hashTable[curHash] = ip2 - baseIp;
      } while (equals32(input, ip2, candidate));
      if (!flag) {
        break;
      }
      ip2 += 1;
      nextHash = hashFunc(load32(input, ip2), hashFuncShift);
    }
  }
  if (nextEmit < ipEnd) {
    op2 = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op2);
  }
  return op2;
}
function putVarint(value, output, op2) {
  do {
    output[op2] = value & 127;
    value = value >>> 7;
    if (value > 0) {
      output[op2] += 128;
    }
    op2 += 1;
  } while (value > 0);
  return op2;
}
function SnappyCompressor$1(uncompressed) {
  this.array = uncompressed;
}
SnappyCompressor$1.prototype.maxCompressedLength = function() {
  var sourceLen = this.array.length;
  return 32 + sourceLen + Math.floor(sourceLen / 6);
};
SnappyCompressor$1.prototype.compressToBuffer = function(outBuffer) {
  var array = this.array;
  var length = array.length;
  var pos = 0;
  var outPos = 0;
  var fragmentSize;
  outPos = putVarint(length, outBuffer, outPos);
  while (pos < length) {
    fragmentSize = Math.min(length - pos, BLOCK_SIZE);
    outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);
    pos += fragmentSize;
  }
  return outPos;
};
snappy_compressor.SnappyCompressor = SnappyCompressor$1;
function isNode() {
  if (typeof process === "object") {
    if (typeof process.versions === "object") {
      if (typeof process.versions.node !== "undefined") {
        return true;
      }
    }
  }
  return false;
}
function isUint8Array(object) {
  return object instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object));
}
function isArrayBuffer(object) {
  return object instanceof ArrayBuffer;
}
function isBuffer$2(object) {
  if (!isNode()) {
    return false;
  }
  return Buffer.isBuffer(object);
}
var SnappyDecompressor = snappy_decompressor.SnappyDecompressor;
var SnappyCompressor = snappy_compressor.SnappyCompressor;
var TYPE_ERROR_MSG = "Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array";
function uncompress(compressed) {
  if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer$2(compressed)) {
    throw new TypeError(TYPE_ERROR_MSG);
  }
  var uint8Mode = false;
  var arrayBufferMode = false;
  if (isUint8Array(compressed)) {
    uint8Mode = true;
  } else if (isArrayBuffer(compressed)) {
    arrayBufferMode = true;
    compressed = new Uint8Array(compressed);
  }
  var decompressor = new SnappyDecompressor(compressed);
  var length = decompressor.readUncompressedLength();
  if (length === -1) {
    throw new Error("Invalid Snappy bitstream");
  }
  var uncompressed, uncompressedView;
  if (uint8Mode) {
    uncompressed = new Uint8Array(length);
    if (!decompressor.uncompressToBuffer(uncompressed)) {
      throw new Error("Invalid Snappy bitstream");
    }
  } else if (arrayBufferMode) {
    uncompressed = new ArrayBuffer(length);
    uncompressedView = new Uint8Array(uncompressed);
    if (!decompressor.uncompressToBuffer(uncompressedView)) {
      throw new Error("Invalid Snappy bitstream");
    }
  } else {
    uncompressed = Buffer.alloc(length);
    if (!decompressor.uncompressToBuffer(uncompressed)) {
      throw new Error("Invalid Snappy bitstream");
    }
  }
  return uncompressed;
}
function compress(uncompressed) {
  if (!isUint8Array(uncompressed) && !isArrayBuffer(uncompressed) && !isBuffer$2(uncompressed)) {
    throw new TypeError(TYPE_ERROR_MSG);
  }
  var uint8Mode = false;
  var arrayBufferMode = false;
  if (isUint8Array(uncompressed)) {
    uint8Mode = true;
  } else if (isArrayBuffer(uncompressed)) {
    arrayBufferMode = true;
    uncompressed = new Uint8Array(uncompressed);
  }
  var compressor = new SnappyCompressor(uncompressed);
  var maxLength = compressor.maxCompressedLength();
  var compressed, compressedView;
  var length;
  if (uint8Mode) {
    compressed = new Uint8Array(maxLength);
    length = compressor.compressToBuffer(compressed);
  } else if (arrayBufferMode) {
    compressed = new ArrayBuffer(maxLength);
    compressedView = new Uint8Array(compressed);
    length = compressor.compressToBuffer(compressedView);
  } else {
    compressed = Buffer.alloc(maxLength);
    length = compressor.compressToBuffer(compressed);
  }
  return compressed.slice(0, length);
}
snappyjs.uncompress = uncompress;
snappyjs.compress = compress;
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const FORMAT_UNCOMPRESSED_AUTOMERGE = 91;
const FORMAT_UNCOMPRESSED_HEYMERGE = 123;
const FORMAT_SNAPPY = 1;
function prependByte(data, byte) {
  const result = new Uint8Array(data.byteLength + 1);
  result[0] = byte;
  result.set(data, 1);
  return result;
}
function serializeData(obj) {
  const str = JSON.stringify(obj);
  const bin = encoder.encode(str);
  const compressed = snappyjs.compress(bin);
  return prependByte(compressed, FORMAT_SNAPPY);
}
function deserializeData(data) {
  let decompressed;
  if (data[0] === FORMAT_UNCOMPRESSED_AUTOMERGE || data[0] === FORMAT_UNCOMPRESSED_HEYMERGE) {
    decompressed = data;
  } else if (data[0] === FORMAT_SNAPPY) {
    decompressed = snappyjs.uncompress(data.slice(1));
  } else {
    throw new UnsupportedCompressionError();
  }
  const str = decoder.decode(decompressed);
  const obj = JSON.parse(str);
  return obj;
}
const MetaVaultContent = MetaVaultContentV2;
function createInitialMetaVaultContent() {
  return { sessions: {} };
}
const metaVaultContentDescriptor = {
  version: 2,
  contentTypeName: "meta",
  vaultTypes: [VaultType.META],
  parseVaultContent: MetaVaultContent.parse.bind(MetaVaultContent),
  createInitialVaultContent: createInitialMetaVaultContent
};
function replaceSession(content, timestamp, id2, session) {
  const newVault = modifyVault$1(content, "sessions", (list) => {
    var _a2;
    const oldSessionMeta = list[id2];
    const newElement = Object.assign(Object.assign(Object.assign({ creationTime: timestamp }, oldSessionMeta), session), { editTime: (_a2 = session === null || session === void 0 ? void 0 : session.editTime) !== null && _a2 !== void 0 ? _a2 : timestamp, isDeleted: false, updateTime: timestamp });
    return {
      newList: Object.assign(Object.assign({}, list), { [id2]: newElement }),
      result: void 0
    };
  });
  if (!MetaVaultContent.safeParse(newVault.newVaultContent).success) {
    throw new InvalidSessionModificationError();
  }
  return newVault;
}
function deleteSession(content, timestamp, id2) {
  return modifyVault$1(content, "sessions", (list) => {
    return removeElement(list, timestamp, id2);
  });
}
function addOrModifySiteSettings(content, timestamp, host, siteSettings) {
  return modifyVault$1(content, "siteSettings", (list) => {
    return addOrModifyElement(list, timestamp, host, siteSettings);
  });
}
function getAccountSettings(content) {
  var _a2;
  return (_a2 = content.accountSettings) === null || _a2 === void 0 ? void 0 : _a2[META_VAULT_ACCOUNT_SETTINGS_ID];
}
function modifyAccountSettings(content, timestamp, settings) {
  return modifyVault$1(content, "accountSettings", (list) => {
    if (!list[META_VAULT_ACCOUNT_SETTINGS_ID]) {
      return addOrModifyElement(list, timestamp, META_VAULT_ACCOUNT_SETTINGS_ID, Object.assign({}, settings));
    }
    return modifyElement(list, timestamp, META_VAULT_ACCOUNT_SETTINGS_ID, settings);
  });
}
const { OrganizationAdminVaultContent } = OAV;
function getOrganizationAdminVaultInfo(content) {
  var _a2;
  return (_a2 = content.info) === null || _a2 === void 0 ? void 0 : _a2[ORGANIZATION_ADMIN_VAULT_INFO_ID];
}
function createInitialVaultContent() {
  return { info: {} };
}
const organizationAdminVaultContentDescriptor = {
  version: 2,
  contentTypeName: "organizationAdminV2",
  vaultTypes: [VaultType.ORGANIZATION_ADMIN],
  parseVaultContent: OrganizationAdminVaultContent.parse.bind(OrganizationAdminVaultContent),
  createInitialVaultContent
};
function replaceOrganizationAdminVaultInfo(content, timestamp, info) {
  return modifyVault$1(content, "info", (list) => {
    return addOrModifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
  });
}
function modifyOrganizationAdminVaultInfo(content, timestamp, info) {
  return modifyVault$1(content, "info", (list) => {
    return modifyElement(list, timestamp, ORGANIZATION_ADMIN_VAULT_INFO_ID, info);
  });
}
function getVaultContentDescriptorByName(vaultType, contentTypeName, version) {
  const descriptor = getVaultContentDescriptor(contentTypeName, version);
  if (!descriptor.vaultTypes.includes(vaultType)) {
    throw new InvalidVaultContentDescriptorNameError(contentTypeName);
  }
  return descriptor;
}
function getVaultContentDescriptor(contentTypeName, version) {
  if (version !== DESCRIPTOR_VERSION_HEYMERGE) {
    throw new UnsupportedVaultVersionError();
  }
  switch (contentTypeName) {
    case loginVaultContentDescriptor.contentTypeName:
      return loginVaultContentDescriptor;
    case organizationPersonalVaultContentDescriptor.contentTypeName:
      return organizationPersonalVaultContentDescriptor;
    case metaVaultContentDescriptor.contentTypeName:
      return metaVaultContentDescriptor;
    case teamMetaVaultContentDescriptor.contentTypeName:
      return teamMetaVaultContentDescriptor;
    case legacyOrganizationAdminVaultContentDescriptor.contentTypeName:
      return legacyOrganizationAdminVaultContentDescriptor;
    case organizationAdminVaultContentDescriptor.contentTypeName:
      return organizationAdminVaultContentDescriptor;
    default:
      throw new InvalidVaultContentDescriptorNameError(contentTypeName);
  }
}
const validModificationFunctions = {
  addLoginInternal,
  modifyLoginInternal,
  addOrModifyLoginInternal,
  addLoginInternalWithHistory,
  modifyLoginInternalWithHistory,
  addOrModifyLoginInternalWithHistory,
  deleteLoginInternal,
  archiveLoginInternal,
  restoreArchivedLoginInternal,
  replaceSession,
  deleteSession,
  addOrModifySiteSettings,
  modifyTeamVaultInfo,
  addOrModifyTeamVaultUser,
  deleteTeamVaultUser,
  replaceLegacyOrganizationAdminVaultInfo,
  modifyLegacyOrganizationAdminVaultInfo,
  replaceOrganizationAdminVaultInfo,
  modifyOrganizationAdminVaultInfo,
  modifyAccountSettings
};
class VaultState {
  constructor(descriptor, state, stagedState) {
    this.descriptor = descriptor;
    this.state = state;
    this.stagedState = stagedState;
  }
  static createEmpty(descriptor) {
    return new VaultState(descriptor, descriptor.createInitialVaultContent(), {
      diff: descriptor.createInitialVaultContent(),
      updateTime: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  static initializeFromCommits(vaultType, commits) {
    const lastCommit = commits[commits.length - 1];
    const lastCommitState = deserializeData(lastCommit);
    if (Array.isArray(lastCommitState)) {
      throw new UnsupportedVaultVersionError();
    }
    const lastCommitStateParsed = VaultStateInternalStructure.safeParse(lastCommitState);
    if (!lastCommitStateParsed.success) {
      throw new InvalidCommitStructureError();
    }
    const descriptor = getVaultContentDescriptorByName(vaultType, lastCommitStateParsed.data.type, lastCommitStateParsed.data.version);
    let content = {};
    for (const commit of commits) {
      const commitState = deserializeData(commit);
      if (Array.isArray(commitState)) {
        throw new UnsupportedVaultVersionError();
      }
      const commitContent = VaultState.parseStateFromCommit(descriptor, commitState);
      content = mergeVaults(content, commitContent, descriptor.postMergeHooks).newVaultContent;
    }
    return new VaultState(descriptor, content, null);
  }
  static parseCommit(descriptor, inputCommit) {
    const parsed = VaultStateInternalStructure.safeParse(inputCommit);
    if (!parsed.success) {
      throw new InvalidCommitStructureError();
    }
    const state = parsed.data;
    if (state.version > descriptor.version) {
      throw new VaultContentTooNewError();
    }
    if (state.version < descriptor.version) {
      throw new NotImplementedError("vault content migration");
    }
    let content;
    try {
      content = descriptor.parseVaultContent(state.content);
    } catch (e2) {
      trackError(e2);
      throw new InvalidCommitContentError();
    }
    return Object.assign(Object.assign({}, parsed.data), { content });
  }
  static parseStateFromCommit(descriptor, inputCommit) {
    return VaultState.parseCommit(descriptor, inputCommit).content;
  }
  withModification(modification) {
    var _a2, _b;
    const updateTime = (/* @__PURE__ */ new Date()).toISOString();
    const { newVaultContent: modifiedContent, result: modificationReturnValue } = modification(this.state, updateTime, validModificationFunctions);
    this.descriptor.parseVaultContent(modifiedContent);
    const { newVaultContent: newDiff } = diffVaults(this.state, modifiedContent, this.descriptor.postMergeHooks);
    const { newVaultContent } = mergeVaults((_b = (_a2 = this.stagedState) === null || _a2 === void 0 ? void 0 : _a2.diff) !== null && _b !== void 0 ? _b : this.descriptor.createInitialVaultContent(), newDiff, this.descriptor.postMergeHooks);
    const stagedState = {
      diff: newVaultContent,
      updateTime
    };
    return {
      state: new VaultState(this.descriptor, modifiedContent, stagedState),
      vaultContentDiff: newDiff,
      result: modificationReturnValue
    };
  }
  getContent() {
    return unpackHeymergeVaultContent(this.state);
  }
  getArchivedContent() {
    return unpackHeymergeVaultContentArchive(this.state);
  }
  getContentInternal() {
    return this.state;
  }
  applyCommit(commitData) {
    const deserialized = deserializeData(commitData);
    const commit = VaultState.parseCommit(this.descriptor, deserialized);
    const newState = this.loadAndValidateState(commit);
    return new VaultState(this.descriptor, newState, this.stagedState);
  }
  applyStagedDiff(diff) {
    var _a2, _b;
    const commit = deserializeData(diff);
    const newState = this.loadAndValidateState(commit);
    const { newVaultContent } = mergeVaults((_b = (_a2 = this.stagedState) === null || _a2 === void 0 ? void 0 : _a2.diff) !== null && _b !== void 0 ? _b : this.descriptor.createInitialVaultContent(), commit.content, this.descriptor.postMergeHooks);
    const stagedState = {
      diff: newVaultContent,
      updateTime: getMaxVaultUpdateTime(newVaultContent)
    };
    return new VaultState(this.descriptor, newState, stagedState);
  }
  loadAndValidateState(diff) {
    const { newVaultContent: content } = mergeVaults(
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
      this.state,
      diff.content,
      this.descriptor.postMergeHooks
    );
    const state = {
      type: diff.type,
      version: diff.version,
      content
    };
    VaultState.parseCommit(this.descriptor, state);
    return state.content;
  }
  getSquashedState() {
    const diff = diffVaults(this.descriptor.createInitialVaultContent(), this.state, this.descriptor.postMergeHooks);
    const commitWrap = {
      type: this.descriptor.contentTypeName,
      version: this.descriptor.version,
      content: diff.newVaultContent
    };
    return serializeData(commitWrap);
  }
  getStagedDiff(cappedUpdateTime) {
    if (this.stagedState === null) {
      return null;
    }
    let { state } = this;
    let { diff } = this.stagedState;
    if (cappedUpdateTime && cappedUpdateTime < this.stagedState.updateTime) {
      for (const k2 of getObjectKeys(diff)) {
        const { newVaultContent } = modifyVault$1(diff, k2, (list) => {
          return setMaxUpdateTime(list, cappedUpdateTime);
        });
        diff = newVaultContent;
      }
      for (const k2 of getObjectKeys(state)) {
        const { newVaultContent } = modifyVault$1(state, k2, (list) => {
          return setMaxUpdateTime(list, cappedUpdateTime);
        });
        state = newVaultContent;
      }
    }
    const commitWrap = {
      type: this.descriptor.contentTypeName,
      version: this.descriptor.version,
      content: diff
    };
    return {
      diff: serializeData(commitWrap),
      vaultState: new VaultState(this.descriptor, state, null),
      latestUpdateTime: cappedUpdateTime ? cappedUpdateTime : this.stagedState.updateTime
    };
  }
  hasStagedDiff() {
    return this.stagedState !== null;
  }
  getLatestUpdateTime() {
    var _a2, _b;
    return (_b = (_a2 = this.stagedState) === null || _a2 === void 0 ? void 0 : _a2.updateTime) !== null && _b !== void 0 ? _b : null;
  }
}
function getObjectKeys(obj) {
  return Object.keys(obj);
}
class Vault {
  constructor(id2, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, linkedUpdateMessages, shareLinkUpdates) {
    this.id = id2;
    this.type = type;
    this.associatedVaultId = associatedVaultId;
    this.generationId = generationId;
    this.firstCommitId = firstCommitId;
    this.commitId = commitId;
    this.userIds = userIds;
    this.profileIds = profileIds;
    this.organizationId = organizationId;
    this.authenticatorLocks = authenticatorLocks;
    this.profileLock = profileLock;
    this.adminProfileLock = adminProfileLock;
    this.dirty = dirty;
    this.isUserJoined = isUserJoined;
    this.vaultState = vaultState;
    this.vaultSecret = vaultSecret;
    this.messagePublicKey = messagePublicKey;
    this.messageQueue = messageQueue;
    this.inboxSlug = inboxSlug;
    this.linkedUpdateMessages = linkedUpdateMessages;
    this.shareLinkUpdates = shareLinkUpdates;
  }
  static createFromCommits(id2, type, associatedVaultId, generationId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, vaultSecret, commits, stagedDiff, profileRepo, messagePublicKey, messageQueue, inboxSlug) {
    const firstCommitId = commits[0].id;
    const commitId = commits.slice(-1)[0].id;
    const rawCommits = commits.map((c2) => c2.getContent(vaultSecret));
    let vaultState = VaultState.initializeFromCommits(type, rawCommits);
    if (stagedDiff) {
      vaultState = vaultState.applyStagedDiff(stagedDiff);
    }
    const isUserJoined = profileRepo.profiles.some((p2) => profileIds.includes(p2.profile.id));
    if (profileLock) {
      const profile = profileRepo.getUnlocked(profileLock.lockingProfileId);
      if (!profile) {
        throw new LockProfileNotFoundError(profileLock.lockingProfileId);
      }
      if (profile.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(profile.profile.id, profile.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
      }
    } else if (adminProfileLock && organizationId) {
      const profile = profileRepo.getOrgAdminProfile(organizationId);
      if (!profile) {
        throw new LockProfileNotFoundError(adminProfileLock.lockingProfileId);
      }
      if (profile.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(profile.profile.id, profile.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
      }
    }
    return new Vault(id2, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, [], []);
  }
  static createFromPersistable(pv, vaultAccess) {
    var _a2, _b, _c2, _d;
    const authenticatorLocks = pv.locks.map((al2) => VaultAuthenticatorLock.load(al2));
    const profileLock = pv.profileLock ? VaultProfileLock.load(pv.profileLock) : null;
    const adminProfileLock = pv.adminProfileLock ? VaultProfileLock.load(pv.adminProfileLock) : null;
    const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
    const vaultType = pv.type;
    let vaultState = VaultState.initializeFromCommits(vaultType, [pv.vaultState]);
    if (pv.stagedDiff) {
      vaultState = vaultState.applyStagedDiff(pv.stagedDiff);
    }
    const isUserJoined = vaultAccess.type === "profile";
    const messagePublicKey = pv.messagePublicKey ? loadEncryptionPublicKey(pv.messagePublicKey) : null;
    return new Vault(pv.id, vaultType, (_a2 = pv.associatedVaultId) !== null && _a2 !== void 0 ? _a2 : null, pv.generationId, (_b = pv.firstCommitId) !== null && _b !== void 0 ? _b : null, pv.commitId, pv.userIds, (_c2 = pv.profileIds) !== null && _c2 !== void 0 ? _c2 : [], (_d = pv.organizationId) !== null && _d !== void 0 ? _d : null, authenticatorLocks, profileLock, adminProfileLock, !!pv.dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, [], pv.inboxSlug, pv.linkedUpdateMessages, []);
  }
  getPersistable() {
    var _a2, _b, _c2;
    const vaultState = this.vaultState.getSquashedState();
    const stagedDiff = (_b = (_a2 = this.vaultState.getStagedDiff()) === null || _a2 === void 0 ? void 0 : _a2.diff) !== null && _b !== void 0 ? _b : null;
    return {
      id: this.id,
      type: this.type,
      associatedVaultId: this.associatedVaultId,
      generationId: this.generationId,
      firstCommitId: (_c2 = this.firstCommitId) !== null && _c2 !== void 0 ? _c2 : void 0,
      commitId: this.commitId,
      userIds: this.userIds,
      profileIds: this.profileIds,
      organizationId: this.organizationId,
      locks: this.authenticatorLocks.map((l2) => serializeVaultAuthenticatorLock(l2)),
      profileLock: this.profileLock ? serializeVaultProfileLock(this.profileLock) : void 0,
      adminProfileLock: this.adminProfileLock ? serializeVaultProfileLock(this.adminProfileLock) : void 0,
      dirty: this.dirty,
      vaultState,
      stagedDiff,
      messagePublicKey: this.messagePublicKey,
      inboxSlug: this.inboxSlug,
      linkedUpdateMessages: this.linkedUpdateMessages
    };
  }
  getProfileId() {
    var _a2, _b;
    return (_b = (_a2 = this.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) !== null && _b !== void 0 ? _b : null;
  }
  getPersonalProfileId() {
    var _a2, _b;
    if (this.type !== VaultType.ORGANIZATION_PERSONAL) {
      return null;
    }
    if (this.profileLock) {
      return (_a2 = this.profileIds.find((id2) => {
        var _a3;
        return id2 === ((_a3 = this.profileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId);
      })) !== null && _a2 !== void 0 ? _a2 : null;
    } else if (this.adminProfileLock) {
      return (_b = this.profileIds.find((id2) => {
        var _a3;
        return id2 !== ((_a3 = this.adminProfileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId);
      })) !== null && _b !== void 0 ? _b : null;
    }
    return null;
  }
  with({ type = this.type, id: id2 = this.id, associatedVaultId = this.associatedVaultId, generationId = this.generationId, firstCommitId = this.firstCommitId, commitId = this.commitId, userIds = this.userIds, profileIds = this.profileIds, organizationId = this.organizationId, authenticatorLocks = this.authenticatorLocks, profileLock = this.profileLock, adminProfileLock = this.adminProfileLock, dirty = this.dirty, isUserJoined = this.isUserJoined, vaultState = this.vaultState, vaultSecret = this.vaultSecret, messageQueue = this.messageQueue, messagePublicKey = this.messagePublicKey, inboxSlug = this.inboxSlug, linkedUpdateMessages = this.linkedUpdateMessages, shareLinkUpdates = this.shareLinkUpdates }) {
    return new Vault(id2, type, associatedVaultId, generationId, firstCommitId, commitId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, isUserJoined, vaultState, vaultSecret, messagePublicKey, messageQueue, inboxSlug, linkedUpdateMessages, shareLinkUpdates);
  }
  withSyncUpdate(su2, profileRepo) {
    let { userIds, profileIds, dirty, organizationId, profileLock, adminProfileLock, isUserJoined, messagePublicKey, inboxSlug } = this;
    let changed = false;
    const newUserIds = su2.users.map((u2) => u2.id);
    if (!deepEqual$1(userIds, newUserIds)) {
      changed = true;
      userIds = newUserIds;
    }
    const newProfileIds = su2.profiles.map((p2) => p2.id);
    if (!deepEqual$1(profileIds, newProfileIds)) {
      changed = true;
      profileIds = newProfileIds;
    }
    const newIsUserJoined = profileRepo.profiles.some((p2) => profileIds.includes(p2.profile.id));
    if (isUserJoined !== newIsUserJoined) {
      changed = true;
      isUserJoined = newIsUserJoined;
    }
    if (this.profileLock && (su2.profileKeyGenerationId !== this.profileLock.lockingProfileKeyGenerationId || !isUserJoined)) {
      changed = true;
      profileLock = null;
    }
    if (this.adminProfileLock && (su2.adminProfileKeyGenerationId !== this.adminProfileLock.lockingProfileKeyGenerationId || isUserJoined)) {
      changed = true;
      adminProfileLock = null;
    }
    if (su2.dirty !== dirty) {
      changed = true;
      dirty = su2.dirty;
    }
    if (su2.organizationId !== organizationId) {
      changed = true;
      organizationId = su2.organizationId;
    }
    if (su2.inboxSlug !== inboxSlug) {
      changed = true;
      inboxSlug = su2.inboxSlug;
    }
    const newMessagePublicKey = su2.messagePublicKey ? loadEncryptionPublicKey(su2.messagePublicKey) : null;
    if (!deepEqual$1(newMessagePublicKey, messagePublicKey)) {
      changed = true;
      messagePublicKey = newMessagePublicKey;
    }
    if (!changed) {
      return this;
    }
    return this.with({
      userIds,
      profileIds,
      dirty,
      organizationId,
      profileLock,
      adminProfileLock,
      isUserJoined,
      inboxSlug,
      messagePublicKey
    });
  }
  withDirty(dirty = true) {
    return this.dirty === dirty ? this : this.with({ dirty });
  }
  withLoadCommits(...commits) {
    let { commitId, vaultState } = this;
    for (const commit of commits) {
      if (commitId !== commit.parentId) {
        throw new ParentIdDoesntMatchError(this.commitId, commit.parentId);
      }
      try {
        const commitData = commit.getContent(this.vaultSecret);
        commitId = commit.id;
        vaultState = vaultState.applyCommit(commitData);
      } catch (e2) {
        commitId = commit.id;
        trackError(e2);
      }
    }
    return this.with({ commitId, vaultState });
  }
  withMessageQueue(messageQueue) {
    return this.with({ messageQueue });
  }
  withAddMessageQueue(...messageQueue) {
    const knownMessageIds = this.messageQueue.map((m2) => m2.id);
    const newMessages = messageQueue.filter((m2) => !knownMessageIds.includes(m2.id));
    return this.with({ messageQueue: [...this.messageQueue, ...newMessages] });
  }
  withLocks(vaultAccess, authenticatorLocks, profileLock, adminProfileLock) {
    if (vaultAccess.type === "admin-profile") {
      const { unlockedProfile: up2 } = vaultAccess;
      if (!adminProfileLock) {
        throw new LockProfileNotFoundError(up2.profile.id);
      }
      if (up2.profile.keyGenerationId !== adminProfileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up2.profile.id, up2.profile.keyGenerationId, adminProfileLock.lockingProfileKeyGenerationId);
      }
      return this.with({ authenticatorLocks: [], profileLock, adminProfileLock });
    } else if (vaultAccess.type === "profile") {
      const { unlockedProfile: up2 } = vaultAccess;
      if (!profileLock) {
        throw new LockProfileNotFoundError(up2.profile.id);
      }
      if (up2.profile.keyGenerationId !== profileLock.lockingProfileKeyGenerationId) {
        throw new ProfileKeyGenerationMismatchError(up2.profile.id, up2.profile.keyGenerationId, profileLock.lockingProfileKeyGenerationId);
      }
      return this.with({ authenticatorLocks: [], profileLock });
    } else {
      const { unlockedAuthenticator: ua2 } = vaultAccess;
      const isAuthenticatorLockAvailable = authenticatorLocks.some((l2) => l2.authenticatorId === ua2.authenticator.id);
      if (!isAuthenticatorLockAvailable) {
        throw new LockAuthenticatorNotFoundError(ua2.authenticator.id, authenticatorLocks);
      }
      return this.with({ authenticatorLocks, profileLock, adminProfileLock });
    }
  }
  withFirstCommitId(firstCommitId) {
    if (this.firstCommitId !== null) {
      throw new Error("Cannot change firstCommitId once set!");
    }
    return this.with({ firstCommitId });
  }
  getContentType() {
    return this.vaultState.descriptor.contentTypeName;
  }
  getVersion() {
    return this.vaultState.descriptor.version;
  }
  getStagedDiff(cappedUpdateTime) {
    const stagedData = this.vaultState.getStagedDiff(cappedUpdateTime === null || cappedUpdateTime === void 0 ? void 0 : cappedUpdateTime.toISOString());
    if (stagedData === null) {
      return null;
    }
    const { diff, vaultState, latestUpdateTime } = stagedData;
    const stagingVault = this.with({
      commitId: nullUuid,
      vaultState,
      linkedUpdateMessages: [],
      shareLinkUpdates: []
    });
    const { linkedUpdateMessages, shareLinkUpdates } = this;
    return { stagingVault, diff, latestUpdateTime, linkedUpdateMessages, shareLinkUpdates };
  }
  hasStagedDiff() {
    return this.vaultState.hasStagedDiff();
  }
  withCommitId(commitId) {
    if (this.id === nullUuid || this.commitId !== nullUuid) {
      throw new CannotOverrideCommitIdError();
    }
    return this.with({ commitId });
  }
  withModification(mod) {
    const { state: vaultState, vaultContentDiff, result } = this.vaultState.withModification(
      // @ts-ignore -- ts doesn't understand that HeymergeVaultContent<VaultContentSpec<T>> = T
      mod
    );
    return {
      vault: this.with({ vaultState }),
      // @ts-ignore -- ts doesn't understand that HeymergeVaultContent<VaultContentSpec<T>> = T
      vaultContentDiff,
      result
    };
  }
  withAddLinkedUpdateMessage(...linkedUpdateMessages) {
    return this.with({
      linkedUpdateMessages: [...this.linkedUpdateMessages, ...linkedUpdateMessages]
    });
  }
  withAddShareLinkUpdate(...shareLinkUpdates) {
    return this.with({
      shareLinkUpdates: [...this.shareLinkUpdates, ...shareLinkUpdates]
    });
  }
  getContent() {
    return this.vaultState.getContent();
  }
  getArchivedContent() {
    return this.vaultState.getArchivedContent();
  }
  getContentInternal() {
    return this.vaultState.getContentInternal();
  }
}
class UnsyncedVault {
  constructor(type, userIds, profileIds, authenticatorLocks, profileLock, adminProfileLock, vaultState, commitBlob, organizationId, vaultSecret, protectedSecret, messageKeyPair, inbox) {
    this.type = type;
    this.userIds = userIds;
    this.profileIds = profileIds;
    this.authenticatorLocks = authenticatorLocks;
    this.profileLock = profileLock;
    this.adminProfileLock = adminProfileLock;
    this.vaultState = vaultState;
    this.commitBlob = commitBlob;
    this.organizationId = organizationId;
    this.vaultSecret = vaultSecret;
    this.protectedSecret = protectedSecret;
    this.messageKeyPair = messageKeyPair;
    this.inbox = inbox;
  }
  getCreationDto() {
    var _a2, _b;
    return {
      blob: this.getCommitBlob(),
      locks: this.getAuthenticatorLockDtos(),
      profileLock: this.getProfileLockDto(),
      adminProfileLock: this.getAdminProfileLockDto(),
      messagePublicKey: (_a2 = this.messageKeyPair) === null || _a2 === void 0 ? void 0 : _a2.encPubKey,
      organizationId: (_b = this.organizationId) !== null && _b !== void 0 ? _b : void 0
    };
  }
  getAuthenticatorLockDtos() {
    return this.authenticatorLocks.map(serializeVaultAuthenticatorLock);
  }
  getProfileLockDto() {
    var _a2;
    return (_a2 = this.profileLock) !== null && _a2 !== void 0 ? _a2 : void 0;
  }
  getAdminProfileLockDto() {
    var _a2;
    return (_a2 = this.adminProfileLock) !== null && _a2 !== void 0 ? _a2 : void 0;
  }
  getExtraProfileLockDto(up2) {
    var _a2, _b;
    return VaultProfileLock.create(up2, this.vaultSecret, this.protectedSecret, (_b = (_a2 = this.messageKeyPair) === null || _a2 === void 0 ? void 0 : _a2.encPrivKey) !== null && _b !== void 0 ? _b : null);
  }
  getExtraLockDto(ua2) {
    const encryptedStorableVaultKey = asymCreateKek(ua2.storableVaultKeyEncPubKey, this.vaultSecret);
    const encryptedHighSecurityVaultKey = asymCreateKek(ua2.highSecurityVaultKeyEncPubKey, this.protectedSecret);
    const encryptedVaultMessagePrivateKey = this.messageKeyPair ? asymEncryptEncryptionPrivateKey(ua2.highSecurityVaultKeyEncPubKey, this.messageKeyPair.encPrivKey) : null;
    return {
      encryptedStorableVaultKey,
      encryptedHighSecurityVaultKey,
      encryptedVaultMessagePrivateKey
    };
  }
  getCommitBlob() {
    return this.commitBlob;
  }
  static create(type, userIds, profileIds, authenticators, profile, adminProfile, organizationId, descriptor, inbox, mod) {
    const vaultSecret = newSymmetricSecret();
    const protectedSecret = newSymmetricSecret();
    const messageKeyPair = newEncryptionKeyPair();
    const authenticatorLocks = authenticators.map((a2) => VaultAuthenticatorLock.create(a2, vaultSecret, protectedSecret, messageKeyPair.encPrivKey));
    const profileLock = profile ? VaultProfileLock.create(profile, vaultSecret, protectedSecret, messageKeyPair.encPrivKey) : null;
    const adminProfileLock = adminProfile ? VaultProfileLock.create(adminProfile, vaultSecret, protectedSecret, messageKeyPair.encPrivKey) : null;
    const initialVaultState = UnsyncedVault.createInitialVaultState(descriptor, protectedSecret, mod);
    const { diff, vaultState } = initialVaultState.getStagedDiff();
    const { blob } = Commit.create(null, vaultSecret, diff);
    return new UnsyncedVault(type, userIds, profileIds, authenticatorLocks, profileLock, adminProfileLock, vaultState, blob, organizationId, vaultSecret, protectedSecret, messageKeyPair, inbox);
  }
  static createInitialVaultState(descriptor, protectedSecret, mod) {
    if (descriptor.version !== DESCRIPTOR_VERSION_HEYMERGE) {
      throw new UnsupportedVaultVersionError();
    }
    let initialVaultState = VaultState.createEmpty(descriptor);
    if (mod) {
      ({ state: initialVaultState } = initialVaultState.withModification(UnsyncedVault.wrapMod(mod, protectedSecret)));
    }
    return initialVaultState;
  }
  static wrapMod(mod, protectedSecret) {
    return (c2, t2, fns) => {
      return mod(c2, t2, Object.assign(Object.assign({}, fns), {
        protect: protect.bind(null, protectedSecret),
        unprotect: unprotect.bind(null, protectedSecret),
        unprotectWithContentId: unprotectWithContentId.bind(null, protectedSecret),
        // NOTE: there are no vault messages in unsynced vaults, so decryptVaultMessage is not needed
        decryptVaultMessage: null
      }));
    };
  }
  withIds(vaultId, generationId, commitId, associatedVaultId, organizationId) {
    var _a2, _b, _c2, _d;
    const firstCommitId = commitId;
    return new Vault(vaultId, this.type, associatedVaultId !== null && associatedVaultId !== void 0 ? associatedVaultId : null, generationId, firstCommitId, commitId, this.userIds, this.profileIds, organizationId, this.authenticatorLocks, this.profileLock, this.adminProfileLock, false, true, this.vaultState, this.vaultSecret, (_b = (_a2 = this.messageKeyPair) === null || _a2 === void 0 ? void 0 : _a2.encPubKey) !== null && _b !== void 0 ? _b : null, [], (_d = (_c2 = this.inbox) === null || _c2 === void 0 ? void 0 : _c2.slug) !== null && _d !== void 0 ? _d : null, [], []);
  }
}
class HighSecurityCache {
  constructor(userHsua) {
    this.userHsua = userHsua;
    this.cachedHighSecurityUnlockedProfiles = {};
  }
  static fromExisting(userHsua) {
    return new HighSecurityCache(userHsua);
  }
  static fromSecret(secret, authenticator) {
    const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(authenticator, secret);
    return new HighSecurityCache(hsua);
  }
  static fromSessionUnlock(unlockData, sessionEncPrivKey, authenticators) {
    const authenticator = authenticators.find((a2) => unlockData.authenticatorId === a2.id);
    if (authenticator === void 0) {
      throw new UnlockedAuthenticatorNotFoundError();
    }
    const { encryptedSecret } = unlockData;
    const hsua = HighSecurityUnlockedAuthenticator.fromAuthenticatorSecret(authenticator, {
      authenticatorId: authenticator.id,
      seed: asymDecrypt(sessionEncPrivKey, loadAsymEncryptedBlob(encryptedSecret))
    });
    return new HighSecurityCache(hsua);
  }
  getAuthenticator() {
    return this.userHsua.authenticator;
  }
  getHighSecurityUnlockedAuthenticator() {
    return this.userHsua;
  }
  getHighSecurityUnlockedProfile(unlockedProfile, profileRepo) {
    if (this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId]) {
      return this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId];
    }
    if (unlockedProfile.profile.profileLock) {
      const parentUp = profileRepo.getUnlocked(unlockedProfile.profile.profileLock.lockingProfileId);
      if (!parentUp) {
        throw new LockProfileNotFoundError(unlockedProfile.profile.profileLock.lockingProfileId);
      }
      const parentHsup = this.getHighSecurityUnlockedProfile(parentUp, profileRepo);
      if (!parentHsup) {
        throw new LockProfileNotFoundError(unlockedProfile.profile.profileLock.lockingProfileId);
      }
      const hsup = HighSecurityUnlockedProfile.fromProfileLock(unlockedProfile, parentHsup);
      this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId] = hsup;
      return hsup;
    } else {
      const hsup = HighSecurityUnlockedProfile.fromAuthenticatorLocks(unlockedProfile, this.userHsua);
      this.cachedHighSecurityUnlockedProfiles[unlockedProfile.profile.keyGenerationId] = hsup;
      return hsup;
    }
  }
}
const KNOWN_USER_PROFILE_TYPES = [
  ProfileType.PREFERENCES,
  ProfileType.INBOX,
  ProfileType.PRIVATE,
  ProfileType.ORGANIZATION,
  ProfileType.ORGANIZATION_SERVICE
];
const LOGIN_PROFILE_TYPES = [
  ProfileType.PRIVATE,
  ProfileType.ORGANIZATION,
  ProfileType.ORGANIZATION_SERVICE
];
const ORGANIZATION_PROFILE_TYPES = [
  ProfileType.ORGANIZATION,
  ProfileType.ORGANIZATION_SERVICE
];
class ProfileRepo {
  constructor(profiles, disabledProfiles, orgAdminProfiles) {
    this.profiles = profiles;
    this.disabledProfiles = disabledProfiles;
    this.orgAdminProfiles = orgAdminProfiles;
  }
  static create(profiles, disabledProfiles) {
    profiles.sort((a2, b2) => {
      if (a2.profile.profileType !== b2.profile.profileType) {
        return a2.profile.profileType - b2.profile.profileType;
      }
      return a2.profile.id.localeCompare(b2.profile.id);
    });
    return new ProfileRepo(profiles, disabledProfiles, []);
  }
  static createFromPersistable(persistable, ua2) {
    const profiles = persistable.profiles.map((p2) => UnlockedProfile.load(p2, ua2));
    const orgAdminProfiles = persistable.orgAdminProfiles.map((p2) => UnlockedProfile.load(p2, ua2));
    return new ProfileRepo(profiles, persistable.disabledProfiles, orgAdminProfiles);
  }
  getPersistable(ua2) {
    const orgAdminProfiles = this.orgAdminProfiles.map((p2) => p2.getPersistable(ua2));
    return {
      profiles: this.profiles.map((p2) => p2.getPersistable()),
      disabledProfiles: this.disabledProfiles,
      orgAdminProfiles
    };
  }
  withSyncUpdate(suProfiles, unlockedAuthenticator, profileEnabledPredicate) {
    const profiles = [];
    const disabledProfiles = [];
    const orgAdminProfiles = [];
    for (const p2 of suProfiles) {
      if (!KNOWN_USER_PROFILE_TYPES.includes(p2.profileType)) {
        continue;
      }
      if (p2.profileLock) {
        continue;
      }
      if (profileEnabledPredicate(p2)) {
        profiles.push(UnlockedProfile.load(p2, unlockedAuthenticator));
      } else {
        disabledProfiles.push(loadProfile(p2));
      }
    }
    for (const p2 of suProfiles) {
      if (p2.profileType !== ProfileType.ORGANIZATION_ADMIN || !p2.profileLock) {
        continue;
      }
      const lockingProfile = profiles.find((lp2) => {
        var _a2;
        return ((_a2 = p2.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) === lp2.profile.id;
      });
      if (!lockingProfile) {
        continue;
      }
      const up2 = UnlockedProfile.load(p2, unlockedAuthenticator, lockingProfile);
      orgAdminProfiles.push(requireOrgAdminProfile(up2));
    }
    return new ProfileRepo(profiles, disabledProfiles, orgAdminProfiles);
  }
  getUnlocked(profileId) {
    var _a2;
    return (_a2 = this.profiles.find((p2) => p2.profile.id === profileId)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  hasProfile(profileId) {
    return this.profiles.some((p2) => p2.profile.id === profileId);
  }
  hasAtLeastOneLoginsProfile() {
    return this.profiles.some((p2) => LOGIN_PROFILE_TYPES.includes(p2.profile.profileType));
  }
  getPrivateProfile() {
    var _a2;
    return (_a2 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.PRIVATE)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  getInboxProfile() {
    var _a2;
    return (_a2 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.INBOX)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  getPreferencesProfile() {
    var _a2;
    return (_a2 = this.profiles.find((p2) => p2.profile.profileType === ProfileType.PREFERENCES)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  getAllOrganizationProfiles() {
    return this.profiles.filter((p2) => ORGANIZATION_PROFILE_TYPES.includes(p2.profile.profileType));
  }
  getAllProfilesByLockingProfileId(lockingProfileId) {
    return this.orgAdminProfiles.filter((p2) => {
      var _a2;
      return ((_a2 = p2.profile.profileLock) === null || _a2 === void 0 ? void 0 : _a2.lockingProfileId) === lockingProfileId;
    });
  }
  getOrganizationProfile(organizationId) {
    var _a2;
    return (_a2 = this.profiles.find((p2) => ORGANIZATION_PROFILE_TYPES.includes(p2.profile.profileType) && p2.profile.organizationId === organizationId)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  getOrgAdminProfile(organizationId) {
    var _a2;
    return (_a2 = this.orgAdminProfiles.find((p2) => p2.profile.profileType === ProfileType.ORGANIZATION_ADMIN && p2.profile.organizationId === organizationId)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  withOrgAdminProfile(unlockedProfile) {
    const existingProfile = this.getOrgAdminProfile(unlockedProfile.profile.organizationId);
    if ((existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.profile.keyGenerationId) === unlockedProfile.profile.keyGenerationId) {
      return this;
    }
    const otherOrgProfiles = this.orgAdminProfiles.filter((oap) => oap.profile.organizationId !== unlockedProfile.profile.organizationId);
    const adminProfiles = [...otherOrgProfiles, unlockedProfile];
    return new ProfileRepo(this.profiles, this.disabledProfiles, adminProfiles);
  }
  withRetainOrgAdminProfiles(keyGenerationIds) {
    const adminProfiles = this.orgAdminProfiles.filter((op2) => keyGenerationIds.includes(op2.profile.keyGenerationId));
    if (adminProfiles.length === this.orgAdminProfiles.length) {
      return this;
    }
    return new ProfileRepo(this.profiles, this.disabledProfiles, adminProfiles);
  }
  getAllLoginProfileIds() {
    return [
      ...this.profiles.flatMap((p2) => LOGIN_PROFILE_TYPES.includes(p2.profile.profileType) ? p2.profile.id : []),
      ...this.disabledProfiles.flatMap((p2) => LOGIN_PROFILE_TYPES.includes(p2.profileType) ? p2.id : [])
    ];
  }
}
function checkForeignVaultSyncPredicate(info, foreignVaultSyncPredicate) {
  var _a2, _b, _c2;
  const profileIds = info.type === "syncUpdate" ? info.vault.profiles.map((p2) => p2.id) : info.vault.profileIds;
  if (foreignVaultSyncPredicate.profileAllVaults && profileIds.some((pId) => {
    var _a3;
    return (_a3 = foreignVaultSyncPredicate.profileAllVaults) === null || _a3 === void 0 ? void 0 : _a3.includes(pId);
  })) {
    return true;
  }
  if (info.vault.organizationId && ((_a2 = foreignVaultSyncPredicate.organizationAllVaults) === null || _a2 === void 0 ? void 0 : _a2.includes(info.vault.organizationId))) {
    return true;
  }
  const type = info.type === "syncUpdate" ? info.vault.vaultType : info.vault.type;
  if (foreignVaultSyncPredicate.organizationTeamVaults && (type === VaultType.TEAM || type === VaultType.TEAM_META)) {
    return true;
  }
  if (info.vault.organizationId && type === VaultType.ORGANIZATION_PERSONAL) {
    const userIdsToSync = (_b = foreignVaultSyncPredicate.organizationPersonalVaultsForUsers) === null || _b === void 0 ? void 0 : _b[info.vault.organizationId];
    const userIds = info.type === "syncUpdate" ? info.vault.users.map((u2) => u2.id) : info.vault.userIds;
    const shouldSyncViaUser = !!userIdsToSync && userIds.some((uId) => userIdsToSync.includes(uId));
    if (shouldSyncViaUser) {
      return true;
    }
    const profileIdsToSync = (_c2 = foreignVaultSyncPredicate.organizationPersonalVaultsForProfiles) === null || _c2 === void 0 ? void 0 : _c2[info.vault.organizationId];
    const shouldSyncViaProfile = !!profileIdsToSync && profileIds.some((pId) => profileIdsToSync.includes(pId));
    if (shouldSyncViaProfile) {
      return true;
    }
  }
  return false;
}
function exponentialSlottedBackoff(attempt) {
  if (attempt === 0) {
    return Promise.resolve();
  }
  const maxDelaySlot = Math.pow(2, attempt);
  const delaySlot = Math.floor(Math.random() * maxDelaySlot);
  const delayMs = delaySlot * 100;
  return sleep(delayMs);
}
function getSessionUnlockedUntil(sessions, ccp) {
  var _a2, _b;
  return (_b = (_a2 = sessions.find((s2) => s2.id === ccp.loginData.sessionId)) === null || _a2 === void 0 ? void 0 : _a2.unlockedUntil) !== null && _b !== void 0 ? _b : null;
}
const KNOWN_VAULT_MESSAGE_TYPES = [
  VaultMessageType.LOGIN_INBOX_V1,
  VaultMessageType.LINKED_LOGIN_UPDATE_V1,
  VaultMessageType.LINKED_VAULT_DELETED_V1,
  VaultMessageType.SHARE_LINK_OPENED_V1
];
function processVaultMessages(vault, decryptVaultMessage, protect2) {
  if (vault.dirty) {
    return { vault, processedMessageIds: [] };
  }
  const messages2 = vault.messageQueue;
  const remainingMessages = [];
  const processedMessageIds = [];
  let updatedVault = vault;
  for (const m2 of messages2) {
    if (!KNOWN_VAULT_MESSAGE_TYPES.includes(m2.type)) {
      remainingMessages.push(m2);
      continue;
    }
    let decrypted;
    try {
      decrypted = decryptVaultMessage(m2);
    } catch (e2) {
      trackError(new Error(`could not decrypt vault message: ${e2}`));
      processedMessageIds.push(m2.id);
      continue;
    }
    try {
      if (m2.type === VaultMessageType.LOGIN_INBOX_V1) {
        updatedVault = processLoginInboxMessage(updatedVault, protect2, decrypted);
        processedMessageIds.push(m2.id);
      } else if (m2.type === VaultMessageType.LINKED_LOGIN_UPDATE_V1) {
        if (!m2.senderVaultId) {
          trackError(new Error(`dropping message with missing senderVaultId (vault ${vault.id})`));
          processedMessageIds.push(m2.id);
          continue;
        }
        updatedVault = processLinkedLoginUpdateMessage(m2.senderVaultId, updatedVault, protect2, decrypted);
        processedMessageIds.push(m2.id);
      } else if (m2.type === VaultMessageType.LINKED_VAULT_DELETED_V1) {
        if (!m2.senderVaultId) {
          trackError(new Error(`dropping message with missing senderVaultId (vault ${vault.id})`));
          processedMessageIds.push(m2.id);
          continue;
        }
        updatedVault = processLinkedVaultDeletedMessage(m2.senderVaultId, updatedVault);
        processedMessageIds.push(m2.id);
      } else if (m2.type === VaultMessageType.SHARE_LINK_OPENED_V1) {
        updatedVault = processShareLinkOpenedMessage(updatedVault, m2);
        processedMessageIds.push(m2.id);
      } else {
        remainingMessages.push(m2);
      }
    } catch (e2) {
      trackError(new Error(`error processing message for vault ${vault.id}, dropping: ${e2}`));
      processedMessageIds.push(m2.id);
    }
  }
  if (!processedMessageIds.length) {
    return { vault, processedMessageIds };
  }
  if (vault === updatedVault) {
    updatedVault = updatedVault.withModification((c2) => {
      return { newVaultContent: c2, result: void 0 };
    }).vault;
  }
  return {
    vault: updatedVault.withMessageQueue(remainingMessages),
    processedMessageIds
  };
}
function processLoginInboxMessage(vault, protect2, decrypted) {
  if (!decrypted) {
    throw new VaultMessageEncryptedDataNotFoundError();
  }
  if (vault.type !== VaultType.INBOX) {
    trackError(new Error(`found login inbox message V1 in non-inbox vault`));
    return vault;
  }
  const parsedMessage = LoginInboxMessageV1.parse(deserializeData(decrypted));
  const login = {
    uiType: LoginUiType.login,
    username: parsedMessage.username,
    websites: parsedMessage.website ? [parsedMessage.website] : [],
    password: protect2({ contentId: newUuid$1(), unencrypted: parsedMessage.password }),
    sender: parsedMessage.sender,
    creationTime: parsedMessage.creationTime,
    editTime: parsedMessage.creationTime,
    customFields: [],
    title: "",
    note: "",
    pendingInboxConfirmation: true,
    changeTime: parsedMessage.creationTime
  };
  return vault.withModification((c2, t2, { addLoginInternal: addLoginInternal2 }) => {
    return addLoginInternal2(c2, t2, login);
  }).vault;
}
function processLinkedLoginUpdateMessage(senderVaultId, vault, protect2, decrypted) {
  if (!decrypted) {
    throw new VaultMessageEncryptedDataNotFoundError();
  }
  if (vault.type !== VaultType.TEAM && vault.type !== VaultType.ORGANIZATION_PERSONAL) {
    trackError(new Error(`found linked login update message V1 in non-team non-personal vault`));
    return vault;
  }
  const parsedMessage = LinkedLoginUpdateMessageV1.parse(deserializeData(decrypted));
  return vault.withModification((c2, t2, { addOrModifyLoginInternal: addOrModifyLoginInternal2, modifyLoginInternal: modifyLoginInternal2, deleteLoginInternal: deleteLoginInternal2 }) => {
    var _a2;
    for (const update4 of parsedMessage) {
      const existingLogin = c2.logins[update4.loginId];
      if (update4.type === "originUpdated") {
        if (existingLogin && !existingLogin.isDeleted && !existingLogin.linkedFrom) {
          throw new Error("tried to manipulate non-linked login via linked login!");
        }
        const { loginId, content } = update4;
        if (existingLogin && existingLogin.updateTime >= content.updateTime) {
          continue;
        }
        if (content.isDeleted) {
          if (!existingLogin.isDeleted) {
            c2 = deleteLoginInternal2(c2, content.updateTime, loginId).newVaultContent;
          }
        } else {
          const protectedLogin = recursivelyTransformUnprotectedValues(content, protect2);
          c2 = addOrModifyLoginInternal2(c2, content.updateTime, loginId, protectedLogin).newVaultContent;
        }
      } else if (update4.type === "targetDeleted") {
        if (!existingLogin.isDeleted) {
          const linkedTo = (_a2 = existingLogin.linkedTo) === null || _a2 === void 0 ? void 0 : _a2.flatMap((lt) => {
            if (lt.targetVaultId !== senderVaultId) {
              return lt;
            }
            return Object.assign(Object.assign({}, lt), { removeTime: update4.removeTime });
          });
          c2 = modifyLoginInternal2(c2, t2, update4.loginId, { linkedTo }).newVaultContent;
        }
      }
    }
    return { newVaultContent: c2, result: void 0 };
  }).vault;
}
function processLinkedVaultDeletedMessage(senderVaultId, vault) {
  if (vault.type !== VaultType.TEAM && vault.type !== VaultType.ORGANIZATION_PERSONAL) {
    trackError(new Error(`found linked vault deleted message V1 in non-team non-personal vault`));
    return vault;
  }
  return vault.withModification((c2, t2, { modifyLoginInternal: modifyLoginInternal2, deleteLoginInternal: deleteLoginInternal2 }) => {
    var _a2, _b, _c2;
    const linkedLogins = Object.entries(c2.logins).filter((e2) => !e2[1].isDeleted && !!(e2[1].linkedTo || e2[1].linkedFrom));
    for (const [loginId, login] of linkedLogins) {
      if (((_a2 = login.linkedFrom) === null || _a2 === void 0 ? void 0 : _a2.originVaultId) === senderVaultId) {
        c2 = deleteLoginInternal2(c2, t2, loginId).newVaultContent;
      } else if ((_b = login.linkedTo) === null || _b === void 0 ? void 0 : _b.some((lt) => lt.targetVaultId === senderVaultId)) {
        const linkedTo = (_c2 = login.linkedTo) === null || _c2 === void 0 ? void 0 : _c2.flatMap((lt) => {
          if (lt.targetVaultId !== senderVaultId) {
            return lt;
          }
          return Object.assign(Object.assign({}, lt), { removeTime: t2 });
        });
        c2 = modifyLoginInternal2(c2, t2, loginId, { linkedTo }).newVaultContent;
      }
    }
    return { newVaultContent: c2, result: void 0 };
  }).vault;
}
function processShareLinkOpenedMessage(vault, msg) {
  let parsedBackendMessage;
  try {
    if (!msg.backendMessage) {
      throw new Error("got share link opened message without backend message");
    }
    parsedBackendMessage = ShareLinkOpenedBackendMessageV1.parse(JSON.parse(naclUtilExports.encodeUTF8(msg.backendMessage)));
  } catch (e2) {
    trackError(e2);
    return vault;
  }
  const [shareLinkModificationInfo] = Object.entries(vault.getContent().logins).flatMap(([lId, login]) => {
    var _a2;
    if (!((_a2 = login.shareLinks) === null || _a2 === void 0 ? void 0 : _a2.some((sl2) => sl2.id === parsedBackendMessage.shareLinkId))) {
      return [];
    }
    const newShareLinks = login.shareLinks.map((sl2) => {
      if (sl2.id !== parsedBackendMessage.shareLinkId) {
        return sl2;
      }
      if (sl2.openedAt) {
        trackError("got share link opened message for previously opened share link");
      }
      return Object.assign(Object.assign({}, sl2), { openedAt: parsedBackendMessage.openedAt });
    });
    return [{ loginId: lId, login, newShareLinks }];
  });
  if (!shareLinkModificationInfo) {
    return vault;
  }
  return vault.withModification((c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => modifyLoginInternal2(c2, t2, shareLinkModificationInfo.loginId, {
    shareLinks: shareLinkModificationInfo.newShareLinks
  })).vault;
}
var __rest$s = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function regenerateVault(vault, authenticatorsByUser, profilesById, newAuths, newProfiles, oldProtectedSecret, oldVaultMessagePrivateKey) {
  return regenerateVaultForUsers(vault, authenticatorsByUser, profilesById, vault.userIds, vault.profileIds, newAuths, newProfiles, oldProtectedSecret, oldVaultMessagePrivateKey).regeneratedVaultDto;
}
function regenerateVaultForUsers(vault, authenticatorsByUser, profilesById, userIds, profileIds, newAuths, newProfiles, oldProtectedSecret, oldMessagePrivateKey) {
  const newVaultSecret = newSymmetricSecret();
  const newProtectedSecret = newSymmetricSecret();
  const newVaultMessageKeyPair = newEncryptionKeyPair();
  let { vault: updatedVault } = vault.withModification((c2, t2) => {
    return {
      newVaultContent: modifyProtectedValues(c2, t2, (pv) => {
        const unprotected = unprotectWithContentId(oldProtectedSecret, pv);
        const reprotected = protect(newProtectedSecret, unprotected);
        return reprotected;
      }),
      result: void 0
    };
  });
  let processedMessageIds = [];
  let regeneratedMessages = [];
  if (oldMessagePrivateKey) {
    const decryptVaultMessage = (msg) => {
      return msg.encryptedData ? asymDecrypt(oldMessagePrivateKey, loadAsymEncryptedBlob(msg.encryptedData)) : void 0;
    };
    const protectInVault = (uv) => protect(newProtectedSecret, uv);
    const result = processVaultMessages(updatedVault, decryptVaultMessage, protectInVault);
    updatedVault = result.vault;
    processedMessageIds = result.processedMessageIds;
    regeneratedMessages = updatedVault.messageQueue.map((_a2) => {
      var { encryptedData } = _a2, rest = __rest$s(_a2, ["encryptedData"]);
      let newEncryptedData;
      if (encryptedData) {
        const decryptedData = asymDecrypt(oldMessagePrivateKey, loadAsymEncryptedBlob(encryptedData));
        newEncryptedData = asymEncrypt(newVaultMessageKeyPair.encPubKey, decryptedData);
      }
      return Object.assign(Object.assign({}, rest), { encryptedData: newEncryptedData });
    });
    updatedVault = updatedVault.withMessageQueue(regeneratedMessages);
  }
  const squashedVaultState = updatedVault.vaultState.getSquashedState();
  const authenticatorLocks = [];
  for (const userId of userIds) {
    const authenticators = authenticatorsByUser[userId];
    if (!authenticators) {
      throw new UserAuthenticatorsMissingForRegenerateError();
    }
    for (const a2 of authenticators) {
      const lock = VaultAuthenticatorLock.create(a2, newVaultSecret, newProtectedSecret, newVaultMessageKeyPair.encPrivKey);
      authenticatorLocks.push(serializeVaultAuthenticatorLock(lock));
    }
  }
  const profileLocks = [];
  for (const profileId of profileIds) {
    const profile = profilesById[profileId];
    if (!profile) {
      throw new ProfileMissingForRegenerateError();
    }
    const lock = VaultProfileLock.create(profile, newVaultSecret, newProtectedSecret, newVaultMessageKeyPair.encPrivKey);
    profileLocks.push(serializeVaultProfileLock(lock));
  }
  const newAuthenticatorEncryptedStorableVaultKeys = newAuths.map((a2) => asymCreateKek(a2.storableVaultKeyEncPubKey, newVaultSecret));
  const newAuthenticatorEncryptedHighSecurityVaultKeys = newAuths.map((a2) => asymCreateKek(a2.highSecurityVaultKeyEncPubKey, newProtectedSecret));
  const newAuthenticatorEncryptedVaultMessagePrivateKeys = newAuths.map((a2) => asymEncryptEncryptionPrivateKey(a2.highSecurityVaultKeyEncPubKey, newVaultMessageKeyPair.encPrivKey));
  const newProfileLockDtos = newProfiles.map((p2) => ({
    lockingProfileId: nullUuid,
    lockingProfileKeyGenerationId: nullUuid,
    encryptedStorableVaultKey: asymCreateKek(p2.storableVaultKeyEncPubKey, newVaultSecret),
    encryptedHighSecurityVaultKey: asymCreateKek(p2.highSecurityVaultKeyEncPubKey, newProtectedSecret),
    encryptedVaultMessagePrivateKey: newVaultMessageKeyPair !== null ? asymEncryptEncryptionPrivateKey(p2.highSecurityVaultKeyEncPubKey, newVaultMessageKeyPair.encPrivKey) : null
  }));
  const { blob } = Commit.create(null, newVaultSecret, squashedVaultState);
  return {
    regeneratedVaultDto: {
      id: updatedVault.id,
      latestCommitId: updatedVault.commitId,
      locks: authenticatorLocks,
      profileLocks,
      blob,
      newAuthenticatorEncryptedStorableVaultKeys,
      newAuthenticatorEncryptedHighSecurityVaultKeys,
      newAuthenticatorEncryptedVaultMessagePrivateKeys,
      messagePublicKey: newVaultMessageKeyPair === null || newVaultMessageKeyPair === void 0 ? void 0 : newVaultMessageKeyPair.encPubKey,
      deleteMessageIds: processedMessageIds,
      regeneratedMessages
    },
    newProfileLockDtos
  };
}
var __awaiter$K = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalGetUsers(backendClient, [...userIds], [...profileIds], userEmails, organizationId) {
  return __awaiter$K(this, void 0, void 0, function* () {
    const emailsByUserId = {};
    if (userEmails.length) {
      const resolvedEmails = yield backendClient.account.resolveEmails(userEmails, true);
      for (const re2 of resolvedEmails) {
        if (re2.emailInvalid) {
          debugConsole.error("unexpected invalid email", re2.email);
          continue;
        }
        if (!userEmails.includes(re2.email)) {
          debugConsole.error("unexpected extra email", re2.email);
          continue;
        }
        const orgProfile = re2.profiles.find((p2) => p2.profileType === ProfileType.ORGANIZATION && p2.organizationId === organizationId);
        if (orgProfile) {
          profileIds.push(orgProfile.profileId);
          continue;
        }
        const privateProfile = re2.profiles.find((p2) => p2.profileType === ProfileType.PRIVATE);
        if (privateProfile) {
          profileIds.push(privateProfile.profileId);
          continue;
        }
        if (re2.userId) {
          userIds.push(re2.userId);
          emailsByUserId[re2.userId] = re2.email;
          continue;
        }
      }
    }
    const index2 = [];
    const authenticatorsByUser = {};
    if (userIds.length) {
      const knownUserIds = [...userIds].map((id2) => ({ id: id2 }));
      const { users } = yield backendClient.account.list(knownUserIds, [], []);
      for (const { id: id2, authenticators, isProfilesEnabled } of users) {
        authenticatorsByUser[id2] = authenticators.map((a2) => loadForeignAuthenticator(a2));
        index2.push({ email: emailsByUserId[id2], userId: id2, isProfilesEnabled });
      }
    }
    const profilesById = {};
    if (profileIds.length) {
      const profiles = yield backendClient.profile.list(profileIds);
      for (const profile of profiles) {
        profilesById[profile.id] = loadForeignProfile(profile);
        index2.push({ email: profile.email, profileId: profile.id, isProfilesEnabled: true });
      }
    }
    return { authenticatorsByUser, profilesById, index: index2 };
  });
}
var __awaiter$J = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalGetUsersForVaults({ backendClient, accountState, profileRepo }, vaults) {
  return __awaiter$J(this, void 0, void 0, function* () {
    const allUserIds = /* @__PURE__ */ new Set([
      ...vaults.map((v2) => v2.userIds).reduce((acc, val) => acc.concat(val), [])
    ]);
    const allProfileIds = new Set(vaults.map((v2) => v2.profileIds).reduce((acc, val) => acc.concat(val), []));
    allUserIds.delete(accountState.userId);
    profileRepo.profiles.forEach((p2) => allProfileIds.delete(p2.profile.id));
    const { authenticatorsByUser, profilesById, index: index2 } = yield onlineInternalGetUsers(backendClient, [...allUserIds], [...allProfileIds], []);
    profileRepo.profiles.forEach((p2) => profilesById[p2.profile.id] = p2.profile);
    return { authenticatorsByUser, profilesById, index: index2 };
  });
}
var __awaiter$I = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess, hsc) {
  return __awaiter$I(this, void 0, void 0, function* () {
    const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(vaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo, hsc);
    const { authenticatorsByUser, profilesById } = yield onlineInternalGetUsersForVaults(ccs, [
      vault
    ]);
    return regenerateVault(vault, authenticatorsByUser, profilesById, [], [], protectedSecret, messagePrivateKey);
  });
}
var __awaiter$H = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$r = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var __asyncValues$1 = globalThis && globalThis.__asyncValues || function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
};
function onlineInternalSync(_a2, syncUpdateArg, fcmMessageId, hsc) {
  var ccs = __rest$r(_a2, []);
  if (syncUpdateArg === void 0) {
    syncUpdateArg = null;
  }
  if (hsc === void 0) {
    hsc = null;
  }
  return __awaiter$H(this, void 0, void 0, function* () {
    const result = yield onlineInternalSyncReturningHighSecurityCache(ccs, syncUpdateArg, fcmMessageId, hsc);
    return result.ccs;
  });
}
function onlineInternalSyncReturningHighSecurityCache(_a2, syncUpdateArg, fcmMessageId, hsc) {
  var ccs = __rest$r(_a2, []);
  if (syncUpdateArg === void 0) {
    syncUpdateArg = null;
  }
  if (hsc === void 0) {
    hsc = null;
  }
  return __awaiter$H(this, void 0, void 0, function* () {
    let su2 = syncUpdateArg;
    if (!su2 || su2.syncVersion && ccs.syncVersion && su2.syncVersion < ccs.syncVersion) {
      su2 = yield ccs.backendClient.sync.poll(fcmMessageId);
    }
    let shouldUpdateSyncVersion = true;
    ccs.lastKnownServerTime = su2.serverTime;
    ccs.clientOutdated = su2.clientOutdated;
    ccs.clientServerTimeOffsetMs = Date.now() - su2.serverTime.getTime();
    ccs.tokenRefreshNeeded = su2.tokenRefreshNeeded;
    ccs.accountState = ccs.accountState.withSyncUpdate(su2);
    ccs = yield onlineInternalSyncAuthenticatorChain(ccs, su2);
    ccs = onlineInternalSyncProfileRepo(ccs, su2);
    if (!hsc) {
      ({ ccs, hsc } = yield onlineInternalSyncSessionUnlock(ccs, su2));
    }
    try {
      ({ ccs, shouldUpdateSyncVersion } = yield onlineInternalSyncVaultRepo(ccs, su2, hsc));
    } catch (e2) {
      shouldUpdateSyncVersion = false;
      trackError(e2);
    }
    try {
      ccs = yield onlineInternalSyncAchievements(ccs, su2);
    } catch (e2) {
      trackError(e2);
    }
    try {
      ccs = yield onlineInternalSyncAuditlogEventQueue(ccs);
    } catch (e2) {
      trackError(e2);
    }
    if (su2.maintenanceSettings) {
      ccs.maintenanceSettings = su2.maintenanceSettings;
    }
    if (shouldUpdateSyncVersion) {
      ccs.syncVersion = su2.syncVersion;
      ccs.backendClient = ccs.backendClient.withSyncVersion(su2.syncVersion);
    }
    return { ccs, hsc: hsc !== null && hsc !== void 0 ? hsc : void 0 };
  });
}
function onlineInternalSyncProfileRepo(_a2, su2) {
  var ccs = __rest$r(_a2, []);
  if (su2.profiles) {
    const sessionId = ccs.backendClient.getSessionId();
    const session = ccs.accountState.sessions.find((s2) => s2.id === sessionId);
    const profileEnabledPredicate = (p2) => {
      var _a3;
      return isProfileEnabled(session, p2, (_a3 = ccs.ephemeralOperationState) === null || _a3 === void 0 ? void 0 : _a3.additionalEnabledProfileIds);
    };
    ccs.profileRepo = ccs.profileRepo.withSyncUpdate(su2.profiles, ccs.params.unlockedAuthenticator, profileEnabledPredicate);
    const availableProfileIds = ccs.profileRepo.profiles.map((p2) => p2.profile.id);
    ccs.vaultRepo = ccs.vaultRepo.withDeleteWithoutMatchingProfileLocks(availableProfileIds);
  }
  return ccs;
}
function isProfileEnabled(session, profile, ephemeralEnabledProfileIds) {
  if (!LOGIN_PROFILE_TYPES.includes(profile.profileType)) {
    return true;
  }
  if (!session) {
    return true;
  }
  if (session.enabledProfileIds.length === 0) {
    return true;
  }
  return session.enabledProfileIds.includes(profile.id) || !!(ephemeralEnabledProfileIds === null || ephemeralEnabledProfileIds === void 0 ? void 0 : ephemeralEnabledProfileIds.includes(profile.id));
}
function onlineInternalSyncAuthenticatorChain(_a2, su2) {
  var _b;
  var ccs = __rest$r(_a2, []);
  return __awaiter$H(this, void 0, void 0, function* () {
    if (su2.user) {
      if (su2.user.authenticatorBlockHash) {
        if (!ccs.accountState.authenticatorBlockHash || !hashEqual(loadHash(su2.user.authenticatorBlockHash), ccs.accountState.authenticatorBlockHash)) {
          const authListDto = yield ccs.backendClient.authenticator.list((_b = ccs.accountState.authenticatorBlockHash) !== null && _b !== void 0 ? _b : void 0);
          ccs.accountState = ccs.accountState.withAuthenticatorList(authListDto);
        }
      } else if (ccs.accountState.authenticatorBlockHash) {
        trackError(new Error("missing authenticator block hash"));
      } else {
        const authListDto = yield ccs.backendClient.authenticator.list();
        ccs.accountState = ccs.accountState.withAuthenticatorList(authListDto);
      }
    }
    return ccs;
  });
}
function onlineInternalSyncSessionUnlock(_a2, su2) {
  var _b, _c2;
  var ccs = __rest$r(_a2, []);
  return __awaiter$H(this, void 0, void 0, function* () {
    const { sessionUnlock } = su2;
    const ownSession = ccs.accountState.sessions.find((s2) => uuidEqual(s2.id, ccs.params.loginData.sessionId));
    if (ccs.ignoredUnlock && ownSession && ((_b = ownSession.unlockedAt) === null || _b === void 0 ? void 0 : _b.getTime()) === ((_c2 = ccs.ignoredUnlock) === null || _c2 === void 0 ? void 0 : _c2.getTime())) {
      ccs.protectedSecretRepo = null;
      return { ccs, hsc: null };
    }
    let hsc;
    const unlockedUntil = getSessionUnlockedUntil(ccs.accountState.sessions, ccs.params);
    if (ccs.pinnedAuthenticatorSecret) {
      const pinnedSecret = ccs.pinnedAuthenticatorSecret;
      const authenticator = ccs.accountState.authenticators.find((a2) => pinnedSecret.authenticatorId === a2.id);
      if (authenticator === void 0) {
        throw new UnlockedAuthenticatorNotFoundError();
      }
      hsc = HighSecurityCache.fromSecret(pinnedSecret, authenticator);
      if (!ccs.protectedSecretRepo) {
        ccs.protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, null);
      }
    } else if (sessionUnlock) {
      hsc = HighSecurityCache.fromSessionUnlock(sessionUnlock, ccs.params.sessionKeys.encPrivKey, ccs.accountState.authenticators);
      if (!ccs.protectedSecretRepo) {
        ccs.protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, unlockedUntil);
      } else if (unlockedUntil) {
        ccs.protectedSecretRepo = ccs.protectedSecretRepo.withUnlockedUntil(unlockedUntil);
      }
    } else {
      hsc = null;
      ccs.protectedSecretRepo = null;
    }
    ccs = refreshOrgAdminCaches(ccs, hsc);
    return { ccs, hsc };
  });
}
function refreshOrgAdminCaches(_a2, hsc) {
  var ccs = __rest$r(_a2, []);
  if (!ccs.backendClient.config.syncSuperUsers || !hsc || !ccs.protectedSecretRepo) {
    return ccs;
  }
  for (const org of ccs.accountState.organizations) {
    if (!org.adminInfo) {
      continue;
    }
    const orgVaultAccess = getOrgAdminVaultAccess(ccs.protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, hsc, org);
    if (!orgVaultAccess) {
      continue;
    }
    const secrets = {};
    for (const vault of ccs.vaultRepo.getForeignVaultsByOrganizationId(orgVaultAccess.orgId)) {
      if (ccs.protectedSecretRepo.hasVault(vault.id)) {
        continue;
      }
      try {
        const { protectedSecret, messagePrivateKey } = unlockLockProtectedSecret(orgVaultAccess, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, ccs.profileRepo, hsc);
        secrets[vault.id] = {
          generationId: vault.generationId,
          protectedSecret,
          messagePrivateKey
        };
      } catch (e2) {
        trackError(new Error(`Dropping vault ${vault.id} due to failed unlockLockProtectedSecret: ${e2}`));
        ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
      }
      ccs.protectedSecretRepo = ccs.protectedSecretRepo.withOrganization(org.id, secrets);
    }
  }
  return ccs;
}
function onlineInternalSyncVaultRepo(ccs, su2, hsc) {
  var _a2, e_1, _b, _c2;
  var _d, _e, _f, _g;
  return __awaiter$H(this, void 0, void 0, function* () {
    let { vaults: suVaultList } = su2;
    let shouldUpdateSyncVersion = true;
    const syncPromises = [];
    if (suVaultList === void 0) {
      for (const vault of ccs.vaultRepo.getAllVaults()) {
        if (shouldSyncVault(vault.type)) {
          syncPromises.push(onlineInternalSyncVault(ccs, vault, null, hsc, su2.serverTime));
        }
      }
    } else {
      suVaultList = suVaultList.filter((suv) => shouldUseSyncUpdateVault(ccs, suv));
      for (const vault of ccs.vaultRepo.getLegacyOrganizationAdminVaults()) {
        if (suVaultList.some((suv) => suv.id === vault.id)) {
          continue;
        }
        ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
        ccs.protectedSecretRepo = (_e = (_d = ccs.protectedSecretRepo) === null || _d === void 0 ? void 0 : _d.withDeleteProtectedSecret(vault.id)) !== null && _e !== void 0 ? _e : null;
      }
      const adminVaultSyncs = suVaultList.filter((v2) => v2.vaultType === VaultType.LEGACY_ORGANIZATION_ADMIN).map((v2) => {
        const localVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(v2.id);
        if (localVault) {
          return onlineInternalSyncVault(ccs, localVault, v2, hsc, su2.serverTime);
        } else {
          return onlineInternalInitializeVault(ccs, v2, hsc);
        }
      });
      try {
        for (var _h2 = true, adminVaultSyncs_1 = __asyncValues$1(adminVaultSyncs), adminVaultSyncs_1_1; adminVaultSyncs_1_1 = yield adminVaultSyncs_1.next(), _a2 = adminVaultSyncs_1_1.done, !_a2; _h2 = true) {
          _c2 = adminVaultSyncs_1_1.value;
          _h2 = false;
          const vaultSyncResult = _c2;
          if (vaultSyncResult.vault) {
            ccs = applyVaultSyncResult(ccs, vaultSyncResult);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_h2 && !_a2 && (_b = adminVaultSyncs_1.return))
            yield _b.call(adminVaultSyncs_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      ccs = refreshOrgAdminCaches(ccs, hsc);
      const localVaultIds = new Set(ccs.vaultRepo.getAllVaults().map((v2) => v2.id));
      for (const vault of ccs.vaultRepo.getAllVaults()) {
        if (vault.type === VaultType.LEGACY_ORGANIZATION_ADMIN) {
          continue;
        }
        const syncUpdateVault = suVaultList.find((suv) => suv.id === vault.id);
        if (!syncUpdateVault) {
          ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
          ccs.protectedSecretRepo = (_g = (_f = ccs.protectedSecretRepo) === null || _f === void 0 ? void 0 : _f.withDeleteProtectedSecret(vault.id)) !== null && _g !== void 0 ? _g : null;
        } else {
          syncPromises.push(onlineInternalSyncVault(ccs, vault, syncUpdateVault, hsc, su2.serverTime));
        }
      }
      const newVaults = suVaultList.filter((v2) => !localVaultIds.has(v2.id));
      for (const syncUpdateVault of newVaults) {
        syncPromises.push(onlineInternalInitializeVault(ccs, syncUpdateVault, hsc));
      }
    }
    const syncPromiseResults = yield Promise.allSettled(syncPromises);
    for (const syncPromiseResult of syncPromiseResults) {
      if (syncPromiseResult.status === "fulfilled") {
        ccs = applyVaultSyncResult(ccs, syncPromiseResult.value);
      } else {
        shouldUpdateSyncVersion = false;
        if (syncPromiseResult.reason instanceof DomainError && syncPromiseResult.reason.code === ClientCoreErrorCode.VaultIsLocked)
          ;
        else {
          trackError(syncPromiseResult.reason);
        }
      }
    }
    for (const syncPromiseResult of syncPromiseResults) {
      if (syncPromiseResult.status === "fulfilled") {
        ccs = applyVaultSyncResultVaultMessages(ccs, syncPromiseResult.value);
      }
    }
    ccs = ensureVaultRepoConsistency(ccs);
    const adminOrgIds = ccs.accountState.organizations.filter((o2) => !!o2.adminInfo).map((o2) => o2.id);
    for (const orgId of Object.keys(ccs.superUserUnlockedAuthenticators)) {
      const isAdmin = adminOrgIds.some((id2) => id2 === orgId);
      if (!isAdmin) {
        const newSuperUserUnlockedAuthenticators = Object.assign({}, ccs.superUserUnlockedAuthenticators);
        delete newSuperUserUnlockedAuthenticators[orgId];
        ccs.superUserUnlockedAuthenticators = newSuperUserUnlockedAuthenticators;
      }
    }
    return { ccs, shouldUpdateSyncVersion };
  });
}
function shouldUseSyncUpdateVault({ profileRepo, foreignVaultSyncPredicate, ephemeralForeignVaultSyncPredicate }, suv) {
  if (!shouldSyncVault(suv.vaultType)) {
    return false;
  }
  const isOwnVault = suv.profiles.some(({ id: id2 }) => profileRepo.hasProfile(id2));
  const isAdminVault = suv.vaultType === VaultType.ORGANIZATION_ADMIN;
  const isForeignOrgVault = suv.organizationId && profileRepo.getOrganizationProfile(suv.organizationId);
  return isOwnVault || isAdminVault || isForeignOrgVault && (checkForeignVaultSyncPredicate({ type: "syncUpdate", vault: suv }, foreignVaultSyncPredicate) || checkForeignVaultSyncPredicate({ type: "syncUpdate", vault: suv }, ephemeralForeignVaultSyncPredicate));
}
function shouldSyncVault(vaultType) {
  if (vaultType === VaultType.UNKNOWN) {
    return false;
  }
  return true;
}
function applyVaultSyncResult(_a2, _b) {
  var _c2, _d;
  var ccs = __rest$r(_a2, []);
  var vault = _b.vault, newSecrets = _b.newSecrets, vaultAccess = _b.vaultAccess;
  if (vault) {
    ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
    if (newSecrets) {
      ccs.protectedSecretRepo = (_d = (_c2 = ccs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.withProtectedSecret(vault, newSecrets.protectedSecret, newSecrets.messagePrivateKey)) !== null && _d !== void 0 ? _d : null;
    }
    if ((vaultAccess === null || vaultAccess === void 0 ? void 0 : vaultAccess.type) === "admin-authenticator") {
      ccs.superUserUnlockedAuthenticators = Object.assign(Object.assign({}, ccs.superUserUnlockedAuthenticators), { [vaultAccess.orgId]: vaultAccess.unlockedAuthenticator });
    }
  }
  return ccs;
}
function applyVaultSyncResultVaultMessages(_a2, _b) {
  var ccs = __rest$r(_a2, []);
  var synthesizedVaultMessages = _b.synthesizedVaultMessages;
  if (synthesizedVaultMessages) {
    for (const { vaultId, message } of synthesizedVaultMessages) {
      if (ccs.vaultRepo.vaultExits(vaultId)) {
        let v2 = ccs.vaultRepo.getVaultById(vaultId);
        v2 = v2.withAddMessageQueue(message);
        ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(v2);
      }
    }
  }
  return ccs;
}
function onlineInternalSyncVault(ccs, initialVault, syncUpdate, hsc, syncUpdateServerTime) {
  var _a2, _b;
  return __awaiter$H(this, void 0, void 0, function* () {
    let vault = initialVault;
    let shouldPerformUpdate = false;
    let forceRegenerate = false;
    if (syncUpdate) {
      vault = vault.withSyncUpdate(syncUpdate, ccs.profileRepo);
      shouldPerformUpdate = vault.commitId !== syncUpdate.commitId || syncUpdate.hasMessagesQueued;
      if (!shouldPerformUpdate && vault.isUserJoined) {
        const hasProfileWithoutLock = !vault.profileLock && vault.profileIds.some((id2) => ccs.profileRepo.hasProfile(id2));
        if (hasProfileWithoutLock) {
          shouldPerformUpdate = true;
        }
      }
      if (!shouldPerformUpdate && !vault.isUserJoined && vault.organizationId) {
        const orgAdminProfile = ccs.profileRepo.getOrgAdminProfile(vault.organizationId);
        const hasAdminProfileWithoutLock = orgAdminProfile && !vault.adminProfileLock && vault.profileIds.includes(orgAdminProfile.profile.id);
        if (hasAdminProfileWithoutLock) {
          shouldPerformUpdate = true;
        }
      }
      if ((vault.type === VaultType.ORGANIZATION_PERSONAL || vault.type === VaultType.PRIVATE) && vault.isUserJoined && vault.messagePublicKey === null) {
        forceRegenerate = true;
      }
      if (vault.isUserJoined && vault.messagePublicKey === null && vault.linkedUpdateMessages.length > 0) {
        forceRegenerate = true;
      }
      if (vault.messagePublicKey === null && vault.hasStagedDiff()) {
        forceRegenerate = true;
      }
    }
    const vaultBackendClient = getBackendClientForVault(ccs, vault);
    const vaultAccess = getVaultAccess(ccs, hsc, vault);
    if (!vaultAccess) {
      return {};
    }
    let newSecrets;
    let synthesizedVaultMessages;
    try {
      let forceFullReload = false;
      for (let attempt = 0; ; attempt += 1) {
        yield exponentialSlottedBackoff(attempt);
        let cappedUpdateTime = syncUpdateServerTime;
        try {
          if (shouldPerformUpdate) {
            const hasAuthenticatorLock = vaultAccess.type === "admin-authenticator" && vault.authenticatorLocks.some((l2) => l2.authenticatorId === vaultAccess.unlockedAuthenticator.authenticator.id);
            const hasProfile = vault.profileIds.some((id2) => ccs.profileRepo.hasProfile(id2));
            const isLockRequired = !vault.profileLock && !vault.adminProfileLock && (!hasAuthenticatorLock || hasProfile);
            const vaultUpdate = forceFullReload ? yield vaultBackendClient.vault.listCommits(vault.id, null, null, false) : yield vaultBackendClient.vault.listCommits(vault.id, vault.commitId, vault.firstCommitId, isLockRequired);
            cappedUpdateTime = vaultUpdate.serverTime;
            const updatedVault2 = internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate, vaultAccess);
            vault = updatedVault2.vault;
            newSecrets = (_a2 = updatedVault2.newSecrets) !== null && _a2 !== void 0 ? _a2 : newSecrets;
          }
          const updatedVault = yield onlineInternalPushOrRegenerateVaultIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate);
          vault = updatedVault.vault;
          newSecrets = (_b = updatedVault.newSecrets) !== null && _b !== void 0 ? _b : newSecrets;
          synthesizedVaultMessages = updatedVault.synthesizedVaultMessages;
          forceRegenerate = false;
          break;
        } catch (e2) {
          if (e2 instanceof DomainError && e2.code === BackendErrorCode.VAULT_OUT_OF_SYNC) {
            shouldPerformUpdate = true;
          } else if (e2 instanceof DomainError && e2.code === BackendErrorCode.INVALID_UPDATE_TIME) {
            shouldPerformUpdate = true;
            trackError(new Error(`Invalid update time, retrying sync #${attempt} for vault ${vault.id}`));
          } else if (e2 instanceof DomainError && e2.code === BackendErrorCode.VAULT_DIRTY) {
            vault = vault.withDirty();
          } else if (e2 instanceof DomainError && (e2.code === ClientCoreErrorCode.NeedLocks || e2.code === ClientCoreErrorCode.NeedFullHistory)) {
            if (!forceFullReload) {
              shouldPerformUpdate = true;
              forceFullReload = true;
              trackError(e2);
            } else {
              throw e2;
            }
          } else {
            throw e2;
          }
        }
        if (attempt === 4) {
          trackError(new Error(`Bailing out of syncVault for vault ${vault.id} due to excessive retries`));
          break;
        }
      }
      const vaultChanged = vault !== initialVault;
      if (!vaultChanged) {
        return {};
      }
      return { vault, newSecrets, synthesizedVaultMessages, vaultAccess };
    } catch (e2) {
      throw e2;
    }
  });
}
function onlineInternalPushOrRegenerateVaultIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate) {
  return __awaiter$H(this, void 0, void 0, function* () {
    if (vault.dirty || forceRegenerate) {
      return onlineInternalCreateRegeneratedVaultDuringSyncIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate);
    }
    return onlineInternalSyncPushCommitIfNecessary(vaultBackendClient, vault, cappedUpdateTime);
  });
}
function onlineInternalSyncPushCommitIfNecessary(vaultBackendClient, vault, serverTime) {
  var _a2, _b;
  return __awaiter$H(this, void 0, void 0, function* () {
    const stagedData = vault.getStagedDiff(serverTime);
    if (!stagedData) {
      return { vault };
    }
    const { stagingVault, diff, latestUpdateTime, linkedUpdateMessages, shareLinkUpdates } = stagedData;
    const protoCommit = Commit.create(null, vault.vaultSecret, diff);
    const messages2 = linkedUpdateMessages.length ? yield prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) : [];
    const activeShareLinkIds = (_b = (_a2 = vault.vaultState.descriptor).getActiveShareLinkIds) === null || _b === void 0 ? void 0 : _b.call(_a2, vault.getContentInternal());
    const { commitId, updateMessageIds } = yield vaultBackendClient.vault.createCommit(vault.id, vault.commitId, protoCommit.blob, new Date(latestUpdateTime), [], messages2, shareLinkUpdates, { keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : [] });
    const synthesizedVaultMessages = messages2.map((m2) => ({
      vaultId: m2.vaultId,
      message: {
        id: updateMessageIds.shift(),
        type: m2.type,
        encryptedData: m2.encryptedData,
        senderVaultId: vault.id
      }
    }));
    return {
      vault: stagingVault.withCommitId(commitId),
      synthesizedVaultMessages
    };
  });
}
function onlineInternalCreateRegeneratedVaultDuringSyncIfNecessary(ccs, vaultBackendClient, hsc, vault, vaultAccess, cappedUpdateTime, forceRegenerate) {
  var _a2, _b;
  return __awaiter$H(this, void 0, void 0, function* () {
    const stagedData = vault.getStagedDiff(cappedUpdateTime);
    if (!stagedData && !forceRegenerate) {
      return { vault };
    }
    if (!hsc) {
      throw new VaultIsLockedError();
    }
    const regeneratedVaultDto = yield onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess, hsc);
    const activeShareLinkIds = (_b = (_a2 = vault.vaultState.descriptor).getActiveShareLinkIds) === null || _b === void 0 ? void 0 : _b.call(_a2, vault.getContentInternal());
    if (!stagedData) {
      yield vaultBackendClient.vault.createGeneration(regeneratedVaultDto, [], {
        keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : []
      });
      const vaultUpdate2 = yield vaultBackendClient.vault.listCommits(vault.id, null, null, false);
      return internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate2, vaultAccess);
    }
    const { stagingVault, linkedUpdateMessages, shareLinkUpdates } = stagedData;
    const messages2 = linkedUpdateMessages.length ? yield prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) : [];
    const { updateMessageIds } = yield vaultBackendClient.vault.createGeneration(regeneratedVaultDto, messages2, { keepShareLinkIds: activeShareLinkIds !== null && activeShareLinkIds !== void 0 ? activeShareLinkIds : [] }, shareLinkUpdates);
    const synthesizedVaultMessages = messages2.map((m2) => ({
      vaultId: m2.vaultId,
      message: {
        id: updateMessageIds.shift(),
        type: m2.type,
        encryptedData: m2.encryptedData,
        senderVaultId: vault.id
      }
    }));
    const vaultUpdate = yield vaultBackendClient.vault.listCommits(vault.id, null, null, false);
    let updatedVault = internalUpdateVaultFromDto(ccs, hsc, stagingVault, vaultUpdate, vaultAccess);
    updatedVault = Object.assign(Object.assign({}, updatedVault), { vault: updatedVault.vault.withDirty(false) });
    return Object.assign(Object.assign({}, updatedVault), { synthesizedVaultMessages });
  });
}
function prepareVaultMessages(vaultBackendClient, vault, linkedUpdateMessages) {
  return __awaiter$H(this, void 0, void 0, function* () {
    if (linkedUpdateMessages.length === 0) {
      return [];
    }
    if (!vault.organizationId) {
      throw new Error("vault with linked logins must be in organization");
    }
    const vaultIds = new Set(linkedUpdateMessages.map(({ vaultId }) => vaultId));
    const { messagePublicKeys } = yield vaultBackendClient.vault.listMessagePublicKeys(vault.organizationId, [...vaultIds]);
    const mpksByVault = {};
    for (const { vaultId, generationId, key } of messagePublicKeys) {
      if (key.length > 0) {
        mpksByVault[vaultId] = {
          generationId,
          messagePublicKey: loadEncryptionPublicKey(key)
        };
      }
    }
    return linkedUpdateMessages.flatMap(({ vaultId, message, type }) => {
      if (!mpksByVault[vaultId]) {
        trackError(new Error("linked vault is missing public key, no longer exists? (skipping)"));
        return [];
      }
      const { generationId, messagePublicKey } = mpksByVault[vaultId];
      return {
        vaultId,
        generationId,
        encryptedData: asymEncrypt(messagePublicKey, serializeData(message)),
        type
      };
    });
  });
}
function internalUpdateVaultFromDto(ccs, hsc, vault, vaultUpdate, vaultAccess) {
  var _a2, _b;
  const { generationId, commitDtos, lockDtos, profileLockDto, adminProfileLockDto, firstCommitId, messages: messages2 } = vaultUpdate;
  const commits = commitDtos.map((c2) => Commit.load(c2));
  const isSameGeneration = generationId === vault.generationId;
  const isReceivedFullHistory = commits.length && commits[0].id === firstCommitId;
  const isLocalCommitsMissing = isSameGeneration && isReceivedFullHistory && !commits.some(({ id: id2 }) => id2 === vault.commitId);
  if (isLocalCommitsMissing) {
    trackError(new Error(`One or more commits (latest local: ${vault.commitId}) were lost serverside in vault ${vault.id}`));
    const stagedDiff2 = vault.vaultState.getSquashedState();
    const updatedVault2 = Vault.createFromCommits(vault.id, vault.type, vault.associatedVaultId, generationId, vault.userIds, vault.profileIds, vault.organizationId, vault.authenticatorLocks, vault.profileLock, vault.adminProfileLock, vault.dirty, vault.vaultSecret, commits, stagedDiff2, ccs.profileRepo, vault.messagePublicKey, messages2, vault.inboxSlug);
    return { vault: updatedVault2 };
  }
  if (isSameGeneration) {
    let newCommits;
    if (isReceivedFullHistory) {
      const lastKnownCommitIndex = commits.findIndex(({ id: id2 }) => id2 === vault.commitId);
      newCommits = commits.slice(lastKnownCommitIndex + 1);
      trackError(new Error(`Unexpectedly received full history for vault ${vault.id} (${lastKnownCommitIndex + 1} old commits)`));
    } else {
      newCommits = commits;
    }
    let updatedVault2 = vault.withLoadCommits(...newCommits).withMessageQueue(messages2);
    if (vault.firstCommitId === null) {
      updatedVault2 = updatedVault2.withFirstCommitId(firstCommitId);
    }
    let newSecrets2;
    if (lockDtos.length || profileLockDto || adminProfileLockDto) {
      const authenticatorLocks2 = (_a2 = lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.map((dto) => VaultAuthenticatorLock.load(dto))) !== null && _a2 !== void 0 ? _a2 : [];
      const profileLock2 = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
      const adminProfileLock2 = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
      updatedVault2 = updatedVault2.withLocks(vaultAccess, authenticatorLocks2, profileLock2, adminProfileLock2);
    }
    if (hsc && (lockDtos.length || profileLockDto || adminProfileLockDto)) {
      newSecrets2 = unlockLockProtectedSecret(vaultAccess, updatedVault2.authenticatorLocks, updatedVault2.profileLock, updatedVault2.adminProfileLock, ccs.profileRepo, hsc);
    }
    return { vault: updatedVault2, newSecrets: newSecrets2 };
  }
  if (!isReceivedFullHistory) {
    throw new NeedFullHistoryError(vault.id, vault.generationId, generationId);
  }
  if (!(lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.length) && !profileLockDto && !adminProfileLockDto) {
    throw new NeedLocksError(vault.id, vault.generationId, generationId);
  }
  const authenticatorLocks = lockDtos.map((dto) => VaultAuthenticatorLock.load(dto));
  const profileLock = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
  const adminProfileLock = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
  const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
  const newSecrets = hsc ? unlockLockProtectedSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock, ccs.profileRepo, hsc) : void 0;
  const stagedDiff = getStagedDiff(vault, vaultAccess, hsc, ccs.profileRepo, (_b = newSecrets === null || newSecrets === void 0 ? void 0 : newSecrets.protectedSecret) !== null && _b !== void 0 ? _b : null);
  const updatedVault = Vault.createFromCommits(vault.id, vault.type, vault.associatedVaultId, generationId, vault.userIds, vault.profileIds, vault.organizationId, authenticatorLocks, profileLock, adminProfileLock, vault.dirty, vaultSecret, commits, stagedDiff, ccs.profileRepo, vault.messagePublicKey, messages2, vault.inboxSlug);
  return { vault: updatedVault, newSecrets };
}
function getStagedDiff(currentVault, vaultAccess, hsc, profileRepo, newProtectedSecret) {
  var _a2, _b, _c2;
  const stagedDiff = (_a2 = currentVault.getStagedDiff(null)) === null || _a2 === void 0 ? void 0 : _a2.diff;
  if (!stagedDiff) {
    return null;
  }
  if (!hsc || !newProtectedSecret) {
    throw new VaultIsLockedError();
  }
  const { protectedSecret: currentProtectedSecret } = unlockLockProtectedSecret(vaultAccess, currentVault.authenticatorLocks, currentVault.profileLock, currentVault.adminProfileLock, profileRepo, hsc);
  const { vault: reprotectedVault } = currentVault.withModification((c2, t2) => {
    return {
      newVaultContent: modifyProtectedValues(c2, t2, (pv) => {
        const unprotected = unprotectWithContentId(currentProtectedSecret, pv);
        const reprotected = protect(newProtectedSecret, unprotected);
        return reprotected;
      }),
      result: void 0
    };
  });
  return (_c2 = (_b = reprotectedVault.getStagedDiff(null)) === null || _b === void 0 ? void 0 : _b.diff) !== null && _c2 !== void 0 ? _c2 : null;
}
function onlineInternalInitializeVault(ccs, syncUpdateVault, hsc) {
  var _a2;
  return __awaiter$H(this, void 0, void 0, function* () {
    const backendClient = getBackendClientForVault(ccs, syncUpdateVault);
    const vaultAccess = getVaultAccess(ccs, hsc, syncUpdateVault);
    if (!vaultAccess) {
      return {};
    }
    const { id: vaultId, vaultType, associatedVaultId, users, profiles, organizationId, dirty, messagePublicKey, inboxSlug } = syncUpdateVault;
    const { generationId, commitDtos, lockDtos, profileLockDto, adminProfileLockDto, messages: messages2 } = yield backendClient.vault.listCommits(vaultId, null, null, false);
    const commits = commitDtos.map((c2) => Commit.load(c2));
    const authenticatorLocks = (_a2 = lockDtos === null || lockDtos === void 0 ? void 0 : lockDtos.map((dto) => VaultAuthenticatorLock.load(dto))) !== null && _a2 !== void 0 ? _a2 : [];
    const profileLock = profileLockDto ? VaultProfileLock.load(profileLockDto) : null;
    const adminProfileLock = adminProfileLockDto ? VaultProfileLock.load(adminProfileLockDto) : null;
    const vaultSecret = unlockLockVaultSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock);
    const newSecrets = hsc && vaultAccess ? unlockLockProtectedSecret(vaultAccess, authenticatorLocks, profileLock, adminProfileLock, ccs.profileRepo, hsc) : void 0;
    const userIds = users.map((u2) => u2.id);
    const profileIds = profiles.map((p2) => p2.id);
    const vault = Vault.createFromCommits(vaultId, vaultType, associatedVaultId, generationId, userIds, profileIds, organizationId, authenticatorLocks, profileLock, adminProfileLock, dirty, vaultSecret, commits, null, ccs.profileRepo, messagePublicKey ? loadEncryptionPublicKey(messagePublicKey) : null, messages2, inboxSlug);
    return { vault, newSecrets, vaultAccess };
  });
}
function ensureVaultRepoConsistency(_a2) {
  var ccs = __rest$r(_a2, []);
  if (ccs.protectedSecretRepo && ccs.protectedSecretRepo.isUnlocked()) {
    for (const vault of ccs.vaultRepo.getAllVaults()) {
      if (!ccs.protectedSecretRepo.hasVault(vault.id)) {
        trackError({ message: "Vault was missing from protectedSecretRepo", vaultId: vault.id });
        ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
      }
    }
  }
  for (const vault of ccs.vaultRepo.getAllVaults()) {
    if (vault.type === VaultType.TEAM && (!vault.associatedVaultId || ccs.vaultRepo.getTeamMetaVaultById(vault.associatedVaultId) === null)) {
      trackError({ messsage: "Team vault is missing assosciated vault", vaultId: vault.id });
      ccs.vaultRepo = ccs.vaultRepo.withDeleteVault(vault.id);
    }
  }
  return ccs;
}
function onlineInternalSyncAchievements(_a2, su2) {
  var ccs = __rest$r(_a2, []);
  return __awaiter$H(this, void 0, void 0, function* () {
    const localAchievements = ccs.accountState.getLocalAchievements();
    if (localAchievements.length) {
      su2 = yield ccs.backendClient.account.addAchievements(localAchievements);
      ccs.accountState = ccs.accountState.withSyncUpdate(su2);
    }
    return ccs;
  });
}
function onlineInternalSyncAuditlogEventQueue(_a2) {
  var _b;
  var ccs = __rest$r(_a2, []);
  return __awaiter$H(this, void 0, void 0, function* () {
    const groupedEvents = groupBy(ccs.auditlogEventQueue, (e2) => e2.organizationId);
    ccs.auditlogEventQueue = [];
    let returnResult;
    for (const events of Object.values(groupedEvents)) {
      if (!events) {
        continue;
      }
      const orgId = events[0].organizationId;
      _b = yield onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, events), { returnResult } = _b, ccs = __rest$r(_b, ["returnResult"]);
      if (returnResult === AuditlogWriteResult.Retry) {
        ccs.auditlogEventQueue.push(...events);
      }
    }
    return ccs;
  });
}
var __awaiter$G = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$q = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalChildOrganizationAddManager(_a2, orgId, parentOrgProfileId) {
  var ccs = __rest$q(_a2, []);
  return __awaiter$G(this, void 0, void 0, function* () {
    const disabledOrgProfile = ccs.profileRepo.disabledProfiles.find((p2) => p2.organizationId === orgId);
    const fullSyncRequired = !!disabledOrgProfile;
    if (disabledOrgProfile) {
      ccs.ephemeralOperationState = {
        additionalEnabledProfileIds: [disabledOrgProfile.id]
      };
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
    }
    let hsc;
    ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
    if (!hsc || !ccs.protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const org = ccs.accountState.organizations.find((o2) => o2.id === orgId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    const { adminInfo } = org;
    if (!adminInfo || !adminInfo.authenticator && !adminInfo.adminProfile) {
      throw new NoOrganizationAdminError();
    }
    const adminAuthenticator = adminInfo.authenticator ? [loadForeignAuthenticator(adminInfo.authenticator)] : [];
    const superUserVaultMemberIds = adminInfo.authenticator ? [org.superUserId] : [];
    const adminProfile = adminInfo.adminProfile ? loadForeignProfile(adminInfo.adminProfile) : null;
    const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
    const adminHsup = adminUp ? hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo) : void 0;
    const { users: [{ authenticators }] } = yield ccs.backendClient.account.list([], [], [parentOrgProfileId]);
    const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, orgId, authenticators.map(loadForeignAuthenticator));
    const personalVaultDto = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, superUserVaultMemberIds, [], adminAuthenticator, unsyncedProfile, adminProfile, orgId, organizationPersonalVaultContentDescriptor, null).getCreationDto();
    const adminProfileLock = adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(unsyncedProfile);
    let legacyAdminVaultLock;
    if (adminInfo.legacyAdminVaultId) {
      const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(adminInfo.legacyAdminVaultId);
      if (!legacyAdminVault) {
        throw new VaultNotFoundError(adminInfo.legacyAdminVaultId);
      }
      legacyAdminVaultLock = {
        generationId: legacyAdminVault.generationId,
        vaultId: legacyAdminVault.id,
        lock: serializeVaultProfileLock(ccs.protectedSecretRepo.createProfileLock(legacyAdminVault, unsyncedProfile))
      };
    }
    const { syncUpdate } = yield ccs.backendClient.childOrganization.addManager(orgId, parentOrgProfileId, {
      profile: unsyncedProfile.serialize(),
      personalVaultData: personalVaultDto,
      adminProfileLock,
      legacyAdminVaultLock
    });
    ccs.ephemeralOperationState = void 0;
    if (fullSyncRequired) {
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
    }
    return onlineInternalSync(ccs, syncUpdate);
  });
}
var __rest$p = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function addUnsyncedVaultAfterCreate(_a2, syncUpdate, vaultId, associatedVaultId, organizationId, unsyncedVault) {
  var _b, _c2, _d, _e, _f;
  var ccs = __rest$p(_a2, []);
  const { generationId, commitId } = (_b = syncUpdate.vaults) === null || _b === void 0 ? void 0 : _b.find((v2) => v2.id === vaultId);
  const vault = unsyncedVault.withIds(vaultId, generationId, commitId, associatedVaultId, organizationId);
  ccs.vaultRepo = ccs.vaultRepo.withUpdateVaults(vault);
  ccs.protectedSecretRepo = (_f = (_c2 = ccs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.withProtectedSecret(vault, unsyncedVault.protectedSecret, (_e = (_d = unsyncedVault.messageKeyPair) === null || _d === void 0 ? void 0 : _d.encPrivKey) !== null && _e !== void 0 ? _e : null)) !== null && _f !== void 0 ? _f : null;
  return ccs;
}
var __awaiter$F = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalMakeUnsyncedTeamVaults(ccs, name, organizationId, profile, isSyncOrganizationMembers, inbox, vaultType = VaultType.TEAM, metaVaultType = VaultType.TEAM_META) {
  return __awaiter$F(this, void 0, void 0, function* () {
    const profileIds = !(profile instanceof UnsyncedProfile) ? [profile.id] : [];
    let userIds;
    let adminProfile;
    let authenticators;
    if (organizationId) {
      const org = ccs.accountState.organizations.find((o2) => o2.id === organizationId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      if (org.adminProfileId) {
        const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], [org.adminProfileId], []);
        adminProfile = profilesById[org.adminProfileId];
        authenticators = [];
        userIds = [];
      } else {
        const { authenticatorsByUser } = yield onlineInternalGetUsers(ccs.backendClient, [org.superUserId], [], []);
        adminProfile = null;
        authenticators = authenticatorsByUser[org.superUserId];
        userIds = [org.superUserId];
      }
    } else {
      adminProfile = null;
      authenticators = [];
      userIds = [];
    }
    const unsyncedTeamVault = UnsyncedVault.create(vaultType, userIds, profileIds, authenticators, profile, adminProfile, organizationId !== null && organizationId !== void 0 ? organizationId : null, loginVaultContentDescriptor, inbox !== null && inbox !== void 0 ? inbox : null);
    const unsyncedTeamMetaVault = UnsyncedVault.create(metaVaultType, userIds, profileIds, authenticators, profile, adminProfile, organizationId !== null && organizationId !== void 0 ? organizationId : null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification(profileIds, name, isSyncOrganizationMembers));
    return { unsyncedTeamVault, unsyncedTeamMetaVault };
  });
}
function getInitialMetaContentModification(adminIds, name, isSyncOrganizationMembers) {
  return (c2, t2, { modifyTeamVaultInfo: modifyTeamVaultInfo2, addOrModifyTeamVaultUser: addOrModifyTeamVaultUser2 }) => {
    let newVaultContent = c2;
    ({ newVaultContent } = modifyTeamVaultInfo2(newVaultContent, t2, {
      name,
      // Note: There's currently no exposed api for changing this setting. We used to force it to
      // true via the web app, but will probably implement a UI for it in the future.
      hideSecretsForRestrictedUsers: true,
      isSyncOrganizationMembers
    }));
    for (const adminId of adminIds) {
      ({ newVaultContent } = addOrModifyTeamVaultUser2(newVaultContent, t2, adminId, {
        permissionLevel: PermissionLevel.admin
      }));
    }
    return { newVaultContent, result: void 0 };
  };
}
var __awaiter$E = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$o = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalInboxVaultCreate(_a2, slug, metadata, organizationId) {
  var _b, _c2;
  var ccs = __rest$o(_a2, []);
  return __awaiter$E(this, void 0, void 0, function* () {
    const metadataJson = jsonStringifyFreeze(metadata);
    const profile = (_b = ccs.profileRepo.getOrganizationProfile(organizationId)) === null || _b === void 0 ? void 0 : _b.profile;
    if (!profile) {
      throw new OrganizationNotFoundError();
    }
    const { unsyncedTeamVault: unsyncedInboxVault, unsyncedTeamMetaVault } = yield onlineInternalMakeUnsyncedTeamVaults(ccs, "Inbox", organizationId, profile, false, { slug, metadata }, VaultType.INBOX, VaultType.INBOX_META);
    const { vaultId: inboxVaultId, associatedVaultId: teamMetaVaultId, syncUpdate } = yield ccs.backendClient.vault.createInboxVault({
      blob: unsyncedInboxVault.getCommitBlob(),
      locks: unsyncedInboxVault.getAuthenticatorLockDtos(),
      profileLock: unsyncedInboxVault.getProfileLockDto(),
      adminProfileLock: unsyncedInboxVault.getAdminProfileLockDto(),
      associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
      associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
      associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
      associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto(),
      organizationId,
      messagePublicKey: (_c2 = unsyncedInboxVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey
    }, slug, metadataJson);
    ccs = addUnsyncedVaultAfterCreate(ccs, syncUpdate, inboxVaultId, teamMetaVaultId, organizationId !== null && organizationId !== void 0 ? organizationId : null, unsyncedInboxVault);
    ccs = addUnsyncedVaultAfterCreate(
      ccs,
      syncUpdate,
      // if we pass in an unsynced associated vault, we're also going to get back an id for it
      teamMetaVaultId,
      null,
      organizationId !== null && organizationId !== void 0 ? organizationId : null,
      unsyncedTeamMetaVault
    );
    ccs = yield onlineInternalSync(ccs, syncUpdate);
    return Object.assign(Object.assign({}, ccs), { returnResult: inboxVaultId });
  });
}
var __awaiter$D = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$n = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalInboxVaultDelete(_a2, vaultId) {
  var ccs = __rest$n(_a2, []);
  return __awaiter$D(this, void 0, void 0, function* () {
    const pair = ccs.vaultRepo.getInboxVaultPairById(vaultId);
    if (!pair) {
      throw new VaultNotFoundError(vaultId);
    }
    if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== PermissionLevel.admin) {
      throw new VaultPermissionDeniedError();
    }
    const syncUpdate = yield ccs.backendClient.vault.deleteInboxVault(vaultId);
    ccs = yield onlineInternalSync(ccs, syncUpdate);
    return Object.assign({}, ccs);
  });
}
const ALL_LOGIN_VAULT_PERMISSIONS = {
  viewSecrets: true,
  createLogins: true,
  deleteLogins: true,
  editLogins: true,
  useLogins: true,
  viewHistory: true
};
function getLoginVaultMetadata({ accountState, profileRepo }, vaultPair) {
  switch (vaultPair.type) {
    case VaultType.PRIVATE:
      return getPrivateVaultMetadata(vaultPair.login);
    case VaultType.ORGANIZATION_PERSONAL:
      return getPersonalVaultMetadata({ accountState, profileRepo }, vaultPair.login);
    case VaultType.TEAM:
      return getTeamVaultPairMetadata({ accountState, profileRepo }, vaultPair);
    case VaultType.INBOX:
      return getInboxVaultPairMetadata(vaultPair);
    default:
      throw new UnsupportedLoginVaultTypeError();
  }
}
function assertVaultType(vault, type) {
  if (vault.type != type) {
    throw new IncorrectVaultTypeError(vault.id, type, vault.type);
  }
}
function getPrivateVaultMetadata(vault) {
  var _a2;
  assertVaultType(vault, VaultType.PRIVATE);
  return {
    id: vault.id,
    profileId: (_a2 = vault.getProfileId()) !== null && _a2 !== void 0 ? _a2 : void 0,
    type: VaultType.PRIVATE,
    permissions: ALL_LOGIN_VAULT_PERMISSIONS,
    path: "/logins"
  };
}
function getPersonalVaultMetadata({ accountState, profileRepo }, vault) {
  var _a2, _b, _c2, _d, _e, _f, _g, _h2;
  assertVaultType(vault, VaultType.ORGANIZATION_PERSONAL);
  const org = vault.organizationId && accountState.getOrganization(vault.organizationId);
  if (!org) {
    throw new OrganizationNotFoundError();
  }
  const orgProfile = (_a2 = profileRepo.getOrganizationProfile(vault.organizationId)) === null || _a2 === void 0 ? void 0 : _a2.profile;
  if (orgProfile && vault.profileIds.includes(orgProfile.id)) {
    return {
      id: vault.id,
      profileId: (_b = vault.getProfileId()) !== null && _b !== void 0 ? _b : void 0,
      permissions: ALL_LOGIN_VAULT_PERMISSIONS,
      type: VaultType.ORGANIZATION_PERSONAL,
      owner: {
        profileId: orgProfile.id,
        isLoggedInUser: true,
        email: (_c2 = orgProfile.email) !== null && _c2 !== void 0 ? _c2 : void 0
      },
      organizationId: vault.organizationId,
      path: `/organizations/${vault.organizationId}/logins`
    };
  }
  if (vault.profileIds.length) {
    const ownerProfileId = vault.profileIds.find((pId) => {
      var _a3;
      return pId !== ((_a3 = vault.adminProfileLock) === null || _a3 === void 0 ? void 0 : _a3.lockingProfileId);
    });
    if (!ownerProfileId) {
      throw new Error("organization personal vault without an owner, this should never happen");
    }
    const ownerProfile = (_d = accountState.getOrganization(vault.organizationId)) === null || _d === void 0 ? void 0 : _d.profiles.find((p2) => p2.profileId === ownerProfileId);
    if (!ownerProfile) {
      throw new Error("owner profile not found in organization");
    }
    const ownerEmail = (_f = (_e = accountState.relatedProfiles[ownerProfileId]) === null || _e === void 0 ? void 0 : _e.email) !== null && _f !== void 0 ? _f : void 0;
    return {
      id: vault.id,
      profileId: (_g = vault.getProfileId()) !== null && _g !== void 0 ? _g : void 0,
      name: (_h2 = accountState.getProfileEmail(ownerProfileId)) !== null && _h2 !== void 0 ? _h2 : void 0,
      permissions: {
        viewSecrets: false,
        createLogins: true,
        editLogins: false,
        deleteLogins: false,
        useLogins: false,
        viewHistory: false
      },
      type: VaultType.ORGANIZATION_PERSONAL,
      owner: {
        profileId: ownerProfileId,
        isLoggedInUser: false,
        email: ownerEmail
      },
      organizationId: vault.organizationId,
      path: `/organizations/${vault.organizationId}/members/profiles/${ownerProfileId}/logins`
    };
  }
  throw new Error("organization personal vault without an owner, this should never happen");
}
function getTeamVaultPairMetadata({ accountState, profileRepo }, { login, meta }) {
  var _a2;
  const org = login.organizationId && accountState.getOrganization(login.organizationId);
  assertVaultType(login, VaultType.TEAM);
  const loggedInProfile = org ? profileRepo.getOrganizationProfile(org.id) : profileRepo.getPrivateProfile();
  if (!loggedInProfile) {
    throw new Error("getTeamVaultPairMetadata on a vault outside a known org or private profile");
  }
  const metaContent = meta.getContent();
  const metaInfo = getTeamMetaVaultInfo(metaContent);
  const permissionLevel = getPermissionLevel(metaContent, loggedInProfile.profile.id);
  const newlyJoinedInfo = getNewlyJoinedInfo(metaContent, loggedInProfile.profile.id);
  const hideSecretsForRestrictedUsers = !!metaInfo.hideSecretsForRestrictedUsers;
  return {
    id: login.id,
    profileId: (_a2 = login.getProfileId()) !== null && _a2 !== void 0 ? _a2 : void 0,
    type: VaultType.TEAM,
    name: metaInfo.name,
    isSyncOrganizationMembers: !!metaInfo.isSyncOrganizationMembers,
    isUserJoined: login.isUserJoined,
    newlyJoinedInfo,
    permissions: {
      viewSecrets: !(permissionLevel === PermissionLevel.restricted && hideSecretsForRestrictedUsers),
      createLogins: permissionLevel !== PermissionLevel.restricted,
      editLogins: permissionLevel !== PermissionLevel.restricted,
      deleteLogins: permissionLevel !== PermissionLevel.restricted,
      useLogins: login.isUserJoined,
      viewHistory: permissionLevel === PermissionLevel.admin
    },
    organizationId: login.organizationId,
    path: org ? `/organizations/${org.id}/teams/${login.id}` : `/teams/${login.id}`,
    icon: metaInfo.icon,
    hideSecretsForRestrictedUsers
  };
}
function getInboxVaultPairMetadata({ login }) {
  var _a2;
  assertVaultType(login, VaultType.INBOX);
  const path = login.organizationId ? `/organizations/${login.organizationId}/inboxes/${login.id}` : `/inboxes/${login.id}`;
  return {
    type: VaultType.INBOX,
    permissions: {
      viewSecrets: true,
      createLogins: false,
      editLogins: true,
      deleteLogins: true,
      useLogins: true,
      viewHistory: true
    },
    id: login.id,
    profileId: (_a2 = login.getProfileId()) !== null && _a2 !== void 0 ? _a2 : void 0,
    path,
    slug: login.inboxSlug,
    organizationId: login.organizationId
  };
}
function encodeBase64Urlsafe(data) {
  return naclUtilExports.encodeBase64(data instanceof Uint8Array ? data : new Uint8Array(data)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
function decodeBase64Urlsafe(data) {
  const substituted = data.replace(/_/g, "/").replace(/-/g, "+");
  const padLength = (4 - substituted.length % 4) % 4;
  const padded = substituted.padEnd(substituted.length + padLength, "=");
  return naclUtilExports.decodeBase64(padded);
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function encryptShareLinkLogin(login) {
  const strippedLogin = {
    customFields: login.customFields,
    note: login.note,
    password: login.password,
    title: login.title,
    uiType: login.uiType,
    username: login.username,
    websites: login.websites,
    androidApps: login.androidApps,
    creditCard: login.creditCard,
    totp: login.totp,
    websiteAttributes: login.websiteAttributes,
    // NOTE: the following fields are explicitly redacted
    creationTime: "1970-01-01T00:00:00.000Z",
    editTime: "1970-01-01T00:00:00.000Z",
    changeTime: "1970-01-01T00:00:00.000Z"
  };
  const protectedSecret = newSymmetricSecret();
  const protectedLogin = recursivelyTransformUnprotectedValues(strippedLogin, (pv) => protect(protectedSecret, pv));
  const loginJson = jsonStringifyFreeze(protectedLogin);
  const secret = newSymmetricSecret();
  const encryptedPayload = symEncrypt(secret, naclUtilExports.decodeUTF8(loginJson));
  const encryptedProtectedSecret = symEncryptSymmetricEncryptionKey(secret, protectedSecret);
  const secretBase64 = encodeBase64Urlsafe(secret);
  return { encryptedPayload, secretBase64, encryptedProtectedSecret };
}
const UNIURI_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
function newUniURI() {
  const seed = [...randomSeed().subarray(0, 16)];
  return seed.map((b2) => UNIURI_ALPHABET.charAt(b2 % UNIURI_ALPHABET.length)).join("");
}
var __awaiter$C = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$m = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalLoginShareLinkCreate$1(_a2, vaultId, loginId) {
  var ccs = __rest$m(_a2, []);
  return __awaiter$C(this, void 0, void 0, function* () {
    if (!ccs.protectedSecretRepo) {
      throw new VaultIsLockedError();
    }
    const vaultPair = ccs.vaultRepo.getLoginVaultPairById(vaultId);
    if (!vaultPair) {
      throw new VaultNotFoundError(vaultId);
    }
    const { permissions } = getLoginVaultMetadata(ccs, vaultPair);
    if (!permissions.editLogins || !permissions.viewSecrets) {
      throw new VaultPermissionDeniedError();
    }
    let modifiedVault = vaultPair.login;
    const protectedLogin = modifiedVault.getContent().logins[loginId];
    if (!protectedLogin) {
      throw new LoginNotFoundError(loginId);
    }
    const { unprotectWithContentId: unprotectWithContentId2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(modifiedVault);
    const login = recursivelyTransformProtectedValues(protectedLogin, unprotectWithContentId2);
    const { encryptedPayload, secretBase64, encryptedProtectedSecret } = encryptShareLinkLogin(login);
    const shareLinkId = newUniURI();
    modifiedVault = modifiedVault.withAddShareLinkUpdate({
      id: shareLinkId,
      encryptedPayload,
      encryptedProtectedSecret
    });
    ccs = modifyLoginVault(ccs, modifiedVault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2, protect: protect2 }) => {
      var _a3;
      const result = modifyLoginInternal2(c2, t2, loginId, {
        shareLinks: [
          ...(_a3 = protectedLogin.shareLinks) !== null && _a3 !== void 0 ? _a3 : [],
          {
            id: shareLinkId,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            secret: protect2({ contentId: newUuid$1(), unencrypted: secretBase64 })
          }
        ]
      });
      return Object.assign(Object.assign({}, result), { auditlogEvents: [
        {
          type: AuditlogEventType.LOGIN_SHARE_LINK_CREATE,
          loginId,
          vaultId
        }
      ] });
    });
    ccs = Object.assign(Object.assign({}, ccs), { accountState: ccs.accountState.withLocalAchievements([Achievement.WEB_LOGIN_CREATE_SHARE_LINK]) });
    ccs = yield onlineInternalSync(ccs);
    return Object.assign(Object.assign({}, ccs), { returnResult: { shareLinkId, secretBase64 } });
  });
}
var __awaiter$B = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$l = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalLoginShareLinkCreate(_a2, vaultId, loginId, shareLinkId) {
  var _b;
  var ccs = __rest$l(_a2, []);
  return __awaiter$B(this, void 0, void 0, function* () {
    const vaultPair = ccs.vaultRepo.getLoginVaultPairById(vaultId);
    if (!vaultPair) {
      throw new VaultNotFoundError(vaultId);
    }
    const { permissions } = getLoginVaultMetadata(ccs, vaultPair);
    if (!permissions.editLogins || !permissions.viewSecrets) {
      throw new VaultPermissionDeniedError();
    }
    const vault = vaultPair.login;
    const protectedLogin = vault.getContent().logins[loginId];
    if (!protectedLogin) {
      throw new LoginNotFoundError(loginId);
    }
    if (!ccs.protectedSecretRepo) {
      throw new VaultIsLockedError();
    }
    if (!((_b = protectedLogin.shareLinks) === null || _b === void 0 ? void 0 : _b.some((sl2) => sl2.id === shareLinkId))) {
      throw new ShareLinkNotFoundError(shareLinkId);
    }
    ccs = modifyLoginVault(ccs, vault, (c2, t2, { modifyLoginInternal: modifyLoginInternal2 }) => {
      var _a3;
      const result = modifyLoginInternal2(c2, t2, loginId, {
        shareLinks: (_a3 = protectedLogin.shareLinks) === null || _a3 === void 0 ? void 0 : _a3.filter((sl2) => sl2.id !== shareLinkId)
      });
      return Object.assign(Object.assign({}, result), { auditlogEvents: [] });
    });
    return onlineInternalSync(ccs);
  });
}
var __awaiter$A = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$k = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalOrganizationRegenerateProfiles(inputCcs, orgId, profiles) {
  return __awaiter$A(this, void 0, void 0, function* () {
    const profileIds = profiles.map((p2) => p2.profileId);
    return performWithPersonalVaultsSyncPredicate(inputCcs, profileIds, (_a2, hsc) => __awaiter$A(this, void 0, void 0, function* () {
      var ccs = __rest$k(_a2, []);
      const org = ccs.accountState.getOrganization(orgId);
      if (!org) {
        throw new OrganizationNotFoundError();
      }
      if (!org.isAdmin) {
        throw new NoOrganizationAdminError();
      }
      const { vaultRepo, protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        throw new ClientCoreIsLockedError();
      }
      const userIds = profiles.flatMap((p2) => p2.userId ? p2.userId : []);
      const { authenticatorsByUser } = yield onlineInternalGetUsers(ccs.backendClient, userIds, [], []);
      const orgAdminProfile = ccs.profileRepo.getOrgAdminProfile(orgId);
      const returnResult = {};
      for (const { profileId, userId } of profiles) {
        const orgProfile = org === null || org === void 0 ? void 0 : org.profiles.find((p2) => p2.profileId === profileId);
        if (!org || !orgProfile) {
          throw new Error("Profile organization not found");
        }
        const unsynced = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION, org.id, userId ? authenticatorsByUser[userId] : [], []);
        const vaultLocks = vaultRepo.getAllVaultsByProfileId(profileId).map((v2) => ({
          vaultId: v2.id,
          generationId: v2.generationId,
          lock: protectedSecretRepo.createProfileLock(v2, unsynced.unsyncedProfile)
        }));
        const downstreamProfileLocks = orgProfile.isAdmin && orgAdminProfile ? [
          hsc.getHighSecurityUnlockedProfile(orgAdminProfile, ccs.profileRepo).createProfileLock(unsynced.unsyncedProfile)
        ] : [];
        const regProfile = {
          profile: unsynced.unsyncedProfile.serialize(profileId),
          vaultLocks,
          downstreamProfileLocks
        };
        yield ccs.backendClient.organization.regenerateUser(orgId, userId, regProfile);
        returnResult[profileId] = unsynced;
      }
      return Object.assign(Object.assign({}, ccs), { returnResult });
    }));
  });
}
function performWithPersonalVaultsSyncPredicate(ccs, profileIds, operation) {
  var _a2;
  return __awaiter$A(this, void 0, void 0, function* () {
    const originalForeignVaultSyncPredicate = ccs.ephemeralForeignVaultSyncPredicate;
    ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { profileAllVaults: [
      ...(_a2 = ccs.ephemeralForeignVaultSyncPredicate.profileAllVaults) !== null && _a2 !== void 0 ? _a2 : [],
      ...profileIds
    ] });
    const originalBackendClient = ccs.backendClient;
    ccs.syncVersion = null;
    ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
    let hsc;
    ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
    if (!hsc) {
      throw new ClientCoreIsLockedError();
    }
    const _b = yield operation(ccs, hsc), { returnResult } = _b, newCcs = __rest$k(_b, ["returnResult"]);
    ccs = newCcs;
    ccs.syncVersion = null;
    ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
    ccs.ephemeralForeignVaultSyncPredicate = originalForeignVaultSyncPredicate;
    ccs = yield onlineInternalSync(ccs);
    return Object.assign(Object.assign({}, ccs), { returnResult });
  });
}
var __awaiter$z = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$j = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineMaintainOrganizationPreliminaryProfiles(_a2) {
  var _b;
  var ccs = __rest$j(_a2, []);
  return __awaiter$z(this, void 0, void 0, function* () {
    const task = MaintenanceTask.ORGANIZATION_PRELIMINARY_PROFILES_V3;
    if (!((_b = ccs.maintenanceSettings) === null || _b === void 0 ? void 0 : _b.allowedTasks.includes(task))) {
      return ccs;
    }
    const registeredFreeProfiles = getOrganizationsProfilesWithPreliminaryUserId(ccs.accountState.organizations, ccs.profileRepo);
    for (const { organization, profiles } of registeredFreeProfiles) {
      ccs = yield onlineInternalOrganizationRegenerateProfiles(ccs, organization.id, profiles.map(({ profileId, preliminaryUserId }) => ({
        profileId,
        userId: preliminaryUserId
      })));
    }
    return ccs;
  });
}
function getOrganizationsProfilesWithPreliminaryUserId(organizations, profileRepo) {
  return organizations.filter((org) => org.isAdmin && !!org.adminInfo).filter((org) => !!profileRepo.getOrganizationProfile(org.id)).flatMap((organization) => {
    const profiles = organization.profiles.filter((p2) => !!p2.preliminaryUserId);
    return profiles.length ? { organization, profiles } : [];
  });
}
function normalizeEmailAddress(email) {
  return email.trim().toLowerCase();
}
var __awaiter$y = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalTeamModifyUsers(ccs, teamId, { profileIdsToRemove, usersToAdd, skipInvite }) {
  return __awaiter$y(this, void 0, void 0, function* () {
    const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
    if (!pair) {
      throw new VaultNotFoundError(teamId);
    }
    let { login: loginVault, meta: metaVault } = pair;
    const backendClient = getBackendClientForVault(ccs, loginVault);
    const normalizedUsersToAdd = usersToAdd === null || usersToAdd === void 0 ? void 0 : usersToAdd.map((u2) => u2.by === "email" ? Object.assign(Object.assign({}, u2), { email: normalizeEmailAddress(u2.email) }) : u2);
    if (
      // only admins can perform user operations
      getLoggedInUserTeamPermissionLevel(ccs.accountState, metaVault) !== PermissionLevel.admin
    ) {
      throw new VaultPermissionDeniedError();
    }
    const { addProfileOps } = normalizedUsersToAdd ? yield onlineCreateAddUserOps(ccs, loginVault, metaVault, normalizedUsersToAdd) : { addProfileOps: [] };
    const commitData = getUpdatedMetaVault$1(ccs, metaVault, addProfileOps, profileIdsToRemove, skipInvite);
    const { syncUpdate } = yield backendClient.vault.modifyTeamUsers(teamId, loginVault.generationId, addProfileOps, profileIdsToRemove !== null && profileIdsToRemove !== void 0 ? profileIdsToRemove : [], metaVault.generationId, commitData === null || commitData === void 0 ? void 0 : commitData.metaVaultCommitId, commitData === null || commitData === void 0 ? void 0 : commitData.blob, commitData === null || commitData === void 0 ? void 0 : commitData.latestUpdateTime);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
function onlineCreateAddUserOps({ backendClient, protectedSecretRepo }, loginVault, metaVault, normalizedUsersToAdd) {
  var _a2, _b;
  return __awaiter$y(this, void 0, void 0, function* () {
    if (!protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const { index: index2, profilesById } = yield onlineInternalGetUsers(backendClient, [], normalizedUsersToAdd.flatMap((u2) => u2.by === "profile" ? u2.profileId : []), normalizedUsersToAdd.flatMap((u2) => u2.by === "email" ? u2.email : []), (_a2 = loginVault.organizationId) !== null && _a2 !== void 0 ? _a2 : void 0);
    const addProfileOps = [];
    for (const { profileId, email } of index2) {
      const userToAdd = (_b = normalizedUsersToAdd.find((u2) => u2.by === "profile" && u2.profileId === profileId)) !== null && _b !== void 0 ? _b : normalizedUsersToAdd.find((u2) => u2.by === "email" && u2.email === email);
      if (!userToAdd) {
        continue;
      }
      const { permissionLevel } = userToAdd;
      if (profileId) {
        const p2 = profilesById[profileId];
        const lock = serializeVaultProfileLock(protectedSecretRepo.createProfileLock(loginVault, p2));
        const associatedLock = serializeVaultProfileLock(protectedSecretRepo.createProfileLock(metaVault, p2));
        addProfileOps.push({
          id: profileId,
          email: email !== null && email !== void 0 ? email : void 0,
          lock,
          associatedLock,
          permissionLevel
        });
      }
    }
    return { addProfileOps };
  });
}
function getUpdatedMetaVault$1(ccs, metaVault, addedProfiles, removeProfileIds, skipMarkNewlyJoined) {
  var _a2;
  const relevantProfileId = metaVault.getProfileId();
  const relevantEmail = relevantProfileId ? (_a2 = ccs.profileRepo.getUnlocked(relevantProfileId)) === null || _a2 === void 0 ? void 0 : _a2.profile.email : ccs.accountState.getPrimaryEmail();
  ({ vault: metaVault } = metaVault.withModification((initialVaultContent, t2, ops) => {
    let newVaultContent = initialVaultContent;
    const org = metaVault.organizationId ? ccs.accountState.getOrganization(metaVault.organizationId) : void 0;
    if (addedProfiles) {
      newVaultContent = addedProfiles.reduce((c2, addedProfile) => {
        var _a3, _b, _c2;
        const isNotConnected = (_b = (_a3 = org === null || org === void 0 ? void 0 : org.profiles.find((p2) => p2.profileId === addedProfile.id)) === null || _a3 === void 0 ? void 0 : _a3.isNotConnected) !== null && _b !== void 0 ? _b : false;
        return ops.addOrModifyTeamVaultUser(c2, t2, addedProfile.id, {
          newlyJoined: skipMarkNewlyJoined || isNotConnected ? void 0 : {
            // Only filled in for compatibility with older clients that require this field to be
            // set
            addedByUserId: nullUuid,
            addedByEmail: relevantEmail !== null && relevantEmail !== void 0 ? relevantEmail : ""
          },
          permissionLevel: (_c2 = addedProfile.permissionLevel) !== null && _c2 !== void 0 ? _c2 : TEAM_USER_DEFAULT_PERMISSION_LEVEL
        }).newVaultContent;
      }, newVaultContent);
    }
    if (removeProfileIds) {
      newVaultContent = removeProfileIds.reduce((c2, userId) => {
        return ops.deleteTeamVaultUser(c2, t2, userId).newVaultContent;
      }, newVaultContent);
    }
    return { newVaultContent, result: void 0 };
  }));
  const stagedData = metaVault.getStagedDiff(null);
  if (!stagedData) {
    return null;
  }
  const { stagingVault, diff, latestUpdateTime } = stagedData;
  const protoCommit = Commit.create(null, stagingVault.vaultSecret, diff);
  return {
    metaVaultCommitId: metaVault.commitId,
    blob: protoCommit.blob,
    latestUpdateTime: new Date(latestUpdateTime)
  };
}
var __awaiter$x = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$i = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalMaintainTeamSyncOrganizationMembers(_a2, skipInvite) {
  var _b;
  var ccs = __rest$i(_a2, []);
  return __awaiter$x(this, void 0, void 0, function* () {
    const task = MaintenanceTask.TEAM_SYNC_ORGANIZATION_MEMBERS_V2;
    if (!((_b = ccs.maintenanceSettings) === null || _b === void 0 ? void 0 : _b.allowedTasks.includes(task))) {
      return ccs;
    }
    const teamsToChange = getTeamsWithSyncOrganizationMembersAndMismatchedUsers(ccs.vaultRepo, ccs.accountState);
    if (!teamsToChange.length) {
      return ccs;
    }
    for (const { teamId, details } of teamsToChange) {
      const { profileIdsToAdd, profileIdsToRemove, profilesToUpdate } = details;
      if (profileIdsToAdd.length || profileIdsToRemove.length) {
        ccs = yield onlineInternalTeamModifyUsers(ccs, teamId, {
          usersToAdd: profileIdsToAdd.map((profileId) => {
            return {
              by: "profile",
              profileId,
              permissionLevel: void 0
            };
          }),
          profileIdsToRemove,
          skipInvite
        });
      }
      if (profilesToUpdate.length) {
        ccs = internalTeamSetUserPermissionLevels(ccs, teamId, ...profilesToUpdate.map(({ profileId, isAdmin }) => ({
          profileId,
          permissionLevel: deriveTeamPermissionLevelFromOrgIsAdmin(isAdmin)
        })));
        ccs = yield onlineInternalSync(ccs);
      }
    }
    return ccs;
  });
}
function getTeamsWithSyncOrganizationMembersAndMismatchedUsers(vaultRepo, accountState) {
  return vaultRepo.getTeamVaultPairs().map(({ login, meta }) => {
    if (!login.organizationId || getLoggedInUserTeamPermissionLevel(accountState, meta) !== PermissionLevel.admin || !getTeamMetaVaultInfo(meta.getContent()).isSyncOrganizationMembers) {
      return null;
    }
    const organization = accountState.getOrganization(login.organizationId);
    if (!organization) {
      return null;
    }
    const adminProfileIds = organization.adminProfileId ? [organization.adminProfileId] : [];
    const organizationProfileIds = /* @__PURE__ */ new Set([
      ...adminProfileIds,
      ...organization.profiles.flatMap(({ profileId, isService }) => isService ? [] : profileId)
    ]);
    const currentUserProfileId = login.getProfileId();
    if (currentUserProfileId) {
      organizationProfileIds.add(currentUserProfileId);
    }
    const teamProfileIds = new Set(login.profileIds);
    const profileIdsToAdd = setDifference(organizationProfileIds, teamProfileIds);
    const profileIdsToRemove = setDifference(teamProfileIds, organizationProfileIds);
    const profilesToUpdate = organization.profiles.filter(({ profileId, isAdmin }) => teamProfileIds.has(profileId) && !orgIsAdminMatchesTeamPermissionLevel(isAdmin, getPermissionLevel(meta.getContent(), profileId)));
    return {
      teamId: login.id,
      details: {
        profileIdsToAdd,
        profileIdsToRemove,
        profilesToUpdate
      }
    };
  }).filter((teamResult) => !!teamResult && Object.values(teamResult.details).some((val) => val.length));
}
function orgIsAdminMatchesTeamPermissionLevel(isAdmin, permissionLevel) {
  if (isAdmin) {
    return permissionLevel === PermissionLevel.admin;
  }
  return permissionLevel !== PermissionLevel.admin;
}
function deriveTeamPermissionLevelFromOrgIsAdmin(isAdmin) {
  return isAdmin ? PermissionLevel.admin : TEAM_USER_DEFAULT_PERMISSION_LEVEL;
}
function setDifference(a2, b2) {
  return [...a2].filter((x) => !b2.has(x));
}
var __awaiter$w = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$h = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalMaintainVaultMessages(_a2) {
  var ccs = __rest$h(_a2, []);
  return __awaiter$w(this, void 0, void 0, function* () {
    if (!ccs.protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const protectedSecretRepo = ccs.protectedSecretRepo;
    const vaultsWithMessages = ccs.vaultRepo.getAllVaults().filter((v2) => !!v2.messageQueue.length);
    const updates = vaultsWithMessages.map((vault) => {
      const { protect: protect2, decryptVaultMessage } = protectedSecretRepo.getProtectedSecretFunctions(vault);
      if (!decryptVaultMessage) {
        throw new Error("cannot decrypt inbox vault");
      }
      return processVaultMessages(vault, decryptVaultMessage, protect2);
    });
    const updatedVaultPromises = updates.map(({ vault, processedMessageIds }) => __awaiter$w(this, void 0, void 0, function* () {
      const stagedDiff = vault.getStagedDiff(null);
      if (!stagedDiff) {
        return;
      }
      const { diff, latestUpdateTime, stagingVault } = stagedDiff;
      const protoCommit = Commit.create(null, vault.vaultSecret, diff);
      const backendClient = getBackendClientForVault(ccs, vault);
      const { commitId } = yield backendClient.vault.createCommit(vault.id, vault.commitId, protoCommit.blob, new Date(latestUpdateTime), processedMessageIds);
      const filteredMessages = stagingVault.messageQueue.filter((m2) => !processedMessageIds.includes(m2.id));
      return stagingVault.withCommitId(commitId).withMessageQueue(filteredMessages);
    }));
    const updateResults = yield Promise.allSettled(updatedVaultPromises);
    const updatedVaults = updateResults.flatMap((result) => {
      if (result.status == "rejected") {
        if (result.reason instanceof DomainError) {
          if (result.reason.code === BackendErrorCode.VAULT_OUT_OF_SYNC) {
            return [];
          }
          if (result.reason.code === BackendErrorCode.VAULT_DIRTY) {
            return [];
          }
        }
        trackError(result.reason);
        return [];
      }
      if (result.value) {
        return [result.value];
      }
      return [];
    });
    const updatedVaultRepo = updatedVaults.length ? ccs.vaultRepo.withUpdateVaults(...updatedVaults) : ccs.vaultRepo;
    return Object.assign(Object.assign({}, ccs), { vaultRepo: updatedVaultRepo });
  });
}
function hasProcessableVaultMessages(vaultRepo) {
  return vaultRepo.getAllVaults().flatMap((v2) => v2.messageQueue).some((m2) => KNOWN_VAULT_MESSAGE_TYPES.includes(m2.type));
}
var __awaiter$v = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$g = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalMigrateToAuthenticatorChain(_a2, hsc) {
  var ccs = __rest$g(_a2, []);
  return __awaiter$v(this, void 0, void 0, function* () {
    const authenticatorKeys = ccs.accountState.authenticators.map((a2) => a2.highSecurityIdentitySigPubKey);
    const authenticatorBlock = AuthenticatorBlock.create(hsc.getHighSecurityUnlockedAuthenticator().highSecurityIdentitySigPrivKey, authenticatorKeys);
    try {
      const syncUpdate = yield ccs.backendClient.authenticator.createInitialAuthenticatorBlock(authenticatorBlock);
      return yield onlineInternalSync(ccs, syncUpdate);
    } catch (e2) {
      if (e2 instanceof BackendDomainError && e2.code === BackendErrorCode.AUTHENTICATOR_BLOCK_EXISTS) {
        return ccs;
      }
      throw e2;
    }
  });
}
function regenerateProfiles(hsc, protectedSecretRepo, vaultRepo, profileRepo, authenticators, newAuthenticators) {
  const unsyncedProfiles = profileRepo.profiles.map(({ profile }) => ({
    profile,
    unsynced: UnsyncedProfile.create(profile.profileType, profile.organizationId, authenticators)
  }));
  const regeneratedProfiles = unsyncedProfiles.map(({ profile, unsynced }) => {
    const vaultLocks = vaultRepo.getAllVaults().filter((v2) => v2.profileIds.includes(profile.id)).map((v2) => ({
      vaultId: v2.id,
      generationId: v2.generationId,
      lock: protectedSecretRepo.createProfileLock(v2, unsynced)
    }));
    const downstreamProfileLocks = profileRepo.getAllProfilesByLockingProfileId(profile.id).map((p2) => {
      const hsup = hsc.getHighSecurityUnlockedProfile(p2, profileRepo);
      return hsup.createProfileLock(unsynced);
    });
    return {
      profile: unsynced.serialize(profile.id, profile.keyGenerationId),
      vaultLocks,
      downstreamProfileLocks
    };
  });
  const authenticatorCreationDtos = newAuthenticators.map((ua2) => ua2.serializeWithLocks(unsyncedProfiles.map(({ profile, unsynced }) => Object.assign(Object.assign({}, unsynced.createExtraLock(ua2)), { profileId: profile.id, profileKeyGenerationId: nullUuid }))));
  return { regeneratedProfiles, authenticatorCreationDtos };
}
var __awaiter$u = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$f = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalModifyAuthenticators(inputCcs, hsc, deleteAuthenticatorIds, newAuthenticators = []) {
  return __awaiter$u(this, void 0, void 0, function* () {
    return performWithSyncSuperUsers(inputCcs, hsc, (_a2) => __awaiter$u(this, void 0, void 0, function* () {
      var ccs = __rest$f(_a2, []);
      let { protectedSecretRepo } = ccs;
      if (!protectedSecretRepo) {
        protectedSecretRepo = ProtectedSecretRepo.create(ccs, hsc, null);
      }
      const isRemovingLocalAuthenticator = deleteAuthenticatorIds.some((id2) => id2 === ccs.params.unlockedAuthenticator.authenticator.id);
      if (isRemovingLocalAuthenticator) {
        throw new RemoveLocalAuthenticatorError();
      }
      const remainingAuths = ccs.accountState.authenticators.filter((a2) => deleteAuthenticatorIds.every((delId) => a2.id !== delId));
      const authenticatorKeys = remainingAuths.map((a2) => a2.highSecurityIdentitySigPubKey);
      const newAuthenticatorKeys = newAuthenticators.map((a2) => a2.highSecurityIdentitySigPubKey);
      const newAuthenticatorBlock = AuthenticatorBlock.create(hsc.getHighSecurityUnlockedAuthenticator().highSecurityIdentitySigPrivKey, [...authenticatorKeys, ...newAuthenticatorKeys], ccs.accountState.authenticatorBlockHash);
      let regeneratedProfiles;
      let authenticatorCreationDtos;
      if (deleteAuthenticatorIds.length) {
        ({ regeneratedProfiles, authenticatorCreationDtos } = regenerateProfiles(hsc, protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, remainingAuths, newAuthenticators));
      } else {
        regeneratedProfiles = [];
        authenticatorCreationDtos = newAuthenticators.map((a2) => a2.serializeForCreation(ccs.profileRepo, hsc));
      }
      const { syncUpdate, authenticatorIds } = yield ccs.backendClient.authenticator.modify(authenticatorCreationDtos, deleteAuthenticatorIds, newAuthenticatorBlock, regeneratedProfiles);
      ccs = yield onlineInternalSync(ccs, syncUpdate, void 0, hsc);
      return Object.assign(Object.assign({}, ccs), { returnResult: authenticatorIds });
    }));
  });
}
function performWithSyncSuperUsers(ccs, hsc, operation) {
  return __awaiter$u(this, void 0, void 0, function* () {
    const originalBackendClient = ccs.backendClient;
    ccs.syncVersion = null;
    ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
    ccs = yield onlineInternalSync(ccs, void 0, void 0, hsc);
    const _a2 = yield operation(ccs), { returnResult } = _a2, newCcs = __rest$f(_a2, ["returnResult"]);
    ccs = newCcs;
    ccs.syncVersion = null;
    ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
    ccs = yield onlineInternalSync(ccs, void 0, void 0, hsc);
    return Object.assign(Object.assign({}, ccs), { returnResult });
  });
}
var __awaiter$t = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalSessionSetProfileEnabled(ccs, profileId, enabled) {
  return __awaiter$t(this, void 0, void 0, function* () {
    const sessionId = ccs.params.loginData.sessionId;
    const session = ccs.accountState.sessions.find((s2) => s2.id == sessionId);
    if (!session) {
      throw new OwnSessionMissingError();
    }
    const allProfilesEnabled = session.enabledProfileIds.length === 0;
    const allProfileIds = ccs.profileRepo.getAllLoginProfileIds();
    const previouslyEnabled = allProfilesEnabled || session.enabledProfileIds.some((pId) => pId === profileId);
    if (enabled === previouslyEnabled) {
      return ccs;
    }
    const oldEnabledProfileIds = allProfilesEnabled ? allProfileIds : session.enabledProfileIds.filter((pId) => allProfileIds.includes(pId));
    const enabledProfileIds = enabled ? [...oldEnabledProfileIds, profileId] : oldEnabledProfileIds.filter((pId) => pId !== profileId);
    return onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds);
  });
}
function onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds) {
  return __awaiter$t(this, void 0, void 0, function* () {
    const sessionId = ccs.params.loginData.sessionId;
    const su2 = yield ccs.backendClient.session.update(sessionId, [], { enabledProfileIds });
    return onlineInternalSync(ccs, su2);
  });
}
var __awaiter$s = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$e = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalOrganizationCreate(_a2, email, name, syncOrganizationMembersVaultName, options) {
  var _b, _c2;
  var ccs = __rest$e(_a2, []);
  return __awaiter$s(this, void 0, void 0, function* () {
    const unsyncedUserProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, null, ccs.accountState.authenticators);
    const { unsyncedProfile: unsyncedAdminProfile } = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION_ADMIN, null, [], [unsyncedUserProfile]);
    const unsyncedPersonalVault = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, organizationPersonalVaultContentDescriptor, null);
    const unsyncedTeamVault = UnsyncedVault.create(VaultType.TEAM, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, loginVaultContentDescriptor, null);
    const unsyncedTeamMetaVault = UnsyncedVault.create(VaultType.TEAM_META, [], [], [], unsyncedUserProfile, unsyncedAdminProfile, null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification([], syncOrganizationMembersVaultName, true));
    const teamVaultDto = {
      blob: unsyncedTeamVault.getCommitBlob(),
      locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
      profileLock: unsyncedTeamVault.getProfileLockDto(),
      adminProfileLock: unsyncedTeamVault.getAdminProfileLockDto(),
      messagePublicKey: (_b = unsyncedTeamVault.messageKeyPair) === null || _b === void 0 ? void 0 : _b.encPubKey,
      associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
      associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
      associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
      associatedMessagePublicKey: (_c2 = unsyncedTeamMetaVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey,
      associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto()
    };
    const unsyncedAdminVault = UnsyncedVault.create(VaultType.ORGANIZATION_ADMIN, [], [], [], null, unsyncedAdminProfile, null, organizationAdminVaultContentDescriptor, null, (c2, t2, { replaceOrganizationAdminVaultInfo: replaceOrganizationAdminVaultInfo2 }) => replaceOrganizationAdminVaultInfo2(c2, t2, {}));
    const result = yield ccs.backendClient.organization.create({
      name,
      email,
      userProfile: unsyncedUserProfile.serialize(),
      adminProfile: unsyncedAdminProfile.serialize(),
      personalVaultDto: unsyncedPersonalVault.getCreationDto(),
      teamVaultDto,
      contactJson: options === null || options === void 0 ? void 0 : options.contactJson,
      parentOrganizationInfo: (options === null || options === void 0 ? void 0 : options.parentOrganizationId) ? { id: options.parentOrganizationId } : void 0,
      adminVaultDto: unsyncedAdminVault.getCreationDto()
    });
    ccs = yield onlineInternalSync(ccs, result.syncUpdate);
    ccs = yield onlineInternalSessionSetProfileEnabled(ccs, result.profileId, true);
    return Object.assign(Object.assign({}, ccs), { returnResult: result.organizationId });
  });
}
function createOrganizationAuthenticator() {
  const secret = { seed: randomSeed() };
  const unsyncedAuthenticator = UnsyncedAuthenticator.create(AuthenticatorType.ORGANIZATION_ADMIN, "", secret);
  return { secret, unsyncedAuthenticator };
}
function serializeAuthenticator(a2) {
  const id2 = "id" in a2 ? a2.id : nullUuid;
  return Object.assign(Object.assign({}, a2), { id: id2 });
}
var __awaiter$r = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$d = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalOrganizationCreateLegacy(_a2, email, name, syncOrganizationMembersVaultName, options) {
  var _b, _c2;
  var ccs = __rest$d(_a2, []);
  return __awaiter$r(this, void 0, void 0, function* () {
    const { secret, unsyncedAuthenticator: orgAuth } = createOrganizationAuthenticator();
    const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, null, ccs.accountState.authenticators);
    const unsyncedAdminVault = UnsyncedVault.create(VaultType.LEGACY_ORGANIZATION_ADMIN, [], [], [], unsyncedProfile, null, null, legacyOrganizationAdminVaultContentDescriptor, null, (c2, t2, { protect: prot, replaceLegacyOrganizationAdminVaultInfo: replaceLegacyOrganizationAdminVaultInfo2 }) => replaceLegacyOrganizationAdminVaultInfo2(c2, t2, {
      authenticatorSecret: {
        seed: prot({ unencrypted: naclUtilExports.encodeBase64(secret.seed), contentId: newUuid$1() })
      }
    }));
    const authBlock = AuthenticatorBlock.fromUnsyncedAuthenticators(orgAuth, []);
    const unsyncedPersonalVault = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, [], [], [], unsyncedProfile, null, null, organizationPersonalVaultContentDescriptor, null);
    const unsyncedTeamVault = UnsyncedVault.create(VaultType.TEAM, [], [], [], unsyncedProfile, null, null, loginVaultContentDescriptor, null);
    const unsyncedTeamMetaVault = UnsyncedVault.create(VaultType.TEAM_META, [], [], [], unsyncedProfile, null, null, teamMetaVaultContentDescriptor, null, getInitialMetaContentModification([], syncOrganizationMembersVaultName, true));
    const teamVaultDto = {
      blob: unsyncedTeamVault.getCommitBlob(),
      locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
      profileLock: unsyncedTeamVault.getProfileLockDto(),
      messagePublicKey: (_b = unsyncedTeamVault.messageKeyPair) === null || _b === void 0 ? void 0 : _b.encPubKey,
      associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
      associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
      associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
      associatedMessagePublicKey: (_c2 = unsyncedTeamMetaVault.messageKeyPair) === null || _c2 === void 0 ? void 0 : _c2.encPubKey
    };
    const result = yield ccs.backendClient.organization.create({
      name,
      email,
      userProfile: unsyncedProfile.serialize(),
      orgAuth: serializeAuthenticator(orgAuth),
      legacyAdminVaultDto: unsyncedAdminVault.getCreationDto(),
      authenticatorBlock: { blob: authBlock.blob, signature: authBlock.signature },
      personalVaultDto: unsyncedPersonalVault.getCreationDto(),
      personalVaultSuperuserLock: unsyncedPersonalVault.getExtraLockDto(orgAuth),
      teamVaultDto,
      teamVaultSuperuserLock: unsyncedTeamVault.getExtraLockDto(orgAuth),
      teamAssociatedVaultSuperuserLock: unsyncedTeamMetaVault.getExtraLockDto(orgAuth),
      contactJson: options === null || options === void 0 ? void 0 : options.contactJson,
      parentOrganizationInfo: (options === null || options === void 0 ? void 0 : options.parentOrganizationId) ? { id: options.parentOrganizationId } : void 0
    });
    ccs = yield onlineInternalSync(ccs, result.syncUpdate);
    ccs = yield onlineInternalSessionSetProfileEnabled(ccs, result.profileId, true);
    return Object.assign(Object.assign({}, ccs), { returnResult: result.organizationId });
  });
}
var __awaiter$q = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalOrganizationCreateServiceProfile(ccs, orgId) {
  return __awaiter$q(this, void 0, void 0, function* () {
    const org = ccs.accountState.organizations.find((o2) => o2.id === orgId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    let hsc;
    ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
    if (!hsc) {
      throw new ClientCoreIsLockedError();
    }
    const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
    if (!adminUp) {
      throw new NoOrganizationAdminError();
    }
    const adminHsup = hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo);
    const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION_SERVICE, orgId, []);
    const adminProfileLock = adminHsup.createProfileLock(unsyncedProfile);
    const syncUpdate = yield ccs.backendClient.organization.createServiceProfile(orgId, unsyncedProfile.serialize(), adminProfileLock);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
var __awaiter$p = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$c = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalOrganizationDelete(_a2, orgId) {
  var ccs = __rest$c(_a2, []);
  return __awaiter$p(this, void 0, void 0, function* () {
    ccs = yield onlineInternalSync(ccs);
    const { protectedSecretRepo } = ccs;
    if (!protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const org = ccs.accountState.getOrganization(orgId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    const syncUpdate = yield ccs.backendClient.organization.delete(orgId);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
var __awaiter$o = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalOrganizationModifyMembers(ccs, orgId, { createFreeProfiles, updateProfiles, removeProfileIds }) {
  var _a2;
  return __awaiter$o(this, void 0, void 0, function* () {
    const disabledOrgProfile = ccs.profileRepo.disabledProfiles.find((p2) => p2.organizationId === orgId);
    const fullSyncRequired = !!disabledOrgProfile;
    if (disabledOrgProfile) {
      ccs.ephemeralOperationState = {
        additionalEnabledProfileIds: [disabledOrgProfile.id]
      };
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
    }
    let hsc;
    ({ hsc, ccs } = yield onlineInternalSyncReturningHighSecurityCache(ccs));
    if (!hsc) {
      throw new ClientCoreIsLockedError();
    }
    const org = ccs.accountState.organizations.find((o2) => o2.id === orgId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
    if (!orgProfile) {
      throw new OrganizationNotFoundError();
    }
    const profiles = org.profiles;
    profiles.push({
      profileId: orgProfile.profile.id,
      isAdmin: org.isAdmin,
      isManager: org.isManager,
      isService: false,
      isNotConnected: false
    });
    const { adminInfo } = org;
    if (!adminInfo || !adminInfo.authenticator && !adminInfo.adminProfile) {
      throw new NoOrganizationAdminError();
    }
    const adminAuthenticator = adminInfo.authenticator ? [loadForeignAuthenticator(adminInfo.authenticator)] : [];
    const superUserVaultMemberIds = adminInfo.authenticator ? [org.superUserId] : [];
    const adminProfile = adminInfo.adminProfile ? loadForeignProfile(adminInfo.adminProfile) : null;
    const adminUp = ccs.profileRepo.getOrgAdminProfile(orgId);
    const adminHsup = adminUp ? hsc.getHighSecurityUnlockedProfile(adminUp, ccs.profileRepo) : void 0;
    const addedAdminProfileIds = [];
    const removedAdminProfileIds = [];
    let addedAdminUnsyncedProfiles = [];
    removeProfileIds === null || removeProfileIds === void 0 ? void 0 : removeProfileIds.forEach((pId) => {
      const existingMember = profiles.find((p2) => uuidEqual(pId, p2.profileId));
      if (existingMember === null || existingMember === void 0 ? void 0 : existingMember.isAdmin) {
        removedAdminProfileIds.push(pId);
      }
    });
    let createProfileDtos = [];
    if (createFreeProfiles === null || createFreeProfiles === void 0 ? void 0 : createFreeProfiles.length) {
      createProfileDtos = createFreeProfiles.flatMap((p2) => {
        const unsyncedProfile = UnsyncedProfile.create(ProfileType.ORGANIZATION, orgId, []);
        const personalVaultDto = UnsyncedVault.create(VaultType.ORGANIZATION_PERSONAL, superUserVaultMemberIds, [], adminAuthenticator, unsyncedProfile, adminProfile, orgId, organizationPersonalVaultContentDescriptor, null).getCreationDto();
        const legacyAdminVaultLock = void 0;
        const adminProfileLock = p2.isAdmin ? adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(unsyncedProfile) : void 0;
        return {
          userId: null,
          email: p2.email,
          isAdmin: p2.isAdmin,
          createStartCodeAndSendMail: p2.createStartCodeAndSendMail,
          profileDto: unsyncedProfile.serialize(),
          unsyncedProfile,
          personalVaultDto,
          legacyAdminVaultLock,
          adminProfileLock
        };
      });
      addedAdminUnsyncedProfiles = createProfileDtos ? createProfileDtos.filter(({ isAdmin }) => isAdmin).map((dto) => dto.unsyncedProfile) : [];
    }
    let selfDemotion = false;
    let updateProfileDtos;
    if (updateProfiles) {
      const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], updateProfiles.map(({ id: id2 }) => id2), []);
      updateProfileDtos = updateProfiles.map(({ id: profileId, isAdmin }) => {
        let adminProfileLock;
        const existingProfile = profiles.find((m2) => uuidEqual(profileId, m2.profileId));
        if (isAdmin !== void 0 && isAdmin !== (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.isAdmin)) {
          if (isAdmin) {
            addedAdminProfileIds.push(profileId);
            adminProfileLock = adminHsup === null || adminHsup === void 0 ? void 0 : adminHsup.createProfileLock(profilesById[profileId]);
          } else if (existingProfile === null || existingProfile === void 0 ? void 0 : existingProfile.isAdmin) {
            if (profileId === orgProfile.profile.id) {
              selfDemotion = true;
            }
            removedAdminProfileIds.push(profileId);
          }
        }
        return { profileId, isAdmin, adminProfileLock };
      });
    }
    if (selfDemotion) {
      const tvps = ccs.vaultRepo.getOrganizationTeamVaultPairs(orgId);
      for (const tvp of tvps) {
        if (getTeamMetaVaultInfo(tvp.meta.getContent()).isSyncOrganizationMembers) {
          ccs = internalTeamSetUserPermissionLevels(ccs, tvp.login.id, {
            profileId: orgProfile.profile.id,
            permissionLevel: TEAM_USER_DEFAULT_PERMISSION_LEVEL
          });
        }
      }
    }
    let regeneratedVaultDto;
    if (removedAdminProfileIds.length || addedAdminProfileIds.length || addedAdminUnsyncedProfiles.length) {
      if (!org.adminInfo) {
        throw new NoOrganizationAdminError();
      }
      if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId !== nullUuid) {
        const adminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
        if (!adminVault) {
          throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
        }
        const adminProfileIdSet = /* @__PURE__ */ new Set([...adminVault.profileIds, ...addedAdminProfileIds]);
        for (const pId of removedAdminProfileIds) {
          adminProfileIdSet.delete(pId);
        }
        const adminProfileIds = [...adminProfileIdSet];
        const { authenticatorsByUser, profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], adminProfileIds, []);
        const oldProtectedSecret = (_a2 = ccs.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.protectedSecrets[adminVault.id];
        if (!oldProtectedSecret) {
          throw new CannotUnprotectError();
        }
        const regenerateData = regenerateVaultForUsers(adminVault, authenticatorsByUser, profilesById, [], adminProfileIds, [], addedAdminUnsyncedProfiles, oldProtectedSecret.protectedSecret, oldProtectedSecret.messagePrivateKey);
        regeneratedVaultDto = regenerateData.regeneratedVaultDto;
        createProfileDtos === null || createProfileDtos === void 0 ? void 0 : createProfileDtos.filter(({ isAdmin }) => isAdmin).forEach((dto, i) => {
          dto.legacyAdminVaultLock = regenerateData.newProfileLockDtos[i];
        });
      }
    }
    const syncUpdate = yield ccs.backendClient.organization.modifyMembers(orgId, createProfileDtos !== null && createProfileDtos !== void 0 ? createProfileDtos : [], updateProfileDtos !== null && updateProfileDtos !== void 0 ? updateProfileDtos : [], removeProfileIds !== null && removeProfileIds !== void 0 ? removeProfileIds : [], regeneratedVaultDto);
    ccs.ephemeralOperationState = void 0;
    if (fullSyncRequired) {
      ccs.syncVersion = null;
      ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
    }
    ccs = yield onlineInternalSync(ccs, syncUpdate);
    ccs = yield onlineInternalMaintainTeamSyncOrganizationMembers(ccs, true);
    return ccs;
  });
}
var __awaiter$n = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$b = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalOrganizationRegenerateAdminProfile(inputCcs, orgId) {
  return __awaiter$n(this, void 0, void 0, function* () {
    return performWithOrgAllVaultsSyncPredicate(inputCcs, orgId, (_a2) => __awaiter$n(this, void 0, void 0, function* () {
      var ccs = __rest$b(_a2, []);
      const org = ccs.accountState.getOrganization(orgId);
      const orgProfile = ccs.profileRepo.getOrganizationProfile(orgId);
      const { vaultRepo, protectedSecretRepo } = ccs;
      if (!org || !org.adminInfo || !orgProfile || !protectedSecretRepo) {
        return ccs;
      }
      const adminProfileIds = org.profiles.flatMap((p2) => p2.isAdmin ? p2.profileId : []);
      const { profilesById } = yield onlineInternalGetUsers(ccs.backendClient, [], adminProfileIds, [], org.id);
      const lockingProfiles = adminProfileIds.map((adminProfileId) => profilesById[adminProfileId]);
      lockingProfiles.push(orgProfile.profile);
      const { unsyncedProfile: adminProfile } = UnsyncedProfile.createWithSeed(ProfileType.ORGANIZATION_ADMIN, orgId, [], lockingProfiles);
      const vaultLocks = vaultRepo.getAllVaultsByOrganizationId(orgId).map((v2) => ({
        vaultId: v2.id,
        generationId: v2.generationId,
        lock: protectedSecretRepo.createProfileLock(v2, adminProfile)
      }));
      let adminVaultCreationData;
      if (!ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id)) {
        const adminVault = UnsyncedVault.create(VaultType.ORGANIZATION_ADMIN, [], [], [], null, adminProfile, org.id, organizationAdminVaultContentDescriptor, null);
        adminVaultCreationData = adminVault.getCreationDto();
      }
      const previousAdminProfile = ccs.profileRepo.getOrgAdminProfile(org.id);
      const syncUpdate = yield ccs.backendClient.organization.regenerateAdmin(orgId, {
        profile: adminProfile.serialize(previousAdminProfile === null || previousAdminProfile === void 0 ? void 0 : previousAdminProfile.profile.id, previousAdminProfile === null || previousAdminProfile === void 0 ? void 0 : previousAdminProfile.profile.keyGenerationId),
        vaultLocks,
        // Organization admin profiles currently never lock any downstream profiles
        downstreamProfileLocks: []
      }, adminVaultCreationData);
      return onlineInternalSync(ccs, syncUpdate);
    }));
  });
}
function performWithOrgAllVaultsSyncPredicate(ccs, orgId, operation) {
  var _a2;
  return __awaiter$n(this, void 0, void 0, function* () {
    const originalForeignVaultSyncPredicate = ccs.ephemeralForeignVaultSyncPredicate;
    ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [
      orgId,
      ...(_a2 = ccs.ephemeralForeignVaultSyncPredicate.organizationAllVaults) !== null && _a2 !== void 0 ? _a2 : []
    ] });
    const originalBackendClient = ccs.backendClient;
    ccs.syncVersion = null;
    ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
    ccs = yield onlineInternalSync(ccs);
    ccs = yield operation(ccs);
    ccs.syncVersion = null;
    ccs.backendClient = originalBackendClient.withSyncVersion(void 0);
    ccs.ephemeralForeignVaultSyncPredicate = originalForeignVaultSyncPredicate;
    return onlineInternalSync(ccs);
  });
}
var __awaiter$m = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$a = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalOrganizationRestoreUnsafeVaultContents(_a2, organizationId) {
  var ccs = __rest$a(_a2, []);
  return __awaiter$m(this, void 0, void 0, function* () {
    const oldEFVSP = ccs.ephemeralForeignVaultSyncPredicate;
    const oldBackendClient = ccs.backendClient;
    ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [organizationId] });
    ccs.syncVersion = null;
    ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
    ccs = yield onlineInternalSync(ccs);
    if (!ccs.protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const org = ccs.accountState.getOrganization(organizationId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    if (!org.isAdmin || !org.adminInfo) {
      throw new NoOrganizationAdminError();
    }
    if (org.adminInfo.licenseType !== LicenseType.EXAMPLE) {
      throw new Error("Tried to restore organization vault contents for non-example organization. This feature may only be used for demo purposes.");
    }
    let storedVaultContents;
    if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId != nullUuid) {
      const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
      if (!legacyAdminVault) {
        throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
      }
      storedVaultContents = getLegacyOrganizationAdminVaultInfo(legacyAdminVault.getContent()).unsafeStoredVaultContents;
    } else {
      const adminVault = ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id);
      if (!adminVault) {
        throw new Error("Organization has no admin vault! This should never happen.");
      }
      storedVaultContents = getOrganizationAdminVaultInfo(adminVault.getContent()).unsafeStoredVaultContents;
    }
    for (const [vaultId, storedContent] of Object.entries(storedVaultContents !== null && storedVaultContents !== void 0 ? storedVaultContents : {})) {
      const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
      if (!vault) {
        continue;
      }
      const { protect: protect2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(vault);
      const storedActiveLoginIds = Object.keys(storedContent.logins);
      const storedArchivedLoginIds = Object.keys(storedContent.archivedLogins);
      const allStoredLoginIds = [...storedActiveLoginIds, ...storedArchivedLoginIds];
      const activeLoginIds = Object.keys(vault.getContent().logins);
      const archivedLoginIds = Object.keys(vault.getArchivedContent().logins);
      const deleteLoginIds = activeLoginIds.filter((lid) => !allStoredLoginIds.includes(lid));
      const deleteArchivedLoginIds = archivedLoginIds.filter((lid) => !allStoredLoginIds.includes(lid));
      const keptArchivedLoginIds = archivedLoginIds.filter((lid) => allStoredLoginIds.includes(lid));
      ccs = modifyLoginVault(ccs, vault, (c2, t2, { deleteLoginInternal: deleteLoginInternal2, restoreArchivedLoginInternal: restoreArchivedLoginInternal2, addOrModifyLoginInternal: addOrModifyLoginInternal2, archiveLoginInternal: archiveLoginInternal2 }) => {
        let newVaultContent = c2;
        for (const lid of [...deleteLoginIds, ...deleteArchivedLoginIds]) {
          ({ newVaultContent } = deleteLoginInternal2(newVaultContent, t2, lid));
        }
        for (const lid of keptArchivedLoginIds) {
          ({ newVaultContent } = restoreArchivedLoginInternal2(newVaultContent, t2, lid));
        }
        for (const [id2, login] of Object.entries(storedContent.logins)) {
          ({ newVaultContent } = addOrModifyLoginInternal2(newVaultContent, t2, id2, recursivelyTransformUnprotectedValues(login, protect2)));
        }
        for (const [id2, login] of Object.entries(storedContent.archivedLogins)) {
          ({ newVaultContent } = addOrModifyLoginInternal2(newVaultContent, t2, id2, recursivelyTransformUnprotectedValues(login, protect2)));
          ({ newVaultContent } = archiveLoginInternal2(newVaultContent, t2, id2));
        }
        return { result: void 0, auditlogEvents: [], newVaultContent };
      });
    }
    ccs = yield onlineInternalSync(ccs);
    ccs.ephemeralForeignVaultSyncPredicate = oldEFVSP;
    ccs.syncVersion = null;
    ccs.backendClient = oldBackendClient.withSyncVersion(void 0);
    return onlineInternalSync(ccs);
  });
}
var __awaiter$l = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$9 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalOrganizationStoreUnsafeVaultContents(_a2, organizationId) {
  var ccs = __rest$9(_a2, []);
  return __awaiter$l(this, void 0, void 0, function* () {
    const oldEFVSP = ccs.ephemeralForeignVaultSyncPredicate;
    const oldBackendClient = ccs.backendClient;
    ccs.ephemeralForeignVaultSyncPredicate = Object.assign(Object.assign({}, ccs.ephemeralForeignVaultSyncPredicate), { organizationAllVaults: [organizationId] });
    ccs.syncVersion = null;
    ccs.backendClient = ccs.backendClient.withSyncVersion(void 0).withSyncSuperUsers(true);
    ccs = yield onlineInternalSync(ccs);
    if (!ccs.protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const org = ccs.accountState.getOrganization(organizationId);
    if (!org) {
      throw new OrganizationNotFoundError();
    }
    if (!(org === null || org === void 0 ? void 0 : org.isAdmin) || !org.adminInfo) {
      throw new NoOrganizationAdminError();
    }
    if (org.adminInfo.licenseType !== LicenseType.EXAMPLE) {
      throw new Error("Tried to unsafely store organization vault contents for non-example organization. This feature may only be used for demo purposes.");
    }
    const orgLoginVaultPairs = ccs.vaultRepo.getOrganizationLoginVaultPairs(organizationId, {
      includeForeignOrganizationPersonalVaults: true,
      includeForeignTeamVaults: true
    });
    const vaultContents = {};
    for (const { login: loginVault } of orgLoginVaultPairs) {
      const { unprotectWithContentId: unprotectWithContentId2 } = ccs.protectedSecretRepo.getProtectedSecretFunctions(loginVault);
      const logins = {};
      for (const [id2, login] of Object.entries(loginVault.getContent().logins)) {
        logins[id2] = recursivelyTransformProtectedValues(login, unprotectWithContentId2);
      }
      const archivedLogins = {};
      for (const [id2, login] of Object.entries(loginVault.getArchivedContent().logins)) {
        archivedLogins[id2] = recursivelyTransformProtectedValues(login, unprotectWithContentId2);
      }
      vaultContents[loginVault.id] = { logins, archivedLogins };
    }
    if (org.adminInfo.legacyAdminVaultId && org.adminInfo.legacyAdminVaultId != nullUuid) {
      const legacyAdminVault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(org.adminInfo.legacyAdminVaultId);
      if (!legacyAdminVault) {
        throw new VaultNotFoundError(org.adminInfo.legacyAdminVaultId);
      }
      ccs = modifyVault(ccs, legacyAdminVault, (c2, t2, { modifyLegacyOrganizationAdminVaultInfo: modifyLegacyOrganizationAdminVaultInfo2 }) => modifyLegacyOrganizationAdminVaultInfo2(c2, t2, {
        unsafeStoredVaultContents: vaultContents
      }));
    } else {
      const adminVault = ccs.vaultRepo.getOrganizationAdminVaultByOrganizationId(org.id);
      if (!adminVault) {
        throw new Error("Organization has no admin vault! This should never happen.");
      }
      ccs = modifyVault(ccs, adminVault, (c2, t2, { modifyOrganizationAdminVaultInfo: modifyOrganizationAdminVaultInfo2 }) => modifyOrganizationAdminVaultInfo2(c2, t2, { unsafeStoredVaultContents: vaultContents }));
    }
    ccs = yield onlineInternalSync(ccs);
    ccs.ephemeralForeignVaultSyncPredicate = oldEFVSP;
    ccs.syncVersion = null;
    ccs.backendClient = oldBackendClient.withSyncVersion(void 0);
    return onlineInternalSync(ccs);
  });
}
var __awaiter$k = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$8 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalProfileCreatePrivate(_a2, email) {
  var ccs = __rest$8(_a2, []);
  return __awaiter$k(this, void 0, void 0, function* () {
    const { protectedSecretRepo } = ccs;
    if (!protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const privateProfile = UnsyncedProfile.create(ProfileType.PRIVATE, null, ccs.accountState.authenticators);
    const privateVault = UnsyncedVault.create(VaultType.PRIVATE, [], [], [], privateProfile, null, null, loginVaultContentDescriptor, null);
    const { privateProfileId, syncUpdate } = yield ccs.backendClient.profile.createPrivate(email, privateProfile.serialize(), privateVault.getCreationDto());
    ccs = yield onlineInternalSync(ccs, syncUpdate);
    ccs = yield onlineInternalSessionSetProfileEnabled(ccs, privateProfileId, true);
    return ccs;
  });
}
var __awaiter$j = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$7 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalProfileDeletePrivate(_a2, privateProfileId) {
  var ccs = __rest$7(_a2, []);
  return __awaiter$j(this, void 0, void 0, function* () {
    const syncUpdate = yield ccs.backendClient.profile.deletePrivate(privateProfileId);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
var __awaiter$i = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$6 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalProfileRegenerate(_a2, hsc) {
  var ccs = __rest$6(_a2, []);
  return __awaiter$i(this, void 0, void 0, function* () {
    const { protectedSecretRepo } = ccs;
    if (!protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const { regeneratedProfiles } = regenerateProfiles(hsc, protectedSecretRepo, ccs.vaultRepo, ccs.profileRepo, ccs.accountState.authenticators, []);
    const syncUpdate = yield ccs.backendClient.profile.regenerate(regeneratedProfiles);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
function createUnsyncedRecoveryAuthenticator(seed, recoveryParameters) {
  if (seed.byteLength !== 32) {
    throw new InvalidAuthenticatorSeedLengthError();
  }
  const checksum = naclUtilExports.encodeBase64(hashData(seed));
  const secretInfo = { checksum, recoveryParameters };
  return UnsyncedAuthenticator.create(AuthenticatorType.BACKUP_CODE, JSON.stringify(secretInfo), {
    seed
  });
}
function createUnsyncedBackupAuthenticator(seed) {
  if (seed.byteLength !== 32) {
    throw new InvalidAuthenticatorSeedLengthError();
  }
  return UnsyncedAuthenticator.create(AuthenticatorType.BACKUP_OS, "", { seed });
}
var __awaiter$h = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$5 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalRegenerateBackup(_a2, backupAuthSeed, hsc) {
  var ccs = __rest$5(_a2, []);
  return __awaiter$h(this, void 0, void 0, function* () {
    ccs = yield onlineInternalSync(ccs);
    const unsyncedAuthenticator = createUnsyncedBackupAuthenticator(backupAuthSeed);
    const previousAuth = ccs.accountState.authenticators.find((a2) => a2.authenticatorType === AuthenticatorType.BACKUP_OS);
    const result = yield onlineInternalModifyAuthenticators(ccs, hsc, previousAuth ? [previousAuth.id] : [], [unsyncedAuthenticator]);
    if (!result.returnResult.length) {
      throw new NoAuthenticatorIdReceivedError();
    }
    return Object.assign(Object.assign({}, result), { returnResult: result.returnResult[0] });
  });
}
var __awaiter$g = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$4 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
const BACKUP_CODE_PATTERN = /\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d-\d\d\d\d/;
function onlineInternalRegenerateRecovery(_a2, backupCode, recoverySeed, recoveryParameters, hsc) {
  var ccs = __rest$4(_a2, []);
  return __awaiter$g(this, void 0, void 0, function* () {
    if (!BACKUP_CODE_PATTERN.test(backupCode)) {
      throw new Error("received incorrectly formatted backup code");
    }
    ccs = yield onlineInternalSync(ccs);
    const metaVault = ccs.vaultRepo.getMetaVault();
    if (!metaVault) {
      throw new MetaVaultNotFoundError();
    }
    ccs = modifyVault(ccs, metaVault, (c2, t2, { protect: protect2, modifyAccountSettings: modifyAccountSettings2 }) => modifyAccountSettings2(c2, t2, {
      backupCode: protect2({ contentId: newUuid$1(), unencrypted: backupCode })
    }), true, hsc);
    ccs.accountState = ccs.accountState.withLocalAchievements([
      Achievement.COR_STORE_BACKUP_CODE_META_VAULT
    ]);
    const unsyncedAuthenticator = createUnsyncedRecoveryAuthenticator(recoverySeed, recoveryParameters);
    const previousAuth = ccs.accountState.authenticators.find((a2) => a2.authenticatorType === AuthenticatorType.BACKUP_CODE);
    const result = yield onlineInternalModifyAuthenticators(ccs, hsc, previousAuth ? [previousAuth.id] : [], [unsyncedAuthenticator]);
    if (!result.returnResult.length) {
      throw new NoAuthenticatorIdReceivedError();
    }
    return Object.assign(Object.assign({}, result), { returnResult: result.returnResult[0] });
  });
}
var __awaiter$f = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalRegenerateVault(ccs, hsc, vaultId) {
  return __awaiter$f(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getVaultById(vaultId);
    const vaultAccess = getVaultAccess(ccs, hsc, vault);
    if (!vaultAccess) {
      throw new ClientCoreIsLockedError();
    }
    const regeneratedVault = yield onlineInternalCreateRegeneratedVault(ccs, vault, vaultAccess);
    const backendClient = getBackendClientForVault(ccs, vault);
    const { syncUpdate } = yield backendClient.vault.createGeneration(regeneratedVault);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
var __awaiter$e = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$3 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalTeamCreate(_a2, name, organizationId) {
  var _b, _c2, _d, _e;
  var ccs = __rest$3(_a2, []);
  return __awaiter$e(this, void 0, void 0, function* () {
    const profile = organizationId ? (_b = ccs.profileRepo.getOrganizationProfile(organizationId)) === null || _b === void 0 ? void 0 : _b.profile : (_c2 = ccs.profileRepo.getPrivateProfile()) === null || _c2 === void 0 ? void 0 : _c2.profile;
    if (!profile) {
      throw new ClientCoreInternalError("no organization or private profile found to create team");
    }
    const { unsyncedTeamVault, unsyncedTeamMetaVault } = yield onlineInternalMakeUnsyncedTeamVaults(ccs, name, organizationId, profile, false);
    const { vaultId: teamVaultId, associatedVaultId: teamMetaVaultId, syncUpdate } = yield ccs.backendClient.vault.createTeam({
      blob: unsyncedTeamVault.getCommitBlob(),
      locks: unsyncedTeamVault.getAuthenticatorLockDtos(),
      profileLock: unsyncedTeamVault.getProfileLockDto(),
      adminProfileLock: unsyncedTeamVault.getAdminProfileLockDto(),
      messagePublicKey: (_d = unsyncedTeamVault.messageKeyPair) === null || _d === void 0 ? void 0 : _d.encPubKey,
      associatedBlob: unsyncedTeamMetaVault.getCommitBlob(),
      associatedLocks: unsyncedTeamMetaVault.getAuthenticatorLockDtos(),
      associatedProfileLock: unsyncedTeamMetaVault.getProfileLockDto(),
      associatedAdminProfileLock: unsyncedTeamMetaVault.getAdminProfileLockDto(),
      associatedMessagePublicKey: (_e = unsyncedTeamMetaVault.messageKeyPair) === null || _e === void 0 ? void 0 : _e.encPubKey,
      organizationId
    });
    ccs = addUnsyncedVaultAfterCreate(ccs, syncUpdate, teamVaultId, teamMetaVaultId, organizationId !== null && organizationId !== void 0 ? organizationId : null, unsyncedTeamVault);
    ccs = addUnsyncedVaultAfterCreate(
      ccs,
      syncUpdate,
      // if we pass in an unsynced associated vault, we're also going to get back an id for it
      teamMetaVaultId,
      null,
      organizationId !== null && organizationId !== void 0 ? organizationId : null,
      unsyncedTeamMetaVault
    );
    ccs = yield onlineInternalSync(ccs, syncUpdate);
    return Object.assign(Object.assign({}, ccs), { returnResult: teamVaultId });
  });
}
var __awaiter$d = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$2 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function onlineInternalTeamDelete(_a2, vaultId) {
  var ccs = __rest$2(_a2, []);
  return __awaiter$d(this, void 0, void 0, function* () {
    const pair = ccs.vaultRepo.getTeamVaultPairById(vaultId);
    if (!pair) {
      throw new VaultNotFoundError(vaultId);
    }
    if (getLoggedInUserTeamPermissionLevel(ccs.accountState, pair.meta) !== PermissionLevel.admin) {
      throw new VaultPermissionDeniedError();
    }
    const { syncUpdate } = yield ccs.backendClient.vault.deleteTeam(vaultId);
    ccs = yield onlineInternalSync(ccs, syncUpdate);
    ccs = yield onlineInternalMaintainVaultMessages(ccs);
    return Object.assign({}, ccs);
  });
}
var __awaiter$c = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalTeamLeave(ccs, teamId) {
  return __awaiter$c(this, void 0, void 0, function* () {
    const pair = ccs.vaultRepo.getTeamVaultPairById(teamId);
    if (!pair) {
      throw new VaultNotFoundError(teamId);
    }
    const { login, meta } = pair;
    const joinedProfileId = login.getProfileId();
    if (!joinedProfileId) {
      throw new VaultNotFoundError(teamId);
    }
    const commitData = getUpdatedMetaVault(meta, joinedProfileId);
    const { syncUpdate } = yield ccs.backendClient.vault.modifyTeamUsers(teamId, login.generationId, [], joinedProfileId ? [joinedProfileId] : [], meta.generationId, commitData === null || commitData === void 0 ? void 0 : commitData.metaVaultCommitId, commitData === null || commitData === void 0 ? void 0 : commitData.blob, commitData === null || commitData === void 0 ? void 0 : commitData.latestUpdateTime);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
function getUpdatedMetaVault(metaVault, removeProfileId) {
  ({ vault: metaVault } = metaVault.withModification((c2, t2, { deleteTeamVaultUser: deleteTeamVaultUser2 }) => deleteTeamVaultUser2(c2, t2, removeProfileId)));
  const stagedData = metaVault.getStagedDiff(null);
  if (!stagedData) {
    return null;
  }
  const { stagingVault, diff, latestUpdateTime } = stagedData;
  const protoCommit = Commit.create(null, stagingVault.vaultSecret, diff);
  return {
    metaVaultCommitId: metaVault.commitId,
    blob: protoCommit.blob,
    latestUpdateTime: new Date(latestUpdateTime)
  };
}
var __awaiter$b = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalWebauthnDeleteCredentials(ccs, ids) {
  return __awaiter$b(this, void 0, void 0, function* () {
    const syncUpdate = yield ccs.backendClient.webauthn.deleteCredentials(ids);
    return onlineInternalSync(ccs, syncUpdate);
  });
}
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalWebauthnEnablePrf(ccs, { options }, cred) {
  var _a2, _b, _c2, _d;
  return __awaiter$a(this, void 0, void 0, function* () {
    if (!cred.prfExtensionResult) {
      throw new PrfNotSupportedError();
    }
    const syncUpdate = yield ccs.backendClient.sync.poll();
    if (!syncUpdate.sessionUnlock) {
      throw new ClientCoreIsLockedError();
    }
    const seed = deriveSecretFromSeed(new Uint8Array(cred.prfExtensionResult.first), null, SALT_AUTHENTICATOR_WEBAUTHN_SEED);
    const webauthnCred = ccs.accountState.webauthnCredentials.find((wc2) => cred.id === wc2.webauthnId);
    if (!webauthnCred) {
      throw new PrfInitError();
    }
    const prfInputs = (_b = (_a2 = options.publicKey) === null || _a2 === void 0 ? void 0 : _a2.extensions) === null || _b === void 0 ? void 0 : _b.prf;
    const prfSalt = (_d = (_c2 = prfInputs === null || prfInputs === void 0 ? void 0 : prfInputs.evalByCredential) === null || _c2 === void 0 ? void 0 : _c2[cred.id]) === null || _d === void 0 ? void 0 : _d.first;
    if (!prfSalt) {
      throw new PrfInitError();
    }
    const ua2 = UnsyncedAuthenticator.createWebauthn({ seed }, { webauthnId: webauthnCred.webauthnId, prfSalt: new Uint8Array(prfSalt) });
    const hsc = HighSecurityCache.fromSessionUnlock(syncUpdate.sessionUnlock, ccs.params.sessionKeys.encPrivKey, ccs.accountState.authenticators);
    return onlineInternalModifyAuthenticators(ccs, hsc, [], [ua2]);
  });
}
function unmarshalCredentialCreationOptions(optionsJson) {
  const options = JSON.parse(optionsJson);
  options.publicKey.challenge = decodeBase64Urlsafe(options.publicKey.challenge);
  options.publicKey.user.id = decodeBase64Urlsafe(options.publicKey.user.id);
  if (options.publicKey.excludeCredentials) {
    options.publicKey.excludeCredentials.forEach((cred) => {
      cred.id = decodeBase64Urlsafe(cred.id);
    });
  }
  return options;
}
function unmarshalCredentialRequestOptions(optionsJson) {
  const options = JSON.parse(optionsJson);
  options.publicKey.challenge = decodeBase64Urlsafe(options.publicKey.challenge);
  options.publicKey.allowCredentials.forEach((cred) => {
    cred.id = decodeBase64Urlsafe(cred.id);
  });
  return options;
}
function marshalAssertionPublicKeyCredential(cred) {
  return JSON.stringify({
    id: cred.id,
    rawId: encodeBase64Urlsafe(cred.rawId),
    type: "public-key",
    response: {
      authenticatorData: encodeBase64Urlsafe(cred.response.authenticatorData),
      clientDataJSON: encodeBase64Urlsafe(cred.response.clientDataJSON),
      signature: encodeBase64Urlsafe(cred.response.signature),
      userHandle: cred.response.userHandle ? encodeBase64Urlsafe(cred.response.userHandle) : void 0
    }
  });
}
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalWebauthnRegisterCredentialInit(ccs, type) {
  return __awaiter$9(this, void 0, void 0, function* () {
    const { requestId, optionsJson } = yield ccs.backendClient.webauthn.registerCredentialInit(type);
    const options = unmarshalCredentialCreationOptions(optionsJson);
    const prfSalt = { first: randomSeed() };
    options.publicKey.extensions = Object.assign(Object.assign({}, options.publicKey.extensions), { prf: { eval: prfSalt } });
    debugConsole.info("webauthn.create options", options);
    return Object.assign(Object.assign({}, ccs), { returnResult: { requestId, options, prfSalt } });
  });
}
function onlineInternalWebauthnRegisterCredentialFinish(ccs, requestId, cred) {
  return __awaiter$9(this, void 0, void 0, function* () {
    const credJson = marshalAttestationPublicKeyCredential(cred);
    const su2 = yield ccs.backendClient.webauthn.registerCredentialFinish(requestId, credJson, cred.prfSupportStatus);
    return onlineInternalSync(ccs, su2);
  });
}
function marshalAttestationPublicKeyCredential(cred) {
  return JSON.stringify({
    id: cred.id,
    rawId: encodeBase64Urlsafe(cred.rawId),
    type: "public-key",
    response: {
      attestationObject: encodeBase64Urlsafe(cred.response.attestationObject),
      clientDataJSON: encodeBase64Urlsafe(cred.response.clientDataJSON),
      transports: cred.response.transports
    }
  });
}
function getUnlockTime() {
  const date2 = new Date((/* @__PURE__ */ new Date()).getTime() + 864e5);
  date2.setHours(2, 0, 0, 0);
  return date2;
}
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function onlineInternalWebauthnUnlockSessionInit(ccs) {
  return __awaiter$8(this, void 0, void 0, function* () {
    const { requestId, optionsJson } = yield ccs.backendClient.webauthn.unlockSessionInit();
    const options = unmarshalCredentialRequestOptions(optionsJson);
    const evalByCredential = {};
    for (const a2 of options.publicKey.allowCredentials) {
      evalByCredential[encodeBase64Urlsafe(a2.id)] = {
        first: randomSeed()
      };
    }
    options.publicKey.extensions = Object.assign(Object.assign({}, options.publicKey.extensions), { prf: { evalByCredential } });
    debugConsole.info("webauthn.get options", options);
    return Object.assign(Object.assign({}, ccs), { returnResult: { requestId, options } });
  });
}
function onlineInternalWebauthnUnlockSessionFinish(ccs, requestId, cred) {
  return __awaiter$8(this, void 0, void 0, function* () {
    const responseJson = marshalAssertionPublicKeyCredential(cred);
    const syncUpdate = yield ccs.backendClient.webauthn.unlockSessionFinish(requestId, responseJson, getUnlockTime());
    return onlineInternalSync(ccs, syncUpdate);
  });
}
function completeLongPollChannelReply(publicKeyB64, authenticatorSeed, registration) {
  const publicKey = loadEncryptionPublicKey(publicKeyB64);
  const publicKeyHash = naclUtilExports.encodeBase64(hashData(publicKey));
  const authReply = createEncryptedSecretAuthenticatorReply({
    encryptedSecret: asymEncrypt(publicKey, authenticatorSeed),
    registration
  });
  return { publicKeyHash, authReply };
}
const SALT_SESSION_ENCRYPTION_KEY = "salt-session-encryption-key-";
const SALT_SESSION_ENCRYPTION_KEY_SIGNATURE$1 = "salt-session-encryption-key-signature-";
function createUnsignedSessionKeys() {
  const secret = randomSeed();
  return deriveEncryptionKeyPair(secret, null, SALT_SESSION_ENCRYPTION_KEY);
}
class SessionKeys {
  constructor(encPrivKey, encPubKey, encPubKeySignature, signingAuthId) {
    this.encPrivKey = encPrivKey;
    this.encPubKey = encPubKey;
    this.encPubKeySignature = encPubKeySignature;
    this.signingAuthId = signingAuthId;
  }
  static createFromUnsigned(usk, ua2) {
    const { encPrivKey, encPubKey } = usk;
    const encPubKeySignature = signEncryptionPublicKey(ua2.highSecurityIdentitySigPrivKey, encPubKey, SALT_SESSION_ENCRYPTION_KEY_SIGNATURE$1);
    return new SessionKeys(encPrivKey, encPubKey, encPubKeySignature, ua2.authenticator.id);
  }
  static create(ua2) {
    return SessionKeys.createFromUnsigned(createUnsignedSessionKeys(), ua2);
  }
}
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function finishChallengeSelfUnlocking({ client, hsua, challenge, userId, sessionType }) {
  return __awaiter$7(this, void 0, void 0, function* () {
    const unsignedSessionKeys = createUnsignedSessionKeys();
    const response = signString(hsua.highSecurityLoginSigPrivKey, challenge, null);
    const { loginData } = yield client.credential.createTokens(userId, hsua.authenticator.id, challenge, response, null, sessionType);
    const { authenticators } = yield client.withLogin(loginData).authenticator.list();
    const authenticatorDto = authenticators.find((a2) => a2.id === hsua.authenticator.id);
    if (!authenticatorDto) {
      throw new AuthenticatorNotFoundError();
    }
    const sessionKeys = SessionKeys.createFromUnsigned(unsignedSessionKeys, hsua);
    const clientCoreParameters = {
      loginData,
      unlockedAuthenticator: hsua.getUnlockedAuthenticator(),
      sessionKeys
    };
    return clientCoreParameters;
  });
}
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class LoginFlowPushAuthenticator {
  constructor(channelId, authenticatorId, backend, sharedSecret, isCancelled = false) {
    this.channelId = channelId;
    this.authenticatorId = authenticatorId;
    this.backend = backend;
    this.sharedSecret = sharedSecret;
    this.isCancelled = isCancelled;
  }
  static create(channelId, authenticatorId, backend) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const keyPair = newSharedSecretKeyPair();
      const hashCommitment = yield backend.channel.loginChannelClaimAndReceiveHashCommitment(channelId, authenticatorId, keyPair.sharedPubKey);
      const clientPubKey = yield backend.channel.loginChannelReceiveClientPubKey(channelId);
      if (!verifyHash(hashCommitment, clientPubKey)) {
        throw new InvalidHashCommitmentError();
      }
      const sharedSecret = combineSharedSecret(keyPair.sharedPrivKey, clientPubKey, "push-login");
      const flow = new LoginFlowPushAuthenticator(channelId, authenticatorId, backend, sharedSecret);
      return flow;
    });
  }
  cancel() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.backend.channel.loginChannelClose(this.channelId);
      this.isCancelled = true;
    });
  }
  getSas() {
    if (this.isCancelled) {
      throw new LoginCancelledError();
    }
    return symKeyToSas(this.sharedSecret);
  }
  sendEncryptedSecret(secret) {
    return __awaiter$6(this, void 0, void 0, function* () {
      if (this.isCancelled) {
        throw new LoginCancelledError();
      }
      const encryptedSecret = symEncrypt(this.sharedSecret, secret);
      yield this.backend.channel.loginChannelSendEncryptedSecret(this.channelId, encryptedSecret, this.authenticatorId);
    });
  }
  waitForClose() {
    return __awaiter$6(this, void 0, void 0, function* () {
      yield this.backend.channel.loginChannelWaitUntilClosed(this.channelId);
    });
  }
}
function checkEncPubKeySignature(trustedSigPubKeys, encPubKey, encPubKeySignature, salt) {
  if (!trustedSigPubKeys.some((sigPubKey) => verifySignedEncryptionPublicKey(sigPubKey, encPubKey, loadEncryptionPublicKeySignature(encPubKeySignature), salt))) {
    throw new NoMatchingSigningKeyFoundError();
  }
}
class OrganizationAuthTokenCache {
  constructor(cache2 = {}) {
    this.cache = cache2;
  }
  isEmpty() {
    return Object.values(this.cache).length === 0;
  }
  getToken(orgId) {
    const entry = this.cache[orgId];
    if (!entry || entry.expiresAt < /* @__PURE__ */ new Date()) {
      return null;
    }
    return entry.token;
  }
  withToken(orgId, token, expiresAt) {
    return new OrganizationAuthTokenCache(Object.assign(Object.assign({}, this.cache), { [orgId]: { expiresAt, token } }));
  }
}
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest$1 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
function mergeLoginWebsites(websites, websiteAttributes, unnormalizedWebsite) {
  const normalizedWebsite = normalizeWebsitePattern(unnormalizedWebsite);
  const websiteHost = new URL(`https://${unnormalizedWebsite}`).host;
  if (websites.find((w2) => new URL(`https://${w2}`).host === websiteHost)) {
    return { websites, websiteAttributes };
  }
  return {
    websites: [...websites, normalizedWebsite],
    websiteAttributes: Object.assign(Object.assign({}, websiteAttributes), { [normalizedWebsite]: Object.assign(Object.assign({}, websiteAttributes === null || websiteAttributes === void 0 ? void 0 : websiteAttributes[normalizedWebsite]), getWebsiteAttributesEntry(unnormalizedWebsite)) })
  };
}
function mergeLoginAndroidApps(androidApps, androidApp) {
  const androidAppWithId = Object.assign({ id: newUuid$1() }, androidApp);
  if (!androidApps) {
    return androidApp ? [androidAppWithId] : [];
  }
  const existingAppIndex = androidApps.findIndex((a2) => a2.appId === androidApp.appId);
  if (existingAppIndex === -1) {
    return [...androidApps, androidAppWithId];
  }
  return [
    ...androidApps.slice(0, existingAppIndex),
    Object.assign(Object.assign({}, androidApps[existingAppIndex]), androidAppWithId),
    ...androidApps.slice(existingAppIndex + 1)
  ];
}
function ingestLoginUpdate(_a2, _b) {
  var ccs = __rest$1(_a2, []);
  var loginId = _b.loginId, vaultId = _b.vaultId, username = _b.username, password = _b.password, unnormalizedWebsite = _b.unnormalizedWebsite, androidApp = _b.androidApp;
  return __awaiter$5(this, void 0, void 0, function* () {
    const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    const { protectedSecretRepo } = ccs;
    if (!protectedSecretRepo) {
      throw new ClientCoreIsLockedError();
    }
    const existing = loginId ? vault.getContent().logins[loginId] : void 0;
    const unprotectedPassword = { contentId: newUuid$1(), unencrypted: password };
    if (loginId && existing) {
      const oldPassword = protectedSecretRepo.unprotectWithContentId(vault, existing.password);
      const newPassword = oldPassword.unencrypted === password ? oldPassword : unprotectedPassword;
      let modifiedLogin = {
        username: username !== null && username !== void 0 ? username : "",
        password: newPassword
      };
      if (unnormalizedWebsite) {
        modifiedLogin = Object.assign(Object.assign({}, modifiedLogin), mergeLoginWebsites(existing.websites, existing.websiteAttributes, unnormalizedWebsite.uri));
      }
      if (androidApp) {
        modifiedLogin = Object.assign(Object.assign({}, modifiedLogin), { androidApps: mergeLoginAndroidApps(existing.androidApps, androidApp) });
      }
      return Object.assign(Object.assign({}, yield modifyLogin(ccs, {
        vaultId,
        loginId,
        login: modifiedLogin,
        source: LoginSource.autosave
      })), { returnResult: loginId });
    }
    let websites = [];
    let websiteAttributes = {};
    if (unnormalizedWebsite === null || unnormalizedWebsite === void 0 ? void 0 : unnormalizedWebsite.uri) {
      const website = normalizeWebsitePattern(unnormalizedWebsite.uri);
      websiteAttributes = { [website]: getWebsiteAttributesEntry(unnormalizedWebsite === null || unnormalizedWebsite === void 0 ? void 0 : unnormalizedWebsite.uri) };
      websites = [website];
    }
    const androidApps = androidApp ? [Object.assign({ id: newUuid$1() }, androidApp)] : [];
    return addLogin(ccs, {
      vaultId,
      login: {
        uiType: LoginUiType.login,
        title: "",
        websites,
        websiteAttributes,
        androidApps,
        username: username !== null && username !== void 0 ? username : "",
        password: unprotectedPassword,
        note: "",
        customFields: []
      },
      source: LoginSource.autosave
    });
  });
}
class VaultRepo {
  constructor(vaults = []) {
    this.vaults = vaults;
  }
  static create(vaults = []) {
    return new VaultRepo(vaults);
  }
  static createFromPersistable(p2, profileRepo, superUserUnlockedAuthenticators = {}) {
    const vaults = p2.vaults.flatMap((pv) => {
      let vaultAccess = getDirectVaultAccess(profileRepo, null, pv);
      if (!vaultAccess && pv.organizationId && pv.adminProfileLock) {
        const unlockedProfile = profileRepo.getOrgAdminProfile(pv.organizationId);
        if (unlockedProfile) {
          vaultAccess = {
            type: "admin-profile",
            unlockedProfile,
            hsup: null,
            orgId: pv.organizationId
          };
        }
      }
      if (!vaultAccess && pv.organizationId && superUserUnlockedAuthenticators[pv.organizationId]) {
        vaultAccess = {
          type: "admin-authenticator",
          unlockedAuthenticator: superUserUnlockedAuthenticators[pv.organizationId],
          hsua: null,
          orgId: pv.organizationId
        };
      }
      if (!vaultAccess) {
        trackError(new Error(`Ignoring vault ${pv.id} from persistable. There is no matching unlocked authenticator.`));
        return [];
      }
      return [Vault.createFromPersistable(pv, vaultAccess)];
    });
    return new VaultRepo(vaults);
  }
  isInitialized() {
    const metaVault = this.getVaultByQuery({ descriptor: metaVaultContentDescriptor });
    return !!metaVault;
  }
  getPersistable(foreignVaultSyncPredicate) {
    return {
      vaults: this.vaults.flatMap((vault) => {
        const shouldPersistVault = vault.isUserJoined || checkForeignVaultSyncPredicate({ type: "vault", vault }, foreignVaultSyncPredicate);
        if (!shouldPersistVault) {
          return [];
        }
        return vault.getPersistable();
      })
    };
  }
  getAllVaults() {
    return this.vaults;
  }
  getAllVaultsByOrganizationId(organizationId) {
    return this.filterVaultsByQuery({ organizationId });
  }
  getForeignVaultsByOrganizationId(organizationId) {
    return this.filterVaultsByQuery({ organizationId, isUserJoined: false });
  }
  getAllVaultsByProfileId(profileId) {
    return this.filterVaultsByQuery({ profileId });
  }
  getVaultById(vaultId) {
    const vault = this.vaults.find((v2) => v2.id === vaultId);
    if (!vault) {
      throw new VaultNotFoundError(vaultId);
    }
    return vault;
  }
  vaultExits(vaultId) {
    return this.vaults.some((v2) => v2.id === vaultId);
  }
  getPrivateLoginVault() {
    const privateLoginVault = this.getVaultByQuery({
      descriptor: loginVaultContentDescriptor,
      vaultTypes: [VaultType.PRIVATE],
      isUserJoined: true
    });
    return privateLoginVault !== null && privateLoginVault !== void 0 ? privateLoginVault : null;
  }
  getPrivateLoginVaultPairs(excludeOrganizationIds) {
    return this.filterVaultsByQuery({
      descriptor: loginVaultContentDescriptor,
      isUserJoined: true,
      vaultTypes: [VaultType.PRIVATE, VaultType.TEAM]
    }).flatMap((l2) => {
      if (l2.organizationId && excludeOrganizationIds.includes(l2.organizationId)) {
        return [];
      }
      const pair = this.makeLoginVaultPair(l2);
      if (!pair) {
        return [];
      }
      return pair;
    });
  }
  getMetaVault() {
    return this.getVaultByQuery({
      descriptor: metaVaultContentDescriptor,
      isUserJoined: true
    });
  }
  getTeamVaultPairs() {
    return this.getTeamVaultPairsByQuery({
      isUserJoined: true
    });
  }
  getOrganizationTeamVaultPairs(organizationId) {
    return this.getTeamVaultPairsByQuery({ organizationId });
  }
  getOrganizationLoginVaultPairs(organizationId, { includeForeignOrganizationPersonalVaults = false, includeForeignTeamVaults = false } = {}) {
    return this.filterVaultsByQuery({
      descriptor: loginVaultContentDescriptor,
      isUserJoined: includeForeignTeamVaults ? void 0 : true,
      organizationId
    }, {
      descriptor: organizationPersonalVaultContentDescriptor,
      isUserJoined: includeForeignOrganizationPersonalVaults ? void 0 : true,
      organizationId
    }).flatMap((l2) => {
      const pair = this.makeLoginVaultPair(l2);
      if (!pair) {
        return [];
      }
      return pair;
    });
  }
  getLoginVaultPairs({ includeForeignOrganizationPersonalVaults = false, includeForeignTeamVaults = false } = {}) {
    return this.filterVaultsByQuery({
      descriptor: loginVaultContentDescriptor,
      isUserJoined: includeForeignTeamVaults ? void 0 : true
    }, {
      descriptor: organizationPersonalVaultContentDescriptor,
      isUserJoined: includeForeignOrganizationPersonalVaults ? void 0 : true
    }).flatMap((l2) => {
      const pair = this.makeLoginVaultPair(l2);
      if (!pair) {
        return [];
      }
      return pair;
    });
  }
  getTeamVaultPairById(vaultId) {
    const login = this.getLoginVaultById(vaultId);
    if (!login) {
      return null;
    }
    const meta = this.getTeamMetaVaultForTeamVault(login);
    if (!meta) {
      return null;
    }
    return { login, meta, type: VaultType.TEAM };
  }
  getLoginVaultById(vaultId) {
    return this.getVaultByQuery({ vaultId, descriptor: loginVaultContentDescriptor }, { vaultId, descriptor: organizationPersonalVaultContentDescriptor });
  }
  getLoginVaultPairById(vaultId) {
    const loginVault = this.getVaultByQuery({ vaultId, descriptor: loginVaultContentDescriptor }, { vaultId, descriptor: organizationPersonalVaultContentDescriptor });
    if (!loginVault) {
      return null;
    }
    return this.makeLoginVaultPair(loginVault);
  }
  getTeamMetaVaultById(vaultId) {
    return this.getVaultByQuery({
      vaultId,
      descriptor: teamMetaVaultContentDescriptor
    });
  }
  getLegacyOrganizationAdminVaults() {
    return this.filterVaultsByQuery({
      descriptor: legacyOrganizationAdminVaultContentDescriptor
    });
  }
  getLegacyOrganizationAdminVaultById(vaultId) {
    return this.getVaultByQuery({
      vaultId,
      descriptor: legacyOrganizationAdminVaultContentDescriptor
    });
  }
  getOrganizationAdminVaultByOrganizationId(organizationId) {
    return this.getVaultByQuery({
      organizationId,
      descriptor: organizationAdminVaultContentDescriptor
    });
  }
  getOrganizationPersonalLoginVault(organizationId) {
    return this.getVaultByQuery({
      organizationId,
      descriptor: organizationPersonalVaultContentDescriptor,
      isUserJoined: true
    });
  }
  getOrganizationAllPersonalLoginVaults(organizationId) {
    return this.filterVaultsByQuery({
      organizationId,
      descriptor: organizationPersonalVaultContentDescriptor
    });
  }
  getOrganizationPersonalLoginVaults() {
    return this.filterVaultsByQuery({
      descriptor: organizationPersonalVaultContentDescriptor,
      isUserJoined: true
    });
  }
  getOrganizationPersonalLoginVaultForUser(organizationId, userId) {
    return this.getVaultByQuery({
      organizationId,
      descriptor: organizationPersonalVaultContentDescriptor,
      userId
    });
  }
  getOrganizationPersonalLoginVaultForProfile(organizationId, profileId) {
    return this.getVaultByQuery({
      organizationId,
      descriptor: organizationPersonalVaultContentDescriptor,
      profileId
    });
  }
  getInboxVaults() {
    return this.filterVaultsByQuery({ vaultTypes: [VaultType.INBOX] });
  }
  getInboxVaultPairById(vaultId) {
    const login = this.getLoginVaultById(vaultId);
    if (!login) {
      return null;
    }
    const meta = this.getTeamMetaVaultForTeamVault(login);
    if (!meta) {
      return null;
    }
    return { login, meta, type: VaultType.INBOX };
  }
  withDeleteVault(vaultId) {
    const modifiedVaults = this.vaults.filter((vault) => !uuidEqual(vault.id, vaultId));
    if (modifiedVaults.length === this.vaults.length) {
      throw new VaultNotFoundError(vaultId);
    }
    return new VaultRepo(modifiedVaults);
  }
  withDeleteWithoutMatchingProfileLocks(profileIds) {
    const modifiedVaults = this.vaults.filter((vault) => {
      return !vault.profileLock || profileIds.includes(vault.profileLock.lockingProfileId);
    });
    if (modifiedVaults.length === this.vaults.length) {
      return this;
    }
    return new VaultRepo(modifiedVaults);
  }
  withUpdateVaults(...updatedVaults) {
    const vaults = [...this.vaults];
    for (const updatedVault of updatedVaults) {
      const i = vaults.findIndex((vault) => uuidEqual(vault.id, updatedVault.id));
      if (i >= 0) {
        vaults[i] = updatedVault;
      } else {
        vaults.push(updatedVault);
      }
    }
    return new VaultRepo(vaults);
  }
  getVaultByQuery(...queries) {
    const vault = this.vaults.find(makeVaultPredicate(queries));
    return vault !== null && vault !== void 0 ? vault : null;
  }
  filterVaultsByQuery(...queries) {
    const vaults = this.vaults.filter(makeVaultPredicate(queries));
    return vaults !== null && vaults !== void 0 ? vaults : null;
  }
  getTeamVaultPairsByQuery(query) {
    return this.filterVaultsByQuery(Object.assign({ descriptor: loginVaultContentDescriptor, vaultTypes: [VaultType.TEAM] }, query)).flatMap((vault) => {
      const meta = this.getTeamMetaVaultForTeamVault(vault);
      if (!meta) {
        return [];
      }
      return {
        login: vault,
        meta,
        type: VaultType.TEAM
      };
    });
  }
  makeLoginVaultPair(login) {
    if (login.type === VaultType.TEAM) {
      const meta = this.getTeamMetaVaultForTeamVault(login);
      if (!meta) {
        return null;
      }
      return {
        type: VaultType.TEAM,
        login,
        meta
      };
    }
    if (login.type === VaultType.PRIVATE) {
      return {
        type: login.type,
        login
      };
    }
    if (login.type === VaultType.INBOX) {
      const meta = this.getTeamMetaVaultForTeamVault(login);
      if (!meta) {
        return null;
      }
      return {
        meta,
        type: login.type,
        login
      };
    }
    if (login.type === VaultType.ORGANIZATION_PERSONAL) {
      return {
        type: login.type,
        login
      };
    }
    throw new UnsupportedLoginVaultTypeError();
  }
  getTeamMetaVaultForTeamVault(loginVault) {
    if (![VaultType.TEAM, VaultType.INBOX].some((t2) => loginVault.type === t2)) {
      throw new IncorrectVaultTypeError(loginVault.id, VaultType.TEAM, loginVault.type);
    }
    if (!loginVault.associatedVaultId) {
      throw new TeamVaultMissingAssociatedMetaVaultError(loginVault.id);
    }
    return this.getTeamMetaVaultById(loginVault.associatedVaultId);
  }
}
function makeVaultPredicate(queries) {
  return (v2) => {
    return queries.some(({ descriptor, vaultId, organizationId, vaultTypes, userId, profileId, isUserJoined }) => (!descriptor || descriptor.vaultTypes.includes(v2.type) && descriptor.contentTypeName === v2.getContentType()) && (!vaultId || uuidEqual(v2.id, vaultId)) && (!organizationId || v2.organizationId === organizationId) && (!vaultTypes || vaultTypes.includes(v2.type)) && (!userId || v2.userIds.includes(userId)) && (!profileId || v2.profileIds.includes(profileId)) && (isUserJoined === void 0 || v2.isUserJoined == isUserJoined));
  };
}
var __decorate$2 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
};
var ClientCore_1;
const SALT_SESSION_ENCRYPTION_KEY_SIGNATURE = "salt-session-encryption-key-signature-";
let ClientCore = ClientCore_1 = class ClientCore2 {
  constructor(vaultRepo, profileRepo, backendClient, params, accountState, pinnedAuthenticatorSecret, syncVersion = null, tokenRefreshNeeded = false, superUserUnlockedAuthenticators = {}, foreignVaultSyncPredicate = {}, ephemeralForeignVaultSyncPredicate = {}, ignoredUnlock = null, lastKnownServerTime = null, clientServerTimeOffsetMs = null, auditlogEventQueue = [], auditlogWriteTokenCache = new OrganizationAuthTokenCache(), clientOutdated = false) {
    this.vaultRepo = vaultRepo;
    this.profileRepo = profileRepo;
    this.backendClient = backendClient;
    this.params = params;
    this.accountState = accountState;
    this.pinnedAuthenticatorSecret = pinnedAuthenticatorSecret;
    this.syncVersion = syncVersion;
    this.tokenRefreshNeeded = tokenRefreshNeeded;
    this.superUserUnlockedAuthenticators = superUserUnlockedAuthenticators;
    this.foreignVaultSyncPredicate = foreignVaultSyncPredicate;
    this.ephemeralForeignVaultSyncPredicate = ephemeralForeignVaultSyncPredicate;
    this.ignoredUnlock = ignoredUnlock;
    this.lastKnownServerTime = lastKnownServerTime;
    this.clientServerTimeOffsetMs = clientServerTimeOffsetMs;
    this.auditlogEventQueue = auditlogEventQueue;
    this.auditlogWriteTokenCache = auditlogWriteTokenCache;
    this.clientOutdated = clientOutdated;
    this.mutex = new Mutex();
    this.protectedSecretRepo = null;
    this.maintenanceSettings = null;
    if (pinnedAuthenticatorSecret) {
      const hsc = HighSecurityCache.fromSecret(pinnedAuthenticatorSecret, params.unlockedAuthenticator.authenticator);
      this.protectedSecretRepo = ProtectedSecretRepo.create(this.getClientCoreState(), hsc, null);
    }
  }
  static onlineLoad(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!pcc) {
        return this.onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret);
      }
      try {
        return this.createFromPersistable(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret);
      } catch (e2) {
        trackError(e2);
        return this.onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret);
      }
    });
  }
  static onlineInitializeFromLogin(clientCoreParameters, backendClient, syncUpdate, authenticatorSecret, customSessionData) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
      const { userId } = clientCoreParameters.loginData;
      const authListDto = yield authorizedBackendClient.authenticator.list();
      const accountState = AccountState.fromSyncUpdate(userId, syncUpdate).withAuthenticatorList(authListDto);
      const vaultRepo = VaultRepo.create();
      const profileRepo = ProfileRepo.create([], []);
      const clientCore = new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, authenticatorSecret);
      yield clientCore.onlineEnsureSessionMetaUpToDate((_2, others) => customSessionData ? customSessionData(others) : {}, syncUpdate);
      return clientCore;
    });
  }
  static createFromPersistable(clientCoreParameters, backendClient, pcc, pinnedAuthenticatorSecret) {
    var _a2, _b;
    if (clientCoreParameters.unlockedAuthenticator.authenticator.authenticatorType === AuthenticatorType.BACKUP_CODE) {
      throw new LoginWithRecoveryError();
    }
    const accountState = AccountState.fromPersistable(pcc.accountState);
    if (accountState.userId !== clientCoreParameters.loginData.userId) {
      throw new PersistableMismatchError(accountState.userId, clientCoreParameters.loginData.userId);
    }
    const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
    const profileRepo = ProfileRepo.createFromPersistable(pcc.profileRepo, clientCoreParameters.unlockedAuthenticator);
    const vaultRepo = VaultRepo.createFromPersistable(pcc.vaultRepo, profileRepo, pcc.superUserUnlockedAuthenticators);
    return new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, pinnedAuthenticatorSecret !== null && pinnedAuthenticatorSecret !== void 0 ? pinnedAuthenticatorSecret : null, (_a2 = pcc.lastKnownSyncVersion) !== null && _a2 !== void 0 ? _a2 : null, false, pcc.superUserUnlockedAuthenticators, pcc.foreignVaultSyncPredicate, void 0, (_b = pcc.ignoredUnlock) !== null && _b !== void 0 ? _b : null, null, null, pcc.auditlogEventQueue);
  }
  static onlineLoadWithClientCoreParameters(clientCoreParameters, backendClient, pinnedAuthenticatorSecret) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (clientCoreParameters.unlockedAuthenticator.authenticator.authenticatorType === AuthenticatorType.BACKUP_CODE) {
        throw new LoginWithRecoveryError();
      }
      const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
      const { userId } = clientCoreParameters.loginData;
      const syncUpdate = yield authorizedBackendClient.sync.poll();
      const authListDto = yield authorizedBackendClient.authenticator.list();
      const accountState = AccountState.fromSyncUpdate(userId, syncUpdate).withAuthenticatorList(authListDto);
      const vaultRepo = VaultRepo.create();
      const profileRepo = ProfileRepo.create([], []);
      return new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, pinnedAuthenticatorSecret !== null && pinnedAuthenticatorSecret !== void 0 ? pinnedAuthenticatorSecret : null);
    });
  }
  static onlineRecoverWithNewAuthenticator(clientCoreParameters, backendClient, unsyncedAuthenticator, hsc, extraAuthenticators = []) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const authorizedBackendClient = backendClient.withLogin(clientCoreParameters.loginData);
      const { userId } = clientCoreParameters.loginData;
      const syncUpdate = yield authorizedBackendClient.sync.poll();
      const accountState = AccountState.fromSyncUpdate(userId, syncUpdate);
      const vaultRepo = VaultRepo.create();
      const profileRepo = ProfileRepo.create([], []);
      const clientCore = new ClientCore_1(vaultRepo, profileRepo, authorizedBackendClient, clientCoreParameters, accountState, null);
      yield clientCore.onlineSyncWithUpdate(syncUpdate, "init");
      const authIds = yield clientCore.onlineAddAuthenticators([unsyncedAuthenticator, ...extraAuthenticators], hsc);
      yield clientCore.onlineLogoutSession(clientCore.getSessionId());
      const hsua = unsyncedAuthenticator.withId(authIds[0]);
      const loginChallenge = yield backendClient.credential.createChallenge(null, null, userId);
      const newClientCoreParameters = yield finishChallengeSelfUnlocking({
        client: backendClient,
        hsua,
        challenge: loginChallenge.challenge,
        userId,
        sessionType: SessionType.SELF_UNLOCKING_PRIMARY
      });
      return {
        clientCoreParameters: Object.assign(Object.assign({}, newClientCoreParameters), { unlockedAuthenticator: hsua.getUnlockedAuthenticator() }),
        extraAuthenticatorIds: authIds.slice(1)
      };
    });
  }
  getPersistable() {
    var _a2;
    let lastKnownSyncVersion;
    if (this.syncVersion && this.accountState.serverSideSettings.persistLastKnownSyncVersion) {
      lastKnownSyncVersion = this.syncVersion;
    }
    return {
      vaultRepo: this.vaultRepo.getPersistable(this.foreignVaultSyncPredicate),
      profileRepo: this.profileRepo.getPersistable(this.params.unlockedAuthenticator),
      accountState: this.accountState.getPersistable(),
      lastKnownSyncVersion,
      superUserUnlockedAuthenticators: this.superUserUnlockedAuthenticators,
      foreignVaultSyncPredicate: this.foreignVaultSyncPredicate,
      ignoredUnlock: (_a2 = this.ignoredUnlock) !== null && _a2 !== void 0 ? _a2 : void 0,
      auditlogEventQueue: this.auditlogEventQueue
    };
  }
  getClientCoreParameters() {
    if (!this.backendClient.config.loginData) {
      throw new LoginDataMissingError();
    }
    return this.params;
  }
  getSessionId() {
    return this.backendClient.getSessionId();
  }
  getLoginVaultById(vaultId) {
    return this.vaultRepo.getLoginVaultById(vaultId);
  }
  getPrivateLoginVault() {
    return this.vaultRepo.getPrivateLoginVault();
  }
  getAchievements() {
    return [...this.accountState.achievements];
  }
  getLoginVaultProtectedSecret(v2, hsc) {
    const vaultAccess = getVaultAccess(this.getClientCoreState(), hsc, v2);
    return unlockLockProtectedSecret(vaultAccess, v2.authenticatorLocks, v2.profileLock, v2.adminProfileLock, this.profileRepo, hsc);
  }
  addLogin(options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => addLogin(ccs, options));
    });
  }
  modifyLogin(options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => modifyLogin(ccs, options));
    });
  }
  addOrModifyLogin(options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => addOrModifyLogin(ccs, options));
    });
  }
  createInitialLoginHistoryEntryIfNecessary(options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => createInitialLoginHistoryEntryIfNecessary(ccs, options));
    });
  }
  copyLogins(toId, ...fromLogins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => copyLogins(ccs, toId, fromLogins));
    });
  }
  moveLogins(toId, ...fromLogins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => moveLogins(ccs, toId, fromLogins));
    });
  }
  deleteOrArchiveLogins(...fromLogins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => deleteOrArchiveLogins(ccs, fromLogins));
    });
  }
  restoreArchivedLogins(...fromLogins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => restoreArchivedLogins(ccs, fromLogins));
    });
  }
  deleteArchivedLogins(...fromLogins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => deleteArchivedLogins(ccs, fromLogins));
    });
  }
  modifyTagsForLogin(options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => modifyTagsForLogin(ccs, options));
    });
  }
  modifyLinkedViewSecretsForLogin(targetVaultId, loginId, linkedViewSecrets) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => modifyLinkedViewSecretsForLogin(ccs, targetVaultId, loginId, linkedViewSecrets));
    });
  }
  importLogins({ targetVaultId, emptyNameCustomFieldDefaultName }, ...logins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => importLogins(ccs, targetVaultId, logins, emptyNameCustomFieldDefaultName));
    });
  }
  ingestLoginUpdate(options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => ingestLoginUpdate(ccs, options));
    });
  }
  deleteOutdatedLoginData(vaultId, loginId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => __awaiter$4(this, void 0, void 0, function* () {
        let newCcs = Object.assign({}, ccs);
        newCcs = yield internalDeleteOutdatedLoginHistory(newCcs, vaultId, loginId);
        newCcs = yield internalDeleteOutdatedShareLinks(newCcs, vaultId, loginId);
        return newCcs;
      }));
    });
  }
  onlineLinkLoginsToTeam(orgId, teamVaultId, ...fromLogins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield onlineCheckCanLinkToVault(this.backendClient, orgId, teamVaultId);
      return this.modifyClientCore((ccs) => linkLoginsToTeam(ccs, orgId, teamVaultId, fromLogins));
    });
  }
  onlineLinkLoginsToPersonalProfile(orgId, profileId, ...fromLogins) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const personalVaultId = findPersonalVaultId(this.accountState, this.vaultRepo, orgId, profileId);
      yield onlineCheckCanLinkToVault(this.backendClient, orgId, personalVaultId);
      return this.modifyClientCore((ccs) => linkLoginsToPersonalVault(ccs, orgId, profileId, fromLogins));
    });
  }
  unlinkLogins(fromId, toId, ...loginIds) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => unlinkLogins(ccs, fromId, toId, loginIds));
    });
  }
  onlineLoginShareLinkCreate(vaultId, loginId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("loginShareLinkCreate", (ccs) => onlineInternalLoginShareLinkCreate$1(ccs, vaultId, loginId), "result");
    });
  }
  onlineLoginShareLinkDelete(vaultId, loginId, shareLinkId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("loginShareLinkDelete", (ccs) => onlineInternalLoginShareLinkCreate(ccs, vaultId, loginId, shareLinkId), "result");
    });
  }
  onlineUserConfirmationCreate(data) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("userConfirmationCreate", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const { id: id2, syncUpdate, webauthnOptionsJson } = yield ccs.backendClient.userConfirmations.create(data);
        const webauthnOptions = webauthnOptionsJson ? unmarshalCredentialRequestOptions(webauthnOptionsJson) : void 0;
        ccs = yield onlineInternalSync(ccs, syncUpdate);
        return Object.assign(Object.assign({}, ccs), { returnResult: { id: id2, webauthnOptions } });
      }), "result");
    });
  }
  onlineUserConfirmationGet(id2) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.backendClient.userConfirmations.get(id2);
    });
  }
  onlineUserConfirmationSendAuthenticatorResult(id2, type) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("onlineUserConfirmationSendAuthenticatorResult", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const su2 = yield ccs.backendClient.userConfirmations.sendResult(id2, type, void 0);
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  onlineUserConfirmationSendWebauthnResult(id2, type, webauthnResponse) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("onlineUserConfirmationSendWebauthnResult", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const webauthnResponseJson = webauthnResponse ? marshalAssertionPublicKeyCredential(webauthnResponse) : void 0;
        const su2 = yield ccs.backendClient.userConfirmations.sendResult(id2, type, webauthnResponseJson);
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  onlineUserConfirmationRetrieveResult(id2) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const { resultType } = yield this.backendClient.userConfirmations.retrieveResult(id2);
      return resultType;
    });
  }
  onlineUserConfirmationCancel(id2) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("userConfirmationCancel", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const su2 = yield ccs.backendClient.userConfirmations.cancel(id2);
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  modifyLoginVaultForTest(vaultId, mod, hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const vault = ccs.vaultRepo.getLoginVaultById(vaultId);
        if (!vault) {
          throw new VaultNotFoundError(vaultId);
        }
        const mod2 = (vaultContent, t2, modificationFunctions) => {
          const result = mod(vaultContent, t2, modificationFunctions);
          return Object.assign(Object.assign({}, result), { auditlogEvents: [] });
        };
        return modifyLoginVault(ccs, vault, mod2, hsc);
      }));
    });
  }
  modifyTeamMetaVault(vaultId, mod) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const vault = ccs.vaultRepo.getTeamMetaVaultById(vaultId);
        if (!vault) {
          throw new VaultNotFoundError(vaultId);
        }
        return modifyVault(ccs, vault, mod);
      }));
    });
  }
  modifyMetaVault(mod) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const vault = ccs.vaultRepo.getMetaVault();
        if (!vault) {
          throw new MetaVaultNotFoundError();
        }
        return modifyVault(ccs, vault, mod);
      }));
    });
  }
  migrateBackupCode(backupCode, hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var _b;
        var ccs = __rest(_a2, []);
        const vault = ccs.vaultRepo.getMetaVault();
        if (!vault) {
          throw new MetaVaultNotFoundError();
        }
        if ((_b = getAccountSettings(vault.getContent())) === null || _b === void 0 ? void 0 : _b.backupCode) {
          trackError("cor: onlineMigrateBackupCode called with backup code already migrated");
          return ccs;
        }
        ccs = modifyVault(ccs, vault, (c2, t2, { modifyAccountSettings: modifyAccountSettings2, protect: protect2 }) => modifyAccountSettings2(c2, t2, {
          backupCode: protect2({ unencrypted: backupCode, contentId: newUuid$1() })
        }), true, hsc);
        ccs.accountState = ccs.accountState.withLocalAchievements([
          Achievement.COR_STORE_BACKUP_CODE_META_VAULT
        ]);
        return ccs;
      }));
    });
  }
  modifyLegacyOrganizationAdminVault(vaultId, mod, hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const vault = ccs.vaultRepo.getLegacyOrganizationAdminVaultById(vaultId);
        if (!vault) {
          throw new VaultNotFoundError(vaultId);
        }
        return modifyVault(ccs, vault, mod, true, hsc);
      }));
    });
  }
  addAchievement(...achievements) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        ccs.accountState = ccs.accountState.withLocalAchievements(achievements);
        return ccs;
      }));
    });
  }
  getMetaContent() {
    var _a2, _b;
    return (_b = (_a2 = this.vaultRepo.getMetaVault()) === null || _a2 === void 0 ? void 0 : _a2.getContent()) !== null && _b !== void 0 ? _b : null;
  }
  isUnlocked() {
    var _a2;
    return !!((_a2 = this.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.isUnlocked());
  }
  isPinnedUnlocked() {
    return !!this.pinnedAuthenticatorSecret;
  }
  modifyClientCore(modify) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.internalModifyClientCore(modify, null, null);
    });
  }
  onlineModifyClientCore(clientOperationName, modify, eventOrigin) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.internalModifyClientCore(modify, eventOrigin, clientOperationName);
    });
  }
  internalModifyClientCore(modify, eventOrigin, clientOperationName) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.mutex.runExclusive(() => __awaiter$4(this, void 0, void 0, function* () {
        var _a2, _b, _c2, _d;
        if (eventOrigin) {
          yield this.emitter.emit("syncStart", { eventOrigin });
        }
        const backendClient = clientOperationName ? this.backendClient.withClientOperation(newUniURI(), clientOperationName, (_a2 = this.syncVersion) !== null && _a2 !== void 0 ? _a2 : void 0) : void 0;
        if (clientOperationName) {
          addBreadcrumb$1({
            type: "info",
            category: "onlineModifyClientCore",
            data: {
              clientOperationName,
              clientOperationId: backendClient === null || backendClient === void 0 ? void 0 : backendClient.config.clientOperationId
            }
          });
        }
        const oldCcs = Object.assign(Object.assign({}, this.getClientCoreState()), { backendClient });
        let newCcs;
        try {
          newCcs = yield modify(oldCcs);
        } catch (e2) {
          if (eventOrigin) {
            yield this.emitter.emit("syncEnd", { eventOrigin });
          }
          throw e2;
        }
        this.vaultRepo = newCcs.vaultRepo;
        this.profileRepo = newCcs.profileRepo;
        this.accountState = newCcs.accountState;
        this.protectedSecretRepo = newCcs.protectedSecretRepo;
        this.syncVersion = newCcs.syncVersion;
        this.tokenRefreshNeeded = newCcs.tokenRefreshNeeded;
        this.superUserUnlockedAuthenticators = newCcs.superUserUnlockedAuthenticators;
        this.foreignVaultSyncPredicate = newCcs.foreignVaultSyncPredicate;
        this.ephemeralForeignVaultSyncPredicate = newCcs.ephemeralForeignVaultSyncPredicate;
        this.ignoredUnlock = newCcs.ignoredUnlock;
        this.maintenanceSettings = newCcs.maintenanceSettings;
        this.lastKnownServerTime = newCcs.lastKnownServerTime;
        this.clientOutdated = newCcs.clientOutdated;
        this.clientServerTimeOffsetMs = newCcs.clientServerTimeOffsetMs;
        this.auditlogEventQueue = newCcs.auditlogEventQueue;
        this.auditlogWriteTokenCache = newCcs.auditlogWriteTokenCache;
        if (newCcs.ignoredUnlock !== oldCcs.ignoredUnlock) {
          this.emitter.emit("ignoredUnlockChange").catch(trackError);
        }
        if (newCcs.accountState && newCcs.accountState !== oldCcs.accountState) {
          this.emitter.emit("accountStateChange", {
            oldAccountState: oldCcs.accountState,
            newAccountState: newCcs.accountState
          }).catch(trackError);
        }
        if (newCcs.protectedSecretRepo !== oldCcs.protectedSecretRepo && ((_b = newCcs.protectedSecretRepo) === null || _b === void 0 ? void 0 : _b.isUnlocked()) !== ((_c2 = oldCcs.protectedSecretRepo) === null || _c2 === void 0 ? void 0 : _c2.isUnlocked())) {
          const isUnlocked = !!((_d = newCcs.protectedSecretRepo) === null || _d === void 0 ? void 0 : _d.isUnlocked());
          this.emitter.emit("unlockedChange", { isUnlocked }).catch(trackError);
          addBreadcrumb$1({
            type: "info",
            category: "unlockedChange",
            data: { isUnlocked }
          });
        }
        if (newCcs.profileRepo !== oldCcs.profileRepo) {
          this.emitter.emit("profileRepoChange", {
            oldProfileRepo: oldCcs.profileRepo,
            newProfileRepo: newCcs.profileRepo
          }).catch(trackError);
        }
        if (newCcs.vaultRepo !== oldCcs.vaultRepo) {
          this.emitter.emit("vaultRepoChange", {
            oldVaultRepo: oldCcs.vaultRepo,
            newVaultRepo: newCcs.vaultRepo
          }).catch(trackError);
        }
        if (eventOrigin) {
          yield this.emitter.emit("syncEnd", { eventOrigin });
        } else if (newCcs.vaultRepo !== oldCcs.vaultRepo) {
          yield this.emitter.emit("localVaultChange");
        }
        if (newCcs.tokenRefreshNeeded) {
          yield this.emitter.emit("clientCoreParametersRefreshNeeded");
        }
        return newCcs.returnResult;
      }));
    });
  }
  batchModify(performBatchModification, pinnedSecret) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.internalBatchModify(performBatchModification, null, pinnedSecret);
    });
  }
  onlineBatchModify(performBatchModification, pinnedSecret) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.internalBatchModify(performBatchModification, "result", pinnedSecret);
    });
  }
  // This method can be called with a pinnedSecret as a temporary unlock. Please note that this way
  // is a relatively expensive operation, and should only be called in ways that don't affect
  // responsiveness.
  internalBatchModify(performBatchModification, eventOrigin, pinnedSecret) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.internalModifyClientCore((_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const batchCC = new ClientCore_1(ccs.vaultRepo, ccs.profileRepo, ccs.backendClient, ccs.params, ccs.accountState, pinnedSecret !== null && pinnedSecret !== void 0 ? pinnedSecret : ccs.pinnedAuthenticatorSecret, ccs.syncVersion, ccs.tokenRefreshNeeded, ccs.superUserUnlockedAuthenticators, ccs.foreignVaultSyncPredicate, ccs.ephemeralForeignVaultSyncPredicate, ccs.ignoredUnlock, ccs.lastKnownServerTime, ccs.clientServerTimeOffsetMs, ccs.auditlogEventQueue, ccs.auditlogWriteTokenCache);
        batchCC.maintenanceSettings = ccs.maintenanceSettings;
        if (!pinnedSecret) {
          batchCC.protectedSecretRepo = ccs.protectedSecretRepo;
        }
        const returnResult = yield performBatchModification(batchCC);
        if (pinnedSecret && !ccs.protectedSecretRepo) {
          batchCC.protectedSecretRepo = null;
        }
        return Object.assign(Object.assign({}, batchCC.getClientCoreState()), { backendClient: batchCC.backendClient, returnResult });
      }), eventOrigin, "batch");
    });
  }
  onlineEnsureSessionMetaUpToDate(customSessionData, syncUpdate = null) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("ensureSessionMetaUpToDate", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var _b;
        var ccs = __rest(_a2, []);
        ccs = yield onlineInternalSync(ccs, syncUpdate);
        const ownSessionId = ccs.backendClient.getSessionId();
        const otherSessionIds = ccs.accountState.sessions.map((s2) => s2.id).filter((s2) => s2 !== ownSessionId);
        const metaVault = ccs.vaultRepo.getMetaVault();
        if (!metaVault) {
          return ccs;
        }
        const allSessionMeta = metaVault.getContent().sessions;
        const ownSessionMeta = (_b = allSessionMeta[ownSessionId]) !== null && _b !== void 0 ? _b : null;
        const otherSessionMeta = otherSessionIds.map((s2) => allSessionMeta[s2]).filter((m2) => m2);
        let fieldsToUpdate = customSessionData(ownSessionMeta, otherSessionMeta);
        if (ownSessionMeta === null) {
          fieldsToUpdate = Object.assign(Object.assign({}, fieldsToUpdate), { encPubKey: naclUtilExports.encodeBase64(ccs.params.sessionKeys.encPubKey), encPubKeySignature: naclUtilExports.encodeBase64(ccs.params.sessionKeys.encPubKeySignature), signingAuthId: ccs.params.sessionKeys.signingAuthId });
        }
        if (Object.keys(fieldsToUpdate).length) {
          ccs = internalUpdateMetaSession(ccs, ownSessionId, fieldsToUpdate);
          ccs = yield onlineInternalSync(ccs, syncUpdate);
        }
        return ccs;
      }), "result");
    });
  }
  updateMetaSession(sessionId, session) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.modifyClientCore((ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return internalUpdateMetaSession(ccs, sessionId, session);
      }));
    });
  }
  getSessions() {
    return this.accountState.sessions;
  }
  getSession() {
    const sessionId = this.getSessionId();
    const session = this.getSessions().find((s2) => s2.id === sessionId);
    if (!session) {
      throw new OwnSessionMissingError();
    }
    return session;
  }
  getSessionById(sessionId) {
    return this.getSessions().find((s2) => s2.id === sessionId);
  }
  getSessionMetaById(sessionId) {
    var _a2, _b;
    const sessionMeta = (_a2 = this.getMetaContent()) === null || _a2 === void 0 ? void 0 : _a2.sessions;
    return (_b = sessionMeta === null || sessionMeta === void 0 ? void 0 : sessionMeta[sessionId]) !== null && _b !== void 0 ? _b : null;
  }
  ignoreCurrentUnlock() {
    return __awaiter$4(this, void 0, void 0, function* () {
      const session = this.getSession();
      if (this.pinnedAuthenticatorSecret) {
        throw new Error("cannot ignore unlock with pinned authenticator secret");
      }
      const { unlockedAt } = session;
      if (unlockedAt !== void 0) {
        yield this.modifyClientCore((_a2) => {
          var ccs = __rest(_a2, []);
          ccs.ignoredUnlock = unlockedAt;
          ccs.protectedSecretRepo = null;
          return Promise.resolve(ccs);
        });
      }
    });
  }
  getActiveChannels() {
    return this.accountState.channels;
  }
  getLoginRequests() {
    return this.accountState.channels.map((c2) => c2.id);
  }
  onlineSync(fcmMessageId, hsc = null) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("sync", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalSync(Object.assign({}, ccs), null, fcmMessageId, hsc);
      }), "poll");
    });
  }
  onlineSyncWithUpdate(syncUpdate, eventOrigin) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("syncWithUpdate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalSync(ccs, syncUpdate);
      }), eventOrigin);
    });
  }
  onlineLogoutSession(sessionId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      try {
        const syncUpdate = yield this.backendClient.deleteSession(sessionId);
        if (syncUpdate) {
          yield this.onlineSyncWithUpdate(syncUpdate, "result");
        }
      } catch (e2) {
        if (e2 instanceof DomainError && e2.code === BackendErrorCode.SESSION_NOT_FOUND) {
          yield this.onlineSync();
          return;
        }
        throw e2;
      }
    });
  }
  lockAllVaults() {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.pinnedAuthenticatorSecret) {
        return;
      }
      yield this.modifyClientCore((ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, ccs), { protectedSecretRepo: null });
      }));
    });
  }
  onlineRegenerateVault(hsc, vaultId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("regenerateVault", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        ccs = yield onlineInternalSync(ccs);
        return onlineInternalRegenerateVault(ccs, hsc, vaultId);
      }), "result");
    });
  }
  onlineRegenerateRecovery(backupCode, recoverySeed, parameters, hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("regenerateRecovery", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalRegenerateRecovery(ccs, backupCode, recoverySeed, parameters, hsc);
      }), "result");
    });
  }
  getBackupCode(hsc) {
    var _a2, _b;
    const metaVault = this.vaultRepo.getMetaVault();
    if (!metaVault) {
      throw new MetaVaultNotFoundError();
    }
    let protectedSecretFunctions;
    if (hsc) {
      protectedSecretFunctions = ProtectedSecretRepo.create(this.getClientCoreState(), hsc, null).getProtectedSecretFunctions(metaVault);
    } else if ((_a2 = this.protectedSecretRepo) === null || _a2 === void 0 ? void 0 : _a2.isUnlocked()) {
      protectedSecretFunctions = this.protectedSecretRepo.getProtectedSecretFunctions(metaVault);
    } else {
      throw new CannotUnprotectError();
    }
    const protectedBackupCode = (_b = getAccountSettings(metaVault.getContent())) === null || _b === void 0 ? void 0 : _b.backupCode;
    if (!protectedBackupCode) {
      return;
    }
    return protectedSecretFunctions.unprotect(protectedBackupCode);
  }
  onlineRegenerateBackup(backupSeed, hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("regenerateBackup", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalRegenerateBackup(ccs, backupSeed, hsc);
      }), "result");
    });
  }
  onlineAddAuthenticators(authsToAdd, hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("addAuthenticators", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const result = yield onlineInternalModifyAuthenticators(ccs, hsc, [], authsToAdd);
        if (result.returnResult.length === 0) {
          throw new NoAuthenticatorIdReceivedError();
        }
        return Object.assign(Object.assign({}, result), { returnResult: result.returnResult });
      }), "result");
    });
  }
  onlineRemoveAuthenticator(authenticatorId, hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("removeAuthenticator", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalModifyAuthenticators(ccs, hsc, [authenticatorId]);
      }), "result");
    });
  }
  onlineMigrateToAuthenticatorChain(hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.accountState.authenticatorBlockHash !== null) {
        return;
      }
      return this.onlineModifyClientCore("migrateToAuthenticatorChain", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalMigrateToAuthenticatorChain(ccs, hsc);
      }), "result");
    });
  }
  onlineProfilesRegenerate(hsc) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("profilesRegenerate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalProfileRegenerate(ccs, hsc);
      }), "result");
    });
  }
  onlineOrganizationRegenerateProfiles(orgId, profiles) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationRegenerateProfile", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const newCcs = yield onlineInternalOrganizationRegenerateProfiles(ccs, orgId, profiles);
        return Object.assign(Object.assign({}, newCcs), { returnResult: newCcs.returnResult });
      }), "result");
    });
  }
  onlineTeamCreate(name, organizationId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("teamCreate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalTeamCreate(ccs, name, organizationId);
      }), "result");
    });
  }
  onlineTeamDelete(vaultId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("teamDelete", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalTeamDelete(ccs, vaultId);
      }), "result");
    });
  }
  onlineTeamAddUsers(teamId, usersToAdd, skipInvite = false) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (usersToAdd.length === 0) {
        return;
      }
      return this.onlineModifyClientCore("teamAddUsers", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalTeamModifyUsers(ccs, teamId, { usersToAdd, skipInvite });
      }), "result");
    });
  }
  onlineTeamRemoveUsers(teamId, profileIds) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (profileIds.length === 0) {
        return;
      }
      return this.onlineModifyClientCore("teamRemoveUsers", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalTeamModifyUsers(ccs, teamId, {
          profileIdsToRemove: profileIds
        });
      }), "result");
    });
  }
  onlineTeamLeave(teamId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("teamLeave", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalTeamLeave(ccs, teamId);
      }), "result");
    });
  }
  teamSetUserPermissionLevels(teamId, ...users) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return internalTeamSetUserPermissionLevels(ccs, teamId, ...users);
      }));
    });
  }
  teamClearNewlyJoined(teamId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return internalTeamClearNewlyJoined(ccs, teamId);
      }));
    });
  }
  loginSetConfirmed(vaultId, loginId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.modifyClientCore((ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return internalLoginSetConfirmed(ccs, vaultId, loginId);
      }));
    });
  }
  onlineMaintainTeamSyncOrganizationMembers() {
    var _a2;
    return __awaiter$4(this, void 0, void 0, function* () {
      const task = MaintenanceTask.TEAM_SYNC_ORGANIZATION_MEMBERS_V2;
      if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
        return;
      }
      const teamsToChange = getTeamsWithSyncOrganizationMembersAndMismatchedUsers(this.vaultRepo, this.accountState);
      if (!teamsToChange.length) {
        return;
      }
      yield this.onlineModifyClientCore("maintainTeamSyncOrganizationMembers", (ccs) => {
        return onlineInternalMaintainTeamSyncOrganizationMembers(ccs);
      }, "result");
    });
  }
  onlineHandleLoginChallenge(channelId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return LoginFlowPushAuthenticator.create(
        channelId,
        // TODO: this is implicit, make this explicit
        this.params.unlockedAuthenticator.authenticator.id,
        this.backendClient
      );
    });
  }
  onlineRejectLoginChallenge(channelId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("rejectLoginChallenge", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const { syncUpdate } = yield ccs.backendClient.channel.delete(channelId);
        return syncUpdate ? onlineInternalSync(ccs, syncUpdate) : ccs;
      }), "result");
    });
  }
  onlineLongPollChannelSendSecret(publicKeyB64, authenticatorSeed, registration) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const { publicKeyHash, authReply } = completeLongPollChannelReply(publicKeyB64, authenticatorSeed, registration);
      yield this.backendClient.credential.completeLongPollChannel(publicKeyHash, this.params.unlockedAuthenticator.authenticator.id, authReply);
    });
  }
  onlineCreateSessionUnlock(sessionId, encPubKey, encPubKeySignature, trustedSigPubKeys, hsc, expiresAt) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("createSessionUnlock", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        checkEncPubKeySignature(trustedSigPubKeys, encPubKey, encPubKeySignature, SALT_SESSION_ENCRYPTION_KEY_SIGNATURE);
        const encryptedSecret = hsc.getHighSecurityUnlockedAuthenticator().createEncryptedSecret(encPubKey);
        const syncUpdate = yield ccs.backendClient.session.createSessionUnlock(
          sessionId,
          // TODO: this is implicit, make this explicit
          this.params.unlockedAuthenticator.authenticator.id,
          encryptedSecret,
          expiresAt
        );
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineExtendSessionUnlock(lastUserActivity) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.getSession().unlockedAt === void 0) {
        return;
      }
      return this.onlineModifyClientCore("extendSessionUnlock", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.session.extendSessionUnlock(lastUserActivity);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineSendLoginEventNotification(vaultId, loginId, username, domain) {
    var _a2;
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!((_a2 = this.accountState.serverSideSettings.eventNotifications) === null || _a2 === void 0 ? void 0 : _a2.enable)) {
        return;
      }
      const { description, iconType } = this.getSessionMetaById(this.getSessionId());
      const data = new TextEncoder().encode(JSON.stringify({
        type: "login",
        session: { description, iconType },
        vaultId,
        loginId,
        username,
        domain
      }));
      const messages2 = [];
      for (const s2 of this.getSessions()) {
        const meta = this.getSessionMetaById(s2.id);
        if (meta && (s2.sessionType === SessionType.SELF_UNLOCKING_PRIMARY || s2.sessionType === SessionType.SELF_UNLOCKING_SECONDARY)) {
          const payload = asymEncrypt(loadEncryptionPublicKey(meta.encPubKey), data);
          messages2.push({ sessionId: s2.id, payload });
        }
      }
      yield this.backendClient.session.sendSessionMessage(messages2);
    });
  }
  onlineDeleteSessionUnlock(sessionId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("deleteSessionUnlock", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.session.deleteSessionUnlock(sessionId);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineCancelRequestSessionUnlock(sessionId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("cancelRequestSessionUnlock", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.session.deleteSessionUnlock(sessionId, true);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineRequestSessionUnlock() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("requestSessionUnlock", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.session.requestSessionUnlock();
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineSessionSetUnlockTimeLimit(unlockTimeLimit) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("sessionSetUnlockTimeLimit", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const sessionId = ccs.params.loginData.sessionId;
        const su2 = yield ccs.backendClient.session.update(sessionId, [], { unlockTimeLimit });
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  onlineSessionSetProfileEnabled(profileId, enabled) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("sessionSetProfileEnabled", (ccs) => onlineInternalSessionSetProfileEnabled(ccs, profileId, enabled), "result");
    });
  }
  onlineSessionSetEnabledProfileIds(enabledProfileIds) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("sessionSetEnabledProfileIds", (ccs) => onlineInternalSessionSetEnabledProfileIds(ccs, enabledProfileIds), "result");
    });
  }
  onlineRequestProfileEmailChange(profileId, email) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("requestProfileEmailChange", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const resp = yield ccs.backendClient.profile.requestEmailChange(profileId, email);
        ccs = yield onlineInternalSync(ccs, resp.syncUpdate);
        return Object.assign(Object.assign({}, ccs), { returnResult: { verificationEmailSent: resp.verificationEmailSent } });
      }), "result");
    });
  }
  onlineCancelProfileEmailChange(profileId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("cancelProfileEmailChange", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const syncUpdate = yield ccs.backendClient.profile.cancelEmailChange(profileId);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineSetPreferredLocale(preferredLocale) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("setPreferredLocale", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.account.update({
          preferredLocale
        });
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineProfileCreatePrivate(email) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("profileCreatePrivate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalProfileCreatePrivate(ccs, email);
      }), "result");
    });
  }
  onlineProfileDeletePrivate(profileId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("profileDeletePrivate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalProfileDeletePrivate(ccs, profileId);
      }), "result");
    });
  }
  onlineProfileClaimWithStartCode(profileId, startCode) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("profileClaimWithStartCode", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const result = yield ccs.backendClient.profile.claimWithStartCode(profileId, startCode);
        ccs = yield onlineInternalSync(ccs, result.syncUpdate);
        return Object.assign(Object.assign({}, ccs), { returnResult: result.organizationId });
      }), "result");
    });
  }
  onlineOrganizationCreate(email, name, syncOrganizationMembersVaultName, options) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationCreate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        if (!(options === null || options === void 0 ? void 0 : options.legacy)) {
          return onlineInternalOrganizationCreate(ccs, email, name, syncOrganizationMembersVaultName, options);
        } else {
          return onlineInternalOrganizationCreateLegacy(ccs, email, name, syncOrganizationMembersVaultName, options);
        }
      }), "result");
    });
  }
  onlineOrganizationUpdate(orgId, fields) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationUpdate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const org = this.accountState.organizations.find((o2) => o2.id === orgId);
        if (!org) {
          throw new OrganizationNotFoundError();
        }
        const { passwordPolicy, clientSettings } = fields, restFields = __rest(fields, ["passwordPolicy", "clientSettings"]);
        const syncUpdate = yield ccs.backendClient.organization.update(orgId, Object.assign(Object.assign({}, restFields), { passwordPolicy: passwordPolicy === void 0 || passwordPolicy === null ? passwordPolicy : jsonStringifyFreeze(passwordPolicy), clientSettings: clientSettings ? jsonStringifyFreeze(Object.assign(Object.assign({}, org.clientSettings), clientSettings)) : void 0 }));
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineOrganizationCreateFreeProfiles(orgId, emails, { isAdmin = false, createStartCodeAndSendMail } = {}) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationAddMember", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const resolvedEmails = yield ccs.backendClient.account.resolveEmails(emails, false);
        const createFreeProfiles = resolvedEmails.map(({ email, emailInvalid }) => {
          if (emailInvalid) {
            throw new DomainError(BackendErrorCode.INVALID_EMAIL, "invalid email", "Email address is invalid", `${email} is not a valid email address.`);
          }
          return {
            email,
            isAdmin,
            createStartCodeAndSendMail
          };
        });
        return onlineInternalOrganizationModifyMembers(ccs, orgId, { createFreeProfiles });
      }), "result");
    });
  }
  onlineOrganizationCreateServiceProfile(orgId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationCreateServiceProfile", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalOrganizationCreateServiceProfile(ccs, orgId);
      }), "result");
    });
  }
  onlineOrganizationUpdateMembers(orgId, membersToUpdate) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationUpdateMembers", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalOrganizationModifyMembers(ccs, orgId, {
          updateProfiles: membersToUpdate.flatMap((m2) => ({
            id: m2.profileId,
            isAdmin: m2.isAdmin
          }))
        });
      }), "result");
    });
  }
  onlineOrganizationRemoveMembers(orgId, profileIds) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationRemoveMembers", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalOrganizationModifyMembers(ccs, orgId, {
          removeProfileIds: profileIds
        });
      }), "result");
    });
  }
  onlineOrganizationLeave(orgId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationLeave", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const su2 = yield ccs.backendClient.organization.leave(orgId);
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  onlineOrganizationDelete(orgId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationDelete", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalOrganizationDelete(ccs, orgId);
      }), "result");
    });
  }
  onlineOrganizationRedeemCoupon(orgId, coupon) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationRedeemCoupon", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const org = ccs.accountState.getOrganization(orgId);
        if (!org) {
          throw new OrganizationNotFoundError();
        }
        if (!org.isAdmin) {
          throw new NoOrganizationAdminError();
        }
        const su2 = yield ccs.backendClient.withPermissionUserId(org.superUserId).organization.redeemCoupon(orgId, coupon);
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  onlineOrganizationEntraFinishAuthorization(search) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationEntraInitSync", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const response = yield ccs.backendClient.integrations.entraFinishAuthorization(search);
        const { syncUpdate } = response;
        ccs = yield onlineInternalSync(ccs, syncUpdate);
        return Object.assign(Object.assign({}, ccs), { returnResult: response });
      }), "result");
    });
  }
  onlineOrganizationEntraClearAuthorization(organizationId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationEntraClearAuthorization", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.integrations.entraClearAuthorization(organizationId);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineOrganizationGoogleWorkspaceFinishAuthorization(search) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationGoogleWorkspaceFinishAuthorization", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const response = yield ccs.backendClient.integrations.googleWorkspaceFinishAuthorization(search);
        const { syncUpdate } = response;
        ccs = yield onlineInternalSync(ccs, syncUpdate);
        return Object.assign(Object.assign({}, ccs), { returnResult: response });
      }), "result");
    });
  }
  onlineOrganizationGoogleWorkspaceClearAuthorization(orgId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationGoogleWorkspaceFinishAuthorization", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const su2 = yield ccs.backendClient.integrations.googleWorkspaceClearAuthorization(orgId);
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  onlineOrganizationSetCsvIntegrationData(organizationId, csvIntegrationData, cancelToken) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationSetCsvIntegrationData", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const su2 = yield ccs.backendClient.integrations.csvSetIntegrationData(organizationId, csvIntegrationData ? JSON.stringify(csvIntegrationData) : null, cancelToken);
        return onlineInternalSync(ccs, su2);
      }), "result");
    });
  }
  onlineOrganizationGetCsvIntegrationData(organizationId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return CsvIntegrationData.parse(JSON.parse(yield this.backendClient.integrations.csvGetIntegrationData(organizationId)));
    });
  }
  onlineOrganizationRegenerateAdminProfile(orgId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationRegenerateAdminProfile", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalOrganizationRegenerateAdminProfile(ccs, orgId);
      }), "result");
    });
  }
  onlineChildOrganizationAddManager(organizationId, parentOrganizationProfileId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("childOrganizationAddManager", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalChildOrganizationAddManager(ccs, organizationId, parentOrganizationProfileId);
      }), "result");
    });
  }
  onlineChildOrganizationUpdate(childOrgId, fields) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("childOrganizationUpdate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const { parentOrganizationMetadata } = fields, restFields = __rest(fields, ["parentOrganizationMetadata"]);
        const syncUpdate = yield ccs.backendClient.childOrganization.update(childOrgId, Object.assign(Object.assign({}, restFields), { parentOrganizationMetadata: parentOrganizationMetadata === void 0 || parentOrganizationMetadata === null ? parentOrganizationMetadata : jsonStringifyFreeze(parentOrganizationMetadata) }));
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineInboxVaultCreate(slug, metadata, organizationId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("inboxVaultCreate", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalInboxVaultCreate(ccs, slug, metadata, organizationId);
      }), "result");
    });
  }
  onlineInboxVaultUpdate(vaultId, { slug, metadata }) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("inboxVaultModify", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const metadataJson = metadata !== void 0 ? jsonStringifyFreeze(metadata) : void 0;
        const syncUpdate = yield ccs.backendClient.vault.updateInbox(vaultId, {
          slug,
          metadataJson
        });
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineInboxVaultDelete(vaultId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("inboxVaultDelete", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalInboxVaultDelete(ccs, vaultId);
      }), "result");
    });
  }
  onlineMaintainMigrateToAdminProfile() {
    var _a2, _b;
    return __awaiter$4(this, void 0, void 0, function* () {
      const task = MaintenanceTask.ORGANIZATION_MIGRATE_TO_ADMIN_PROFILE_V2;
      if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
        return;
      }
      const legacyOrgId = (_b = this.accountState.organizations.find((o2) => o2.adminProfileId === null)) === null || _b === void 0 ? void 0 : _b.id;
      if (!legacyOrgId) {
        return;
      }
      yield this.onlineModifyClientCore("maintainMigrateToAdminProfile", (ccs) => {
        return onlineInternalOrganizationRegenerateAdminProfile(ccs, legacyOrgId);
      }, "result");
    });
  }
  onlineMaintainVaultMessages() {
    var _a2;
    return __awaiter$4(this, void 0, void 0, function* () {
      const task = MaintenanceTask.PROCESS_VAULT_MESSAGES_V2;
      if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
        return;
      }
      if (!hasProcessableVaultMessages(this.vaultRepo)) {
        return;
      }
      yield this.onlineModifyClientCore("maintainVaultMessages", (ccs) => {
        return onlineInternalMaintainVaultMessages(ccs);
      }, "result");
    });
  }
  onlineMaintainOrganizationPreliminaryProfiles() {
    var _a2;
    return __awaiter$4(this, void 0, void 0, function* () {
      const task = MaintenanceTask.ORGANIZATION_PRELIMINARY_PROFILES_V3;
      if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
        return;
      }
      const profiles = getOrganizationsProfilesWithPreliminaryUserId(this.accountState.organizations, this.profileRepo);
      if (!profiles.length) {
        return;
      }
      yield this.onlineModifyClientCore("maintainOrganizationPreliminaryProfiles", (ccs) => {
        return onlineMaintainOrganizationPreliminaryProfiles(ccs);
      }, "result");
    });
  }
  onlineSetUserClientSettings(updatedSettings) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("setUserClientSettings", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const userClientSettings = jsonStringifyFreeze(Object.assign(Object.assign({}, ccs.accountState.userClientSettings), updatedSettings));
        const syncUpdate = yield ccs.backendClient.account.update({
          userClientSettings
        });
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlinePerformMaintenance() {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!this.isUnlocked()) {
        return;
      }
      yield this.onlineMaintainMigrateToAdminProfile().catch(trackError);
      const results = yield Promise.allSettled([
        this.onlineMaintainOrganizationPreliminaryProfiles(),
        this.onlineMaintainTeamSyncOrganizationMembers(),
        this.onlineMaintainVaultMessages()
      ]);
      results.filter((result) => result.status === "rejected").forEach(({ reason }) => trackError(reason));
    });
  }
  onlineWebauthnRegisterCredentialInit(type) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("webauthnRegisterCredentialInit", (ccs) => onlineInternalWebauthnRegisterCredentialInit(ccs, type), "result");
    });
  }
  onlineWebauthnRegisterCredentialFinish(requestId, cred) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("webauthnRegisterCredentialFinish", (ccs) => onlineInternalWebauthnRegisterCredentialFinish(ccs, requestId, cred), "result");
    });
  }
  onlineWebauthnDeleteCredentials(...ids) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("webauthnDeleteCredentials", (ccs) => onlineInternalWebauthnDeleteCredentials(ccs, ids), "result");
    });
  }
  onlineWebauthnUnlockSessionInit() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("webauthnUnlockSessionInit", onlineInternalWebauthnUnlockSessionInit, "result");
    });
  }
  onlineWebauthnUnlockSessionFinish(requestId, cred) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("webauthnUnlockSessionFinish", (ccs) => onlineInternalWebauthnUnlockSessionFinish(ccs, requestId, cred), "result");
    });
  }
  onlineWebauthnEnablePrf(request, cred) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("webauthnEnablePrf", (ccs) => onlineInternalWebauthnEnablePrf(ccs, request, cred), "result");
    });
  }
  onlineWebauthnEnablePrfOpportunistically(request, result) {
    var _a2;
    return __awaiter$4(this, void 0, void 0, function* () {
      const task = MaintenanceTask.ENABLE_PRF_OPPORTUNISTICALLY_V1;
      if (!((_a2 = this.maintenanceSettings) === null || _a2 === void 0 ? void 0 : _a2.allowedTasks.includes(task))) {
        return;
      }
      const isAlreadyEnabled = this.accountState.authenticators.some((a2) => {
        var _a3;
        return ((_a3 = a2.webauthn) === null || _a3 === void 0 ? void 0 : _a3.webauthnId) === result.id;
      });
      if (isAlreadyEnabled) {
        return;
      }
      const isSessionBound = this.accountState.webauthnCredentials.some((wc2) => wc2.webauthnId === result.id && wc2.sessionId !== null);
      if (isSessionBound) {
        return;
      }
      yield this.onlineWebauthnEnablePrf(request, result);
    });
  }
  onlineModifyForeignVaultSyncPredicate(predicateModification) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!this.backendClient.config.syncSuperUsers) {
        throw new Error("onlineModifyForeignVaultSyncPredicate requires syncSuperUsers!");
      }
      yield this.onlineModifyClientCore("modifyForeignVaultSyncPredicate", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const newPredicate = predicateModification(ccs.foreignVaultSyncPredicate);
        if (deepEqual$1(ccs.foreignVaultSyncPredicate, newPredicate)) {
          return ccs;
        }
        ccs.foreignVaultSyncPredicate = newPredicate;
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
        ccs = yield onlineInternalSync(ccs);
        return ccs;
      }), "result");
    });
  }
  onlineModifyEphemeralForeignVaultSyncPredicate(predicateModification) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!this.backendClient.config.syncSuperUsers) {
        throw new Error("onlineModifyEphemeralForeignVaultSyncPredicate requires syncSuperUsers!");
      }
      yield this.onlineModifyClientCore("modifyEphemeralForeignVaultSyncPredicate", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const newPredicate = predicateModification(ccs.ephemeralForeignVaultSyncPredicate);
        if (deepEqual$1(ccs.ephemeralForeignVaultSyncPredicate, newPredicate)) {
          return ccs;
        }
        ccs.ephemeralForeignVaultSyncPredicate = newPredicate;
        ccs.syncVersion = null;
        ccs.backendClient = ccs.backendClient.withSyncVersion(void 0);
        ccs = yield onlineInternalSync(ccs);
        return ccs;
      }), "result");
    });
  }
  auditlogWriteEventsWithRetry(orgId, ...events) {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.onlineModifyClientCore("auditlogWriteEventsWithRetry", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const queuedEvents = events.map((event) => {
          var _a3;
          return {
            organizationId: orgId,
            clientTime: /* @__PURE__ */ new Date(),
            lastKnownServerTime: (_a3 = ccs.lastKnownServerTime) !== null && _a3 !== void 0 ? _a3 : /* @__PURE__ */ new Date(0),
            event
          };
        });
        const newCcs = yield onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, queuedEvents);
        if (newCcs.returnResult === AuditlogWriteResult.Retry) {
          newCcs.auditlogEventQueue = [...newCcs.auditlogEventQueue, ...queuedEvents];
        }
        return newCcs;
      }), "result");
    });
  }
  onlineAuditlogWriteEvents(orgId, ...events) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("auditlogWriteQueuedEvents", (_a2) => __awaiter$4(this, void 0, void 0, function* () {
        var ccs = __rest(_a2, []);
        const queuedEvents = events.map((event) => Object.assign({ organizationId: orgId }, event));
        return onlineInternalAuditlogWriteQueuedEvents(ccs, orgId, queuedEvents);
      }), "result");
    });
  }
  onlineAuditlogGetEvents(orgId, page, filter2, anchor, cancelToken) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const auditlogClient = yield this.onlineGetAuditlogAdminClient(orgId, cancelToken);
      const { events, totalCount, timeAnchor: newTimeAnchor } = yield auditlogClient.listEvents(page, filter2, anchor, cancelToken);
      return {
        events: events.map((e2) => AuditlogEventEnvelope.parse(JSON.parse(e2))),
        totalCount,
        timeAnchor: newTimeAnchor
      };
    });
  }
  onlineGetAuditlogAdminClient(orgId, cancelToken) {
    return __awaiter$4(this, void 0, void 0, function* () {
      const token = yield this.backendClient.credential.createAuditlogAdminToken(orgId, cancelToken);
      return this.backendClient.getAuditlogAdminClient(token);
    });
  }
  onlineCreateRefreshedClientCoreParameters() {
    return __awaiter$4(this, void 0, void 0, function* () {
      const currentCcp = this.getClientCoreParameters();
      const newToken = yield this.backendClient.credential.refreshToken();
      const newCcp = Object.assign(Object.assign({}, currentCcp), { loginData: Object.assign(Object.assign({}, currentCcp.loginData), { token: newToken }) });
      return newCcp;
    });
  }
  onlineOrganizationRenewStartCodes(orgId, ...profileIds) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationRenewStartCodes", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.organization.renewProfileStartCode(orgId, ...profileIds);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineOrganizationSendStartCodeEmails(orgId, ...profileIds) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationSendStartCodeEmails", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.organization.sendStartCodeEmail(orgId, ...profileIds);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineOrganizationRevokeStartCodes(orgId, ...profileIds) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("organizationRevokeStartCodes", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        const syncUpdate = yield ccs.backendClient.organization.revokeProfileStartCode(orgId, ...profileIds);
        return onlineInternalSync(ccs, syncUpdate);
      }), "result");
    });
  }
  onlineOrganizationGetBreachData(organizationId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.backendClient.organization.getBreachData(organizationId);
    });
  }
  onlineOrganizationStoreUnsafeVaultContents(organizationId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("onlineOrganizationStoreUnsafeVaultStates", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalOrganizationStoreUnsafeVaultContents(ccs, organizationId);
      }), "result");
    });
  }
  onlineOrganizationRestoreUnsafeVaultContents(organizationId) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this.onlineModifyClientCore("onlineOrganizationRestoreVaultStates", (ccs) => __awaiter$4(this, void 0, void 0, function* () {
        return onlineInternalOrganizationRestoreUnsafeVaultContents(ccs, organizationId);
      }), "result");
    });
  }
  debugEmitClientCoreParametersRefreshNeeded() {
    return __awaiter$4(this, void 0, void 0, function* () {
      yield this.emitter.emit("clientCoreParametersRefreshNeeded");
    });
  }
  getClientCoreState() {
    return {
      params: this.params,
      pinnedAuthenticatorSecret: this.pinnedAuthenticatorSecret,
      vaultRepo: this.vaultRepo,
      profileRepo: this.profileRepo,
      accountState: this.accountState,
      protectedSecretRepo: this.protectedSecretRepo,
      syncVersion: this.syncVersion,
      tokenRefreshNeeded: this.tokenRefreshNeeded,
      superUserUnlockedAuthenticators: this.superUserUnlockedAuthenticators,
      foreignVaultSyncPredicate: this.foreignVaultSyncPredicate,
      ephemeralForeignVaultSyncPredicate: this.ephemeralForeignVaultSyncPredicate,
      ignoredUnlock: this.ignoredUnlock,
      maintenanceSettings: this.maintenanceSettings,
      lastKnownServerTime: this.lastKnownServerTime,
      clientOutdated: this.clientOutdated,
      clientServerTimeOffsetMs: this.clientServerTimeOffsetMs,
      auditlogEventQueue: this.auditlogEventQueue,
      auditlogWriteTokenCache: this.auditlogWriteTokenCache
    };
  }
};
ClientCore = ClientCore_1 = __decorate$2([
  Emittery$1.mixin("emitter")
], ClientCore);
function getDummySecretSeedFromSecretInfo(secretInfo) {
  const { seed } = jsonParseThaw(secretInfo);
  return seed;
}
var __decorate$1 = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LongPollUpdateEmitter_1;
let LongPollUpdateEmitter = LongPollUpdateEmitter_1 = class LongPollUpdateEmitter2 {
  constructor(backendClient, requestUnlock) {
    this.backendClient = backendClient;
    this.cancelToken = new CancelToken();
    this.longPollLoopUntilCancelled(requestUnlock).catch((error2) => __awaiter$3(this, void 0, void 0, function* () {
      if (this.cancelToken.isCancelled) {
        return;
      }
      if (error2 instanceof Cancel) {
        return this.emitter.emit("cancel");
      } else {
        return this.emitter.emit("error", { error: error2 });
      }
    }));
  }
  longPollLoopUntilCancelled(requestUnlock) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let message = yield this.backendClient.withSyncVersion(0).sync.longPoll(this.cancelToken, requestUnlock);
      let updateSyncVersion = message.syncVersion;
      yield this.emitter.emit("message", { message });
      while (!this.cancelToken.isCancelled) {
        message = yield this.backendClient.withSyncVersion(updateSyncVersion).sync.longPoll(this.cancelToken, false);
        updateSyncVersion = message.syncVersion;
        yield this.emitter.emit("message", { message });
      }
    });
  }
  static fromLoginData(loginData, backendClient) {
    const authorizedBackendClient = backendClient.withLogin(loginData);
    return new LongPollUpdateEmitter_1(authorizedBackendClient, false);
  }
  static fromClientCore(clientCore, requestUnlock) {
    return new LongPollUpdateEmitter_1(clientCore.backendClient, requestUnlock);
  }
  close() {
    this.cancelToken.cancel();
    this.emitter.emit("cancel").catch(trackError);
    this.emitter.clearListeners();
  }
};
LongPollUpdateEmitter = LongPollUpdateEmitter_1 = __decorate$1([
  Emittery$1.mixin("emitter")
], LongPollUpdateEmitter);
const LongPollUpdateEmitter$1 = LongPollUpdateEmitter;
class StreamingUpdateEmitter {
  constructor(backendClient, requestUnlock) {
    this.backendClient = backendClient;
    this.cancelToken = new CancelToken();
    this.emitter = backendClient.sync.streamingSync(this.cancelToken, requestUnlock);
    this.emitter.bindMethods(this);
  }
  static fromLoginData(loginData, backendClient) {
    const authorizedBackendClient = backendClient.withLogin(loginData);
    return new StreamingUpdateEmitter(authorizedBackendClient, false);
  }
  static fromClientCore(clientCore, requestUnlock) {
    var _a2;
    const backendClient = clientCore.backendClient.withSyncVersion((_a2 = clientCore.syncVersion) !== null && _a2 !== void 0 ? _a2 : void 0);
    return new StreamingUpdateEmitter(backendClient, requestUnlock);
  }
  close() {
    this.emitter.clearListeners();
    this.cancelToken.cancel();
  }
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function runWithCancel(cb2, onCancel, cancelToken) {
  return __awaiter$2(this, void 0, void 0, function* () {
    if (cancelToken) {
      try {
        yield Promise.race([cb2(), waitForCancel(cancelToken)]);
      } catch (e2) {
        if (e2 instanceof Cancel) {
          yield onCancel();
          return;
        }
        throw e2;
      }
    } else {
      yield cb2();
    }
  });
}
function waitForCancel(cancelToken) {
  return new Promise((_2, reject) => cancelToken.onCancel(() => {
    reject(new Cancel());
  }));
}
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
};
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = globalThis && globalThis.__asyncValues || function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
};
let ClientCoreSync = class ClientCoreSync2 {
  constructor(clientCore, { performMaintenanceAfterSync = true, minReconnectDelayMs = 3e3, stateStore = {} } = {}) {
    this.clientCore = clientCore;
    this.autoSyncLocalChanges = true;
    this.autoSyncRemoteChanges = true;
    this.internalUpdateEmitter = null;
    this.isInitialSyncResponse = false;
    this.isSyncEnabled = false;
    this.isDelayExtendUnlock = false;
    this.syncConnectionMode = "streaming";
    this.handleUpdateEmitterMessage = ({ message }) => {
      this.stateStore.lastConnectAttempt = 0;
      if (!this.autoSyncRemoteChanges) {
        return;
      }
      let eventOrigin;
      if (this.isInitialSyncResponse) {
        this.isInitialSyncResponse = false;
        debugConsole.log("Initial sync successful");
        eventOrigin = "init";
      } else {
        eventOrigin = "push";
      }
      this.onlineSyncNonBlocking(message, eventOrigin);
    };
    this.handleClientCoreLocalVaultChange = () => {
      if (this.autoSyncLocalChanges) {
        this.onlineSyncNonBlocking(null);
      }
    };
    this.handleSyncEnd = () => {
      this.scheduleUnlockTimeouts();
    };
    this.performMaintenanceAfterSync = performMaintenanceAfterSync;
    this.minReconnectDelayMs = minReconnectDelayMs;
    this.stateStore = stateStore;
    const { clientType } = clientCore.backendClient.config;
    const { preferLongPollForProtoClientTypes } = clientCore.accountState.serverSideSettings;
    if (clientType && (preferLongPollForProtoClientTypes === null || preferLongPollForProtoClientTypes === void 0 ? void 0 : preferLongPollForProtoClientTypes.includes(clientType))) {
      this.syncConnectionMode = "longPoll";
    }
  }
  open() {
    this.isSyncEnabled = true;
    this.reconnectWithDelay();
    this.clientCore.on("localVaultChange", this.handleClientCoreLocalVaultChange);
    this.clientCore.on("syncEnd", this.handleSyncEnd);
  }
  close() {
    this.isSyncEnabled = false;
    this.disconnect();
    this.clientCore.off("localVaultChange", this.handleClientCoreLocalVaultChange);
    this.clientCore.off("syncEnd", this.handleSyncEnd);
    if (this.unlockExpirationTimeoutId) {
      clearTimeout(this.unlockExpirationTimeoutId);
      this.unlockExpirationTimeoutId = void 0;
    }
    if (this.unlockExtensionTimeoutId) {
      clearTimeout(this.unlockExtensionTimeoutId);
      this.unlockExtensionTimeoutId = void 0;
    }
    if (this.maintenanceTaskTimeoutId) {
      clearTimeout(this.maintenanceTaskTimeoutId);
      this.maintenanceTaskTimeoutId = void 0;
    }
    if (this.reconnectTimeoutId) {
      clearTimeout(this.reconnectTimeoutId);
      this.reconnectTimeoutId = void 0;
    }
  }
  reconnectIfNecessary(requestUnlock = false) {
    if (this.internalUpdateEmitter) {
      return;
    }
    this.reconnect(requestUnlock);
  }
  disconnect() {
    if (this.internalUpdateEmitter) {
      this.internalUpdateEmitter.close();
      this.internalUpdateEmitter = null;
    }
  }
  setSyncConnectionMode(mode2, origin = "explicit") {
    if (this.syncConnectionMode === mode2) {
      return;
    }
    const keepConnection = mode2 === "streaming" && this.syncConnectionMode === "streamingOrFallback";
    this.syncConnectionMode = mode2;
    this.emitter.emit("syncConnectionModeChange", { mode: mode2, origin }).catch(trackError);
    if (!keepConnection) {
      this.reconnect();
    }
  }
  getSyncConnectionMode() {
    return this.syncConnectionMode;
  }
  setDelayExtendUnlock(delayExtendUnlock) {
    this.isDelayExtendUnlock = delayExtendUnlock;
  }
  reconnectWithDelay(requestUnlock = false) {
    var _a2;
    this.disconnect();
    if (!this.isSyncEnabled) {
      return;
    }
    const now = /* @__PURE__ */ new Date();
    if (this.minReconnectDelayMs === null) {
      return;
    }
    if (!this.stateStore.lastConnectAttemptDate) {
      debugConsole.log("Reconnecting immediately, no last connect attempt date known");
      this.reconnectIfNecessary(requestUnlock);
      return;
    }
    if (this.stateStore.lastConnectAttempt === 0) {
      debugConsole.log(`Reconnecting event stream immediately`);
      this.stateStore.lastConnectAttempt += 1;
      this.reconnectIfNecessary(requestUnlock);
      return;
    }
    let reconnectDelay = this.minReconnectDelayMs;
    const lastConnectAttempt = (_a2 = this.stateStore.lastConnectAttempt) !== null && _a2 !== void 0 ? _a2 : 0;
    reconnectDelay *= Math.pow(2, Math.min(lastConnectAttempt - 1, 5));
    this.stateStore.lastConnectAttempt = lastConnectAttempt + 1;
    const timeSinceLastConnect = now.getTime() - this.stateStore.lastConnectAttemptDate.getTime();
    const effectiveDelay = Math.max(500, reconnectDelay - timeSinceLastConnect);
    debugConsole.log(`Reconnecting event stream in ${effectiveDelay / 1e3} seconds... ${requestUnlock ? "(With unlock)" : ""}`);
    this.reconnectTimeoutId = setTimeout(this.reconnectIfNecessary.bind(this, requestUnlock), effectiveDelay);
  }
  reconnectRequestingUnlock() {
    this.reconnect(true);
  }
  reconnect(requestUnlock = false) {
    this.disconnect();
    if (this.reconnectTimeoutId) {
      clearTimeout(this.reconnectTimeoutId);
      this.reconnectTimeoutId = void 0;
    }
    if (!this.isSyncEnabled) {
      return;
    }
    this.stateStore.lastConnectAttemptDate = /* @__PURE__ */ new Date();
    this.isInitialSyncResponse = true;
    this.internalUpdateEmitter = this.syncConnectionMode === "longPoll" ? LongPollUpdateEmitter$1.fromClientCore(this.clientCore, requestUnlock) : StreamingUpdateEmitter.fromClientCore(this.clientCore, requestUnlock);
    this.internalUpdateEmitter.on("message", this.handleUpdateEmitterMessage);
    this.internalUpdateEmitter.on("error", ({ error: error2 }) => {
      debugConsole.log("Event stream disconnected due to error.", error2);
      if (error2 instanceof NoResponseError) {
        this.emitter.emit("recoverableSyncError", { error: error2 }).catch(trackError);
        this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
        return;
      }
      if (error2 instanceof BackendDomainError && error2.code === BackendErrorCode.CANCELED) {
        if (this.isSyncEnabled) {
          this.emitter.emit("recoverableSyncCancel", {}).catch(trackError);
        }
        this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
        return;
      }
      if (error2 instanceof InvalidGrpcResponseError) {
        this.emitter.emit("recoverableSyncError", { error: error2 }).catch(trackError);
        if (this.stateStore.lastConnectAttempt === 0) {
          trackError(error2);
        }
        this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
        return;
      }
      debugConsole.log("Sync stream error not recoverable, giving up.", error2);
      this.disconnect();
      this.emitter.emit("syncError", { error: error2 }).catch(trackError);
    });
    this.internalUpdateEmitter.on("cancel", () => {
      if (this.isSyncEnabled) {
        this.emitter.emit("recoverableSyncCancel", {}).catch(trackError);
      }
      this.reconnectWithDelay(this.isInitialSyncResponse ? requestUnlock : void 0);
    });
    if (this.syncConnectionMode === "streamingOrFallback") {
      const initialSyncTimeout = setTimeout(() => {
        debugConsole.log("[clientCoreSync]", "switching to long poll after 5s no response");
        this.setSyncConnectionMode("longPoll", "fallback");
      }, 5e3);
      const clearOnAny = this.internalUpdateEmitter.onAny((...args) => {
        debugConsole.log("[clientCoreSync]", "canceling switch to longpoll", args);
        clearTimeout(initialSyncTimeout);
        clearOnAny();
        this.setSyncConnectionMode("streaming", "fallback");
      });
    }
  }
  /**
   * Triggers a sync that cannot be awaited. Sync errors emit syncError events.
   */
  onlineSyncNonBlocking(syncUpdate, eventOrigin = "poll") {
    this.sync(syncUpdate, eventOrigin).catch(trackError);
  }
  requestUnlock(cancelToken) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.startRequestUnlock(cancelToken);
      yield this.finishRequestUnlock(cancelToken);
    });
  }
  startRequestUnlock(cancelToken) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this.clientCore.isUnlocked()) {
        return;
      }
      const syncEvents = this.clientCore.events("syncEnd");
      this.reconnectRequestingUnlock();
      yield runWithCancel(() => __awaiter$1(this, void 0, void 0, function* () {
        var _a2, e_1, _b, _c2;
        try {
          for (var _d = true, syncEvents_1 = __asyncValues(syncEvents), syncEvents_1_1; syncEvents_1_1 = yield syncEvents_1.next(), _a2 = syncEvents_1_1.done, !_a2; _d = true) {
            _c2 = syncEvents_1_1.value;
            _d = false;
            const _2 = _c2;
            if (this.clientCore.isUnlocked()) {
              return;
            }
            if (this.clientCore.getSession().unlockRequestedAt !== void 0) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a2 && (_b = syncEvents_1.return))
              yield _b.call(syncEvents_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }), () => __awaiter$1(this, void 0, void 0, function* () {
        yield this.clientCore.onlineCancelRequestSessionUnlock(this.clientCore.getSessionId());
        throw new Cancel();
      }), cancelToken);
    });
  }
  finishRequestUnlock(cancelToken) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this.clientCore.isUnlocked()) {
        return;
      }
      if (this.clientCore.getSession().unlockRequestedAt === void 0) {
        throw new UnlockRejectedError();
      }
      const syncEvents = this.clientCore.events("syncEnd");
      yield this.tryUnlockingWithDummyAuth();
      yield runWithCancel(() => __awaiter$1(this, void 0, void 0, function* () {
        var _a2, e_2, _b, _c2;
        try {
          for (var _d = true, syncEvents_2 = __asyncValues(syncEvents), syncEvents_2_1; syncEvents_2_1 = yield syncEvents_2.next(), _a2 = syncEvents_2_1.done, !_a2; _d = true) {
            _c2 = syncEvents_2_1.value;
            _d = false;
            const _2 = _c2;
            if (this.clientCore.isUnlocked()) {
              return;
            }
            if (this.clientCore.getSession().unlockRequestedAt === void 0) {
              throw new UnlockRejectedError();
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a2 && (_b = syncEvents_2.return))
              yield _b.call(syncEvents_2);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }), () => __awaiter$1(this, void 0, void 0, function* () {
        yield this.clientCore.onlineCancelRequestSessionUnlock(this.clientCore.getSessionId());
        throw new Cancel();
      }), cancelToken);
    });
  }
  tryUnlockingWithDummyAuth() {
    var _a2;
    return __awaiter$1(this, void 0, void 0, function* () {
      const currentAuth = this.clientCore.params.unlockedAuthenticator.authenticator;
      if (currentAuth.authenticatorType !== AuthenticatorType.DUMMY) {
        return;
      }
      if (this.isInitialSyncResponse) {
        yield (_a2 = this.internalUpdateEmitter) === null || _a2 === void 0 ? void 0 : _a2.once("message");
      }
      const hsc = HighSecurityCache.fromSecret({
        authenticatorId: currentAuth.id,
        seed: getDummySecretSeedFromSecretInfo(currentAuth.secretInfo)
      }, currentAuth);
      const meta = this.clientCore.getSessionMetaById(this.clientCore.getSessionId());
      if (!meta || !meta.encPubKey || !meta.encPubKeySignature) {
        return;
      }
      const encPubKey = loadEncryptionPublicKey(meta.encPubKey);
      const encPubKeySignature = loadEncryptionPublicKeySignature(meta.encPubKeySignature);
      const trustedSigPubKeys = [currentAuth.storableSigPubKey];
      const expiresAt = getUnlockTime();
      yield this.clientCore.onlineCreateSessionUnlock(this.clientCore.getSessionId(), encPubKey, encPubKeySignature, trustedSigPubKeys, hsc, expiresAt);
    });
  }
  sync(syncUpdate, eventOrigin) {
    return __awaiter$1(this, void 0, void 0, function* () {
      try {
        if (!syncUpdate) {
          yield this.clientCore.onlineSync();
        } else {
          if (eventOrigin === "push" && syncUpdate.syncVersion === this.clientCore.syncVersion) {
            return;
          }
          this.emitter.emit("syncUpdate", { eventOrigin, syncUpdate }).catch(trackError);
          yield this.clientCore.onlineSyncWithUpdate(syncUpdate, eventOrigin);
        }
        this.checkLongPollSetting();
        this.scheduleMaintenanceTasks();
      } catch (error2) {
        if (error2 instanceof InvalidGrpcResponseError || error2 instanceof NoResponseError) {
          yield this.emitter.emit("recoverableSyncError", { error: error2 });
        } else if (error2 instanceof Error) {
          yield this.emitter.emit("syncError", { error: error2 });
        } else {
          yield this.emitter.emit("syncError", { error: new Error(`${error2}`) });
        }
      }
    });
  }
  checkLongPollSetting() {
    if (this.syncConnectionMode === "longPoll") {
      return;
    }
    const { clientType } = this.clientCore.backendClient.config;
    const { preferLongPollForProtoClientTypes } = this.clientCore.accountState.serverSideSettings;
    if (clientType && (preferLongPollForProtoClientTypes === null || preferLongPollForProtoClientTypes === void 0 ? void 0 : preferLongPollForProtoClientTypes.includes(clientType))) {
      this.setSyncConnectionMode("longPoll", "serverSideSetting");
    }
  }
  scheduleUnlockTimeouts() {
    if (this.unlockExpirationTimeoutId) {
      clearTimeout(this.unlockExpirationTimeoutId);
      this.unlockExpirationTimeoutId = void 0;
    }
    if (this.unlockExtensionTimeoutId) {
      clearTimeout(this.unlockExtensionTimeoutId);
      this.unlockExtensionTimeoutId = void 0;
    }
    if (this.clientCore.vaultRepo.isInitialized() && !this.clientCore.isUnlocked()) {
      return;
    }
    if (this.clientCore.isPinnedUnlocked()) {
      return;
    }
    const { unlockedAt, unlockExtendAt, unlockedUntil } = this.clientCore.getSession();
    if (!unlockedAt) {
      this.clientCore.lockAllVaults().catch(trackError);
      return;
    }
    if (unlockedUntil) {
      const unlockDurationMs = unlockedUntil.getTime() - Date.now();
      this.unlockExpirationTimeoutId = setTimeout(() => {
        this.clientCore.lockAllVaults().catch(trackError);
      }, unlockDurationMs);
      if (unlockExtendAt) {
        const extendSessionTime = unlockExtendAt.getTime() - Date.now() + (this.isDelayExtendUnlock ? 5e3 : 0);
        this.unlockExtensionTimeoutId = setTimeout(() => {
          this.extendSessionIfNecessary();
        }, extendSessionTime);
      }
    }
  }
  pingActivity() {
    const now = /* @__PURE__ */ new Date();
    if (this.lastUserActivityDate && this.lastUserActivityDate.getTime() > now.getTime() - 10 * 1e3) {
      return;
    }
    this.lastUserActivityDate = now;
    this.extendSessionIfNecessary();
  }
  extendSessionIfNecessary() {
    if (!this.lastUserActivityDate) {
      return;
    }
    const session = this.clientCore.getSession();
    const { unlockedAt, unlockExtendAt, unlockedUntil } = session;
    if (!unlockedAt || !unlockExtendAt || unlockExtendAt.getTime() > Date.now() || unlockedUntil && unlockedUntil.getTime() < Date.now()) {
      return;
    }
    const lastUserActivity = this.lastUserActivityDate;
    this.lastUserActivityDate = void 0;
    this.clientCore.onlineExtendSessionUnlock(lastUserActivity).catch((e2) => {
      if (e2 instanceof NoResponseError) {
        return;
      }
      if (e2 instanceof DomainError) {
        switch (e2.code) {
          case BackendErrorCode.SESSION_NOT_UNLOCKED:
          case BackendErrorCode.SESSION_NOT_FOUND:
            return;
        }
      }
      throw e2;
    }).catch(trackError);
  }
  scheduleMaintenanceTasks() {
    if (!this.performMaintenanceAfterSync) {
      return;
    }
    if (this.maintenanceTaskTimeoutId) {
      clearTimeout(this.maintenanceTaskTimeoutId);
      this.maintenanceTaskTimeoutId = void 0;
    }
    const delay = 1e3 + Math.random() * 2e3;
    this.maintenanceTaskTimeoutId = setTimeout(() => {
      this.clientCore.onlinePerformMaintenance().catch(trackError);
    }, delay);
  }
};
ClientCoreSync = __decorate([
  Emittery$1.mixin("emitter")
], ClientCoreSync);
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function filterUnprotectedCustomFields(customFields) {
  const totpField = customFields === null || customFields === void 0 ? void 0 : customFields.find((f2) => f2.protected && f2.name.toLowerCase().includes("totp"));
  const remainingFields = customFields.filter((cf2) => cf2 !== totpField);
  return {
    totpField,
    remainingFields
  };
}
function getLoginDisplayLabel(login) {
  var _a2, _b, _c2, _d, _e;
  if ((_a2 = login.title) === null || _a2 === void 0 ? void 0 : _a2.trim()) {
    return login.title.trim();
  }
  if (login.uiType === LoginUiType.creditCard && ((_c2 = (_b = login.creditCard) === null || _b === void 0 ? void 0 : _b.displayType) === null || _c2 === void 0 ? void 0 : _c2.trim())) {
    return login.creditCard.displayType.trim();
  }
  if (login.uiType === LoginUiType.wifi && ((_d = login.wifiSsid) === null || _d === void 0 ? void 0 : _d.trim())) {
    return login.wifiSsid.trim();
  }
  if ((_e = login.username) === null || _e === void 0 ? void 0 : _e.trim()) {
    return login.username.trim();
  }
  return void 0;
}
function getLoginDisplaySources(login, { noSourceCount } = {}) {
  var _a2, _b, _c2;
  const androidApps = (_a2 = login.androidApps) !== null && _a2 !== void 0 ? _a2 : [];
  const websites = (_c2 = (_b = login.websites) === null || _b === void 0 ? void 0 : _b.filter((w2) => w2.trim())) !== null && _c2 !== void 0 ? _c2 : [];
  let displayWebsite;
  if (androidApps.length) {
    displayWebsite = androidApps[0].displayName;
  } else if (websites.length) {
    displayWebsite = websites[0];
  }
  const length = androidApps.length + websites.length;
  if (!noSourceCount && displayWebsite !== void 0 && length > 1) {
    displayWebsite += ` (+${length - 1})`;
  }
  return displayWebsite;
}
function getLoginDisplayInfo(login, { noSourceCount } = {}) {
  var _a2, _b, _c2, _d;
  const label = getLoginDisplayLabel(login);
  const cardNumber2 = (_b = (_a2 = login.creditCard) === null || _a2 === void 0 ? void 0 : _a2.displayMaskedNumber) === null || _b === void 0 ? void 0 : _b.trim();
  if (login.uiType === LoginUiType.creditCard && cardNumber2) {
    return {
      headline: label,
      subheadline: cardNumber2,
      subheadlineMonospace: true
    };
  }
  if (login.uiType === LoginUiType.wifi) {
    return {
      headline: label,
      subheadline: ((_c2 = login.title) === null || _c2 === void 0 ? void 0 : _c2.trim()) ? (_d = login.wifiSsid) === null || _d === void 0 ? void 0 : _d.trim() : void 0
    };
  }
  if (login.uiType === LoginUiType.note && login.note) {
    return {
      headline: label,
      subheadline: login.note.split("\n")[0].substring(0, 100)
    };
  }
  const sources = getLoginDisplaySources(login, { noSourceCount });
  if (sources) {
    return { headline: sources, subheadline: label };
  }
  if (label) {
    return { headline: label };
  }
  return {
    headline: void 0
  };
}
const relatedDomainsDictionary = {
  "3docean.net": [
    "audiojungle.net",
    "codecanyon.net",
    "envato.com",
    "graphicriver.net",
    "photodune.net",
    "placeit.net",
    "themeforest.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "audiojungle.net": [
    "3docean.net",
    "codecanyon.net",
    "envato.com",
    "graphicriver.net",
    "photodune.net",
    "placeit.net",
    "themeforest.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "codecanyon.net": [
    "3docean.net",
    "audiojungle.net",
    "envato.com",
    "graphicriver.net",
    "photodune.net",
    "placeit.net",
    "themeforest.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "envato.com": [
    "3docean.net",
    "audiojungle.net",
    "codecanyon.net",
    "graphicriver.net",
    "photodune.net",
    "placeit.net",
    "themeforest.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "graphicriver.net": [
    "3docean.net",
    "audiojungle.net",
    "codecanyon.net",
    "envato.com",
    "photodune.net",
    "placeit.net",
    "themeforest.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "photodune.net": [
    "3docean.net",
    "audiojungle.net",
    "codecanyon.net",
    "envato.com",
    "graphicriver.net",
    "placeit.net",
    "themeforest.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "placeit.net": [
    "3docean.net",
    "audiojungle.net",
    "codecanyon.net",
    "envato.com",
    "graphicriver.net",
    "photodune.net",
    "themeforest.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "themeforest.net": [
    "3docean.net",
    "audiojungle.net",
    "codecanyon.net",
    "envato.com",
    "graphicriver.net",
    "photodune.net",
    "placeit.net",
    "tutsplus.com",
    "videohive.net"
  ],
  "tutsplus.com": [
    "3docean.net",
    "audiojungle.net",
    "codecanyon.net",
    "envato.com",
    "graphicriver.net",
    "photodune.net",
    "placeit.net",
    "themeforest.net",
    "videohive.net"
  ],
  "videohive.net": [
    "3docean.net",
    "audiojungle.net",
    "codecanyon.net",
    "envato.com",
    "graphicriver.net",
    "photodune.net",
    "placeit.net",
    "themeforest.net",
    "tutsplus.com"
  ],
  "airbnb.com.ar": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.au": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.at": [
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.be": [
    "airbnb.at",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.bz": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.bo": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.br": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.ca": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.cl": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.co": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.co.cr": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.cz": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.dk": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.ec": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.sv": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.fi": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.fr": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.de": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.gr": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.gt": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.gy": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.hn": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.hk": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.hu": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.is": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.co.in": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.co.id": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.ie": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.it": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.jp": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.my": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.mt": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.mx": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.nl": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.co.nz": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.ni": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.no": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.pa": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.py": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.pe": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.pl": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.pt": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.ru": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.se"
  ],
  "airbnb.com.sg": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.co.kr": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.es": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.se": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru"
  ],
  "airbnb.ch": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.tw": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com.tr": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.co.uk": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.ve",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.com": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.co.ve",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airbnb.co.ve": [
    "airbnb.at",
    "airbnb.be",
    "airbnb.ca",
    "airbnb.ch",
    "airbnb.cl",
    "airbnb.co.cr",
    "airbnb.co.id",
    "airbnb.co.in",
    "airbnb.co.kr",
    "airbnb.co.nz",
    "airbnb.co.uk",
    "airbnb.com",
    "airbnb.com.ar",
    "airbnb.com.au",
    "airbnb.com.bo",
    "airbnb.com.br",
    "airbnb.com.bz",
    "airbnb.com.co",
    "airbnb.com.ec",
    "airbnb.com.gt",
    "airbnb.com.hk",
    "airbnb.com.hn",
    "airbnb.com.mt",
    "airbnb.com.my",
    "airbnb.com.ni",
    "airbnb.com.pa",
    "airbnb.com.pe",
    "airbnb.com.py",
    "airbnb.com.sg",
    "airbnb.com.sv",
    "airbnb.com.tr",
    "airbnb.com.tw",
    "airbnb.cz",
    "airbnb.de",
    "airbnb.dk",
    "airbnb.es",
    "airbnb.fi",
    "airbnb.fr",
    "airbnb.gr",
    "airbnb.gy",
    "airbnb.hu",
    "airbnb.ie",
    "airbnb.is",
    "airbnb.it",
    "airbnb.jp",
    "airbnb.mx",
    "airbnb.nl",
    "airbnb.no",
    "airbnb.pl",
    "airbnb.pt",
    "airbnb.ru",
    "airbnb.se"
  ],
  "airnewzealand.co.nz": [
    "airnewzealand.com",
    "airnewzealand.com.au"
  ],
  "airnewzealand.com": [
    "airnewzealand.co.nz",
    "airnewzealand.com.au"
  ],
  "airnewzealand.com.au": [
    "airnewzealand.co.nz",
    "airnewzealand.com"
  ],
  "albertsons.com": [
    "acmemarkets.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "acmemarkets.com": [
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "carrsqc.com": [
    "acmemarkets.com",
    "albertsons.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "jewelosco.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "pavilions.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "randalls.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "safeway.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "shaws.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "starmarket.com",
    "tomthumb.com",
    "vons.com"
  ],
  "starmarket.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "tomthumb.com",
    "vons.com"
  ],
  "tomthumb.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "vons.com"
  ],
  "vons.com": [
    "acmemarkets.com",
    "albertsons.com",
    "carrsqc.com",
    "jewelosco.com",
    "pavilions.com",
    "randalls.com",
    "safeway.com",
    "shaws.com",
    "starmarket.com",
    "tomthumb.com"
  ],
  "alelo.com.br": [
    "meualelo.com.br"
  ],
  "meualelo.com.br": [
    "alelo.com.br"
  ],
  "ana.co.jp": [
    "astyle.jp"
  ],
  "astyle.jp": [
    "ana.co.jp"
  ],
  "angel.co": [
    "wellfound.com"
  ],
  "anthem.com": [
    "sydneyhealth.com"
  ],
  "sydneyhealth.com": [
    "anthem.com"
  ],
  "appannie.com": [
    "data.ai"
  ],
  "bgg.cc": [
    "boardgamegeek.com",
    "rpggeek.com",
    "videogamegeek.com"
  ],
  "boardgamegeek.com": [
    "bgg.cc",
    "rpggeek.com",
    "videogamegeek.com"
  ],
  "rpggeek.com": [
    "bgg.cc",
    "boardgamegeek.com",
    "videogamegeek.com"
  ],
  "videogamegeek.com": [
    "bgg.cc",
    "boardgamegeek.com",
    "rpggeek.com"
  ],
  "centralfcu.org": [
    "centralfcu.com"
  ],
  "centralfcu.com": [
    "centralfcu.org"
  ],
  "coolblue.nl": [
    "coolblue.be",
    "coolblue.de"
  ],
  "coolblue.be": [
    "coolblue.de",
    "coolblue.nl"
  ],
  "coolblue.de": [
    "coolblue.be",
    "coolblue.nl"
  ],
  "dan.org": [
    "diversalertnetwork.org"
  ],
  "diversalertnetwork.org": [
    "dan.org"
  ],
  "discordapp.com": [
    "discord.com"
  ],
  "discordmerch.com": [
    "discord.store"
  ],
  "discord.store": [
    "discordmerch.com"
  ],
  "discovercard.com": [
    "discover.com"
  ],
  "disney.com": [
    "disneyplus.com",
    "disneystore.com",
    "espn.com",
    "go.com",
    "hulu.com",
    "shopdisney.com"
  ],
  "disneyplus.com": [
    "disney.com",
    "disneystore.com",
    "espn.com",
    "go.com",
    "hulu.com",
    "shopdisney.com"
  ],
  "disneystore.com": [
    "disney.com",
    "disneyplus.com",
    "espn.com",
    "go.com",
    "hulu.com",
    "shopdisney.com"
  ],
  "espn.com": [
    "disney.com",
    "disneyplus.com",
    "disneystore.com",
    "go.com",
    "hulu.com",
    "shopdisney.com"
  ],
  "go.com": [
    "disney.com",
    "disneyplus.com",
    "disneystore.com",
    "espn.com",
    "hulu.com",
    "shopdisney.com"
  ],
  "hulu.com": [
    "disney.com",
    "disneyplus.com",
    "disneystore.com",
    "espn.com",
    "go.com",
    "shopdisney.com"
  ],
  "shopdisney.com": [
    "disney.com",
    "disneyplus.com",
    "disneystore.com",
    "espn.com",
    "go.com",
    "hulu.com"
  ],
  "dnt.abine.com": [
    "ironvest.com"
  ],
  "ironvest.com": [
    "dnt.abine.com"
  ],
  "drivethrucards.com": [
    "dmsguild.com",
    "drivethrucomics.com",
    "drivethrufiction.com",
    "drivethrurpg.com",
    "pathfinderinfinite.com",
    "storytellersvault.com",
    "wargamevault.com"
  ],
  "drivethrucomics.com": [
    "dmsguild.com",
    "drivethrucards.com",
    "drivethrufiction.com",
    "drivethrurpg.com",
    "pathfinderinfinite.com",
    "storytellersvault.com",
    "wargamevault.com"
  ],
  "drivethrufiction.com": [
    "dmsguild.com",
    "drivethrucards.com",
    "drivethrucomics.com",
    "drivethrurpg.com",
    "pathfinderinfinite.com",
    "storytellersvault.com",
    "wargamevault.com"
  ],
  "drivethrurpg.com": [
    "dmsguild.com",
    "drivethrucards.com",
    "drivethrucomics.com",
    "drivethrufiction.com",
    "pathfinderinfinite.com",
    "storytellersvault.com",
    "wargamevault.com"
  ],
  "dmsguild.com": [
    "drivethrucards.com",
    "drivethrucomics.com",
    "drivethrufiction.com",
    "drivethrurpg.com",
    "pathfinderinfinite.com",
    "storytellersvault.com",
    "wargamevault.com"
  ],
  "pathfinderinfinite.com": [
    "dmsguild.com",
    "drivethrucards.com",
    "drivethrucomics.com",
    "drivethrufiction.com",
    "drivethrurpg.com",
    "storytellersvault.com",
    "wargamevault.com"
  ],
  "storytellersvault.com": [
    "dmsguild.com",
    "drivethrucards.com",
    "drivethrucomics.com",
    "drivethrufiction.com",
    "drivethrurpg.com",
    "pathfinderinfinite.com",
    "wargamevault.com"
  ],
  "wargamevault.com": [
    "dmsguild.com",
    "drivethrucards.com",
    "drivethrucomics.com",
    "drivethrufiction.com",
    "drivethrurpg.com",
    "pathfinderinfinite.com",
    "storytellersvault.com"
  ],
  "ebay.at": [
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.be": [
    "ebay.at",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.ca": [
    "ebay.at",
    "ebay.be",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.ch": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.cn": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.co.th": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.co.uk": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.com": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.com.au": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.com.hk": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.com.my": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.com.sg": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.com.tw": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.de": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.es": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.fr": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.ie": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.it": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.nl": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.ph",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.ph": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.pl",
    "ebay.vn"
  ],
  "ebay.pl": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.vn"
  ],
  "ebay.vn": [
    "ebay.at",
    "ebay.be",
    "ebay.ca",
    "ebay.ch",
    "ebay.cn",
    "ebay.co.th",
    "ebay.co.uk",
    "ebay.com",
    "ebay.com.au",
    "ebay.com.hk",
    "ebay.com.my",
    "ebay.com.sg",
    "ebay.com.tw",
    "ebay.de",
    "ebay.es",
    "ebay.fr",
    "ebay.ie",
    "ebay.it",
    "ebay.nl",
    "ebay.ph",
    "ebay.pl"
  ],
  "epicgames.com": [
    "unrealengine.com"
  ],
  "unrealengine.com": [
    "epicgames.com"
  ],
  "eventbrite.at": [
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.be": [
    "eventbrite.at",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.ca": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.ch": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.cl": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.co": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.com": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.de": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.dk": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.es": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.fi": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.fr": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.hk": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.ie": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.in": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.it": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.my": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.nl": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.ph": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.pt",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.pt": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.se",
    "eventbrite.sg"
  ],
  "eventbrite.se": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.sg"
  ],
  "eventbrite.sg": [
    "eventbrite.at",
    "eventbrite.be",
    "eventbrite.ca",
    "eventbrite.ch",
    "eventbrite.cl",
    "eventbrite.co",
    "eventbrite.com",
    "eventbrite.de",
    "eventbrite.dk",
    "eventbrite.es",
    "eventbrite.fi",
    "eventbrite.fr",
    "eventbrite.hk",
    "eventbrite.ie",
    "eventbrite.in",
    "eventbrite.it",
    "eventbrite.my",
    "eventbrite.nl",
    "eventbrite.ph",
    "eventbrite.pt",
    "eventbrite.se"
  ],
  "fancourier.ro": [
    "selfawb.ro"
  ],
  "flyblade.com": [
    "blade.com"
  ],
  "gazduire.com.ro": [
    "admin.ro"
  ],
  "gazduire.net": [
    "admin.ro"
  ],
  "hbo.com": [
    "max.com"
  ],
  "hbomax.com": [
    "max.com"
  ],
  "hbonow.com": [
    "max.com"
  ],
  "heroku.com": [
    "verify.salesforce.com"
  ],
  "ing.de": [
    "ing.com"
  ],
  "instagram.com": [
    "threads.net"
  ],
  "threads.net": [
    "instagram.com"
  ],
  "letsdeel.com": [
    "deel.com"
  ],
  "login.airfrance.com": [
    "login.flyingblue.com",
    "login.klm.com"
  ],
  "login.flyingblue.com": [
    "login.airfrance.com",
    "login.klm.com"
  ],
  "login.klm.com": [
    "login.airfrance.com",
    "login.flyingblue.com"
  ],
  "lrz.de": [
    "mwn.de",
    "mytum.de",
    "tum.de",
    "tum.edu"
  ],
  "mwn.de": [
    "lrz.de",
    "mytum.de",
    "tum.de",
    "tum.edu"
  ],
  "mytum.de": [
    "lrz.de",
    "mwn.de",
    "tum.de",
    "tum.edu"
  ],
  "tum.de": [
    "lrz.de",
    "mwn.de",
    "mytum.de",
    "tum.edu"
  ],
  "tum.edu": [
    "lrz.de",
    "mwn.de",
    "mytum.de",
    "tum.de"
  ],
  "mercadolibre.cl": [
    "mercadolibre.com"
  ],
  "mercadolibre.co.cr": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.ar": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.bo": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.co": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.do": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.ec": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.gt": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.hn": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.mx": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.ni": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.pa": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.pe": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.py": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.sv": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.uy": [
    "mercadolibre.com"
  ],
  "mercadolibre.com.ve": [
    "mercadolibre.com"
  ],
  "mercadopago.cl": [
    "mercadolibre.com"
  ],
  "mercadopago.com.ar": [
    "mercadolibre.com"
  ],
  "mercadopago.com.co": [
    "mercadolibre.com"
  ],
  "mercadopago.com.ec": [
    "mercadolibre.com"
  ],
  "mercadopago.com.mx": [
    "mercadolibre.com"
  ],
  "mercadopago.com.pe": [
    "mercadolibre.com"
  ],
  "mercadopago.com.uy": [
    "mercadolibre.com"
  ],
  "mercadopago.com.ve": [
    "mercadolibre.com"
  ],
  "mercadolivre.com.br": [
    "mercadolivre.com"
  ],
  "mercadopago.com.br": [
    "mercadolivre.com"
  ],
  "moneybird.nl": [
    "moneybird.com"
  ],
  "moneybird.de": [
    "moneybird.com"
  ],
  "nebula.app": [
    "nebula.tv"
  ],
  "watchnebula.com": [
    "nebula.tv"
  ],
  "nextinpact.com": [
    "next.ink"
  ],
  "nordvpn.com": [
    "nordaccount.com"
  ],
  "nordpass.com": [
    "nordaccount.com"
  ],
  "overstock.com": [
    "bedbathandbeyond.com"
  ],
  "parkmobile.us": [
    "parkmobile.io"
  ],
  "pinterest.com": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.ca": [
    "pinterest.at",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.co.uk": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.fr": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.de": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.es": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.com.au": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.se": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru"
  ],
  "pinterest.ph": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.ch": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.com.mx": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.dk": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.pt": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.ru": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.se"
  ],
  "pinterest.it": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.at": [
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.jp": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.cl": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.ie": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.co.kr": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.nz",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "pinterest.nz": [
    "pinterest.at",
    "pinterest.ca",
    "pinterest.ch",
    "pinterest.cl",
    "pinterest.co.kr",
    "pinterest.co.uk",
    "pinterest.com",
    "pinterest.com.au",
    "pinterest.com.mx",
    "pinterest.de",
    "pinterest.dk",
    "pinterest.es",
    "pinterest.fr",
    "pinterest.ie",
    "pinterest.it",
    "pinterest.jp",
    "pinterest.ph",
    "pinterest.pt",
    "pinterest.ru",
    "pinterest.se"
  ],
  "postnl.nl": [
    "postnl.be"
  ],
  "postnl.be": [
    "postnl.nl"
  ],
  "pretendo.network": [
    "pretendo.cc"
  ],
  "pretendo.cc": [
    "pretendo.network"
  ],
  "proton.me": [
    "protonmail.ch",
    "protonmail.com",
    "protonvpn.com"
  ],
  "protonvpn.com": [
    "proton.me",
    "protonmail.ch",
    "protonmail.com"
  ],
  "protonmail.ch": [
    "proton.me",
    "protonmail.com",
    "protonvpn.com"
  ],
  "protonmail.com": [
    "proton.me",
    "protonmail.ch",
    "protonvpn.com"
  ],
  "quicken.com": [
    "simplifimoney.com"
  ],
  "simplifimoney.com": [
    "quicken.com"
  ],
  "raywenderlich.com": [
    "kodeco.com"
  ],
  "redis.com": [
    "redislabs.com"
  ],
  "redislabs.com": [
    "redis.com"
  ],
  "s.activision.com": [
    "profile.callofduty.com"
  ],
  "profile.callofduty.com": [
    "s.activision.com"
  ],
  "scottscheapflights.com": [
    "going.com"
  ],
  "steampowered.com": [
    "steamcommunity.com"
  ],
  "steamcommunity.com": [
    "steampowered.com"
  ],
  "taxhawk.com": [
    "express1040.com",
    "freetaxusa.com"
  ],
  "freetaxusa.com": [
    "express1040.com",
    "taxhawk.com"
  ],
  "express1040.com": [
    "freetaxusa.com",
    "taxhawk.com"
  ],
  "telegram.me": [
    "telegram.org"
  ],
  "ting.com": [
    "tingmobile.com"
  ],
  "tingmobile.com": [
    "ting.com"
  ],
  "transferwise.com": [
    "wise.com"
  ],
  "tvnow.de": [
    "auth.rtl.de",
    "rtlplus.com",
    "rtlplus.de"
  ],
  "tvnow.at": [
    "auth.rtl.de",
    "rtlplus.com",
    "rtlplus.de"
  ],
  "tvnow.ch": [
    "auth.rtl.de",
    "rtlplus.com",
    "rtlplus.de"
  ],
  "twitter.com": [
    "x.com"
  ],
  "uspowerboating.com": [
    "ussailing.org"
  ],
  "ussailing.org": [
    "uspowerboating.com"
  ],
  "wacom.eu": [
    "wacom.com"
  ],
  "wikipedia.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "mediawiki.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikibooks.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikidata.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikinews.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikiquote.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikisource.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikiversity.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikivoyage.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wiktionary.org"
  ],
  "wiktionary.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org"
  ],
  "commons.wikimedia.org": [
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "meta.wikimedia.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "incubator.wikimedia.org": [
    "commons.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "outreach.wikimedia.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "species.wikimedia.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikimania.wikimedia.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "wikimania.wikimedia.org": [
    "commons.wikimedia.org",
    "incubator.wikimedia.org",
    "mediawiki.org",
    "meta.wikimedia.org",
    "outreach.wikimedia.org",
    "species.wikimedia.org",
    "wikibooks.org",
    "wikidata.org",
    "wikinews.org",
    "wikipedia.org",
    "wikiquote.org",
    "wikisource.org",
    "wikiversity.org",
    "wikivoyage.org",
    "wiktionary.org"
  ],
  "www.seek.com.au": [
    "login.seek.com"
  ],
  "www.seek.co.nz": [
    "login.seek.com"
  ],
  "jobsdb.com": [
    "login.seek.com"
  ],
  "hk.jobsdb.com": [
    "login.seek.com"
  ],
  "sg.jobsdb.com": [
    "login.seek.com"
  ],
  "th.jobsdb.com": [
    "login.seek.com"
  ],
  "jobstreet.com": [
    "login.seek.com"
  ],
  "myjobstreet.jobstreet.co.id": [
    "login.seek.com"
  ],
  "myjobstreet.jobstreet.com.my": [
    "login.seek.com"
  ],
  "myjobstreet.jobstreet.com.ph": [
    "login.seek.com"
  ],
  "myjobstreet.jobstreet.com.sg": [
    "login.seek.com"
  ],
  "www.vistaprint.ca": [
    "account.vistaprint.com"
  ],
  "youneedabudget.com": [
    "ynab.com"
  ],
  "aa.com": [
    "americanairlines.com",
    "americanairlines.jp"
  ],
  "americanairlines.com": [
    "aa.com",
    "americanairlines.jp"
  ],
  "americanairlines.jp": [
    "aa.com",
    "americanairlines.com"
  ],
  "aetna.com": [
    "banneraetna.myplanportal.com"
  ],
  "banneraetna.myplanportal.com": [
    "aetna.com"
  ],
  "alibaba.com": [
    "aliexpress.com"
  ],
  "aliexpress.com": [
    "alibaba.com"
  ],
  "alltrails.com": [
    "alltrails.io"
  ],
  "alltrails.io": [
    "alltrails.com"
  ],
  "amazon.com": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.ae": [
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.com.au": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.com.br": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.ca": [
    "amazon.ae",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.fr": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.de": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.in": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.it": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.com.mx": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.nl": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.es": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.com.tr": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.co.uk": [
    "amazon.ae",
    "amazon.ca",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.sa": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.se",
    "amazon.sg"
  ],
  "amazon.sg": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.se"
  ],
  "amazon.se": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.pl",
    "amazon.sa",
    "amazon.sg"
  ],
  "amazon.pl": [
    "amazon.ae",
    "amazon.ca",
    "amazon.co.uk",
    "amazon.com",
    "amazon.com.au",
    "amazon.com.br",
    "amazon.com.mx",
    "amazon.com.tr",
    "amazon.de",
    "amazon.es",
    "amazon.fr",
    "amazon.in",
    "amazon.it",
    "amazon.nl",
    "amazon.sa",
    "amazon.se",
    "amazon.sg"
  ],
  "amcrestcloud.com": [
    "amcrestview.com"
  ],
  "amcrestview.com": [
    "amcrestcloud.com"
  ],
  "americastestkitchen.com": [
    "cookscountry.com",
    "cooksillustrated.com",
    "onlinecookingschool.com"
  ],
  "cooksillustrated.com": [
    "americastestkitchen.com",
    "cookscountry.com",
    "onlinecookingschool.com"
  ],
  "cookscountry.com": [
    "americastestkitchen.com",
    "cooksillustrated.com",
    "onlinecookingschool.com"
  ],
  "onlinecookingschool.com": [
    "americastestkitchen.com",
    "cookscountry.com",
    "cooksillustrated.com"
  ],
  "ameritrade.com": [
    "tdameritrade.com"
  ],
  "tdameritrade.com": [
    "ameritrade.com"
  ],
  "anylist.com": [
    "anylistapp.com"
  ],
  "anylistapp.com": [
    "anylist.com"
  ],
  "apple.com": [
    "icloud.com"
  ],
  "icloud.com": [
    "apple.com"
  ],
  "atlassian.com": [
    "trello.com"
  ],
  "trello.com": [
    "atlassian.com"
  ],
  "att.com": [
    "att.net"
  ],
  "att.net": [
    "att.com"
  ],
  "audi.com": [
    "audiusa.com"
  ],
  "audiusa.com": [
    "audi.com"
  ],
  "bahn.de": [
    "bahn.com"
  ],
  "bahn.com": [
    "bahn.de"
  ],
  "battle.net": [
    "blizzard.com"
  ],
  "blizzard.com": [
    "battle.net"
  ],
  "beachbodyondemand.com": [
    "teambeachbody.com"
  ],
  "teambeachbody.com": [
    "beachbodyondemand.com"
  ],
  "beavercreek.com": [
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "breckenridge.com": [
    "beavercreek.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "epicpass.com": [
    "beavercreek.com",
    "breckenridge.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "keystoneresort.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "kirkwood.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "mountsunapee.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "northstarcalifornia.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "okemo.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "parkcitymountain.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "skicb.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "skiheavenly.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "snow.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "stevenspass.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stowe.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "stowe.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "vail.com",
    "whistlerblackcomb.com"
  ],
  "vail.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "whistlerblackcomb.com"
  ],
  "whistlerblackcomb.com": [
    "beavercreek.com",
    "breckenridge.com",
    "epicpass.com",
    "keystoneresort.com",
    "kirkwood.com",
    "mountsunapee.com",
    "northstarcalifornia.com",
    "okemo.com",
    "parkcitymountain.com",
    "skicb.com",
    "skiheavenly.com",
    "snow.com",
    "stevenspass.com",
    "stowe.com",
    "vail.com"
  ],
  "boingo.com": [
    "boingohotspot.com"
  ],
  "boingohotspot.com": [
    "boingo.com"
  ],
  "bol.com": [
    "kobo.com"
  ],
  "kobo.com": [
    "bol.com"
  ],
  "boudinbakery.com": [
    "boudincatering.com"
  ],
  "boudincatering.com": [
    "boudinbakery.com"
  ],
  "braze.com": [
    "braze.eu"
  ],
  "braze.eu": [
    "braze.com"
  ],
  "capitalone.com": [
    "capitalone360.com"
  ],
  "capitalone360.com": [
    "capitalone.com"
  ],
  "cathaypacific.com": [
    "asiamiles.com"
  ],
  "asiamiles.com": [
    "cathaypacific.com"
  ],
  "citi.com": [
    "citibank.com",
    "citibankonline.com"
  ],
  "citibank.com": [
    "citi.com",
    "citibankonline.com"
  ],
  "citibankonline.com": [
    "citi.com",
    "citibank.com"
  ],
  "comcast.net": [
    "xfinity.com"
  ],
  "xfinity.com": [
    "comcast.net"
  ],
  "curbed.com": [
    "grubstreet.com",
    "nymag.com",
    "thecut.com",
    "vulture.com"
  ],
  "grubstreet.com": [
    "curbed.com",
    "nymag.com",
    "thecut.com",
    "vulture.com"
  ],
  "nymag.com": [
    "curbed.com",
    "grubstreet.com",
    "thecut.com",
    "vulture.com"
  ],
  "thecut.com": [
    "curbed.com",
    "grubstreet.com",
    "nymag.com",
    "vulture.com"
  ],
  "vulture.com": [
    "curbed.com",
    "grubstreet.com",
    "nymag.com",
    "thecut.com"
  ],
  "dinersclubnorthamerica.com": [
    "dinersclubus.com"
  ],
  "dinersclubus.com": [
    "dinersclubnorthamerica.com"
  ],
  "dish.com": [
    "dishnetwork.com",
    "mydish.com"
  ],
  "mydish.com": [
    "dish.com",
    "dishnetwork.com"
  ],
  "dishnetwork.com": [
    "dish.com",
    "mydish.com"
  ],
  "docusign.com": [
    "docusign.net"
  ],
  "docusign.net": [
    "docusign.com"
  ],
  "dropbox.com": [
    "getdropbox.com"
  ],
  "getdropbox.com": [
    "dropbox.com"
  ],
  "eater.com": [
    "polygon.com",
    "sbnation.com",
    "theverge.com"
  ],
  "polygon.com": [
    "eater.com",
    "sbnation.com",
    "theverge.com"
  ],
  "sbnation.com": [
    "eater.com",
    "polygon.com",
    "theverge.com"
  ],
  "theverge.com": [
    "eater.com",
    "polygon.com",
    "sbnation.com"
  ],
  "eurosport.no": [
    "eurosportplayer.com"
  ],
  "eurosportplayer.com": [
    "eurosport.no"
  ],
  "facebook.com": [
    "messenger.com"
  ],
  "messenger.com": [
    "facebook.com"
  ],
  "fandangonow.com": [
    "fandango.com"
  ],
  "fandango.com": [
    "fandangonow.com"
  ],
  "fidelity.com": [
    "fidelityinvestments.com"
  ],
  "fidelityinvestments.com": [
    "fidelity.com"
  ],
  "flyingblue.com": [
    "klm.com"
  ],
  "klm.com": [
    "flyingblue.com"
  ],
  "fnac.com": [
    "fnacspectacles.com"
  ],
  "fnacspectacles.com": [
    "fnac.com"
  ],
  "fourleaf.net": [
    "fourleaf.cl"
  ],
  "fourleaf.cl": [
    "fourleaf.net"
  ],
  "foursquare.com": [
    "swarmapp.com"
  ],
  "swarmapp.com": [
    "foursquare.com"
  ],
  "glassdoor.ca": [
    "glassdoor.com",
    "glassdoor.com.ar"
  ],
  "glassdoor.com": [
    "glassdoor.ca",
    "glassdoor.com.ar"
  ],
  "glassdoor.com.ar": [
    "glassdoor.ca",
    "glassdoor.com"
  ],
  "gogoair.com": [
    "gogoinflight.com"
  ],
  "gogoinflight.com": [
    "gogoair.com"
  ],
  "igen.fr": [
    "macg.co",
    "watchgeneration.fr"
  ],
  "watchgeneration.fr": [
    "igen.fr",
    "macg.co"
  ],
  "macg.co": [
    "igen.fr",
    "watchgeneration.fr"
  ],
  "ikonpass.com": [
    "skilynx.com"
  ],
  "skilynx.com": [
    "ikonpass.com"
  ],
  "intuit.com": [
    "mint.com"
  ],
  "mint.com": [
    "intuit.com"
  ],
  "kaiserpermanente.org": [
    "kp.org"
  ],
  "kp.org": [
    "kaiserpermanente.org"
  ],
  "kclibrary.overdrive.com": [
    "kclibrary.bibliocommons.com"
  ],
  "kclibrary.bibliocommons.com": [
    "kclibrary.overdrive.com"
  ],
  "kcls.bibliocommons.com": [
    "kcls.org",
    "kcls.overdrive.com"
  ],
  "kcls.overdrive.com": [
    "kcls.bibliocommons.com",
    "kcls.org"
  ],
  "kcls.org": [
    "kcls.bibliocommons.com",
    "kcls.overdrive.com"
  ],
  "liebherr.com": [
    "myliebherr.com"
  ],
  "myliebherr.com": [
    "liebherr.com"
  ],
  "logitech.com": [
    "astrogaming.com",
    "logi.com",
    "logitechg.com",
    "ultimateears.com"
  ],
  "logitechg.com": [
    "astrogaming.com",
    "logi.com",
    "logitech.com",
    "ultimateears.com"
  ],
  "logi.com": [
    "astrogaming.com",
    "logitech.com",
    "logitechg.com",
    "ultimateears.com"
  ],
  "astrogaming.com": [
    "logi.com",
    "logitech.com",
    "logitechg.com",
    "ultimateears.com"
  ],
  "ultimateears.com": [
    "astrogaming.com",
    "logi.com",
    "logitech.com",
    "logitechg.com"
  ],
  "lookmark.io": [
    "lookmark.link"
  ],
  "lookmark.link": [
    "lookmark.io"
  ],
  "lufthansa.com": [
    "miles-and-more.com"
  ],
  "miles-and-more.com": [
    "lufthansa.com"
  ],
  "marriott.com": [
    "marriottrewards.com",
    "ritzcarlton.com",
    "spg.com",
    "starwoodhotels.com"
  ],
  "marriottrewards.com": [
    "marriott.com",
    "ritzcarlton.com",
    "spg.com",
    "starwoodhotels.com"
  ],
  "ritzcarlton.com": [
    "marriott.com",
    "marriottrewards.com",
    "spg.com",
    "starwoodhotels.com"
  ],
  "spg.com": [
    "marriott.com",
    "marriottrewards.com",
    "ritzcarlton.com",
    "starwoodhotels.com"
  ],
  "starwoodhotels.com": [
    "marriott.com",
    "marriottrewards.com",
    "ritzcarlton.com",
    "spg.com"
  ],
  "microsoft.com": [
    "azure.com",
    "hotmail.com",
    "live.com",
    "microsoftonline.com",
    "office.com",
    "onenote.com",
    "skype.com"
  ],
  "live.com": [
    "azure.com",
    "hotmail.com",
    "microsoft.com",
    "microsoftonline.com",
    "office.com",
    "onenote.com",
    "skype.com"
  ],
  "microsoftonline.com": [
    "azure.com",
    "hotmail.com",
    "live.com",
    "microsoft.com",
    "office.com",
    "onenote.com",
    "skype.com"
  ],
  "office.com": [
    "azure.com",
    "hotmail.com",
    "live.com",
    "microsoft.com",
    "microsoftonline.com",
    "onenote.com",
    "skype.com"
  ],
  "skype.com": [
    "azure.com",
    "hotmail.com",
    "live.com",
    "microsoft.com",
    "microsoftonline.com",
    "office.com",
    "onenote.com"
  ],
  "onenote.com": [
    "azure.com",
    "hotmail.com",
    "live.com",
    "microsoft.com",
    "microsoftonline.com",
    "office.com",
    "skype.com"
  ],
  "hotmail.com": [
    "azure.com",
    "live.com",
    "microsoft.com",
    "microsoftonline.com",
    "office.com",
    "onenote.com",
    "skype.com"
  ],
  "azure.com": [
    "hotmail.com",
    "live.com",
    "microsoft.com",
    "microsoftonline.com",
    "office.com",
    "onenote.com",
    "skype.com"
  ],
  "minecraft.net": [
    "mojang.com"
  ],
  "mojang.com": [
    "minecraft.net"
  ],
  "mytotalconnectcomfort.com": [
    "tccna.honeywell.com"
  ],
  "tccna.honeywell.com": [
    "mytotalconnectcomfort.com"
  ],
  "myuhc.com": [
    "optum.com",
    "optumrx.com",
    "uhc.com"
  ],
  "uhc.com": [
    "myuhc.com",
    "optum.com",
    "optumrx.com"
  ],
  "optum.com": [
    "myuhc.com",
    "optumrx.com",
    "uhc.com"
  ],
  "optumrx.com": [
    "myuhc.com",
    "optum.com",
    "uhc.com"
  ],
  "neatorama.com": [
    "neatoshop.com"
  ],
  "neatoshop.com": [
    "neatorama.com"
  ],
  "newyorker.com": [
    "vanityfair.com"
  ],
  "vanityfair.com": [
    "newyorker.com"
  ],
  "nintendolife.com": [
    "purexbox.com",
    "pushsquare.com"
  ],
  "purexbox.com": [
    "nintendolife.com",
    "pushsquare.com"
  ],
  "pushsquare.com": [
    "nintendolife.com",
    "purexbox.com"
  ],
  "nokia.com": [
    "alcatel-lucent.com",
    "nsn-rdnet.net",
    "nsn.com"
  ],
  "alcatel-lucent.com": [
    "nokia.com",
    "nsn-rdnet.net",
    "nsn.com"
  ],
  "nsn-rdnet.net": [
    "alcatel-lucent.com",
    "nokia.com",
    "nsn.com"
  ],
  "nsn.com": [
    "alcatel-lucent.com",
    "nokia.com",
    "nsn-rdnet.net"
  ],
  "norwegian.com": [
    "norwegianreward.com"
  ],
  "norwegianreward.com": [
    "norwegian.com"
  ],
  "olo.com": [
    "olo.express"
  ],
  "olo.express": [
    "olo.com"
  ],
  "pocket.com": [
    "getpocket.com"
  ],
  "getpocket.com": [
    "pocket.com"
  ],
  "probikeshop.fr": [
    "bikeshop.es",
    "probikeshop.com",
    "probikeshop.it",
    "probikeshop.pt"
  ],
  "bikeshop.es": [
    "probikeshop.com",
    "probikeshop.fr",
    "probikeshop.it",
    "probikeshop.pt"
  ],
  "probikeshop.it": [
    "bikeshop.es",
    "probikeshop.com",
    "probikeshop.fr",
    "probikeshop.pt"
  ],
  "probikeshop.pt": [
    "bikeshop.es",
    "probikeshop.com",
    "probikeshop.fr",
    "probikeshop.it"
  ],
  "probikeshop.com": [
    "bikeshop.es",
    "probikeshop.fr",
    "probikeshop.it",
    "probikeshop.pt"
  ],
  "qnap.com": [
    "myqnapcloud.com"
  ],
  "myqnapcloud.com": [
    "qnap.com"
  ],
  "questdiagnostics.com": [
    "care360.com"
  ],
  "care360.com": [
    "questdiagnostics.com"
  ],
  "rocketaccount.com": [
    "rocketmortgage.com"
  ],
  "rocketmortgage.com": [
    "rocketaccount.com"
  ],
  "scholarshare529.com": [
    "secureaccountview.com"
  ],
  "secureaccountview.com": [
    "scholarshare529.com"
  ],
  "scoutingevent.com": [
    "campreservation.com"
  ],
  "campreservation.com": [
    "scoutingevent.com"
  ],
  "scribbr.com": [
    "scribbr.de",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.de": [
    "scribbr.com",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.dk": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.es": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.dk",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.fi": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.fr": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.it": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.nl",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.nl": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.no",
    "scribbr.se"
  ],
  "scribbr.no": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.se"
  ],
  "scribbr.se": [
    "scribbr.com",
    "scribbr.de",
    "scribbr.dk",
    "scribbr.es",
    "scribbr.fi",
    "scribbr.fr",
    "scribbr.it",
    "scribbr.nl",
    "scribbr.no"
  ],
  "seattle.bibliocommons.com": [
    "spl.org",
    "spl.overdrive.com"
  ],
  "spl.overdrive.com": [
    "seattle.bibliocommons.com",
    "spl.org"
  ],
  "spl.org": [
    "seattle.bibliocommons.com",
    "spl.overdrive.com"
  ],
  "sfpl.bibliocommons.com": [
    "sfpl.overdrive.com"
  ],
  "sfpl.overdrive.com": [
    "sfpl.bibliocommons.com"
  ],
  "slcl.overdrive.com": [
    "slcl.org"
  ],
  "slcl.org": [
    "slcl.overdrive.com"
  ],
  "slpl.bibliocommons.com": [
    "slpl.overdrive.com"
  ],
  "slpl.overdrive.com": [
    "slpl.bibliocommons.com"
  ],
  "sonyentertainmentnetwork.com": [
    "sony.com"
  ],
  "sony.com": [
    "sonyentertainmentnetwork.com"
  ],
  "spark.net": [
    "jdate.com"
  ],
  "jdate.com": [
    "spark.net"
  ],
  "spirit.com": [
    "spirit-airlines.com"
  ],
  "spirit-airlines.com": [
    "spirit.com"
  ],
  "springfield.overdrive.com": [
    "coolcat.org"
  ],
  "coolcat.org": [
    "springfield.overdrive.com"
  ],
  "square.com": [
    "squareup.com"
  ],
  "squareup.com": [
    "square.com"
  ],
  "stackoverflow.com": [
    "askubuntu.com",
    "serverfault.com",
    "stackexchange.com",
    "superuser.com"
  ],
  "askubuntu.com": [
    "serverfault.com",
    "stackexchange.com",
    "stackoverflow.com",
    "superuser.com"
  ],
  "serverfault.com": [
    "askubuntu.com",
    "stackexchange.com",
    "stackoverflow.com",
    "superuser.com"
  ],
  "stackexchange.com": [
    "askubuntu.com",
    "serverfault.com",
    "stackoverflow.com",
    "superuser.com"
  ],
  "superuser.com": [
    "askubuntu.com",
    "serverfault.com",
    "stackexchange.com",
    "stackoverflow.com"
  ],
  "telekom-dienste.de": [
    "accounts.login.idm.telekom.com"
  ],
  "accounts.login.idm.telekom.com": [
    "telekom-dienste.de"
  ],
  "tesla.com": [
    "teslamotors.com"
  ],
  "teslamotors.com": [
    "tesla.com"
  ],
  "ticketmaster.com": [
    "livenation.com"
  ],
  "livenation.com": [
    "ticketmaster.com"
  ],
  "tp-link.com": [
    "tplinkcloud.com"
  ],
  "tplinkcloud.com": [
    "tp-link.com"
  ],
  "turkishairlines.com": [
    "thy.com"
  ],
  "thy.com": [
    "turkishairlines.com"
  ],
  "ubi.com": [
    "ubisoft.com"
  ],
  "ubisoft.com": [
    "ubi.com"
  ],
  "umsystem.edu": [
    "missouri.edu",
    "mst.edu",
    "umkc.edu",
    "umsl.edu"
  ],
  "mst.edu": [
    "missouri.edu",
    "umkc.edu",
    "umsl.edu",
    "umsystem.edu"
  ],
  "umkc.edu": [
    "missouri.edu",
    "mst.edu",
    "umsl.edu",
    "umsystem.edu"
  ],
  "umsl.edu": [
    "missouri.edu",
    "mst.edu",
    "umkc.edu",
    "umsystem.edu"
  ],
  "missouri.edu": [
    "mst.edu",
    "umkc.edu",
    "umsl.edu",
    "umsystem.edu"
  ],
  "united.com": [
    "unitedwifi.com"
  ],
  "unitedwifi.com": [
    "united.com"
  ],
  "verizon.com": [
    "verizonwireless.com",
    "vzw.com"
  ],
  "verizonwireless.com": [
    "verizon.com",
    "vzw.com"
  ],
  "vzw.com": [
    "verizon.com",
    "verizonwireless.com"
  ],
  "wayfair.com": [
    "allmodern.com",
    "birchlane.com",
    "jossandmain.com",
    "perigold.com",
    "wayfair.ca"
  ],
  "wayfair.ca": [
    "allmodern.com",
    "birchlane.com",
    "jossandmain.com",
    "perigold.com",
    "wayfair.com"
  ],
  "jossandmain.com": [
    "allmodern.com",
    "birchlane.com",
    "perigold.com",
    "wayfair.ca",
    "wayfair.com"
  ],
  "allmodern.com": [
    "birchlane.com",
    "jossandmain.com",
    "perigold.com",
    "wayfair.ca",
    "wayfair.com"
  ],
  "perigold.com": [
    "allmodern.com",
    "birchlane.com",
    "jossandmain.com",
    "wayfair.ca",
    "wayfair.com"
  ],
  "birchlane.com": [
    "allmodern.com",
    "jossandmain.com",
    "perigold.com",
    "wayfair.ca",
    "wayfair.com"
  ],
  "wellsfargo.com": [
    "wellsfargoadvisors.com"
  ],
  "wellsfargoadvisors.com": [
    "wellsfargo.com"
  ],
  "wiimmfi.de": [
    "wii-homebrew.com"
  ],
  "wii-homebrew.com": [
    "wiimmfi.de"
  ],
  "williams-sonoma.com": [
    "markandgraham.com",
    "potterybarn.com",
    "westelm.com"
  ],
  "markandgraham.com": [
    "potterybarn.com",
    "westelm.com",
    "williams-sonoma.com"
  ],
  "potterybarn.com": [
    "markandgraham.com",
    "westelm.com",
    "williams-sonoma.com"
  ],
  "westelm.com": [
    "markandgraham.com",
    "potterybarn.com",
    "williams-sonoma.com"
  ],
  "wilson.com": [
    "atecsports.com",
    "demarini.com",
    "evoshield.com",
    "luxilon.com",
    "slugger.com"
  ],
  "slugger.com": [
    "atecsports.com",
    "demarini.com",
    "evoshield.com",
    "luxilon.com",
    "wilson.com"
  ],
  "atecsports.com": [
    "demarini.com",
    "evoshield.com",
    "luxilon.com",
    "slugger.com",
    "wilson.com"
  ],
  "demarini.com": [
    "atecsports.com",
    "evoshield.com",
    "luxilon.com",
    "slugger.com",
    "wilson.com"
  ],
  "evoshield.com": [
    "atecsports.com",
    "demarini.com",
    "luxilon.com",
    "slugger.com",
    "wilson.com"
  ],
  "luxilon.com": [
    "atecsports.com",
    "demarini.com",
    "evoshield.com",
    "slugger.com",
    "wilson.com"
  ],
  "worldlink.com.np": [
    "nettv.com.np"
  ],
  "nettv.com.np": [
    "worldlink.com.np"
  ],
  "wsj.com": [
    "dowjones.com"
  ],
  "dowjones.com": [
    "wsj.com"
  ],
  "zixmail.net": [
    "zixmessagecenter.com"
  ],
  "zixmessagecenter.com": [
    "zixmail.net"
  ],
  "sackrace.ai": [],
  "poalim.xyz": [
    "poalim.site"
  ],
  "poalim.site": [
    "poalim.xyz"
  ],
  "nacion.com": [
    "elfinancierocr.com",
    "lateja.cr"
  ],
  "lateja.cr": [
    "elfinancierocr.com",
    "nacion.com"
  ],
  "elfinancierocr.com": [
    "lateja.cr",
    "nacion.com"
  ],
  "wp.pl": [
    "abczdrowie.pl",
    "money.pl",
    "o2.pl",
    "pudelek.pl",
    "wpext.pl"
  ],
  "o2.pl": [
    "abczdrowie.pl",
    "money.pl",
    "pudelek.pl",
    "wp.pl",
    "wpext.pl"
  ],
  "pudelek.pl": [
    "abczdrowie.pl",
    "money.pl",
    "o2.pl",
    "wp.pl",
    "wpext.pl"
  ],
  "money.pl": [
    "abczdrowie.pl",
    "o2.pl",
    "pudelek.pl",
    "wp.pl",
    "wpext.pl"
  ],
  "abczdrowie.pl": [
    "money.pl",
    "o2.pl",
    "pudelek.pl",
    "wp.pl",
    "wpext.pl"
  ],
  "wpext.pl": [
    "abczdrowie.pl",
    "money.pl",
    "o2.pl",
    "pudelek.pl",
    "wp.pl"
  ],
  "cafemedia.com": [
    "cardsayings.net",
    "nourishingpursuits.com"
  ],
  "cardsayings.net": [
    "cafemedia.com",
    "nourishingpursuits.com"
  ],
  "nourishingpursuits.com": [
    "cafemedia.com",
    "cardsayings.net"
  ],
  "bild.de": [
    "autobild.de",
    "computerbild.de",
    "welt.de",
    "wieistmeineip.de"
  ],
  "welt.de": [
    "autobild.de",
    "bild.de",
    "computerbild.de",
    "wieistmeineip.de"
  ],
  "autobild.de": [
    "bild.de",
    "computerbild.de",
    "welt.de",
    "wieistmeineip.de"
  ],
  "computerbild.de": [
    "autobild.de",
    "bild.de",
    "welt.de",
    "wieistmeineip.de"
  ],
  "wieistmeineip.de": [
    "autobild.de",
    "bild.de",
    "computerbild.de",
    "welt.de"
  ],
  "gliadomain.com": [
    "salemoveadvisor.com",
    "salemovefinancial.com",
    "salemovetravel.com"
  ],
  "salemoveadvisor.com": [
    "gliadomain.com",
    "salemovefinancial.com",
    "salemovetravel.com"
  ],
  "salemovefinancial.com": [
    "gliadomain.com",
    "salemoveadvisor.com",
    "salemovetravel.com"
  ],
  "salemovetravel.com": [
    "gliadomain.com",
    "salemoveadvisor.com",
    "salemovefinancial.com"
  ],
  "hapara.com": [
    "mystudentdashboard.com",
    "teacherdashboard.com"
  ],
  "teacherdashboard.com": [
    "hapara.com",
    "mystudentdashboard.com"
  ],
  "mystudentdashboard.com": [
    "hapara.com",
    "teacherdashboard.com"
  ],
  "songstats.com": [
    "songshare.com"
  ],
  "songshare.com": [
    "songstats.com"
  ],
  "hindustantimes.com": [
    "desimartini.com",
    "healthshots.com",
    "livehindustan.com",
    "livemint.com",
    "ottplay.com"
  ],
  "livemint.com": [
    "desimartini.com",
    "healthshots.com",
    "hindustantimes.com",
    "livehindustan.com",
    "ottplay.com"
  ],
  "livehindustan.com": [
    "desimartini.com",
    "healthshots.com",
    "hindustantimes.com",
    "livemint.com",
    "ottplay.com"
  ],
  "healthshots.com": [
    "desimartini.com",
    "hindustantimes.com",
    "livehindustan.com",
    "livemint.com",
    "ottplay.com"
  ],
  "ottplay.com": [
    "desimartini.com",
    "healthshots.com",
    "hindustantimes.com",
    "livehindustan.com",
    "livemint.com"
  ],
  "desimartini.com": [
    "healthshots.com",
    "hindustantimes.com",
    "livehindustan.com",
    "livemint.com",
    "ottplay.com"
  ],
  "landyrev.com": [
    "landyrev.ru"
  ],
  "landyrev.ru": [
    "landyrev.com"
  ],
  "jagran.com": [
    "gujaratijagran.com",
    "punjabijagran.com"
  ],
  "gujaratijagran.com": [
    "jagran.com",
    "punjabijagran.com"
  ],
  "punjabijagran.com": [
    "gujaratijagran.com",
    "jagran.com"
  ],
  "mercadolibre.com": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadolivre.com": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadopago.com": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadoshops.com": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "portalinmobiliario.com": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "tucarro.com": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadoshops.com.ar": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadoshops.com.br": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadoshops.com.mx": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadoshops.cl": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "mercadoshops.com.co": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co",
    "tucarro.com.ve"
  ],
  "tucarro.com.co": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.ve"
  ],
  "tucarro.com.ve": [
    "mercadolibre.cl",
    "mercadolibre.co.cr",
    "mercadolibre.com",
    "mercadolibre.com.ar",
    "mercadolibre.com.bo",
    "mercadolibre.com.co",
    "mercadolibre.com.do",
    "mercadolibre.com.ec",
    "mercadolibre.com.gt",
    "mercadolibre.com.hn",
    "mercadolibre.com.mx",
    "mercadolibre.com.ni",
    "mercadolibre.com.pa",
    "mercadolibre.com.pe",
    "mercadolibre.com.py",
    "mercadolibre.com.sv",
    "mercadolibre.com.uy",
    "mercadolibre.com.ve",
    "mercadolivre.com",
    "mercadolivre.com.br",
    "mercadopago.cl",
    "mercadopago.com",
    "mercadopago.com.ar",
    "mercadopago.com.br",
    "mercadopago.com.co",
    "mercadopago.com.ec",
    "mercadopago.com.mx",
    "mercadopago.com.pe",
    "mercadopago.com.uy",
    "mercadopago.com.ve",
    "mercadoshops.cl",
    "mercadoshops.com",
    "mercadoshops.com.ar",
    "mercadoshops.com.br",
    "mercadoshops.com.co",
    "mercadoshops.com.mx",
    "portalinmobiliario.com",
    "tucarro.com",
    "tucarro.com.co"
  ],
  "joyreactor.cc": [
    "cookreactor.com",
    "joyreactor.com",
    "reactor.cc"
  ],
  "reactor.cc": [
    "cookreactor.com",
    "joyreactor.cc",
    "joyreactor.com"
  ],
  "cookreactor.com": [
    "joyreactor.cc",
    "joyreactor.com",
    "reactor.cc"
  ],
  "joyreactor.com": [
    "cookreactor.com",
    "joyreactor.cc",
    "reactor.cc"
  ],
  "unotv.com": [
    "clarosports.com"
  ],
  "clarosports.com": [
    "unotv.com"
  ],
  "idbs-cloud.com": [
    "eworkbookcloud.com",
    "eworkbookrequest.com",
    "idbs-dev.com",
    "idbs-eworkbook.com",
    "idbs-staging.com"
  ],
  "idbs-dev.com": [
    "eworkbookcloud.com",
    "eworkbookrequest.com",
    "idbs-cloud.com",
    "idbs-eworkbook.com",
    "idbs-staging.com"
  ],
  "idbs-staging.com": [
    "eworkbookcloud.com",
    "eworkbookrequest.com",
    "idbs-cloud.com",
    "idbs-dev.com",
    "idbs-eworkbook.com"
  ],
  "idbs-eworkbook.com": [
    "eworkbookcloud.com",
    "eworkbookrequest.com",
    "idbs-cloud.com",
    "idbs-dev.com",
    "idbs-staging.com"
  ],
  "eworkbookcloud.com": [
    "eworkbookrequest.com",
    "idbs-cloud.com",
    "idbs-dev.com",
    "idbs-eworkbook.com",
    "idbs-staging.com"
  ],
  "eworkbookrequest.com": [
    "eworkbookcloud.com",
    "idbs-cloud.com",
    "idbs-dev.com",
    "idbs-eworkbook.com",
    "idbs-staging.com"
  ],
  "mightytext.net": [],
  "vwo.com": [
    "wingify.com"
  ],
  "wingify.com": [
    "vwo.com"
  ],
  "wildix.com": [
    "wildixin.com"
  ],
  "wildixin.com": [
    "wildix.com"
  ],
  "timesinternet.in": [
    "cricbuzz.com",
    "economictimes.com",
    "indiatimes.com",
    "samayam.com",
    "timesofindia.com"
  ],
  "indiatimes.com": [
    "cricbuzz.com",
    "economictimes.com",
    "samayam.com",
    "timesinternet.in",
    "timesofindia.com"
  ],
  "timesofindia.com": [
    "cricbuzz.com",
    "economictimes.com",
    "indiatimes.com",
    "samayam.com",
    "timesinternet.in"
  ],
  "economictimes.com": [
    "cricbuzz.com",
    "indiatimes.com",
    "samayam.com",
    "timesinternet.in",
    "timesofindia.com"
  ],
  "samayam.com": [
    "cricbuzz.com",
    "economictimes.com",
    "indiatimes.com",
    "timesinternet.in",
    "timesofindia.com"
  ],
  "cricbuzz.com": [
    "economictimes.com",
    "indiatimes.com",
    "samayam.com",
    "timesinternet.in",
    "timesofindia.com"
  ],
  "hc1.com": [
    "hc1.global"
  ],
  "hc1.global": [
    "hc1.com"
  ],
  "kompas.com": [
    "bolasport.com",
    "grid.id",
    "kompas.tv",
    "kompasiana.com",
    "tribunnews.com"
  ],
  "tribunnews.com": [
    "bolasport.com",
    "grid.id",
    "kompas.com",
    "kompas.tv",
    "kompasiana.com"
  ],
  "grid.id": [
    "bolasport.com",
    "kompas.com",
    "kompas.tv",
    "kompasiana.com",
    "tribunnews.com"
  ],
  "bolasport.com": [
    "grid.id",
    "kompas.com",
    "kompas.tv",
    "kompasiana.com",
    "tribunnews.com"
  ],
  "kompasiana.com": [
    "bolasport.com",
    "grid.id",
    "kompas.com",
    "kompas.tv",
    "tribunnews.com"
  ],
  "kompas.tv": [
    "bolasport.com",
    "grid.id",
    "kompas.com",
    "kompasiana.com",
    "tribunnews.com"
  ],
  "journaldesfemmes.com": [
    "commentcamarche.com",
    "commentcamarche.net",
    "journaldesfemmes.fr",
    "journaldunet.com",
    "journaldunet.fr",
    "linternaute.com",
    "linternaute.fr",
    "phonandroid.com"
  ],
  "commentcamarche.net": [
    "commentcamarche.com",
    "journaldesfemmes.com",
    "journaldesfemmes.fr",
    "journaldunet.com",
    "journaldunet.fr",
    "linternaute.com",
    "linternaute.fr",
    "phonandroid.com"
  ],
  "linternaute.com": [
    "commentcamarche.com",
    "commentcamarche.net",
    "journaldesfemmes.com",
    "journaldesfemmes.fr",
    "journaldunet.com",
    "journaldunet.fr",
    "linternaute.fr",
    "phonandroid.com"
  ],
  "journaldunet.com": [
    "commentcamarche.com",
    "commentcamarche.net",
    "journaldesfemmes.com",
    "journaldesfemmes.fr",
    "journaldunet.fr",
    "linternaute.com",
    "linternaute.fr",
    "phonandroid.com"
  ],
  "phonandroid.com": [
    "commentcamarche.com",
    "commentcamarche.net",
    "journaldesfemmes.com",
    "journaldesfemmes.fr",
    "journaldunet.com",
    "journaldunet.fr",
    "linternaute.com",
    "linternaute.fr"
  ],
  "commentcamarche.com": [
    "commentcamarche.net",
    "journaldesfemmes.com",
    "journaldesfemmes.fr",
    "journaldunet.com",
    "journaldunet.fr",
    "linternaute.com",
    "linternaute.fr",
    "phonandroid.com"
  ],
  "journaldesfemmes.fr": [
    "commentcamarche.com",
    "commentcamarche.net",
    "journaldesfemmes.com",
    "journaldunet.com",
    "journaldunet.fr",
    "linternaute.com",
    "linternaute.fr",
    "phonandroid.com"
  ],
  "linternaute.fr": [
    "commentcamarche.com",
    "commentcamarche.net",
    "journaldesfemmes.com",
    "journaldesfemmes.fr",
    "journaldunet.com",
    "journaldunet.fr",
    "linternaute.com",
    "phonandroid.com"
  ],
  "journaldunet.fr": [
    "commentcamarche.com",
    "commentcamarche.net",
    "journaldesfemmes.com",
    "journaldesfemmes.fr",
    "journaldunet.com",
    "linternaute.com",
    "linternaute.fr",
    "phonandroid.com"
  ],
  "johndeere.com": [
    "deere.com"
  ],
  "deere.com": [
    "johndeere.com"
  ],
  "lanacion.com.ar": [
    "bonvivir.com"
  ],
  "bonvivir.com": [
    "lanacion.com.ar"
  ],
  "nien.com": [
    "chennien.com",
    "nien.co",
    "nien.org"
  ],
  "chennien.com": [
    "nien.co",
    "nien.com",
    "nien.org"
  ],
  "nien.org": [
    "chennien.com",
    "nien.co",
    "nien.com"
  ],
  "nien.co": [
    "chennien.com",
    "nien.com",
    "nien.org"
  ],
  "hearty.me": [
    "alice.tw",
    "hearty.app",
    "hearty.gift",
    "heartymail.com",
    "hj.rs",
    "jiayi.life",
    "miss.com.tw"
  ],
  "hearty.app": [
    "alice.tw",
    "hearty.gift",
    "hearty.me",
    "heartymail.com",
    "hj.rs",
    "jiayi.life",
    "miss.com.tw"
  ],
  "hearty.gift": [
    "alice.tw",
    "hearty.app",
    "hearty.me",
    "heartymail.com",
    "hj.rs",
    "jiayi.life",
    "miss.com.tw"
  ],
  "hj.rs": [
    "alice.tw",
    "hearty.app",
    "hearty.gift",
    "hearty.me",
    "heartymail.com",
    "jiayi.life",
    "miss.com.tw"
  ],
  "heartymail.com": [
    "alice.tw",
    "hearty.app",
    "hearty.gift",
    "hearty.me",
    "hj.rs",
    "jiayi.life",
    "miss.com.tw"
  ],
  "alice.tw": [
    "hearty.app",
    "hearty.gift",
    "hearty.me",
    "heartymail.com",
    "hj.rs",
    "jiayi.life",
    "miss.com.tw"
  ],
  "jiayi.life": [
    "alice.tw",
    "hearty.app",
    "hearty.gift",
    "hearty.me",
    "heartymail.com",
    "hj.rs",
    "miss.com.tw"
  ],
  "miss.com.tw": [
    "alice.tw",
    "hearty.app",
    "hearty.gift",
    "hearty.me",
    "heartymail.com",
    "hj.rs",
    "jiayi.life"
  ],
  "talkdeskqaid.com": [
    "trytalkdesk.com"
  ],
  "trytalkdesk.com": [
    "talkdeskqaid.com"
  ],
  "talkdeskstgid.com": [
    "gettalkdesk.com"
  ],
  "gettalkdesk.com": [
    "talkdeskstgid.com"
  ],
  "onet.pl": [
    "businessinsider.com.pl",
    "fakt.pl",
    "medonet.pl",
    "plejada.pl"
  ],
  "fakt.pl": [
    "businessinsider.com.pl",
    "medonet.pl",
    "onet.pl",
    "plejada.pl"
  ],
  "businessinsider.com.pl": [
    "fakt.pl",
    "medonet.pl",
    "onet.pl",
    "plejada.pl"
  ],
  "medonet.pl": [
    "businessinsider.com.pl",
    "fakt.pl",
    "onet.pl",
    "plejada.pl"
  ],
  "plejada.pl": [
    "businessinsider.com.pl",
    "fakt.pl",
    "medonet.pl",
    "onet.pl"
  ],
  "elpais.com.uy": [
    "clubelpais.com.uy",
    "elpais.uy",
    "gallito.com.uy",
    "paula.com.uy"
  ],
  "clubelpais.com.uy": [
    "elpais.com.uy",
    "elpais.uy",
    "gallito.com.uy",
    "paula.com.uy"
  ],
  "paula.com.uy": [
    "clubelpais.com.uy",
    "elpais.com.uy",
    "elpais.uy",
    "gallito.com.uy"
  ],
  "gallito.com.uy": [
    "clubelpais.com.uy",
    "elpais.com.uy",
    "elpais.uy",
    "paula.com.uy"
  ],
  "elpais.uy": [
    "clubelpais.com.uy",
    "elpais.com.uy",
    "gallito.com.uy",
    "paula.com.uy"
  ],
  "libero.it": [
    "supereva.it"
  ],
  "supereva.it": [
    "libero.it"
  ],
  "rws1nvtvt.com": [
    "rws2nvtvt.com",
    "rws3nvtvt.com"
  ],
  "rws2nvtvt.com": [
    "rws1nvtvt.com",
    "rws3nvtvt.com"
  ],
  "rws3nvtvt.com": [
    "rws1nvtvt.com",
    "rws2nvtvt.com"
  ],
  "stripe.com": [],
  "repid.org": [
    "human-talk.org",
    "reshim.org"
  ],
  "reshim.org": [
    "human-talk.org",
    "repid.org"
  ],
  "human-talk.org": [
    "repid.org",
    "reshim.org"
  ],
  "ya.ru": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.ru": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.net": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "turbopages.org": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "auto.ru": [
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "kinopoisk.ru": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "clck.ru": [
    "auto.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "edadeal.ru": [
    "auto.ru",
    "clck.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "webvisor.com": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yastatic.net": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz"
  ],
  "ya.cc": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.az": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.by": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.kz": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.md": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.tj": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.tm": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.uz": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yastatic.net"
  ],
  "yandex.st": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.com": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com.am",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.com.am": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.ru",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "yandex.com.ru": [
    "auto.ru",
    "clck.ru",
    "edadeal.ru",
    "kinopoisk.ru",
    "turbopages.org",
    "webvisor.com",
    "ya.cc",
    "ya.ru",
    "yandex.az",
    "yandex.by",
    "yandex.com",
    "yandex.com.am",
    "yandex.kz",
    "yandex.md",
    "yandex.net",
    "yandex.ru",
    "yandex.st",
    "yandex.tj",
    "yandex.tm",
    "yandex.uz",
    "yastatic.net"
  ],
  "victorymedium.com": [
    "standardsandpraiserepurpose.com"
  ],
  "standardsandpraiserepurpose.com": [
    "victorymedium.com"
  ],
  "startupislandtaiwan.com": [
    "startupislandtaiwan.net",
    "startupislandtaiwan.org"
  ],
  "startupislandtaiwan.net": [
    "startupislandtaiwan.com",
    "startupislandtaiwan.org"
  ],
  "startupislandtaiwan.org": [
    "startupislandtaiwan.com",
    "startupislandtaiwan.net"
  ],
  "carcostadvisor.com": [
    "carcostadvisor.be",
    "carcostadvisor.fr"
  ],
  "carcostadvisor.be": [
    "carcostadvisor.com",
    "carcostadvisor.fr"
  ],
  "carcostadvisor.fr": [
    "carcostadvisor.be",
    "carcostadvisor.com"
  ],
  "caracoltv.com": [
    "bluradio.com",
    "bumbox.com",
    "hjck.com",
    "noticiascaracol.com",
    "shock.co"
  ],
  "noticiascaracol.com": [
    "bluradio.com",
    "bumbox.com",
    "caracoltv.com",
    "hjck.com",
    "shock.co"
  ],
  "bluradio.com": [
    "bumbox.com",
    "caracoltv.com",
    "hjck.com",
    "noticiascaracol.com",
    "shock.co"
  ],
  "shock.co": [
    "bluradio.com",
    "bumbox.com",
    "caracoltv.com",
    "hjck.com",
    "noticiascaracol.com"
  ],
  "bumbox.com": [
    "bluradio.com",
    "caracoltv.com",
    "hjck.com",
    "noticiascaracol.com",
    "shock.co"
  ],
  "hjck.com": [
    "bluradio.com",
    "bumbox.com",
    "caracoltv.com",
    "noticiascaracol.com",
    "shock.co"
  ],
  "max.auto": [
    "firstlook.biz"
  ],
  "firstlook.biz": [
    "max.auto"
  ],
  "gridgames.app": [
    "wordle.at"
  ],
  "wordle.at": [
    "gridgames.app"
  ],
  "blackrock.com": [
    "blackrockadvisorelite.it",
    "cachematrix.com",
    "efront.com",
    "etfacademy.it",
    "ishares.com"
  ],
  "blackrockadvisorelite.it": [
    "blackrock.com",
    "cachematrix.com",
    "efront.com",
    "etfacademy.it",
    "ishares.com"
  ],
  "cachematrix.com": [
    "blackrock.com",
    "blackrockadvisorelite.it",
    "efront.com",
    "etfacademy.it",
    "ishares.com"
  ],
  "efront.com": [
    "blackrock.com",
    "blackrockadvisorelite.it",
    "cachematrix.com",
    "etfacademy.it",
    "ishares.com"
  ],
  "etfacademy.it": [
    "blackrock.com",
    "blackrockadvisorelite.it",
    "cachematrix.com",
    "efront.com",
    "ishares.com"
  ],
  "ishares.com": [
    "blackrock.com",
    "blackrockadvisorelite.it",
    "cachematrix.com",
    "efront.com",
    "etfacademy.it"
  ],
  "tvn.pl": [
    "player.pl",
    "tvn24.pl",
    "zdrowietvn.pl"
  ],
  "player.pl": [
    "tvn.pl",
    "tvn24.pl",
    "zdrowietvn.pl"
  ],
  "tvn24.pl": [
    "player.pl",
    "tvn.pl",
    "zdrowietvn.pl"
  ],
  "zdrowietvn.pl": [
    "player.pl",
    "tvn.pl",
    "tvn24.pl"
  ],
  "zalo.me": [
    "baomoi.com",
    "smoney.vn",
    "zingmp3.vn"
  ],
  "zingmp3.vn": [
    "baomoi.com",
    "smoney.vn",
    "zalo.me"
  ],
  "baomoi.com": [
    "smoney.vn",
    "zalo.me",
    "zingmp3.vn"
  ],
  "smoney.vn": [
    "baomoi.com",
    "zalo.me",
    "zingmp3.vn"
  ],
  "finn.no": [
    "mittanbud.no",
    "prisjakt.no"
  ],
  "prisjakt.no": [
    "finn.no",
    "mittanbud.no"
  ],
  "mittanbud.no": [
    "finn.no",
    "prisjakt.no"
  ],
  "laprensagrafica.com": [
    "eleconomista.net",
    "elgrafico.com",
    "ella.sv",
    "grupolpg.sv"
  ],
  "elgrafico.com": [
    "eleconomista.net",
    "ella.sv",
    "grupolpg.sv",
    "laprensagrafica.com"
  ],
  "eleconomista.net": [
    "elgrafico.com",
    "ella.sv",
    "grupolpg.sv",
    "laprensagrafica.com"
  ],
  "ella.sv": [
    "eleconomista.net",
    "elgrafico.com",
    "grupolpg.sv",
    "laprensagrafica.com"
  ],
  "grupolpg.sv": [
    "eleconomista.net",
    "elgrafico.com",
    "ella.sv",
    "laprensagrafica.com"
  ],
  "kaksya.in": [
    "nidhiacademyonline.com"
  ],
  "nidhiacademyonline.com": [
    "kaksya.in"
  ],
  "vrt.be": [
    "dewarmsteweek.be",
    "een.be",
    "radio1.be",
    "radio2.be",
    "sporza.be"
  ],
  "dewarmsteweek.be": [
    "een.be",
    "radio1.be",
    "radio2.be",
    "sporza.be",
    "vrt.be"
  ],
  "sporza.be": [
    "dewarmsteweek.be",
    "een.be",
    "radio1.be",
    "radio2.be",
    "vrt.be"
  ],
  "een.be": [
    "dewarmsteweek.be",
    "radio1.be",
    "radio2.be",
    "sporza.be",
    "vrt.be"
  ],
  "radio2.be": [
    "dewarmsteweek.be",
    "een.be",
    "radio1.be",
    "sporza.be",
    "vrt.be"
  ],
  "radio1.be": [
    "dewarmsteweek.be",
    "een.be",
    "radio2.be",
    "sporza.be",
    "vrt.be"
  ],
  "nvidia.com": [
    "geforcenow.com"
  ],
  "geforcenow.com": [
    "nvidia.com"
  ],
  "sapo.pt": [
    "meo.pt",
    "sapo.io"
  ],
  "meo.pt": [
    "sapo.io",
    "sapo.pt"
  ],
  "sapo.io": [
    "meo.pt",
    "sapo.pt"
  ],
  "tolteck.com": [
    "tolteck.app"
  ],
  "tolteck.app": [
    "tolteck.com"
  ],
  "p24.hu": [
    "24.hu",
    "hazipatika.com",
    "nlc.hu",
    "nosalty.hu",
    "startlap.hu"
  ],
  "24.hu": [
    "hazipatika.com",
    "nlc.hu",
    "nosalty.hu",
    "p24.hu",
    "startlap.hu"
  ],
  "startlap.hu": [
    "24.hu",
    "hazipatika.com",
    "nlc.hu",
    "nosalty.hu",
    "p24.hu"
  ],
  "nlc.hu": [
    "24.hu",
    "hazipatika.com",
    "nosalty.hu",
    "p24.hu",
    "startlap.hu"
  ],
  "hazipatika.com": [
    "24.hu",
    "nlc.hu",
    "nosalty.hu",
    "p24.hu",
    "startlap.hu"
  ],
  "nosalty.hu": [
    "24.hu",
    "hazipatika.com",
    "nlc.hu",
    "p24.hu",
    "startlap.hu"
  ],
  "cognitiveai.ru": [
    "cognitive-ai.ru"
  ],
  "cognitive-ai.ru": [
    "cognitiveai.ru"
  ],
  "citybibleforum.org": [
    "thirdspace.org.au"
  ],
  "thirdspace.org.au": [
    "citybibleforum.org"
  ],
  "p106.net": [
    "smpn106jkt.sch.id"
  ],
  "smpn106jkt.sch.id": [
    "p106.net"
  ],
  "indiatoday.in": [
    "aajtak.in",
    "businesstoday.in",
    "gnttv.com",
    "indiatodayne.in",
    "intoday.in"
  ],
  "aajtak.in": [
    "businesstoday.in",
    "gnttv.com",
    "indiatoday.in",
    "indiatodayne.in",
    "intoday.in"
  ],
  "businesstoday.in": [
    "aajtak.in",
    "gnttv.com",
    "indiatoday.in",
    "indiatodayne.in",
    "intoday.in"
  ],
  "intoday.in": [
    "aajtak.in",
    "businesstoday.in",
    "gnttv.com",
    "indiatoday.in",
    "indiatodayne.in"
  ],
  "gnttv.com": [
    "aajtak.in",
    "businesstoday.in",
    "indiatoday.in",
    "indiatodayne.in",
    "intoday.in"
  ],
  "indiatodayne.in": [
    "aajtak.in",
    "businesstoday.in",
    "gnttv.com",
    "indiatoday.in",
    "intoday.in"
  ],
  "naukri.com": [
    "ambitionbox.com",
    "infoedgeindia.com"
  ],
  "ambitionbox.com": [
    "infoedgeindia.com",
    "naukri.com"
  ],
  "infoedgeindia.com": [
    "ambitionbox.com",
    "naukri.com"
  ],
  "text.com": [
    "chatbot.com",
    "helpdesk.com",
    "knowledgebase.com",
    "livechat.com",
    "livechatinc.com",
    "openwidget.com"
  ],
  "livechat.com": [
    "chatbot.com",
    "helpdesk.com",
    "knowledgebase.com",
    "livechatinc.com",
    "openwidget.com",
    "text.com"
  ],
  "helpdesk.com": [
    "chatbot.com",
    "knowledgebase.com",
    "livechat.com",
    "livechatinc.com",
    "openwidget.com",
    "text.com"
  ],
  "chatbot.com": [
    "helpdesk.com",
    "knowledgebase.com",
    "livechat.com",
    "livechatinc.com",
    "openwidget.com",
    "text.com"
  ],
  "livechatinc.com": [
    "chatbot.com",
    "helpdesk.com",
    "knowledgebase.com",
    "livechat.com",
    "openwidget.com",
    "text.com"
  ],
  "knowledgebase.com": [
    "chatbot.com",
    "helpdesk.com",
    "livechat.com",
    "livechatinc.com",
    "openwidget.com",
    "text.com"
  ],
  "openwidget.com": [
    "chatbot.com",
    "helpdesk.com",
    "knowledgebase.com",
    "livechat.com",
    "livechatinc.com",
    "text.com"
  ],
  "thejournal.ie": [
    "the42.ie"
  ],
  "the42.ie": [
    "thejournal.ie"
  ],
  "html-load.com": [
    "07c225f3.online",
    "content-loader.com",
    "css-load.com",
    "html-load.cc",
    "img-load.com"
  ],
  "css-load.com": [
    "07c225f3.online",
    "content-loader.com",
    "html-load.cc",
    "html-load.com",
    "img-load.com"
  ],
  "img-load.com": [
    "07c225f3.online",
    "content-loader.com",
    "css-load.com",
    "html-load.cc",
    "html-load.com"
  ],
  "content-loader.com": [
    "07c225f3.online",
    "css-load.com",
    "html-load.cc",
    "html-load.com",
    "img-load.com"
  ],
  "07c225f3.online": [
    "content-loader.com",
    "css-load.com",
    "html-load.cc",
    "html-load.com",
    "img-load.com"
  ],
  "html-load.cc": [
    "07c225f3.online",
    "content-loader.com",
    "css-load.com",
    "html-load.com",
    "img-load.com"
  ],
  "interia.pl": [
    "deccoria.pl",
    "pomponik.pl",
    "smaker.pl",
    "terazgotuje.pl",
    "top.pl"
  ],
  "pomponik.pl": [
    "deccoria.pl",
    "interia.pl",
    "smaker.pl",
    "terazgotuje.pl",
    "top.pl"
  ],
  "deccoria.pl": [
    "interia.pl",
    "pomponik.pl",
    "smaker.pl",
    "terazgotuje.pl",
    "top.pl"
  ],
  "top.pl": [
    "deccoria.pl",
    "interia.pl",
    "pomponik.pl",
    "smaker.pl",
    "terazgotuje.pl"
  ],
  "smaker.pl": [
    "deccoria.pl",
    "interia.pl",
    "pomponik.pl",
    "terazgotuje.pl",
    "top.pl"
  ],
  "terazgotuje.pl": [
    "deccoria.pl",
    "interia.pl",
    "pomponik.pl",
    "smaker.pl",
    "top.pl"
  ],
  "graziadaily.co.uk": [
    "closeronline.co.uk",
    "heatworld.com",
    "motherandbaby.com",
    "takeabreak.co.uk",
    "yours.co.uk"
  ],
  "heatworld.com": [
    "closeronline.co.uk",
    "graziadaily.co.uk",
    "motherandbaby.com",
    "takeabreak.co.uk",
    "yours.co.uk"
  ],
  "closeronline.co.uk": [
    "graziadaily.co.uk",
    "heatworld.com",
    "motherandbaby.com",
    "takeabreak.co.uk",
    "yours.co.uk"
  ],
  "yours.co.uk": [
    "closeronline.co.uk",
    "graziadaily.co.uk",
    "heatworld.com",
    "motherandbaby.com",
    "takeabreak.co.uk"
  ],
  "motherandbaby.com": [
    "closeronline.co.uk",
    "graziadaily.co.uk",
    "heatworld.com",
    "takeabreak.co.uk",
    "yours.co.uk"
  ],
  "takeabreak.co.uk": [
    "closeronline.co.uk",
    "graziadaily.co.uk",
    "heatworld.com",
    "motherandbaby.com",
    "yours.co.uk"
  ],
  "drimer.io": [
    "drimer.travel"
  ],
  "drimer.travel": [
    "drimer.io"
  ],
  "zoom.us": [
    "zoom.com"
  ],
  "zoom.com": [
    "zoom.us"
  ]
};
function getRelatedDomains(domain) {
  const relatedDomains = getRelatedDomainsDictionary()[domain];
  return relatedDomains;
}
function getRelatedDomainsDictionary() {
  return relatedDomainsDictionary;
}
var assertNever$1 = {};
Object.defineProperty(assertNever$1, "__esModule", { value: true });
function assertNever(value, noThrow) {
  if (noThrow) {
    return value;
  }
  throw new Error("Unhandled discriminated union member: " + JSON.stringify(value));
}
assertNever$1.assertNever = assertNever;
assertNever$1.default = assertNever;
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function a$1(t2, e2) {
  const n2 = getNormalizedPatternParts(e2, {
    usePunycode: true
  });
  if (n2.port !== "" && n2.port !== t2.url.port)
    return null;
  const i = M(t2, n2.hostname);
  if (i === null)
    return null;
  const s2 = w$2(t2.url.pathname, n2.pathname);
  return i * 100 + s2;
}
function M(t2, e2) {
  if (e2 = S(e2), !e2 || !t2.url.hostname.endsWith(e2))
    return null;
  const n2 = psl.parse(e2);
  if (n2.error || // either both are on the psl, or none is
  t2.psl.listed !== n2.listed || t2.psl.domain !== n2.domain)
    return null;
  const i = t2.psl.listed ? t2.psl.subdomain : t2.url.hostname, s2 = n2.listed ? n2.subdomain : e2, r2 = (i == null ? void 0 : i.split(".")) ?? [], u2 = (s2 == null ? void 0 : s2.split(".")) ?? [];
  r2.reverse(), u2.reverse();
  const l2 = v$2(r2, u2);
  return l2 === null ? null : l2 + 1;
}
function S(t2) {
  for (; t2.startsWith("www."); )
    t2 = t2.substring(4);
  return t2;
}
function w$2(t2, e2) {
  const n2 = m$3(e2), i = m$3(t2), s2 = p$2(i, n2, true), r2 = s2.findIndex(([l2, o2]) => l2 !== o2);
  if (r2 === -1)
    return n2.length;
  const [, u2] = s2[r2];
  if (u2 === void 0)
    return n2.length;
  if (r2 !== 0) {
    const l2 = n2.length - r2;
    return -(l2 / (l2 + 1));
  }
  return -n2.length;
}
function f$3(t2) {
  let e2;
  try {
    e2 = new URL(t2);
  } catch {
    return;
  }
  const n2 = x$2(e2.hostname);
  if (!n2.error)
    return {
      url: e2,
      psl: n2
    };
}
const h$3 = /* @__PURE__ */ new Map();
function x$2(t2) {
  const e2 = h$3.get(t2);
  if (e2)
    return e2;
  const n2 = psl.parse(t2);
  return h$3.set(t2, n2), n2;
}
function m$3(t2) {
  const e2 = t2.replace(/^\/+|\/+$/g, "");
  return e2 === "" ? [] : e2.split("/");
}
function v$2(t2, e2) {
  const n2 = p$2(t2, e2, true), i = n2.findIndex(([r2, u2]) => r2 !== u2);
  if (i === -1)
    return e2.length;
  const [, s2] = n2[i];
  return s2 === void 0 ? e2.length : null;
}
function p$2(t2, e2, n2) {
  const s2 = (n2 ? Math.max : Math.min)(t2.length, e2.length);
  return Array.from(Array(s2).keys()).map((r2) => [t2[r2], e2[r2]]);
}
var classnames = { exports: {} };
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(module2) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg) && arg.length) {
          var inner = classNames2.apply(null, arg);
          if (inner) {
            classes.push(inner);
          }
        } else if (argType === "object") {
          for (var key in arg) {
            if (hasOwn2.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module2.exports) {
      classNames2.default = classNames2;
      module2.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
var lib$1 = {};
var useMedia = {};
var utilities = {};
var camelToHyphen$1 = {};
Object.defineProperty(camelToHyphen$1, "__esModule", { value: true });
function camelToHyphen(camelString) {
  return camelString.replace(/[A-Z]/g, function(string) {
    return "-" + string.toLowerCase();
  }).toLowerCase();
}
camelToHyphen$1.default = camelToHyphen;
var queryObjectToString$1 = {};
Object.defineProperty(queryObjectToString$1, "__esModule", { value: true });
var camelToHyphen_1$1 = camelToHyphen$1;
var QUERY_COMBINATOR = " and ";
function queryObjectToString(query) {
  if (typeof query === "string") {
    return query;
  }
  return Object.entries(query).map(function(_a2) {
    var feature = _a2[0], value = _a2[1];
    var convertedFeature = camelToHyphen_1$1.default(feature);
    var convertedValue = value;
    if (typeof convertedValue === "boolean") {
      return convertedValue ? convertedFeature : "not " + convertedFeature;
    }
    if (typeof convertedValue === "number" && /[height|width]$/.test(convertedFeature)) {
      convertedValue = convertedValue + "px";
    }
    return "(" + convertedFeature + ": " + convertedValue + ")";
  }).join(QUERY_COMBINATOR);
}
queryObjectToString$1.default = queryObjectToString;
var noop$4 = {};
Object.defineProperty(noop$4, "__esModule", { value: true });
function noop$3() {
}
noop$4.default = noop$3;
Object.defineProperty(utilities, "__esModule", { value: true });
var camelToHyphen_1 = camelToHyphen$1;
utilities.camelToHyphen = camelToHyphen_1.default;
var queryObjectToString_1 = queryObjectToString$1;
utilities.queryObjectToString = queryObjectToString_1.default;
var noop_1 = noop$4;
utilities.noop = noop_1.default;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var react_1 = reactExports;
  var utilities_1 = utilities;
  exports2.mockMediaQueryList = {
    media: "",
    matches: false,
    onchange: utilities_1.noop,
    addListener: utilities_1.noop,
    removeListener: utilities_1.noop,
    addEventListener: utilities_1.noop,
    removeEventListener: utilities_1.noop,
    dispatchEvent: function(_2) {
      return true;
    }
  };
  var createUseMedia = function(effect) {
    return function(rawQuery, defaultState) {
      if (defaultState === void 0) {
        defaultState = false;
      }
      var _a2 = react_1.useState(defaultState), state = _a2[0], setState = _a2[1];
      var query = utilities_1.queryObjectToString(rawQuery);
      effect(function() {
        var mounted = true;
        var mediaQueryList = typeof window === "undefined" ? exports2.mockMediaQueryList : window.matchMedia(query);
        var onChange = function() {
          if (!mounted) {
            return;
          }
          setState(Boolean(mediaQueryList.matches));
        };
        mediaQueryList.addListener(onChange);
        setState(mediaQueryList.matches);
        return function() {
          mounted = false;
          mediaQueryList.removeListener(onChange);
        };
      }, [query]);
      return state;
    };
  };
  exports2.useMedia = createUseMedia(react_1.useEffect);
  exports2.useMediaLayout = createUseMedia(react_1.useLayoutEffect);
  exports2.default = exports2.useMedia;
})(useMedia);
Object.defineProperty(lib$1, "__esModule", { value: true });
var useMedia_1 = useMedia;
var _default = lib$1.default = useMedia_1.default;
lib$1.useMedia = useMedia_1.useMedia;
lib$1.useMediaLayout = useMedia_1.useMediaLayout;
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
const BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
const PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
const OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
const ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua2) {
    const match2 = ua2.match(regexp);
    return match2 && match2.length > 0 && match2[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua2) {
    const match2 = ua2.match(regexp);
    return match2 && match2.length > 1 && match2[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua2, _const) {
    if (regexp.test(ua2)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version) {
    switch (version) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] !== 10)
      return void 0;
    switch (v2[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] === 1 && v2[1] < 5)
      return void 0;
    if (v2[0] === 1 && v2[1] < 6)
      return "Cupcake";
    if (v2[0] === 1 && v2[1] >= 6)
      return "Donut";
    if (v2[0] === 2 && v2[1] < 2)
      return "Eclair";
    if (v2[0] === 2 && v2[1] === 2)
      return "Froyo";
    if (v2[0] === 2 && v2[1] > 2)
      return "Gingerbread";
    if (v2[0] === 3)
      return "Honeycomb";
    if (v2[0] === 4 && v2[1] < 1)
      return "Ice Cream Sandwich";
    if (v2[0] === 4 && v2[1] < 4)
      return "Jelly Bean";
    if (v2[0] === 4 && v2[1] >= 4)
      return "KitKat";
    if (v2[0] === 5)
      return "Lollipop";
    if (v2[0] === 6)
      return "Marshmallow";
    if (v2[0] === 7)
      return "Nougat";
    if (v2[0] === 8)
      return "Oreo";
    if (v2[0] === 9)
      return "Pie";
    return void 0;
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version) {
    return version.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = Utils.getVersionPrecision(versionA);
    const versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version) => {
      const delta = precision - Utils.getVersionPrecision(version);
      const _version = version + new Array(delta + 1).join(".0");
      return Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator2) {
    const result = [];
    let i;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator2);
    }
    for (i = 0; i < arr.length; i += 1) {
      result.push(iterator2(arr[i]));
    }
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i = 0, l2 = arr.length; i < l2; i += 1) {
      const value = arr[i];
      if (predicate(value, i)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i;
    let l2;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i = 0, l2 = assigners.length; i < l2; i += 1) {
      const assigner = assigners[i];
      if (typeof assigner === "object" && assigner !== null) {
        const keys3 = Object.keys(assigner);
        keys3.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
const browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua2) {
      const browser2 = {
        name: "Googlebot"
      };
      const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Samsung Internet for Android"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/Whale/i],
    describe(ua2) {
      const browser2 = {
        name: "NAVER Whale Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "MZ Browser"
      };
      const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/focus/i],
    describe(ua2) {
      const browser2 = {
        name: "Focus"
      };
      const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/swing/i],
    describe(ua2) {
      const browser2 = {
        name: "Swing"
      };
      const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/coast/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera Coast"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua2) {
      const browser2 = {
        name: "Opera Touch"
      };
      const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Yandex Browser"
      };
      const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "UC Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua2) {
      const browser2 = {
        name: "Maxthon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua2) {
      const browser2 = {
        name: "Epiphany"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/puffin/i],
    describe(ua2) {
      const browser2 = {
        name: "Puffin"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua2) {
      const browser2 = {
        name: "Sleipnir"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua2) {
      const browser2 = {
        name: "K-Meleon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua2) {
      const browser2 = {
        name: "WeChat"
      };
      const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua2) {
      const browser2 = {
        name: /qqbrowserlite/i.test(ua2) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua2) {
      const browser2 = {
        name: "Internet Explorer"
      };
      const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua2) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua2) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua2) {
      const browser2 = {
        name: "Vivaldi"
      };
      const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua2) {
      const browser2 = {
        name: "SeaMonkey"
      };
      const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua2) {
      const browser2 = {
        name: "Sailfish"
      };
      const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/silk/i],
    describe(ua2) {
      const browser2 = {
        name: "Amazon Silk"
      };
      const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/phantom/i],
    describe(ua2) {
      const browser2 = {
        name: "PhantomJS"
      };
      const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua2) {
      const browser2 = {
        name: "SlimerJS"
      };
      const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua2) {
      const browser2 = {
        name: "BlackBerry"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua2) {
      const browser2 = {
        name: "WebOS Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/bada/i],
    describe(ua2) {
      const browser2 = {
        name: "Bada"
      };
      const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/tizen/i],
    describe(ua2) {
      const browser2 = {
        name: "Tizen"
      };
      const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua2) {
      const browser2 = {
        name: "QupZilla"
      };
      const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua2) {
      const browser2 = {
        name: "Firefox"
      };
      const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/electron/i],
    describe(ua2) {
      const browser2 = {
        name: "Electron"
      };
      const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua2) {
      const browser2 = {
        name: "Miui"
      };
      const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/chromium/i],
    describe(ua2) {
      const browser2 = {
        name: "Chromium"
      };
      const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua2) || Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua2) {
      const browser2 = {
        name: "Chrome"
      };
      const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  {
    test: [/GSA/i],
    describe(ua2) {
      const browser2 = {
        name: "Google Search"
      };
      const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua2) {
      const browser2 = {
        name: "Android Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua2) {
      const browser2 = {
        name: "PlayStation 4"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua2) {
      const browser2 = {
        name: "Safari"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua2);
      if (version) {
        browser2.version = version;
      }
      return browser2;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua2) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua2.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua2),
        version: Utils.getSecondMatch(regexp, ua2)
      };
    }
  }
];
const osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua2) {
      const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua2);
      return {
        name: OS_MAP.Roku,
        version
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.WindowsPhone,
        version
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua2);
      const versionName = Utils.getWindowsVersionName(version);
      return {
        name: OS_MAP.Windows,
        version,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua2) {
      const result = {
        name: OS_MAP.iOS
      };
      const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua2);
      if (version) {
        result.version = version;
      }
      return result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua2).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version);
      const os2 = {
        name: OS_MAP.MacOS,
        version
      };
      if (versionName) {
        os2.versionName = versionName;
      }
      return os2;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua2).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua2) {
      const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua2);
      const versionName = Utils.getAndroidVersionName(version);
      const os2 = {
        name: OS_MAP.Android,
        version
      };
      if (versionName) {
        os2.versionName = versionName;
      }
      return os2;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua2);
      const os2 = {
        name: OS_MAP.WebOS
      };
      if (version && version.length) {
        os2.version = version;
      }
      return os2;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua2) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua2) || Utils.getFirstMatch(/\bbb(\d+)/i, ua2);
      return {
        name: OS_MAP.BlackBerry,
        version
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.Bada,
        version
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua2) {
      const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.Tizen,
        version
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua2) {
      const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua2);
      return {
        name: OS_MAP.PlayStation4,
        version
      };
    }
  }
];
const platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua2) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua2) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua2) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua2);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];
const enginesParsersList = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua2) {
      const isBlinkBased = /\sedg\//i.test(ua2);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua2);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua2) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua2);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex2) {
    return regex2.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(browsersList, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os2 = Utils.find(osParsersList, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os2) {
      this.parsedResult.os = os2.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS — macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    if (toLowerCase) {
      return String(name).toLowerCase() || "";
    }
    return name || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(platformParsersList, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name) => this.isPlatform(name)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version) {
    let expectedResults = [0];
    let comparableVersion = version;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version[0] === ">" || version[0] === "<") {
      comparableVersion = version.substr(1);
      if (version[1] === "=") {
        isLoose = true;
        comparableVersion = version.substr(2);
      } else {
        expectedResults = [];
      }
      if (version[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version[0] === "=") {
      comparableVersion = version.substr(1);
    } else if (version[0] === "~") {
      isLoose = true;
      comparableVersion = version.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new Parser(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new Parser(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
function L(e2, r2) {
  const n2 = getLoginDisplayInfo(e2, r2);
  return {
    ...n2,
    headline: n2.headline ?? f$2(getValueWithPlaceholder(e2 == null ? void 0 : e2.uiType))
  };
}
function f$2(e2) {
  switch (e2) {
    case LoginUiType.creditCard:
      return i18n._(
        /*i18n*/
        {
          id: "3dKLN3"
        }
      );
    case LoginUiType.wifi:
      return i18n._(
        /*i18n*/
        {
          id: "+jQjTh"
        }
      );
    case LoginUiType.note:
      return i18n._(
        /*i18n*/
        {
          id: "tF8MKq"
        }
      );
    case LoginUiType.login:
    case void 0:
      return i18n._(
        /*i18n*/
        {
          id: "4QFgr2"
        }
      );
  }
}
function U(e2) {
  switch (e2) {
    case LoginUiType.creditCard:
      return i18n._(
        /*i18n*/
        {
          id: "ooW934"
        }
      );
    case LoginUiType.wifi:
      return i18n._(
        /*i18n*/
        {
          id: "5VAKau"
        }
      );
    case LoginUiType.note:
      return i18n._(
        /*i18n*/
        {
          id: "tF8MKq"
        }
      );
    case LoginUiType.login:
    case void 0:
      return i18n._(
        /*i18n*/
        {
          id: "z0t9bb"
        }
      );
  }
}
function g$3(e2) {
  if (e2.name)
    return e2.name;
  switch (e2.type) {
    case VaultType.PRIVATE:
      return i18n._(
        /*i18n*/
        {
          id: "12Aozu"
        }
      );
    case VaultType.ORGANIZATION_PERSONAL:
      return i18n._(
        /*i18n*/
        {
          id: "oENbfc"
        }
      );
    case VaultType.TEAM:
      return i18n._(
        /*i18n*/
        {
          id: "57/aFB"
        }
      );
    case VaultType.INBOX:
      return i18n._(
        /*i18n*/
        {
          id: "lh348v"
        }
      );
  }
}
function O(e2, r2) {
  const n2 = g$3(e2);
  return `${(r2 == null ? void 0 : r2.name) ?? i18n._(
    /*i18n*/
    {
      id: "Ysej7j"
    }
  )} – ${n2}`;
}
function D$1(e2) {
  const r2 = e2 ?? Bowser.parse(window.navigator.userAgent);
  return r2.os.name === "iOS" || r2.os.name === "macOS";
}
function I$1(e2) {
  return (e2 ?? Bowser.parse(window.navigator.userAgent)).platform.type === "desktop" && !m$2(e2);
}
function m$2(e2) {
  var n2;
  const r2 = e2 ?? Bowser.parse(window.navigator.userAgent);
  return r2.platform.type === "desktop" && r2.browser.name === "Safari" && // iPad Safari likes to pretend it is macOS Safari by cloning its user agent:
  // https://github.com/lancedikson/bowser/issues/455 But it doesn't support our extension, so we
  // need to exclude it here based on somewhat sketchy fingerprinting. Yeah, I don't like it
  // either.
  // eslint-disable-next-line -- compat complains about this, but only on older iOS, where we don't need it anyway
  ((n2 = window.navigator) == null ? void 0 : n2.maxTouchPoints) === 5;
}
class P {
  constructor(r2, n2 = "DEBUG") {
    this.onDebugTriggered = r2, this.debugString = n2, this.index = 0, this.onKeypress = (s2) => {
      s2.defaultPrevented || (s2.key === this.debugString[this.index] ? (this.index += 1, this.index === this.debugString.length && (this.onDebugTriggered(), this.index = 0)) : this.index = 0);
    };
  }
  init() {
    window.addEventListener("keypress", this.onKeypress);
  }
  close() {
    window.removeEventListener("keypress", this.onKeypress);
  }
}
const T = "0 0 0.5rem hsl(0deg 0% 0% / 50%)";
function F$1(e2, r2) {
  var l2;
  const n2 = [];
  let s2 = e2;
  for (; s2; ) {
    if (!((l2 = s2.at(0)) != null && l2.match(/[\x00-\x7f]/))) {
      n2.push(s2.at(0)), s2 = s2.substring(1);
      continue;
    }
    const i = s2.search(/\+/);
    if (i === -1) {
      n2.push(s2);
      break;
    }
    n2.push(s2.substring(0, i)), s2 = s2.substring(i + 1);
  }
  return n2.map((i) => b$2(i, r2));
}
function b$2(e2, r2) {
  const n2 = e2.toLowerCase();
  if (r2)
    switch (n2) {
      case "macctrl":
        return "⌃";
      case "ctrl":
      case "command":
        return "⌘";
      case "shift":
        return "⇧";
      case "alt":
        return "⌥";
      case "enter":
        return "↵";
      case "esc":
        return "⎋";
      case "home":
        return "↖";
      case "end":
        return "↘";
      case "pageup":
        return "⇞";
      case "pagedown":
        return "⇟";
    }
  switch (n2) {
    case "ctrl":
    case "strg":
      return i18n._(
        /*i18n*/
        {
          id: "F5QOVM"
        }
      );
    case "shift":
    case "umschalttaste":
      return i18n._(
        /*i18n*/
        {
          id: "PGetcZ"
        }
      );
    case "alt":
      return i18n._(
        /*i18n*/
        {
          id: "mac4Aw"
        }
      );
    case "enter":
      return i18n._(
        /*i18n*/
        {
          id: "9Vnjc9"
        }
      );
    case "esc":
      return i18n._(
        /*i18n*/
        {
          id: "zO1gmR"
        }
      );
    case "home":
      return i18n._(
        /*i18n*/
        {
          id: "i0qMbr"
        }
      );
    case "end":
      return i18n._(
        /*i18n*/
        {
          id: "xDr/ct"
        }
      );
    case "pageup":
      return i18n._(
        /*i18n*/
        {
          id: "ycPJXO"
        }
      );
    case "pagedown":
      return i18n._(
        /*i18n*/
        {
          id: "lojVac"
        }
      );
    case "comma":
      return ",";
    case "period":
    case "punkt":
      return ".";
    case "space":
      return i18n._(
        /*i18n*/
        {
          id: "pOE8Vh"
        }
      );
    case "insert":
      return i18n._(
        /*i18n*/
        {
          id: "mSlBXj"
        }
      );
    case "delete":
      return i18n._(
        /*i18n*/
        {
          id: "W/50sr"
        }
      );
    case "up":
    case "up arrow":
      return "↑";
    case "down":
    case "down arrow":
      return "↓";
    case "left":
    case "left arrow":
      return "←";
    case "right":
    case "right arrow":
      return "→";
    case "medianexttrack":
      return "⏭";
    case "mediaplaypause":
      return "⏯";
    case "mediaprevtrack":
      return "⏮";
    case "mediastop":
      return "⏹";
    default:
      return y$4(e2);
  }
}
function y$4(e2) {
  return `${e2[0].toUpperCase()}${e2.slice(1).toLowerCase()}`;
}
function detectFromNavigator(navigator2 = globalThis.navigator) {
  const result = navigator2.language || navigator2.userLanguage;
  return result;
}
function detect(...args) {
  for (let i = 0; i < args.length; i++) {
    const res = typeof args[i] === "function" ? args[i]() : args[i];
    if (res)
      return res;
  }
  return null;
}
const g$2 = JSON.parse('{"nYAZ22":["„",["loginLabel"],"” wurde gelöscht."],"BBrYPy":["„",["loginLabel"],"” wurde nach „",["0"],"” verschoben."],"+BllQ/":["„",["loginLabel"],"” wurde in den <0>Papierkorb</0> verschoben."],"d/ZbMk":"(geändert)","Gv57aB":[["fieldName"]," (alt)"],"9XZ3SQ":"#@$","qdmWOt":["0",["nonBreakingHyphen"],"9"],"sbGnrd":["a",["nonBreakingHyphen"],"z"],"umLW9t":["A",["nonBreakingHyphen"],"Z"],"m16xKo":"Hinzufügen","lyqwgn":"Label hinzufügen","iOiHwJ":"Weitere hinzufügen","CgUQh7":"Neues Feld hinzufügen","648VR4":"TOTP-Schlüssel hinzufügen","xkWEmO":"Alle Felder sind Ende-zu-Ende-verschlüsselt.","mac4Aw":"Alt","zVJj0U":"Android-App","DB8zMK":"Übernehmen","NamUYY":["von ",["creationProfileEmail"]],"nmimYO":["von ",["editProfileEmail"]],"dEgA5A":"Abbrechen","bMFXRG":"Karteninhaber","xHIEQ5":"Kreditkartennummer","2SqvU5":"Uhrzeit wird überprüft…","RLe7Vk":"Wird überprüft…","xCJdfg":"Leeren","yz7wBu":"Schließen","yrwl2P":"Konform","aIJHYe":"Zugriff erlauben","MpA0AY":"Bestätige mit einem deiner Login-Geräte","F0GBL0":"Bestätige mit deinem Handy","1yegnp":"Bestätige mit deinem Security Key","6V3Ea3":"Kopiert","he3ygx":"Kopieren","t3sqJR":["Erstellt am ",["0"]],"ooW934":"Kreditkarte","F5QOVM":"Strg","W/50sr":"Entf","cnGeoo":"Löschen","pfa8F0":"Anzeigename","d3ZUIN":"E-Mail oder Nutzername","xDr/ct":"Ende","9Vnjc9":"Enter","nNWuY1":"Eintrags-Typ","dgi+MR":"Fehler beim Überprüfen des Passworts","zO1gmR":"Esc","sZg7s1":"Ablaufdatum","2Pjc5z":"Ablaufdatum (mm / yy)","7Bj3x9":"Fehlgeschlagen","19BWU3":"Passwort generieren","YU1MkM":"PIN generieren","Jf0PuK":"Zum Login gehen","76gPWk":"Okay","+AzmrG":"heylogin wurde aktualisiert","vLyv1R":"Verbergen","g9eOjA":"Inhalt verstecken","i0qMbr":"Pos1","62ft/Z":"https://help.heylogin.com/de/2be545c602c144d6992a50e6301afa18","mSlBXj":"Einfg","/Gcaah":"Unsicher","0FSRiz":"Ungültige Kreditkartennummer","Lyd22+":"Ungültiges Ablaufdatum","7xaBoY":"Ungültiger Sicherheitscode","oYNiCo":"Label bereits hinzugefügt","h8DugX":"Labels","hko/4A":"Labels:","Lr4lJo":["Zuletzt bearbeitet am ",["0"]],"NC2AI2":"Länge","zUDyah":"Du wirst eingeloggt","z0t9bb":"Login","zUtMod":"Login abgebrochen","lh348v":"Login-Posteingang","a7UoOG":"Login-Status","gKfrpZ":["min. ",["0"]," Zeichen"],"2FYpfJ":"Mehr","3Siwmw":"Weitere Optionen","IK+8Ec":"In den Papierkorb verschieben","12Aozu":"Meine Logins","6YtxFj":"Name","1xTnZJ":"Name darf nicht leer sein!","MKYFuo":"Netzwerkname (SSID)","/nT6AE":"Neues Passwort","nr1I0W":"Keine App gefunden","xAAcWG":"Benachrichtigung kommt nicht an?","KiJn9B":"Notiz","CqOvzI":"Altes Passwort","yxTdsJ":"Webseite aufrufen","8ZsakT":"Passwort","kcggoH":"Passwort-Check:","dsVW+d":"Geprüftes Passwort","9QBiCg":"Passwort ist leer","Xjatg3":"Passwort-Policy:","oENbfc":"Persönliche Logins","lojVac":"Bild↓","ycPJXO":"Bild↑","sXULwc":"PIN","XdSz+P":"Bitte gib ein Label ein","QsZjF+":"Bitte lade die Seite neu um die aktuelle Version zu verwenden.","Ysej7j":"Privater Account","3WxAes":"Erneut prüfen","HpK/8d":"Neu laden","/7FPnu":"Label entfernen","Clnbgt":"Geteiltes Login entfernen","yKu/3Y":"Wiederherstellen","I89uD4":"Wiederherstellen…","tfDRzk":"Speichern","mwMktx":[["changeCount","plural",{"one":"Eine Änderung","other":["#"," Änderungen"]}]," speichern"],"u5eWCX":"Neuen Eintrag speichern","idD8Ev":"Gespeichert","OFqAkw":"Erfolgreich gespeichert","uF9ruK":"Wird gespeichert","tF8MKq":"Sichere Notiz","FLkaGY":"Sicheres Passwort","wLmRnI":"Sicherheitscode","rmoyE2":["Sicherheitscode (",["cardCodeName"],", ",["1","plural",{"one":["#"," Ziffer"],"other":["#"," Ziffern"]}],")"],"byfRNP":"Login-Absender","PGetcZ":"Shift","8vETh9":"Anzeigen","h8lzfw":[["0"]," anzeigen"],"7C+Jn5":"Passwort anzeigen","2cIs6V":"PIN anzeigen","BqrHbB":"Sicherheitscode anzeigen","nld5XV":"TOTP-Schlüssel anzeigen","vHxqT2":"Zeige WLAN-QR-Code","pOE8Vh":"Leerstaste","J8XjuC":"Uhrzeit ist jetzt korrekt.","kWroQx":"der Besitzer","QNFK92":"Ungespeicherte Änderungen. <0>Jetzt speichern</0>","2vXxVm":["Diese Kreditkarte wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"HoCMO6":"Diese Kreditkarte wird aus einem Team mit dir geteilt.","RCxO9Q":["Diese Kreditkarte wird aus dem Team ",["link"]," mit dir geteilt."],"xdufSh":["Diese Kreditkarte wird von ",["originEmail"]," mit dir geteilt."],"JWTc8Z":"Diese Kreditkarte wird von einem anderen Nutzer mit dir geteilt.","QAuBJT":["Dieses Login wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"thM6gj":"Dieses Login wird aus einem Team mit dir geteilt.","sQ0SXs":["Dieses Login wird aus dem Team ",["link"]," mit dir geteilt."],"0lXBAq":["Dieses Login wird von ",["originEmail"]," mit dir geteilt."],"OXhtqX":"Dieses Login wird von einem anderen Nutzer mit dir geteilt.","c/nFq0":["Dieses Login wurde am ",["0"]," in deinen Login-Posteingang übermittelt."],"czBEzZ":["Dieses Login wird auch auf ",["0"]," weiteren Webseiten angezeigt."],"y4UGV2":["Dieses Login wird auch auf ",["0"]," und ",["1"]," angezeigt."],"ai680t":["Dieses Login wird auch auf ",["0"]," angezeigt."],"S/ZmvX":["Dieses Notiz wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt"],"lr/OH6":"Diese Notiz wird aus einem Team mit dir geteilt.","a9Vkxt":["Diese Notiz wird aus dem Team ",["link"]," mit dir geteilt."],"RzvhXF":["Dieses Notiz wird von ",["originEmail"]," mit dir geteilt"],"UMBnwA":"Diese Notiz wird von einem anderen Nutzer mit dir geteilt.","2DMQa6":"Dieses Passwort wurde auf einer Liste von geleakten Passwörtern gefunden. Bitte nicht verwenden!","ESK+7k":"Dieser TOTP-Code benutzt von der Voreinstellung abweichende Parameter.","DUExfD":["Dieses WLAN-Netzwerk wird von ",["linkedByEmail"]," aus einem Team mit dir geteilt."],"QGWnC/":"Dieses WLAN-Netzwerk wird aus einem Team mit dir geteilt.","+JycaI":["Dieses WLAN-Netzwerk wird aus dem Team ",["link"]," mit dir geteilt."],"OoKYf3":["Dieses WLAN-Netzwerk wird von ",["originEmail"]," mit dir geteilt."],"oSL3k7":"Dieses WLAN-Netzwerk wird von einem anderen Nutzer mit dir geteilt.","Kvajkr":"TOTP","yoyvgB":"TOTP-Algorithmus","HqgpzW":"TOTP-Code könnte ungültig sein aufgrund abweichender Uhrzeit auf diesem Gerät. Bitte stelle die Systemzeit auf die aktuelle Zeit.","dME5Kz":"TOTP-Code:","16oMiL":"TOTP-Länge","rsWzn3":"TOTP-Periode","g4uCmi":"TOTP-Schlüssel","KDw4GX":"Erneut versuchen","3dKLN3":"Unbekannte Kreditkarte","29VNqC":"Unbekannter Fehler","fEjABR":["Unbekannter Fehler: ",["0"]],"IU3aCs":"Unbekanntes Feld","+jQjTh":"Unbekanntes WLAN-Netzwerk","4QFgr2":"Unbenanntes Login","57/aFB":"Unbenanntes Team","/zWqH6":"Als Standardeinstellung nutzen","7sNhEz":"Nutzername","ZBkKyh":"Verletzt","IVBLxC":"Warte auf Überprüfung","On0aF2":"Website","1J9wMe":"Websites","5VAKau":"WLAN-Netzwerk","2rz/ET":"Du kannst sie nur lesen.","PwJojz":"Du kannst es nur lesen.","mJdpuD":"Du kannst es nur lesen.","7uotGR":"Du kannst sie nur lesen.","KBRW1Z":"Du kannst diese Kreditkarte nur lesen.","ntxE/T":"Du kannst dieses Login nur lesen.","U7HgqM":"Du kannst dieses Notiz nur lesen.","cyzc26":"Du kannst dieses WLAN-Netzwerk nur lesen.","du68I6":"Du kannst es nur zum Einloggen auf Webseiten verwenden.","c8d9tl":"Du kannst dieses Login nur zum Einloggen auf Webseiten verwenden.","T9CzYt":["Du hast ",["remainingMinutes","plural",{"one":"weniger als eine Minute","other":["#"," Minuten"]}]," Zeit, um die Kreditkarte anzupassen, danach kann nur noch ",["ownerEmail"]," editieren."],"KoxsxA":["Du hast ",["remainingMinutes","plural",{"one":"weniger als eine Minute","other":["#"," Minuten"]}]," Zeit, um das Login anzupassen, danach kann nur noch ",["ownerEmail"]," editieren."]}'), u$1 = JSON.parse('{"nYAZ22":["“",["loginLabel"],"” was deleted."],"BBrYPy":["“",["loginLabel"],"” was moved to “",["0"],"”."],"+BllQ/":["“",["loginLabel"],"” was moved to the <0>recycle bin</0>."],"d/ZbMk":"(changed)","Gv57aB":[["fieldName"]," (old)"],"9XZ3SQ":"#@$","qdmWOt":["0",["nonBreakingHyphen"],"9"],"sbGnrd":["a",["nonBreakingHyphen"],"z"],"umLW9t":["A",["nonBreakingHyphen"],"Z"],"m16xKo":"Add","lyqwgn":"Add label","iOiHwJ":"Add more","CgUQh7":"Add new field","648VR4":"Add TOTP secret","xkWEmO":"All fields are end-to-end encrypted.","mac4Aw":"Alt","zVJj0U":"Android app","DB8zMK":"Apply","NamUYY":["by ",["creationProfileEmail"]],"nmimYO":["by ",["editProfileEmail"]],"dEgA5A":"Cancel","bMFXRG":"Card holder","xHIEQ5":"Card number","2SqvU5":"Checking system clock…","RLe7Vk":"Checking…","xCJdfg":"Clear","yz7wBu":"Close","yrwl2P":"Compliant","aIJHYe":"Confirm access","MpA0AY":"Confirm with one of your login devices","F0GBL0":"Confirm with your phone","1yegnp":"Confirm with your security key","6V3Ea3":"Copied","he3ygx":"Copy","t3sqJR":["Created on ",["0"]],"ooW934":"Credit card","F5QOVM":"Ctrl","W/50sr":"Del","cnGeoo":"Delete","pfa8F0":"Display name","d3ZUIN":"E-mail or username","xDr/ct":"End","9Vnjc9":"Enter","nNWuY1":"Entry type","dgi+MR":"Error checking password","zO1gmR":"Esc","sZg7s1":"Expiration date","2Pjc5z":"Expiration date (mm / yy)","7Bj3x9":"Failed","19BWU3":"Generate password","YU1MkM":"Generate PIN","Jf0PuK":"Go to login","76gPWk":"Got it","+AzmrG":"heylogin was updated","vLyv1R":"Hide","g9eOjA":"Hide content","i0qMbr":"Home","62ft/Z":"https://help.heylogin.com/en/4200f43b493c4bb18c8e16bffcd40071","mSlBXj":"Ins","/Gcaah":"Insecure","0FSRiz":"Invalid card number","Lyd22+":"Invalid expiration date","7xaBoY":"Invalid security code","oYNiCo":"Label already added","h8DugX":"Labels","hko/4A":"Labels:","Lr4lJo":["Last edited on ",["0"]],"NC2AI2":"Length","zUDyah":"Logging in","z0t9bb":"Login","zUtMod":"Login cancelled","lh348v":"Login Inbox","a7UoOG":"Login status","gKfrpZ":["min. ",["0"]," characters"],"2FYpfJ":"More","3Siwmw":"More options","IK+8Ec":"Move to recycle bin","12Aozu":"My Logins","6YtxFj":"Name","1xTnZJ":"Name may not be empty!","MKYFuo":"Network name (SSID)","/nT6AE":"New password","nr1I0W":"No app found","xAAcWG":"No notification received?","KiJn9B":"Note","CqOvzI":"Old password","yxTdsJ":"Open website","8ZsakT":"Password","kcggoH":"Password check:","dsVW+d":"Password checked","9QBiCg":"Password is empty","Xjatg3":"Password policy:","oENbfc":"Personal Logins","lojVac":"PgDn","ycPJXO":"PgUp","sXULwc":"PIN","XdSz+P":"Please enter a label","QsZjF+":"Please reload to use the latest version.","Ysej7j":"Private account","3WxAes":"Recheck","HpK/8d":"Reload","/7FPnu":"Remove label","Clnbgt":"Remove shared login","yKu/3Y":"Restore","I89uD4":"Restoring…","tfDRzk":"Save","mwMktx":["Save ",["changeCount","plural",{"one":["#"," change"],"other":["#"," changes"]}]],"u5eWCX":"Save new entry","idD8Ev":"Saved","OFqAkw":"Saved successfully","uF9ruK":"Saving","tF8MKq":"Secure note","FLkaGY":"Secure password","wLmRnI":"Security code","rmoyE2":["Security code (",["cardCodeName"],", ",["0","plural",{"one":["#"," digit"],"other":["#"," digits"]}],")"],"byfRNP":"Sent by","PGetcZ":"Shift","8vETh9":"Show","h8lzfw":["Show ",["0"]],"7C+Jn5":"Show password","2cIs6V":"Show PIN","BqrHbB":"Show security code","nld5XV":"Show TOTP secret","vHxqT2":"Show WiFi QR code","pOE8Vh":"Space","J8XjuC":"System clock is correct now.","kWroQx":"the owner","QNFK92":"There are unsaved changes. <0>Save now</0>","2vXxVm":["This credit card is shared from a team by ",["linkedByEmail"],"."],"HoCMO6":"This credit card is shared from a team.","RCxO9Q":["This credit card is shared from team ",["link"],"."],"xdufSh":["This credit card is shared with you by ",["originEmail"],"."],"JWTc8Z":"This credit card is shared with you by another user.","QAuBJT":["This login is shared from a team by ",["linkedByEmail"],"."],"thM6gj":"This login is shared from a team.","sQ0SXs":["This login is shared from team ",["link"],"."],"0lXBAq":["This login is shared with you by ",["originEmail"],"."],"OXhtqX":"This login is shared with you by another user.","c/nFq0":["This login was submitted to your login inbox on ",["0"],"."],"czBEzZ":["This login will also be shown on ",["0"]," additional websites."],"y4UGV2":["This login will also be shown on ",["0"]," and ",["1"],"."],"ai680t":["This login will also be shown on ",["0"],"."],"S/ZmvX":["This note is shared from a team by ",["linkedByEmail"],"."],"lr/OH6":"This note is shared from a team.","a9Vkxt":["This note is shared from team ",["link"],"."],"RzvhXF":["This note is shared with you by ",["originEmail"],"."],"UMBnwA":"This note is shared with you by another user.","2DMQa6":"This password was found in a list of leaked passwords. Please do not use it!","ESK+7k":"This TOTP code uses parameters that differ from the default.","DUExfD":["This wifi network is shared from a team by ",["linkedByEmail"],"."],"QGWnC/":"This wifi network is shared from a team.","+JycaI":["This wifi network is shared from team ",["link"],"."],"OoKYf3":["This wifi network is shared with you by ",["originEmail"],"."],"oSL3k7":"This wifi network is shared with you by another user.","Kvajkr":"TOTP","yoyvgB":"TOTP algorithm","HqgpzW":"TOTP code might be invalid due to incorrect system clock on this device. Please set your system time to the current time.","dME5Kz":"TOTP code:","16oMiL":"TOTP length","rsWzn3":"TOTP period","g4uCmi":"TOTP secret","KDw4GX":"Try again","3dKLN3":"Unknown credit card","29VNqC":"Unknown error","fEjABR":["Unknown error: ",["0"]],"IU3aCs":"Unknown field","+jQjTh":"Unknown wifi network","4QFgr2":"Unnamed login","57/aFB":"Unnamed team","/zWqH6":"Use as default setting","7sNhEz":"Username","ZBkKyh":"Violated","IVBLxC":"Waiting to check","On0aF2":"Website","1J9wMe":"Websites","5VAKau":"Wifi network","2rz/ET":"You can only read it.","PwJojz":"You can only read it.","mJdpuD":"You can only read it.","7uotGR":"You can only read it.","KBRW1Z":"You can only read this credit card.","ntxE/T":"You can only read this login.","U7HgqM":"You can only read this note.","cyzc26":"You can only read this wifi network.","du68I6":"You can only use it to log in on websites.","c8d9tl":"You can only use this login to log in on websites.","T9CzYt":["You have ",["remainingMinutes","plural",{"one":"less than one minute","other":["#"," minutes"]}]," to edit this credit card. After that, only ",["ownerEmail"]," can edit it."],"KoxsxA":["You have ",["remainingMinutes","plural",{"one":"less than one minute","other":["#"," minutes"]}]," to edit this login. After that, only ",["ownerEmail"]," can edit it."]}'), a = ["de", "en"], s = "en";
function y$3(i, o2) {
  h$2(i);
  let n2 = (o2 ?? detect(detectFromNavigator()) ?? s).split("-")[0];
  return a.every((t2) => t2 !== n2) && (n2 = s), i18n.on("change", () => {
    var t2, r2;
    (r2 = (t2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : t2.documentElement) == null || r2.setAttribute("lang", i18n.locale);
  }), i18n.activate(n2), {
    supported: a,
    active: n2
  };
}
function h$2(i) {
  i18n.load("en", {
    ...u$1,
    ...i.en
  }), i18n.load("de", {
    ...g$2,
    ...i.de
  });
}
var formatDistanceLocale$1 = {
  lessThanXSeconds: {
    standalone: {
      one: "weniger als eine Sekunde",
      other: "weniger als {{count}} Sekunden"
    },
    withPreposition: {
      one: "weniger als einer Sekunde",
      other: "weniger als {{count}} Sekunden"
    }
  },
  xSeconds: {
    standalone: {
      one: "eine Sekunde",
      other: "{{count}} Sekunden"
    },
    withPreposition: {
      one: "einer Sekunde",
      other: "{{count}} Sekunden"
    }
  },
  halfAMinute: {
    standalone: "eine halbe Minute",
    withPreposition: "einer halben Minute"
  },
  lessThanXMinutes: {
    standalone: {
      one: "weniger als eine Minute",
      other: "weniger als {{count}} Minuten"
    },
    withPreposition: {
      one: "weniger als einer Minute",
      other: "weniger als {{count}} Minuten"
    }
  },
  xMinutes: {
    standalone: {
      one: "eine Minute",
      other: "{{count}} Minuten"
    },
    withPreposition: {
      one: "einer Minute",
      other: "{{count}} Minuten"
    }
  },
  aboutXHours: {
    standalone: {
      one: "etwa eine Stunde",
      other: "etwa {{count}} Stunden"
    },
    withPreposition: {
      one: "etwa einer Stunde",
      other: "etwa {{count}} Stunden"
    }
  },
  xHours: {
    standalone: {
      one: "eine Stunde",
      other: "{{count}} Stunden"
    },
    withPreposition: {
      one: "einer Stunde",
      other: "{{count}} Stunden"
    }
  },
  xDays: {
    standalone: {
      one: "ein Tag",
      other: "{{count}} Tage"
    },
    withPreposition: {
      one: "einem Tag",
      other: "{{count}} Tagen"
    }
  },
  aboutXWeeks: {
    standalone: {
      one: "etwa ein Woche",
      other: "etwa {{count}} Wochen"
    },
    withPreposition: {
      one: "etwa einem Woche",
      other: "etwa {{count}} Wochen"
    }
  },
  xWeeks: {
    standalone: {
      one: "ein Woche",
      other: "{{count}} Wochen"
    },
    withPreposition: {
      one: "einem Woche",
      other: "{{count}} Wochen"
    }
  },
  aboutXMonths: {
    standalone: {
      one: "etwa ein Monat",
      other: "etwa {{count}} Monate"
    },
    withPreposition: {
      one: "etwa einem Monat",
      other: "etwa {{count}} Monaten"
    }
  },
  xMonths: {
    standalone: {
      one: "ein Monat",
      other: "{{count}} Monate"
    },
    withPreposition: {
      one: "einem Monat",
      other: "{{count}} Monaten"
    }
  },
  aboutXYears: {
    standalone: {
      one: "etwa ein Jahr",
      other: "etwa {{count}} Jahre"
    },
    withPreposition: {
      one: "etwa einem Jahr",
      other: "etwa {{count}} Jahren"
    }
  },
  xYears: {
    standalone: {
      one: "ein Jahr",
      other: "{{count}} Jahre"
    },
    withPreposition: {
      one: "einem Jahr",
      other: "{{count}} Jahren"
    }
  },
  overXYears: {
    standalone: {
      one: "mehr als ein Jahr",
      other: "mehr als {{count}} Jahre"
    },
    withPreposition: {
      one: "mehr als einem Jahr",
      other: "mehr als {{count}} Jahren"
    }
  },
  almostXYears: {
    standalone: {
      one: "fast ein Jahr",
      other: "fast {{count}} Jahre"
    },
    withPreposition: {
      one: "fast einem Jahr",
      other: "fast {{count}} Jahren"
    }
  }
};
function formatDistance$1(token, count, options) {
  options = options || {};
  var usageGroup = options.addSuffix ? formatDistanceLocale$1[token].withPreposition : formatDistanceLocale$1[token].standalone;
  var result;
  if (typeof usageGroup === "string") {
    result = usageGroup;
  } else if (count === 1) {
    result = usageGroup.one;
  } else {
    result = usageGroup.other.replace("{{count}}", count);
  }
  if (options.addSuffix) {
    if (options.comparison > 0) {
      return "in " + result;
    } else {
      return "vor " + result;
    }
  }
  return result;
}
function buildFormatLongFn(args) {
  return function(dirtyOptions) {
    var options = dirtyOptions || {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}
var dateFormats$1 = {
  full: "EEEE, do MMMM y",
  // Montag, 7. Januar 2018
  long: "do MMMM y",
  // 7. Januar 2018
  medium: "do MMM. y",
  // 7. Jan. 2018
  short: "dd.MM.y"
  // 07.01.2018
};
var timeFormats$1 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats$1 = {
  full: "{{date}} 'um' {{time}}",
  long: "{{date}} 'um' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong$2 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: "full"
  })
};
const formatLong$3 = formatLong$2;
var formatRelativeLocale$1 = {
  lastWeek: "'letzten' eeee 'um' p",
  yesterday: "'gestern um' p",
  today: "'heute um' p",
  tomorrow: "'morgen um' p",
  nextWeek: "eeee 'um' p",
  other: "P"
};
function formatRelative$1(token, _date, _baseDate, _options) {
  return formatRelativeLocale$1[token];
}
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues$1 = {
  narrow: ["v.Chr.", "n.Chr."],
  abbreviated: ["v.Chr.", "n.Chr."],
  wide: ["vor Christus", "nach Christus"]
};
var quarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. Quartal", "2. Quartal", "3. Quartal", "4. Quartal"]
  // Note: in German, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.
};
var monthValues$1 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
  wide: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
};
var dayValues$1 = {
  narrow: ["S", "M", "D", "M", "D", "F", "S"],
  short: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  abbreviated: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."],
  wide: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
  // https://www.unicode.org/cldr/charts/32/summary/de.html#1881
};
var dayPeriodValues$1 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachm.",
    evening: "Abend",
    night: "Nacht"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "Morgen",
    afternoon: "Nachmittag",
    evening: "Abend",
    night: "Nacht"
  }
};
var formattingDayPeriodValues$1 = {
  narrow: {
    am: "vm.",
    pm: "nm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachm.",
    evening: "abends",
    night: "nachts"
  },
  abbreviated: {
    am: "vorm.",
    pm: "nachm.",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  },
  wide: {
    am: "vormittags",
    pm: "nachmittags",
    midnight: "Mitternacht",
    noon: "Mittag",
    morning: "morgens",
    afternoon: "nachmittags",
    evening: "abends",
    night: "nachts"
  }
};
function ordinalNumber$1(dirtyNumber, _dirtyOptions) {
  var number2 = Number(dirtyNumber);
  return number2 + ".";
}
var localize$2 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn({
    values: eraValues$1,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues$1,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: "wide"
  })
};
const localize$3 = localize$2;
function buildMatchPatternFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options = dirtyOptions || {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) {
      return null;
    }
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    return {
      value,
      rest: string.slice(matchedString.length)
    };
  };
}
function buildMatchFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options = dirtyOptions || {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var value;
    if (Object.prototype.toString.call(parsePatterns) === "[object Array]") {
      value = findIndex$1(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      });
    } else {
      value = findKey(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      });
    }
    value = args.valueCallback ? args.valueCallback(value) : value;
    value = options.valueCallback ? options.valueCallback(value) : value;
    return {
      value,
      rest: string.slice(matchedString.length)
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
}
function findIndex$1(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
}
var matchOrdinalNumberPattern$1 = /^(\d+)(\.)?/i;
var parseOrdinalNumberPattern$1 = /\d+/i;
var matchEraPatterns$1 = {
  narrow: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  abbreviated: /^(v\.? ?Chr\.?|n\.? ?Chr\.?)/i,
  wide: /^(vor Christus|vor unserer Zeitrechnung|nach Christus|unserer Zeitrechnung)/i
};
var parseEraPatterns$1 = {
  any: [/^v/i, /^n/i]
};
var matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? Quartal/i
};
var parseQuarterPatterns$1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns$1 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mär|apr|mai|jun|jul|aug|sep|okt|nov|dez)/i,
  wide: /^(januar|februar|märz|april|mai|juni|juli|august|september|oktober|november|dezember)/i
};
var parseMonthPatterns$1 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mär/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns$1 = {
  narrow: /^[smdmf]/i,
  short: /^(so|mo|di|mi|do|fr|sa)/i,
  abbreviated: /^(son?|mon?|die?|mit?|don?|fre?|sam?)\.?/i,
  wide: /^(sonntag|montag|dienstag|mittwoch|donnerstag|freitag|samstag)/i
};
var parseDayPatterns$1 = {
  any: [/^so/i, /^mo/i, /^di/i, /^mi/i, /^do/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns$1 = {
  narrow: /^(vm\.?|nm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  abbreviated: /^(vorm\.?|nachm\.?|Mitternacht|Mittag|morgens|nachm\.?|abends|nachts)/i,
  wide: /^(vormittags|nachmittags|Mitternacht|Mittag|morgens|nachmittags|abends|nachts)/i
};
var parseDayPeriodPatterns$1 = {
  any: {
    am: /^v/i,
    pm: /^n/i,
    midnight: /^Mitte/i,
    noon: /^Mitta/i,
    morning: /morgens/i,
    afternoon: /nachmittags/i,
    // will never be matched. Afternoon is matched by `pm`
    evening: /abends/i,
    night: /nachts/i
    // will never be matched. Night is matched by `pm`
  }
};
var match$2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: "any",
    valueCallback: function(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: "any"
  })
};
const match$3 = match$2;
var locale$1 = {
  code: "de",
  formatDistance: formatDistance$1,
  formatLong: formatLong$3,
  formatRelative: formatRelative$1,
  localize: localize$3,
  match: match$3,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const jo = locale$1;
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
function formatDistance(token, count, options) {
  options = options || {};
  var result;
  if (typeof formatDistanceLocale[token] === "string") {
    result = formatDistanceLocale[token];
  } else if (count === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace("{{count}}", count);
  }
  if (options.addSuffix) {
    if (options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
function ordinalNumber(dirtyNumber, _dirtyOptions) {
  var number2 = Number(dirtyNumber);
  var rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
}
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(quarter) {
      return Number(quarter) - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const localize$1 = localize;
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const match$1 = match;
var locale = {
  code: "en-US",
  formatDistance,
  formatLong: formatLong$1,
  formatRelative,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const Ko = locale;
var mousetrap = { exports: {} };
(function(module2) {
  (function(window2, document2, undefined$12) {
    if (!window2) {
      return;
    }
    var _MAP = {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      20: "capslock",
      27: "esc",
      32: "space",
      33: "pageup",
      34: "pagedown",
      35: "end",
      36: "home",
      37: "left",
      38: "up",
      39: "right",
      40: "down",
      45: "ins",
      46: "del",
      91: "meta",
      93: "meta",
      224: "meta"
    };
    var _KEYCODE_MAP = {
      106: "*",
      107: "+",
      109: "-",
      110: ".",
      111: "/",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    var _SHIFT_MAP = {
      "~": "`",
      "!": "1",
      "@": "2",
      "#": "3",
      "$": "4",
      "%": "5",
      "^": "6",
      "&": "7",
      "*": "8",
      "(": "9",
      ")": "0",
      "_": "-",
      "+": "=",
      ":": ";",
      '"': "'",
      "<": ",",
      ">": ".",
      "?": "/",
      "|": "\\"
    };
    var _SPECIAL_ALIASES = {
      "option": "alt",
      "command": "meta",
      "return": "enter",
      "escape": "esc",
      "plus": "+",
      "mod": /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
    };
    var _REVERSE_MAP;
    for (var i = 1; i < 20; ++i) {
      _MAP[111 + i] = "f" + i;
    }
    for (i = 0; i <= 9; ++i) {
      _MAP[i + 96] = i.toString();
    }
    function _addEvent(object, type, callback) {
      if (object.addEventListener) {
        object.addEventListener(type, callback, false);
        return;
      }
      object.attachEvent("on" + type, callback);
    }
    function _characterFromEvent(e2) {
      if (e2.type == "keypress") {
        var character = String.fromCharCode(e2.which);
        if (!e2.shiftKey) {
          character = character.toLowerCase();
        }
        return character;
      }
      if (_MAP[e2.which]) {
        return _MAP[e2.which];
      }
      if (_KEYCODE_MAP[e2.which]) {
        return _KEYCODE_MAP[e2.which];
      }
      return String.fromCharCode(e2.which).toLowerCase();
    }
    function _modifiersMatch(modifiers1, modifiers2) {
      return modifiers1.sort().join(",") === modifiers2.sort().join(",");
    }
    function _eventModifiers(e2) {
      var modifiers = [];
      if (e2.shiftKey) {
        modifiers.push("shift");
      }
      if (e2.altKey) {
        modifiers.push("alt");
      }
      if (e2.ctrlKey) {
        modifiers.push("ctrl");
      }
      if (e2.metaKey) {
        modifiers.push("meta");
      }
      return modifiers;
    }
    function _preventDefault(e2) {
      if (e2.preventDefault) {
        e2.preventDefault();
        return;
      }
      e2.returnValue = false;
    }
    function _stopPropagation(e2) {
      if (e2.stopPropagation) {
        e2.stopPropagation();
        return;
      }
      e2.cancelBubble = true;
    }
    function _isModifier(key) {
      return key == "shift" || key == "ctrl" || key == "alt" || key == "meta";
    }
    function _getReverseMap() {
      if (!_REVERSE_MAP) {
        _REVERSE_MAP = {};
        for (var key in _MAP) {
          if (key > 95 && key < 112) {
            continue;
          }
          if (_MAP.hasOwnProperty(key)) {
            _REVERSE_MAP[_MAP[key]] = key;
          }
        }
      }
      return _REVERSE_MAP;
    }
    function _pickBestAction(key, modifiers, action) {
      if (!action) {
        action = _getReverseMap()[key] ? "keydown" : "keypress";
      }
      if (action == "keypress" && modifiers.length) {
        action = "keydown";
      }
      return action;
    }
    function _keysFromString(combination) {
      if (combination === "+") {
        return ["+"];
      }
      combination = combination.replace(/\+{2}/g, "+plus");
      return combination.split("+");
    }
    function _getKeyInfo(combination, action) {
      var keys3;
      var key;
      var i2;
      var modifiers = [];
      keys3 = _keysFromString(combination);
      for (i2 = 0; i2 < keys3.length; ++i2) {
        key = keys3[i2];
        if (_SPECIAL_ALIASES[key]) {
          key = _SPECIAL_ALIASES[key];
        }
        if (action && action != "keypress" && _SHIFT_MAP[key]) {
          key = _SHIFT_MAP[key];
          modifiers.push("shift");
        }
        if (_isModifier(key)) {
          modifiers.push(key);
        }
      }
      action = _pickBestAction(key, modifiers, action);
      return {
        key,
        modifiers,
        action
      };
    }
    function _belongsTo(element, ancestor) {
      if (element === null || element === document2) {
        return false;
      }
      if (element === ancestor) {
        return true;
      }
      return _belongsTo(element.parentNode, ancestor);
    }
    function Mousetrap(targetElement) {
      var self2 = this;
      targetElement = targetElement || document2;
      if (!(self2 instanceof Mousetrap)) {
        return new Mousetrap(targetElement);
      }
      self2.target = targetElement;
      self2._callbacks = {};
      self2._directMap = {};
      var _sequenceLevels = {};
      var _resetTimer;
      var _ignoreNextKeyup = false;
      var _ignoreNextKeypress = false;
      var _nextExpectedAction = false;
      function _resetSequences(doNotReset) {
        doNotReset = doNotReset || {};
        var activeSequences = false, key;
        for (key in _sequenceLevels) {
          if (doNotReset[key]) {
            activeSequences = true;
            continue;
          }
          _sequenceLevels[key] = 0;
        }
        if (!activeSequences) {
          _nextExpectedAction = false;
        }
      }
      function _getMatches(character, modifiers, e2, sequenceName, combination, level) {
        var i2;
        var callback;
        var matches2 = [];
        var action = e2.type;
        if (!self2._callbacks[character]) {
          return [];
        }
        if (action == "keyup" && _isModifier(character)) {
          modifiers = [character];
        }
        for (i2 = 0; i2 < self2._callbacks[character].length; ++i2) {
          callback = self2._callbacks[character][i2];
          if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
            continue;
          }
          if (action != callback.action) {
            continue;
          }
          if (action == "keypress" && !e2.metaKey && !e2.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
            var deleteCombo = !sequenceName && callback.combo == combination;
            var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
            if (deleteCombo || deleteSequence) {
              self2._callbacks[character].splice(i2, 1);
            }
            matches2.push(callback);
          }
        }
        return matches2;
      }
      function _fireCallback(callback, e2, combo, sequence) {
        if (self2.stopCallback(e2, e2.target || e2.srcElement, combo, sequence)) {
          return;
        }
        if (callback(e2, combo) === false) {
          _preventDefault(e2);
          _stopPropagation(e2);
        }
      }
      self2._handleKey = function(character, modifiers, e2) {
        var callbacks = _getMatches(character, modifiers, e2);
        var i2;
        var doNotReset = {};
        var maxLevel = 0;
        var processedSequenceCallback = false;
        for (i2 = 0; i2 < callbacks.length; ++i2) {
          if (callbacks[i2].seq) {
            maxLevel = Math.max(maxLevel, callbacks[i2].level);
          }
        }
        for (i2 = 0; i2 < callbacks.length; ++i2) {
          if (callbacks[i2].seq) {
            if (callbacks[i2].level != maxLevel) {
              continue;
            }
            processedSequenceCallback = true;
            doNotReset[callbacks[i2].seq] = 1;
            _fireCallback(callbacks[i2].callback, e2, callbacks[i2].combo, callbacks[i2].seq);
            continue;
          }
          if (!processedSequenceCallback) {
            _fireCallback(callbacks[i2].callback, e2, callbacks[i2].combo);
          }
        }
        var ignoreThisKeypress = e2.type == "keypress" && _ignoreNextKeypress;
        if (e2.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
          _resetSequences(doNotReset);
        }
        _ignoreNextKeypress = processedSequenceCallback && e2.type == "keydown";
      };
      function _handleKeyEvent(e2) {
        if (typeof e2.which !== "number") {
          e2.which = e2.keyCode;
        }
        var character = _characterFromEvent(e2);
        if (!character) {
          return;
        }
        if (e2.type == "keyup" && _ignoreNextKeyup === character) {
          _ignoreNextKeyup = false;
          return;
        }
        self2.handleKey(character, _eventModifiers(e2), e2);
      }
      function _resetSequenceTimer() {
        clearTimeout(_resetTimer);
        _resetTimer = setTimeout(_resetSequences, 1e3);
      }
      function _bindSequence(combo, keys3, callback, action) {
        _sequenceLevels[combo] = 0;
        function _increaseSequence(nextAction) {
          return function() {
            _nextExpectedAction = nextAction;
            ++_sequenceLevels[combo];
            _resetSequenceTimer();
          };
        }
        function _callbackAndReset(e2) {
          _fireCallback(callback, e2, combo);
          if (action !== "keyup") {
            _ignoreNextKeyup = _characterFromEvent(e2);
          }
          setTimeout(_resetSequences, 10);
        }
        for (var i2 = 0; i2 < keys3.length; ++i2) {
          var isFinal = i2 + 1 === keys3.length;
          var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys3[i2 + 1]).action);
          _bindSingle(keys3[i2], wrappedCallback, action, combo, i2);
        }
      }
      function _bindSingle(combination, callback, action, sequenceName, level) {
        self2._directMap[combination + ":" + action] = callback;
        combination = combination.replace(/\s+/g, " ");
        var sequence = combination.split(" ");
        var info;
        if (sequence.length > 1) {
          _bindSequence(combination, sequence, callback, action);
          return;
        }
        info = _getKeyInfo(combination, action);
        self2._callbacks[info.key] = self2._callbacks[info.key] || [];
        _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
        self2._callbacks[info.key][sequenceName ? "unshift" : "push"]({
          callback,
          modifiers: info.modifiers,
          action: info.action,
          seq: sequenceName,
          level,
          combo: combination
        });
      }
      self2._bindMultiple = function(combinations, callback, action) {
        for (var i2 = 0; i2 < combinations.length; ++i2) {
          _bindSingle(combinations[i2], callback, action);
        }
      };
      _addEvent(targetElement, "keypress", _handleKeyEvent);
      _addEvent(targetElement, "keydown", _handleKeyEvent);
      _addEvent(targetElement, "keyup", _handleKeyEvent);
    }
    Mousetrap.prototype.bind = function(keys3, callback, action) {
      var self2 = this;
      keys3 = keys3 instanceof Array ? keys3 : [keys3];
      self2._bindMultiple.call(self2, keys3, callback, action);
      return self2;
    };
    Mousetrap.prototype.unbind = function(keys3, action) {
      var self2 = this;
      return self2.bind.call(self2, keys3, function() {
      }, action);
    };
    Mousetrap.prototype.trigger = function(keys3, action) {
      var self2 = this;
      if (self2._directMap[keys3 + ":" + action]) {
        self2._directMap[keys3 + ":" + action]({}, keys3);
      }
      return self2;
    };
    Mousetrap.prototype.reset = function() {
      var self2 = this;
      self2._callbacks = {};
      self2._directMap = {};
      return self2;
    };
    Mousetrap.prototype.stopCallback = function(e2, element) {
      var self2 = this;
      if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
        return false;
      }
      if (_belongsTo(element, self2.target)) {
        return false;
      }
      if ("composedPath" in e2 && typeof e2.composedPath === "function") {
        var initialEventTarget = e2.composedPath()[0];
        if (initialEventTarget !== e2.target) {
          element = initialEventTarget;
        }
      }
      return element.tagName == "INPUT" || element.tagName == "SELECT" || element.tagName == "TEXTAREA" || element.isContentEditable;
    };
    Mousetrap.prototype.handleKey = function() {
      var self2 = this;
      return self2._handleKey.apply(self2, arguments);
    };
    Mousetrap.addKeycodes = function(object) {
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          _MAP[key] = object[key];
        }
      }
      _REVERSE_MAP = null;
    };
    Mousetrap.init = function() {
      var documentMousetrap = Mousetrap(document2);
      for (var method in documentMousetrap) {
        if (method.charAt(0) !== "_") {
          Mousetrap[method] = function(method2) {
            return function() {
              return documentMousetrap[method2].apply(documentMousetrap, arguments);
            };
          }(method);
        }
      }
    };
    Mousetrap.init();
    window2.Mousetrap = Mousetrap;
    if (module2.exports) {
      module2.exports = Mousetrap;
    }
    if (typeof undefined$12 === "function" && undefined$12.amd) {
      undefined$12(function() {
        return Mousetrap;
      });
    }
  })(typeof window !== "undefined" ? window : null, typeof window !== "undefined" ? document : null);
})(mousetrap);
var mousetrapExports = mousetrap.exports;
const cr = /* @__PURE__ */ getDefaultExportFromCjs(mousetrapExports);
var isProduction = true;
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x) {
    }
  }
}
var reactIs$1 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$2 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$2 = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$1 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$2 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$1:
          case e$2:
          case g$1:
          case f$1:
          case p$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n$2:
              case t$1:
              case r$2:
              case h$1:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$1(a2) {
  return z$1(a2) === m$1;
}
reactIs_production_min$1.AsyncMode = l$1;
reactIs_production_min$1.ConcurrentMode = m$1;
reactIs_production_min$1.ContextConsumer = k$1;
reactIs_production_min$1.ContextProvider = h$1;
reactIs_production_min$1.Element = c$1;
reactIs_production_min$1.ForwardRef = n$2;
reactIs_production_min$1.Fragment = e$2;
reactIs_production_min$1.Lazy = t$1;
reactIs_production_min$1.Memo = r$2;
reactIs_production_min$1.Portal = d$1;
reactIs_production_min$1.Profiler = g$1;
reactIs_production_min$1.StrictMode = f$1;
reactIs_production_min$1.Suspense = p$1;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A$1(a2) || z$1(a2) === l$1;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z$1(a2) === k$1;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z$1(a2) === h$1;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$1;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z$1(a2) === n$2;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z$1(a2) === e$2;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z$1(a2) === t$1;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z$1(a2) === r$2;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z$1(a2) === d$1;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z$1(a2) === g$1;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z$1(a2) === f$1;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z$1(a2) === p$1;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$1 || a2 === g$1 || a2 === f$1 || a2 === p$1 || a2 === q$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$1 || a2.$$typeof === r$2 || a2.$$typeof === h$1 || a2.$$typeof === k$1 || a2.$$typeof === n$2 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$2 || a2.$$typeof === v$1);
};
reactIs_production_min$1.typeOf = z$1;
{
  reactIs$1.exports = reactIs_production_min$1;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty$2 = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys3 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i = 0; i < keys3.length; ++i) {
      var key = keys3[i];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty$2(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
const hoistNonReactStatics$1 = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjs);
function throttle(delay, noTrailing, callback, debounceMode) {
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  }
  if (typeof noTrailing !== "boolean") {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = void 0;
  }
  function wrapper() {
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    var args = arguments;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, args);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      exec();
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce$1(delay, atBegin, callback) {
  return callback === void 0 ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
}
const SvgE05728E87Cd1Ca23 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 2", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M1.488.012A1.503 1.503 0 0 0 .42 2.56l7.353 7.353A32.31 32.31 0 0 0 .17 19.301a1.53 1.53 0 0 0 0 1.379C.46 21.27 7.45 35 20 35a18.35 18.35 0 0 0 9.836-3.023l7.584 7.584a1.47 1.47 0 0 0 1.06.439 1.45 1.45 0 0 0 1.1-.41 1.49 1.49 0 0 0 0-2.12l-37-37A1.503 1.503 0 0 0 1.488.013zM19.855 5.07a16.18 16.18 0 0 0-3.685.44 1.5 1.5 0 1 0 .68 2.92A13.9 13.9 0 0 1 20 8.07c9.23 0 15.26 9.33 16.77 11.93a29.8 29.8 0 0 1-3.11 4.45 1.49 1.49 0 0 0 .18 2.11 1.48 1.48 0 0 0 1 .36l.02-.04a1.5 1.5 0 0 0 1.14-.54 31.88 31.88 0 0 0 3.82-5.62 1.5 1.5 0 0 0 0-1.38C39.53 18.76 32.55 5.07 20 5.07a16.18 16.18 0 0 0-.145 0zM9.9 12.041l4.495 4.494A6.55 6.55 0 0 0 19.84 26.76l.28-.09a6.47 6.47 0 0 0 3.325-1.084L27.66 29.8A15.32 15.32 0 0 1 20 32c-9.23 0-15.26-9.37-16.77-12a29.25 29.25 0 0 1 6.67-7.959zm6.688 6.688 4.674 4.673a3.56 3.56 0 0 1-1.282.309 3.62 3.62 0 0 1-2.55-.922 3.55 3.55 0 0 1-.842-4.06z" }));
const Svg5D0Be631Bf7D3947 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 1", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M20 5C7.45 5 .46 18.72.17 19.31a1.5 1.5 0 0 0 0 1.34c.29.58 7.28 14.28 19.83 14.28 12.55 0 19.54-13.7 19.83-14.3a1.44 1.44 0 0 0 0-1.34C39.54 18.7 32.55 5 20 5zm0 3c9.24 0 15.28 9.37 16.78 12-1.5 2.59-7.55 12-16.78 12S4.73 22.61 3.22 20C4.73 17.36 10.76 8 20 8zm0 5.43a6.54 6.54 0 0 0 0 13.08A6.54 6.54 0 0 0 26.54 20 6.52 6.52 0 0 0 20 13.43zm0 3a3.52 3.52 0 0 1 2.54 1.07 3.48 3.48 0 0 1 1 2.5A3.54 3.54 0 1 1 20 16.43z" }));
const SvgB1C9Ac3221E94B98 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 49, height: 49, viewBox: "0 0 49 49", ...props }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("clipPath", { id: "checkmark_svg__a" }, /* @__PURE__ */ reactExports.createElement("path", { fill: "none", d: "M0 0h49v49H0z" }))), /* @__PURE__ */ reactExports.createElement("g", { clipPath: "url(#checkmark_svg__a)" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M17.373 37.182l23.465-35.2A4.454 4.454 0 0 1 47.015.747a4.454 4.454 0 0 1 1.235 6.177l-26.727 40.09a4.455 4.455 0 0 1-7.088.428L1.072 31.854a4.454 4.454 0 0 1 .483-6.281 4.455 4.455 0 0 1 6.281.483z" })));
const Svg32192847008Cf9Fc = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 3", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M16.54.07a5.48 5.48 0 0 0-5.48 5.48v2a1.5 1.5 0 0 0 3 0v-2a2.49 2.49 0 0 1 2.48-2.48h17.92a2.48 2.48 0 0 1 2.48 2.48v17.91a2.48 2.48 0 0 1-2.48 2.48h-2a1.5 1.5 0 0 0 0 3h2a5.49 5.49 0 0 0 5.48-5.48V5.55A5.48 5.48 0 0 0 34.46.07H16.54zM5.57 11a5.5 5.5 0 0 0-5.48 5.53v17.91a5.49 5.49 0 0 0 5.48 5.48h17.92A5.49 5.49 0 0 0 29 34.44V16.53A5.49 5.49 0 0 0 23.49 11H5.57zm0 3h17.92A2.49 2.49 0 0 1 26 16.53v17.91a2.49 2.49 0 0 1-2.51 2.48H5.57a2.48 2.48 0 0 1-2.48-2.48V16.48A2.49 2.49 0 0 1 5.57 14z" }));
function _extends$4() {
  _extends$4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var ReactPropTypesSecret$5 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1$2 = ReactPropTypesSecret$5;
var ReactPropTypesSecret$4 = ReactPropTypesSecret_1$2;
function emptyFunction$2() {
}
function emptyFunctionWithReset$2() {
}
emptyFunctionWithReset$2.resetWarningCache = emptyFunction$2;
var factoryWithThrowingShims$2 = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret$4) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset$2,
    resetWarningCache: emptyFunction$2
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  factoryWithThrowingShims$2();
}
function hasClass(element, className) {
  if (element.classList)
    return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList)
    element.classList.add(className);
  else if (!hasClass(element, className))
    if (typeof element.className === "string")
      element.className = element.className + " " + className;
    else
      element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
const config = {
  disabled: false
};
const TransitionGroupContext = React$1.createContext(null);
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose$4(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React$1.cloneElement(React$1.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React$1.Component);
Transition$1.contextType = TransitionGroupContext;
Transition$1.propTypes = {};
function noop$2() {
}
Transition$1.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$2,
  onEntering: noop$2,
  onEntered: noop$2,
  onExit: noop$2,
  onExiting: noop$2,
  onExited: noop$2
};
Transition$1.UNMOUNTED = UNMOUNTED;
Transition$1.EXITED = EXITED;
Transition$1.ENTERING = ENTERING;
Transition$1.ENTERED = ENTERED;
Transition$1.EXITING = EXITING;
const Transition$2 = Transition$1;
var _addClass = function addClass$1(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c2) {
    return addClass(node, c2);
  });
};
var removeClass = function removeClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c2) {
    return removeClass$1(node, c2);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames2 = _this.props.classNames;
      var isStringClassNames = typeof classNames2 === "string";
      var prefix = isStringClassNames && classNames2 ? classNames2 + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames2[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames2[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames2[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      node && node.scrollTop;
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node, baseClassName);
    }
    if (activeClassName) {
      removeClass(node, activeClassName);
    }
    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose$4(_this$props, ["classNames"]);
    return /* @__PURE__ */ React$1.createElement(Transition$2, _extends$4({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React$1.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
const Ut = CSSTransition;
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized$2(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$4({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose$4(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React$1.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React$1.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const hr = TransitionGroup;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren)
    return false;
  if (React$1.isValidElement(oldChildren) && React$1.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name, cb2) {
  return function() {
    var _element$props;
    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb2();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return React$1.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children = _ref2.children;
  return [current, React$1.cloneElement(children, {
    in: true,
    onEntered: callHook(children, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children = _ref3.children, changeState = _ref3.changeState;
  return React$1.cloneElement(children, {
    in: true,
    onEntered: callHook(children, "onEntered", function() {
      changeState(ENTERED, React$1.cloneElement(children, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children = _ref4.children, changeState = _ref4.changeState;
  return [React$1.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, React$1.cloneElement(children, {
        in: true
      }));
    })
  }), React$1.cloneElement(children, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: React$1.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render() {
    var _this$props = this.props, children = _this$props.children, mode2 = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode2](data);
        break;
      case EXITING:
        component = leaveRenders[mode2](data);
        break;
      case ENTERED:
        component = current;
    }
    return /* @__PURE__ */ React$1.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(React$1.Component);
SwitchTransition.propTypes = {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
const mr = SwitchTransition;
const SvgD1032194Ec1096E8 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 43, height: 43, viewBox: "0 0 43 43", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M13.361.31a13.05 13.05 0 1 0 0 26.1 13.05 13.05 0 0 0 0-26.1zM9.185 4.85a4.325 4.325 0 0 1 4.333 4.334 4.321 4.321 0 0 1-4.333 4.333 4.321 4.321 0 0 1-4.333-4.333A4.324 4.324 0 0 1 9.185 4.85zm18.53 14.563a15.424 15.424 0 0 1-1.723 3.028l13.05 13.049a1.487 1.487 0 0 1 0 2.088 1.49 1.49 0 0 1-2.088 0L24.061 24.632a15.693 15.693 0 0 1-5.689 3.447v2.297c0 .735.62 1.356 1.358 1.356h3.653v3.655c0 .735.62 1.356 1.358 1.356h3.653v3.655c0 .735.621 1.356 1.358 1.356h3.705l.94.94c.571.57 6.294.856 7.725-.574 1.432-1.433 1.143-7.155.573-7.725l-14.98-14.981z" }));
const Svg680Caa6137361575 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 15.366, height: 30.746, viewBox: "0 0 15.366 30.746", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M23.281,2.25H12.4a2.258,2.258,0,0,0-2.272,2.258V30.656A2.325,2.325,0,0,0,12.4,33H23.274a2.279,2.279,0,0,0,2.217-2.34V4.508A2.2,2.2,0,0,0,23.281,2.25Zm-6.5,1.578h2.059a.275.275,0,1,1,0,.549H16.782a.275.275,0,0,1,0-.549Zm1.064,28.138a1.194,1.194,0,1,1,1.194-1.194A1.2,1.2,0,0,1,17.846,31.967ZM24.263,28.6H11.36a.138.138,0,0,1-.137-.137V5.887a.138.138,0,0,1,.137-.137h12.9a.138.138,0,0,1,.137.137V28.467A.138.138,0,0,1,24.263,28.6Z", transform: "translate(-10.125 -2.25)" }));
const SvgD3851543766Ba342 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 28, height: 51, viewBox: "0 0 28 51", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M22.306 0c.461 0 .907.165 1.255.466.347.3.573.714.636 1.167l.018.257v11.05a5.729 5.729 0 0 1 2.614 1.902 5.64 5.64 0 0 1 1.153 3.002l.018.428v26.456c0 1.437-.55 2.82-1.54 3.871a5.75 5.75 0 0 1-3.795 1.788l-.392.013H5.727a5.76 5.76 0 0 1-3.909-1.525 5.646 5.646 0 0 1-1.805-3.756L0 44.73V18.275a5.63 5.63 0 0 1 1.06-3.29 5.722 5.722 0 0 1 2.791-2.07V1.89c0-.457.167-.898.47-1.242a1.915 1.915 0 0 1 1.18-.63L5.758 0h16.548zm-.033 16.385H5.727a1.92 1.92 0 0 0-1.254.466c-.348.3-.574.714-.637 1.167l-.018.257V44.73c0 .957.718 1.746 1.65 1.872l.26.018h16.545a1.92 1.92 0 0 0 1.255-.466c.347-.3.573-.715.636-1.167l.018-.257V18.275c0-.457-.167-.898-.47-1.242a1.915 1.915 0 0 0-1.18-.63l-.26-.018zM20.397 3.78H7.667v8.824h12.73V3.78z" }));
const Svg1Bcfd951Ee5Cd05C = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 18.672, height: 18.672, viewBox: "0 0 18.672 18.672", ...props }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("style", null, ".close_svg__a{fill:none;stroke:currentColor;stroke-width:2px}")), /* @__PURE__ */ reactExports.createElement("path", { className: "close_svg__a", d: "M.707.707l17.258 17.258M17.965.707L.707 17.965" }));
const SvgAd255589C29Ec33D = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M0 0h24v24H0z", fill: "transparent" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M12 2a10 10 0 1010 10A10 10 0 0012 2zm1 15h-2v-2h2zm0-4h-2V7h2z", fill: "#f03c51" }));
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var index$1 = reactExports.useLayoutEffect;
var useLatest = function useLatest2(value) {
  var ref = reactExports.useRef(value);
  index$1(function() {
    ref.current = value;
  });
  return ref;
};
var updateRef = function updateRef2(ref, value) {
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  ref.current = value;
};
var useComposedRef = function useComposedRef2(libRef, userRef) {
  var prevUserRef = reactExports.useRef();
  return reactExports.useCallback(function(instance) {
    libRef.current = instance;
    if (prevUserRef.current) {
      updateRef(prevUserRef.current, null);
    }
    prevUserRef.current = userRef;
    if (!userRef) {
      return;
    }
    updateRef(userRef, instance);
  }, [userRef]);
};
var HIDDEN_TEXTAREA_STYLE = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
};
var forceHiddenStyles = function forceHiddenStyles2(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function(key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
  });
};
var forceHiddenStyles$1 = forceHiddenStyles;
var hiddenTextarea = null;
var getHeight = function getHeight2(node, sizingData) {
  var height = node.scrollHeight;
  if (sizingData.sizingStyle.boxSizing === "border-box") {
    return height + sizingData.borderSize;
  }
  return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  if (minRows === void 0) {
    minRows = 1;
  }
  if (maxRows === void 0) {
    maxRows = Infinity;
  }
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tabindex", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    forceHiddenStyles$1(hiddenTextarea);
  }
  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }
  var paddingSize = sizingData.paddingSize, borderSize = sizingData.borderSize, sizingStyle = sizingData.sizingStyle;
  var boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function(_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles$1(hiddenTextarea);
  hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = value;
  height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = "x";
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  var minHeight = rowHeight * minRows;
  if (boxSizing === "border-box") {
    minHeight = minHeight + paddingSize + borderSize;
  }
  height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;
  if (boxSizing === "border-box") {
    maxHeight = maxHeight + paddingSize + borderSize;
  }
  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}
var noop$1 = function noop() {
};
var pick = function pick2(props, obj) {
  return props.reduce(function(acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
};
var SIZING_STYLE = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
];
var isIE = !!document.documentElement.currentStyle;
var getSizingData = function getSizingData2(node) {
  var style = window.getComputedStyle(node);
  if (style === null) {
    return null;
  }
  var sizingStyle = pick(SIZING_STYLE, style);
  var boxSizing = sizingStyle.boxSizing;
  if (boxSizing === "") {
    return null;
  }
  if (isIE && boxSizing === "border-box") {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + "px";
  }
  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return {
    sizingStyle,
    paddingSize,
    borderSize
  };
};
var getSizingData$1 = getSizingData;
function useListener(target, type, listener) {
  var latestListener = useLatest(listener);
  reactExports.useLayoutEffect(function() {
    var handler = function handler2(ev) {
      return latestListener.current(ev);
    };
    if (!target) {
      return;
    }
    target.addEventListener(type, handler);
    return function() {
      return target.removeEventListener(type, handler);
    };
  }, []);
}
var useWindowResizeListener = function useWindowResizeListener2(listener) {
  useListener(window, "resize", listener);
};
var useFontsLoadedListener = function useFontsLoadedListener2(listener) {
  useListener(document.fonts, "loadingdone", listener);
};
var _excluded = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"];
var TextareaAutosize = function TextareaAutosize2(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements, maxRows = _ref.maxRows, minRows = _ref.minRows, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop$1 : _ref$onChange, _ref$onHeightChange = _ref.onHeightChange, onHeightChange = _ref$onHeightChange === void 0 ? noop$1 : _ref$onHeightChange, props = _objectWithoutPropertiesLoose$3(_ref, _excluded);
  var isControlled = props.value !== void 0;
  var libRef = reactExports.useRef(null);
  var ref = useComposedRef(libRef, userRef);
  var heightRef = reactExports.useRef(0);
  var measurementsCacheRef = reactExports.useRef();
  var resizeTextarea = function resizeTextarea2() {
    var node = libRef.current;
    var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
    if (!nodeSizingData) {
      return;
    }
    measurementsCacheRef.current = nodeSizingData;
    var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", minRows, maxRows), height = _calculateNodeHeight[0], rowHeight = _calculateNodeHeight[1];
    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty("height", height + "px", "important");
      onHeightChange(height, {
        rowHeight
      });
    }
  };
  var handleChange = function handleChange2(event) {
    if (!isControlled) {
      resizeTextarea();
    }
    onChange(event);
  };
  {
    reactExports.useLayoutEffect(resizeTextarea);
    useWindowResizeListener(resizeTextarea);
    useFontsLoadedListener(resizeTextarea);
    return /* @__PURE__ */ reactExports.createElement("textarea", _extends$3({}, props, {
      onChange: handleChange,
      ref
    }));
  }
};
var index = /* @__PURE__ */ reactExports.forwardRef(TextareaAutosize);
const SvgE7A3F077F365818E = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: 24, viewBox: "0 0 24 24", width: 24, ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" }));
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends$2() {
  _extends$2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$3 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1$1 = ReactPropTypesSecret$3;
var ReactPropTypesSecret$2 = ReactPropTypesSecret_1$1;
function emptyFunction$1() {
}
function emptyFunctionWithReset$1() {
}
emptyFunctionWithReset$1.resetWarningCache = emptyFunction$1;
var factoryWithThrowingShims$1 = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret$2) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset$1,
    resetWarningCache: emptyFunction$1
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims$1();
}
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var reactIs_production_min = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = 60103, c = 60106, d = 60107, e$1 = 60108, f = 60114, g = 60109, h = 60110, k = 60112, l = 60113, m = 60120, n$1 = 60115, p = 60116, q = 60121, r$1 = 60122, u = 60117, v = 60129, w = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var x = Symbol.for;
  b = x("react.element");
  c = x("react.portal");
  d = x("react.fragment");
  e$1 = x("react.strict_mode");
  f = x("react.profiler");
  g = x("react.provider");
  h = x("react.context");
  k = x("react.forward_ref");
  l = x("react.suspense");
  m = x("react.suspense_list");
  n$1 = x("react.memo");
  p = x("react.lazy");
  q = x("react.block");
  r$1 = x("react.server.block");
  u = x("react.fundamental");
  v = x("react.debug_trace_mode");
  w = x("react.legacy_hidden");
}
function y$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var t2 = a2.$$typeof;
    switch (t2) {
      case b:
        switch (a2 = a2.type, a2) {
          case d:
          case f:
          case e$1:
          case l:
          case m:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case h:
              case k:
              case p:
              case n$1:
              case g:
                return a2;
              default:
                return t2;
            }
        }
      case c:
        return t2;
    }
  }
}
var z = g, A = b, B = k, C = d, D = p, E = n$1, F = c, G$1 = f, H = e$1, I = l;
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = z;
reactIs_production_min.Element = A;
reactIs_production_min.ForwardRef = B;
reactIs_production_min.Fragment = C;
reactIs_production_min.Lazy = D;
reactIs_production_min.Memo = E;
reactIs_production_min.Portal = F;
reactIs_production_min.Profiler = G$1;
reactIs_production_min.StrictMode = H;
reactIs_production_min.Suspense = I;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return y$1(a2) === h;
};
reactIs_production_min.isContextProvider = function(a2) {
  return y$1(a2) === g;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a2) {
  return y$1(a2) === k;
};
reactIs_production_min.isFragment = function(a2) {
  return y$1(a2) === d;
};
reactIs_production_min.isLazy = function(a2) {
  return y$1(a2) === p;
};
reactIs_production_min.isMemo = function(a2) {
  return y$1(a2) === n$1;
};
reactIs_production_min.isPortal = function(a2) {
  return y$1(a2) === c;
};
reactIs_production_min.isProfiler = function(a2) {
  return y$1(a2) === f;
};
reactIs_production_min.isStrictMode = function(a2) {
  return y$1(a2) === e$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return y$1(a2) === l;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f || a2 === v || a2 === e$1 || a2 === l || a2 === m || a2 === w || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p || a2.$$typeof === n$1 || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === u || a2.$$typeof === q || a2[0] === r$1) ? true : false;
};
reactIs_production_min.typeOf = y$1;
function t(t2) {
  return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
}
function e(t2, e2) {
  return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
}
function n(t2, n2) {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    var r2 = getComputedStyle(t2, null);
    return e(r2.overflowY, n2) || e(r2.overflowX, n2) || function(t3) {
      var e2 = function(t4) {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      }(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    }(t2);
  }
  return false;
}
function r(t2, e2, n2, r2, i, o2, l2, d2) {
  return o2 < t2 && l2 > e2 || o2 > t2 && l2 < e2 ? 0 : o2 <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o2 - t2 - r2 : l2 > e2 && d2 < n2 || o2 < t2 && d2 > n2 ? l2 - e2 + i : 0;
}
function compute(e2, i) {
  var o2 = window, l2 = i.scrollMode, d2 = i.block, u2 = i.inline, h2 = i.boundary, a2 = i.skipOverflowHiddenElements, c2 = "function" == typeof h2 ? h2 : function(t2) {
    return t2 !== h2;
  };
  if (!t(e2))
    throw new TypeError("Invalid target");
  for (var f2 = document.scrollingElement || document.documentElement, s2 = [], p2 = e2; t(p2) && c2(p2); ) {
    if ((p2 = p2.parentElement) === f2) {
      s2.push(p2);
      break;
    }
    null != p2 && p2 === document.body && n(p2) && !n(document.documentElement) || null != p2 && n(p2, a2) && s2.push(p2);
  }
  for (var m2 = o2.visualViewport ? o2.visualViewport.width : innerWidth, g2 = o2.visualViewport ? o2.visualViewport.height : innerHeight, w2 = window.scrollX || pageXOffset, v2 = window.scrollY || pageYOffset, W2 = e2.getBoundingClientRect(), b2 = W2.height, H2 = W2.width, y2 = W2.top, E2 = W2.right, M2 = W2.bottom, V2 = W2.left, x = "start" === d2 || "nearest" === d2 ? y2 : "end" === d2 ? M2 : y2 + b2 / 2, I2 = "center" === u2 ? V2 + H2 / 2 : "end" === u2 ? E2 : V2, C2 = [], T2 = 0; T2 < s2.length; T2++) {
    var k2 = s2[T2], B2 = k2.getBoundingClientRect(), D2 = B2.height, O2 = B2.width, R2 = B2.top, X2 = B2.right, Y2 = B2.bottom, L2 = B2.left;
    if ("if-needed" === l2 && y2 >= 0 && V2 >= 0 && M2 <= g2 && E2 <= m2 && y2 >= R2 && M2 <= Y2 && V2 >= L2 && E2 <= X2)
      return C2;
    var S2 = getComputedStyle(k2), j = parseInt(S2.borderLeftWidth, 10), q2 = parseInt(S2.borderTopWidth, 10), z2 = parseInt(S2.borderRightWidth, 10), A2 = parseInt(S2.borderBottomWidth, 10), F2 = 0, G2 = 0, J2 = "offsetWidth" in k2 ? k2.offsetWidth - k2.clientWidth - j - z2 : 0, K2 = "offsetHeight" in k2 ? k2.offsetHeight - k2.clientHeight - q2 - A2 : 0;
    if (f2 === k2)
      F2 = "start" === d2 ? x : "end" === d2 ? x - g2 : "nearest" === d2 ? r(v2, v2 + g2, g2, q2, A2, v2 + x, v2 + x + b2, b2) : x - g2 / 2, G2 = "start" === u2 ? I2 : "center" === u2 ? I2 - m2 / 2 : "end" === u2 ? I2 - m2 : r(w2, w2 + m2, m2, j, z2, w2 + I2, w2 + I2 + H2, H2), F2 = Math.max(0, F2 + v2), G2 = Math.max(0, G2 + w2);
    else {
      F2 = "start" === d2 ? x - R2 - q2 : "end" === d2 ? x - Y2 + A2 + K2 : "nearest" === d2 ? r(R2, Y2, D2, q2, A2 + K2, x, x + b2, b2) : x - (R2 + D2 / 2) + K2 / 2, G2 = "start" === u2 ? I2 - L2 - j : "center" === u2 ? I2 - (L2 + O2 / 2) + J2 / 2 : "end" === u2 ? I2 - X2 + z2 + J2 : r(L2, X2, O2, j, z2 + J2, I2, I2 + H2, H2);
      var N2 = k2.scrollLeft, P2 = k2.scrollTop;
      x += P2 - (F2 = Math.max(0, Math.min(P2 + F2, k2.scrollHeight - D2 + K2))), I2 += N2 - (G2 = Math.max(0, Math.min(N2 + G2, k2.scrollWidth - O2 + J2)));
    }
    C2.push({ el: k2, top: F2, left: G2 });
  }
  return C2;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var idCounter = 0;
function noop2() {
}
function scrollIntoView(node, menuNode) {
  if (!node) {
    return;
  }
  var actions = compute(node, {
    boundary: menuNode,
    block: "nearest",
    scrollMode: "if-needed"
  });
  actions.forEach(function(_ref) {
    var el2 = _ref.el, top = _ref.top, left = _ref.left;
    el2.scrollTop = top;
    el2.scrollLeft = left;
  });
}
function isOrContainsNode(parent, child, environment) {
  var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}
function debounce(fn, time) {
  var timeoutId;
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId = setTimeout(function() {
      timeoutId = null;
      fn.apply(void 0, args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some(function(fn) {
      if (fn) {
        fn.apply(void 0, [event].concat(args));
      }
      return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return function(node) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
}
function generateId() {
  return String(idCounter++);
}
function getA11yStatusMessage$1(_ref2) {
  var isOpen = _ref2.isOpen, resultCount = _ref2.resultCount, previousResultCount = _ref2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
  }
  return "";
}
function getState(state, props) {
  return Object.keys(state).reduce(function(prevState, key) {
    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
    return prevState;
  }, {});
}
function isControlledProp(props, key) {
  return props[key] !== void 0;
}
function normalizeArrowKey(event) {
  var key = event.key, keyCode = event.keyCode;
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
    return "Arrow" + key;
  }
  return key;
}
function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  if (circular === void 0) {
    circular = true;
  }
  if (itemCount === 0) {
    return -1;
  }
  var itemsLastIndex = itemCount - 1;
  if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
  }
  var newIndex = baseIndex + moveAmount;
  if (newIndex < 0) {
    newIndex = circular ? itemsLastIndex : 0;
  } else if (newIndex > itemsLastIndex) {
    newIndex = circular ? 0 : itemsLastIndex;
  }
  var nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
  if (nonDisabledNewIndex === -1) {
    return baseIndex >= itemCount ? -1 : baseIndex;
  }
  return nonDisabledNewIndex;
}
function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  var currentElementNode = getItemNodeFromIndex(baseIndex);
  if (!currentElementNode || !currentElementNode.hasAttribute("disabled")) {
    return baseIndex;
  }
  if (moveAmount > 0) {
    for (var index2 = baseIndex + 1; index2 < itemCount; index2++) {
      if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
        return index2;
      }
    }
  } else {
    for (var _index = baseIndex - 1; _index >= 0; _index--) {
      if (!getItemNodeFromIndex(_index).hasAttribute("disabled")) {
        return _index;
      }
    }
  }
  if (circular) {
    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
  }
  return -1;
}
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return downshiftElements.some(function(contextNode) {
    return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
  });
}
var cleanupStatus = debounce(function(documentProp) {
  getStatusDiv(documentProp).textContent = "";
}, 500);
function setStatus(status, documentProp) {
  var div = getStatusDiv(documentProp);
  if (!status) {
    return;
  }
  div.textContent = status;
  cleanupStatus(documentProp);
}
function getStatusDiv(documentProp) {
  if (documentProp === void 0) {
    documentProp = document;
  }
  var statusDiv = documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement("div");
  statusDiv.setAttribute("id", "a11y-status-message");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.setAttribute("aria-relevant", "additions text");
  Object.assign(statusDiv.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
var _excluded$3 = ["isInitialMount", "highlightedIndex", "items", "environment"];
var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ""
};
function callOnChangeProps(action, state, newState) {
  var props = action.props, type = action.type;
  var changes = {};
  Object.keys(state).forEach(function(key) {
    invokeOnChangeHandler(key, action, state, newState);
    if (newState[key] !== state[key]) {
      changes[key] = newState[key];
    }
  });
  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange(_extends$2({
      type
    }, changes));
  }
}
function invokeOnChangeHandler(key, action, state, newState) {
  var props = action.props, type = action.type;
  var handler = "on" + capitalizeString(key) + "Change";
  if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
    props[handler](_extends$2({
      type
    }, newState));
  }
}
function stateReducer(s2, a2) {
  return a2.changes;
}
function getA11ySelectionMessage(selectionParameters) {
  var selectedItem = selectionParameters.selectedItem, itemToStringLocal = selectionParameters.itemToString;
  return selectedItem ? itemToStringLocal(selectedItem) + " has been selected." : "";
}
var updateA11yStatus = debounce(function(getA11yMessage, document2) {
  setStatus(getA11yMessage(), document2);
}, 200);
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useElementIds(_ref) {
  var _ref$id = _ref.id, id2 = _ref$id === void 0 ? "downshift-" + generateId() : _ref$id, labelId = _ref.labelId, menuId = _ref.menuId, getItemId = _ref.getItemId, toggleButtonId = _ref.toggleButtonId, inputId = _ref.inputId;
  var elementIdsRef = reactExports.useRef({
    labelId: labelId || id2 + "-label",
    menuId: menuId || id2 + "-menu",
    getItemId: getItemId || function(index2) {
      return id2 + "-item-" + index2;
    },
    toggleButtonId: toggleButtonId || id2 + "-toggle-button",
    inputId: inputId || id2 + "-input"
  });
  return elementIdsRef.current;
}
function getItemIndex(index2, item, items) {
  if (index2 !== void 0) {
    return index2;
  }
  if (items.length === 0) {
    return -1;
  }
  return items.indexOf(item);
}
function itemToString(item) {
  return item ? String(item) : "";
}
function capitalizeString(string) {
  return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
}
function useLatestRef(val) {
  var ref = reactExports.useRef(val);
  ref.current = val;
  return ref;
}
function useEnhancedReducer(reducer, initialState, props) {
  var prevStateRef = reactExports.useRef();
  var actionRef = reactExports.useRef();
  var enhancedReducer = reactExports.useCallback(function(state2, action2) {
    actionRef.current = action2;
    state2 = getState(state2, action2.props);
    var changes = reducer(state2, action2);
    var newState = action2.props.stateReducer(state2, _extends$2({}, action2, {
      changes
    }));
    return newState;
  }, [reducer]);
  var _useReducer = reactExports.useReducer(enhancedReducer, initialState), state = _useReducer[0], dispatch = _useReducer[1];
  var propsRef = useLatestRef(props);
  var dispatchWithProps = reactExports.useCallback(function(action2) {
    return dispatch(_extends$2({
      props: propsRef.current
    }, action2));
  }, [propsRef]);
  var action = actionRef.current;
  reactExports.useEffect(function() {
    if (action && prevStateRef.current && prevStateRef.current !== state) {
      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
    }
    prevStateRef.current = state;
  }, [state, props, action]);
  return [state, dispatchWithProps];
}
var defaultProps$3 = {
  itemToString,
  stateReducer,
  getA11ySelectionMessage,
  scrollIntoView,
  circularNavigation: false,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window === "undefined" ? {} : window
  )
};
function getDefaultValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }
  var defaultPropKey = "default" + capitalizeString(propKey);
  if (defaultPropKey in props) {
    return props[defaultPropKey];
  }
  return defaultStateValues[propKey];
}
function getInitialValue$1(props, propKey, defaultStateValues) {
  if (defaultStateValues === void 0) {
    defaultStateValues = dropdownDefaultStateValues;
  }
  if (propKey in props) {
    return props[propKey];
  }
  var initialPropKey = "initial" + capitalizeString(propKey);
  if (initialPropKey in props) {
    return props[initialPropKey];
  }
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
function getInitialState$2(props) {
  var selectedItem = getInitialValue$1(props, "selectedItem");
  var isOpen = getInitialValue$1(props, "isOpen");
  var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
  var inputValue = getInitialValue$1(props, "inputValue");
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {
  var items = props.items, initialHighlightedIndex = props.initialHighlightedIndex, defaultHighlightedIndex = props.defaultHighlightedIndex;
  var selectedItem = state.selectedItem, highlightedIndex = state.highlightedIndex;
  if (items.length === 0) {
    return -1;
  }
  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {
    return initialHighlightedIndex;
  }
  if (defaultHighlightedIndex !== void 0) {
    return defaultHighlightedIndex;
  }
  if (selectedItem) {
    if (offset === 0) {
      return items.indexOf(selectedItem);
    }
    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);
  }
  if (offset === 0) {
    return -1;
  }
  return offset < 0 ? items.length - 1 : 0;
}
function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
  var mouseAndTouchTrackersRef = reactExports.useRef({
    isMouseDown: false,
    isTouchMove: false
  });
  reactExports.useEffect(function() {
    var onMouseDown = function onMouseDown2() {
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    };
    var onMouseUp = function onMouseUp2(event) {
      mouseAndTouchTrackersRef.current.isMouseDown = false;
      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref) {
        return ref.current;
      }), environment)) {
        handleBlur();
      }
    };
    var onTouchStart = function onTouchStart2() {
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    };
    var onTouchMove = function onTouchMove2() {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    };
    var onTouchEnd = function onTouchEnd2(event) {
      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(function(ref) {
        return ref.current;
      }), environment, false)) {
        handleBlur();
      }
    };
    environment.addEventListener("mousedown", onMouseDown);
    environment.addEventListener("mouseup", onMouseUp);
    environment.addEventListener("touchstart", onTouchStart);
    environment.addEventListener("touchmove", onTouchMove);
    environment.addEventListener("touchend", onTouchEnd);
    return function cleanup() {
      environment.removeEventListener("mousedown", onMouseDown);
      environment.removeEventListener("mouseup", onMouseUp);
      environment.removeEventListener("touchstart", onTouchStart);
      environment.removeEventListener("touchmove", onTouchMove);
      environment.removeEventListener("touchend", onTouchEnd);
    };
  }, [isOpen, environment]);
  return mouseAndTouchTrackersRef;
}
var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
  return noop2;
};
function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
  var isInitialMount = _ref2.isInitialMount, highlightedIndex = _ref2.highlightedIndex, items = _ref2.items, environment = _ref2.environment, rest = _objectWithoutPropertiesLoose$2(_ref2, _excluded$3);
  reactExports.useEffect(function() {
    if (isInitialMount || false) {
      return;
    }
    updateA11yStatus(function() {
      return getA11yMessage(_extends$2({
        highlightedIndex,
        highlightedItem: items[highlightedIndex],
        resultCount: items.length
      }, rest));
    }, environment.document);
  }, dependencyArray);
}
function useScrollIntoView(_ref3) {
  var highlightedIndex = _ref3.highlightedIndex, isOpen = _ref3.isOpen, itemRefs = _ref3.itemRefs, getItemNodeFromIndex = _ref3.getItemNodeFromIndex, menuElement = _ref3.menuElement, scrollIntoViewProp = _ref3.scrollIntoView;
  var shouldScrollRef = reactExports.useRef(true);
  useIsomorphicLayoutEffect$1(function() {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }
    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    }
  }, [highlightedIndex]);
  return shouldScrollRef;
}
var useControlPropsValidator = noop2;
function downshiftCommonReducer(state, action, stateChangeTypes) {
  var type = action.type, props = action.props;
  var changes;
  switch (type) {
    case stateChangeTypes.ItemMouseMove:
      changes = {
        highlightedIndex: action.index
      };
      break;
    case stateChangeTypes.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;
    case stateChangeTypes.ToggleButtonClick:
    case stateChangeTypes.FunctionToggleMenu:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;
    case stateChangeTypes.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: action.highlightedIndex
      };
      break;
    case stateChangeTypes.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;
    case stateChangeTypes.FunctionReset:
      changes = {
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        isOpen: getDefaultValue$1(props, "isOpen"),
        selectedItem: getDefaultValue$1(props, "selectedItem"),
        inputValue: getDefaultValue$1(props, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends$2({}, state, changes);
}
({
  items: PropTypes.array.isRequired,
  itemToString: PropTypes.func,
  getA11yStatusMessage: PropTypes.func,
  getA11ySelectionMessage: PropTypes.func,
  circularNavigation: PropTypes.bool,
  highlightedIndex: PropTypes.number,
  defaultHighlightedIndex: PropTypes.number,
  initialHighlightedIndex: PropTypes.number,
  isOpen: PropTypes.bool,
  defaultIsOpen: PropTypes.bool,
  initialIsOpen: PropTypes.bool,
  selectedItem: PropTypes.any,
  initialSelectedItem: PropTypes.any,
  defaultSelectedItem: PropTypes.any,
  id: PropTypes.string,
  labelId: PropTypes.string,
  menuId: PropTypes.string,
  getItemId: PropTypes.func,
  toggleButtonId: PropTypes.string,
  stateReducer: PropTypes.func,
  onSelectedItemChange: PropTypes.func,
  onHighlightedIndexChange: PropTypes.func,
  onStateChange: PropTypes.func,
  onIsOpenChange: PropTypes.func,
  environment: PropTypes.shape({
    addEventListener: PropTypes.func,
    removeEventListener: PropTypes.func,
    document: PropTypes.shape({
      getElementById: PropTypes.func,
      activeElement: PropTypes.any,
      body: PropTypes.any
    })
  })
});
function getA11yStatusMessage(_a2) {
  var isOpen = _a2.isOpen, resultCount = _a2.resultCount, previousResultCount = _a2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.";
  }
  return "";
}
__assign$1(__assign$1({}, defaultProps$3), { getA11yStatusMessage });
var InputKeyDownArrowDown = 0;
var InputKeyDownArrowUp = 1;
var InputKeyDownEscape = 2;
var InputKeyDownHome = 3;
var InputKeyDownEnd = 4;
var InputKeyDownEnter = 5;
var InputChange = 6;
var InputBlur = 7;
var MenuMouseLeave = 8;
var ItemMouseMove = 9;
var ItemClick = 10;
var ToggleButtonClick = 11;
var FunctionToggleMenu = 12;
var FunctionOpenMenu = 13;
var FunctionCloseMenu = 14;
var FunctionSetHighlightedIndex = 15;
var FunctionSelectItem = 16;
var FunctionSetInputValue = 17;
var FunctionReset$1 = 18;
var ControlledPropUpdatedSelectedItem = 19;
var stateChangeTypes$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  InputKeyDownArrowDown,
  InputKeyDownArrowUp,
  InputKeyDownEscape,
  InputKeyDownHome,
  InputKeyDownEnd,
  InputKeyDownEnter,
  InputChange,
  InputBlur,
  MenuMouseLeave,
  ItemMouseMove,
  ItemClick,
  ToggleButtonClick,
  FunctionToggleMenu,
  FunctionOpenMenu,
  FunctionCloseMenu,
  FunctionSetHighlightedIndex,
  FunctionSelectItem,
  FunctionSetInputValue,
  FunctionReset: FunctionReset$1,
  ControlledPropUpdatedSelectedItem
});
function getInitialState$1(props) {
  var initialState = getInitialState$2(props);
  var selectedItem = initialState.selectedItem;
  var inputValue = initialState.inputValue;
  if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
    inputValue = props.itemToString(selectedItem);
  }
  return _extends$2({}, initialState, {
    inputValue
  });
}
({
  items: PropTypes.array.isRequired,
  itemToString: PropTypes.func,
  getA11yStatusMessage: PropTypes.func,
  getA11ySelectionMessage: PropTypes.func,
  circularNavigation: PropTypes.bool,
  highlightedIndex: PropTypes.number,
  defaultHighlightedIndex: PropTypes.number,
  initialHighlightedIndex: PropTypes.number,
  isOpen: PropTypes.bool,
  defaultIsOpen: PropTypes.bool,
  initialIsOpen: PropTypes.bool,
  selectedItem: PropTypes.any,
  initialSelectedItem: PropTypes.any,
  defaultSelectedItem: PropTypes.any,
  inputValue: PropTypes.string,
  defaultInputValue: PropTypes.string,
  initialInputValue: PropTypes.string,
  id: PropTypes.string,
  labelId: PropTypes.string,
  menuId: PropTypes.string,
  getItemId: PropTypes.func,
  inputId: PropTypes.string,
  toggleButtonId: PropTypes.string,
  stateReducer: PropTypes.func,
  onSelectedItemChange: PropTypes.func,
  onHighlightedIndexChange: PropTypes.func,
  onStateChange: PropTypes.func,
  onIsOpenChange: PropTypes.func,
  onInputValueChange: PropTypes.func,
  environment: PropTypes.shape({
    addEventListener: PropTypes.func,
    removeEventListener: PropTypes.func,
    document: PropTypes.shape({
      getElementById: PropTypes.func,
      activeElement: PropTypes.any,
      body: PropTypes.any
    })
  })
});
function useControlledReducer(reducer, initialState, props) {
  var previousSelectedItemRef = reactExports.useRef();
  var _useEnhancedReducer = useEnhancedReducer(reducer, initialState, props), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  reactExports.useEffect(function() {
    if (isControlledProp(props, "selectedItem")) {
      if (previousSelectedItemRef.current !== props.selectedItem) {
        dispatch({
          type: ControlledPropUpdatedSelectedItem,
          inputValue: props.itemToString(props.selectedItem)
        });
      }
      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
    }
  });
  return [getState(state, props), dispatch];
}
var validatePropTypes$1 = noop2;
var defaultProps$1 = _extends$2({}, defaultProps$3, {
  getA11yStatusMessage: getA11yStatusMessage$1,
  circularNavigation: true
});
function downshiftUseComboboxReducer(state, action) {
  var type = action.type, props = action.props, shiftKey = action.shiftKey;
  var changes;
  switch (type) {
    case ItemClick:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        selectedItem: props.items[action.index],
        inputValue: props.itemToString(props.items[action.index])
      };
      break;
    case InputKeyDownArrowDown:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownArrowUp:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownEnter:
      changes = _extends$2({}, state.isOpen && state.highlightedIndex >= 0 && {
        selectedItem: props.items[state.highlightedIndex],
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        inputValue: props.itemToString(props.items[state.highlightedIndex])
      });
      break;
    case InputKeyDownEscape:
      changes = _extends$2({
        isOpen: false,
        highlightedIndex: -1
      }, !state.isOpen && {
        selectedItem: null,
        inputValue: ""
      });
      break;
    case InputKeyDownHome:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputKeyDownEnd:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputBlur:
      changes = _extends$2({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && action.selectItem && {
        selectedItem: props.items[state.highlightedIndex],
        inputValue: props.itemToString(props.items[state.highlightedIndex])
      });
      break;
    case InputChange:
      changes = {
        isOpen: true,
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        inputValue: action.inputValue
      };
      break;
    case FunctionSelectItem:
      changes = {
        selectedItem: action.selectedItem,
        inputValue: props.itemToString(action.selectedItem)
      };
      break;
    case ControlledPropUpdatedSelectedItem:
      changes = {
        inputValue: action.inputValue
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$1);
  }
  return _extends$2({}, state, changes);
}
var _excluded$1 = ["onMouseLeave", "refKey", "ref"], _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onClick", "onPress"], _excluded3 = ["onClick", "onPress", "refKey", "ref"], _excluded4 = ["onKeyDown", "onChange", "onInput", "onBlur", "onChangeText", "refKey", "ref"], _excluded5 = ["refKey", "ref"];
useCombobox.stateChangeTypes = stateChangeTypes$1;
function useCombobox(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$1();
  var props = _extends$2({}, defaultProps$1, userProps);
  var initialIsOpen = props.initialIsOpen, defaultIsOpen = props.defaultIsOpen, items = props.items, scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage, getA11ySelectionMessage2 = props.getA11ySelectionMessage, itemToString2 = props.itemToString;
  var initialState = getInitialState$1(props);
  var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, initialState, props), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var menuRef = reactExports.useRef(null);
  var itemRefs = reactExports.useRef({});
  var inputRef = reactExports.useRef(null);
  var toggleButtonRef = reactExports.useRef(null);
  var comboboxRef = reactExports.useRef(null);
  var isInitialMountRef = reactExports.useRef(true);
  var elementIds = useElementIds(props);
  var previousResultCountRef = reactExports.useRef();
  var latest = useLatestRef({
    state,
    props
  });
  var getItemNodeFromIndex = reactExports.useCallback(function(index2) {
    return itemRefs.current[elementIds.getItemId(index2)];
  }, [elementIds]);
  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], _extends$2({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], _extends$2({
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2
  }, state));
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  reactExports.useEffect(function() {
    var focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;
    if (focusOnOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  reactExports.useEffect(function() {
    if (isInitialMountRef.current) {
      return;
    }
    previousResultCountRef.current = items.length;
  });
  var mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, function() {
    dispatch({
      type: InputBlur,
      selectItem: false
    });
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker();
  reactExports.useEffect(function() {
    isInitialMountRef.current = false;
  }, []);
  reactExports.useEffect(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  var inputKeyDownHandlers = reactExports.useMemo(function() {
    return {
      ArrowDown: function ArrowDown(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowDown,
          shiftKey: event.shiftKey,
          getItemNodeFromIndex
        });
      },
      ArrowUp: function ArrowUp(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowUp,
          shiftKey: event.shiftKey,
          getItemNodeFromIndex
        });
      },
      Home: function Home(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownHome,
          getItemNodeFromIndex
        });
      },
      End: function End(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnd,
          getItemNodeFromIndex
        });
      },
      Escape: function Escape() {
        var latestState = latest.current.state;
        if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
          dispatch({
            type: InputKeyDownEscape
          });
        }
      },
      Enter: function Enter(event) {
        var latestState = latest.current.state;
        if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnter,
          getItemNodeFromIndex
        });
      }
    };
  }, [dispatch, latest, getItemNodeFromIndex]);
  var getLabelProps = reactExports.useCallback(function(labelProps) {
    return _extends$2({
      id: elementIds.labelId,
      htmlFor: elementIds.inputId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = reactExports.useCallback(function(_temp, _temp2) {
    var _extends2;
    var _ref = _temp === void 0 ? {} : _temp, onMouseLeave = _ref.onMouseLeave, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref = _ref.ref, rest = _objectWithoutPropertiesLoose$2(_ref, _excluded$1);
    var _ref2 = _temp2 === void 0 ? {} : _temp2;
    _ref2.suppressRefError;
    return _extends$2((_extends2 = {}, _extends2[refKey] = handleRefs(ref, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends2.id = elementIds.menuId, _extends2.role = "listbox", _extends2["aria-labelledby"] = elementIds.labelId, _extends2.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
      dispatch({
        type: MenuMouseLeave
      });
    }), _extends2), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getItemProps = reactExports.useCallback(function(_temp3) {
    var _extends3, _ref4;
    var _ref3 = _temp3 === void 0 ? {} : _temp3, item = _ref3.item, index2 = _ref3.index, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref = _ref3.ref, onMouseMove = _ref3.onMouseMove, onClick = _ref3.onClick;
    _ref3.onPress;
    var rest = _objectWithoutPropertiesLoose$2(_ref3, _excluded2$1);
    var _latest$current = latest.current, latestProps = _latest$current.props, latestState = _latest$current.state;
    var itemIndex = getItemIndex(index2, item, latestProps.items);
    if (itemIndex < 0) {
      throw new Error("Pass either item or item index in getItemProps!");
    }
    var onSelectKey = "onClick";
    var customClickHandler = onClick;
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (index2 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index2
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick,
        index: index2
      });
      if (inputRef.current) {
        inputRef.current.focus();
      }
    };
    return _extends$2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;
      }
    }), _extends3.role = "option", _extends3["aria-selected"] = "" + (itemIndex === latestState.highlightedIndex), _extends3.id = elementIds.getItemId(itemIndex), _extends3), !rest.disabled && (_ref4 = {
      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove)
    }, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), rest);
  }, [dispatch, latest, shouldScrollRef, elementIds]);
  var getToggleButtonProps = reactExports.useCallback(function(_temp4) {
    var _extends4;
    var _ref5 = _temp4 === void 0 ? {} : _temp4, onClick = _ref5.onClick;
    _ref5.onPress;
    var _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref = _ref5.ref, rest = _objectWithoutPropertiesLoose$2(_ref5, _excluded3);
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick
      });
      if (!latest.current.state.isOpen && inputRef.current) {
        inputRef.current.focus();
      }
    };
    return _extends$2((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends$2({}, {
      onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
    }), rest);
  }, [dispatch, latest, elementIds]);
  var getInputProps = reactExports.useCallback(function(_temp5, _temp6) {
    var _extends5;
    var _ref6 = _temp5 === void 0 ? {} : _temp5, onKeyDown = _ref6.onKeyDown, onChange = _ref6.onChange, onInput = _ref6.onInput, onBlur = _ref6.onBlur;
    _ref6.onChangeText;
    var _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, ref = _ref6.ref, rest = _objectWithoutPropertiesLoose$2(_ref6, _excluded4);
    var _ref7 = _temp6 === void 0 ? {} : _temp6;
    _ref7.suppressRefError;
    var latestState = latest.current.state;
    var inputHandleKeyDown = function inputHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && inputKeyDownHandlers[key]) {
        inputKeyDownHandlers[key](event);
      }
    };
    var inputHandleChange = function inputHandleChange2(event) {
      dispatch({
        type: InputChange,
        inputValue: event.target.value
      });
    };
    var inputHandleBlur = function inputHandleBlur2() {
      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
        dispatch({
          type: InputBlur,
          selectItem: true
        });
      }
    };
    var onChangeKey = "onChange";
    var eventHandlers = {};
    if (!rest.disabled) {
      var _eventHandlers;
      eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers);
    }
    return _extends$2((_extends5 = {}, _extends5[refKey] = handleRefs(ref, function(inputNode) {
      inputRef.current = inputNode;
    }), _extends5.id = elementIds.inputId, _extends5["aria-autocomplete"] = "list", _extends5["aria-controls"] = elementIds.menuId, _extends5), latestState.isOpen && latestState.highlightedIndex > -1 && {
      "aria-activedescendant": elementIds.getItemId(latestState.highlightedIndex)
    }, {
      "aria-labelledby": elementIds.labelId,
      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
      // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
      autoComplete: "off",
      value: latestState.inputValue
    }, eventHandlers, rest);
  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);
  var getComboboxProps = reactExports.useCallback(function(_temp7, _temp8) {
    var _extends6;
    var _ref8 = _temp7 === void 0 ? {} : _temp7, _ref8$refKey = _ref8.refKey, refKey = _ref8$refKey === void 0 ? "ref" : _ref8$refKey, ref = _ref8.ref, rest = _objectWithoutPropertiesLoose$2(_ref8, _excluded5);
    var _ref9 = _temp8 === void 0 ? {} : _temp8;
    _ref9.suppressRefError;
    return _extends$2((_extends6 = {}, _extends6[refKey] = handleRefs(ref, function(comboboxNode) {
      comboboxRef.current = comboboxNode;
    }), _extends6.role = "combobox", _extends6["aria-haspopup"] = "listbox", _extends6["aria-owns"] = elementIds.menuId, _extends6["aria-expanded"] = latest.current.state.isOpen, _extends6), rest);
  }, [latest, setGetterPropCallInfo, elementIds]);
  var toggleMenu = reactExports.useCallback(function() {
    dispatch({
      type: FunctionToggleMenu
    });
  }, [dispatch]);
  var closeMenu = reactExports.useCallback(function() {
    dispatch({
      type: FunctionCloseMenu
    });
  }, [dispatch]);
  var openMenu = reactExports.useCallback(function() {
    dispatch({
      type: FunctionOpenMenu
    });
  }, [dispatch]);
  var setHighlightedIndex = reactExports.useCallback(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = reactExports.useCallback(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var setInputValue = reactExports.useCallback(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var reset = reactExports.useCallback(function() {
    dispatch({
      type: FunctionReset$1
    });
  }, [dispatch]);
  return {
    // prop getters.
    getItemProps,
    getLabelProps,
    getMenuProps,
    getInputProps,
    getComboboxProps,
    getToggleButtonProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    setInputValue,
    selectItem,
    reset,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getA11yRemovalMessage(selectionParameters) {
  var removedSelectedItem = selectionParameters.removedSelectedItem, itemToStringLocal = selectionParameters.itemToString;
  return itemToStringLocal(removedSelectedItem) + " has been removed.";
}
({
  selectedItems: PropTypes.array,
  initialSelectedItems: PropTypes.array,
  defaultSelectedItems: PropTypes.array,
  itemToString: PropTypes.func,
  getA11yRemovalMessage: PropTypes.func,
  stateReducer: PropTypes.func,
  activeIndex: PropTypes.number,
  initialActiveIndex: PropTypes.number,
  defaultActiveIndex: PropTypes.number,
  onActiveIndexChange: PropTypes.func,
  onSelectedItemsChange: PropTypes.func,
  keyNavigationNext: PropTypes.string,
  keyNavigationPrevious: PropTypes.string,
  environment: PropTypes.shape({
    addEventListener: PropTypes.func,
    removeEventListener: PropTypes.func,
    document: PropTypes.shape({
      getElementById: PropTypes.func,
      activeElement: PropTypes.any,
      body: PropTypes.any
    })
  })
});
({
  itemToString: defaultProps$3.itemToString,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  getA11yRemovalMessage,
  keyNavigationNext: "ArrowRight",
  keyNavigationPrevious: "ArrowLeft"
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __2() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__2.prototype = b2.prototype, new __2());
}
var VIEWBOX_WIDTH = 100;
var VIEWBOX_HEIGHT = 100;
var VIEWBOX_HEIGHT_HALF = 50;
var VIEWBOX_CENTER_X = 50;
var VIEWBOX_CENTER_Y = 50;
function Path(_a2) {
  var className = _a2.className, counterClockwise = _a2.counterClockwise, dashRatio = _a2.dashRatio, pathRadius = _a2.pathRadius, strokeWidth = _a2.strokeWidth, style = _a2.style;
  return reactExports.createElement("path", { className, style: Object.assign({}, style, getDashStyle({ pathRadius, dashRatio, counterClockwise })), d: getPathDescription({
    pathRadius,
    counterClockwise
  }), strokeWidth, fillOpacity: 0 });
}
function getPathDescription(_a2) {
  var pathRadius = _a2.pathRadius, counterClockwise = _a2.counterClockwise;
  var radius = pathRadius;
  var rotation = counterClockwise ? 1 : 0;
  return "\n      M " + VIEWBOX_CENTER_X + "," + VIEWBOX_CENTER_Y + "\n      m 0,-" + radius + "\n      a " + radius + "," + radius + " " + rotation + " 1 1 0," + 2 * radius + "\n      a " + radius + "," + radius + " " + rotation + " 1 1 0,-" + 2 * radius + "\n    ";
}
function getDashStyle(_a2) {
  var counterClockwise = _a2.counterClockwise, dashRatio = _a2.dashRatio, pathRadius = _a2.pathRadius;
  var diameter = Math.PI * 2 * pathRadius;
  var gapLength = (1 - dashRatio) * diameter;
  return {
    strokeDasharray: diameter + "px " + diameter + "px",
    strokeDashoffset: (counterClockwise ? -gapLength : gapLength) + "px"
  };
}
var CircularProgressbar = function(_super) {
  __extends(CircularProgressbar2, _super);
  function CircularProgressbar2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CircularProgressbar2.prototype.getBackgroundPadding = function() {
    if (!this.props.background) {
      return 0;
    }
    return this.props.backgroundPadding;
  };
  CircularProgressbar2.prototype.getPathRadius = function() {
    return VIEWBOX_HEIGHT_HALF - this.props.strokeWidth / 2 - this.getBackgroundPadding();
  };
  CircularProgressbar2.prototype.getPathRatio = function() {
    var _a2 = this.props, value = _a2.value, minValue = _a2.minValue, maxValue = _a2.maxValue;
    var boundedValue = Math.min(Math.max(value, minValue), maxValue);
    return (boundedValue - minValue) / (maxValue - minValue);
  };
  CircularProgressbar2.prototype.render = function() {
    var _a2 = this.props, circleRatio = _a2.circleRatio, className = _a2.className, classes = _a2.classes, counterClockwise = _a2.counterClockwise, styles = _a2.styles, strokeWidth = _a2.strokeWidth, text = _a2.text;
    var pathRadius = this.getPathRadius();
    var pathRatio = this.getPathRatio();
    return reactExports.createElement(
      "svg",
      { className: classes.root + " " + className, style: styles.root, viewBox: "0 0 " + VIEWBOX_WIDTH + " " + VIEWBOX_HEIGHT, "data-test-id": "CircularProgressbar" },
      this.props.background ? reactExports.createElement("circle", { className: classes.background, style: styles.background, cx: VIEWBOX_CENTER_X, cy: VIEWBOX_CENTER_Y, r: VIEWBOX_HEIGHT_HALF }) : null,
      reactExports.createElement(Path, { className: classes.trail, counterClockwise, dashRatio: circleRatio, pathRadius, strokeWidth, style: styles.trail }),
      reactExports.createElement(Path, { className: classes.path, counterClockwise, dashRatio: pathRatio * circleRatio, pathRadius, strokeWidth, style: styles.path }),
      text ? reactExports.createElement("text", { className: classes.text, style: styles.text, x: VIEWBOX_CENTER_X, y: VIEWBOX_CENTER_Y }, text) : null
    );
  };
  CircularProgressbar2.defaultProps = {
    background: false,
    backgroundPadding: 0,
    circleRatio: 1,
    classes: {
      root: "CircularProgressbar",
      trail: "CircularProgressbar-trail",
      path: "CircularProgressbar-path",
      text: "CircularProgressbar-text",
      background: "CircularProgressbar-background"
    },
    counterClockwise: false,
    className: "",
    maxValue: 100,
    minValue: 0,
    strokeWidth: 8,
    styles: {
      root: {},
      trail: {},
      path: {},
      text: {},
      background: {}
    },
    text: ""
  };
  return CircularProgressbar2;
}(reactExports.Component);
const Svg46Dde8092160Efa1 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { viewBox: "0 0 14.685 8.391", height: 8.391, width: 14.685, ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M7.338 5.863 1.788.307A1.049 1.049 0 0 0 .305 1.793L6.6 8.087a1.047 1.047 0 0 0 1.443.03l6.334-6.324A1.05 1.05 0 1 0 12.894.307z" }));
const SvgFca912Dd1Ab82474 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 8.394, height: 14.683, viewBox: "0 0 8.394 14.683", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m2.53 7.339 5.556-5.551A1.049 1.049 0 0 0 6.6.307L.306 6.6a1.047 1.047 0 0 0-.031 1.443L6.6 14.377a1.049 1.049 0 1 0 1.486-1.482z" }));
const Svg1B8Acf1Cc5Bb7E55 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 8.394, height: 14.683, viewBox: "0 0 8.394 14.683", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M5.864 7.344.308 12.895a1.049 1.049 0 0 0 1.486 1.481l6.294-6.293a1.047 1.047 0 0 0 .031-1.443L1.794.306A1.05 1.05 0 1 0 .308 1.788z" }));
const SvgEd18499E3448Aad6 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { viewBox: "0 0 14.685 8.391", height: 8.391, width: 14.685, ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m7.346 2.528 5.551 5.556a1.049 1.049 0 0 0 1.481-1.486L8.085.304a1.047 1.047 0 0 0-1.443-.03L.308 6.597A1.05 1.05 0 1 0 1.79 8.084z" }));
var isArray$2 = Array.isArray;
var keyList = Object.keys;
var hasProp$1 = Object.prototype.hasOwnProperty;
var hasElementType = typeof Element !== "undefined";
function equal(a2, b2) {
  if (a2 === b2)
    return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    var arrA = isArray$2(a2), arrB = isArray$2(b2), i, length, key;
    if (arrA && arrB) {
      length = a2.length;
      if (length != b2.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!equal(a2[i], b2[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var dateA = a2 instanceof Date, dateB = b2 instanceof Date;
    if (dateA != dateB)
      return false;
    if (dateA && dateB)
      return a2.getTime() == b2.getTime();
    var regexpA = a2 instanceof RegExp, regexpB = b2 instanceof RegExp;
    if (regexpA != regexpB)
      return false;
    if (regexpA && regexpB)
      return a2.toString() == b2.toString();
    var keys3 = keyList(a2);
    length = keys3.length;
    if (length !== keyList(b2).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!hasProp$1.call(b2, keys3[i]))
        return false;
    if (hasElementType && a2 instanceof Element && b2 instanceof Element)
      return a2 === b2;
    for (i = length; i-- !== 0; ) {
      key = keys3[i];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      } else {
        if (!equal(a2[key], b2[key]))
          return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
var reactFastCompare = function exportedEqual(a2, b2) {
  try {
    return equal(a2, b2);
  } catch (error2) {
    if (error2.message && error2.message.match(/stack|recursion/i) || error2.number === -2146828260) {
      console.warn("Warning: react-fast-compare does not handle circular references.", error2.name, error2.message);
      return false;
    }
    throw error2;
  }
};
const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    Object.keys(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  Object.keys(source).forEach(function(key) {
    if (!options.isMergeableObject(source[key]) || !target[key]) {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    } else {
      destination[key] = deepmerge(target[key], source[key], options);
    }
  });
  return destination;
}
function deepmerge(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}
deepmerge.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge;
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var Symbol$1 = root$1.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$1 = objectProto$d.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$c = Object.prototype;
var nativeObjectToString = objectProto$c.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var objectTag$3 = "[object Object]";
var funcProto$2 = Function.prototype, objectProto$b = Object.prototype;
var funcToString$2 = funcProto$2.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var objectCtorString = funcToString$2.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto2 = getPrototype$1(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$9.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$1, "Map");
const Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data, key) ? data[key] : void 0;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$6.call(data, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
const defineProperty$1 = defineProperty;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var isArguments4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
const isArguments$1 = isArguments4;
var isArray = Array.isArray;
const isArray$1 = isArray;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
const isBuffer$1 = isBuffer;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$1 = isTypedArray;
var objectProto$5 = Object.prototype;
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value === proto2;
}
var nativeKeys = overArg(Object.keys, Object);
const nativeKeys$1 = nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function keys2(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function baseAssign(object, source) {
  return object && copyObject(source, keys2(source), object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$1(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function copyArray(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
const getSymbols$1 = getSymbols;
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}
function arrayPush(array, values2) {
  var index2 = -1, length = values2.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values2[index2];
  }
  return array;
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
const getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys2, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView$1 = getNative(root$1, "DataView");
const DataView$2 = DataView$1;
var Promise$1 = getNative(root$1, "Promise");
const Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
const Set$2 = Set$1;
var WeakMap$1 = getNative(root$1, "WeakMap");
const WeakMap$2 = WeakMap$1;
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$3 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
const getTag$1 = getTag;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
const Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object);
  }
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$1(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
const baseCreate$1 = baseCreate;
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$1;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
const isMap$1 = isMap2;
var setTag$1 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
const isSet$1 = isSet2;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_SYMBOLS_FLAG$1 = 4;
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG$1);
}
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath3 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match2, number2, quote2, subString) {
    result.push(quote2 ? subString.replace(reEscapeChar, "$1") : number2 || match2);
  });
  return result;
});
const stringToPath$1 = stringToPath3;
var INFINITY$1 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var INFINITY = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$1(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function toPath(value) {
  if (isArray$1(value)) {
    return arrayMap(value, toKey);
  }
  return isSymbol(value) ? [value] : copyArray(stringToPath$1(toString(value)));
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var isEmptyArray = function isEmptyArray2(value) {
  return Array.isArray(value) && value.length === 0;
};
var isFunction = function isFunction2(obj) {
  return typeof obj === "function";
};
var isObject = function isObject2(obj) {
  return obj !== null && typeof obj === "object";
};
var isInteger = function isInteger2(obj) {
  return String(Math.floor(Number(obj))) === obj;
};
var isString$1 = function isString2(obj) {
  return Object.prototype.toString.call(obj) === "[object String]";
};
var isEmptyChildren = function isEmptyChildren2(children) {
  return reactExports.Children.count(children) === 0;
};
var isPromise = function isPromise2(value) {
  return isObject(value) && isFunction(value.then);
};
function getIn(obj, key, def, p2) {
  if (p2 === void 0) {
    p2 = 0;
  }
  var path = toPath(key);
  while (obj && p2 < path.length) {
    obj = obj[path[p2++]];
  }
  return obj === void 0 ? def : obj;
}
function setIn(obj, path, value) {
  var res = clone(obj);
  var resVal = res;
  var i = 0;
  var pathArray = toPath(path);
  for (; i < pathArray.length - 1; i++) {
    var currentPath = pathArray[i];
    var currentObj = getIn(obj, pathArray.slice(0, i + 1));
    if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {
      resVal = resVal[currentPath] = clone(currentObj);
    } else {
      var nextPath = pathArray[i + 1];
      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};
    }
  }
  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {
    return obj;
  }
  if (value === void 0) {
    delete resVal[pathArray[i]];
  } else {
    resVal[pathArray[i]] = value;
  }
  if (i === 0 && value === void 0) {
    delete res[pathArray[i]];
  }
  return res;
}
function setNestedObjectValues(object, value, visited, response) {
  if (visited === void 0) {
    visited = /* @__PURE__ */ new WeakMap();
  }
  if (response === void 0) {
    response = {};
  }
  for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
    var k2 = _Object$keys[_i];
    var val = object[k2];
    if (isObject(val)) {
      if (!visited.get(val)) {
        visited.set(val, true);
        response[k2] = Array.isArray(val) ? [] : {};
        setNestedObjectValues(val, value, visited, response[k2]);
      }
    } else {
      response[k2] = value;
    }
  }
  return response;
}
var FormikContext = /* @__PURE__ */ reactExports.createContext(void 0);
FormikContext.displayName = "FormikContext";
var FormikProvider = FormikContext.Provider;
var FormikConsumer = FormikContext.Consumer;
function useFormikContext() {
  var formik = reactExports.useContext(FormikContext);
  !!!formik ? warning(false) : void 0;
  return formik;
}
function formikReducer(state, msg) {
  switch (msg.type) {
    case "SET_VALUES":
      return _extends$1({}, state, {
        values: msg.payload
      });
    case "SET_TOUCHED":
      return _extends$1({}, state, {
        touched: msg.payload
      });
    case "SET_ERRORS":
      if (isEqual(state.errors, msg.payload)) {
        return state;
      }
      return _extends$1({}, state, {
        errors: msg.payload
      });
    case "SET_STATUS":
      return _extends$1({}, state, {
        status: msg.payload
      });
    case "SET_ISSUBMITTING":
      return _extends$1({}, state, {
        isSubmitting: msg.payload
      });
    case "SET_ISVALIDATING":
      return _extends$1({}, state, {
        isValidating: msg.payload
      });
    case "SET_FIELD_VALUE":
      return _extends$1({}, state, {
        values: setIn(state.values, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_TOUCHED":
      return _extends$1({}, state, {
        touched: setIn(state.touched, msg.payload.field, msg.payload.value)
      });
    case "SET_FIELD_ERROR":
      return _extends$1({}, state, {
        errors: setIn(state.errors, msg.payload.field, msg.payload.value)
      });
    case "RESET_FORM":
      return _extends$1({}, state, msg.payload);
    case "SET_FORMIK_STATE":
      return msg.payload(state);
    case "SUBMIT_ATTEMPT":
      return _extends$1({}, state, {
        touched: setNestedObjectValues(state.values, true),
        isSubmitting: true,
        submitCount: state.submitCount + 1
      });
    case "SUBMIT_FAILURE":
      return _extends$1({}, state, {
        isSubmitting: false
      });
    case "SUBMIT_SUCCESS":
      return _extends$1({}, state, {
        isSubmitting: false
      });
    default:
      return state;
  }
}
var emptyErrors = {};
var emptyTouched = {};
function useFormik(_ref) {
  var _ref$validateOnChange = _ref.validateOnChange, validateOnChange = _ref$validateOnChange === void 0 ? true : _ref$validateOnChange, _ref$validateOnBlur = _ref.validateOnBlur, validateOnBlur = _ref$validateOnBlur === void 0 ? true : _ref$validateOnBlur, _ref$validateOnMount = _ref.validateOnMount, validateOnMount = _ref$validateOnMount === void 0 ? false : _ref$validateOnMount, isInitialValid = _ref.isInitialValid, _ref$enableReinitiali = _ref.enableReinitialize, enableReinitialize = _ref$enableReinitiali === void 0 ? false : _ref$enableReinitiali, onSubmit = _ref.onSubmit, rest = _objectWithoutPropertiesLoose$1(_ref, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"]);
  var props = _extends$1({
    validateOnChange,
    validateOnBlur,
    validateOnMount,
    onSubmit
  }, rest);
  var initialValues = reactExports.useRef(props.initialValues);
  var initialErrors = reactExports.useRef(props.initialErrors || emptyErrors);
  var initialTouched = reactExports.useRef(props.initialTouched || emptyTouched);
  var initialStatus = reactExports.useRef(props.initialStatus);
  var isMounted = reactExports.useRef(false);
  var fieldRegistry = reactExports.useRef({});
  reactExports.useEffect(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  var _React$useReducer = reactExports.useReducer(formikReducer, {
    values: props.initialValues,
    errors: props.initialErrors || emptyErrors,
    touched: props.initialTouched || emptyTouched,
    status: props.initialStatus,
    isSubmitting: false,
    isValidating: false,
    submitCount: 0
  }), state = _React$useReducer[0], dispatch = _React$useReducer[1];
  var runValidateHandler = reactExports.useCallback(function(values2, field) {
    return new Promise(function(resolve, reject) {
      var maybePromisedErrors = props.validate(values2, field);
      if (maybePromisedErrors == null) {
        resolve(emptyErrors);
      } else if (isPromise(maybePromisedErrors)) {
        maybePromisedErrors.then(function(errors2) {
          resolve(errors2 || emptyErrors);
        }, function(actualException) {
          reject(actualException);
        });
      } else {
        resolve(maybePromisedErrors);
      }
    });
  }, [props.validate]);
  var runValidationSchema = reactExports.useCallback(function(values2, field) {
    var validationSchema = props.validationSchema;
    var schema = isFunction(validationSchema) ? validationSchema(field) : validationSchema;
    var promise = field && schema.validateAt ? schema.validateAt(field, values2) : validateYupSchema(values2, schema);
    return new Promise(function(resolve, reject) {
      promise.then(function() {
        resolve(emptyErrors);
      }, function(err) {
        if (err.name === "ValidationError") {
          resolve(yupToFormErrors(err));
        } else {
          reject(err);
        }
      });
    });
  }, [props.validationSchema]);
  var runSingleFieldLevelValidation = reactExports.useCallback(function(field, value) {
    return new Promise(function(resolve) {
      return resolve(fieldRegistry.current[field].validate(value));
    });
  }, []);
  var runFieldLevelValidations = reactExports.useCallback(function(values2) {
    var fieldKeysWithValidation = Object.keys(fieldRegistry.current).filter(function(f2) {
      return isFunction(fieldRegistry.current[f2].validate);
    });
    var fieldValidations = fieldKeysWithValidation.length > 0 ? fieldKeysWithValidation.map(function(f2) {
      return runSingleFieldLevelValidation(f2, getIn(values2, f2));
    }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
    return Promise.all(fieldValidations).then(function(fieldErrorsList) {
      return fieldErrorsList.reduce(function(prev, curr, index2) {
        if (curr === "DO_NOT_DELETE_YOU_WILL_BE_FIRED") {
          return prev;
        }
        if (curr) {
          prev = setIn(prev, fieldKeysWithValidation[index2], curr);
        }
        return prev;
      }, {});
    });
  }, [runSingleFieldLevelValidation]);
  var runAllValidations = reactExports.useCallback(function(values2) {
    return Promise.all([runFieldLevelValidations(values2), props.validationSchema ? runValidationSchema(values2) : {}, props.validate ? runValidateHandler(values2) : {}]).then(function(_ref2) {
      var fieldErrors = _ref2[0], schemaErrors = _ref2[1], validateErrors = _ref2[2];
      var combinedErrors = deepmerge_1.all([fieldErrors, schemaErrors, validateErrors], {
        arrayMerge
      });
      return combinedErrors;
    });
  }, [props.validate, props.validationSchema, runFieldLevelValidations, runValidateHandler, runValidationSchema]);
  var validateFormWithHighPriority = useEventCallback(function(values2) {
    if (values2 === void 0) {
      values2 = state.values;
    }
    dispatch({
      type: "SET_ISVALIDATING",
      payload: true
    });
    return runAllValidations(values2).then(function(combinedErrors) {
      if (!!isMounted.current) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
        dispatch({
          type: "SET_ERRORS",
          payload: combinedErrors
        });
      }
      return combinedErrors;
    });
  });
  reactExports.useEffect(function() {
    if (validateOnMount && isMounted.current === true && isEqual(initialValues.current, props.initialValues)) {
      validateFormWithHighPriority(initialValues.current);
    }
  }, [validateOnMount, validateFormWithHighPriority]);
  var resetForm = reactExports.useCallback(function(nextState) {
    var values2 = nextState && nextState.values ? nextState.values : initialValues.current;
    var errors2 = nextState && nextState.errors ? nextState.errors : initialErrors.current ? initialErrors.current : props.initialErrors || {};
    var touched = nextState && nextState.touched ? nextState.touched : initialTouched.current ? initialTouched.current : props.initialTouched || {};
    var status = nextState && nextState.status ? nextState.status : initialStatus.current ? initialStatus.current : props.initialStatus;
    initialValues.current = values2;
    initialErrors.current = errors2;
    initialTouched.current = touched;
    initialStatus.current = status;
    var dispatchFn = function dispatchFn2() {
      dispatch({
        type: "RESET_FORM",
        payload: {
          isSubmitting: !!nextState && !!nextState.isSubmitting,
          errors: errors2,
          touched,
          status,
          values: values2,
          isValidating: !!nextState && !!nextState.isValidating,
          submitCount: !!nextState && !!nextState.submitCount && typeof nextState.submitCount === "number" ? nextState.submitCount : 0
        }
      });
    };
    if (props.onReset) {
      var maybePromisedOnReset = props.onReset(state.values, imperativeMethods);
      if (isPromise(maybePromisedOnReset)) {
        maybePromisedOnReset.then(dispatchFn);
      } else {
        dispatchFn();
      }
    } else {
      dispatchFn();
    }
  }, [props.initialErrors, props.initialStatus, props.initialTouched]);
  reactExports.useEffect(function() {
    if (isMounted.current === true && !isEqual(initialValues.current, props.initialValues)) {
      if (enableReinitialize) {
        initialValues.current = props.initialValues;
        resetForm();
      }
      if (validateOnMount) {
        validateFormWithHighPriority(initialValues.current);
      }
    }
  }, [enableReinitialize, props.initialValues, resetForm, validateOnMount, validateFormWithHighPriority]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialErrors.current, props.initialErrors)) {
      initialErrors.current = props.initialErrors || emptyErrors;
      dispatch({
        type: "SET_ERRORS",
        payload: props.initialErrors || emptyErrors
      });
    }
  }, [enableReinitialize, props.initialErrors]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialTouched.current, props.initialTouched)) {
      initialTouched.current = props.initialTouched || emptyTouched;
      dispatch({
        type: "SET_TOUCHED",
        payload: props.initialTouched || emptyTouched
      });
    }
  }, [enableReinitialize, props.initialTouched]);
  reactExports.useEffect(function() {
    if (enableReinitialize && isMounted.current === true && !isEqual(initialStatus.current, props.initialStatus)) {
      initialStatus.current = props.initialStatus;
      dispatch({
        type: "SET_STATUS",
        payload: props.initialStatus
      });
    }
  }, [enableReinitialize, props.initialStatus, props.initialTouched]);
  var validateField = useEventCallback(function(name) {
    if (fieldRegistry.current[name] && isFunction(fieldRegistry.current[name].validate)) {
      var value = getIn(state.values, name);
      var maybePromise = fieldRegistry.current[name].validate(value);
      if (isPromise(maybePromise)) {
        dispatch({
          type: "SET_ISVALIDATING",
          payload: true
        });
        return maybePromise.then(function(x) {
          return x;
        }).then(function(error2) {
          dispatch({
            type: "SET_FIELD_ERROR",
            payload: {
              field: name,
              value: error2
            }
          });
          dispatch({
            type: "SET_ISVALIDATING",
            payload: false
          });
        });
      } else {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: maybePromise
          }
        });
        return Promise.resolve(maybePromise);
      }
    } else if (props.validationSchema) {
      dispatch({
        type: "SET_ISVALIDATING",
        payload: true
      });
      return runValidationSchema(state.values, name).then(function(x) {
        return x;
      }).then(function(error2) {
        dispatch({
          type: "SET_FIELD_ERROR",
          payload: {
            field: name,
            value: error2[name]
          }
        });
        dispatch({
          type: "SET_ISVALIDATING",
          payload: false
        });
      });
    }
    return Promise.resolve();
  });
  var registerField = reactExports.useCallback(function(name, _ref3) {
    var validate2 = _ref3.validate;
    fieldRegistry.current[name] = {
      validate: validate2
    };
  }, []);
  var unregisterField = reactExports.useCallback(function(name) {
    delete fieldRegistry.current[name];
  }, []);
  var setTouched = useEventCallback(function(touched, shouldValidate) {
    dispatch({
      type: "SET_TOUCHED",
      payload: touched
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var setErrors = reactExports.useCallback(function(errors2) {
    dispatch({
      type: "SET_ERRORS",
      payload: errors2
    });
  }, []);
  var setValues = useEventCallback(function(values2, shouldValidate) {
    var resolvedValues = isFunction(values2) ? values2(state.values) : values2;
    dispatch({
      type: "SET_VALUES",
      payload: resolvedValues
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(resolvedValues) : Promise.resolve();
  });
  var setFieldError = reactExports.useCallback(function(field, value) {
    dispatch({
      type: "SET_FIELD_ERROR",
      payload: {
        field,
        value
      }
    });
  }, []);
  var setFieldValue = useEventCallback(function(field, value, shouldValidate) {
    dispatch({
      type: "SET_FIELD_VALUE",
      payload: {
        field,
        value
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnChange : shouldValidate;
    return willValidate ? validateFormWithHighPriority(setIn(state.values, field, value)) : Promise.resolve();
  });
  var executeChange = reactExports.useCallback(function(eventOrTextValue, maybePath) {
    var field = maybePath;
    var val = eventOrTextValue;
    var parsed;
    if (!isString$1(eventOrTextValue)) {
      if (eventOrTextValue.persist) {
        eventOrTextValue.persist();
      }
      var target = eventOrTextValue.target ? eventOrTextValue.target : eventOrTextValue.currentTarget;
      var type = target.type, name = target.name, id2 = target.id, value = target.value, checked = target.checked, outerHTML = target.outerHTML, options = target.options, multiple = target.multiple;
      field = maybePath ? maybePath : name ? name : id2;
      if (!field && false) {
        warnAboutMissingIdentifier({
          htmlContent: outerHTML,
          documentationAnchorLink: "handlechange-e-reactchangeeventany--void",
          handlerName: "handleChange"
        });
      }
      val = /number|range/.test(type) ? (parsed = parseFloat(value), isNaN(parsed) ? "" : parsed) : /checkbox/.test(type) ? getValueForCheckbox(getIn(state.values, field), checked, value) : options && multiple ? getSelectedValues(options) : value;
    }
    if (field) {
      setFieldValue(field, val);
    }
  }, [setFieldValue, state.values]);
  var handleChange = useEventCallback(function(eventOrPath) {
    if (isString$1(eventOrPath)) {
      return function(event) {
        return executeChange(event, eventOrPath);
      };
    } else {
      executeChange(eventOrPath);
    }
  });
  var setFieldTouched = useEventCallback(function(field, touched, shouldValidate) {
    if (touched === void 0) {
      touched = true;
    }
    dispatch({
      type: "SET_FIELD_TOUCHED",
      payload: {
        field,
        value: touched
      }
    });
    var willValidate = shouldValidate === void 0 ? validateOnBlur : shouldValidate;
    return willValidate ? validateFormWithHighPriority(state.values) : Promise.resolve();
  });
  var executeBlur = reactExports.useCallback(function(e2, path) {
    if (e2.persist) {
      e2.persist();
    }
    var _e$target = e2.target, name = _e$target.name, id2 = _e$target.id, outerHTML = _e$target.outerHTML;
    var field = path ? path : name ? name : id2;
    if (!field && false) {
      warnAboutMissingIdentifier({
        htmlContent: outerHTML,
        documentationAnchorLink: "handleblur-e-any--void",
        handlerName: "handleBlur"
      });
    }
    setFieldTouched(field, true);
  }, [setFieldTouched]);
  var handleBlur = useEventCallback(function(eventOrString) {
    if (isString$1(eventOrString)) {
      return function(event) {
        return executeBlur(event, eventOrString);
      };
    } else {
      executeBlur(eventOrString);
    }
  });
  var setFormikState = reactExports.useCallback(function(stateOrCb) {
    if (isFunction(stateOrCb)) {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: stateOrCb
      });
    } else {
      dispatch({
        type: "SET_FORMIK_STATE",
        payload: function payload() {
          return stateOrCb;
        }
      });
    }
  }, []);
  var setStatus2 = reactExports.useCallback(function(status) {
    dispatch({
      type: "SET_STATUS",
      payload: status
    });
  }, []);
  var setSubmitting = reactExports.useCallback(function(isSubmitting) {
    dispatch({
      type: "SET_ISSUBMITTING",
      payload: isSubmitting
    });
  }, []);
  var submitForm = useEventCallback(function() {
    dispatch({
      type: "SUBMIT_ATTEMPT"
    });
    return validateFormWithHighPriority().then(function(combinedErrors) {
      var isInstanceOfError = combinedErrors instanceof Error;
      var isActuallyValid = !isInstanceOfError && Object.keys(combinedErrors).length === 0;
      if (isActuallyValid) {
        var promiseOrUndefined;
        try {
          promiseOrUndefined = executeSubmit();
          if (promiseOrUndefined === void 0) {
            return;
          }
        } catch (error2) {
          throw error2;
        }
        return Promise.resolve(promiseOrUndefined).then(function(result) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_SUCCESS"
            });
          }
          return result;
        })["catch"](function(_errors) {
          if (!!isMounted.current) {
            dispatch({
              type: "SUBMIT_FAILURE"
            });
            throw _errors;
          }
        });
      } else if (!!isMounted.current) {
        dispatch({
          type: "SUBMIT_FAILURE"
        });
        if (isInstanceOfError) {
          throw combinedErrors;
        }
      }
      return;
    });
  });
  var handleSubmit = useEventCallback(function(e2) {
    if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
      e2.preventDefault();
    }
    if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
      e2.stopPropagation();
    }
    submitForm()["catch"](function(reason) {
      console.warn("Warning: An unhandled error was caught from submitForm()", reason);
    });
  });
  var imperativeMethods = {
    resetForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    setErrors,
    setFieldError,
    setFieldTouched,
    setFieldValue,
    setStatus: setStatus2,
    setSubmitting,
    setTouched,
    setValues,
    setFormikState,
    submitForm
  };
  var executeSubmit = useEventCallback(function() {
    return onSubmit(state.values, imperativeMethods);
  });
  var handleReset = useEventCallback(function(e2) {
    if (e2 && e2.preventDefault && isFunction(e2.preventDefault)) {
      e2.preventDefault();
    }
    if (e2 && e2.stopPropagation && isFunction(e2.stopPropagation)) {
      e2.stopPropagation();
    }
    resetForm();
  });
  var getFieldMeta = reactExports.useCallback(function(name) {
    return {
      value: getIn(state.values, name),
      error: getIn(state.errors, name),
      touched: !!getIn(state.touched, name),
      initialValue: getIn(initialValues.current, name),
      initialTouched: !!getIn(initialTouched.current, name),
      initialError: getIn(initialErrors.current, name)
    };
  }, [state.errors, state.touched, state.values]);
  var getFieldHelpers = reactExports.useCallback(function(name) {
    return {
      setValue: function setValue(value, shouldValidate) {
        return setFieldValue(name, value, shouldValidate);
      },
      setTouched: function setTouched2(value, shouldValidate) {
        return setFieldTouched(name, value, shouldValidate);
      },
      setError: function setError(value) {
        return setFieldError(name, value);
      }
    };
  }, [setFieldValue, setFieldTouched, setFieldError]);
  var getFieldProps = reactExports.useCallback(function(nameOrOptions) {
    var isAnObject = isObject(nameOrOptions);
    var name = isAnObject ? nameOrOptions.name : nameOrOptions;
    var valueState = getIn(state.values, name);
    var field = {
      name,
      value: valueState,
      onChange: handleChange,
      onBlur: handleBlur
    };
    if (isAnObject) {
      var type = nameOrOptions.type, valueProp = nameOrOptions.value, is3 = nameOrOptions.as, multiple = nameOrOptions.multiple;
      if (type === "checkbox") {
        if (valueProp === void 0) {
          field.checked = !!valueState;
        } else {
          field.checked = !!(Array.isArray(valueState) && ~valueState.indexOf(valueProp));
          field.value = valueProp;
        }
      } else if (type === "radio") {
        field.checked = valueState === valueProp;
        field.value = valueProp;
      } else if (is3 === "select" && multiple) {
        field.value = field.value || [];
        field.multiple = true;
      }
    }
    return field;
  }, [handleBlur, handleChange, state.values]);
  var dirty = reactExports.useMemo(function() {
    return !isEqual(initialValues.current, state.values);
  }, [initialValues.current, state.values]);
  var isValid2 = reactExports.useMemo(function() {
    return typeof isInitialValid !== "undefined" ? dirty ? state.errors && Object.keys(state.errors).length === 0 : isInitialValid !== false && isFunction(isInitialValid) ? isInitialValid(props) : isInitialValid : state.errors && Object.keys(state.errors).length === 0;
  }, [isInitialValid, dirty, state.errors, props]);
  var ctx = _extends$1({}, state, {
    initialValues: initialValues.current,
    initialErrors: initialErrors.current,
    initialTouched: initialTouched.current,
    initialStatus: initialStatus.current,
    handleBlur,
    handleChange,
    handleReset,
    handleSubmit,
    resetForm,
    setErrors,
    setFormikState,
    setFieldTouched,
    setFieldValue,
    setFieldError,
    setStatus: setStatus2,
    setSubmitting,
    setTouched,
    setValues,
    submitForm,
    validateForm: validateFormWithHighPriority,
    validateField,
    isValid: isValid2,
    dirty,
    unregisterField,
    registerField,
    getFieldProps,
    getFieldMeta,
    getFieldHelpers,
    validateOnBlur,
    validateOnChange,
    validateOnMount
  });
  return ctx;
}
function Formik(props) {
  var formikbag = useFormik(props);
  var component = props.component, children = props.children, render = props.render, innerRef = props.innerRef;
  reactExports.useImperativeHandle(innerRef, function() {
    return formikbag;
  });
  return reactExports.createElement(FormikProvider, {
    value: formikbag
  }, component ? reactExports.createElement(component, formikbag) : render ? render(formikbag) : children ? isFunction(children) ? children(formikbag) : !isEmptyChildren(children) ? reactExports.Children.only(children) : null : null);
}
function warnAboutMissingIdentifier(_ref4) {
  var htmlContent = _ref4.htmlContent, documentationAnchorLink = _ref4.documentationAnchorLink, handlerName = _ref4.handlerName;
  console.warn("Warning: Formik called `" + handlerName + "`, but you forgot to pass an `id` or `name` attribute to your input:\n    " + htmlContent + "\n    Formik cannot determine which value to update. For more info see https://formik.org/docs/api/formik#" + documentationAnchorLink + "\n  ");
}
function yupToFormErrors(yupError) {
  var errors2 = {};
  if (yupError.inner) {
    if (yupError.inner.length === 0) {
      return setIn(errors2, yupError.path, yupError.message);
    }
    for (var _iterator = yupError.inner, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
      var _ref5;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref5 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref5 = _i.value;
      }
      var err = _ref5;
      if (!getIn(errors2, err.path)) {
        errors2 = setIn(errors2, err.path, err.message);
      }
    }
  }
  return errors2;
}
function validateYupSchema(values2, schema, sync, context) {
  if (sync === void 0) {
    sync = false;
  }
  if (context === void 0) {
    context = {};
  }
  var validateData = prepareDataForValidation(values2);
  return schema[sync ? "validateSync" : "validate"](validateData, {
    abortEarly: false,
    context
  });
}
function prepareDataForValidation(values2) {
  var data = Array.isArray(values2) ? [] : {};
  for (var k2 in values2) {
    if (Object.prototype.hasOwnProperty.call(values2, k2)) {
      var key = String(k2);
      if (Array.isArray(values2[key]) === true) {
        data[key] = values2[key].map(function(value) {
          if (Array.isArray(value) === true || isPlainObject$1(value)) {
            return prepareDataForValidation(value);
          } else {
            return value !== "" ? value : void 0;
          }
        });
      } else if (isPlainObject$1(values2[key])) {
        data[key] = prepareDataForValidation(values2[key]);
      } else {
        data[key] = values2[key] !== "" ? values2[key] : void 0;
      }
    }
  }
  return data;
}
function arrayMerge(target, source, options) {
  var destination = target.slice();
  source.forEach(function merge2(e2, i) {
    if (typeof destination[i] === "undefined") {
      var cloneRequested = options.clone !== false;
      var shouldClone = cloneRequested && options.isMergeableObject(e2);
      destination[i] = shouldClone ? deepmerge_1(Array.isArray(e2) ? [] : {}, e2, options) : e2;
    } else if (options.isMergeableObject(e2)) {
      destination[i] = deepmerge_1(target[i], e2, options);
    } else if (target.indexOf(e2) === -1) {
      destination.push(e2);
    }
  });
  return destination;
}
function getSelectedValues(options) {
  return Array.from(options).filter(function(el2) {
    return el2.selected;
  }).map(function(el2) {
    return el2.value;
  });
}
function getValueForCheckbox(currentValue, checked, valueProp) {
  if (typeof currentValue === "boolean") {
    return Boolean(checked);
  }
  var currentArrayOfValues = [];
  var isValueInArray = false;
  var index2 = -1;
  if (!Array.isArray(currentValue)) {
    if (!valueProp || valueProp == "true" || valueProp == "false") {
      return Boolean(checked);
    }
  } else {
    currentArrayOfValues = currentValue;
    index2 = currentValue.indexOf(valueProp);
    isValueInArray = index2 >= 0;
  }
  if (checked && valueProp && !isValueInArray) {
    return currentArrayOfValues.concat(valueProp);
  }
  if (!isValueInArray) {
    return currentArrayOfValues;
  }
  return currentArrayOfValues.slice(0, index2).concat(currentArrayOfValues.slice(index2 + 1));
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEventCallback(fn) {
  var ref = reactExports.useRef(fn);
  useIsomorphicLayoutEffect(function() {
    ref.current = fn;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current.apply(void 0, args);
  }, []);
}
var Form = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var action = props.action, rest = _objectWithoutPropertiesLoose$1(props, ["action"]);
  var _action = action != null ? action : "#";
  var _useFormikContext = useFormikContext(), handleReset = _useFormikContext.handleReset, handleSubmit = _useFormikContext.handleSubmit;
  return reactExports.createElement("form", Object.assign({
    onSubmit: handleSubmit,
    ref,
    onReset: handleReset,
    action: _action
  }, rest));
});
Form.displayName = "Form";
function connect(Comp) {
  var C2 = function C3(props) {
    return reactExports.createElement(FormikConsumer, null, function(formik) {
      !!!formik ? warning(false) : void 0;
      return reactExports.createElement(Comp, Object.assign({}, props, {
        formik
      }));
    });
  };
  var componentDisplayName = Comp.displayName || Comp.name || Comp.constructor && Comp.constructor.name || "Component";
  C2.WrappedComponent = Comp;
  C2.displayName = "FormikConnect(" + componentDisplayName + ")";
  return hoistNonReactStatics$1(
    C2,
    Comp
    // cast type to ComponentClass (even if SFC)
  );
}
var move = function move2(array, from, to2) {
  var copy = copyArrayLike(array);
  var value = copy[from];
  copy.splice(from, 1);
  copy.splice(to2, 0, value);
  return copy;
};
var swap = function swap2(arrayLike, indexA, indexB) {
  var copy = copyArrayLike(arrayLike);
  var a2 = copy[indexA];
  copy[indexA] = copy[indexB];
  copy[indexB] = a2;
  return copy;
};
var insert = function insert2(arrayLike, index2, value) {
  var copy = copyArrayLike(arrayLike);
  copy.splice(index2, 0, value);
  return copy;
};
var replace = function replace2(arrayLike, index2, value) {
  var copy = copyArrayLike(arrayLike);
  copy[index2] = value;
  return copy;
};
var copyArrayLike = function copyArrayLike2(arrayLike) {
  if (!arrayLike) {
    return [];
  } else if (Array.isArray(arrayLike)) {
    return [].concat(arrayLike);
  } else {
    var maxIndex = Object.keys(arrayLike).map(function(key) {
      return parseInt(key);
    }).reduce(function(max2, el2) {
      return el2 > max2 ? el2 : max2;
    }, 0);
    return Array.from(_extends$1({}, arrayLike, {
      length: maxIndex + 1
    }));
  }
};
var FieldArrayInner = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(FieldArrayInner2, _React$Component);
  function FieldArrayInner2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.updateArrayField = function(fn, alterTouched, alterErrors) {
      var _this$props = _this.props, name = _this$props.name, setFormikState = _this$props.formik.setFormikState;
      setFormikState(function(prevState) {
        var updateErrors = typeof alterErrors === "function" ? alterErrors : fn;
        var updateTouched = typeof alterTouched === "function" ? alterTouched : fn;
        var values2 = setIn(prevState.values, name, fn(getIn(prevState.values, name)));
        var fieldError = alterErrors ? updateErrors(getIn(prevState.errors, name)) : void 0;
        var fieldTouched = alterTouched ? updateTouched(getIn(prevState.touched, name)) : void 0;
        if (isEmptyArray(fieldError)) {
          fieldError = void 0;
        }
        if (isEmptyArray(fieldTouched)) {
          fieldTouched = void 0;
        }
        return _extends$1({}, prevState, {
          values: values2,
          errors: alterErrors ? setIn(prevState.errors, name, fieldError) : prevState.errors,
          touched: alterTouched ? setIn(prevState.touched, name, fieldTouched) : prevState.touched
        });
      });
    };
    _this.push = function(value) {
      return _this.updateArrayField(function(arrayLike) {
        return [].concat(copyArrayLike(arrayLike), [cloneDeep(value)]);
      }, false, false);
    };
    _this.handlePush = function(value) {
      return function() {
        return _this.push(value);
      };
    };
    _this.swap = function(indexA, indexB) {
      return _this.updateArrayField(function(array) {
        return swap(array, indexA, indexB);
      }, true, true);
    };
    _this.handleSwap = function(indexA, indexB) {
      return function() {
        return _this.swap(indexA, indexB);
      };
    };
    _this.move = function(from, to2) {
      return _this.updateArrayField(function(array) {
        return move(array, from, to2);
      }, true, true);
    };
    _this.handleMove = function(from, to2) {
      return function() {
        return _this.move(from, to2);
      };
    };
    _this.insert = function(index2, value) {
      return _this.updateArrayField(function(array) {
        return insert(array, index2, value);
      }, function(array) {
        return insert(array, index2, null);
      }, function(array) {
        return insert(array, index2, null);
      });
    };
    _this.handleInsert = function(index2, value) {
      return function() {
        return _this.insert(index2, value);
      };
    };
    _this.replace = function(index2, value) {
      return _this.updateArrayField(function(array) {
        return replace(array, index2, value);
      }, false, false);
    };
    _this.handleReplace = function(index2, value) {
      return function() {
        return _this.replace(index2, value);
      };
    };
    _this.unshift = function(value) {
      var length = -1;
      _this.updateArrayField(function(array) {
        var arr = array ? [value].concat(array) : [value];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      }, function(array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      }, function(array) {
        var arr = array ? [null].concat(array) : [null];
        if (length < 0) {
          length = arr.length;
        }
        return arr;
      });
      return length;
    };
    _this.handleUnshift = function(value) {
      return function() {
        return _this.unshift(value);
      };
    };
    _this.handleRemove = function(index2) {
      return function() {
        return _this.remove(index2);
      };
    };
    _this.handlePop = function() {
      return function() {
        return _this.pop();
      };
    };
    _this.remove = _this.remove.bind(_assertThisInitialized$1(_this));
    _this.pop = _this.pop.bind(_assertThisInitialized$1(_this));
    return _this;
  }
  var _proto = FieldArrayInner2.prototype;
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.validateOnChange && this.props.formik.validateOnChange && !isEqual(getIn(prevProps.formik.values, prevProps.name), getIn(this.props.formik.values, this.props.name))) {
      this.props.formik.validateForm(this.props.formik.values);
    }
  };
  _proto.remove = function remove(index2) {
    var result;
    this.updateArrayField(
      // so this gets call 3 times
      function(array) {
        var copy = array ? copyArrayLike(array) : [];
        if (!result) {
          result = copy[index2];
        }
        if (isFunction(copy.splice)) {
          copy.splice(index2, 1);
        }
        return copy;
      },
      true,
      true
    );
    return result;
  };
  _proto.pop = function pop() {
    var result;
    this.updateArrayField(
      // so this gets call 3 times
      function(array) {
        var tmp = array;
        if (!result) {
          result = tmp && tmp.pop && tmp.pop();
        }
        return tmp;
      },
      true,
      true
    );
    return result;
  };
  _proto.render = function render() {
    var arrayHelpers = {
      push: this.push,
      pop: this.pop,
      swap: this.swap,
      move: this.move,
      insert: this.insert,
      replace: this.replace,
      unshift: this.unshift,
      remove: this.remove,
      handlePush: this.handlePush,
      handlePop: this.handlePop,
      handleSwap: this.handleSwap,
      handleMove: this.handleMove,
      handleInsert: this.handleInsert,
      handleReplace: this.handleReplace,
      handleUnshift: this.handleUnshift,
      handleRemove: this.handleRemove
    };
    var _this$props2 = this.props, component = _this$props2.component, render2 = _this$props2.render, children = _this$props2.children, name = _this$props2.name, _this$props2$formik = _this$props2.formik, restOfFormik = _objectWithoutPropertiesLoose$1(_this$props2$formik, ["validate", "validationSchema"]);
    var props = _extends$1({}, arrayHelpers, {
      form: restOfFormik,
      name
    });
    return component ? reactExports.createElement(component, props) : render2 ? render2(props) : children ? typeof children === "function" ? children(props) : !isEmptyChildren(children) ? reactExports.Children.only(children) : null : null;
  };
  return FieldArrayInner2;
}(reactExports.Component);
FieldArrayInner.defaultProps = {
  validateOnChange: true
};
var FieldArray = /* @__PURE__ */ connect(FieldArrayInner);
var defaultExitDuration = 250;
var defaultEnterDuration = 250;
var defaultTransitionDuration = 300;
var defaultEasingEnter = "ease-out";
var defaultEasingExit = "ease-in";
var defaultTransitionEasing = "ease";
var Variable;
(function(Variable2) {
  Variable2["Width"] = "%WIDTH%";
  Variable2["Height"] = "%HEIGHT%";
  Variable2["Top"] = "%TOP%";
  Variable2["Bottom"] = "%BOTTOM%";
  Variable2["Left"] = "%LEFT%";
  Variable2["Right"] = "%RIGHT%";
})(Variable || (Variable = {}));
var fade = {
  enter: {
    keyframes: {
      opacity: [0, 1]
    },
    options: { duration: defaultEnterDuration, easing: defaultEasingEnter }
  },
  exit: {
    keyframes: {
      opacity: [1, 0]
    },
    options: { duration: defaultExitDuration, easing: defaultEasingExit }
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op2) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op2[1])).done)
          return t2;
        if (y2 = 0, t2)
          op2 = [op2[0] & 2, t2.value];
        switch (op2[0]) {
          case 0:
          case 1:
            t2 = op2;
            break;
          case 4:
            _2.label++;
            return { value: op2[1], done: false };
          case 5:
            _2.label++;
            y2 = op2[1];
            op2 = [0];
            continue;
          case 7:
            op2 = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op2[0] === 3 && (!t2 || op2[1] > t2[0] && op2[1] < t2[3])) {
              _2.label = op2[1];
              break;
            }
            if (op2[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op2;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op2);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op2 = body.call(thisArg, _2);
      } catch (e2) {
        op2 = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op2[0] & 5)
      throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
}
var TransitionFade = function(props) {
  return React$1.createElement(ComponentTransition, __assign({ animateContainer: true }, props, { enterAnimation: fade.enter, exitAnimation: fade.exit }), props.children);
};
var ComponentTransitionContext = reactExports.createContext(null);
var TransitionState;
(function(TransitionState2) {
  TransitionState2["Exit"] = "exit";
  TransitionState2["Container"] = "container";
  TransitionState2["Enter"] = "enter";
  TransitionState2["ContainerRect"] = "container-rect";
})(TransitionState || (TransitionState = {}));
var useContainerRectangle = function(props) {
  var prevClientRect = reactExports.useRef(null);
  var nextClientRect = reactExports.useRef(null);
  var transitionState = props.transitionState, getElement = props.getElement, onFinish = props.onFinish;
  if (getElement() && transitionState === TransitionState.Exit) {
    prevClientRect.current = getElement().getBoundingClientRect();
  }
  reactExports.useLayoutEffect(function() {
    if (getElement() && transitionState === TransitionState.ContainerRect) {
      nextClientRect.current = getElement().getBoundingClientRect();
      onFinish();
    }
  }, [transitionState]);
  return {
    prevClientRect: prevClientRect.current,
    nextClientRect: nextClientRect.current
  };
};
var animationDurationThreshold = 100;
var animateContainer = function(element, prevClientRect, nextClientRect, duration, easing) {
  if (duration === void 0) {
    duration = defaultTransitionDuration;
  }
  if (easing === void 0) {
    easing = defaultTransitionEasing;
  }
  if (!element || !prevClientRect || !nextClientRect) {
    return null;
  }
  var newWidth = nextClientRect.width, newHeight = nextClientRect.height;
  var width = prevClientRect.width, height = prevClientRect.height;
  if (width === newWidth && height === newHeight) {
    return null;
  }
  var widthDelta = Math.abs(width - newWidth);
  var heightDelta = Math.abs(height - newHeight);
  var options = {
    duration,
    easing
  };
  if (typeof options.duration === "number" && widthDelta < animationDurationThreshold && heightDelta < animationDurationThreshold) {
    var max2 = Math.max(widthDelta, heightDelta);
    options.duration = max2 * options.duration / animationDurationThreshold;
  }
  var transition = {
    width: [width + "px", newWidth + "px"],
    height: [height + "px", newHeight + "px"]
  };
  return element.animate(transition, options);
};
var animateEnter = function(element, clientRect, settings) {
  return animateContent(element, clientRect, settings);
};
var animateExit = function(element, clientRect, settings) {
  var animationSettings = (Array.isArray(settings) ? settings : [settings]).filter(function(s2) {
    return s2;
  });
  for (var _i = 0, animationSettings_1 = animationSettings; _i < animationSettings_1.length; _i++) {
    var setting = animationSettings_1[_i];
    if (!setting.options) {
      setting.options = {
        fill: "forwards"
      };
      continue;
    }
    switch (setting.options.fill) {
      case "backwards":
      case "both":
        setting.options.fill = "both";
        break;
      default:
        setting.options.fill = "forwards";
    }
  }
  return animateContent(element, clientRect, animationSettings);
};
function finishAnimation(animation) {
  return __awaiter(this, void 0, void 0, function() {
    var animationCount, counter;
    return __generator(this, function(_a2) {
      animationCount = Array.isArray(animation) ? animation.filter(function(a2) {
        return a2;
      }).length : animation ? 1 : 0;
      counter = 0;
      return [2, new Promise(function(resolve) {
        if (!animationCount) {
          resolve();
        }
        var onFinish = function() {
          counter++;
          if (counter === animationCount) {
            resolve();
          }
        };
        animationCallback(animation, function(anim) {
          if (anim.playState === "finished") {
            onFinish();
          } else {
            anim.onfinish = onFinish;
          }
        });
      })];
    });
  });
}
var cancelAnimation = function(animation) {
  if (!animation) {
    return;
  }
  animationCallback(animation, function(anim) {
    anim.cancel();
  });
};
var animationCallback = function(animation, callback) {
  var animationArray = Array.isArray(animation) ? animation : [animation];
  for (var _i = 0, animationArray_1 = animationArray; _i < animationArray_1.length; _i++) {
    var anim = animationArray_1[_i];
    if (anim && callback) {
      callback(anim);
    }
  }
};
var animateContent = function(element, clientRect, settings) {
  if (!element || !settings) {
    return null;
  }
  var settingsArray = (Array.isArray(settings) ? settings : [settings]).filter(function(s2) {
    return s2;
  });
  var settingsKeyframes = [];
  for (var _i = 0, settingsArray_1 = settingsArray; _i < settingsArray_1.length; _i++) {
    var setting = settingsArray_1[_i];
    var keyframes = setting.keyframes;
    if (clientRect) {
      if (Array.isArray(setting.keyframes)) {
        for (var i = 0, len = setting.keyframes.length; i < len; i++) {
          keyframes[i] = replaceKeyframeVariable(setting.keyframes[i], clientRect);
        }
      } else {
        keyframes = replaceKeyframeVariable(setting.keyframes, clientRect);
      }
    }
    settingsKeyframes.push(keyframes);
  }
  return settingsArray.map(function(setting2, index2) {
    return element.animate(settingsKeyframes[index2], setting2.options);
  });
};
var replaceKeyframeVariable = function(keyframe, clientRect) {
  if (!keyframe || !clientRect) {
    return keyframe;
  }
  var replacedKeyframe = __assign({}, keyframe);
  var applyReplace = function(value2) {
    var newValue = value2;
    newValue = replaceVariable(newValue, clientRect.width.toString(), Variable.Width);
    newValue = replaceVariable(newValue, clientRect.height.toString(), Variable.Height);
    newValue = replaceVariable(newValue, clientRect.top.toString(), Variable.Top);
    newValue = replaceVariable(newValue, clientRect.bottom.toString(), Variable.Bottom);
    newValue = replaceVariable(newValue, clientRect.left.toString(), Variable.Left);
    newValue = replaceVariable(newValue, clientRect.right.toString(), Variable.Right);
    return newValue;
  };
  for (var index2 in keyframe) {
    var value = keyframe[index2];
    if (typeof value === "string") {
      replacedKeyframe[index2] = applyReplace(value);
    }
    if (Array.isArray(value)) {
      var valueArray = [];
      for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
        var keyframeValue = value_1[_i];
        if (typeof keyframeValue !== "string") {
          valueArray.push(keyframeValue);
          continue;
        }
        var newKeyframeValue = applyReplace(keyframeValue);
        valueArray.push(newKeyframeValue);
      }
      replacedKeyframe[index2] = valueArray;
    }
  }
  return replacedKeyframe;
};
var replaceVariable = function(value, newValue, variable) {
  if (!value || !variable) {
    return value;
  }
  var regExp = new RegExp(variable);
  if (regExp.test(value)) {
    return value.replace(variable, newValue);
  }
  return value;
};
var useExitAnimation = function(props) {
  var exitAnimation = reactExports.useRef([]);
  var isRunning = reactExports.useRef(false);
  var prevChildren = props.prevChildren, onFinish = props.onFinish, transitionState = props.transitionState, getElement = props.getElement, settings = props.settings, prevClientRect = props.prevClientRect, disabled = props.disabled;
  reactExports.useEffect(function() {
    return function() {
      cancelAnimation(exitAnimation.current);
    };
  }, []);
  var finish = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, finishAnimation(exitAnimation.current)];
          case 1:
            _a2.sent();
            cancelAnimation(exitAnimation.current);
            onFinish();
            isRunning.current = false;
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  reactExports.useEffect(function() {
    if (transitionState !== TransitionState.Exit) {
      return;
    }
    if (!prevChildren || disabled) {
      onFinish();
      return;
    }
    if (isRunning.current) {
      return;
    }
    cancelAnimation(exitAnimation.current);
    isRunning.current = true;
    exitAnimation.current = animateExit(getElement(), prevClientRect, settings);
    finish();
  });
};
var useContainerAnimation = function(props) {
  var transitionState = props.transitionState, prevClientRect = props.prevClientRect, nextClientRect = props.nextClientRect, animateContainer$1 = props.animateContainer, onFinish = props.onFinish, getElement = props.getElement, disabled = props.disabled;
  var transitionAnimation = reactExports.useRef(null);
  var isRunning = reactExports.useRef(false);
  reactExports.useEffect(function() {
    return function() {
      cancelAnimation(transitionAnimation.current);
    };
  }, []);
  var finish = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, finishAnimation(transitionAnimation.current)];
          case 1:
            _a2.sent();
            onFinish();
            isRunning.current = false;
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  reactExports.useLayoutEffect(function() {
    if (transitionState !== TransitionState.Container) {
      return;
    }
    if (!getElement() || !animateContainer$1 || !prevClientRect || disabled) {
      onFinish();
      return;
    }
    if (isRunning.current) {
      return;
    }
    isRunning.current = true;
    transitionAnimation.current = animateContainer(getElement(), prevClientRect, nextClientRect, props.animateContainerDuration, props.animateContainerEasing);
    finish();
  });
};
var useEnterAnimation = function(props) {
  var enterAnimation = reactExports.useRef([]);
  var isRunning = reactExports.useRef(false);
  var transitionState = props.transitionState, prevChildren = props.prevChildren, getElement = props.getElement, nextClientRect = props.nextClientRect, settings = props.settings, disabled = props.disabled, onFinish = props.onFinish;
  reactExports.useEffect(function() {
    return function() {
      cancelAnimation(enterAnimation.current);
    };
  }, []);
  var finish = function() {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, finishAnimation(enterAnimation.current)];
          case 1:
            _a2.sent();
            onFinish();
            isRunning.current = false;
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  reactExports.useLayoutEffect(function() {
    if (transitionState !== TransitionState.Enter) {
      return;
    }
    if (!prevChildren || disabled) {
      onFinish();
      return;
    }
    if (isRunning.current) {
      return;
    }
    isRunning.current = true;
    enterAnimation.current = animateEnter(getElement(), nextClientRect, settings);
    finish();
  });
};
var Transition = function(_a2) {
  var animateContainer2 = _a2.animateContainer, animateContainerDuration = _a2.animateContainerDuration, animateContainerEasing = _a2.animateContainerEasing, animateOnMount = _a2.animateOnMount, children = _a2.children, className = _a2.className, classNameEnter = _a2.classNameEnter, classNameExit = _a2.classNameExit, disabled = _a2.disabled, enterAnimation = _a2.enterAnimation, exitAnimation = _a2.exitAnimation, inViewRef = _a2.inViewRef, inViewEnabled = _a2.inViewEnabled, lazy = _a2.lazy, onEnterFinished = _a2.onEnterFinished, onExitFinished = _a2.onExitFinished, style = _a2.style;
  var _b = reactExports.useState(children && !lazy && animateOnMount && !animateContainer2 ? TransitionState.ContainerRect : null), transitionState = _b[0], setTransitionState = _b[1];
  var prevChildren = reactExports.useRef(animateOnMount && animateContainer2 ? null : children);
  var containerRef = reactExports.useRef(null);
  var unmounted = reactExports.useRef(false);
  var hasChildrenChanged = didChildrenChanged(prevChildren.current, children);
  if (!hasChildrenChanged && !transitionState) {
    prevChildren.current = children;
  }
  var udpatedState = function(state) {
    if (!unmounted.current) {
      setTransitionState(state);
    }
  };
  reactExports.useEffect(function() {
    return function() {
      return unmounted.current = true;
    };
  }, []);
  reactExports.useLayoutEffect(function() {
    if (inViewEnabled && animateOnMount && !animateContainer2) {
      udpatedState(TransitionState.ContainerRect);
    }
  }, [inViewEnabled]);
  reactExports.useEffect(function() {
    if (!hasChildrenChanged) {
      return;
    }
    if (!transitionState) {
      udpatedState(TransitionState.Exit);
    }
  });
  var animationHooks = {
    children,
    getElement: function() {
      return containerRef.current;
    },
    prevChildren: prevChildren.current,
    transitionState,
    disabled,
    onFinish: null
  };
  var _c2 = useContainerRectangle(__assign(__assign({}, animationHooks), { onFinish: function() {
    return udpatedState(TransitionState.Container);
  } })), nextClientRect = _c2.nextClientRect, prevClientRect = _c2.prevClientRect;
  var exitFinishedHandler = function() {
    onExitFinished && onExitFinished();
  };
  useExitAnimation(__assign(__assign({}, animationHooks), { prevClientRect, settings: exitAnimation, onFinish: function() {
    var hadPrevChildren = !!prevChildren.current;
    prevChildren.current = children;
    if (hadPrevChildren && !animateContainer2) {
      exitFinishedHandler();
    }
    udpatedState(TransitionState.ContainerRect);
  } }));
  useContainerAnimation(__assign(__assign({}, animationHooks), {
    prevClientRect,
    nextClientRect,
    animateContainer: animateContainer2,
    animateContainerDuration,
    animateContainerEasing,
    onFinish: function() {
      if (!prevChildren.current && animateContainer2) {
        exitFinishedHandler();
      }
      udpatedState(TransitionState.Enter);
    }
  }));
  useEnterAnimation(__assign(__assign({}, animationHooks), { nextClientRect, settings: enterAnimation, onFinish: function() {
    if (prevChildren.current) {
      onEnterFinished && onEnterFinished();
    }
    udpatedState(null);
  } }));
  var shouldRenderPrevChildren = hasChildrenChanged || transitionState === TransitionState.Exit;
  var hideContent = lazy && !inViewEnabled || transitionState === TransitionState.ContainerRect || transitionState === TransitionState.Container;
  var setRefs = reactExports.useCallback(function(element) {
    containerRef.current = element;
    inViewRef && inViewRef(element);
  }, [inViewRef]);
  if (!lazy && !hasChildrenChanged && !transitionState && !children) {
    return null;
  }
  return React$1.createElement("div", { ref: setRefs, className: classNames(className, transitionState === TransitionState.Enter && classNameEnter, transitionState === TransitionState.Exit && classNameExit) || null, style: __assign(__assign({}, style), { opacity: hideContent ? 0 : null }) }, shouldRenderPrevChildren ? prevChildren.current : children);
};
var didChildrenChanged = function(prevChildren, children) {
  var prevChildrenElement = prevChildren;
  var childrenElement = children;
  if (!prevChildren && !children) {
    return false;
  }
  if (!prevChildren && children) {
    return true;
  }
  if (prevChildren && !children) {
    return true;
  }
  if (prevChildrenElement.key === childrenElement.key && prevChildrenElement.type === childrenElement.type) {
    return false;
  }
  return true;
};
Transition.defaultProps = {
  animateContainer: false,
  animateContainerDuration: defaultTransitionDuration,
  animateContainerEasing: defaultTransitionEasing
};
Transition.displayName = "Transition";
var ObserverMap = /* @__PURE__ */ new Map();
var RootIds = /* @__PURE__ */ new WeakMap();
var rootId = 0;
function getRootId(root2) {
  if (!root2)
    return "0";
  if (RootIds.has(root2))
    return RootIds.get(root2);
  rootId += 1;
  RootIds.set(root2, rootId.toString());
  return RootIds.get(root2);
}
function optionsToId(options) {
  return Object.keys(options).sort().filter(function(key) {
    return options[key] !== void 0;
  }).map(function(key) {
    return key + "_" + (key === "root" ? getRootId(options.root) : options[key]);
  }).toString();
}
function createObserver(options) {
  var id2 = optionsToId(options);
  var instance = ObserverMap.get(id2);
  if (!instance) {
    var elements = /* @__PURE__ */ new Map();
    var thresholds;
    var observer = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        var _elements$get;
        var inView = entry.isIntersecting && thresholds.some(function(threshold) {
          return entry.intersectionRatio >= threshold;
        });
        if (options.trackVisibility && typeof entry.isVisible === "undefined") {
          entry.isVisible = inView;
        }
        (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(function(callback) {
          callback(inView, entry);
        });
      });
    }, options);
    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance = {
      id: id2,
      observer,
      elements
    };
    ObserverMap.set(id2, instance);
  }
  return instance;
}
function observe(element, callback, options) {
  if (options === void 0) {
    options = {};
  }
  if (!element)
    return function() {
    };
  var _createObserver = createObserver(options), id2 = _createObserver.id, observer = _createObserver.observer, elements = _createObserver.elements;
  var callbacks = elements.get(element) || [];
  if (!elements.has(element)) {
    elements.set(element, callbacks);
  }
  callbacks.push(callback);
  observer.observe(element);
  return function unobserve() {
    callbacks.splice(callbacks.indexOf(callback), 1);
    if (callbacks.length === 0) {
      elements["delete"](element);
      observer.unobserve(element);
    }
    if (elements.size === 0) {
      observer.disconnect();
      ObserverMap["delete"](id2);
    }
  };
}
function useInView(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, threshold = _ref.threshold, delay = _ref.delay, trackVisibility = _ref.trackVisibility, rootMargin = _ref.rootMargin, root2 = _ref.root, triggerOnce = _ref.triggerOnce, skip = _ref.skip, initialInView = _ref.initialInView;
  var unobserve = reactExports.useRef();
  var _React$useState = reactExports.useState({
    inView: !!initialInView
  }), state = _React$useState[0], setState = _React$useState[1];
  var setRef = reactExports.useCallback(
    function(node) {
      if (unobserve.current !== void 0) {
        unobserve.current();
        unobserve.current = void 0;
      }
      if (skip)
        return;
      if (node) {
        unobserve.current = observe(node, function(inView, entry) {
          setState({
            inView,
            entry
          });
          if (entry.isIntersecting && triggerOnce && unobserve.current) {
            unobserve.current();
            unobserve.current = void 0;
          }
        }, {
          root: root2,
          rootMargin,
          threshold,
          // @ts-ignore
          trackVisibility,
          // @ts-ignore
          delay
        });
      }
    },
    // We break the rule here, because we aren't including the actual `threshold` variable
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      // If the threshold is an array, convert it to a string so it won't change between renders.
      // eslint-disable-next-line react-hooks/exhaustive-deps
      Array.isArray(threshold) ? threshold.toString() : threshold,
      root2,
      rootMargin,
      triggerOnce,
      skip,
      trackVisibility,
      delay
    ]
  );
  reactExports.useEffect(function() {
    if (!unobserve.current && state.entry && !triggerOnce && !skip) {
      setState({
        inView: !!initialInView
      });
    }
  });
  var result = [setRef, state.inView, state.entry];
  result.ref = result[0];
  result.inView = result[1];
  result.entry = result[2];
  return result;
}
var LazyTransition = function(props) {
  var animateOnMount = props.animateOnMount, animateContainer2 = props.animateContainer, children = props.children, disabled = props.disabled, inViewOptions = props.inViewOptions;
  var _a2 = useInView(inViewOptions), inViewRef = _a2[0], inView = _a2[1], entry = _a2[2];
  var observerWait = !entry && animateOnMount && animateContainer2;
  return React$1.createElement(Transition, __assign({}, props, { inViewRef, inViewEnabled: !!entry, disabled: disabled || !inView }), observerWait ? null : children);
};
LazyTransition.displayName = "LazyTransition";
var ComponentTransition = function(props) {
  var context = reactExports.useContext(ComponentTransitionContext);
  var forceExit = (context === null || context === void 0 ? void 0 : context.exitKeys.indexOf(context.contextId)) > -1;
  var forceEnter = (context === null || context === void 0 ? void 0 : context.enterKeys.indexOf(context.contextId)) > -1;
  var animateOnMount = props.animateOnMount, children = props.children, lazy = props.lazy, onEnterFinished = props.onEnterFinished, onExitFinished = props.onExitFinished;
  var handleEnterFinished = function() {
    if (onEnterFinished) {
      onEnterFinished();
    }
    if ((context === null || context === void 0 ? void 0 : context.contextId) && (context === null || context === void 0 ? void 0 : context.onEnterFinished)) {
      context.onEnterFinished(context.contextId);
    }
  };
  var handleExitFinished = function() {
    if (onExitFinished) {
      onExitFinished();
    }
    if ((context === null || context === void 0 ? void 0 : context.contextId) && (context === null || context === void 0 ? void 0 : context.onExitFinished)) {
      context.onExitFinished(context.contextId);
    }
  };
  var Component = lazy ? LazyTransition : Transition;
  return (
    // Clear context for nested transitions
    React$1.createElement(
      ComponentTransitionContext.Provider,
      { value: null },
      React$1.createElement(Component, __assign({}, props, { animateOnMount: forceEnter || animateOnMount, onEnterFinished: handleEnterFinished, onExitFinished: handleExitFinished }), forceExit ? null : children)
    )
  );
};
ComponentTransition.displayName = "ComponentTransition";
const Svg85901Eed410D7B8F = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 9.1174364, height: 9.1174459, viewBox: "0 0 9.1174364 9.1174459", id: "svg22", ...props }, /* @__PURE__ */ reactExports.createElement("path", { id: "rect18", d: "M 0,7.7032211 7.7032211,0 9.1174351,1.4142136 1.4142136,9.1174351 Z M 1.4e-6,1.4142246 1.414215,1.11e-5 l 7.7032211,7.703221 -1.414213,1.414214 z" }));
const SvgC707E009107B34Db = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 7", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M19.89.006A10.72 10.72 0 0 0 9.32 10.83v5.88H7.13a5.19 5.19 0 0 0-5.19 5.19v12.92A5.17 5.17 0 0 0 7.13 40H33a5.19 5.19 0 0 0 5.19-5.19V21.9A5.19 5.19 0 0 0 33 16.71h-2.24v-6.09A10.72 10.72 0 0 0 19.89.005zM20 3a7.53 7.53 0 0 1 5.44 2.21 7.71 7.71 0 0 1 2.32 5.44v6.06H12.32l.05-5.91A7.72 7.72 0 0 1 20 3zM7.13 19.71H33a2.21 2.21 0 0 1 1.55.64 2.18 2.18 0 0 1 .64 1.55v12.92A2.19 2.19 0 0 1 33 37H7.13a2.14 2.14 0 0 1-1.55-.65 2.17 2.17 0 0 1-.64-1.54V21.9a2.19 2.19 0 0 1 2.19-2.19z" }));
const SvgC8F08Adbe83Afe3E = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 5", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M17.3 0A5.3 5.3 0 0 0 12 5.27v17.07a5.3 5.3 0 0 0 5.29 5.3h17.08a5.3 5.3 0 0 0 5.29-5.3V5.29A5.29 5.29 0 0 0 34.37 0H17.3zm0 3h17.07a2.3 2.3 0 0 1 2.29 2.27v17.07a2.3 2.3 0 0 1-2.29 2.3H17.29a2.3 2.3 0 0 1-2.29-2.3V5.27A2.3 2.3 0 0 1 17.3 3zm13.585 4.559a1.503 1.503 0 0 0-.033.002H20a1.5 1.5 0 0 0 0 3h7.309L19 18.869A1.5 1.5 0 0 0 19 21a1.48 1.48 0 0 0 1 .47 1.5 1.5 0 0 0 1.08-.47l8.35-8.32v7.29a1.5 1.5 0 0 0 1.5 1.5 1.5 1.5 0 0 0 1.5-1.47V9.201a1.503 1.503 0 0 0-1.545-1.642zM5.67 12.31A5.29 5.29 0 0 0 .38 17.6v17.08A5.29 5.29 0 0 0 5.67 40h17.08A5.29 5.29 0 0 0 28 34.68v-1.9a1.5 1.5 0 0 0-3 0v1.9A2.3 2.3 0 0 1 22.75 37H5.67a2.3 2.3 0 0 1-2.29-2.32V17.6a2.3 2.3 0 0 1 2.29-2.29h1.9a1.5 1.5 0 0 0 0-3h-1.9z" }));
const SvgE29A75303Cd009Cd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", "data-name": "Ebene 6", viewBox: "0 0 40 40", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M16.29 0a5.2 5.2 0 0 0-5.2 5.19v2.2H3.34a1.5 1.5 0 0 0 0 3h2.2V34.8a5.2 5.2 0 0 0 5.2 5.2h18.49a5.2 5.2 0 0 0 5.2-5.22V10.39h2.2a1.5 1.5 0 0 0 0-3H28.882V5.2A5.2 5.2 0 0 0 23.68 0h-7.39zm0 3h7.39a2.2 2.2 0 0 1 2.2 2.19v2.2H14.09V5.2a2.21 2.21 0 0 1 2.2-2.2zm-7.75 7.39h3.884a1.5 1.5 0 0 0 .318 0H31.43v24.39a2.2 2.2 0 0 1-2.2 2.2H10.74a2.21 2.21 0 0 1-2.2-2.2V10.39z" }));
const Svg92Beb0D5816827F1 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 240 240", width: 240, height: 240, ...props }, /* @__PURE__ */ reactExports.createElement("g", { "data-name": "Layer 2" }, /* @__PURE__ */ reactExports.createElement("g", { "data-name": "Layer 1" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M120.037 214.988a94.486 94.486 0 0054.407-17.147l-36.933-44.088a37.84 37.84 0 01-31.657 1.488L68.5 199.76a94.58 94.58 0 0051.538 15.227z", fill: "#3e48f8" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M189.608 55.395l-37.366 44.573a37.893 37.893 0 01-14.773 53.817l36.986 44.087a94.971 94.971 0 0015.164-142.456z", fill: "#00c9ff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M158.025 120.017a37.788 37.788 0 00-5.783-20.05l-46.367 55.284a37.988 37.988 0 0052.15-35.234z", fill: "#00f500" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M68.478 199.761l37.345-44.51a37.988 37.988 0 1146.43-55.347l37.345-44.51a94.971 94.971 0 10-121.12 144.388z", fill: "#292748" }))));
const Svg79403247197Ec9Cd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 236 236", style: {
  enableBackground: "new 0 0 236 236"
}, xmlSpace: "preserve", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M165.2 118.5c0-8.8-2.5-17.4-7.1-24.8l-57.3 68.4c7.1 2.9 14.8 3.9 22.5 3.1 7.6-.8 14.9-3.5 21.3-7.8s11.6-10.1 15.2-16.9c3.5-6.7 5.4-14.3 5.4-22z", style: {
  fill: "#999"
} }), /* @__PURE__ */ reactExports.createElement("path", { d: "M118.5 229.9c61.5 0 111.4-49.9 111.4-111.4S180 7.1 118.5 7.1 7.1 57 7.1 118.5 57 229.9 118.5 229.9z", style: {
  fill: "#fff",
  stroke: "#fff",
  strokeWidth: 11
} }), /* @__PURE__ */ reactExports.createElement("path", { d: "M118.3 222.9c21.4 0 42.2-6.6 59.7-18.9l-40.5-48.5c-5.3 2.8-11.2 4.4-17.2 4.6-6 .3-12-.7-17.6-3l-41 49c16.9 11 36.5 16.9 56.6 16.8z", style: {
  fill: "#3e48f8"
} }), /* @__PURE__ */ reactExports.createElement("path", { d: "m194.7 47.4-41 49c3.1 4.9 5.1 10.4 5.9 16.1.8 5.7.5 11.5-1 17.1-1.5 5.6-4.2 10.8-7.8 15.2-3.6 4.5-8.1 8.2-13.3 10.8l40.6 48.5c12.2-8.6 22.5-19.6 30-32.5 7.6-12.9 12.3-27.2 13.9-42 1.6-14.8 0-29.9-4.7-44-4.8-14.2-12.5-27.2-22.6-38.2z", style: {
  fill: "#00c8ff"
} }), /* @__PURE__ */ reactExports.createElement("path", { d: "M160 118.5c0-7.8-2.2-15.4-6.3-22l-50.9 60.8c6.3 2.5 13.2 3.5 20 2.8 6.8-.7 13.3-3.1 18.9-6.9 5.6-3.8 10.3-9 13.5-15 3.1-6.1 4.8-12.9 4.8-19.7z", style: {
  fill: "#00f500"
} }), /* @__PURE__ */ reactExports.createElement("path", { d: "m61.7 206.2 41-48.9c-6.1-2.5-11.5-6.3-15.9-11.3-4.3-5-7.4-10.9-9-17.3-1.6-6.4-1.7-13.1-.2-19.5s4.5-12.4 8.7-17.5 9.6-9 15.7-11.6 12.6-3.7 19.2-3.2 12.9 2.5 18.6 5.9c5.6 3.4 10.4 8.1 13.9 13.7l41-48.9c-10.1-10.9-22.3-19.5-35.9-25.2-13.6-5.8-28.3-8.5-43.1-8.2S86.3 17.9 73 24.4c-13.3 6.4-25.1 15.6-34.6 27C28.9 62.7 21.9 76 17.9 90.3s-4.9 29.2-2.7 43.9c2.2 14.6 7.5 28.7 15.5 41.1 8 12.3 18.6 22.9 31 30.9z", style: {
  fill: "#282846"
} }));
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  factoryWithThrowingShims();
}
var mode$1 = {
  MODE_NUMBER: 1 << 0,
  MODE_ALPHA_NUM: 1 << 1,
  MODE_8BIT_BYTE: 1 << 2,
  MODE_KANJI: 1 << 3
};
var mode = mode$1;
function QR8bitByte(data) {
  this.mode = mode.MODE_8BIT_BYTE;
  this.data = data;
}
QR8bitByte.prototype = {
  getLength: function(buffer) {
    return this.data.length;
  },
  write: function(buffer) {
    for (var i = 0; i < this.data.length; i++) {
      buffer.put(this.data.charCodeAt(i), 8);
    }
  }
};
var _8BitByte = QR8bitByte;
var ErrorCorrectLevel$1 = {
  L: 1,
  M: 0,
  Q: 3,
  H: 2
};
var ECL = ErrorCorrectLevel$1;
function QRRSBlock(totalCount, dataCount) {
  this.totalCount = totalCount;
  this.dataCount = dataCount;
}
QRRSBlock.RS_BLOCK_TABLE = [
  // L
  // M
  // Q
  // H
  // 1
  [1, 26, 19],
  [1, 26, 16],
  [1, 26, 13],
  [1, 26, 9],
  // 2
  [1, 44, 34],
  [1, 44, 28],
  [1, 44, 22],
  [1, 44, 16],
  // 3
  [1, 70, 55],
  [1, 70, 44],
  [2, 35, 17],
  [2, 35, 13],
  // 4		
  [1, 100, 80],
  [2, 50, 32],
  [2, 50, 24],
  [4, 25, 9],
  // 5
  [1, 134, 108],
  [2, 67, 43],
  [2, 33, 15, 2, 34, 16],
  [2, 33, 11, 2, 34, 12],
  // 6
  [2, 86, 68],
  [4, 43, 27],
  [4, 43, 19],
  [4, 43, 15],
  // 7		
  [2, 98, 78],
  [4, 49, 31],
  [2, 32, 14, 4, 33, 15],
  [4, 39, 13, 1, 40, 14],
  // 8
  [2, 121, 97],
  [2, 60, 38, 2, 61, 39],
  [4, 40, 18, 2, 41, 19],
  [4, 40, 14, 2, 41, 15],
  // 9
  [2, 146, 116],
  [3, 58, 36, 2, 59, 37],
  [4, 36, 16, 4, 37, 17],
  [4, 36, 12, 4, 37, 13],
  // 10		
  [2, 86, 68, 2, 87, 69],
  [4, 69, 43, 1, 70, 44],
  [6, 43, 19, 2, 44, 20],
  [6, 43, 15, 2, 44, 16],
  // 11
  [4, 101, 81],
  [1, 80, 50, 4, 81, 51],
  [4, 50, 22, 4, 51, 23],
  [3, 36, 12, 8, 37, 13],
  // 12
  [2, 116, 92, 2, 117, 93],
  [6, 58, 36, 2, 59, 37],
  [4, 46, 20, 6, 47, 21],
  [7, 42, 14, 4, 43, 15],
  // 13
  [4, 133, 107],
  [8, 59, 37, 1, 60, 38],
  [8, 44, 20, 4, 45, 21],
  [12, 33, 11, 4, 34, 12],
  // 14
  [3, 145, 115, 1, 146, 116],
  [4, 64, 40, 5, 65, 41],
  [11, 36, 16, 5, 37, 17],
  [11, 36, 12, 5, 37, 13],
  // 15
  [5, 109, 87, 1, 110, 88],
  [5, 65, 41, 5, 66, 42],
  [5, 54, 24, 7, 55, 25],
  [11, 36, 12],
  // 16
  [5, 122, 98, 1, 123, 99],
  [7, 73, 45, 3, 74, 46],
  [15, 43, 19, 2, 44, 20],
  [3, 45, 15, 13, 46, 16],
  // 17
  [1, 135, 107, 5, 136, 108],
  [10, 74, 46, 1, 75, 47],
  [1, 50, 22, 15, 51, 23],
  [2, 42, 14, 17, 43, 15],
  // 18
  [5, 150, 120, 1, 151, 121],
  [9, 69, 43, 4, 70, 44],
  [17, 50, 22, 1, 51, 23],
  [2, 42, 14, 19, 43, 15],
  // 19
  [3, 141, 113, 4, 142, 114],
  [3, 70, 44, 11, 71, 45],
  [17, 47, 21, 4, 48, 22],
  [9, 39, 13, 16, 40, 14],
  // 20
  [3, 135, 107, 5, 136, 108],
  [3, 67, 41, 13, 68, 42],
  [15, 54, 24, 5, 55, 25],
  [15, 43, 15, 10, 44, 16],
  // 21
  [4, 144, 116, 4, 145, 117],
  [17, 68, 42],
  [17, 50, 22, 6, 51, 23],
  [19, 46, 16, 6, 47, 17],
  // 22
  [2, 139, 111, 7, 140, 112],
  [17, 74, 46],
  [7, 54, 24, 16, 55, 25],
  [34, 37, 13],
  // 23
  [4, 151, 121, 5, 152, 122],
  [4, 75, 47, 14, 76, 48],
  [11, 54, 24, 14, 55, 25],
  [16, 45, 15, 14, 46, 16],
  // 24
  [6, 147, 117, 4, 148, 118],
  [6, 73, 45, 14, 74, 46],
  [11, 54, 24, 16, 55, 25],
  [30, 46, 16, 2, 47, 17],
  // 25
  [8, 132, 106, 4, 133, 107],
  [8, 75, 47, 13, 76, 48],
  [7, 54, 24, 22, 55, 25],
  [22, 45, 15, 13, 46, 16],
  // 26
  [10, 142, 114, 2, 143, 115],
  [19, 74, 46, 4, 75, 47],
  [28, 50, 22, 6, 51, 23],
  [33, 46, 16, 4, 47, 17],
  // 27
  [8, 152, 122, 4, 153, 123],
  [22, 73, 45, 3, 74, 46],
  [8, 53, 23, 26, 54, 24],
  [12, 45, 15, 28, 46, 16],
  // 28
  [3, 147, 117, 10, 148, 118],
  [3, 73, 45, 23, 74, 46],
  [4, 54, 24, 31, 55, 25],
  [11, 45, 15, 31, 46, 16],
  // 29
  [7, 146, 116, 7, 147, 117],
  [21, 73, 45, 7, 74, 46],
  [1, 53, 23, 37, 54, 24],
  [19, 45, 15, 26, 46, 16],
  // 30
  [5, 145, 115, 10, 146, 116],
  [19, 75, 47, 10, 76, 48],
  [15, 54, 24, 25, 55, 25],
  [23, 45, 15, 25, 46, 16],
  // 31
  [13, 145, 115, 3, 146, 116],
  [2, 74, 46, 29, 75, 47],
  [42, 54, 24, 1, 55, 25],
  [23, 45, 15, 28, 46, 16],
  // 32
  [17, 145, 115],
  [10, 74, 46, 23, 75, 47],
  [10, 54, 24, 35, 55, 25],
  [19, 45, 15, 35, 46, 16],
  // 33
  [17, 145, 115, 1, 146, 116],
  [14, 74, 46, 21, 75, 47],
  [29, 54, 24, 19, 55, 25],
  [11, 45, 15, 46, 46, 16],
  // 34
  [13, 145, 115, 6, 146, 116],
  [14, 74, 46, 23, 75, 47],
  [44, 54, 24, 7, 55, 25],
  [59, 46, 16, 1, 47, 17],
  // 35
  [12, 151, 121, 7, 152, 122],
  [12, 75, 47, 26, 76, 48],
  [39, 54, 24, 14, 55, 25],
  [22, 45, 15, 41, 46, 16],
  // 36
  [6, 151, 121, 14, 152, 122],
  [6, 75, 47, 34, 76, 48],
  [46, 54, 24, 10, 55, 25],
  [2, 45, 15, 64, 46, 16],
  // 37
  [17, 152, 122, 4, 153, 123],
  [29, 74, 46, 14, 75, 47],
  [49, 54, 24, 10, 55, 25],
  [24, 45, 15, 46, 46, 16],
  // 38
  [4, 152, 122, 18, 153, 123],
  [13, 74, 46, 32, 75, 47],
  [48, 54, 24, 14, 55, 25],
  [42, 45, 15, 32, 46, 16],
  // 39
  [20, 147, 117, 4, 148, 118],
  [40, 75, 47, 7, 76, 48],
  [43, 54, 24, 22, 55, 25],
  [10, 45, 15, 67, 46, 16],
  // 40
  [19, 148, 118, 6, 149, 119],
  [18, 75, 47, 31, 76, 48],
  [34, 54, 24, 34, 55, 25],
  [20, 45, 15, 61, 46, 16]
];
QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
  var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
  if (rsBlock == void 0) {
    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
  }
  var length = rsBlock.length / 3;
  var list = new Array();
  for (var i = 0; i < length; i++) {
    var count = rsBlock[i * 3 + 0];
    var totalCount = rsBlock[i * 3 + 1];
    var dataCount = rsBlock[i * 3 + 2];
    for (var j = 0; j < count; j++) {
      list.push(new QRRSBlock(totalCount, dataCount));
    }
  }
  return list;
};
QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
  switch (errorCorrectLevel) {
    case ECL.L:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
    case ECL.M:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
    case ECL.Q:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
    case ECL.H:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var RSBlock$1 = QRRSBlock;
function QRBitBuffer() {
  this.buffer = new Array();
  this.length = 0;
}
QRBitBuffer.prototype = {
  get: function(index2) {
    var bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) == 1;
  },
  put: function(num, length) {
    for (var i = 0; i < length; i++) {
      this.putBit((num >>> length - i - 1 & 1) == 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var BitBuffer$1 = QRBitBuffer;
var QRMath = {
  glog: function(n2) {
    if (n2 < 1) {
      throw new Error("glog(" + n2 + ")");
    }
    return QRMath.LOG_TABLE[n2];
  },
  gexp: function(n2) {
    while (n2 < 0) {
      n2 += 255;
    }
    while (n2 >= 256) {
      n2 -= 255;
    }
    return QRMath.EXP_TABLE[n2];
  },
  EXP_TABLE: new Array(256),
  LOG_TABLE: new Array(256)
};
for (var i = 0; i < 8; i++) {
  QRMath.EXP_TABLE[i] = 1 << i;
}
for (var i = 8; i < 256; i++) {
  QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
}
for (var i = 0; i < 255; i++) {
  QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
}
var math$2 = QRMath;
var math$1 = math$2;
function QRPolynomial(num, shift) {
  if (num.length == void 0) {
    throw new Error(num.length + "/" + shift);
  }
  var offset = 0;
  while (offset < num.length && num[offset] == 0) {
    offset++;
  }
  this.num = new Array(num.length - offset + shift);
  for (var i = 0; i < num.length - offset; i++) {
    this.num[i] = num[i + offset];
  }
}
QRPolynomial.prototype = {
  get: function(index2) {
    return this.num[index2];
  },
  getLength: function() {
    return this.num.length;
  },
  multiply: function(e2) {
    var num = new Array(this.getLength() + e2.getLength() - 1);
    for (var i = 0; i < this.getLength(); i++) {
      for (var j = 0; j < e2.getLength(); j++) {
        num[i + j] ^= math$1.gexp(math$1.glog(this.get(i)) + math$1.glog(e2.get(j)));
      }
    }
    return new QRPolynomial(num, 0);
  },
  mod: function(e2) {
    if (this.getLength() - e2.getLength() < 0) {
      return this;
    }
    var ratio = math$1.glog(this.get(0)) - math$1.glog(e2.get(0));
    var num = new Array(this.getLength());
    for (var i = 0; i < this.getLength(); i++) {
      num[i] = this.get(i);
    }
    for (var i = 0; i < e2.getLength(); i++) {
      num[i] ^= math$1.gexp(math$1.glog(e2.get(i)) + ratio);
    }
    return new QRPolynomial(num, 0).mod(e2);
  }
};
var Polynomial$2 = QRPolynomial;
var Mode = mode$1;
var Polynomial$1 = Polynomial$2;
var math = math$2;
var QRMaskPattern = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
};
var QRUtil = {
  PATTERN_POSITION_TABLE: [
    [],
    [6, 18],
    [6, 22],
    [6, 26],
    [6, 30],
    [6, 34],
    [6, 22, 38],
    [6, 24, 42],
    [6, 26, 46],
    [6, 28, 50],
    [6, 30, 54],
    [6, 32, 58],
    [6, 34, 62],
    [6, 26, 46, 66],
    [6, 26, 48, 70],
    [6, 26, 50, 74],
    [6, 30, 54, 78],
    [6, 30, 56, 82],
    [6, 30, 58, 86],
    [6, 34, 62, 90],
    [6, 28, 50, 72, 94],
    [6, 26, 50, 74, 98],
    [6, 30, 54, 78, 102],
    [6, 28, 54, 80, 106],
    [6, 32, 58, 84, 110],
    [6, 30, 58, 86, 114],
    [6, 34, 62, 90, 118],
    [6, 26, 50, 74, 98, 122],
    [6, 30, 54, 78, 102, 126],
    [6, 26, 52, 78, 104, 130],
    [6, 30, 56, 82, 108, 134],
    [6, 34, 60, 86, 112, 138],
    [6, 30, 58, 86, 114, 142],
    [6, 34, 62, 90, 118, 146],
    [6, 30, 54, 78, 102, 126, 150],
    [6, 24, 50, 76, 102, 128, 154],
    [6, 28, 54, 80, 106, 132, 158],
    [6, 32, 58, 84, 110, 136, 162],
    [6, 26, 54, 82, 110, 138, 166],
    [6, 30, 58, 86, 114, 142, 170]
  ],
  G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0,
  G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0,
  G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1,
  getBCHTypeInfo: function(data) {
    var d2 = data << 10;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
      d2 ^= QRUtil.G15 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15);
    }
    return (data << 10 | d2) ^ QRUtil.G15_MASK;
  },
  getBCHTypeNumber: function(data) {
    var d2 = data << 12;
    while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
      d2 ^= QRUtil.G18 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18);
    }
    return data << 12 | d2;
  },
  getBCHDigit: function(data) {
    var digit = 0;
    while (data != 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  },
  getPatternPosition: function(typeNumber) {
    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
  },
  getMask: function(maskPattern, i, j) {
    switch (maskPattern) {
      case QRMaskPattern.PATTERN000:
        return (i + j) % 2 == 0;
      case QRMaskPattern.PATTERN001:
        return i % 2 == 0;
      case QRMaskPattern.PATTERN010:
        return j % 3 == 0;
      case QRMaskPattern.PATTERN011:
        return (i + j) % 3 == 0;
      case QRMaskPattern.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
      case QRMaskPattern.PATTERN101:
        return i * j % 2 + i * j % 3 == 0;
      case QRMaskPattern.PATTERN110:
        return (i * j % 2 + i * j % 3) % 2 == 0;
      case QRMaskPattern.PATTERN111:
        return (i * j % 3 + (i + j) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern);
    }
  },
  getErrorCorrectPolynomial: function(errorCorrectLength) {
    var a2 = new Polynomial$1([1], 0);
    for (var i = 0; i < errorCorrectLength; i++) {
      a2 = a2.multiply(new Polynomial$1([1, math.gexp(i)], 0));
    }
    return a2;
  },
  getLengthInBits: function(mode2, type) {
    if (1 <= type && type < 10) {
      switch (mode2) {
        case Mode.MODE_NUMBER:
          return 10;
        case Mode.MODE_ALPHA_NUM:
          return 9;
        case Mode.MODE_8BIT_BYTE:
          return 8;
        case Mode.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + mode2);
      }
    } else if (type < 27) {
      switch (mode2) {
        case Mode.MODE_NUMBER:
          return 12;
        case Mode.MODE_ALPHA_NUM:
          return 11;
        case Mode.MODE_8BIT_BYTE:
          return 16;
        case Mode.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + mode2);
      }
    } else if (type < 41) {
      switch (mode2) {
        case Mode.MODE_NUMBER:
          return 14;
        case Mode.MODE_ALPHA_NUM:
          return 13;
        case Mode.MODE_8BIT_BYTE:
          return 16;
        case Mode.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + mode2);
      }
    } else {
      throw new Error("type:" + type);
    }
  },
  getLostPoint: function(qrCode) {
    var moduleCount = qrCode.getModuleCount();
    var lostPoint = 0;
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount; col++) {
        var sameCount = 0;
        var dark = qrCode.isDark(row, col);
        for (var r2 = -1; r2 <= 1; r2++) {
          if (row + r2 < 0 || moduleCount <= row + r2) {
            continue;
          }
          for (var c2 = -1; c2 <= 1; c2++) {
            if (col + c2 < 0 || moduleCount <= col + c2) {
              continue;
            }
            if (r2 == 0 && c2 == 0) {
              continue;
            }
            if (dark == qrCode.isDark(row + r2, col + c2)) {
              sameCount++;
            }
          }
        }
        if (sameCount > 5) {
          lostPoint += 3 + sameCount - 5;
        }
      }
    }
    for (var row = 0; row < moduleCount - 1; row++) {
      for (var col = 0; col < moduleCount - 1; col++) {
        var count = 0;
        if (qrCode.isDark(row, col))
          count++;
        if (qrCode.isDark(row + 1, col))
          count++;
        if (qrCode.isDark(row, col + 1))
          count++;
        if (qrCode.isDark(row + 1, col + 1))
          count++;
        if (count == 0 || count == 4) {
          lostPoint += 3;
        }
      }
    }
    for (var row = 0; row < moduleCount; row++) {
      for (var col = 0; col < moduleCount - 6; col++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
          lostPoint += 40;
        }
      }
    }
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount - 6; row++) {
        if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
          lostPoint += 40;
        }
      }
    }
    var darkCount = 0;
    for (var col = 0; col < moduleCount; col++) {
      for (var row = 0; row < moduleCount; row++) {
        if (qrCode.isDark(row, col)) {
          darkCount++;
        }
      }
    }
    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
    lostPoint += ratio * 10;
    return lostPoint;
  }
};
var util$1 = QRUtil;
var BitByte = _8BitByte;
var RSBlock = RSBlock$1;
var BitBuffer = BitBuffer$1;
var util = util$1;
var Polynomial = Polynomial$2;
function QRCode$1(typeNumber, errorCorrectLevel) {
  this.typeNumber = typeNumber;
  this.errorCorrectLevel = errorCorrectLevel;
  this.modules = null;
  this.moduleCount = 0;
  this.dataCache = null;
  this.dataList = [];
}
var proto = QRCode$1.prototype;
proto.addData = function(data) {
  var newData = new BitByte(data);
  this.dataList.push(newData);
  this.dataCache = null;
};
proto.isDark = function(row, col) {
  if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
    throw new Error(row + "," + col);
  }
  return this.modules[row][col];
};
proto.getModuleCount = function() {
  return this.moduleCount;
};
proto.make = function() {
  if (this.typeNumber < 1) {
    var typeNumber = 1;
    for (typeNumber = 1; typeNumber < 40; typeNumber++) {
      var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);
      var buffer = new BitBuffer();
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i++) {
        totalDataCount += rsBlocks[i].dataCount;
      }
      for (var i = 0; i < this.dataList.length; i++) {
        var data = this.dataList[i];
        buffer.put(data.mode, 4);
        buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
        data.write(buffer);
      }
      if (buffer.getLengthInBits() <= totalDataCount * 8)
        break;
    }
    this.typeNumber = typeNumber;
  }
  this.makeImpl(false, this.getBestMaskPattern());
};
proto.makeImpl = function(test, maskPattern) {
  this.moduleCount = this.typeNumber * 4 + 17;
  this.modules = new Array(this.moduleCount);
  for (var row = 0; row < this.moduleCount; row++) {
    this.modules[row] = new Array(this.moduleCount);
    for (var col = 0; col < this.moduleCount; col++) {
      this.modules[row][col] = null;
    }
  }
  this.setupPositionProbePattern(0, 0);
  this.setupPositionProbePattern(this.moduleCount - 7, 0);
  this.setupPositionProbePattern(0, this.moduleCount - 7);
  this.setupPositionAdjustPattern();
  this.setupTimingPattern();
  this.setupTypeInfo(test, maskPattern);
  if (this.typeNumber >= 7) {
    this.setupTypeNumber(test);
  }
  if (this.dataCache == null) {
    this.dataCache = QRCode$1.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
  }
  this.mapData(this.dataCache, maskPattern);
};
proto.setupPositionProbePattern = function(row, col) {
  for (var r2 = -1; r2 <= 7; r2++) {
    if (row + r2 <= -1 || this.moduleCount <= row + r2)
      continue;
    for (var c2 = -1; c2 <= 7; c2++) {
      if (col + c2 <= -1 || this.moduleCount <= col + c2)
        continue;
      if (0 <= r2 && r2 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r2 == 0 || r2 == 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
        this.modules[row + r2][col + c2] = true;
      } else {
        this.modules[row + r2][col + c2] = false;
      }
    }
  }
};
proto.getBestMaskPattern = function() {
  var minLostPoint = 0;
  var pattern = 0;
  for (var i = 0; i < 8; i++) {
    this.makeImpl(true, i);
    var lostPoint = util.getLostPoint(this);
    if (i == 0 || minLostPoint > lostPoint) {
      minLostPoint = lostPoint;
      pattern = i;
    }
  }
  return pattern;
};
proto.createMovieClip = function(target_mc, instance_name, depth) {
  var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
  var cs2 = 1;
  this.make();
  for (var row = 0; row < this.modules.length; row++) {
    var y2 = row * cs2;
    for (var col = 0; col < this.modules[row].length; col++) {
      var x = col * cs2;
      var dark = this.modules[row][col];
      if (dark) {
        qr_mc.beginFill(0, 100);
        qr_mc.moveTo(x, y2);
        qr_mc.lineTo(x + cs2, y2);
        qr_mc.lineTo(x + cs2, y2 + cs2);
        qr_mc.lineTo(x, y2 + cs2);
        qr_mc.endFill();
      }
    }
  }
  return qr_mc;
};
proto.setupTimingPattern = function() {
  for (var r2 = 8; r2 < this.moduleCount - 8; r2++) {
    if (this.modules[r2][6] != null) {
      continue;
    }
    this.modules[r2][6] = r2 % 2 == 0;
  }
  for (var c2 = 8; c2 < this.moduleCount - 8; c2++) {
    if (this.modules[6][c2] != null) {
      continue;
    }
    this.modules[6][c2] = c2 % 2 == 0;
  }
};
proto.setupPositionAdjustPattern = function() {
  var pos = util.getPatternPosition(this.typeNumber);
  for (var i = 0; i < pos.length; i++) {
    for (var j = 0; j < pos.length; j++) {
      var row = pos[i];
      var col = pos[j];
      if (this.modules[row][col] != null) {
        continue;
      }
      for (var r2 = -2; r2 <= 2; r2++) {
        for (var c2 = -2; c2 <= 2; c2++) {
          if (r2 == -2 || r2 == 2 || c2 == -2 || c2 == 2 || r2 == 0 && c2 == 0) {
            this.modules[row + r2][col + c2] = true;
          } else {
            this.modules[row + r2][col + c2] = false;
          }
        }
      }
    }
  }
};
proto.setupTypeNumber = function(test) {
  var bits = util.getBCHTypeNumber(this.typeNumber);
  for (var i = 0; i < 18; i++) {
    var mod = !test && (bits >> i & 1) == 1;
    this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
  }
  for (var i = 0; i < 18; i++) {
    var mod = !test && (bits >> i & 1) == 1;
    this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
  }
};
proto.setupTypeInfo = function(test, maskPattern) {
  var data = this.errorCorrectLevel << 3 | maskPattern;
  var bits = util.getBCHTypeInfo(data);
  for (var i = 0; i < 15; i++) {
    var mod = !test && (bits >> i & 1) == 1;
    if (i < 6) {
      this.modules[i][8] = mod;
    } else if (i < 8) {
      this.modules[i + 1][8] = mod;
    } else {
      this.modules[this.moduleCount - 15 + i][8] = mod;
    }
  }
  for (var i = 0; i < 15; i++) {
    var mod = !test && (bits >> i & 1) == 1;
    if (i < 8) {
      this.modules[8][this.moduleCount - i - 1] = mod;
    } else if (i < 9) {
      this.modules[8][15 - i - 1 + 1] = mod;
    } else {
      this.modules[8][15 - i - 1] = mod;
    }
  }
  this.modules[this.moduleCount - 8][8] = !test;
};
proto.mapData = function(data, maskPattern) {
  var inc = -1;
  var row = this.moduleCount - 1;
  var bitIndex = 7;
  var byteIndex = 0;
  for (var col = this.moduleCount - 1; col > 0; col -= 2) {
    if (col == 6)
      col--;
    while (true) {
      for (var c2 = 0; c2 < 2; c2++) {
        if (this.modules[row][col - c2] == null) {
          var dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) == 1;
          }
          var mask = util.getMask(maskPattern, row, col - c2);
          if (mask) {
            dark = !dark;
          }
          this.modules[row][col - c2] = dark;
          bitIndex--;
          if (bitIndex == -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || this.moduleCount <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
};
QRCode$1.PAD0 = 236;
QRCode$1.PAD1 = 17;
QRCode$1.createData = function(typeNumber, errorCorrectLevel, dataList) {
  var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
  var buffer = new BitBuffer();
  for (var i = 0; i < dataList.length; i++) {
    var data = dataList[i];
    buffer.put(data.mode, 4);
    buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber));
    data.write(buffer);
  }
  var totalDataCount = 0;
  for (var i = 0; i < rsBlocks.length; i++) {
    totalDataCount += rsBlocks[i].dataCount;
  }
  if (buffer.getLengthInBits() > totalDataCount * 8) {
    throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
  }
  if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
    buffer.put(0, 4);
  }
  while (buffer.getLengthInBits() % 8 != 0) {
    buffer.putBit(false);
  }
  while (true) {
    if (buffer.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer.put(QRCode$1.PAD0, 8);
    if (buffer.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer.put(QRCode$1.PAD1, 8);
  }
  return QRCode$1.createBytes(buffer, rsBlocks);
};
QRCode$1.createBytes = function(buffer, rsBlocks) {
  var offset = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;
  var dcdata = new Array(rsBlocks.length);
  var ecdata = new Array(rsBlocks.length);
  for (var r2 = 0; r2 < rsBlocks.length; r2++) {
    var dcCount = rsBlocks[r2].dataCount;
    var ecCount = rsBlocks[r2].totalCount - dcCount;
    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);
    dcdata[r2] = new Array(dcCount);
    for (var i = 0; i < dcdata[r2].length; i++) {
      dcdata[r2][i] = 255 & buffer.buffer[i + offset];
    }
    offset += dcCount;
    var rsPoly = util.getErrorCorrectPolynomial(ecCount);
    var rawPoly = new Polynomial(dcdata[r2], rsPoly.getLength() - 1);
    var modPoly = rawPoly.mod(rsPoly);
    ecdata[r2] = new Array(rsPoly.getLength() - 1);
    for (var i = 0; i < ecdata[r2].length; i++) {
      var modIndex = i + modPoly.getLength() - ecdata[r2].length;
      ecdata[r2][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
    }
  }
  var totalCodeCount = 0;
  for (var i = 0; i < rsBlocks.length; i++) {
    totalCodeCount += rsBlocks[i].totalCount;
  }
  var data = new Array(totalCodeCount);
  var index2 = 0;
  for (var i = 0; i < maxDcCount; i++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i < dcdata[r2].length) {
        data[index2++] = dcdata[r2][i];
      }
    }
  }
  for (var i = 0; i < maxEcCount; i++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i < ecdata[r2].length) {
        data[index2++] = ecdata[r2][i];
      }
    }
  }
  return data;
};
var QRCode_1 = QRCode$1;
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(source, true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var React = reactExports;
var QRCodeImpl = QRCode_1;
var ErrorCorrectLevel = ErrorCorrectLevel$1;
function convertStr(str) {
  var out = "";
  for (var i = 0; i < str.length; i++) {
    var charcode = str.charCodeAt(i);
    if (charcode < 128) {
      out += String.fromCharCode(charcode);
    } else if (charcode < 2048) {
      out += String.fromCharCode(192 | charcode >> 6);
      out += String.fromCharCode(128 | charcode & 63);
    } else if (charcode < 55296 || charcode >= 57344) {
      out += String.fromCharCode(224 | charcode >> 12);
      out += String.fromCharCode(128 | charcode >> 6 & 63);
      out += String.fromCharCode(128 | charcode & 63);
    } else {
      i++;
      charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
      out += String.fromCharCode(240 | charcode >> 18);
      out += String.fromCharCode(128 | charcode >> 12 & 63);
      out += String.fromCharCode(128 | charcode >> 6 & 63);
      out += String.fromCharCode(128 | charcode & 63);
    }
  }
  return out;
}
var DEFAULT_PROPS = {
  size: 128,
  level: "L",
  bgColor: "#FFFFFF",
  fgColor: "#000000",
  includeMargin: false
};
var MARGIN_SIZE = 4;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules) {
  var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var ops = [];
  modules.forEach(function(row, y2) {
    var start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push("M".concat(start + margin, " ").concat(y2 + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push("M".concat(x + margin, ",").concat(y2 + margin, " h1v1H").concat(x + margin, "z"));
        } else {
          ops.push("M".concat(start + margin, ",").concat(y2 + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map(function(row, y2) {
    if (y2 < excavation.y || y2 >= excavation.y + excavation.h) {
      return row;
    }
    return row.map(function(cell, x) {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(props, cells) {
  var imageSettings = props.imageSettings, size = props.size, includeMargin = props.includeMargin;
  if (imageSettings == null) {
    return null;
  }
  var margin = includeMargin ? MARGIN_SIZE : 0;
  var numCells = cells.length + margin * 2;
  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  var scale = numCells / size;
  var w2 = (imageSettings.width || defaultSize) * scale;
  var h2 = (imageSettings.height || defaultSize) * scale;
  var x = imageSettings.x == null ? cells.length / 2 - w2 / 2 : imageSettings.x * scale;
  var y2 = imageSettings.y == null ? cells.length / 2 - h2 / 2 : imageSettings.y * scale;
  var excavation = null;
  if (imageSettings.excavate) {
    var floorX = Math.floor(x);
    var floorY = Math.floor(y2);
    var ceilW = Math.ceil(w2 + x - floorX);
    var ceilH = Math.ceil(h2 + y2 - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }
  return {
    x,
    y: y2,
    h: h2,
    w: w2,
    excavation
  };
}
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e2) {
    return false;
  }
  return true;
}();
var QRCodeCanvas = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(QRCodeCanvas2, _React$PureComponent);
  function QRCodeCanvas2() {
    var _getPrototypeOf2;
    var _this;
    _classCallCheck(this, QRCodeCanvas2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(QRCodeCanvas2)).call.apply(_getPrototypeOf2, [this].concat(args)));
    _defineProperty(_assertThisInitialized(_this), "_canvas", void 0);
    _defineProperty(_assertThisInitialized(_this), "_image", void 0);
    _defineProperty(_assertThisInitialized(_this), "state", {
      imgLoaded: false
    });
    _defineProperty(_assertThisInitialized(_this), "handleImageLoad", function() {
      _this.setState({
        imgLoaded: true
      });
    });
    return _this;
  }
  _createClass(QRCodeCanvas2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._image && this._image.complete) {
        this.handleImageLoad();
      }
      this.update();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this$props$imageSett, _nextProps$imageSetti;
      var currentSrc = (_this$props$imageSett = this.props.imageSettings) === null || _this$props$imageSett === void 0 ? void 0 : _this$props$imageSett.src;
      var nextSrc = (_nextProps$imageSetti = nextProps.imageSettings) === null || _nextProps$imageSetti === void 0 ? void 0 : _nextProps$imageSetti.src;
      if (currentSrc !== nextSrc) {
        this.setState({
          imgLoaded: false
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.update();
    }
  }, {
    key: "update",
    value: function update4() {
      var _this$props = this.props, value = _this$props.value, size = _this$props.size, level = _this$props.level, bgColor = _this$props.bgColor, fgColor = _this$props.fgColor, includeMargin = _this$props.includeMargin, imageSettings = _this$props.imageSettings;
      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();
      if (this._canvas != null) {
        var canvas = this._canvas;
        var ctx = canvas.getContext("2d");
        if (!ctx) {
          return;
        }
        var cells = qrcode.modules;
        if (cells === null) {
          return;
        }
        var margin = includeMargin ? MARGIN_SIZE : 0;
        var numCells = cells.length + margin * 2;
        var calculatedImageSettings = getImageSettings(this.props, cells);
        if (imageSettings != null && calculatedImageSettings != null) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }
        }
        var pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        var scale = size / numCells * pixelRatio;
        ctx.scale(scale, scale);
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;
        if (SUPPORTS_PATH2D) {
          ctx.fill(new Path2D(generatePath(cells, margin)));
        } else {
          cells.forEach(function(row, rdx) {
            row.forEach(function(cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }
        if (this.state.imgLoaded && this._image && calculatedImageSettings != null) {
          ctx.drawImage(this._image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props2 = this.props;
      _this$props2.value;
      var size = _this$props2.size;
      _this$props2.level;
      _this$props2.bgColor;
      _this$props2.fgColor;
      var style = _this$props2.style;
      _this$props2.includeMargin;
      var imageSettings = _this$props2.imageSettings, otherProps = _objectWithoutProperties(_this$props2, ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"]);
      var canvasStyle = _objectSpread({
        height: size,
        width: size
      }, style);
      var img = null;
      var imgSrc = imageSettings && imageSettings.src;
      if (imageSettings != null && imgSrc != null) {
        img = React.createElement("img", {
          src: imgSrc,
          style: {
            display: "none"
          },
          onLoad: this.handleImageLoad,
          ref: function ref(_ref) {
            return _this2._image = _ref;
          }
        });
      }
      return React.createElement(React.Fragment, null, React.createElement("canvas", _extends({
        style: canvasStyle,
        height: size,
        width: size,
        ref: function ref(_ref2) {
          return _this2._canvas = _ref2;
        }
      }, otherProps)), img);
    }
  }]);
  return QRCodeCanvas2;
}(React.PureComponent);
_defineProperty(QRCodeCanvas, "defaultProps", DEFAULT_PROPS);
var QRCodeSVG = /* @__PURE__ */ function(_React$PureComponent2) {
  _inherits(QRCodeSVG2, _React$PureComponent2);
  function QRCodeSVG2() {
    _classCallCheck(this, QRCodeSVG2);
    return _possibleConstructorReturn(this, _getPrototypeOf(QRCodeSVG2).apply(this, arguments));
  }
  _createClass(QRCodeSVG2, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props, value = _this$props3.value, size = _this$props3.size, level = _this$props3.level, bgColor = _this$props3.bgColor, fgColor = _this$props3.fgColor, includeMargin = _this$props3.includeMargin, imageSettings = _this$props3.imageSettings, otherProps = _objectWithoutProperties(_this$props3, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]);
      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();
      var cells = qrcode.modules;
      if (cells === null) {
        return null;
      }
      var margin = includeMargin ? MARGIN_SIZE : 0;
      var numCells = cells.length + margin * 2;
      var calculatedImageSettings = getImageSettings(this.props, cells);
      var image = null;
      if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }
        image = React.createElement("image", {
          xlinkHref: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none"
        });
      }
      var fgPath = generatePath(cells, margin);
      return React.createElement("svg", _extends({
        shapeRendering: "crispEdges",
        height: size,
        width: size,
        viewBox: "0 0 ".concat(numCells, " ").concat(numCells)
      }, otherProps), React.createElement("path", {
        fill: bgColor,
        d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")
      }), React.createElement("path", {
        fill: fgColor,
        d: fgPath
      }), image);
    }
  }]);
  return QRCodeSVG2;
}(React.PureComponent);
_defineProperty(QRCodeSVG, "defaultProps", DEFAULT_PROPS);
var QRCode = function QRCode2(props) {
  var renderAs = props.renderAs, otherProps = _objectWithoutProperties(props, ["renderAs"]);
  var Component = renderAs === "svg" ? QRCodeSVG : QRCodeCanvas;
  return React.createElement(Component, otherProps);
};
QRCode.defaultProps = _objectSpread({
  renderAs: "canvas"
}, DEFAULT_PROPS);
var lib = QRCode;
const Mr = /* @__PURE__ */ getDefaultExportFromCjs(lib);
const SvgEa285Cf2Cf54Ed10 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 .001h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#2557d6" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m.253 235.69h37.441l8.442-19.51h18.9l8.42 19.51h73.668v-14.915l6.576 14.98h38.243l6.576-15.202v15.138h183.08l-.085-32.026h3.542c2.479.083 3.204.302 3.204 4.226v27.8h94.689v-7.455c7.639 3.92 19.518 7.455 35.148 7.455h39.836l8.525-19.51h18.9l8.337 19.51h76.765v-18.532l11.626 18.532h61.515v-122.51h-60.88v14.468l-8.522-14.468h-62.471v14.468l-7.828-14.468h-84.38c-14.123 0-26.539 1.889-36.569 7.153v-7.153h-58.229v7.153c-6.383-5.426-15.079-7.153-24.75-7.153h-212.74l-14.274 31.641-14.659-31.641h-67.005v14.468l-7.362-14.468h-57.145l-26.539 58.246v64.261h.003zm236.34-17.67h-22.464l-.083-68.794-31.775 68.793h-19.24l-31.858-68.854v68.854h-44.57l-8.42-19.592h-45.627l-8.505 19.592h-23.801l39.241-87.837h32.559l37.269 83.164v-83.164h35.766l28.678 59.587 26.344-59.587h36.485zm-165.9-37.823-14.998-35.017-14.915 35.017zm255.3 37.821h-73.203v-87.837h73.203v18.291h-51.289v15.833h50.06v18.005h-50.061v17.542h51.289zm103.16-64.18c0 14.004-9.755 21.24-15.439 23.412 4.794 1.748 8.891 4.838 10.84 7.397 3.094 4.369 3.628 8.271 3.628 16.116v17.255h-22.104l-.083-11.077c0-5.285.528-12.886-3.458-17.112-3.202-3.09-8.083-3.76-15.973-3.76h-23.523v31.95h-21.914v-87.838h50.401c11.199 0 19.451.283 26.535 4.207 6.933 3.924 11.09 9.652 11.09 19.45zm-27.699 13.042c-3.013 1.752-6.573 1.81-10.841 1.81h-26.62v-19.51h26.982c3.818 0 7.804.164 10.393 1.584 2.842 1.28 4.601 4.003 4.601 7.765 0 3.84-1.674 6.929-4.515 8.351zm62.844 51.138h-22.358v-87.837h22.358zm259.56 0h-31.053l-41.535-65.927v65.927h-44.628l-8.527-19.592h-45.521l-8.271 19.592h-25.648c-10.649 0-24.138-2.257-31.773-9.715-7.701-7.458-11.708-17.56-11.708-33.533 0-13.027 2.395-24.936 11.812-34.347 7.085-7.01 18.18-10.242 33.28-10.242h21.215v18.821h-20.771c-7.997 0-12.514 1.14-16.862 5.203-3.735 3.699-6.298 10.69-6.298 19.897 0 9.41 1.951 16.196 6.023 20.628 3.373 3.476 9.506 4.53 15.272 4.53h9.842l30.884-69.076h32.835l37.102 83.081v-83.08h33.366l38.519 61.174v-61.174h22.445zm-133.2-37.82-15.165-35.017-15.081 35.017zm189.04 178.08c-5.322 7.457-15.694 11.238-29.736 11.238h-42.319v-18.84h42.147c4.181 0 7.106-.527 8.868-2.175 1.665-1.474 2.605-3.554 2.591-5.729 0-2.561-1.064-4.593-2.677-5.811-1.59-1.342-3.904-1.95-7.722-1.95-20.574-.67-46.244.608-46.244-27.194 0-12.742 8.443-26.156 31.439-26.156h43.649v-17.479h-40.557c-12.237 0-21.129 2.81-27.425 7.174v-7.175h-59.985c-9.595 0-20.854 2.279-26.179 7.175v-7.175h-107.12v7.175c-8.524-5.892-22.908-7.175-29.549-7.175h-70.656v7.175c-6.745-6.258-21.742-7.175-30.886-7.175h-79.077l-18.094 18.764-16.949-18.764h-118.13v122.59h115.9l18.646-19.062 17.565 19.062 71.442.061v-28.838h7.021c9.479.14 20.66-.228 30.523-4.312v33.085h58.928v-31.952h2.842c3.628 0 3.985.144 3.985 3.615v28.333h179.01c11.364 0 23.244-2.786 29.824-7.845v7.845h56.78c11.815 0 23.354-1.587 32.134-5.649l.002-22.84zm-354.94-47.155c0 24.406-19.005 29.445-38.159 29.445h-27.343v29.469h-42.591l-26.984-29.086-28.042 29.086h-86.802v-87.859h88.135l26.961 28.799 27.875-28.799h70.021c17.389 0 36.929 4.613 36.929 28.945zm-174.22 40.434h-53.878v-17.48h48.11v-17.926h-48.11v-15.974h54.939l23.969 25.604zm86.81 10.06-33.644-35.789 33.644-34.65zm49.757-39.066h-28.318v-22.374h28.572c7.912 0 13.404 3.09 13.404 10.772 0 7.599-5.238 11.602-13.658 11.602zm148.36-40.373h73.138v18.17h-51.315v15.973h50.062v17.926h-50.062v17.48l51.314.08v18.23h-73.139zm-28.119 47.029c4.878 1.725 8.865 4.816 10.734 7.375 3.095 4.291 3.542 8.294 3.631 16.037v17.418h-22.002v-10.992c0-5.286.531-13.112-3.542-17.198-3.201-3.147-8.083-3.899-16.076-3.899h-23.42v32.09h-22.02v-87.859h50.594c11.093 0 19.173.47 26.366 4.146 6.915 4.004 11.266 9.487 11.266 19.511-.001 14.022-9.764 21.178-15.531 23.371zm-12.385-11.107c-2.932 1.667-6.556 1.811-10.818 1.811h-26.622v-19.732h26.982c3.902 0 7.807.08 10.458 1.587 2.84 1.423 4.538 4.146 4.538 7.903 0 3.758-1.699 6.786-4.538 8.431zm197.82 5.597c4.27 4.229 6.554 9.571 6.554 18.613 0 18.9-12.322 27.723-34.425 27.723h-42.68v-18.84h42.51c4.157 0 7.104-.525 8.95-2.175 1.508-1.358 2.589-3.333 2.589-5.729 0-2.561-1.17-4.592-2.675-5.811-1.675-1.34-3.986-1.949-7.803-1.949-20.493-.67-46.157.609-46.157-27.192 0-12.744 8.355-26.158 31.33-26.158h43.932v18.7h-40.198c-3.984 0-6.575.145-8.779 1.587-2.4 1.422-3.29 3.534-3.29 6.319 0 3.314 2.037 5.57 4.795 6.546 2.311.77 4.795.995 8.526.995l11.797.306c11.895.276 20.061 2.248 25.024 7.065zm86.955-23.52h-39.938c-3.986 0-6.638.144-8.867 1.587-2.312 1.423-3.202 3.534-3.202 6.322 0 3.314 1.951 5.568 4.791 6.544 2.312.771 4.795.996 8.444.996l11.878.304c11.983.284 19.982 2.258 24.86 7.072.891.67 1.422 1.422 2.033 2.175v-25z", fill: "#fff" }));
const Svg4Bda20Dc465Fd5E8 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#0079be" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m599.93 251.45c0-99.415-82.98-168.13-173.9-168.1h-78.242c-92.003-.033-167.73 68.705-167.73 168.1 0 90.93 75.727 165.64 167.73 165.2h78.242c90.914.436 173.9-74.294 173.9-165.2z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m348.28 97.43c-84.07.027-152.19 68.308-152.21 152.58.02 84.258 68.144 152.53 152.21 152.56 84.09-.027 152.23-68.303 152.24-152.56-.011-84.272-68.149-152.55-152.24-152.58z", fill: "#0079be" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m252.07 249.6c.08-41.181 25.746-76.297 61.94-90.25v180.48c-36.194-13.948-61.861-49.045-61.94-90.23zm131 90.274v-180.53c36.207 13.92 61.914 49.057 61.979 90.257-.065 41.212-25.772 76.322-61.979 90.269z", fill: "#fff" }));
const Svg96E6C7C43A915C12 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("g", { fillRule: "evenodd" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m54.992 0c-30.365 0-54.992 24.63-54.992 55.004v390.992c0 30.38 24.619 55.004 54.992 55.004h670.016c30.365 0 54.992-24.63 54.992-55.004v-390.992c0-30.38-24.619-55.004-54.992-55.004z", fill: "#4d4d4d" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m327.152 161.893c8.837 0 16.248 1.784 25.268 6.09v22.751c-8.544-7.863-15.955-11.154-25.756-11.154-19.264 0-34.414 15.015-34.414 34.05 0 20.075 14.681 34.196 35.37 34.196 9.312 0 16.586-3.12 24.8-10.857v22.763c-9.341 4.14-16.911 5.776-25.756 5.776-31.278 0-55.582-22.596-55.582-51.737 0-28.826 24.951-51.878 56.07-51.878zm-97.113.627c11.546 0 22.11 3.72 30.943 10.994l-10.748 13.248c-5.35-5.646-10.41-8.028-16.564-8.028-8.853 0-15.3 4.745-15.3 10.989 0 5.354 3.619 8.188 15.944 12.482 23.365 8.044 30.29 15.176 30.29 30.926 0 19.193-14.976 32.553-36.32 32.553-15.63 0-26.994-5.795-36.458-18.872l13.268-12.03c4.73 8.61 12.622 13.222 22.42 13.222 9.163 0 15.947-5.952 15.947-13.984 0-4.164-2.055-7.734-6.158-10.258-2.066-1.195-6.158-2.977-14.2-5.647-19.291-6.538-25.91-13.527-25.91-27.185 0-16.225 14.214-28.41 32.846-28.41zm234.723 1.728h22.437l28.084 66.592 28.446-66.592h22.267l-45.494 101.686h-11.053zm-397.348.152h30.15c33.312 0 56.534 20.382 56.534 49.641 0 14.59-7.104 28.696-19.118 38.057-10.108 7.901-21.626 11.445-37.574 11.445h-29.992zm96.135 0h20.54v99.143h-20.54zm411.734 0h58.252v16.8h-37.725v22.005h36.336v16.791h-36.336v26.762h37.726v16.785h-58.252v-99.143zm71.858 0h30.455c23.69 0 37.265 10.71 37.265 29.272 0 15.18-8.514 25.14-23.986 28.105l33.148 41.766h-25.26l-28.429-39.828h-2.678v39.828h-20.515zm20.515 15.616v30.025h6.002c13.117 0 20.069-5.362 20.069-15.328 0-9.648-6.954-14.697-19.745-14.697zm-579.716 1.183v65.559h5.512c13.273 0 21.656-2.394 28.11-7.88 7.103-5.955 11.376-15.465 11.376-24.98 0-9.499-4.273-18.725-11.376-24.681-6.785-5.78-14.837-8.018-28.11-8.018z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m415.13 161.21c30.941 0 56.022 23.58 56.022 52.709v.033c0 29.13-25.081 52.742-56.021 52.742s-56.022-23.613-56.022-52.742v-.033c0-29.13 25.082-52.71 56.022-52.71zm364.85 127.15c-26.05 18.33-221.08 149.34-558.75 212.62h503.76c30.365 0 54.992-24.63 54.992-55.004v-157.62z", fill: "#f47216" })));
const Svg4Cd29C4C3E16Daa4 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m41.68 0h698.14c23.027 0 41.68 18.983 41.68 42.42v414.66c0 23.437-18.652 42.42-41.68 42.42h-698.14c-23.028 0-41.68-18.983-41.68-42.42v-414.66c0-23.437 18.652-42.42 41.68-42.42z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m167.25 181.4c6.8-2.3 14.1-3.5 21.7-3.5 33.2 0 60.9 23.601 67.2 54.9l47-9.6c-10.8-53.2-57.8-93.301-114.2-93.301-12.9 0-25.3 2.101-36.9 6z", fill: "#fff100" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m111.75 333.8 31.8-36c-14.2-12.6-23.1-30.9-23.1-51.4 0-20.399 8.9-38.8 23.1-51.3l-31.8-35.899c-24.1 21.399-39.3 52.5-39.3 87.3 0 34.699 15.2 65.898 39.3 87.299z", fill: "#00a3df" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m256.15 260.2c-6.4 31.3-34 54.8-67.2 54.8-7.6 0-14.9-1.2-21.8-3.5l-15.2 45.5c11.6 3.899 24.1 6 37 6 56.4 0 103.4-40 114.2-93.2z", fill: "#ee4023" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m459.75 292.4c-7.8 7.601-18.3 12.2-29.9 12-8-.1-15.399-2.5-21.6-6.5l-15.601 24.801c10.7 6.699 23.2 10.699 36.801 10.899 19.699.3 37.699-7.5 50.8-20.2zm-28.2-101.1c-39.2-.6-71.6 30.8-72.2 70-.2 14.7 4 28.5 11.5 39.9l128.8-55.101c-7.2-30.899-34.8-54.2-68.1-54.799m-42.7 75.599c-.2-1.6-.3-3.3-.3-5 .4-23.1 19.4-41.6 42.5-41.199 12.6.199 23.8 5.899 31.3 14.899zm151.3-107.6v137.3l23.801 9.9-11.301 27.1-23.6-9.8c-5.3-2.3-8.9-5.8-11.6-9.8-2.601-4-4.601-9.601-4.601-17v-137.7zm85.901 63.5c4.2-1.4 8.6-2.1 13.3-2.1 20.3 0 37.101 14.399 41 33.5l28.7-5.9c-6.6-32.5-35.3-56.9-69.7-56.9-7.899 0-15.5 1.301-22.5 3.601zm-33.901 92.9 19.4-21.9c-8.7-7.7-14.1-18.9-14.1-31.4s5.5-23.699 14.1-31.3l-19.4-21.899c-14.699 13-24 32.1-24 53.3s9.301 40.199 24 53.199zm88.201-44.801c-3.899 19.101-20.8 33.5-41 33.5-4.6 0-9.1-.8-13.3-2.199l-9.3 27.8c7.1 2.399 14.7 3.7 22.6 3.7 34.4 0 63.101-24.4 69.7-56.9z", fill: "#fff" }));
const SvgAcb05338A032C728 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M39.756-14C10.72-14-13.5 9.393-13.5 38.31v391.756c0 28.917 24.22 52.311 53.256 52.311H709.24c29.037 0 53.26-23.394 53.26-52.31V38.31C762.5 9.394 738.277-14 709.24-14H39.756zm0 30H709.24c13.227 0 23.26 10.018 23.26 22.31v11.188h-716V38.311C16.5 26.018 26.534 16 39.756 16zM16.5 144.64h716v285.426c0 12.293-10.033 22.311-23.26 22.311H39.756c-13.221 0-23.256-10.02-23.256-22.31V144.64z", transform: "translate(15 15)" }));
const SvgDf6706Eae6F7E6B2 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", viewBox: "0 0 780 500", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m724.3 0h-668.6c-30.3 0-54.9 24.6-54.9 54.9v390.2c0 30.3 24.6 54.9 54.9 54.9h668.7c30.3 0 54.9-24.6 54.9-54.9v-390.2c-.1-30.3-24.7-54.9-55-54.9z", fill: "#f37421" }), /* @__PURE__ */ reactExports.createElement("g", { fill: "#fff" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m100 139.9v175h39.7v-73.2h65.2v73.2h39.5v-175h-39.5v67.3h-65.2v-67.3z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m586.2 264c.5-2.9 1.3-8.8 1.3-15.6 0-31.4-15.6-63.4-56.6-63.4-44.1 0-64.1 35.6-64.1 67.8 0 39.7 24.7 64.7 67.8 64.7 17.1 0 33-2.6 46-7.8l-5.2-26.7c-10.6 3.4-21.6 5.2-35.1 5.2-18.4 0-34.5-7.8-35.8-24.1h81.7zm-82.1-27c1-10.6 7.8-25.7 24.4-25.7 18.2 0 22.3 16.1 22.3 25.7z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m600.1 314.9h39.5v-64.4c0-3.1.3-6.2.8-8.8 2.6-12.2 12.5-20 27-20 4.4 0 7.8.5 10.6 1v-37.1c-2.9-.5-4.7-.5-8.3-.5-12.2 0-27.8 7.8-34.3 26.2h-1l-1.3-23.4h-34c.5 10.9 1 23.1 1 41.8z" })), /* @__PURE__ */ reactExports.createElement("path", { clipRule: "evenodd", d: "m284.5 132.9c11.2 0 20.3 9.1 20.3 20.3s-9.1 20.3-20.3 20.3-20.3-9.1-20.3-20.3 9.1-20.3 20.3-20.3z", fill: "#ffe700", fillRule: "evenodd" }), /* @__PURE__ */ reactExports.createElement("path", { clipRule: "evenodd", d: "m367.9 285.3h19.8c19.9 0 28.9-12.7 28.9-26s-1-43.3-25.5-43.3c-28.2 0-23.7 37.3-23.5 56.8-.1 4.2.2 8.4.3 12.5zm-103.7-97.5h40.6v71.6c0 13.3 7.4 26 23.7 26 .1-32.2 0-65.4-1.1-97.6h33.9c.7 6.2 1.4 12.4 2 18.6 16-32 66.5-25 83.5 2.1 17.5 27.9 23.5 107.9-59.1 107.9h-19.2c.2 16.2.2 32.5.2 48.8h-40.6c0-15.6.1-32 .2-48.8-43.9-.2-64.1-28-64.1-57z", fill: "#fff", fillRule: "evenodd" }));
const SvgC919F85Dd32Ab2Ca = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 471, viewBox: "0 0 750 471", width: 750, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("g", { fill: "none" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m697.115385 0h-644.2307696c-29.1605769 0-52.8846154 23.1955749-52.8846154 51.7065868v367.5868262c0 28.511012 23.7240385 51.706587 52.8846154 51.706587h644.2307696c29.158653 0 52.884615-23.195575 52.884615-51.706587v-367.5868262c0-28.5110119-23.725962-51.7065868-52.884615-51.7065868z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m321.004048 378.440089-274.004048.098495v-.659826c0-.362427.4370157-2.713896.9706147-5.226019.5345553-2.511167 1.3645982-6.506466 1.8465586-8.877061.4800478-2.371551 1.3024406-6.400319 1.8255206-8.954518.5240363-2.552286 1.3951988-6.805778 1.9354918-9.450822.5393366-2.644089 1.3846798-6.822991 1.8790717-9.284432.4943919-2.463353 1.317741-6.493077 1.8322146-8.954518.5135173-2.462397 1.3904175-6.714932 1.9479232-9.450823.5565495-2.73589 1.402849-6.914793 1.8809844-9.286344.4781353-2.371551 1.2374141-6.027373 1.6878176-8.123519.4494472-2.098057 1.0241659-4.9334 1.2747088-6.301823.2514991-1.367467 1.0652854-5.397192 1.8083077-8.953562s1.56159-7.586095 1.8216956-8.953562c.2591493-1.368423 1.0824983-5.398148 1.8303019-8.954518.7468474-3.555414 1.5673276-7.585139 1.8236081-8.953562.2562806-1.367467 1.0815421-5.397191 1.8331708-8.953562.7535413-3.557327 1.5663713-7.511506 1.805439-8.788127.2409802-1.276621.8988944-4.559498 1.463094-7.295389.5632434-2.73589 1.6304415-7.884451 2.3705949-11.440821.7411098-3.557327 2.0072121-9.750136 2.8133482-13.763603.8080487-4.012512 1.7729258-8.787171 2.144915-10.610779.371033-1.823608 1.0432913-5.107442 1.4936947-7.296345.4504035-2.188904 1.2670586-6.143083 1.815958-8.787171.5488993-2.646001 1.4410998-6.973125 1.9833053-9.61817.5431617-2.644088 1.3789422-6.748402 1.8580338-9.118997.4790916-2.371551 1.296703-6.32573 1.8169142-8.788127s1.4152805-6.790478 1.9890429-9.617213c.5737624-2.827693 1.5348143-7.154817 2.1353523-9.617214.6005379-2.462397 1.4497063-5.446918 1.8876782-6.631737.4370157-1.186732 1.6447854-3.755275 2.6832954-5.711804l1.888634-3.554458 1.716506-2.249149c.942883-1.235502 2.628788-3.189162 3.744756-4.340512s2.997908-2.884112 4.18464-3.849946c1.18482-.966789 2.901325-2.271143 3.812651-2.898456.912282-.627314 2.703377-1.726069 3.979999-2.441359 1.276621-.71529 3.068672-1.651479 3.979998-2.080845.912282-.429365 2.777966-1.2144636 4.145433-1.7432813 1.367467-.5278613 3.979042-1.4143242 5.80265-1.9680049 1.823608-.554637 5.248014-1.3904175 7.609046-1.8561213 2.361032-.4666601 6.090487-1.0901485 8.290866-1.3856361l3.998168-.5374241 274.169483-.1032773 274.168526-.106146v.6598267c0 .3624266-.439884 2.7138961-.976352 5.2250627-.53838 2.5111666-1.436319 6.8048216-1.996693 9.5407126-.561331 2.73589-1.377986 6.691025-1.817871 8.788127-.438928 2.098057-1.270883 6.126825-1.848471 8.953561-.576631 2.827693-1.465006 7.155774-1.972786 9.617214-.50778 2.462397-1.331129 6.492121-1.82839 8.953562-.49726 2.463353-1.325391 6.492121-1.838908 8.954518-.51543 2.462397-1.311047 6.342943-1.771969 8.622692-.460923 2.27975-1.293835 6.383107-1.85134 9.118997-.558462 2.73589-1.454488 7.063971-1.991912 9.617214-.53838 2.553242-1.355992 6.508378-1.818827 8.788127-.464747 2.279749-1.297659 6.383106-1.853252 9.118997-.55655 2.73589-1.450663 7.063971-1.988087 9.61817-.537424 2.553242-1.337823 6.432832-1.77962 8.621736-.44084 2.187947-1.271839 6.29226-1.845602 9.118996-.574719 2.826736-1.409543 6.93105-1.85899 9.12091-.449447 2.187947-1.249846 6.068493-1.77962 8.620779-.531686 2.554199-1.439187 6.956869-2.015818 9.783605-.5795 2.827692-1.406674 6.855504-1.838908 8.954518-.434147 2.096145-1.244109 6.051281-1.802571 8.786215-.557505 2.737803-1.444925 7.063971-1.972786 9.61817-.526905 2.553242-1.353123 6.582967-1.836996 8.954518-.48196 2.370595-1.322522 6.474908-1.864728 9.118997-.544118 2.644088-1.431537 6.972169-1.972786 9.616257-.541249 2.645045-1.352167 6.60018-1.80257 8.789083-.450403 2.187948-1.272796 6.217672-1.828389 8.953562-.555594 2.735891-1.460226 7.047715-2.009125 9.580876l-.998347 4.606355-1.1896 3.186294c-.654089 1.752844-1.638092 4.082319-2.186991 5.177249-.546987 1.093018-1.662955 3.024684-2.478654 4.290787-.816655 1.265146-1.954617 2.886024-2.528379 3.602271-.573763.716247-2.301744 2.565674-3.841339 4.111007l-2.795179 2.806655-2.691902 1.912541c-1.480307 1.051898-3.075366 2.121965-3.542983 2.377289-.468572.255324-2.252017 1.16665-3.963742 2.022512-1.710768.857775-4.129176 1.947923-5.371372 2.42319-1.243151.477179-3.705548 1.28714-5.47178 1.800658-1.766232.515429-3.659648 1.022253-4.206635 1.126486-.547943.10519-2.44614.497261-4.220978.874032-1.773882.375814-5.355116.937145-7.958084 1.246977l-4.73354.563243zm-97.486053-70.873998h7.129954l.200817-.524993c.111884-.288793.201773-.966789.201773-1.507082 0-.541249.235243-2.505429.52308-4.366332.286881-1.862815.960096-6.145951 1.49752-9.519674.536468-3.374679 1.339735-8.448651 1.785357-11.275387.445622-2.827692.98974-6.44622 1.209682-8.042236.218986-1.596016.485786-2.901325.593844-2.901325.107103 0 .568025.704772 1.024166 1.567328l.828131 1.566371 1.837952 1.853252 1.838908 1.85134 2.262537.906545 2.263492.905588 2.696683.349995 2.69764.349039 3.422492-.209423 3.423449-.21038 3.706505-.959139 3.707461-.960096 1.989043-.906545c1.09493-.500129 3.034247-1.589321 4.310868-2.421277l2.321825-1.511864 2.164041-2.16404c1.190557-1.187688 2.869768-3.096404 3.730411-4.239148.862557-1.141787 1.567328-2.159259 1.567328-2.260624 0-.10232.423628-.809004.94097-1.572108.517343-.762148 1.574978-2.879331 2.35147-4.702939.777448-1.823608 1.989999-5.106486 2.697639-7.295389l1.285228-3.979998.664608-3.4464c.365295-1.895328.835781-5.029027 1.045204-6.964519l.379639-3.516207-.219942-2.98452-.218986-2.984521-.69234-2.985477-.691384-2.984521-1.120749-2.233848-1.119793-2.234804-2.16404-2.294093-2.163084-2.294094-2.559937-1.322522-2.559936-1.322522-2.819086-.676084-2.819086-.67417-2.819086-.206555-2.818129-.206554-3.139437.360514-3.141349.360514-2.561849.655045-2.562805.653133-2.227154 1.031816c-1.224027.565156-3.006515 1.52812-3.958961 2.138221-.953401.610101-1.937404 1.311047-2.186034 1.558721-.247674.247674-.843431.707641-1.321566 1.019385l-.871163.570893.608188-2.913756c.335651-1.601754.614882-3.098317.622533-3.327822l.013387-.414065h-6.080925-6.079012l-1.065285 6.715888c-.587151 3.694074-1.512821 9.401097-2.057895 12.68493-.545074 3.282877-1.368423 8.206715-1.827433 10.942605s-1.278534 7.586095-1.821696 10.778126c-.542205 3.191075-1.438231 8.266004-1.991911 11.275387-.553681 3.009384-1.363642 7.412054-1.801614 9.783605-.437016 2.370595-1.261321 6.846898-1.829346 9.947127-.568025 3.102142-1.482219 8.02598-2.031119 10.944517-.548899 2.917582-1.4411 7.544019-1.983305 10.27991-.543162 2.73589-1.067198 5.311127-1.167606 5.720411l-.180736.746847zm30.696287-38.341671-2.768403.166391-1.809264-.32035-1.81022-.319395-1.837953-.838649-1.838908-.839606-1.283315-1.226895-1.284272-1.224983-.741109-1.658173c-.408328-.912282-.931408-2.461441-1.163782-3.44353l-.422671-1.784401.16926-2.858293.170216-2.857337.853949-4.477259c.469529-2.462397 1.31296-7.088834 1.874291-10.279909.561331-3.192032 1.412412-7.870108 1.889591-10.393706l.867337-4.590099 1.901066-1.581671c1.04616-.86925 2.702421-2.035901 3.681642-2.590538l1.778663-1.009821 2.320869-.71816 2.321825-.719115 2.984521-.174998 2.984521-.174997 2.430839.518299 2.429884.517342 1.71555.789879 1.714593.78988 1.438231 1.445881 1.439187 1.445881.774579 1.53099c.427453.842474 1.027035 2.490128 1.332085 3.662516l.555594 2.131527-.170217 6.301824-.170216 6.300867-.851081 3.724674c-.468572 2.048332-1.359816 5.182031-1.981392 6.963563l-1.129356 3.239845-1.38468 2.622094c-.761191 1.443012-1.934535 3.391892-2.60775 4.331906-.673214.939057-1.747106 2.158303-2.385895 2.705289-.636876.5489-1.706943 1.406674-2.375376 1.904891l-1.21542.907501-2.814305.957227-2.814304.957227zm68.862005 9.116128 3.648172.042076 3.647216-.332782c2.007212-.182648 5.290089-.5642 7.295389-.847256 2.007212-.2821 5.472737-.915151 7.70276-1.404762l4.053631-.8922.202729-1.495607c.110928-.821437.566113-3.267577 1.011735-5.436399l.809961-3.944616-.179779-.177867-.177866-.177866-1.239327.597669c-.681821.328957-2.805698 1.115012-4.718239 1.745194l-3.478913 1.145612-3.651041.708597-3.651041.706684-5.803607.012431-5.803606.009563-1.99-.634964c-1.093973-.349038-2.703377-.987827-3.576452-1.421018l-1.586453-.785098-1.31009-1.183863-1.310091-1.183863-1.022253-1.785357-1.022254-1.78727-.640701-2.239586-.640701-2.240542-.003825-4.146389-.004782-4.147346.568025-3.697899.569937-3.699811 4.98982-.23333 4.98982-.23333 18.447417.119534 18.446461.117621.556549-2.361988c.306963-1.299572.775536-3.985736 1.041379-5.969041l.483873-3.607053.010519-3.033291.010519-3.034246-.524993-2.265405-.525949-2.264449-.86925-1.499433c-.476222-.824305-1.318697-2.019643-1.869509-2.656519-.550812-.63592-1.534814-1.532902-2.186034-1.992868-.652177-.459967-1.930711-1.233589-2.842993-1.718419l-1.658173-.881681-2.896544-.698078-2.8975-.697121-3.568802-.341389-3.570715-.341388-3.31539.216117-3.316346.215161-3.979999.76406-3.979042.765017-2.488216.993565c-1.367467.54603-3.456918 1.544377-4.641738 2.216635-1.185775.672258-2.826736 1.766232-3.647216 2.43084-.822392.665564-2.243411 1.958442-3.158562 2.873593-.916107.916107-2.272099 2.55898-3.011296 3.65391-.740153 1.09493-1.87429 3.034247-2.521685 4.310868-.646439 1.277578-1.488914 3.067716-1.872378 3.979999-.382509.911326-1.07963 2.77701-1.547246 4.144477-.468573 1.368423-1.203945 3.979998-1.634267 5.804562-.431278 1.823608-1.021297 4.825342-1.312959 6.670944l-.528818 3.35651.005738 4.934356.004781 4.934357.503955 2.15639c.276362 1.184819.807092 2.976871 1.177169 3.979042.370076 1.003128 1.056679 2.495867 1.523339 3.316347s1.465006 2.142046 2.216635 2.936707 2.113358 2.000518 3.02564 2.678514c.911326.678952 2.535074 1.634266 3.607053 2.121964l1.949836.88742 2.718677.657914c1.494651.360514 3.75145.788923 5.014684.951489 1.262277.16161 3.936966.313657 5.943222.335651zm6.245403-46.716689c-9.180198 0-16.691704-.065026-16.691704-.146309 0-.079371.392071-1.236458.871163-2.570456.478135-1.333041 1.319653-3.316346 1.867596-4.408407l.999303-1.986174 2.192729-2.181254 2.193684-2.183166 2.156391-1.029903c1.184819-.567069 2.752147-1.184819 3.480825-1.372248.730591-.18743 2.819086-.43606 4.642694-.551769l3.317303-.213248 2.547505.328001 2.545592.327044 1.850384.847256 1.85134.847256 1.015559 1.09493c.557506.601494 1.22307 1.487957 1.478394 1.968961l.462835.875944.306007 1.943142.306963 1.943142-.350952 3.233151-.349995 3.234107zm99.213078 46.718602 3.650085.040163 4.142564-.490567c2.278793-.270624 5.312083-.717203 6.741708-.995478 1.427712-.276362 3.740931-.826217 5.139955-1.220201 1.398067-.395896 2.663213-.823349 2.811435-.949577.148222-.127184.542206-1.632354.877857-3.345034.334694-1.711725.757366-4.008687.938101-5.10266.179779-1.09493.273494-2.048332.207511-2.120052-.066939-.071721-.310788.021038-.543162.204642-.23333.185516-1.859946.870206-3.616615 1.522382l-3.192988 1.185776-4.547067.880725-4.548023.880725-3.865246-.131009-3.866202-.131965-2.196554-.762148-2.196553-.762147-1.696424-1.483176-1.696424-1.485088-1.126487-2.050245-1.124574-2.049288-.537425-2.74354-.535511-2.742584.003825-3.557327.002869-3.558283.65122-4.310868.652177-4.311824.688515-2.321825c.379639-1.276622.809004-2.768404.953401-3.315391.14631-.547943.753542-2.114314 1.352167-3.482737.597669-1.367467 1.664867-3.481781 2.370595-4.698158l1.283315-2.209941 1.57689-1.634267 1.576891-1.634266 1.668692-1.034685 1.670605-1.035641 2.143958-.660783c1.179082-.363383 3.263752-.834824 4.631219-1.047116l2.48726-.388246 3.647216.183604 3.648173.182647 4.310868.863513 4.311824.8616 1.752844.654089c.963921.359557 1.79492.655045 1.847515.655045.050682 0 .2821-1.231676.513517-2.736846.231418-1.504214.642614-3.979999.914195-5.500469.272537-1.522383.429365-2.832474.348082-2.911844-.07937-.080327-1.375117-.285925-2.878374-.457098-1.504214-.171172-5.591315-.475266-9.082659-.677039l-6.34868-.364339-4.477259.343301-4.476303.344257-3.317303.696165-3.31539.697122-2.136309.853949c-1.1743.469529-2.894631 1.317741-3.82317 1.883853-.928539.567069-2.108577 1.32826-2.624963 1.692599-.516386.365296-2.080845 1.788227-3.478912 3.163344l-2.538899 2.499691-1.419105 2.07702c-.779361 1.142743-2.127703 3.523857-2.996953 5.293914l-1.579759 3.216895-1.211595 3.480825c-.665564 1.91541-1.596015 5.049109-2.065544 6.964519l-.855862 3.482737-.310788 3.149956-.309832 3.150911.002869 4.145434.003825 4.144476.3127 2.411715.312701 2.411714.993565 2.480567.992609 2.480566 1.148481 1.793007 1.146568 1.793007 1.823609 1.795877 1.82552 1.79492 1.928798 1.021297 1.93071 1.019384 2.535074.704772c1.393286.386333 3.408148.830999 4.476303.986871 1.068154.155872 3.584102.302181 5.59227.324176zm54.549501-.122403 4.476303-.129097 2.819086-.721028 2.819086-.721984 1.824564-.8616c1.003128-.473354 2.644088-1.409543 3.647216-2.079888 1.003128-.670346 2.557068-1.944099 3.451181-2.830561.894113-.88742 2.22046-2.40024 2.947226-3.362248.726766-.962965 1.365555-1.706943 1.419106-1.652436.054507.053551-.113796 1.586453-.37199 3.407193-.257236 1.821695-.471441 4.243929-.475266 5.383803l-.005738 2.072239h6.085707 6.086662l.186473-4.724933.185516-4.72589.868294-6.135432c.478136-3.374679 1.249846-8.374062 1.71555-11.108996.464747-2.73589 1.272796-7.361371 1.796832-10.280866.52308-2.918538 1.352167-7.46943 1.840821-10.114474l.891244-4.808129.030601-4.153083.028688-4.15404-.938101-1.919235-.940014-1.920191-1.272797-1.222114-1.274708-1.22307-2.089452-1.058592-2.091363-1.060504-3.116486-.693296-3.116486-.693296-4.28983-.326089-4.290787-.326088-5.526288.342345c-3.04094.187429-7.317383.558462-9.506286.825261l-3.979998.481961-2.711984.010519-2.711983.010519-.39494 1.90776c-.217074 1.048072-.82048 3.539157-1.339735 5.536807-.521168 1.996693-.897938 3.677816-.83865 3.737105.058333.059289 1.508995-.270624 3.222632-.731547 1.713637-.461879 5.355116-1.219245 8.091962-1.685905l4.973564-.847256 4.476303-.183604 4.477259-.185516 2.884112.505867 2.884112.505867 1.924017.949577 1.924973.950533 1.077717 1.606535 1.078673 1.605578-.015301 2.532205-.016256 2.53316-.570894 2.778923-.57185 2.779879-11.932344.043032-11.932345.042076-3.904453 1.071023c-2.147784.589062-4.526029 1.371292-5.285308 1.737544-.759279.367207-1.518558.667476-1.687818.667476-.168303 0-1.445881.707641-2.839167 1.574978l-2.532205 1.573065-1.993824 1.990956c-1.097799 1.09493-2.498735 2.736846-3.114574 3.649128-.615838.911326-1.617053 2.816217-2.223329 4.233411l-1.103536 2.575236-.506823 2.895588-.506824 2.896544v3.038071 3.039028l.482917 2.530292.484829 2.529336.896982 1.649567c.494392.906545 1.401893 2.236717 2.014862 2.95392l1.116924 1.304353 1.982349 1.204901 1.983305 1.204901 2.271143.641658c1.24889.352864 3.148999.781273 4.223848.951489l1.952704.307919 4.477259-.12814zm4.145434-9.273913-2.653651.139616-1.75667-.448491c-.965833-.245762-2.432752-.794661-3.25897-1.219245l-1.500388-.77171-.820481-.97444c-.450403-.536468-1.138918-1.588366-1.530033-2.339038l-.710509-1.365555-.138659-3.18725-.140572-3.188206.562287-1.933579c.308876-1.063373 1.034685-2.909932 1.612273-4.101445l1.049985-2.167865 2.011037-1.995737 2.010081-1.996693 2.134396-1.027991 2.134396-1.027035 2.652695-.631138 2.653651-.630183h8.290866 8.290866l.524037.217074.524036.216117-.440841 2.602968c-.242893 1.430581-.821436 4.019206-1.28714 5.751968-.464748 1.733719-1.285228 4.280268-1.823608 5.660166-.538381 1.380855-.979221 2.601056-.979221 2.711984 0 .111883-.545075 1.116924-1.211595 2.234804l-1.210639 2.033988-1.988086 1.970873c-1.093018 1.082499-2.109534 1.968962-2.256799 1.968962-.14631 0-.816655.373902-1.488914.830043l-1.222113.82813-2.68999.851081-2.689033.850124zm107.942872 9.391534 3.149955.040164 2.985477-.48483c1.641917-.265843 3.730412-.695208 4.642694-.953401.911326-.258193 2.554199-.927583 3.647216-1.487958l1.990956-1.019384 1.711724-1.507083 1.710768-1.507082 1.803527-2.403108c.991652-1.322522 1.888634-2.627832 1.99478-2.902281l.192211-.498217-.167348 1.659129c-.091802.911326-.2974 2.404064-.45901 3.316347-.160653.912282-.389202 2.665126-.509692 3.896802l-.219942 2.237674h6.506465 6.504553v-2.237674-2.238629l.990696-8.457258c.545075-4.6513 1.351211-10.843152 1.791095-13.76169.439885-2.919494 1.119793-7.096485 1.510908-9.285388.389202-2.188903 1.080586-6.144039 1.533858-8.788127.455185-2.644088 1.275665-7.271482 1.824564-10.279909.547943-3.01034 1.426756-7.784999 1.951749-10.611735.524036-2.827693 1.340691-7.230363 1.812132-9.783605.471442-2.553243 1.316785-7.030502 1.878116-9.948084.563243-2.918538 1.381811-7.022851 1.822652-9.120909.441797-2.096145.802311-3.925491.801355-4.061281l.000002-.249587h-7.097443-7.097441l-.209423 2.073195c-.114752 1.139874-.65887 4.907581-1.206813 8.374062-.5489 3.464568-1.443969 8.986075-1.989043 12.268952-.545075 3.282877-1.069111 6.467258-1.165694 7.075446l-.177867 1.105449-.559418-.238111c-.307919-.131009-1.978524-.594801-3.71033-1.029904l-3.149955-.790836-4.310868-.33565-4.311825-.335651-3.648172.339476-3.647216.340432-3.316347.838649-3.316346.837693-3.149956 1.536727-3.151868 1.536727-2.320869 1.717462-2.320868 1.718419-2.0053 2.150652c-1.10258 1.181951-2.69477 3.137524-3.540114 4.345294l-1.533858 2.195597-1.803526 3.750494c-.990697 2.063632-2.19751 4.795697-2.680427 6.072318-.483873 1.277578-1.334954 4.107182-1.894372 6.289392l-1.014603 3.968523-.50013 5.152386-.500129 5.150474.374858 4.145433.376771 4.145433.442753 1.491782c.245761.821437.759279 2.283575 1.144656 3.249408l.69999 1.758582 1.276621 1.727024 1.277578 1.728938 1.457356 1.193426 1.457357 1.194382 1.989999.988783c1.09493.542206 2.930013 1.245065 4.07945 1.559678 1.148481.314613 3.014165.693296 4.145434.839605 1.130311.147266 3.472218.285925 5.205937.306963zm5.654428-9.406834-2.504473.131009-1.688774-.304094c-.929495-.166391-2.416496-.615838-3.305827-.996434l-1.615141-.691384-1.359817-1.115011-1.358861-1.113099-1.009822-1.934536-1.009821-1.934535-.461879-2.155434-.45901-2.15639.039207-4.310868.038251-4.310868.534555-3.814564.534556-3.812651.830999-2.652695c.457097-1.459269.833868-2.836298.83578-3.060066.003825-.222811.453273-1.416236 1.003128-2.651738.5489-1.236458 1.465007-3.142305 2.036857-4.237235.571849-1.09493 1.64096-2.799961 2.37442-3.790657.735372-.990696 2.044506-2.483435 2.908975-3.317303.864468-.831955 2.238629-1.925929 3.056241-2.427971l1.484132-.913238 2.60775-.90272 2.606794-.902719 5.47178-.002869h5.471781l3.149955.874987c1.733719.480048 3.573583 1.037554 4.089013 1.238371l.938102.364339-.182648.91037c-.100408.501086-.495348 2.701464-.875944 4.889411-.380596 2.188904-1.132224 6.367807-1.668692 9.286344-.536468 2.918538-1.360773 7.321208-1.832215 9.782649-.470485 2.462397-1.152306 5.596096-1.515689 6.963563-.362426 1.368423-.874987 3.262795-1.137962 4.210459-.262974.947665-.888375 2.590537-1.390417 3.648173-.502042 1.058591-1.380855 2.596275-1.952705 3.416755s-1.537683 1.958442-2.147784 2.526467c-.611057.569937-1.93071 1.579759-2.933838 2.246279l-1.823608 1.212552-2.636438.836736-2.636438.836737zm-488.066184 7.793606h8.05658l.578543-3.564021c.317482-1.961311.939058-5.729974 1.379899-8.374062s1.262277-7.569838 1.823608-10.943561c.562287-3.374679 1.405718-8.374062 1.873334-11.108996.467616-2.73589 1.211595-6.979819 1.651479-9.430741.440841-2.452834.885507-4.541329.986872-4.64365l.186473-.185516h21.666223 21.665267l.240981.240024.24098.24098-.376771 1.914454c-.205598 1.05381-.816655 4.302261-1.356948 7.220799s-1.44875 7.843332-2.019643 10.944517c-.568981 3.10023-1.393287 7.5029-1.830302 9.782649-.437972 2.279749-1.323479 7.054408-1.968005 10.611735-.64357 3.556371-1.169519 6.652775-1.167607 6.881323l.003825.414066h8.09005 8.091006l.357645-2.072239c.197948-1.139874.513517-3.192031.704771-4.559498.189342-1.368423.649308-4.279311 1.019385-6.467258.370077-2.187948 1.109274-6.516985 1.643829-9.617214.533599-3.100229 1.428668-8.397969 1.98713-11.772648s1.386593-8.298516 1.841778-10.942605c.453272-2.646 1.263233-7.122303 1.797788-9.949039.534556-2.827692 1.4258-7.602352 1.980437-10.612692.554637-3.008427 1.383723-7.560275 1.844646-10.114474.460922-2.553243 1.300528-7.17968 1.86664-10.279909.566112-3.10023 1.280447-6.718758 1.587409-8.042236l.558462-2.404065h-8.191414-8.19237l-.222811 1.575934c-.121447.865425-.517343 3.291484-.878813 5.388585-.362427 2.098058-1.018428 5.827514-1.460225 8.28991-.441797 2.463354-1.24889 7.163424-1.793964 10.447257-.545074 3.281921-1.239327 7.628171-1.543421 9.657377l-.552724 3.688336-12.025103.243849-12.02606.242893-10.071442-.239068c-5.539676-.131009-10.102999-.265843-10.14125-.296444-.037294-.032513.151091-1.32061.418847-2.86403.268712-1.543421.775535-4.224804 1.127443-5.95661.351907-1.732763 1.019384-5.164818 1.482219-7.628171.463791-2.461441.987828-5.52055 1.16665-6.797172.177867-1.276621.551768-3.403367.830043-4.726845.278275-1.321566.806136-4.107183 1.173344-6.188984.366252-2.081801.757367-4.022074.86925-4.310868l.200817-.525949h-8.125431-8.126388l-.519255 2.902282c-.286881 1.596015-.668433 3.870983-.848212 5.056759-.180735 1.185775-.786055 4.990776-1.345473 8.456301s-1.385636 8.614086-1.83604 11.440822c-.450403 2.827692-1.268971 7.976253-1.819783 11.440822-.552724 3.466481-1.462137 8.837853-2.023468 11.938082-.560375 3.102142-1.372249 7.503856-1.804483 9.783605-.431278 2.279749-1.252714 6.60783-1.826477 9.617214-.572806 3.010339-1.411455 7.262875-1.859946 9.451778-.449447 2.187948-.945752 4.724934-1.10258 5.63626-.158741.912282-.671302 3.542982-1.141787 5.845682-.469529 2.3027-.85395 4.428489-.85395 4.725889v.538381zm89.199011 0h7.132823l.200817-.524037c.111883-.28975.201773-1.04616.201773-1.681123 0-.636877.449447-3.945573.996434-7.352765.548899-3.407192 1.454487-8.954518 2.013906-12.329197.558462-3.373723 1.383723-8.298517 1.834127-10.943562.450403-2.644088 1.249845-7.045802 1.777707-9.783604.527861-2.734934 1.338779-6.988426 1.801614-9.449867.461878-2.462397 1.372248-7.147166 2.021556-10.410918s1.261321-6.063712 1.359817-6.223409l.180735-.291663-7.21315.088933-7.213149.088934-.60245 4.311824c-.328957 2.371551-1.051898 7.072577-1.604623 10.445344-.551768 3.374679-1.387548 8.524196-1.857077 11.440822-.469529 2.919494-1.286184 7.619564-1.816914 10.447256-.53073 2.826736-1.343561 7.153861-1.807352 9.616258-.462835 2.463353-1.293834 6.790477-1.846558 9.617213-.552725 2.827693-1.293834 6.558104-1.647655 8.290867-.354776 1.733718-.734415 3.486562-.845343 3.896803l-.19986.745891zm166.830974 0h7.080228l.212292-2.995996c.117621-1.646698.517342-4.967826.890288-7.378584.372945-2.410759 1.137005-7.217931 1.696424-10.6825.560374-3.466481 1.600797-9.234705 2.312262-12.819764.713378-3.584102 1.517602-7.147166 1.789183-7.916964.272537-.770754.494391-1.604622.494391-1.854209 0-.250543.532643-1.612272 1.182907-3.026596.650264-1.414325 1.862815-3.579321 2.694771-4.811954l1.511864-2.241499 2.022512-1.87429 2.023469-1.872378 2.49491-1.191513 2.49491-1.19247 3.814563.021038 3.812651.020082 1.875247.559418c1.03086.30792 1.963224.560375 2.072239.560375.109014 0 .197948-.351908.197948-.783186 0-.430321.372945-2.614444.829086-4.854029.455185-2.23863.829087-4.164559.829087-4.280268 0-.115708-1.081542-.539336-2.404065-.94097-1.322522-.401634-3.150911-.822393-4.062237-.936189l-1.658173-.204642-2.155434.381552c-1.185776.209423-2.948183.672258-3.916885 1.028947-.969658.355733-2.569499 1.162825-3.55637 1.793964-.985915.632095-2.52073 1.861859-3.409105 2.733021-.890288.872119-2.385895 2.630701-3.323997 3.907322-.939058 1.276622-1.920191 2.620182-2.181253 2.984521l-.47431.662695.287837-1.325391c.158741-.73059.600538-3.118398.981134-5.306345.380595-2.188904.773623-4.242017.86925-4.559499l.17691-.581412h-6.322862-6.323817v.799442c0 .439884-.373902 3.087798-.829087 5.885846-.456141 2.799004-1.208726 7.475167-1.671561 10.393705s-1.285228 7.99251-1.826477 11.275387-1.363642 7.983904-1.827433 10.445344c-.463791 2.462397-1.286184 6.790478-1.829346 9.61817-.541249 2.82578-1.443012 7.453173-2.000518 10.279909-.558462 2.827693-1.226895 6.165077-1.484132 7.419704-.259149 1.252715-.469529 2.408846-.469529 2.568543v.291663zm168.073169 0h7.238969v-2.214723-2.216635l.833868-5.494731c.459966-3.020859 1.216376-7.80795 1.683036-10.63373.46666-2.827692 1.047117-6.408926 1.290966-7.959997.244805-1.550114.891244-4.90758 1.437274-7.460823.547943-2.554199 1.229764-5.313996 1.517602-6.135432.287837-.820481.524992-1.68208.527861-1.913498.003825-.231417.62062-1.721287 1.371292-3.310609l1.366511-2.890806 1.803526-2.395458 1.802571-2.394501 1.972786-1.483176c1.084411-.816655 2.829605-1.898197 3.877677-2.405977l1.904891-.922801 4.144477.028688 4.145433.029644 1.632354.52308 1.631398.524037.275406-.170217.27445-.170216.0153-1.057635c.006694-.582369.36147-2.747366.787967-4.81291l.775535-3.754319-.872118-.341388c-.479092-.187429-1.617054-.575675-2.529336-.862556l-1.658173-.52308-2.984521.008606-2.984521.006694-2.432752.856818-2.432753.854906-1.826477 1.101624-1.82552 1.101624-2.375376 2.48726-2.37442 2.486303-1.275665 1.929755c-.700947 1.06146-1.318698 1.88194-1.372249 1.823608-.053551-.057377.328001-2.269231.847256-4.913319.519255-2.645044.951489-5.144736.959139-5.554976l.014345-.746847h-6.135433-6.134476v.212292c0 .115709-.306006 2.242454-.679908 4.724933-.373902 2.483435-1.125531 7.275307-1.667736 10.649986-.544118 3.373723-1.435363 8.82064-1.982349 12.104474-.546031 3.282877-1.370336 7.983903-1.831259 10.4463-.459966 2.461441-1.277577 6.789521-1.816914 9.616257-.539336 2.827693-1.424843 7.379541-1.968005 10.115431-.543161 2.734934-1.264189 6.354418-1.59984 8.04128l-.612014 3.06676zm-320.877565-80.92249 2.011993.006694 1.600797-.545074 1.601753-.545074 1.416237-1.437275 1.417193-1.436319.744935-1.91541.746848-1.914453.025819-2.819086.026775-2.817173-.662695-1.101624-.663652-1.100668-1.154219-.714334-1.155174-.71529h-2.492998-2.492998l-1.69738.760235-1.69738.759279-.984959 1.055722-.984959 1.05668-.774579 1.823608-.773623 1.823608-.146309 2.84108-.145353 2.84108.719115 1.412411.721028 1.411456 1.390418.631139 1.389461.630182z", fill: "#b3131b" })));
const SvgBc16C58Eb1De638B = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", ...props }, /* @__PURE__ */ reactExports.createElement("linearGradient", { id: "a", gradientTransform: "matrix(132.87 0 0 -323.02 -10686 208760)", gradientUnits: "userSpaceOnUse", x1: 83.977, x2: 84.977, y1: 645.5, y2: 645.5 }, /* @__PURE__ */ reactExports.createElement("stop", { offset: 0, stopColor: "#007b40" }), /* @__PURE__ */ reactExports.createElement("stop", { offset: 1, stopColor: "#55b330" })), /* @__PURE__ */ reactExports.createElement("linearGradient", { id: "b", gradientTransform: "matrix(133.43 0 0 -323.02 -11031 208760)", gradientUnits: "userSpaceOnUse", x1: 83.984, x2: 84.979, y1: 645.5, y2: 645.5 }, /* @__PURE__ */ reactExports.createElement("stop", { offset: 0, stopColor: "#1d2970" }), /* @__PURE__ */ reactExports.createElement("stop", { offset: 1, stopColor: "#006dba" })), /* @__PURE__ */ reactExports.createElement("linearGradient", { id: "c", gradientTransform: "matrix(132.96 0 0 -323.03 -10842 208770)", gradientUnits: "userSpaceOnUse", x1: 83.978, x2: 84.977, y1: 645.5, y2: 645.5 }, /* @__PURE__ */ reactExports.createElement("stop", { offset: 0, stopColor: "#6e2b2f" }), /* @__PURE__ */ reactExports.createElement("stop", { offset: 1, stopColor: "#e30138" })), /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#0e4c96" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m632.24 361.27c0 41.615-33.729 75.36-75.36 75.36h-409.13v-297.88c0-41.626 33.733-75.37 75.365-75.37l409.12-.001.001 297.89z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m498.86 256.54c11.684.253 23.437-.516 35.076.4 11.787 2.199 14.629 20.043 4.156 25.888-7.141 3.851-15.633 1.433-23.379 2.113h-15.852zm41.833-32.145c2.596 9.164-6.238 17.392-15.066 16.13h-26.767c.185-8.642-.368-18.021.271-26.208 10.725.301 21.549-.616 32.21.479 4.581 1.151 8.414 4.917 9.352 9.599zm64.428-135.9c.498 17.501.071 35.927.214 53.783-.035 72.596.072 145.19-.055 217.79-.47 27.207-24.582 50.844-51.601 51.387-27.046.111-54.095.016-81.142.047v-109.75c29.47-.154 58.959.307 88.417-.232 13.667-.859 28.632-9.875 29.27-24.914 1.61-15.103-12.632-25.551-26.152-27.201-5.198-.135-5.044-1.516 0-2.117 12.892-2.787 23.02-16.133 19.226-29.499-3.236-14.058-18.772-19.499-31.697-19.472-26.351-.18-52.709-.026-79.062-.077.172-20.489-.354-41 .286-61.474 2.087-26.716 26.806-48.747 53.447-48.27h78.849z", fill: "url(#a)" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m174.74 139.54c.674-27.163 24.889-50.611 51.875-51.007 26.944-.083 53.891-.012 80.837-.036-.074 90.885.148 181.78-.112 272.66-1.038 26.835-24.99 49.835-51.679 50.308-26.996.099-53.995.014-80.992.042v-113.45c26.223 6.194 53.722 8.832 80.473 4.721 15.993-2.574 33.488-10.424 38.902-27.014 3.986-14.191 1.742-29.126 2.334-43.691v-33.824h-46.297c-.208 22.369.426 44.779-.335 67.125-1.248 13.734-14.846 22.46-27.8 21.994-16.066.17-47.898-11.639-47.898-11.639-.08-41.918.466-94.409.692-136.18z", fill: "url(#b)" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m324.72 211.89c-2.434.517-.489-8.301-1.113-11.646.165-21.15-.347-42.323.283-63.458 2.083-26.829 26.991-48.916 53.739-48.288h78.766c-.073 90.884.147 181.78-.111 272.66-1.039 26.834-24.992 49.833-51.681 50.308-26.997.1-53.997.015-80.997.043v-124.3c18.44 15.128 43.5 17.483 66.473 17.524 17.316-.006 34.534-2.674 51.35-6.67v-22.772c-18.953 9.446-41.232 15.446-62.243 10.019-14.655-3.65-25.294-17.812-25.056-32.937-1.699-15.728 7.524-32.335 22.981-37.011 19.189-6.008 40.107-1.413 58.096 6.397 3.854 2.019 7.765 4.521 6.222-1.921v-17.9c-30.084-7.156-62.101-9.792-92.329-2.004-8.749 2.469-17.271 6.212-24.38 11.958z", fill: "url(#c)" }));
const Svg75Bb17D442A9Aa5E = (props) => /* @__PURE__ */ reactExports.createElement("svg", { height: 471, viewBox: "0 0 750 471", width: 750, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("g", { fill: "none" }, /* @__PURE__ */ reactExports.createElement("rect", { fill: "#000", height: 471, rx: 40, width: 750 }), /* @__PURE__ */ reactExports.createElement("g", { transform: "translate(133 48)" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m146.8 373.77v-24.77c0-9.35-6-15.64-15.55-15.72-5-.08-10.26 1.49-13.9 7-2.73-4.38-7-7-13.07-7-4.6271851-.232271-9.0320026 2.000568-11.58 5.87v-4.88h-8.61v39.55h8.69v-21.97c0-6.87 3.81-10.51 9.68-10.51 5.71 0 8.61 3.72 8.61 10.42v22h8.69v-21.91c0-6.87 4-10.51 9.68-10.51 5.87 0 8.69 3.72 8.69 10.42v22zm48.48-19.77v-19.77h-8.61v4.77c-2.73-3.56-6.87-5.79-12.49-5.79-11.09 0-19.77 8.69-19.77 20.77s8.69 20.77 19.77 20.77c5.63 0 9.76-2.23 12.49-5.79v4.8h8.61zm-32 0c0-6.95 4.55-12.66 12-12.66 7.12 0 11.91 5.46 11.91 12.66s-4.8 12.66-11.91 12.66c-7.47 0-12.02-5.71-12.02-12.66zm216.12-20.81c2.906602-.028642 5.790743.511498 8.49 1.59 2.514719 1.004654 4.807997 2.492736 6.75 4.38 1.913063 1.875758 3.429744 4.116773 4.46 6.59 2.146003 5.297587 2.146003 11.222413 0 16.52-1.030256 2.473227-2.546937 4.714242-4.46 6.59-1.941678 1.887671-4.235042 3.375809-6.75 4.38-5.466835 2.128264-11.533165 2.128264-17 0-2.510499-1.00137-4.797832-2.490006-6.73-4.38-1.901515-1.881202-3.410681-4.121157-4.44-6.59-2.146003-5.297587-2.146003-11.222413 0-16.52 1.029788-2.46859 2.538895-4.708458 4.44-6.59 1.932334-1.889787 4.219623-3.378394 6.73-4.38 2.705493-1.08107 5.596681-1.621257 8.51-1.59zm0 8.14c-1.681779-.014559-3.350036.301425-4.91.93-1.470254.590363-2.804249 1.475156-3.92 2.6-1.122908 1.148077-2.006664 2.507702-2.6 4-1.265729 3.309784-1.265729 6.970216 0 10.28.592861 1.492544 1.476675 2.852258 2.6 4 1.115751 1.124844 2.449746 2.009637 3.92 2.6 3.159488 1.239283 6.670512 1.239283 9.83 0 1.474284-.593902 2.814154-1.47808 3.94-2.6 1.132829-1.144071 2.023848-2.504406 2.62-4 1.265729-3.309784 1.265729-6.970216 0-10.28-.596152-1.495594-1.487171-2.855929-2.62-4-1.125846-1.12192-2.465716-2.006098-3.94-2.6-1.562387-.633286-3.234193-.952696-4.92-.94zm-137.3 12.67c-.08-12.33-7.69-20.77-18.78-20.77-11.58 0-19.69 8.44-19.69 20.77 0 12.58 8.44 20.77 20.27 20.77 6 0 11.42-1.49 16.22-5.54l-4.22-6.37c-3.266738 2.619648-7.313106 4.076341-11.5 4.14-5.54 0-10.59-2.56-11.83-9.68h29.37c.06-1.09.16-2.16.16-3.32zm-29.45-3.47c.91-5.71 4.38-9.6 10.51-9.6 5.54 0 9.1 3.47 10 9.6zm65.69-6.2c-3.757197-2.164453-8.004435-3.334681-12.34-3.4-4.72 0-7.53 1.74-7.53 4.63 0 2.65 3 3.39 6.7 3.89l4.05.58c8.61 1.24 13.82 4.88 13.82 11.83 0 7.53-6.62 12.91-18 12.91-6.45 0-12.41-1.66-17.13-5.13l4.05-6.7c3.797785 2.817702 8.43304 4.275905 13.16 4.14 5.87 0 9-1.74 9-4.8 0-2.23-2.23-3.47-6.95-4.14l-4.05-.58c-8.85-1.24-13.65-5.21-13.65-11.67 0-7.86 6.45-12.66 16.46-12.66 6.29 0 12 1.41 16.13 4.14zm41.35-2.23h-14.07v17.9c0 4 1.41 6.62 5.71 6.62 2.684365-.088246 5.302562-.85547 7.61-2.23l2.48 7.36c-3.227525 2.011602-6.956934 3.072196-10.76 3.06-10.18 0-13.73-5.46-13.73-14.65v-18h-8v-7.86h8v-12h8.69v12h14.06zm29.78-8.85c2.086514.010012 4.15609.375232 6.12 1.08l-2.65 8.11c-1.710096-.683978-3.538347-1.023802-5.38-1-5.63 0-8.44 3.64-8.44 10.18v22.17h-8.6v-39.56h8.48v4.77c2.149726-3.693802 6.148028-5.915508 10.42-5.79z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m176.95 32.39h130.5v234.51h-130.5z", fill: "#7673c0" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m185.24 149.64c-.03486-45.77046 20.985386-89.0131626 57-117.26-61.147032-48.0618249-148.9622811-41.06578574-201.7283628 16.0712353-52.7660817 57.1370207-52.7660817 145.2305087 0 202.3675297s140.5813308 64.13306 201.7283628 16.071235c-36.011849-28.244672-57.031785-71.483049-57-117.25z", fill: "#eb001b" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m483.5 149.64c.001034 57.09874-32.59844 109.186356-83.954442 134.142862s-112.453215 18.400897-157.345558-16.882862c35.966584-28.279813 56.964715-71.501935 56.964715-117.255s-20.998131-88.975187-56.964715-117.255c44.890924-35.28264477 105.985845-41.83904288 157.341061-16.8850475 51.355216 24.9539954 83.956145 77.0381115 83.958939 134.1350475z", fill: "#00a1df" }))));
const SvgF1A233802Cf96Ae4 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#16366f" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m449.01 250c0 99.143-80.37 179.5-179.51 179.5s-179.5-80.361-179.5-179.5c0-99.133 80.362-179.5 179.5-179.5 99.137 0 179.51 80.37 179.51 179.5", fill: "#d9222a" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m510.49 70.496c-46.38 0-88.643 17.596-120.5 46.466-6.49 5.889-12.548 12.237-18.125 18.996h36.266c4.966 6.037 9.536 12.388 13.685 19.013h-63.635c-3.827 6.121-7.28 12.469-10.341 19.008h84.312c2.893 6.185 5.431 12.53 7.6 19.004h-99.512c-2.091 6.235-3.832 12.581-5.217 19.009h109.94c2.689 12.49 4.044 25.231 4.041 38.008 0 19.934-3.254 39.113-9.254 57.02h-99.512c2.164 6.479 4.7 12.825 7.595 19.01h84.317c-3.064 6.54-6.52 12.889-10.347 19.013h-63.625c4.154 6.629 8.73 12.979 13.685 18.996h36.258c-5.57 6.772-11.63 13.126-18.13 19.012 31.86 28.867 74.118 46.454 120.5 46.454 99.138-.001 179.51-80.362 179.51-179.5 0-99.13-80.37-179.5-179.51-179.5", fill: "#ee9f2d" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m666.08 350.06c0-3.201 2.592-5.801 5.796-5.801s5.796 2.6 5.796 5.801c0 3.199-2.592 5.799-5.796 5.799-3.202-.001-5.797-2.598-5.796-5.799zm5.796 4.408c2.435-.001 4.407-1.975 4.408-4.408 0-2.433-1.972-4.404-4.404-4.404h-.004c-2.429-.004-4.4 1.963-4.404 4.392v.013c-.003 2.432 1.967 4.406 4.399 4.408.001-.001.003-.001.005-.001zm-.783-1.86h-1.188v-5.094h2.149c.45 0 .908 0 1.305.254.413.278.646.77.646 1.278 0 .57-.337 1.104-.883 1.312l.937 2.25h-1.315l-.78-2.016h-.87v2.016zm0-2.89h.658c.246 0 .504.02.725-.1.196-.125.296-.359.296-.584 0-.195-.12-.42-.288-.516-.207-.131-.536-.101-.758-.101h-.633zm-443.5-80.063c-2.045-.237-2.945-.301-4.35-.301-11.045 0-16.637 3.789-16.637 11.268 0 4.611 2.73 7.546 6.987 7.546 7.938 0 13.659-7.56 14-18.513zm14.171 32.996h-16.146l.371-7.676c-4.925 6.067-11.496 8.95-20.425 8.95-10.562 0-17.804-8.25-17.804-20.229 0-18.024 12.596-28.54 34.217-28.54 2.208 0 5.041.2 7.941.569.605-2.441.763-3.486.763-4.8 0-4.908-3.396-6.738-12.5-6.738-9.533-.108-17.396 2.271-20.625 3.334.204-1.23 2.7-16.658 2.7-16.658 9.712-2.846 16.117-3.917 23.325-3.917 16.733 0 25.596 7.512 25.58 21.712.032 3.805-.597 8.5-1.58 14.671-1.692 10.731-5.32 33.718-5.817 39.322zm-62.158 0h-19.488l11.163-69.997-24.925 69.997h-13.28l-1.64-69.597-11.734 69.597h-18.242l15.238-91.054h28.02l1.7 50.966 17.092-50.966h31.167zm354.98-32.996c-2.037-.237-2.942-.301-4.342-.301-11.041 0-16.634 3.789-16.634 11.268 0 4.611 2.726 7.546 6.983 7.546 7.939 0 13.664-7.56 13.993-18.513zm14.183 32.996h-16.145l.365-7.676c-4.925 6.067-11.5 8.95-20.42 8.95-10.566 0-17.8-8.25-17.8-20.229 0-18.024 12.587-28.54 34.212-28.54 2.208 0 5.037.2 7.934.569.604-2.441.763-3.486.763-4.8 0-4.908-3.392-6.738-12.496-6.738-9.533-.108-17.388 2.271-20.63 3.334.205-1.23 2.709-16.658 2.709-16.658 9.713-2.846 16.113-3.917 23.312-3.917 16.741 0 25.604 7.512 25.588 21.712.032 3.805-.597 8.5-1.58 14.671-1.682 10.731-5.32 33.718-5.812 39.322zm-220.39-1.125c-5.334 1.68-9.492 2.399-14 2.399-9.963 0-15.4-5.725-15.4-16.267-.142-3.27 1.433-11.879 2.67-19.737 1.125-6.917 8.45-50.53 8.45-50.53h19.371l-2.262 11.209h11.7l-2.643 17.796h-11.742c-2.25 14.083-5.454 31.625-5.491 33.95 0 3.817 2.037 5.483 6.67 5.483 2.221 0 3.941-.226 5.255-.7zm59.391-.6c-6.654 2.033-13.075 3.017-19.879 3-21.683-.021-32.987-11.346-32.987-33.032 0-25.313 14.38-43.947 33.9-43.947 15.97 0 26.17 10.433 26.17 26.796 0 5.429-.7 10.729-2.387 18.212h-38.575c-1.304 10.742 5.57 15.217 16.837 15.217 6.935 0 13.188-1.43 20.142-4.663zm-10.887-43.9c.107-1.543 2.054-13.217-9.013-13.217-6.171 0-10.583 4.704-12.38 13.217zm-123.42-5.017c0 9.367 4.541 15.825 14.841 20.676 7.892 3.709 9.113 4.809 9.113 8.17 0 4.617-3.48 6.7-11.192 6.7-5.812 0-11.22-.907-17.458-2.92 0 0-2.563 16.32-2.68 17.101 4.43.966 8.38 1.861 20.28 2.19 20.562 0 30.058-7.829 30.058-24.75 0-10.175-3.975-16.146-13.737-20.633-8.171-3.75-9.109-4.588-9.109-8.046 0-4.004 3.238-6.046 9.538-6.046 3.825 0 9.05.408 14 1.113l2.775-17.175c-5.046-.8-12.696-1.442-17.15-1.442-21.8 0-29.346 11.387-29.279 25.062m229.09-23.116c5.413 0 10.459 1.42 17.413 4.92l3.187-19.762c-2.854-1.12-12.904-7.7-21.416-7.7-13.042 0-24.066 6.47-31.82 17.15-11.31-3.746-15.959 3.825-21.659 11.367l-5.062 1.179c.383-2.483.73-4.95.613-7.446h-17.896c-2.445 22.917-6.779 46.13-10.171 69.075l-.884 4.976h19.496c3.254-21.143 5.038-34.681 6.121-43.842l7.342-4.084c1.096-4.08 4.529-5.458 11.416-5.292-.926 5.008-1.389 10.09-1.383 15.184 0 24.225 13.071 39.308 34.05 39.308 5.404 0 10.042-.712 17.221-2.657l3.431-20.76c-6.46 3.18-11.761 4.676-16.561 4.676-11.328 0-18.183-8.362-18.183-22.184-.001-20.05 10.195-34.108 24.745-34.108" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m185.21 297.24h-19.491l11.17-69.988-24.925 69.988h-13.282l-1.642-69.588-11.733 69.588h-18.243l15.238-91.042h28.02l.788 56.362 18.904-56.362h30.267z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m647.52 211.6-4.319 26.308c-5.33-7.012-11.054-12.087-18.612-12.087-9.834 0-18.784 7.454-24.642 18.425-8.158-1.692-16.597-4.563-16.597-4.563l-.004.067c.658-6.133.92-9.875.862-11.146h-17.9c-2.437 22.917-6.77 46.13-10.157 69.075l-.893 4.976h19.492c2.633-17.097 4.65-31.293 6.133-42.551 6.659-6.017 9.992-11.267 16.721-10.917-2.979 7.206-4.725 15.504-4.725 24.017 0 18.513 9.367 30.725 23.534 30.725 7.141 0 12.62-2.462 17.966-8.17l-.912 6.884h18.433l14.842-91.043zm-24.37 73.942c-6.634 0-9.983-4.909-9.983-14.597 0-14.553 6.271-24.875 15.112-24.875 6.695 0 10.32 5.104 10.32 14.508.001 14.681-6.369 24.964-15.449 24.964z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m233.19 264.26c-2.042-.236-2.946-.3-4.346-.3-11.046 0-16.634 3.788-16.634 11.267 0 4.604 2.73 7.547 6.98 7.547 7.945-.001 13.666-7.559 14-18.514zm14.179 32.984h-16.146l.367-7.663c-4.921 6.054-11.5 8.95-20.421 8.95-10.567 0-17.804-8.25-17.804-20.229 0-18.032 12.591-28.542 34.216-28.542 2.209 0 5.042.2 7.938.571.604-2.442.762-3.487.762-4.808 0-4.908-3.391-6.73-12.496-6.73-9.537-.108-17.395 2.272-20.629 3.322.204-1.226 2.7-16.638 2.7-16.638 9.709-2.858 16.121-3.93 23.321-3.93 16.738 0 25.604 7.518 25.588 21.705.029 3.82-.605 8.512-1.584 14.675-1.687 10.725-5.32 33.725-5.812 39.317zm261.38-88.592-3.192 19.767c-6.95-3.496-12-4.921-17.407-4.921-14.551 0-24.75 14.058-24.75 34.107 0 13.821 6.857 22.181 18.183 22.181 4.8 0 10.096-1.492 16.554-4.677l-3.42 20.75c-7.184 1.959-11.816 2.672-17.226 2.672-20.976 0-34.05-15.084-34.05-39.309 0-32.55 18.059-55.3 43.888-55.3 8.507.001 18.562 3.609 21.42 4.73m31.442 55.608c-2.041-.236-2.941-.3-4.346-.3-11.042 0-16.634 3.788-16.634 11.267 0 4.604 2.729 7.547 6.984 7.547 7.937-.001 13.662-7.559 13.996-18.514zm14.179 32.984h-16.15l.37-7.663c-4.924 6.054-11.5 8.95-20.42 8.95-10.563 0-17.804-8.25-17.804-20.229 0-18.032 12.595-28.542 34.212-28.542 2.213 0 5.042.2 7.941.571.601-2.442.763-3.487.763-4.808 0-4.908-3.392-6.73-12.496-6.73-9.533-.108-17.396 2.272-20.629 3.322.204-1.226 2.704-16.638 2.704-16.638 9.709-2.858 16.116-3.93 23.316-3.93 16.742 0 25.604 7.518 25.583 21.705.034 3.82-.595 8.512-1.579 14.675-1.682 10.725-5.324 33.725-5.811 39.317zm-220.39-1.122c-5.338 1.68-9.496 2.409-14 2.409-9.963 0-15.4-5.726-15.4-16.266-.138-3.281 1.437-11.881 2.675-19.738 1.12-6.926 8.446-50.533 8.446-50.533h19.367l-2.259 11.212h9.942l-2.646 17.788h-9.975c-2.25 14.091-5.463 31.619-5.496 33.949 0 3.83 2.042 5.483 6.671 5.483 2.22 0 3.938-.217 5.254-.692zm59.392-.591c-6.65 2.033-13.08 3.013-19.88 3-21.684-.021-32.987-11.346-32.987-33.033 0-25.321 14.38-43.95 33.9-43.95 15.97 0 26.17 10.429 26.17 26.8 0 5.433-.7 10.733-2.382 18.212h-38.575c-1.306 10.741 5.569 15.221 16.837 15.221 6.93 0 13.188-1.434 20.137-4.676zm-10.892-43.912c.117-1.538 2.059-13.217-9.013-13.217-6.166 0-10.579 4.717-12.375 13.217zm-123.42-5.004c0 9.365 4.542 15.816 14.842 20.675 7.891 3.708 9.112 4.812 9.112 8.17 0 4.617-3.483 6.7-11.187 6.7-5.817 0-11.225-.908-17.467-2.92 0 0-2.554 16.32-2.67 17.1 4.42.967 8.374 1.85 20.274 2.191 20.567 0 30.059-7.829 30.059-24.746 0-10.18-3.971-16.15-13.738-20.637-8.167-3.758-9.112-4.583-9.112-8.046 0-4 3.245-6.058 9.541-6.058 3.821 0 9.046.42 14.004 1.125l2.771-17.18c-5.041-.8-12.691-1.441-17.146-1.441-21.804 0-29.345 11.379-29.283 25.067m398.45 50.629h-18.437l.917-6.893c-5.347 5.717-10.825 8.18-17.967 8.18-14.168 0-23.53-12.213-23.53-30.725 0-24.63 14.521-45.393 31.709-45.393 7.558 0 13.28 3.088 18.604 10.096l4.325-26.308h19.221zm-28.745-17.109c9.075 0 15.45-10.283 15.45-24.953 0-9.405-3.63-14.509-10.325-14.509-8.838 0-15.116 10.317-15.116 24.875-.001 9.686 3.357 14.587 9.991 14.587zm-56.843-56.929c-2.439 22.917-6.773 46.13-10.162 69.063l-.891 4.975h19.491c6.971-45.275 8.658-54.117 19.588-53.009 1.742-9.266 4.982-17.383 7.399-21.479-8.163-1.7-12.721 2.913-18.688 11.675.471-3.787 1.334-7.466 1.163-11.225zm-160.42 0c-2.446 22.917-6.78 46.13-10.167 69.063l-.887 4.975h19.5c6.962-45.275 8.646-54.117 19.569-53.009 1.75-9.266 4.992-17.383 7.4-21.479-8.154-1.7-12.716 2.913-18.678 11.675.47-3.787 1.325-7.466 1.162-11.225zm254.57 68.242c0-3.214 2.596-5.8 5.796-5.8 3.197-.003 5.792 2.587 5.795 5.785v.015c-.001 3.2-2.595 5.794-5.795 5.796-3.2-.002-5.794-2.596-5.796-5.796zm5.796 4.404c2.432.001 4.403-1.97 4.403-4.401v-.002c.003-2.433-1.968-4.406-4.399-4.408h-.004c-2.435.001-4.408 1.974-4.409 4.408.003 2.432 1.976 4.403 4.409 4.403zm-.784-1.87h-1.188v-5.084h2.154c.446 0 .908.008 1.296.254.416.283.654.767.654 1.274 0 .575-.338 1.113-.888 1.317l.941 2.236h-1.319l-.78-2.008h-.87v2.008zm0-2.88h.654c.245 0 .513.018.729-.1.195-.125.295-.361.295-.587-.009-.21-.115-.404-.287-.524-.204-.117-.542-.085-.763-.085h-.629v1.296z", fill: "#fff" }));
const SvgD40Fa15A82Ff4Ca7 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m216.4 69.791h142.39c19.87 0 32.287 16.406 27.63 36.47l-66.333 287.48c-4.656 20.063-24.629 36.47-44.498 36.47h-142.39c-19.87 0-32.287-16.406-27.63-36.47l66.331-287.48c4.657-20.168 24.526-36.47 44.395-36.47h.104z", fill: "#d10429" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m346.34 69.791h163.82c19.868 0 10.865 16.406 6.209 36.47l-66.334 287.48c-4.657 20.063-3.208 36.47-23.077 36.47h-163.81c-19.972 0-32.287-16.406-27.527-36.47l66.334-287.48c4.656-20.168 24.524-36.47 44.498-36.47h-.104z", fill: "#022e64" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m504.41 69.791h142.4c19.869 0 32.287 16.406 27.629 36.47l-66.332 287.48c-4.658 20.063-24.631 36.47-44.499 36.47h-142.39c-19.973 0-32.287-16.406-27.63-36.47l66.333-287.48c4.656-20.168 24.525-36.47 44.394-36.47h.104z", fill: "#076f74" }), /* @__PURE__ */ reactExports.createElement("g", { fill: "#fefefe" }, /* @__PURE__ */ reactExports.createElement("path", { d: "m480.5 340.81h13.453l3.829-13.063h-13.351zm10.762-35.95-4.657 15.467s5.071-2.613 7.865-3.449c2.794-.627 6.933-1.15 6.933-1.15l3.208-10.763h-13.451zm6.726-22.153-4.449 14.839s4.967-2.3 7.761-3.029c2.794-.732 6.933-.941 6.933-.941l3.208-10.764h-13.349zm29.701 0-17.386 57.997h4.657l-3.622 12.018h-4.657l-1.138 3.657h-16.559l1.14-3.657h-33.529l3.311-11.076h3.415l17.594-58.938 3.518-11.913h16.868l-1.76 5.956s4.449-3.239 8.797-4.39c4.243-1.148 28.665-1.566 28.665-1.566l-3.622 11.809h-5.795z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m534.59 270.79h18.006l.207 6.792c-.103 1.149.828 1.672 3.001 1.672h3.622l-3.311 11.183h-9.729c-8.382.627-11.59-3.03-11.383-7.106l-.311-12.437zm2.216 53.2h-17.178l2.896-9.927h19.662l2.794-9.092h-19.351l3.311-11.182h53.812l-3.312 11.182h-18.109l-2.794 9.092h18.109l-3.002 9.927h-19.558l-3.518 4.18h7.968l1.966 12.54c.207 1.254.207 2.09.62 2.613.415.418 2.795.627 4.14.627h2.38l-3.725 12.227h-6.106c-.93 0-2.38-.104-4.346-.104-1.863-.21-3.104-1.255-4.346-1.882-1.139-.522-2.794-1.881-3.208-4.284l-1.863-12.54-8.899 12.331c-2.795 3.866-6.622 6.897-13.143 6.897h-12.418l3.311-10.869h4.761c1.346 0 2.588-.521 3.52-1.045.931-.418 1.758-.836 2.586-2.193zm-187.9-27.2h45.429l-3.312 10.973h-18.109l-2.793 9.299h18.627l-3.415 11.287h-18.524l-4.553 15.152c-.517 1.672 4.45 1.881 6.209 1.881l9.313-1.254-3.726 12.54h-20.904c-1.654 0-2.896-.209-4.76-.627-1.76-.418-2.587-1.254-3.311-2.403-.726-1.254-1.968-2.195-1.14-4.912l6.002-20.063h-10.348l3.415-11.495h10.348l2.794-9.3h-10.347l3.312-10.974zm31.387-19.835h18.627l-3.415 11.39h-25.457l-2.794 2.404c-1.242 1.15-1.552.732-3.105 1.568-1.447.73-4.449 2.193-8.382 2.193h-8.175l3.311-10.972h2.484c2.07 0 3.52-.21 4.243-.627.828-.522 1.76-1.672 2.69-3.554l4.656-8.568h18.525l-3.208 6.27zm35.107 18.81s5.07-4.701 13.764-6.164c1.966-.418 14.384-.211 14.384-.211l1.863-6.27h-26.182l-3.83 12.75zm24.629 4.807h-25.975l-1.552 5.329h22.56c2.69-.313 3.208.104 3.415-.104l1.655-5.225zm-33.735-29.678h15.833l-2.276 8.047s4.967-4.075 8.485-5.539c3.519-1.254 11.383-2.508 11.383-2.508l25.664-.104-8.796 29.469c-1.449 5.016-3.208 8.256-4.243 9.823-.93 1.463-2.07 2.821-4.346 4.075-2.173 1.15-4.141 1.881-6.002 1.986-1.656.104-4.347.209-7.865.209h-24.732l-6.934 23.303c-.62 2.299-.931 3.447-.517 4.074.31.523 1.241 1.15 2.38 1.15l10.865-1.045-3.726 12.749h-12.21c-3.933 0-6.727-.104-8.693-.21-1.862-.208-3.83 0-5.175-1.044-1.138-1.045-2.896-2.403-2.794-3.763.104-1.254.621-3.344 1.45-6.27z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m452.43 317.79-1.449 7.105c-.619 2.194-1.138 3.867-2.794 5.33-1.759 1.463-3.725 3.03-8.484 3.03l-8.796.418-.104 7.942c-.103 2.193.519 1.984.828 2.402.414.418.724.523 1.138.732l2.794-.21 8.384-.417-3.52 11.704h-9.624c-6.726 0-11.797-.21-13.35-1.463-1.655-1.046-1.862-2.3-1.862-4.599l.62-31.141h15.42l-.207 6.374h3.725c1.242 0 2.175-.104 2.691-.418s.828-.836 1.035-1.567l1.552-5.016h12.108zm-219.37-156c-.517 2.508-10.451 48.592-10.451 48.592-2.174 9.3-3.726 15.989-8.9 20.273-3.001 2.508-6.52 3.657-10.555 3.657-6.52 0-10.245-3.239-10.866-9.404l-.104-2.09s1.966-12.436 1.966-12.54c0 0 10.349-42.009 12.212-47.548.103-.313.103-.522.103-.627-20.18.21-23.801 0-24.008-.313-.104.418-.621 3.03-.621 3.03l-10.556 47.34-.932 3.97-1.758 13.168c0 3.866.724 7.105 2.277 9.718 4.863 8.569 18.627 9.823 26.388 9.823 10.038 0 19.455-2.195 25.767-6.061 11.073-6.584 13.97-16.929 16.454-26.02l1.242-4.703s10.659-43.576 12.522-49.219c.103-.314.103-.523.207-.627-14.695.104-18.938 0-20.387-.314zm59.03 86.623c-7.141-.105-9.728-.105-18.11.313l-.311-.627c.724-3.24 1.552-6.374 2.173-9.614l1.035-4.389c1.552-6.792 3.001-14.839 3.208-17.242.207-1.463.62-5.12-3.519-5.12-1.759 0-3.518.835-5.38 1.671-1.036 3.658-3.002 13.899-4.037 18.497-2.07 9.823-2.173 10.972-3.104 15.78l-.621.626c-7.347-.104-9.934-.104-18.42.314l-.414-.732c1.449-5.852 2.794-11.704 4.14-17.556 3.518-15.78 4.45-21.84 5.38-29.887l.725-.418c8.279-1.149 10.245-1.463 19.248-3.239l.724.836-1.345 5.016c1.552-.94 3.001-1.881 4.553-2.613 4.243-2.09 8.9-2.717 11.487-2.717 3.932 0 8.279 1.15 10.038 5.748 1.656 4.075.62 9.091-1.656 19.019l-1.138 5.016c-2.277 11.077-2.69 13.062-3.933 20.586l-.827.627zm29.057.027c-4.346 0-7.14-.104-9.83 0-2.691 0-5.278.21-9.314.314l-.207-.314-.207-.418c1.138-4.18 1.656-5.643 2.277-7.106.517-1.463 1.034-2.926 2.07-7.21 1.241-5.539 2.069-9.405 2.586-12.854.621-3.24.932-6.06 1.346-9.3l.31-.209.31-.313c4.347-.627 7.038-1.045 9.832-1.463s5.691-.94 10.141-1.776l.207.418.103.418-2.482 10.345c-.828 3.449-1.656 6.897-2.38 10.346-1.554 7.315-2.277 10.032-2.587 12.017-.414 1.881-.519 2.822-1.14 6.584l-.414.313-.414.314zm45.942-25.675c-.31 1.881-1.966 8.883-4.139 11.809-1.553 2.194-3.312 3.553-5.382 3.553-.62 0-4.14 0-4.242-5.33 0-2.612.517-5.33 1.138-8.255 1.863-8.465 4.14-15.466 9.831-15.466 4.45 0 4.76 5.225 2.794 13.689zm18.73.836c2.483-11.077.518-16.302-1.862-19.437-3.726-4.807-10.348-6.374-17.178-6.374-4.141 0-13.867.418-21.525 7.524-5.484 5.12-8.071 12.122-9.52 18.81-1.554 6.792-3.312 19.019 7.864 23.617 3.414 1.463 8.382 1.88 11.59 1.88 8.176 0 16.558-2.298 22.87-8.986 4.863-5.434 7.036-13.585 7.864-17.034zm174.43 26.08c-8.693-.104-11.176-.104-19.146.314l-.517-.627c2.173-8.256 4.346-16.616 6.312-24.976 2.483-10.868 3.104-15.466 3.933-21.84l.62-.522c8.59-1.254 10.97-1.567 19.973-3.239l.207.731c-1.656 6.897-3.208 13.69-4.864 20.482-3.311 14.317-4.45 21.632-5.69 29.156l-.828.627z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m547.75 224.16c-.414 1.776-2.07 8.882-4.243 11.808-1.449 2.09-4.967 3.449-6.933 3.449-.621 0-4.036 0-4.243-5.225 0-2.613.517-5.33 1.138-8.256 1.863-8.255 4.141-15.257 9.831-15.257 4.45 0 6.416 5.12 4.45 13.585zm17.075.836c2.482-11.077-7.658-.94-9.21-4.598-2.484-5.748-.933-17.243-10.866-21.109-3.829-1.568-12.832.418-20.49 7.524-5.381 5.016-8.072 12.017-9.52 18.705-1.554 6.688-3.312 19.02 7.76 23.304 3.52 1.567 6.727 1.985 9.935 1.776 11.178-.627 19.662-17.661 25.976-24.349 4.861-5.329 5.69 1.986 6.415-1.253zm-129.94 23.413c-7.14-.105-9.624-.105-18.006.313l-.311-.627c.725-3.24 1.553-6.374 2.276-9.614l.931-4.389c1.554-6.792 3.105-14.839 3.208-17.242.207-1.463.621-5.12-3.415-5.12-1.759 0-3.62.835-5.38 1.671-.932 3.658-3.002 13.899-4.037 18.497-1.966 9.823-2.173 10.972-3.104 15.78l-.621.626c-7.347-.104-9.934-.104-18.42.314l-.414-.732c1.449-5.852 2.794-11.704 4.14-17.556 3.519-15.78 4.347-21.84 5.38-29.887l.621-.418c8.28-1.149 10.35-1.463 19.248-3.239l.726.836-1.242 5.016c1.449-.94 3.001-1.881 4.45-2.613 4.243-2.09 8.899-2.717 11.485-2.717 3.934 0 8.177 1.15 10.038 5.748 1.656 4.075.519 9.091-1.759 19.019l-1.138 5.016c-2.38 11.077-2.69 13.062-3.934 20.586l-.826.627zm62.001-86.519-6.002.105c-15.523.209-21.732.104-24.215-.209-.207 1.15-.621 3.135-.621 3.135s-5.588 25.916-5.588 26.02c0 0-13.246 55.176-13.867 57.788 13.556-.209 19.041-.209 21.421.105.519-2.613 3.622-17.974 3.726-17.974 0 0 2.69-11.286 2.795-11.704 0 0 .826-1.15 1.654-1.672h1.242c11.694 0 24.836 0 35.186-7.628 7.036-5.225 11.797-13.063 13.97-22.468.517-2.299.931-5.016.931-7.837 0-3.658-.724-7.21-2.794-10.032-5.279-7.42-15.731-7.524-27.838-7.629zm7.761 27.066c-1.241 5.747-4.967 10.659-9.727 12.958-3.933 1.985-8.693 2.194-13.66 2.194h-3.208l.207-1.254s5.899-25.916 5.899-25.811l.206-1.359.104-1.045 2.38.21s12.211 1.044 12.418 1.044c4.759 1.881 6.83 6.688 5.381 13.063zm127.21 8.666-.723-.836c-8.797 1.776-10.453 2.09-18.525 3.24l-.619.626c0 .105-.104.21-.104.418v-.104c-6.002 14.107-5.9 11.077-10.762 22.154 0-.523 0-.836-.105-1.359l-1.242-24.035-.723-.836c-9.314 1.777-9.521 2.09-18.007 3.24l-.621.627c-.104.313-.104.627-.104.94l.104.105c1.035 5.538.828 4.284 1.863 12.958.517 4.284 1.138 8.569 1.655 12.749.828 7.106 1.346 10.554 2.381 21.318-5.797 9.613-7.142 13.271-12.729 21.734l.31.836c8.384-.312 10.246-.312 16.455-.312l1.346-1.568c4.656-10.135 40.256-71.79 40.256-71.79zm-302.72 6.922c4.76-3.344 5.38-7.942 1.345-10.345-4.036-2.404-11.176-1.672-15.937 1.672-4.76 3.24-5.277 7.837-1.241 10.345 3.932 2.3 11.072 1.672 15.833-1.672z" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m590.33 270.9-6.935 12.019c-2.173 4.075-6.312 7.21-12.728 7.21l-11.073-.209 3.208-10.868h2.173c1.138 0 1.966-.104 2.587-.418.621-.209.933-.627 1.449-1.254l4.14-6.583h17.282z" })));
const Svg223Ca525897C672A = (props) => /* @__PURE__ */ reactExports.createElement("svg", { enableBackground: "new 0 0 780 500", height: 500, viewBox: "0 0 780 500", width: 780, xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m40 0h700c22.092 0 40 17.909 40 40v420c0 22.092-17.908 40-40 40h-700c-22.091 0-40-17.908-40-40v-420c0-22.091 17.909-40 40-40z", fill: "#0e4595" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m293.2 348.73 33.361-195.76h53.36l-33.385 195.76zm246.11-191.54c-10.57-3.966-27.137-8.222-47.822-8.222-52.725 0-89.865 26.55-90.18 64.603-.299 28.13 26.514 43.822 46.752 53.186 20.771 9.595 27.752 15.714 27.654 24.283-.131 13.121-16.586 19.116-31.922 19.116-21.357 0-32.703-2.967-50.227-10.276l-6.876-3.11-7.489 43.823c12.463 5.464 35.51 10.198 59.438 10.443 56.09 0 92.5-26.246 92.916-66.882.199-22.269-14.016-39.216-44.801-53.188-18.65-9.055-30.072-15.099-29.951-24.268 0-8.137 9.668-16.839 30.557-16.839 17.449-.27 30.09 3.535 39.938 7.5l4.781 2.26zm137.31-4.223h-41.232c-12.773 0-22.332 3.487-27.941 16.234l-79.244 179.4h56.031s9.16-24.123 11.232-29.418c6.125 0 60.555.084 68.338.084 1.596 6.853 6.49 29.334 6.49 29.334h49.514l-43.188-195.64zm-65.418 126.41c4.412-11.279 21.26-54.723 21.26-54.723-.316.522 4.379-11.334 7.074-18.684l3.605 16.879s10.219 46.729 12.354 56.528zm-363.3-126.41-52.24 133.5-5.567-27.13c-9.725-31.273-40.025-65.155-73.898-82.118l47.766 171.2 56.456-.064 84.004-195.39h-56.521", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m146.92 152.96h-86.041l-.681 4.073c66.938 16.204 111.23 55.363 129.62 102.41l-18.71-89.96c-3.23-12.395-12.597-16.094-24.186-16.527", fill: "#f2ae14" }));
const Svg3696C0364Ce81148 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { id: "svg4703", viewBox: "0 0 18 18", height: 18, width: 18, ...props }, /* @__PURE__ */ reactExports.createElement("defs", { id: "defs4707" }), /* @__PURE__ */ reactExports.createElement("path", { id: "path4701", d: "m 11,0 v 2 h 3.59 L 4.76,11.83 6.17,13.24 16,3.41 V 7 h 2 V 0 M 16,16 H 2 V 2 H 9 V 0 H 2 C 0.89,0 0,0.9 0,2 v 14 a 2,2 0 0 0 2,2 h 14 a 2,2 0 0 0 2,-2 V 9 h -2 z" }));
const SvgC4E2C2A224B8321A = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M9.625 1.697a1.92 1.92 0 0 0-1.916 1.917c0 1.054.862 1.916 1.917 1.916a1.92 1.92 0 0 0 1.916-1.916 1.92 1.92 0 0 0-1.915-1.917zm0 13.417a1.92 1.92 0 0 0-1.916 1.916c0 1.055.862 1.917 1.917 1.917a1.92 1.92 0 0 0 1.916-1.917 1.92 1.92 0 0 0-1.917-1.916m0-6.709a1.92 1.92 0 0 0-1.916 1.917c0 1.054.862 1.917 1.917 1.917a1.92 1.92 0 0 0 1.916-1.917 1.92 1.92 0 0 0-1.915-1.917z" }));
const Svg3714337086137Eb1 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "m11.227 3.172-3.201.002c-1.508 0-2.657-.006-3.612.123s-1.768.423-2.38 1.033c-.61.61-.907 1.426-1.036 2.383-.128.955-.123 2.1-.123 3.61 0 1.508-.005 2.654.123 3.61.13.956.425 1.771 1.036 2.381.61.61 1.424.905 2.38 1.034.956.128 2.104.125 3.612.125h3.199c1.508 0 2.656.003 3.611-.125.957-.13 1.77-.424 2.381-1.034s.906-1.425 1.035-2.38c.13-.958.123-2.103.123-3.612s.006-2.654-.123-3.61c-.129-.954-.423-1.771-1.033-2.382s-1.427-.906-2.383-1.035c-.956-.13-2.102-.123-3.61-.123M8.026 4.674h3.199c1.508 0 2.625.005 3.412.11.786.106 1.193.28 1.52.606v.002h.001c.327.326.5.733.606 1.52l.03.26H2.456q.014-.136.03-.26c.106-.786.28-1.195.605-1.522h.002c.326-.327.733-.499 1.52-.605.786-.105 1.904-.111 3.412-.111M2.389 8.672h14.475c.008.492.011 1.03.011 1.65 0 1.51-.005 2.625-.109 3.41-.107.788-.28 1.198-.607 1.524h-.002c-.326.326-.733.5-1.52.605-.786.106-1.903.113-3.41.113H8.026c-1.51 0-2.625-.007-3.412-.113-.786-.105-1.193-.278-1.52-.605-.328-.326-.5-.736-.607-1.522-.105-.787-.11-1.902-.11-3.41 0-.62.004-1.16.012-1.652m2.436 3.302a.75.75 0 1 0 0 1.5h3.2a.75.75 0 0 0 0-1.5zm5.2 0a.75.75 0 1 0 0 1.5h1.2a.75.75 0 0 0 0-1.5z" }));
const Svg071A4A0C17B97D20 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M1.75 15.452a.85.85 0 0 1-.624-.252.84.84 0 0 1-.25-.623q0-.372.251-.624a.84.84 0 0 1 .623-.251H17.5q.372 0 .624.252a.84.84 0 0 1 .251.623.85.85 0 0 1-.252.623.84.84 0 0 1-.623.252zM1.312 9.83a.6.6 0 0 1-.306-.394.68.68 0 0 1 .066-.503l.415-.744h-.83A.637.637 0 0 1 0 7.533a.635.635 0 0 1 .656-.656h.831l-.415-.7a.68.68 0 0 1-.066-.504.6.6 0 0 1 .306-.393.68.68 0 0 1 .504-.066.6.6 0 0 1 .393.306l.416.7.416-.7a.6.6 0 0 1 .393-.306.68.68 0 0 1 .503.066q.24.13.307.393a.68.68 0 0 1-.066.504l-.415.7h.83a.635.635 0 0 1 .657.656.64.64 0 0 1-.656.656h-.832l.416.744a.67.67 0 0 1 .066.503.6.6 0 0 1-.306.394.68.68 0 0 1-.504.065.6.6 0 0 1-.393-.306l-.416-.744-.416.744a.6.6 0 0 1-.393.306.68.68 0 0 1-.503-.065zm7 0a.6.6 0 0 1-.306-.394.68.68 0 0 1 .066-.503l.416-.744h-.833A.637.637 0 0 1 7 7.533a.635.635 0 0 1 .656-.656h.832l-.416-.7a.68.68 0 0 1-.066-.504.6.6 0 0 1 .306-.393.68.68 0 0 1 .504-.066.6.6 0 0 1 .393.306l.416.7.416-.7a.6.6 0 0 1 .393-.306.68.68 0 0 1 .504.066q.24.13.306.393a.68.68 0 0 1-.066.504l-.416.7h.832a.635.635 0 0 1 .656.656.64.64 0 0 1-.656.656h-.832l.416.744a.67.67 0 0 1 .066.503.6.6 0 0 1-.306.394.68.68 0 0 1-.504.065.6.6 0 0 1-.393-.306l-.416-.744-.416.744a.6.6 0 0 1-.393.306.68.68 0 0 1-.504-.065m7 0a.6.6 0 0 1-.306-.394.68.68 0 0 1 .066-.503l.416-.744h-.832A.637.637 0 0 1 14 7.533a.635.635 0 0 1 .656-.656h.832l-.416-.7a.68.68 0 0 1-.066-.504.6.6 0 0 1 .306-.393.68.68 0 0 1 .504-.066.6.6 0 0 1 .393.306l.416.7.416-.7a.6.6 0 0 1 .393-.306.68.68 0 0 1 .503.066q.24.13.307.393a.67.67 0 0 1-.066.504l-.416.7h.832a.635.635 0 0 1 .656.656.64.64 0 0 1-.656.656h-.832l.416.744a.67.67 0 0 1 .066.503.6.6 0 0 1-.306.394.68.68 0 0 1-.504.065.6.6 0 0 1-.393-.306l-.416-.744-.416.744a.6.6 0 0 1-.393.306.68.68 0 0 1-.503-.065z" }));
const Svg6018Ebb68Aec24Ff = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 19.251, height: 20.644, viewBox: "0 0 19.251 20.644", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M7.98 0a.75.75 0 0 0-.75.75v.916H4.644A2.417 2.417 0 0 0 2.23 4.082v12.5a2.417 2.417 0 0 0 2.416 2.416h10a2.42 2.42 0 0 0 2.418-2.416v-12.5a2.42 2.42 0 0 0-2.418-2.416H11.73a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75h2.916a.915.915 0 0 1 .918.916v12.5a.917.917 0 0 1-.918.916h-10a.916.916 0 0 1-.916-.916v-12.5a.915.915 0 0 1 .916-.916H7.23v.916a.75.75 0 0 0 .75.75.75.75 0 0 0 .75-.75V.75A.75.75 0 0 0 7.98 0M6.313 7.5a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75H7.98a.75.75 0 0 0 .75-.75.75.75 0 0 0-.75-.75zm0 3.332a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75h6.666a.75.75 0 0 0 .75-.75.75.75 0 0 0-.75-.75zm0 3.334a.75.75 0 0 0-.75.75.75.75 0 0 0 .75.75h3.332a.75.75 0 0 0 .75-.75.75.75 0 0 0-.75-.75z" }));
const SvgB1D9C11A519C251C = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 21, height: 21, viewBox: "0 0 21 21", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M11.088 3.654q-.638-.027-1.275.01A12.5 12.5 0 0 0 5.578 4.67a12.5 12.5 0 0 0-3.617 2.383.9.9 0 0 0-.375.63.9.9 0 0 0 .227.698.9.9 0 0 0 .672.29.9.9 0 0 0 .662-.312l-.01.012c.385-.367-.023.005.379-.344.402-.348-.026.003.392-.326s-.023.004.41-.304c.434-.309-.025 0 .422-.288.448-.287-.025 0 .436-.265.46-.266-.024 0 .45-.244.472-.244-.026-.002.458-.223s-.025-.003.469-.201-.024-.006.478-.18c.503-.174-.024-.004.487-.154.51-.15-.023-.008.494-.133s-.025-.007.498-.107c.522-.101-.023-.01.504-.086s-.022-.01.508-.06c.53-.051-.022-.01.51-.036.53-.025-.023-.014.51-.014.531 0-.023-.011.509.014.531.025-.02-.015.51.035s-.02-.015.508.06c.526.076-.019-.014.503.087.523.1-.019-.018.499.107.517.125-.017-.017.494.133.51.15-.017-.02.486.154s-.015-.018.478.18c.494.198-.015-.02.47.201.483.221-.015-.021.458.223.473.243-.011-.022.45.244.46.266-.013-.022.435.265s-.012-.021.422.288c.433.308-.008-.025.41.304.418.33-.01-.022.393.326.402.349-.007-.023.379.344l.002.002c.162.15.382.234.603.234h.004a.91.91 0 0 0 .81-.574.91.91 0 0 0-.23-.967A12.5 12.5 0 0 0 14.826 4.4a12.5 12.5 0 0 0-3.738-.746m-.508 3.922a8.93 8.93 0 0 0-5.912 2.27.9.9 0 0 0-.295.61.9.9 0 0 0 .213.642l.002.004a.9.9 0 0 0 .613.295.9.9 0 0 0 .643-.225c.266-.238-.03.015.246-.211s-.03.014.256-.2c.286-.212-.032.013.264-.187.295-.2-.031.012.273-.174.305-.185-.033.01.28-.162.312-.171-.032.007.288-.15s-.034.006.293-.137c.327-.142-.032.007.301-.12.333-.128-.034.002.305-.11s-.033 0 .31-.096c.344-.096-.035 0 .313-.08.347-.08-.033-.002.318-.066.351-.065-.033-.003.32-.051.354-.049-.032-.005.323-.037.355-.033-.034-.006.322-.022s-.032-.008.324-.008c.357 0-.032-.008.324.008.357.016-.032-.01.323.022s-.031-.012.322.037c.353.048-.03-.014.32.05.351.065-.029-.014.319.067.347.08-.031-.016.312.08.344.097-.028-.016.31.096.34.112-.028-.018.305.11.334.127-.026-.022.301.12.327.143-.027-.02.293.137s-.023-.021.29.15c.312.172-.026-.023.279.162.304.186-.023-.025.273.174.296.2-.023-.025.264.188.286.213-.02-.027.256.199s-.02-.027.246.21c.157.146.37.227.584.226h.002a.94.94 0 0 0 .67-.293l.003-.006a.9.9 0 0 0 .213-.643.9.9 0 0 0-.295-.61 8.93 8.93 0 0 0-5.914-2.269m-.51 4.024a5.23 5.23 0 0 0-2.67 1.045.9.9 0 0 0-.354.587.9.9 0 0 0 .174.66.9.9 0 0 0 .713.356h.002a.92.92 0 0 0 .53-.176l.001-.002c.143-.108-.033.019.113-.084.147-.102-.033.019.118-.078.15-.096-.036.018.119-.072.154-.09-.035.016.123-.068s-.037.015.125-.063c.161-.077-.036.012.129-.058.164-.071-.039.01.129-.053.167-.064-.037.008.132-.049.17-.057-.039.01.133-.041.172-.05-.037.006.137-.037s-.039.005.137-.031c.175-.037-.04.003.136-.026s-.039.002.139-.02-.038.002.14-.013c.18-.015-.038-.003.141-.01.18-.007-.038-.002.14-.002.18 0-.04-.005.14.002.178.007-.038-.005.14.01s-.037-.008.14.014-.037-.01.14.02c.176.028-.04-.012.136.025.176.036-.037-.012.137.03.174.044-.035-.012.137.038.171.05-.037-.016.132.041.17.057-.034-.015.133.049s-.035-.018.13.053c.164.07-.033-.02.128.058s-.033-.021.125.063-.032-.022.123.068-.032-.024.12.072c.15.097-.03-.024.116.078s-.029-.024.114.084l.002.002a.9.9 0 0 0 .658.164.9.9 0 0 0 .586-.341v-.002a.9.9 0 0 0 .17-.66.9.9 0 0 0-.348-.586 5.26 5.26 0 0 0-3.644-1.047m.481 3.98a.9.9 0 0 0-.629.26.9.9 0 0 0-.26.629.9.9 0 0 0 .26.629.9.9 0 0 0 .629.26.9.9 0 0 0 .629-.26.9.9 0 0 0 .26-.63.9.9 0 0 0-.26-.628.9.9 0 0 0-.629-.26" }));
const SvgF36883B8Db9C47Da = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 36, height: 36, viewBox: "0 0 36 36", ...props }, /* @__PURE__ */ reactExports.createElement("g", { stroke: "#262a47", strokeWidth: 3, strokeDasharray: "400 655", fill: "none" }, /* @__PURE__ */ reactExports.createElement("circle", { cx: 18, cy: 18, r: 18, stroke: "none" }), /* @__PURE__ */ reactExports.createElement("circle", { cx: 18, cy: 18, r: 16.5 })), /* @__PURE__ */ reactExports.createElement("path", { d: "M16.123 23.064l6.919-10.379a1.314 1.314 0 011.822-.364 1.313 1.313 0 01.364 1.821l-7.881 11.821a1.314 1.314 0 01-2.09.126l-3.94-4.6a1.313 1.313 0 01.142-1.852 1.314 1.314 0 011.852.142z", fill: "#262a47" }));
const SvgA67451C466Ea8Aca = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 17.485, height: 11.661, viewBox: "0 0 17.485 11.661", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M6.335 11.438a.794.794 0 00.006-1.117l-3.693-3.7h14.054a.79.79 0 000-1.579H2.654l3.693-3.7A.8.8 0 006.341.225.786.786 0 005.23.231l-5 5.041a.887.887 0 00-.164.249.754.754 0 00-.061.3.792.792 0 00.225.553l5 5.041a.774.774 0 001.105.023z" }));
const Svg05454371D50Be11F = (props) => /* @__PURE__ */ reactExports.createElement("svg", { viewBox: "0 0 1500 500", preserveAspectRatio: "none", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fill: "#262a47", d: "M 1000,500 1371,0 H 0 v 500 z", className: "Segment1", clipPath: "" }), /* @__PURE__ */ reactExports.createElement("path", { fill: "#2bc4fd", d: "M 1500,500 1248.8,164.66 1370.71,0 H 1500 Z", className: "Segment2" }), /* @__PURE__ */ reactExports.createElement("path", { fill: "#3e52e4", d: "m 1000,500 h 500 L 1248.81,164.69 Z", className: "Segment3" }));
const Svg86370Fb8F6D9029D = (props) => /* @__PURE__ */ reactExports.createElement("svg", { viewBox: "0 0 500 500", preserveAspectRatio: "none", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fill: "#262a47", d: "M 0,500 371,0 H 0 Z", className: "Segment1" }), /* @__PURE__ */ reactExports.createElement("path", { fill: "#2bc4fd", d: "M 500,500 248.8,164.66 370.71,0 H 500 Z", className: "Segment2" }), /* @__PURE__ */ reactExports.createElement("path", { fill: "#3e52e4", d: "M 0,500 H 500 L 248.81,164.69 Z", className: "Segment3" }));
const Svg02Fe5840D790De36 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 13.27, height: 8.85, viewBox: "0 0 13.27 8.85", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M16.337,11.421a.6.6,0,0,0,0,.848l2.8,2.807H8.47a.6.6,0,0,0,0,1.2H19.13l-2.8,2.807a.607.607,0,0,0,0,.848.6.6,0,0,0,.843,0l3.8-3.826h0a.673.673,0,0,0,.124-.189.572.572,0,0,0,.046-.23.6.6,0,0,0-.171-.419l-3.8-3.826A.587.587,0,0,0,16.337,11.421Z", transform: "translate(-7.875 -11.252)" }));
const Svg86A990C017Ab6E32 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 17.371, height: 11.58, viewBox: "0 0 17.371 11.58", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M4.64 0a1.448 1.448 0 0 0-1.2.645L.241 5.424a1.447 1.447 0 0 0-.242.8v3.901a1.447 1.447 0 0 0 1.447 1.455h14.477a1.447 1.447 0 0 0 1.447-1.45V6.233a1.447 1.447 0 0 0-.242-.8l-.002-.008-3.188-4.78A1.448 1.448 0 0 0 12.74 0zm.253 1.93h7.584l2.574 3.86H11.34l-.965 1.929H7l-.965-1.93H2.32z" }));
const SvgC1B53E269A6A3694 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 14.935, height: 9.504, viewBox: "0 0 14.935 9.504", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M10.183 4.073a2.037 2.037 0 10-2.037-2.036 2.028 2.028 0 002.037 2.036zm-5.431 0a2.037 2.037 0 10-2.037-2.036 2.028 2.028 0 002.037 2.036zm0 1.358C3.17 5.431 0 6.225 0 7.807V9.5h9.5V7.8c0-1.575-3.166-2.369-4.748-2.369zm5.431 0a8 8 0 00-.658.034 2.865 2.865 0 011.337 2.342V9.5h4.073V7.8c0-1.575-3.171-2.369-4.752-2.369z" }));
const Svg588D2E3C75F50062 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M2 5l6 6 6-6" }));
const Svg12F2Ab3739Adfbea = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 22, height: 22, viewBox: "0 0 22 22", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { d: "M11 0A11 11 0 0 0 0 11a11 11 0 0 0 11 11 11 11 0 0 0 11-11A11 11 0 0 0 11 0zM6.523 5.271a1.25 1.25 0 0 1 .887.37L11 9.23l3.59-3.59a1.25 1.25 0 0 1 1.771 0 1.25 1.25 0 0 1-.002 1.77L12.77 11l3.592 3.592a1.25 1.25 0 0 1-.002 1.77 1.25 1.25 0 0 1-1.767 0L11 12.77l-3.592 3.59a1.25 1.25 0 0 1-1.767 0 1.25 1.25 0 0 1-.002-1.77L9.23 11 5.64 7.41a1.25 1.25 0 0 1-.001-1.77 1.25 1.25 0 0 1 .884-.369z" }));
const Svg78Cd0901269Cea25 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16.018, height: 16.018, viewBox: "0 0 16.018 16.018", ...props }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("style", null, ".search_svg__a{fill:none;stroke:#8e8e8e;stroke-linecap:round;stroke-linejoin:round;stroke-width:2.5px}")), /* @__PURE__ */ reactExports.createElement("path", { className: "search_svg__a", d: "M12.806 7.028A5.778 5.778 0 1 1 7.028 1.25a5.778 5.778 0 0 1 5.778 5.778zM14.25 14.25l-3.142-3.142" }));
const Svg8Dd98122Bc298E52 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 680 180", ...props }, /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("style", null, ".heylogin_logo_svg__cls-1{fill:#292748}")), /* @__PURE__ */ reactExports.createElement("g", { id: "heylogin_logo_svg__Layer_2", "data-name": "Layer 2" }, /* @__PURE__ */ reactExports.createElement("g", { id: "heylogin_logo_svg__Layer_1-2", "data-name": "Layer 1" }, /* @__PURE__ */ reactExports.createElement("g", { id: "heylogin_logo_svg__Word_trademark", "data-name": "Word trademark" }, /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1101", "data-name": "Path 1101", className: "heylogin_logo_svg__cls-1", d: "M249 33.83v37.9h.23a10.39 10.39 0 011.91-3.15 15.2 15.2 0 013.27-2.82 17.61 17.61 0 014.49-2 19.38 19.38 0 015.62-.8 23.34 23.34 0 0110.35 2 14.91 14.91 0 016.13 5.43 22 22 0 013 8.23 64 64 0 01.82 10.26v30.21H268V92.25c0-1.59-.06-3.21-.17-4.9a15.69 15.69 0 00-1-4.69 7.28 7.28 0 00-7.61-4.84 10.39 10.39 0 00-5.3 1.13 7.84 7.84 0 00-3.14 3.19 12.87 12.87 0 00-1.41 4.49 36 36 0 00-.34 5.18v27.28H232V33.83z" }), /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1102", "data-name": "Path 1102", className: "heylogin_logo_svg__cls-1", d: "M349 109.62a27 27 0 01-10.22 8 31 31 0 01-12.85 2.82 34.71 34.71 0 01-11.9-2 28.58 28.58 0 01-9.69-5.8 27.32 27.32 0 01-6.48-9.08 30.76 30.76 0 010-23.68 27.32 27.32 0 016.48-9.08A28.74 28.74 0 01314 65a34.77 34.77 0 0111.91-2 27.13 27.13 0 0110.56 2 22.23 22.23 0 018.12 5.8 26.61 26.61 0 015.17 9.11 37.16 37.16 0 011.81 11.84V97h-39.23a13.48 13.48 0 004.39 7.71 12.46 12.46 0 008.35 2.88 12.78 12.78 0 007.05-1.86 19.22 19.22 0 005-4.79zM334.67 85.5a9.79 9.79 0 00-2.82-7.32 10 10 0 00-7.56-3.05 12.29 12.29 0 00-8.63 3.21 10.63 10.63 0 00-2.37 3.27 10.74 10.74 0 00-1 3.89z" }), /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1103", "data-name": "Path 1103", className: "heylogin_logo_svg__cls-1", d: "M393.43 128q-1.73 4.41-3.28 7.77a18.78 18.78 0 01-4 5.7A15.63 15.63 0 01380 145a33.26 33.26 0 01-9.82 1.19 39.3 39.3 0 01-12.63-2l2.25-13.87a19.18 19.18 0 007.86 1.69 14.49 14.49 0 004.63-.61 7.86 7.86 0 003-1.81 10.2 10.2 0 002-2.88c.52-1.12 1.12-2.45 1.68-3.93l1.25-3.16-24-55.26h18.28l14.1 36.19h.22l12.06-36.19h17.36z" }), /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1104", "data-name": "Path 1104", className: "heylogin_logo_svg__cls-1", d: "M427.76 33.83h16.92v85.26h-16.92z" }), /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1105", "data-name": "Path 1105", className: "heylogin_logo_svg__cls-1", d: "M454.82 91.69a28.89 28.89 0 012.37-11.81 27.28 27.28 0 016.48-9.07 28.69 28.69 0 019.71-5.81 35.79 35.79 0 0123.78 0 28.65 28.65 0 019.7 5.81 27 27 0 016.48 9.07 30.67 30.67 0 010 23.68 26.84 26.84 0 01-6.48 9.08 28.56 28.56 0 01-9.74 5.77 35.79 35.79 0 01-23.78 0 28.37 28.37 0 01-9.7-5.8 27.18 27.18 0 01-6.48-9.08 28.68 28.68 0 01-2.34-11.84zm16.92 0a14.09 14.09 0 003.55 10q3.54 3.84 10 3.84t10-3.84a16 16 0 000-20.06q-3.57-3.82-10-3.83t-10 3.83a14.14 14.14 0 00-3.55 10.06z" }), /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1106", "data-name": "Path 1106", className: "heylogin_logo_svg__cls-1", d: "M582.93 114.46q0 15.55-7.86 23.59t-23.84 8.1a64.8 64.8 0 01-14.42-1.63 32.8 32.8 0 01-13.09-6.38l9.36-14a35.64 35.64 0 008.29 5.19 23.27 23.27 0 009.53 1.92q7.79 0 11.44-3.79a13.27 13.27 0 003.68-9.62v-5.3h-.23a16.13 16.13 0 01-7.28 5.61 23.34 23.34 0 01-8.18 1.64 28.3 28.3 0 01-11.05-2.09 24.8 24.8 0 01-8.51-5.86 26 26 0 01-5.47-9 34 34 0 01-.17-22 29.16 29.16 0 015-9.15 25 25 0 017.87-6.31A22.3 22.3 0 01548.44 63a25.82 25.82 0 016.6.8 27.08 27.08 0 015.36 2 20.33 20.33 0 014.06 2.76 18.25 18.25 0 012.7 3h.23v-7.27H583zm-42.68-23.11a13.18 13.18 0 003.88 9.41 14.62 14.62 0 004.28 3 13.27 13.27 0 0010.66 0 14.8 14.8 0 004.35-3 13.31 13.31 0 000-18.83 14.77 14.77 0 00-4.35-3 13.19 13.19 0 00-10.66 0 14.77 14.77 0 00-4.28 3 13.22 13.22 0 00-3.88 9.42z" }), /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1107", "data-name": "Path 1107", className: "heylogin_logo_svg__cls-1", d: "M595.34 47.06a9.8 9.8 0 112.87 6.94 9.44 9.44 0 01-2.87-6.94zm1.35 17.24h16.92v54.79h-16.92z" }), /* @__PURE__ */ reactExports.createElement("path", { id: "heylogin_logo_svg__Path_1108", "data-name": "Path 1108", className: "heylogin_logo_svg__cls-1", d: "M627.2 64.29h16.25v7.44h.22a14.64 14.64 0 012.25-3.16 17.54 17.54 0 013.49-2.82 21.67 21.67 0 014.63-2 19.43 19.43 0 015.62-.8 23.5 23.5 0 0110.36 2 15.08 15.08 0 016.16 5.47 22.29 22.29 0 013 8.23 64.06 64.06 0 01.82 10.22v30.22h-16.92V92.24c0-1.58-.05-3.2-.17-4.9a15.37 15.37 0 00-1-4.68 7.25 7.25 0 00-7.61-4.84 10.44 10.44 0 00-5.3 1.12 8.08 8.08 0 00-3.11 3.19 12.93 12.93 0 00-1.41 4.49 39.07 39.07 0 00-.34 5.18v27.29H627.2z" })), /* @__PURE__ */ reactExports.createElement("path", { d: "M90 180a89.54 89.54 0 0051.56-16.25l-35-41.78a35.86 35.86 0 01-30 1.41l-35.4 42.19A89.63 89.63 0 0090 180z", fill: "#3e48f8" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M155.93 28.76L120.52 71a35.91 35.91 0 01-14 51l35.05 41.78a90 90 0 0014.37-135z", fill: "#00c9ff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M126 90a35.81 35.81 0 00-5.48-19l-43.94 52.39A36 36 0 00126 90z", fill: "#00f500" }), /* @__PURE__ */ reactExports.createElement("path", { className: "heylogin_logo_svg__cls-1", d: "M41.14 165.57l35.39-42.18a36 36 0 1144-52.45l35.39-42.18A90 90 0 1041.14 165.59z" }))));
const Svg9B19Acdf996Aea57 = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: 181, height: 48, viewBox: "0 0 181 48", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("g", { clipPath: "url(#heylogin_logo_negative_svg__a)" }, /* @__PURE__ */ reactExports.createElement("path", { d: "M66.278 9.021v10.107h.061c.118-.308.29-.593.508-.84.254-.291.547-.544.87-.752a4.687 4.687 0 0 1 1.196-.534 5.15 5.15 0 0 1 1.496-.213 6.203 6.203 0 0 1 2.755.533c.668.321 1.233.823 1.632 1.448.41.67.681 1.417.798 2.195.146.905.22 1.82.218 2.736v8.056h-4.477V24.6c0-.424-.016-.856-.045-1.307a4.192 4.192 0 0 0-.266-1.25 1.941 1.941 0 0 0-2.026-1.291 2.761 2.761 0 0 0-1.41.301 2.09 2.09 0 0 0-.836.85 3.437 3.437 0 0 0-.376 1.198c-.063.458-.093.92-.09 1.381v7.275h-4.533V9.021h4.525zM92.896 29.232a7.19 7.19 0 0 1-2.72 2.133 8.24 8.24 0 0 1-3.421.752 9.223 9.223 0 0 1-3.167-.533 7.605 7.605 0 0 1-2.58-1.547 7.285 7.285 0 0 1-1.725-2.421 8.217 8.217 0 0 1 0-6.315 7.283 7.283 0 0 1 1.725-2.421 7.646 7.646 0 0 1 2.572-1.547 9.238 9.238 0 0 1 3.17-.533 7.21 7.21 0 0 1 2.81.533 5.918 5.918 0 0 1 2.162 1.547 7.1 7.1 0 0 1 1.376 2.43 9.93 9.93 0 0 1 .482 3.157v1.4H83.138a3.596 3.596 0 0 0 1.168 2.055c.623.52 1.413.793 2.223.768.66.021 1.312-.151 1.876-.495a5.118 5.118 0 0 0 1.331-1.278l3.16 2.315zM89.08 22.8a2.616 2.616 0 0 0-.75-1.952 2.662 2.662 0 0 0-2.013-.813 3.268 3.268 0 0 0-2.297.855 2.87 2.87 0 0 0-.897 1.91h5.957zM104.722 34.133a39.082 39.082 0 0 1-.873 2.072 5.013 5.013 0 0 1-1.065 1.52 4.151 4.151 0 0 1-1.637.941 8.837 8.837 0 0 1-2.614.317 10.442 10.442 0 0 1-3.362-.533l.6-3.699c.657.297 1.37.45 2.091.451.417.013.834-.042 1.233-.163.299-.098.572-.263.798-.482.221-.224.401-.483.533-.768.138-.299.298-.654.447-1.048l.333-.843-6.389-14.736h4.866l3.753 9.65h.059l3.21-9.65h4.621l-6.604 16.97zM113.86 9.021h4.503v22.736h-4.503V9.021zM121.062 24.45a7.712 7.712 0 0 1 .631-3.149 7.28 7.28 0 0 1 1.725-2.419 7.629 7.629 0 0 1 2.585-1.549 9.507 9.507 0 0 1 6.329 0 7.62 7.62 0 0 1 2.582 1.55 7.198 7.198 0 0 1 1.725 2.418 8.187 8.187 0 0 1 0 6.315 7.15 7.15 0 0 1-1.725 2.421 7.596 7.596 0 0 1-2.592 1.539 9.51 9.51 0 0 1-6.33 0 7.54 7.54 0 0 1-2.582-1.547 7.252 7.252 0 0 1-1.725-2.421 7.661 7.661 0 0 1-.623-3.158zm4.504 0a3.76 3.76 0 0 0 .945 2.667c.628.683 1.515 1.024 2.662 1.024 1.146 0 2.033-.341 2.662-1.024a4.276 4.276 0 0 0 0-5.35c-.634-.678-1.521-1.019-2.662-1.02-1.141-.002-2.029.338-2.662 1.02a3.772 3.772 0 0 0-.945 2.683zM155.162 30.523c0 2.764-.697 4.86-2.092 6.29-1.395 1.43-3.51 2.15-6.346 2.16-1.291 0-2.579-.146-3.838-.434a8.72 8.72 0 0 1-3.484-1.702l2.491-3.733a9.482 9.482 0 0 0 2.207 1.384c.8.348 1.664.522 2.537.512 1.382 0 2.397-.337 3.045-1.01a3.548 3.548 0 0 0 .979-2.566V30.01h-.061a4.299 4.299 0 0 1-1.938 1.495 6.203 6.203 0 0 1-2.177.438 7.518 7.518 0 0 1-2.941-.557 6.604 6.604 0 0 1-2.266-1.563 6.948 6.948 0 0 1-1.456-2.4 9.089 9.089 0 0 1-.045-5.867 7.793 7.793 0 0 1 1.331-2.44 6.66 6.66 0 0 1 2.095-1.683 5.927 5.927 0 0 1 2.779-.634 6.856 6.856 0 0 1 1.756.213c.493.127.972.306 1.427.534.389.2.752.447 1.081.735.268.24.509.508.719.8h.061v-1.938h4.155l-.019 13.379zm-11.36-6.163a3.517 3.517 0 0 0 1.032 2.51c.329.332.715.603 1.14.8a3.524 3.524 0 0 0 2.837 0 3.939 3.939 0 0 0 1.158-.8 3.56 3.56 0 0 0 0-5.021v-.001a3.933 3.933 0 0 0-1.158-.8 3.505 3.505 0 0 0-2.837 0c-.424.197-.81.467-1.14.8a3.527 3.527 0 0 0-1.032 2.512zM158.465 12.549a2.62 2.62 0 0 1 .594-1.657 2.606 2.606 0 0 1 4.426.661 2.62 2.62 0 0 1-.962 3.172 2.606 2.606 0 0 1-3.294-.325 2.526 2.526 0 0 1-.764-1.85v-.001zm.36 4.597h4.503v14.611h-4.503v-14.61zM166.946 17.144h4.325v1.984h.059a3.89 3.89 0 0 1 .599-.843 4.65 4.65 0 0 1 .929-.752A5.748 5.748 0 0 1 174.09 17c.485-.145.99-.216 1.496-.214a6.24 6.24 0 0 1 2.757.534c.672.324 1.239.829 1.64 1.458.409.672.68 1.418.799 2.195.145.901.218 1.812.218 2.725v8.059h-4.504v-7.16c0-.421-.013-.853-.045-1.307a4.108 4.108 0 0 0-.266-1.248 1.928 1.928 0 0 0-2.026-1.29 2.777 2.777 0 0 0-1.411.298c-.35.2-.636.495-.827.85a3.437 3.437 0 0 0-.376 1.198c-.06.458-.091.92-.09 1.382v7.277h-4.509V17.144z", fill: "#fff" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M23.956 48a23.804 23.804 0 0 0 13.724-4.333l-9.316-11.142a9.53 9.53 0 0 1-7.986.376l-9.422 11.251a23.827 23.827 0 0 0 13 3.848z", fill: "#D9D9D9" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M41.505 7.67 32.08 18.932a9.587 9.587 0 0 1-3.727 13.6l9.33 11.142a23.984 23.984 0 0 0 6.9-7.467 24.03 24.03 0 0 0-3.075-28.533l-.003-.006z", fill: "#B8B8B8" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M33.538 24a9.563 9.563 0 0 0-1.458-5.067l-11.696 13.97a9.567 9.567 0 0 0 8.936-.953A9.614 9.614 0 0 0 33.538 24z", fill: "#999" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m10.95 44.152 9.42-11.248a9.605 9.605 0 0 1-5.755-11.06 9.584 9.584 0 0 1 10.008-7.42 9.57 9.57 0 0 1 7.46 4.493l9.42-11.248a23.955 23.955 0 0 0-8.257-5.793 23.917 23.917 0 0 0-19.703.493 23.962 23.962 0 0 0-7.957 6.198A24.043 24.043 0 0 0 3.82 37.019a23.977 23.977 0 0 0 7.13 7.138v-.005z", fill: "#F9F9F9" }), /* @__PURE__ */ reactExports.createElement("circle", { cx: 24, cy: 24, r: 22.75, fill: "#fff", stroke: "#fff", strokeWidth: 2.5 }), /* @__PURE__ */ reactExports.createElement("path", { d: "M24.008 44a19.89 19.89 0 0 0 11.454-3.61l-7.775-9.283a7.966 7.966 0 0 1-6.665.313l-7.864 9.374A19.91 19.91 0 0 0 24.008 44z", fill: "#3E48F8" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m38.654 10.398-7.866 9.385a7.98 7.98 0 0 1-3.11 11.33l7.786 9.283a19.993 19.993 0 0 0 7.513-22.7 19.996 19.996 0 0 0-4.32-7.294l-.003-.004z", fill: "#00C8FF" }), /* @__PURE__ */ reactExports.createElement("path", { d: "M32.005 24.004a7.957 7.957 0 0 0-1.217-4.222l-9.762 11.64a7.998 7.998 0 0 0 10.979-7.418z", fill: "#00F500" }), /* @__PURE__ */ reactExports.createElement("path", { d: "m13.153 40.793 7.862-9.371a7.998 7.998 0 1 1 9.775-11.654l7.862-9.371A19.994 19.994 0 0 0 7.202 34.85a19.994 19.994 0 0 0 5.951 5.947v-.004z", fill: "#282846" })), /* @__PURE__ */ reactExports.createElement("defs", null, /* @__PURE__ */ reactExports.createElement("clipPath", { id: "heylogin_logo_negative_svg__a" }, /* @__PURE__ */ reactExports.createElement("path", { fill: "#fff", d: "M0 0h181v48H0z" }))));
const Svg4Be4720676Aebafd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 12.5, height: 12.5, viewBox: "0 0 12.5 12.5", ...props }, /* @__PURE__ */ reactExports.createElement("path", { "data-name": "Icon ionic-ios-checkmark-circle", d: "M6.25 0a6.25 6.25 0 106.25 6.25A6.249 6.249 0 006.25 0zm3.2 4.522L5.433 8.558a.543.543 0 01-.349.165.526.526 0 01-.352-.171L3.047 6.869a.12.12 0 010-.171l.535-.535a.116.116 0 01.168 0l1.334 1.334L8.75 3.804a.119.119 0 01.084-.036.109.109 0 01.084.036l.526.544a.118.118 0 01.006.177z" }));
const Svg639E0321C796A6Fd = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 12.5, height: 12.5, viewBox: "0 0 12.5 12.5", ...props }, /* @__PURE__ */ reactExports.createElement("path", { "data-name": "Icon ionic-ios-warning", d: "M5.435.518L.114 11.038A.99.99 0 00.925 12.5h10.648a.992.992 0 00.814-1.462L7.063.518a.9.9 0 00-1.628 0zm1.343 4.365L6.67 8.854h-.845l-.1-3.971zm-.529 6.133a.6.6 0 11.574-.6.581.581 0 01-.574.6z" }));
var en = ((e2) => (e2[e2.Undefined = 0] = "Undefined", e2[e2.NoCharacterClass = ErrorGroup.ClientWebSdk + 400] = "NoCharacterClass", e2[e2.PasswordTooShort = ErrorGroup.ClientWebSdk + 410] = "PasswordTooShort", e2))(en || {});
class to extends DomainError {
  constructor(t2, n2, r2, i) {
    super(t2, n2, r2 ?? n2, i ?? pleaseUpdate$3);
  }
}
class bi extends to {
  constructor() {
    super(en.NoCharacterClass, "no character class", "at least one type of chars must be selected", `Select at least one of the types (numbers, upper-case, lower-case, special).${pleaseUpdate$3}`);
  }
}
class Ii extends to {
  constructor() {
    super(en.PasswordTooShort, "password to short", "the requested password length is too short", `The password length must be at least on for each character type.${pleaseUpdate$3}`);
  }
}
const Cn = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", wn = "abcdefghijklmnopqrstuvwxyz", bn = "0123456789", In = "!#$@&%*^+_?()\\;:.=~{}<>-,\"'/`|".slice(0, 10);
function kt(e2) {
  const t2 = new Uint32Array(1);
  return window.crypto.getRandomValues(t2), t2[0] >= Math.floor(4294967295 / e2) * e2 ? kt(e2) : t2[0] % e2;
}
function ot(e2, t2) {
  const n2 = kt(e2.value.length), r2 = t2[kt(t2.length)];
  return {
    value: e2.value.slice(0, n2) + r2 + e2.value.slice(n2, e2.value.length),
    /* TODO: entropy calculation is not exact here as distribution of char groups is not considered
     * actual entropy is a little bit higher
     */
    entropy: e2.entropy + Math.log2(t2.length)
  };
}
function tn(e2, t2, n2, r2, i) {
  const s2 = (t2 ? 1 : 0) + (n2 ? 1 : 0) + (r2 ? 1 : 0) + (i ? 1 : 0);
  if (s2 === 0)
    throw new bi();
  if (e2 < s2)
    throw new Ii();
  const c2 = (t2 ? Cn : "") + (n2 ? wn : "") + (r2 ? bn : "") + (i ? In : "");
  let a2 = {
    value: "",
    entropy: 0
  };
  for (t2 && (a2 = ot(a2, Cn)), n2 && (a2 = ot(a2, wn)), r2 && (a2 = ot(a2, bn)), i && (a2 = ot(a2, In)); a2.value.length < e2; )
    a2 = ot(a2, c2);
  return a2;
}
const no = React$1.createContext("default");
function Si({
  children: e2,
  uiStyle: t2
}) {
  return /* @__PURE__ */ jsx(no.Provider, { value: t2, children: e2 });
}
const ch = reactExports.forwardRef(({
  children: e2,
  uiStyle: t2,
  element: n2,
  className: r2,
  ...i
}, s2) => /* @__PURE__ */ jsx(Si, { uiStyle: t2, children: /* @__PURE__ */ jsx(n2 ?? "div", { className: classNames(r2, {
  [d$2.defaultStyle]: t2 === "default",
  [d$2.highlightStyle]: t2 === "highlight"
}), ref: s2, ...i, children: e2 }) }));
function Ye() {
  return reactExports.useContext(no);
}
const oo = React$1.createContext("light");
function lh({
  children: e2,
  forceUIMode: t2
}) {
  const n2 = _default("(prefers-color-scheme: dark)"), r2 = t2 ?? (n2 ? "dark" : "light"), [i, s2] = reactExports.useState(false);
  return reactExports.useEffect(() => {
    document.documentElement.classList.add(d$2.noAnimation), r2 === "light" ? (document.documentElement.classList.add(d$2.lightMode), document.documentElement.classList.remove(d$2.darkMode)) : (document.documentElement.classList.remove(d$2.lightMode), document.documentElement.classList.add(d$2.darkMode)), setTimeout(() => {
      s2(true), document.documentElement.classList.remove(d$2.noAnimation);
    }, 5);
  }, [r2]), /* @__PURE__ */ jsx(oo.Provider, { value: r2, children: i && e2 });
}
function Z() {
  return reactExports.useContext(oo);
}
const ro = reactExports.createContext(false);
function dh({
  children: e2,
  value: t2
}) {
  return /* @__PURE__ */ jsx(ro.Provider, { value: t2, children: e2 });
}
function nn() {
  return reactExports.useContext(ro);
}
function Ni({
  element: e2,
  children: t2,
  ...n2
}) {
  const r2 = e2 ?? "div";
  return nn() ? /* @__PURE__ */ jsx(r2, { style: {
    outline: "5px solid #f0f"
  }, ...n2, children: t2 }) : null;
}
reactExports.createContext({
  openLogin: void 0,
  setOpenLogin: () => {
  }
});
const ao = reactExports.createContext({
  writeAuditlogEvent: () => {
    trackError(new Error("AuditlogWriteContext used without being set up!"));
  }
});
function _h({
  children: e2,
  writeAuditlogEvent: t2
}) {
  return /* @__PURE__ */ jsx(ao.Provider, { value: {
    writeAuditlogEvent: t2
  }, children: e2 });
}
function mh() {
  return reactExports.useContext(ao);
}
function Li(e2, t2, n2, r2) {
  const [i, s2] = reactExports.useState(), [c2, a2] = reactExports.useState(), [l2, d2] = reactExports.useState(), u2 = n2 ?? DEFAULT_TOTP_DIGITS;
  return reactExports.useEffect(() => {
    if (!e2) {
      s2(void 0), a2(void 0), d2(void 0);
      return;
    }
    let m2;
    const h2 = () => {
      const {
        totp: g2,
        epochLeftMs: v2,
        epochStart: L2,
        epochEnd: N2
      } = calculateTotp(e2.toUpperCase().trim(), t2 ?? DEFAULT_TOTP_ALGORITHM, u2, r2 ?? DEFAULT_TOTP_PERIOD);
      s2(g2), a2([L2, N2]), m2 = setTimeout(h2, v2);
    };
    try {
      h2();
    } catch (g2) {
      if (g2 instanceof InvalidTotpSecretError || g2 instanceof UnknownTotpAlgorithmError) {
        s2(void 0), a2(void 0), d2(void 0);
        return;
      }
      throw g2;
    }
    return () => {
      clearTimeout(m2), a2(void 0);
    };
  }, [e2, t2, u2, r2]), reactExports.useEffect(() => {
    if (c2 === void 0)
      return;
    const [m2, h2] = c2, g2 = h2 - m2, v2 = () => {
      const N2 = Date.now() - m2;
      d2(N2 * 100 / g2);
    };
    v2();
    const L2 = setInterval(v2, 250);
    return () => {
      clearInterval(L2);
    };
  }, [c2]), {
    totp: i,
    totpPercent: l2,
    totpDigits: (i == null ? void 0 : i.length) ?? u2
  };
}
function he() {
  const [e2, t2] = reactExports.useState({
    width: 0,
    height: 0
  }), [n2, r2] = reactExports.useState(null), i = reactExports.useCallback((c2) => {
    r2(c2), t2(Sn(c2));
  }, []), s2 = reactExports.useCallback(() => {
    t2(Sn(n2));
  }, [n2]);
  return reactExports.useEffect(() => {
    if (!n2)
      return;
    const c2 = new ResizeObserver(s2);
    return c2.observe(n2, {
      box: "border-box"
    }), () => c2.disconnect();
  }, [n2, s2]), [i, e2];
}
function Sn(e2) {
  return e2 ? {
    width: e2.offsetWidth,
    height: e2.offsetHeight
  } : {
    width: 0,
    height: 0
  };
}
function Ht() {
  return i18n.locale === "de" ? jo : Ko;
}
function Ri(e2, t2, n2) {
  const {
    action: r2,
    global: i,
    deps: s2
  } = {
    deps: [],
    ...n2
  }, c2 = reactExports.useRef(new cr());
  reactExports.useEffect(() => {
    i ? c2.current.stopCallback = () => false : c2.current.stopCallback = Bi;
  }, [i]);
  const a2 = reactExports.useCallback(t2, s2);
  reactExports.useEffect(() => {
    const l2 = c2.current;
    return l2.bind(e2, a2, r2), () => {
      l2.unbind(e2, r2);
    };
  }, [r2, a2, e2, i]);
}
function Bi(e2, t2, n2) {
  return t2.tagName === "SELECT" || t2.tagName === "TEXTAREA" || t2 instanceof HTMLInputElement && t2.type !== "checkbox" && t2.type !== "radio" || t2 instanceof HTMLElement && (t2 == null ? void 0 : t2.contentEditable) === "true";
}
function on(e2, t2) {
  const n2 = Array.isArray(e2) ? e2 : [e2], r2 = reactExports.useMemo(() => n2, n2);
  reactExports.useEffect(() => {
    const i = (s2) => {
      Nn(s2, r2) || t2();
    };
    return window.addEventListener("click", i), () => window.removeEventListener("click", i);
  }, [t2, r2]), reactExports.useEffect(() => {
    const i = (s2) => {
      s2.key === "Escape" && Nn(s2, r2) && t2();
    };
    return window.addEventListener("keydown", i), () => window.removeEventListener("keydown", i);
  }, [t2, r2]);
}
function Nn(e2, t2) {
  return t2.flatMap((r2) => r2.current ? r2.current : []).some((r2) => r2.contains(e2.target));
}
function Ke({
  isEmpty: e2,
  onShow: t2
}) {
  const [n2, r2] = reactExports.useState(e2);
  reactExports.useEffect(() => {
    e2 && r2(true);
  }, [e2]);
  const i = reactExports.useRef(n2);
  return reactExports.useEffect(() => {
    n2 !== i.current && (i.current = n2, t2 && n2 && t2());
  }, [t2, n2]), {
    show: n2,
    setShow: r2,
    action: {
      key: "show/hide",
      icon: Svg5D0Be631Bf7D3947,
      label: i18n._(
        /*i18n*/
        {
          id: "8vETh9"
        }
      ),
      activeIcon: SvgE05728E87Cd1Ca23,
      activeLabel: i18n._(
        /*i18n*/
        {
          id: "vLyv1R"
        }
      ),
      active: n2,
      element: {
        type: "button",
        props: {
          onClick: (s2) => {
            r2((c2) => !c2), s2.preventDefault();
          },
          type: "button",
          disabled: e2
        }
      }
    }
  };
}
function Ti({
  visible: e2,
  anchor: t2,
  innerAnchor: n2 = {
    top: 0,
    left: 0
  },
  rootStyle: r2
}) {
  const i = reactExports.useRef(null), s2 = reactExports.useRef(null), c2 = reactExports.useCallback((d2) => {
    i.current = d2;
    let u2 = d2;
    for (; u2 && u2.scrollHeight <= u2.clientHeight; )
      u2 = u2.parentElement;
    s2.current = u2;
  }, []), a2 = reactExports.useRef(document.createElement("div"));
  return reactExports.useEffect(() => {
    if (!e2)
      return;
    const d2 = a2.current;
    return document.body.appendChild(d2), () => {
      document.body.removeChild(d2);
    };
  }, [e2]), $i({
    visible: e2,
    positionElementScrollParentRef: s2,
    portalRootRef: a2
  }), Ei({
    visible: e2,
    anchor: t2,
    innerAnchor: n2,
    rootStyle: r2,
    positioningElementRef: i,
    portalRootRef: a2
  }), {
    PositionedPortal: reactExports.useCallback(({
      children: d2
    }) => ReactDOM.createPortal(d2, a2.current), []),
    updatePositioningElement: c2
  };
}
function $i({
  visible: e2,
  positionElementScrollParentRef: t2,
  portalRootRef: n2
}) {
  reactExports.useEffect(() => {
    if (!e2)
      return;
    function r2(s2) {
      var c2;
      (c2 = t2.current) == null || c2.scrollBy({
        top: s2.deltaY,
        left: s2.deltaX
      });
    }
    const i = n2.current;
    return i.addEventListener("wheel", r2), () => {
      i.removeEventListener("wheel", r2);
    };
  }, [n2, t2, e2]);
}
function Ei({
  visible: e2,
  anchor: t2,
  innerAnchor: n2,
  rootStyle: r2,
  positioningElementRef: i,
  portalRootRef: s2
}) {
  const c2 = reactExports.useCallback(() => {
    i.current && Object.assign(s2.current.style, Pi({
      posEl: i.current,
      posAnchor: t2,
      innerAnchor: n2,
      rootStyle: r2
    }));
  }, [t2, n2, s2, i, r2]), a2 = reactExports.useCallback(() => {
    requestAnimationFrame(c2);
  }, [c2]);
  reactExports.useEffect(() => {
    if (e2)
      return a2(), document.addEventListener("scroll", a2, true), window.addEventListener("resize", a2), () => {
        document.removeEventListener("scroll", a2, true), window.addEventListener("resize", a2);
      };
  }, [a2, e2]);
}
function Pi({
  posEl: e2,
  posAnchor: t2,
  innerAnchor: n2,
  rootStyle: r2
}) {
  const i = {
    position: "fixed",
    ...r2
  }, s2 = e2.getBoundingClientRect();
  "top" in t2 ? i.top = `${s2.top + s2.height * t2.top}px` : i.bottom = `${document.documentElement.clientHeight - s2.bottom + s2.height * t2.bottom}px`, "left" in t2 ? i.left = `${s2.left + s2.width * t2.left}px` : i.right = `${document.documentElement.clientWidth - s2.right + s2.width * t2.right}px`;
  const c2 = "top" in n2 ? -n2.top : -(1 - n2.bottom), a2 = "left" in n2 ? -n2.left : -(1 - n2.right);
  return i.transform = `translate(${a2 * 100}%, ${c2 * 100}%)`, i;
}
function gh(e2) {
  const t2 = reactExports.useMemo(() => new P(e2), [e2]);
  reactExports.useEffect(() => (t2.init(), () => t2.close()), [t2, e2]);
}
function de(e2, t2) {
  const [n2, r2] = reactExports.useState(false), i = reactExports.useCallback(() => {
    if (!t2)
      return;
    e2(t2), r2(true);
    const s2 = window.setTimeout(() => r2(false), 1e3);
    return () => window.clearTimeout(s2);
  }, [e2, t2]);
  return {
    action: {
      key: "copy",
      icon: Svg32192847008Cf9Fc,
      label: i18n._(
        /*i18n*/
        {
          id: "he3ygx"
        }
      ),
      activeIcon: SvgB1C9Ac3221E94B98,
      active: n2,
      activeLabel: i18n._(
        /*i18n*/
        {
          id: "6V3Ea3"
        }
      ),
      element: {
        type: "button",
        props: {
          onClick: i,
          type: "button",
          disabled: !t2
        }
      }
    }
  };
}
function yh() {
  return reactExports.useMemo(() => D$1() ? "metaKey" : "ctrlKey", []);
}
const Ai = "_PushState_1xmnu_1", Mi = "_confirmed_1xmnu_17", Oi = "_warning_1xmnu_20", Fi = "_error_1xmnu_23", Wi = "_small_1xmnu_27", zi = "_connecting_1xmnu_60", Di = "_rotating_1xmnu_63", Ui = "_rotate_1xmnu_1", Vi = "_Icon_1xmnu_67", ki = "_fadeEnter_1xmnu_86", Hi = "_fadeExit_1xmnu_89", qi = "_fadeEnterActive_1xmnu_92", ji = "_fadeExitActive_1xmnu_96", ye = {
  PushState: Ai,
  confirmed: Mi,
  warning: Oi,
  error: Fi,
  small: Wi,
  connecting: zi,
  rotating: Di,
  rotate: Ui,
  Icon: Vi,
  fadeEnter: ki,
  fadeExit: Hi,
  fadeEnterActive: qi,
  fadeExitActive: ji
};
function Ki({
  className: e2,
  state: t2,
  small: n2,
  unlockDeviceType: r2
}) {
  const i = reactExports.useRef(null), s2 = Gi(i, t2 === "connecting"), c2 = t2 === "confirmed", a2 = {
    enter: ye.fadeEnter,
    enterActive: ye.fadeEnterActive,
    exit: ye.fadeExit,
    exitActive: ye.fadeExitActive
  }, l2 = c2 ? SvgB1C9Ac3221E94B98 : r2 === "multiple" || r2 === "mobileSafari" ? SvgD1032194Ec1096E8 : r2 === "securityKey" ? SvgD3851543766Ba342 : Svg680Caa6137361575;
  return /* @__PURE__ */ jsx("div", { ref: i, className: classNames(ye.PushState, ye[t2], {
    [ye.rotating]: s2,
    [ye.small]: n2
  }, e2), children: /* @__PURE__ */ jsx(mr, { children: /* @__PURE__ */ jsx(Ut, { addEndListener: (d2, u2) => d2.addEventListener("transitionend", u2, false), classNames: a2, children: /* @__PURE__ */ jsx(l2, { className: ye.Icon }) }, c2 ? "a" : "b") }) });
}
function Gi(e2, t2) {
  const [n2, r2] = reactExports.useState(t2);
  return reactExports.useEffect(() => {
    const i = e2 == null ? void 0 : e2.current;
    function s2() {
      r2(false), i == null || i.removeEventListener("animationiteration", s2);
    }
    return t2 ? r2(true) : i == null || i.addEventListener("animationiteration", s2), () => {
      i == null || i.removeEventListener("animationiteration", s2);
    };
  }, [e2, t2]), n2;
}
const Qi = "_Button_1jnoy_1 _UnstyledButton_14p2i_205", Yi = "_medium_1jnoy_31", Ji = "_small_1jnoy_35", Xi = "_PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", Zi = "_primary_1jnoy_62 _PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", es = "_secondary_1jnoy_77 _PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", ts = "_userConfirmation_1jnoy_92 _PillButton_1jnoy_40 _Button_1jnoy_1 _UnstyledButton_14p2i_205", ns = "_dark_1jnoy_109", os = "_highlight_1jnoy_110", rs = "_tertiary_1jnoy_122 _Button_1jnoy_1 _UnstyledButton_14p2i_205", rt = {
  Button: Qi,
  medium: Yi,
  small: Ji,
  PillButton: Xi,
  primary: Zi,
  secondary: es,
  userConfirmation: ts,
  dark: ns,
  highlight: os,
  tertiary: rs,
  default: "_default_1jnoy_141"
};
function be({
  element: e2,
  buttonStyle: t2,
  className: n2,
  children: r2,
  size: i,
  buttonRef: s2,
  overrideColor: c2,
  style: a2,
  ...l2
}) {
  const d2 = e2 ?? "button", u2 = Ye(), m2 = Z();
  return /* @__PURE__ */ jsx(d2, { className: classNames(rt.Button, rt[t2], rt[u2], rt[m2], rt[i ?? "medium"], n2), style: {
    ...a2,
    "--color-override": c2
  }, ...l2, ref: s2, children: r2 });
}
const is2 = "_ActionInputWrapper_kgcit_1", ss = "_medium_kgcit_5", as = "_small_kgcit_9", cs = "_InputFieldWrapper_kgcit_13", ls = "_ActionInput_kgcit_1", ds = "_highlight_kgcit_47", us = "_error_kgcit_54", ps = "_Placeholder_kgcit_63", _s = "_PlaceholderIcon_kgcit_78", ms = "_PlaceholderText_kgcit_87", hs = "_ClearButton_kgcit_96 _UnstyledButton_14p2i_205", fs = "_ErrorIcon_kgcit_97", gs = "_Message_kgcit_113", ne = {
  ActionInputWrapper: is2,
  medium: ss,
  small: as,
  InputFieldWrapper: cs,
  ActionInput: ls,
  highlight: ds,
  error: us,
  Placeholder: ps,
  PlaceholderIcon: _s,
  PlaceholderText: ms,
  ClearButton: hs,
  ErrorIcon: fs,
  Message: gs
};
function vh({
  icon: e2,
  placeholder: t2,
  value: n2,
  className: r2,
  onClear: i,
  error: s2,
  size: c2,
  ...a2
}) {
  const [l2, d2] = reactExports.useState(false), u2 = Ye();
  return /* @__PURE__ */ jsxs("label", { className: classNames(ne.ActionInputWrapper, ne[c2 ?? "medium"], r2), children: [
    /* @__PURE__ */ jsxs("div", { className: ne.InputFieldWrapper, children: [
      !l2 && !n2 && /* @__PURE__ */ jsxs("div", { className: ne.Placeholder, children: [
        e2 && /* @__PURE__ */ jsx("div", { className: ne.PlaceholderIcon, children: e2 }),
        " ",
        /* @__PURE__ */ jsx("div", { className: ne.PlaceholderText, children: t2 })
      ] }),
      /* @__PURE__ */ jsx("input", { ...a2, className: classNames(ne.ActionInput, {
        [ne.highlight]: u2 === "highlight",
        [ne.error]: !!s2
      }), onFocus: () => d2(true), onBlur: () => d2(false), value: n2, "data-lpignore": "true" }),
      " ",
      s2 ? /* @__PURE__ */ jsx("div", { className: ne.ErrorIcon, children: /* @__PURE__ */ jsx(SvgAd255589C29Ec33D, {}) }) : !!n2 && i && /* @__PURE__ */ jsx("button", { type: "button", className: ne.ClearButton, onClick: i, children: /* @__PURE__ */ jsx(Svg1Bcfd951Ee5Cd05C, {}) })
    ] }),
    s2 && /* @__PURE__ */ jsx("div", { className: ne.Message, children: s2 })
  ] });
}
const ys = "_Button_1s6un_1 _UnstyledButton_14p2i_205", Ln = {
  Button: ys
};
function co({
  element: e2,
  className: t2,
  children: n2,
  ...r2
}) {
  const i = e2 ?? "button", s2 = Ye();
  return /* @__PURE__ */ jsx(i, { className: classNames(Ln.Button, Ln[s2], t2), ...r2, children: n2 });
}
const vs = "_Switch_lac3f_1", Cs = {
  Switch: vs
};
function at({
  className: e2,
  ...t2
}) {
  return /* @__PURE__ */ jsx("input", { type: "checkbox", className: classNames(Cs.Switch, e2), ...t2 });
}
const xs = "_InputContainer_17zv7_1", Rs = "_hasIcon_17zv7_20", Bs = "_labelInside_17zv7_23", Ts = "_relaxedLabelInsideSpacing_17zv7_27", $s = "_hasRightInlineUi_17zv7_31", Es = "_hasBottomInlineUi_17zv7_34", Ps = "_disabled_17zv7_37", As = "_readOnly_17zv7_38", Ms = "_lightMode_17zv7_41", Os = "_error_17zv7_45", Fs = "_warning_17zv7_48", Ws = "_darkMode_17zv7_51", zs = "_InputFieldWrapper_17zv7_63", Ds = "_InputLabel_17zv7_67", Us = "_Input_17zv7_1", Vs = "_InputPlaceholder_17zv7_73", ks = "_InputBackgroundText_17zv7_74", Hs = "_raisedLabel_17zv7_130", qs = "_colorize_17zv7_145", js = "_autosize_17zv7_177", Ks = "_focus_17zv7_184", Gs = "_suggestions_17zv7_188", Qs = "_monospace_17zv7_195", Ys = "_Icon_17zv7_208", Js = "_InlineUi_17zv7_224", Xs = "_Prefix_17zv7_253", Zs = "_Message_17zv7_266", V = {
  InputContainer: xs,
  hasIcon: Rs,
  labelInside: Bs,
  relaxedLabelInsideSpacing: Ts,
  hasRightInlineUi: $s,
  hasBottomInlineUi: Es,
  disabled: Ps,
  readOnly: As,
  lightMode: Ms,
  error: Os,
  warning: Fs,
  darkMode: Ws,
  InputFieldWrapper: zs,
  InputLabel: Ds,
  Input: Us,
  InputPlaceholder: Vs,
  InputBackgroundText: ks,
  raisedLabel: Hs,
  colorize: qs,
  autosize: js,
  focus: Ks,
  suggestions: Gs,
  monospace: Qs,
  Icon: Ys,
  InlineUi: Js,
  Prefix: Xs,
  Message: Zs
};
function J({
  style: e2,
  className: t2,
  element: n2,
  label: r2,
  icon: i,
  error: s2,
  reserveSpaceForMessage: c2,
  warning: a2,
  inlineUi: l2,
  labelInside: d2,
  placeholder: u2,
  monospace: m2,
  info: h2,
  prefix: g2
}) {
  var E2, b2, B2, I2, A2;
  const v2 = typeof ((E2 = n2 == null ? void 0 : n2.props) == null ? void 0 : E2.value) == "string" ? (b2 = n2 == null ? void 0 : n2.props) == null ? void 0 : b2.value : "", [L2, N2] = reactExports.useState(false);
  return reactExports.useEffect(() => {
    var w2;
    (w2 = n2 == null ? void 0 : n2.props) != null && w2.disabled && N2(false);
  }, [(B2 = n2 == null ? void 0 : n2.props) == null ? void 0 : B2.disabled]), /* @__PURE__ */ jsx(Tt, { value: v2, style: e2, className: t2, icon: i, label: r2, placeholder: u2, error: s2, reserveSpaceForMessage: c2, warning: a2, focus: L2, disabled: !!((I2 = n2 == null ? void 0 : n2.props) != null && I2.disabled), readOnly: !!((A2 = n2 == null ? void 0 : n2.props) != null && A2.readOnly), labelInside: d2, relaxedLabelInsideSpacing: (n2 == null ? void 0 : n2.type) === "textarea" || (n2 == null ? void 0 : n2.type) === "autosizeTextarea", monospace: m2, info: h2, prefix: g2, renderInputElement: (w2, R2, T2) => {
    if ((n2 == null ? void 0 : n2.type) === "textarea") {
      const {
        className: S2,
        onFocus: $,
        onBlur: U2,
        onChange: F2,
        ...K2
      } = n2.props ?? {};
      return /* @__PURE__ */ jsx("textarea", { ...K2, value: w2, className: classNames(R2, S2), onFocus: We(() => N2(true), $), onBlur: We(() => N2(false), U2), onChange: F2, id: T2 });
    }
    if ((n2 == null ? void 0 : n2.type) === "autosizeTextarea") {
      const {
        className: S2,
        onFocus: $,
        onBlur: U2,
        onChange: F2,
        ...K2
      } = n2.props ?? {};
      return /* @__PURE__ */ jsx(index, { ...K2, value: w2, className: classNames(R2, S2, V.autosize), onFocus: We(() => N2(true), $), onBlur: We(() => N2(false), U2), onChange: F2, id: T2 });
    }
    if (!n2 || n2.type === "input") {
      const {
        className: S2,
        onFocus: $,
        onBlur: U2,
        onChange: F2,
        ...K2
      } = (n2 == null ? void 0 : n2.props) ?? {};
      return /* @__PURE__ */ jsx("input", { ...K2, value: w2, className: classNames(R2, S2), onFocus: We(() => N2(true), $), onBlur: We(() => N2(false), U2), onChange: F2, id: T2, "data-lpignore": "true" });
    }
  }, inlineUi: l2 });
}
function We(e2, t2) {
  return t2 ? (n2) => {
    e2(n2), t2(n2);
  } : e2;
}
function Tt({
  className: e2,
  error: t2,
  reserveSpaceForMessage: n2,
  focus: r2,
  disabled: i,
  readOnly: s2,
  icon: c2,
  inlineUi: a2,
  label: l2,
  placeholder: d2,
  backgroundText: u2,
  style: m2,
  suggestions: h2,
  suggestionsVisible: g2,
  value: v2,
  warning: L2,
  renderInputElement: N2,
  labelInside: E2,
  relaxedLabelInsideSpacing: b2,
  monospace: B2,
  inputWrapperProps: I2,
  info: A2,
  prefix: w2
}) {
  const R2 = reactExports.useRef(newUuid$1()), T2 = classNames(V.Input, {
    [V.focus]: r2,
    [V.monospace]: B2
  }), [S2, {
    width: $
  }] = he(), U2 = {
    ...m2,
    "--inline-ui-width": a2 != null && a2.bottom ? "0px" : (a2 == null ? void 0 : a2.width) ?? "0px",
    "--inline-ui-height": a2 != null && a2.bottom ? (a2 == null ? void 0 : a2.height) ?? "0px" : "0px",
    "--prefix-width": `${$}px`
  }, F2 = !r2 && !v2 && !u2 && d2, K2 = r2 && !s2 || v2 || d2 || u2 || w2, j = Z();
  return /* @__PURE__ */ jsxs("div", { className: classNames(V.InputContainer, e2, {
    [V.hasRightInlineUi]: a2 && !a2.bottom,
    [V.hasBottomInlineUi]: a2 && a2.bottom,
    [V.raisedLabel]: K2,
    [V.disabled]: i,
    [V.readOnly]: s2,
    [V.error]: t2,
    [V.warning]: L2,
    [V.hasIcon]: c2,
    [V.colorize]: L2 || t2,
    [V.suggestions]: g2,
    [V.labelInside]: E2 || j === "dark" && l2,
    [V.relaxedLabelInsideSpacing]: b2,
    [V.lightMode]: j === "light",
    [V.darkMode]: j === "dark"
  }), style: U2, children: [
    /* @__PURE__ */ jsxs("div", { className: V.InputFieldWrapper, ...I2, children: [
      l2 && /* @__PURE__ */ jsx("label", { htmlFor: R2.current, className: V.InputLabel, children: l2 }),
      F2 && /* @__PURE__ */ jsx("span", { className: V.InputPlaceholder, children: d2 }),
      u2 && /* @__PURE__ */ jsx("span", { className: V.InputBackgroundText, children: u2 }),
      c2 && /* @__PURE__ */ jsx("div", { className: V.Icon, children: c2 }),
      N2 ? N2(v2, T2, R2.current) : /* @__PURE__ */ jsx("input", { className: T2, type: "text", value: v2, id: R2.current, "data-lpignore": "true" }),
      a2 && /* @__PURE__ */ jsx("div", { className: V.InlineUi, children: a2.node })
    ] }),
    w2 && /* @__PURE__ */ jsx("div", { className: V.Prefix, ref: S2, children: w2 }),
    h2,
    (typeof t2 == "string" || typeof L2 == "string" || A2 || n2) && /* @__PURE__ */ jsx("div", { className: V.Message, children: t2 || L2 || A2 })
  ] });
}
const ea = "_Dropdown_4ya18_1", ta = {
  Dropdown: ea
}, rn = React$1.forwardRef(({
  element: e2,
  className: t2,
  children: n2,
  ...r2
}, i) => /* @__PURE__ */ jsx(e2 ?? "div", { className: classNames(ta.Dropdown, t2), ref: i, ...r2, children: n2 })), na = "_fadeEnter_1q1f0_1", oa = "_fadeExit_1q1f0_5", ra = "_fadeEnterActive_1q1f0_9", ia = "_fadeExitActive_1q1f0_14", ft = {
  fadeEnter: na,
  fadeExit: oa,
  fadeEnterActive: ra,
  fadeExitActive: ia
}, xn = {
  enter: ft.fadeEnter,
  exit: ft.fadeExit,
  enterActive: ft.fadeEnterActive,
  exitActive: ft.fadeExitActive
};
function sn({
  children: e2,
  active: t2,
  className: n2
}) {
  return /* @__PURE__ */ jsx(hr, { className: n2, children: t2 ? /* @__PURE__ */ jsx(Ut, { classNames: xn, addEndListener: () => {
  }, children: e2.active }, t2 ? "b" : "a") : /* @__PURE__ */ jsx(Ut, { classNames: xn, addEndListener: () => {
  }, children: e2.default }, t2 ? "b" : "a") });
}
const sa = "_Wrapper_11r2k_1", aa = "_Action_11r2k_6 _UnstyledButton_14p2i_205", ca = "_inline_11r2k_21", la = "_ActionIcon_11r2k_32", da = "_OpenActionWrapper_11r2k_46", ua = "_Menu_11r2k_52", pa = "_dropdown_11r2k_67", fe = {
  Wrapper: sa,
  Action: aa,
  inline: ca,
  ActionIcon: la,
  OpenActionWrapper: da,
  Menu: ua,
  dropdown: pa
}, _a = "_HoverOverlay_te52q_1", ma = {
  HoverOverlay: _a
};
function lo({
  children: e2,
  downwards: t2,
  element: n2,
  overlay: r2,
  ariaLabel: i,
  ...s2
}) {
  const c2 = n2, [a2, l2] = reactExports.useState(false), {
    PositionedPortal: d2,
    updatePositioningElement: u2
  } = Ti({
    visible: a2,
    anchor: t2 ? {
      top: 1,
      left: 0.5
    } : {
      bottom: 1,
      left: 0.5
    },
    innerAnchor: {
      top: 0,
      left: 0.5
    },
    rootStyle: {
      zIndex: "100",
      pointerEvents: "none"
    }
  }), m2 = reactExports.useRef(), h2 = nn();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(c2, { "aria-label": i, ...s2, ref: u2, onMouseEnter: () => {
      m2.current = window.setTimeout(() => l2(true), 50);
    }, onMouseLeave: (g2) => {
      h2 && g2.altKey || (clearTimeout(m2.current), l2(false));
    }, children: e2 }),
    /* @__PURE__ */ jsx(d2, { children: /* @__PURE__ */ jsx("div", { "aria-hidden": true, className: classNames(ma.HoverOverlay), children: r2 }) })
  ] });
}
function uo({
  tooltip: e2,
  element: t2,
  ...n2
}) {
  return /* @__PURE__ */ jsx(lo, { ...n2, element: t2, overlay: e2, ariaLabel: e2 });
}
function po({
  actions: e2,
  maxInlineActions: t2,
  downwardsTooltips: n2
}) {
  let r2 = e2, i = [];
  return t2 && e2.length > t2 && (r2 = e2.slice(0, t2 - 1), i = e2.slice(t2 - 1)), /* @__PURE__ */ jsxs("div", { className: classNames(fe.Wrapper), children: [
    r2.map((s2) => /* @__PURE__ */ jsx(_o, { ...s2, downwardsTooltip: n2 })),
    i.length > 0 && /* @__PURE__ */ jsx(ha, { children: i.map((s2) => /* @__PURE__ */ jsx(fa, { ...s2 })) })
  ] });
}
function an(e2) {
  let t2 = e2.actions.length;
  return e2.maxInlineActions && e2.maxInlineActions < t2 && (t2 = e2.maxInlineActions), {
    node: /* @__PURE__ */ jsx(po, { ...e2 }),
    width: `${1.75 * t2 - 0.25}rem`,
    height: "1.5rem",
    bottom: e2.bottom
  };
}
function oe(e2) {
  const [t2, {
    width: n2
  }] = he();
  let r2;
  return n2 < 300 ? r2 = 1 : n2 < 400 && (r2 = 2), {
    ref: t2,
    inlineUi: an({
      actions: e2,
      maxInlineActions: r2
    })
  };
}
function _o({
  icon: e2,
  active: t2,
  activeIcon: n2,
  className: r2,
  activeClassName: i,
  element: s2,
  label: c2,
  activeLabel: a2,
  downwardsTooltip: l2
}) {
  var m2;
  const d2 = n2 ?? e2, u2 = t2 && a2 ? a2 : c2;
  return /* @__PURE__ */ jsx(uo, { element: s2.type, tooltip: u2, downwards: l2, ...s2.props, className: classNames(fe.Action, fe.inline, (m2 = s2.props) == null ? void 0 : m2.className), children: /* @__PURE__ */ jsx(sn, { active: t2, children: {
    default: /* @__PURE__ */ jsx(e2, { className: classNames(fe.ActionIcon, r2) }),
    active: /* @__PURE__ */ jsx(d2, { className: classNames(fe.ActionIcon, r2, i) })
  } }) });
}
function ha({
  children: e2
}) {
  const [t2, n2] = reactExports.useState(false), r2 = reactExports.useCallback(() => n2(false), []), i = reactExports.useRef(null);
  return on(i, r2), /* @__PURE__ */ jsxs("div", { className: fe.OpenActionWrapper, ref: i, children: [
    /* @__PURE__ */ jsx(_o, { element: {
      type: "button",
      props: {
        type: "button",
        onClick: () => n2(!t2)
      }
    }, label: i18n._(
      /*i18n*/
      {
        id: "2FYpfJ"
      }
    ), icon: SvgE7A3F077F365818E }, "more"),
    t2 && /* @__PURE__ */ jsx(rn, { element: "ul", className: fe.Menu, onClick: r2, children: e2 })
  ] });
}
function fa({
  icon: e2,
  element: t2,
  active: n2,
  activeIcon: r2,
  className: i,
  activeClassName: s2,
  label: c2,
  activeLabel: a2
}) {
  var m2;
  const l2 = n2 && r2 ? r2 : e2, d2 = n2 && a2 ? a2 : c2, u2 = t2.type;
  return /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsxs(u2, { ...t2.props, className: classNames(fe.Action, fe.dropdown, (m2 = t2.props) == null ? void 0 : m2.className), children: [
    /* @__PURE__ */ jsx(l2, { className: classNames(fe.ActionIcon, i, n2 && s2) }),
    d2
  ] }) });
}
const ga = "_Options_uim5e_1", ya = "_open_uim5e_14", va = "_darkMode_uim5e_18", Ca = "_colorize_uim5e_21", wa = "_overlay_uim5e_24", ba = "_Option_uim5e_1", Ia = "_OptionButton_uim5e_54 _Option_uim5e_1", Sa = "_highlighted_uim5e_58", Na = "_selected_uim5e_62", La = "_OptionInfo_uim5e_79 _Option_uim5e_1", ve = {
  Options: ga,
  open: ya,
  darkMode: va,
  colorize: Ca,
  overlay: wa,
  Option: ba,
  OptionButton: Ia,
  highlighted: Sa,
  selected: Na,
  OptionInfo: La
};
function mo({
  isOpen: e2,
  value: t2,
  colorize: n2,
  filteredOptions: r2,
  highlightedIndex: i,
  noMatchingOptionsText: s2,
  optionsOverlay: c2,
  getMenuProps: a2,
  getItemProps: l2,
  renderValueLabel: d2,
  valuesEqual: u2
}) {
  const m2 = Z();
  return /* @__PURE__ */ jsx("ul", { ...a2({
    className: classNames(ve.Options, {
      [ve.open]: e2,
      [ve.colorize]: n2,
      [ve.overlay]: c2,
      [ve.darkMode]: m2 === "dark"
    })
  }), children: e2 && (r2.length ? r2.map((h2, g2) => /* @__PURE__ */ jsx("li", { className: classNames(ve.OptionButton, {
    [ve.selected]: t2 && u2(h2, t2),
    [ve.highlighted]: i === g2
  }), ...l2({
    item: h2,
    index: g2
  }), children: d2(h2) }, g2)) : s2 && /* @__PURE__ */ jsx("li", { className: ve.OptionInfo, children: s2 }, "empty")) });
}
const xa = "_ClearButton_m0igx_1 _UnstyledButton_14p2i_205", Ra = "_Container_m0igx_11", Rn = {
  ClearButton: xa,
  Container: Ra
};
function Ba({
  value: e2,
  options: t2,
  noMatchingOptionsText: n2,
  getValueLabel: r2,
  getValueIconNode: i,
  valuesEqual: s2,
  onFocus: c2,
  onBlur: a2,
  autoFocus: l2,
  className: d2,
  style: u2,
  error: m2,
  warning: h2,
  disabled: g2,
  readOnly: v2,
  label: L2,
  labelInside: N2,
  optionsOverlay: E2,
  inlineUi: b2,
  // keep these props together since they form a correlated union with clearable
  ...B2
}) {
  const [I2, A2] = reactExports.useState(""), w2 = reactExports.useRef(null), [R2, T2] = reactExports.useState(t2), {
    isOpen: S2,
    getMenuProps: $,
    getInputProps: U2,
    getComboboxProps: F2,
    highlightedIndex: K2,
    getItemProps: j,
    openMenu: ie2
  } = useCombobox({
    items: R2,
    inputValue: I2,
    selectedItem: e2 ?? null,
    itemToString: (k2) => k2 ? r2(k2) : "",
    onSelectedItemChange: ({
      selectedItem: k2
    }) => {
      B2.clearable ? (B2.onChange(k2 ?? void 0), A2("")) : k2 && (B2.onChange(k2), A2(""));
    },
    onStateChange: (k2) => {
      k2.type === useCombobox.stateChangeTypes.InputChange && A2(k2.inputValue ?? "");
    }
  });
  reactExports.useEffect(() => {
    const k2 = I2.toLowerCase().trim();
    if (!k2) {
      T2(t2);
      return;
    }
    T2(t2.filter((Ie2) => r2(Ie2).toLowerCase().includes(k2)));
  }, [r2, I2, t2]);
  const [ue2, Pe2] = reactExports.useState(false);
  return /* @__PURE__ */ jsx(Tt, { focus: ue2, disabled: !!g2, readOnly: !!v2, className: classNames(Rn.Container, d2), style: u2, error: S2 ? void 0 : m2, warning: S2 ? void 0 : h2, label: L2, labelInside: N2, value: I2, icon: e2 ? i == null ? void 0 : i(e2) : void 0, backgroundText: !I2 && e2 ? r2(e2) : void 0, inputWrapperProps: F2(), renderInputElement: (k2, Ie2, Je2) => /* @__PURE__ */ jsx("input", { ...U2({
    id: Je2,
    onFocus: () => {
      !S2 && !v2 && !g2 && ie2(), c2 == null || c2(), Pe2(true);
    },
    onBlur: () => {
      a2 == null || a2(), Pe2(false);
    },
    onKeyDown: (W2) => {
      (W2.key === "ArrowDown" || W2.key === "ArrowUp") && !S2 && (W2.preventDownshiftDefault = true), W2.key === "Enter" && !g2 && !v2 && (S2 ? R2.length && (W2.preventDefault(), B2.onChange(R2[0])) : (W2.preventDefault(), ie2()));
    },
    onClick: () => {
      !S2 && !g2 && !v2 && ie2();
    },
    type: "text",
    disabled: g2,
    readOnly: v2,
    autoFocus: l2,
    className: Ie2,
    ref: w2
  }), "data-lpignore": "true" }), suggestionsVisible: S2, suggestions: /* @__PURE__ */ jsx(mo, { isOpen: S2, value: e2, colorize: !!(h2 || m2), filteredOptions: R2, highlightedIndex: K2, noMatchingOptionsText: n2, optionsOverlay: E2, getMenuProps: $, getItemProps: j, valuesEqual: s2, renderValueLabel: (k2) => /* @__PURE__ */ jsx(Ta, { option: k2, getValueLabel: r2, getValueIconNode: i }) }), inlineUi: I2 || e2 !== void 0 && B2.clearable ? {
    node: /* @__PURE__ */ jsx("button", { type: "button", className: Rn.ClearButton, onClick: () => {
      var k2;
      A2(""), ie2(), B2.clearable && B2.onChange(void 0), (k2 = w2.current) == null || k2.focus();
    }, children: /* @__PURE__ */ jsx(Svg1Bcfd951Ee5Cd05C, { title: i18n._(
      /*i18n*/
      {
        id: "xCJdfg"
      }
    ) }) }),
    width: "1rem"
  } : b2 });
}
function Ta({
  option: e2,
  getValueLabel: t2,
  getValueIconNode: n2
}) {
  return n2 ? /* @__PURE__ */ jsxs(Fragment, { children: [
    n2(e2),
    " ",
    t2(e2)
  ] }) : /* @__PURE__ */ jsx(Fragment, { children: t2(e2) });
}
const $a = "_Loading_rnsnm_1", Ea = {
  Loading: $a
}, Pa = "_Spinner_1gk9j_1", Aa = {
  Spinner: Pa,
  "lds-spinner": "_lds-spinner_1gk9j_1"
};
function $t({
  size: e2,
  armCount: t2 = 12,
  animationDurationMs: n2 = 1e3,
  armWidth: r2 = 0.075,
  armHeight: i = 0.25,
  armCornerRadius: s2 = 0.03
}) {
  return /* @__PURE__ */ jsx("div", { className: Aa.Spinner, style: {
    // @ts-ignore
    "--size": e2,
    "--animation-duration": `${n2}ms`,
    "--arm-width": r2,
    "--arm-height": i,
    "--arm-corner-radius": s2
  }, children: Array(t2).fill(void 0).map((c2, a2) => /* @__PURE__ */ jsx("div", { style: {
    // @ts-ignore
    "--rotate": `${a2 / t2}turn`,
    animationDelay: `${-n2 + (a2 + 1) * n2 / t2}ms`
  } }, `${t2}-${a2}`)) });
}
function wh({
  className: e2,
  ...t2
}) {
  return /* @__PURE__ */ jsx("div", { className: classNames(Ea.Loading, e2), ...t2, children: /* @__PURE__ */ jsx($t, { size: "80px" }) });
}
const Ma = "_TotpCountdown_1qwcq_1", Oa = "_hidden_1qwcq_11", Fa = "_darkMode_1qwcq_21", Wa = "_finishing_1qwcq_35", za = "_starting_1qwcq_49", it = {
  TotpCountdown: Ma,
  hidden: Oa,
  darkMode: Fa,
  finishing: Wa,
  "flicker-animation": "_flicker-animation_1qwcq_1",
  starting: za
};
function Da({
  percent: e2,
  hidden: t2
}) {
  const n2 = Z();
  return /* @__PURE__ */ jsx(CircularProgressbar, { value: 100 - e2, strokeWidth: 50, className: classNames(it.TotpCountdown, {
    [it.finishing]: e2 >= 84,
    [it.starting]: e2 < 2,
    [it.darkMode]: n2 === "dark",
    [it.hidden]: !!t2
  }), counterClockwise: true });
}
const Ua = "_CopyButton_x6l9h_1", Va = "_success_x6l9h_27", ka = "_Icon_x6l9h_35", Ha = "_Content_x6l9h_52", ze = {
  CopyButton: Ua,
  success: Va,
  Icon: ka,
  Content: Ha
};
function qa({
  onClick: e2,
  className: t2,
  success: n2,
  defaultIcon: r2,
  defaultText: i,
  successText: s2,
  successIcon: c2,
  disabled: a2
}) {
  const l2 = r2, d2 = c2 ?? r2;
  return /* @__PURE__ */ jsx("button", { className: classNames(ze.CopyButton, t2), onClick: e2, type: "button", disabled: a2, children: /* @__PURE__ */ jsx(sn, { active: n2, children: {
    active: /* @__PURE__ */ jsxs("div", { className: classNames(ze.Content, ze.success), children: [
      /* @__PURE__ */ jsx("div", { className: ze.Icon, children: /* @__PURE__ */ jsx(d2, {}) }),
      /* @__PURE__ */ jsx("p", { children: s2 ?? i })
    ] }),
    default: /* @__PURE__ */ jsxs("div", { className: ze.Content, children: [
      /* @__PURE__ */ jsx("div", { className: ze.Icon, children: /* @__PURE__ */ jsx(l2, {}) }),
      /* @__PURE__ */ jsx("p", { children: i })
    ] })
  } }) });
}
function ja({
  onClick: e2,
  className: t2,
  copied: n2,
  disabled: r2
}) {
  return /* @__PURE__ */ jsx(qa, { className: t2, success: n2, defaultText: i18n._(
    /*i18n*/
    {
      id: "he3ygx"
    }
  ), defaultIcon: Svg32192847008Cf9Fc, successText: i18n._(
    /*i18n*/
    {
      id: "6V3Ea3"
    }
  ), successIcon: SvgB1C9Ac3221E94B98, onClick: e2, disabled: r2 });
}
const Ka = "_ArrowIcon_xe8or_1", gt = {
  ArrowIcon: Ka
}, cn = React$1.forwardRef(({
  direction: e2,
  className: t2,
  ...n2
}, r2) => e2 === "up" ? /* @__PURE__ */ jsx(SvgEd18499E3448Aad6, { ref: r2, className: classNames(gt.ArrowIcon, t2), ...n2 }) : e2 === "right" ? /* @__PURE__ */ jsx(Svg1B8Acf1Cc5Bb7E55, { ref: r2, className: classNames(gt.ArrowIcon, t2), ...n2 }) : e2 === "down" ? /* @__PURE__ */ jsx(Svg46Dde8092160Efa1, { ref: r2, className: classNames(gt.ArrowIcon, t2), ...n2 }) : /* @__PURE__ */ jsx(SvgFca912Dd1Ab82474, { ref: r2, className: classNames(gt.ArrowIcon, t2), ...n2 }));
const Xa = "_LinkButton_1w1ip_1 _UnstyledButton_14p2i_205", Za = {
  LinkButton: Xa
};
function Ge({
  className: e2,
  children: t2,
  ...n2
}) {
  return /* @__PURE__ */ jsx("button", { className: classNames(Za.LinkButton, e2), ...n2, children: t2 });
}
const ec = "_MessageBox_1pt86_1", tc = "_large_1pt86_21", nc = "_hasClose_1pt86_24", oc = "_success_1pt86_27", rc = "_warning_1pt86_31", ic = "_error_1pt86_35", sc = "_dark_1pt86_39", ac = "_light_1pt86_40", cc = "_highlight_1pt86_40", lc = "_hidden_1pt86_43", dc = "_Content_1pt86_57", uc = "_SmallIcon_1pt86_61", pc = "_SmallContent_1pt86_72", _c = "_LargeIcon_1pt86_83", mc = "_LargeText_1pt86_93", hc = "_LargeHeadline_1pt86_99", fc = "_LargeContent_1pt86_109", gc = "_Close_1pt86_127 _UnstyledButton_14p2i_205", Y = {
  MessageBox: ec,
  large: tc,
  hasClose: nc,
  success: oc,
  warning: rc,
  error: ic,
  dark: sc,
  light: ac,
  highlight: cc,
  hidden: lc,
  Content: dc,
  SmallIcon: uc,
  SmallContent: pc,
  LargeIcon: _c,
  LargeText: mc,
  LargeHeadline: hc,
  LargeContent: fc,
  Close: gc
};
function ct(e2) {
  const {
    sizeProps: t2,
    restProps: n2
  } = yc(e2), {
    hidden: r2,
    type: i,
    onClose: s2,
    className: c2,
    children: a2,
    style: l2,
    contentClassName: d2,
    ...u2
  } = n2, m2 = Z(), h2 = Ye(), [g2, v2] = he();
  return /* @__PURE__ */ jsxs("div", { className: classNames(Y.MessageBox, i && Y[i], Y[m2], Y[h2], c2, {
    [Y.hidden]: r2,
    [Y.large]: t2.large,
    [Y.hasClose]: !!s2
  }), "aria-hidden": r2, style: {
    ...l2,
    "--content-height": v2.height > 0 ? `${v2.height}px` : "auto"
  }, ...u2, children: [
    /* @__PURE__ */ jsx("div", { className: Y.Content, ref: g2, children: t2.large ? /* @__PURE__ */ jsx(Cc, { headline: t2.headline, icon: t2.icon, contentClassName: d2, children: a2 }) : /* @__PURE__ */ jsx(vc, { type: i, noDefaultIcon: t2.noDefaultIcon, contentClassName: d2, children: a2 }) }),
    s2 && /* @__PURE__ */ jsx("button", { type: "button", onClick: s2, className: Y.Close, children: /* @__PURE__ */ jsx(Svg85901Eed410D7B8F, { "aria-label": i18n._(
      /*i18n*/
      {
        id: "yz7wBu"
      }
    ) }) })
  ] });
}
function yc(e2) {
  if (e2.large) {
    const {
      large: i,
      headline: s2,
      icon: c2,
      ...a2
    } = e2;
    return {
      sizeProps: {
        large: i,
        headline: s2,
        icon: c2
      },
      restProps: a2
    };
  }
  const {
    large: t2,
    noDefaultIcon: n2,
    ...r2
  } = e2;
  return {
    sizeProps: {
      large: t2,
      noDefaultIcon: n2
    },
    restProps: r2
  };
}
function vc({
  type: e2,
  noDefaultIcon: t2,
  children: n2,
  contentClassName: r2
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    !t2 && (e2 === "success" ? /* @__PURE__ */ jsx(Svg4Be4720676Aebafd, { className: Y.SmallIcon }) : e2 === "warning" || e2 === "error" ? /* @__PURE__ */ jsx(Svg639E0321C796A6Fd, { className: Y.SmallIcon }) : e2 === "progress" ? /* @__PURE__ */ jsx("div", { className: Y.SmallIcon, children: /* @__PURE__ */ jsx($t, { size: "1rem", armCount: 10, armWidth: 0.15, armHeight: 0.3 }) }) : null),
    /* @__PURE__ */ jsx("div", { className: classNames(Y.SmallContent, r2), children: n2 })
  ] });
}
function Cc({
  headline: e2,
  icon: t2,
  children: n2,
  contentClassName: r2
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    t2 && /* @__PURE__ */ jsx(t2, { className: Y.LargeIcon }),
    /* @__PURE__ */ jsxs("div", { className: Y.LargeText, children: [
      /* @__PURE__ */ jsx("p", { className: Y.LargeHeadline, children: /* @__PURE__ */ jsx("strong", { children: e2 }) }),
      /* @__PURE__ */ jsx("p", { className: classNames(Y.LargeContent, r2), children: n2 })
    ] })
  ] });
}
function wc({
  children: e2,
  message: t2,
  recheck: n2,
  hidden: r2,
  onRecheckSuccess: i,
  ...s2
}) {
  const [c2, a2] = reactExports.useState(), l2 = reactExports.useCallback(async () => {
    if (n2)
      try {
        a2("inProgress"), await Promise.all([n2(), sleep(2e3)]), a2("done");
      } catch {
        a2(void 0);
      }
  }, [n2]);
  return reactExports.useEffect(() => {
    if (c2 === "done")
      a2(r2 ? "showSuccess" : void 0);
    else if (c2 === "showSuccess") {
      const d2 = window.setTimeout(() => a2("hideSuccess"), 2e3);
      return () => window.clearTimeout(d2);
    }
  }, [r2, i, c2]), c2 === "inProgress" ? /* @__PURE__ */ jsx(ct, { type: "progress", ...s2, children: /* @__PURE__ */ jsx(Trans, { id: "2SqvU5" }) }) : c2 === "showSuccess" || c2 === "hideSuccess" ? /* @__PURE__ */ jsx(ct, { ...s2, type: "success", hidden: c2 === "hideSuccess", onTransitionEnd: () => {
    a2(void 0), i == null || i();
  }, children: /* @__PURE__ */ jsx(Trans, { id: "J8XjuC" }) }) : /* @__PURE__ */ jsxs(ct, { ...s2, type: "warning", hidden: r2, children: [
    t2,
    " ",
    n2 && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => {
        l2().catch(trackError);
      }, children: /* @__PURE__ */ jsx(Trans, { id: "3WxAes" }) }),
      " "
    ] }),
    e2
  ] });
}
function ho(e2) {
  return /* @__PURE__ */ jsx(wc, { message: i18n._(
    /*i18n*/
    {
      id: "HqgpzW"
    }
  ), ...e2 });
}
function Bn(e2) {
  return e2 = e2.replaceAll("\\", "\\\\"), e2 = e2.replaceAll(":", "\\:"), e2 = e2.replaceAll(";", "\\;"), e2 = e2.replaceAll(",", "\\,"), e2;
}
function bc(e2, t2) {
  return reactExports.useMemo(() => {
    let n2 = "WIFI:";
    return n2 += "T:WPA;", n2 += `S:${Bn(e2)};`, n2 += `P:${Bn(t2)};`, n2 += ";", n2;
  }, [e2, t2]);
}
function ut(e2, t2) {
  return {
    action: {
      icon: SvgE29A75303Cd009Cd,
      label: i18n._(
        /*i18n*/
        {
          id: "cnGeoo"
        }
      ),
      key: "delete",
      element: {
        type: "button",
        props: {
          type: "button",
          onClick: e2,
          ...t2
        }
      }
    }
  };
}
const Ic = "_FormInputPlaceholder_aibmw_1", Sc = "_ButtonWrapper_aibmw_8", Nc = "_hasInlineUi_aibmw_19", Lc = "_HiddenValuePill_aibmw_23 _UnstyledButton_14p2i_205", xc = "_dark_aibmw_40", Rc = "_HeyloginIcon_aibmw_43", Bc = "_PillText_aibmw_54", Tc = "_InlineUi_aibmw_64", Se = {
  FormInputPlaceholder: Ic,
  ButtonWrapper: Sc,
  hasInlineUi: Nc,
  HiddenValuePill: Lc,
  dark: xc,
  HeyloginIcon: Rc,
  PillText: Bc,
  InlineUi: Tc
}, Qe = React$1.forwardRef(({
  inlineUi: e2,
  onButtonClick: t2,
  changed: n2,
  children: r2,
  className: i,
  style: s2,
  ...c2
}, a2) => {
  const l2 = Z(), d2 = l2 === "light" ? Svg92Beb0D5816827F1 : Svg79403247197Ec9Cd;
  return /* @__PURE__ */ jsxs("div", { className: classNames(Se.FormInputPlaceholder, Se[l2], {
    [Se.hasInlineUi]: e2
  }, i), style: {
    "--inline-ui-width": (e2 == null ? void 0 : e2.width) ?? 0,
    ...s2
  }, ...c2, children: [
    /* @__PURE__ */ jsx("div", { className: Se.ButtonWrapper, ref: a2, children: /* @__PURE__ */ jsxs("button", { type: "button", className: Se.HiddenValuePill, onClick: t2, children: [
      /* @__PURE__ */ jsx(d2, { className: Se.HeyloginIcon }),
      /* @__PURE__ */ jsxs("span", { className: Se.PillText, children: [
        r2,
        n2 && /* @__PURE__ */ jsxs(Fragment, { children: [
          " ",
          /* @__PURE__ */ jsx(Trans, { id: "d/ZbMk" })
        ] })
      ] })
    ] }) }),
    e2 && /* @__PURE__ */ jsx("div", { className: Se.InlineUi, children: e2.node })
  ] });
});
function fo({
  suggestions: e2,
  applySuggestion: t2,
  inputProps: n2,
  inlineUi: r2,
  optionsOverlay: i,
  onInputEnter: s2,
  renderSuggestionValueLabel: c2,
  ...a2
}) {
  const l2 = reactExports.useRef(null), d2 = typeof n2.value == "string" ? n2.value : "", [u2, m2] = reactExports.useState(e2), {
    isOpen: h2,
    getMenuProps: g2,
    getInputProps: v2,
    getComboboxProps: L2,
    highlightedIndex: N2,
    getItemProps: E2,
    openMenu: b2,
    closeMenu: B2
  } = useCombobox({
    items: u2,
    inputValue: d2,
    selectedItem: d2,
    itemToString: (R2) => R2 ?? "",
    onSelectedItemChange: ({
      selectedItem: R2
    }) => {
      R2 && t2(R2);
    }
  }), I2 = h2 && u2.length > 0;
  reactExports.useEffect(() => {
    const R2 = d2.toLowerCase().trim();
    if (!R2) {
      m2(e2);
      return;
    }
    m2(e2.filter((T2) => T2.toLowerCase().includes(R2)));
  }, [e2, d2]);
  const [A2, w2] = reactExports.useState(false);
  return /* @__PURE__ */ jsx(Tt, { ...a2, focus: A2, disabled: !!(n2 != null && n2.disabled), readOnly: !!(n2 != null && n2.readOnly), value: d2, inputWrapperProps: L2(), renderInputElement: (R2, T2, S2) => /* @__PURE__ */ jsx("input", { ...v2({
    ...n2,
    id: S2,
    onFocus: ($) => {
      var U2;
      (U2 = n2 == null ? void 0 : n2.onFocus) == null || U2.call(n2, $), !$.defaultPrevented && (!h2 && !n2.readOnly && !n2.disabled && b2(), w2(true));
    },
    onBlur: ($) => {
      var U2;
      (U2 = n2 == null ? void 0 : n2.onBlur) == null || U2.call(n2, $), !$.defaultPrevented && w2(false);
    },
    onKeyDown: ($) => {
      var U2;
      if ($.key === "Enter" && s2 && (!I2 || N2 === -1)) {
        const F2 = s2();
        if (F2 != null && F2.closeMenu && B2(), F2 != null && F2.preventDefault) {
          $.preventDefault();
          return;
        }
      }
      (U2 = n2 == null ? void 0 : n2.onKeyDown) == null || U2.call(n2, $), !$.defaultPrevented && (($.key === "ArrowDown" || $.key === "ArrowUp" || $.key === "Home" || $.key === "End") && !I2 && ($.preventDownshiftDefault = true), $.key === "Enter" && !n2.readOnly && !n2.disabled && (h2 ? u2.length && N2 === -1 && ($.preventDefault(), t2(u2[0]), B2()) : ($.preventDefault(), b2())));
    },
    onClick: () => {
      !h2 && !n2.readOnly && !n2.disabled && b2();
    },
    className: T2,
    ref: l2
  }), "data-lpignore": "true" }), suggestionsVisible: I2, suggestions: /* @__PURE__ */ jsx(mo, { isOpen: I2, value: d2, colorize: !!(a2.warning || a2.error), filteredOptions: u2, highlightedIndex: N2, optionsOverlay: i, getMenuProps: g2, getItemProps: E2, valuesEqual: (R2, T2) => R2 === T2, renderValueLabel: c2 ?? ((R2) => /* @__PURE__ */ jsx(Fragment, { children: R2 })) }), inlineUi: r2 });
}
const $c = "_QrCodeWrapper_7qr4w_1", Ec = "_QrCode_7qr4w_1", $n = {
  QrCodeWrapper: $c,
  QrCode: Ec
};
function Pc({
  data: e2,
  inlineUi: t2,
  className: n2
}) {
  return /* @__PURE__ */ jsx(Tt, { value: e2, readOnly: true, disabled: false, focus: false, inlineUi: t2, className: n2, renderInputElement: (r2, i, s2) => /* @__PURE__ */ jsx("div", { className: classNames(i, $n.QrCodeWrapper), children: /* @__PURE__ */ jsx(Mr, { className: $n.QrCode, value: r2, renderAs: "svg", bgColor: "transparent", fgColor: "currentColor", id: s2 }) }) });
}
const Ac = "_Button_m6o5o_1 _UnstyledButton_14p2i_205", Mc = "_TextWrapper_m6o5o_12", Oc = "_Text_m6o5o_12", yt = {
  Button: Ac,
  TextWrapper: Mc,
  Text: Oc
};
function Fc({
  onClick: e2,
  visible: t2,
  label: n2,
  successLabel: r2,
  className: i
}) {
  const [s2, c2] = reactExports.useState(false), a2 = reactExports.useRef(), l2 = reactExports.useCallback((d2) => {
    window.clearTimeout(a2.current), e2(d2), c2(true), a2.current = window.setTimeout(() => c2(false), 2e3);
  }, [e2]);
  return !s2 && !t2 ? null : /* @__PURE__ */ jsx("button", { type: "button", className: classNames(yt.Button, i), onClick: l2, children: /* @__PURE__ */ jsx(sn, { active: s2, className: yt.TextWrapper, children: {
    active: /* @__PURE__ */ jsxs("span", { className: yt.Text, children: [
      /* @__PURE__ */ jsx(SvgB1C9Ac3221E94B98, {}),
      r2
    ] }),
    default: /* @__PURE__ */ jsx("span", { className: yt.Text, children: n2 })
  } }) });
}
const Wc = "_PasswordGenerator_fvzwp_1", zc = "_leaked_fvzwp_15", Dc = "_darkMode_fvzwp_19", Uc = "_PasswordInput_fvzwp_27", Vc = "_OptionsGroup_fvzwp_31", kc = "_SwitchGroup_fvzwp_35", Hc = "_OptionSwitch_fvzwp_44", qc = "_Switch_fvzwp_35", jc = "_PasswordInfo_fvzwp_64", Kc = "_StrengthIndication_fvzwp_76", Gc = "_NumberOfCharacters_fvzwp_81", Qc = "_NumberOfCharactersInternal_fvzwp_87", Yc = "_SubmitButton_fvzwp_98", Jc = "_CancelButton_fvzwp_102", G = {
  PasswordGenerator: Wc,
  leaked: zc,
  darkMode: Dc,
  PasswordInput: Uc,
  OptionsGroup: Vc,
  SwitchGroup: kc,
  OptionSwitch: Hc,
  Switch: qc,
  PasswordInfo: jc,
  StrengthIndication: Kc,
  NumberOfCharacters: Gc,
  NumberOfCharactersInternal: Qc,
  SubmitButton: Yc,
  CancelButton: Jc
};
function qt({
  close: e2,
  writeToClipboard: t2,
  apply: n2,
  changeSettings: r2,
  editPassword: i,
  className: s2,
  oldPassword: c2,
  hideButtons: a2,
  hideNewPasswordLabel: l2,
  newPasswordLabel: d2,
  oldPasswordLabel: u2,
  settings: m2,
  password: h2,
  strengthIndication: g2,
  error: v2,
  saveSettings: L2,
  savedSettings: N2,
  onNewPasswordBlur: E2,
  leakedPasswordCheckStatus: b2
}) {
  const B2 = reactExports.useMemo(() => {
    const w2 = N2 ?? ln;
    return w2.length !== m2.length || w2.letters !== m2.letters || w2.numbers !== m2.numbers || w2.special !== m2.special;
  }, [N2, m2]), I2 = Z(), A2 = (b2 == null ? void 0 : b2.status) === "checked" && b2.leakCount > 0;
  return /* @__PURE__ */ jsxs("div", { className: classNames(G.PasswordGenerator, {
    [G.darkMode]: I2 === "dark",
    [G.leaked]: !!A2
  }, s2), children: [
    c2 && /* @__PURE__ */ jsx(En, { element: {
      type: "input",
      props: {
        value: c2,
        disabled: true,
        autoComplete: "off",
        autoCapitalize: "off",
        autoCorrect: "off"
      }
    }, labelInside: true, label: u2 ?? i18n._(
      /*i18n*/
      {
        id: "CqOvzI"
      }
    ), className: G.PasswordInput, writeToClipboard: (w2) => t2(w2, true), monospace: true }),
    /* @__PURE__ */ jsx(En, { element: {
      type: "input",
      props: {
        value: h2,
        onChange: (w2) => i(w2.target.value),
        autoComplete: "off",
        autoCapitalize: "off",
        autoCorrect: "off",
        onKeyDown: (w2) => {
          !a2 && w2.key === "Enter" && (n2 == null || n2());
        },
        onBlur: (w2) => E2 == null ? void 0 : E2(w2.currentTarget.value)
      }
    }, labelInside: !l2, label: l2 ? void 0 : d2 ?? i18n._(
      /*i18n*/
      {
        id: "/nT6AE"
      }
    ), className: G.PasswordInput, writeToClipboard: (w2) => t2(w2, true), error: v2 ?? A2, monospace: true }),
    /* @__PURE__ */ jsxs("div", { className: G.PasswordInfo, children: [
      /* @__PURE__ */ jsx(TransitionFade, { children: g2 !== null && /* @__PURE__ */ jsx("span", { className: G.StrengthIndication, children: g2 }) }),
      /* @__PURE__ */ jsx(Fc, { label: i18n._(
        /*i18n*/
        {
          id: "/zWqH6"
        }
      ), successLabel: i18n._(
        /*i18n*/
        {
          id: "idD8Ev"
        }
      ), onClick: () => L2(m2), visible: B2 && vo(m2) })
    ] }),
    /* @__PURE__ */ jsx(Xc, { value: m2, onChange: r2 }),
    !a2 && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(co, { element: "button", type: "button", onClick: n2, className: G.SubmitButton, children: /* @__PURE__ */ jsx(Trans, { id: "DB8zMK" }) }),
      /* @__PURE__ */ jsx(be, { type: "button", buttonStyle: "tertiary", size: "small", className: G.CancelButton, onClick: e2, children: /* @__PURE__ */ jsx(Trans, { id: "dEgA5A" }) })
    ] })
  ] });
}
const ln = {
  length: 16,
  letters: true,
  numbers: true,
  special: true
};
function dn(e2) {
  const t2 = e2 ?? ln;
  return tn(t2.length, t2.letters, t2.letters, t2.numbers, t2.special).value;
}
function go({
  password: e2,
  setPassword: t2,
  initialSettings: n2,
  initialGeneratedPassword: r2,
  onSettingsChange: i
}) {
  const [s2, c2] = reactExports.useState(n2 ?? ln), [a2, l2] = reactExports.useState(r2), u2 = Zc(e2 !== a2, s2, e2), m2 = reactExports.useCallback((g2) => {
    if (!deepEqual$1(s2, g2))
      if (c2(g2), un(g2)) {
        const v2 = tn(g2.length, g2.letters, g2.letters, g2.numbers, g2.special);
        t2(v2.value), l2(v2.value), i == null || i(v2.value);
      } else
        t2(""), l2(void 0), i == null || i("");
  }, [i, t2, s2]), h2 = reactExports.useCallback((g2, v2) => {
    t2(g2), v2 && l2(g2);
  }, [t2]);
  return {
    changeSettings: m2,
    editPassword: h2,
    password: e2,
    strengthIndication: u2,
    settings: s2
  };
}
function yo({
  initialValue: e2,
  initialSettings: t2,
  onChange: n2,
  onSettingsChange: r2
}) {
  const [i] = reactExports.useState(() => e2 || dn(t2)), [s2, c2] = reactExports.useState(() => i), a2 = reactExports.useCallback((l2) => {
    c2(l2), n2 == null || n2(l2);
  }, [n2]);
  return go({
    password: s2,
    setPassword: a2,
    initialSettings: t2,
    initialGeneratedPassword: i,
    onSettingsChange: r2
  });
}
function Xc({
  value: e2,
  onChange: t2
}) {
  const [r2, i] = reactExports.useState(`${e2.length}`), s2 = reactExports.useCallback((d2) => {
    const u2 = parseInt(d2, 10), m2 = un({
      ...e2,
      length: u2
    }) && u2 <= 999;
    i(d2), t2({
      ...e2,
      length: m2 ? u2 : e2.length
    });
  }, [e2, t2]), c2 = reactExports.useCallback(() => {
    const d2 = parseInt(r2, 10), u2 = Math.min(Math.max(bt(e2), isNaN(d2) ? 0 : d2), 999);
    i(`${u2}`), t2({
      ...e2,
      length: u2
    });
  }, [r2, t2, e2]), a2 = reactExports.useCallback((d2) => {
    const u2 = (N2, E2) => N2 !== E2, m2 = u2(d2 === "letters", e2.letters), h2 = u2(d2 === "numbers", e2.numbers), g2 = u2(d2 === "special", e2.special), v2 = parseInt(r2, 10), L2 = Math.max(bt({
      ...e2,
      letters: m2,
      numbers: h2,
      special: g2
    }), v2);
    i(`${L2}`), t2({
      ...e2,
      letters: m2,
      numbers: h2,
      special: g2,
      length: L2
    });
  }, [r2, t2, e2]), l2 = /* @__PURE__ */ jsx(Fragment, { children: "‑" });
  return /* @__PURE__ */ jsxs("div", { className: G.OptionsGroup, children: [
    /* @__PURE__ */ jsxs("div", { className: G.SwitchGroup, children: [
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsxs("label", { className: G.OptionSwitch, children: [
        /* @__PURE__ */ jsx(at, { checked: e2.numbers, onChange: () => a2("numbers"), className: G.Switch }),
        "0",
        l2,
        "9"
      ] }) }),
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsxs("label", { className: G.OptionSwitch, children: [
        /* @__PURE__ */ jsx(at, { checked: e2.letters, onChange: () => a2("letters"), className: G.Switch }),
        "A",
        l2,
        "Z a",
        l2,
        "z"
      ] }) }),
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsxs("label", { className: G.OptionSwitch, children: [
        /* @__PURE__ */ jsx(at, { checked: e2.special, onChange: () => a2("special"), className: G.Switch }),
        "#@$"
      ] }) })
    ] }),
    /* @__PURE__ */ jsx(J, { element: {
      type: "input",
      props: {
        type: "number",
        value: r2,
        min: bt(e2),
        max: 999,
        onChange: (d2) => s2(d2.target.value),
        onBlur: c2,
        className: G.NumberOfCharactersInternal,
        // show numeric keypad on ios: https://stackoverflow.com/a/27538989
        pattern: "[0-9]*"
      }
    }, label: i18n._(
      /*i18n*/
      {
        id: "NC2AI2"
      }
    ), labelInside: true, className: G.NumberOfCharacters })
  ] });
}
function En({
  writeToClipboard: e2,
  labelInside: t2,
  ...n2
}) {
  const [r2, i] = reactExports.useState(false), s2 = reactExports.useCallback(() => {
    e2(n2.element.props.value), i(true);
    const c2 = window.setTimeout(() => i(false), 1e3);
    return () => window.clearTimeout(c2);
  }, [e2, n2.element.props.value]);
  return /* @__PURE__ */ jsx(J, { ...n2, labelInside: t2, inlineUi: {
    node: /* @__PURE__ */ jsx(ja, { copied: r2, onClick: s2 }),
    width: "3.25rem"
  } });
}
function bt(e2) {
  return (e2.numbers ? 1 : 0) + (e2.letters ? 2 : 0) + (e2.special ? 1 : 0);
}
function vo(e2) {
  return un(e2) && e2.length >= 12 && e2.letters;
}
function un(e2) {
  return e2.length >= bt(e2) && (e2.letters || e2.numbers || e2.special);
}
function Zc(e2, t2, n2) {
  return reactExports.useMemo(() => pn(n2) ? i18n._(
    /*i18n*/
    {
      id: "sXULwc"
    }
  ) : !e2 && vo(t2) ? i18n._(
    /*i18n*/
    {
      id: "FLkaGY"
    }
  ) : "", [e2, n2, t2]);
}
function pn(e2) {
  return /^\d+$/.exec(e2) !== null;
}
const el = "_LoginEdit_yxwvf_1", tl = "_MovedLoginHint_yxwvf_7", nl = "_movedLogin_yxwvf_15", ol = "_Main_yxwvf_15", rl = "_Preform_yxwvf_20", il = "_FormElement_yxwvf_28", sl = "_FormGroup_yxwvf_33", al = "_TotpCustomField_yxwvf_52", cl = "_TotpLabel_yxwvf_58", ll = "_TotpInput_yxwvf_63", dl = "_TotpCodeContainer_yxwvf_68", ul = "_TotpValue_yxwvf_80", pl = "_AndroidAppIcon_yxwvf_93", _l = "_FormElementInfoLine_yxwvf_100", ml = "_RelatedDomains_yxwvf_111", hl = "_AddElement_yxwvf_116 _UnstyledButton_14p2i_205", fl = "_NoteTextarea_yxwvf_132", gl = "_large_yxwvf_135", yl = "_SubmitContainer_yxwvf_139", vl = "_darkMode_yxwvf_159", Cl = "_UnsavedChangesWarning_yxwvf_169", wl = "_SubmitButton_yxwvf_174", bl = "_saved_yxwvf_183", Il = "_danger_yxwvf_191", Sl = "_Info_yxwvf_195", Nl = "_DropdownButton_yxwvf_201", Ll = "_Dropdown_yxwvf_201", xl = "_LabeledSwitch_yxwvf_219", Rl = "_Switch_yxwvf_226", Bl = "_Tags_yxwvf_230", Tl = "_TagsLabel_yxwvf_239", $l = "_TagChip_yxwvf_243", El = "_TagText_yxwvf_254 _UnstyledButton_14p2i_205", Pl = "_readOnly_yxwvf_270", Al = "_TagChipRemove_yxwvf_274 _UnstyledButton_14p2i_205", Ml = "_TagAddButton_yxwvf_294", Ol = "_CreditCardIcon_yxwvf_299", Fl = "_CreditCardExpirationSecurityCode_yxwvf_306", Wl = "_CreditCardSecurityCode_yxwvf_312", zl = "_CreditCardExpiration_yxwvf_306", y = {
  LoginEdit: el,
  MovedLoginHint: tl,
  movedLogin: nl,
  Main: ol,
  Preform: rl,
  FormElement: il,
  FormGroup: sl,
  TotpCustomField: al,
  TotpLabel: cl,
  TotpInput: ll,
  TotpCodeContainer: dl,
  TotpValue: ul,
  AndroidAppIcon: pl,
  FormElementInfoLine: _l,
  RelatedDomains: ml,
  AddElement: hl,
  NoteTextarea: fl,
  large: gl,
  SubmitContainer: yl,
  darkMode: vl,
  UnsavedChangesWarning: Cl,
  SubmitButton: wl,
  saved: bl,
  danger: Il,
  Info: Sl,
  DropdownButton: Nl,
  Dropdown: Ll,
  LabeledSwitch: xl,
  Switch: Rl,
  Tags: Bl,
  TagsLabel: Tl,
  TagChip: $l,
  TagText: El,
  readOnly: Pl,
  TagChipRemove: Al,
  TagAddButton: Ml,
  CreditCardIcon: Ol,
  CreditCardExpirationSecurityCode: Fl,
  CreditCardSecurityCode: Wl,
  CreditCardExpiration: zl
}, Dl = "_ExternalLink_14d8h_1", Ul = "_IconWrapper_14d8h_11", Vl = "_Icon_14d8h_11", Ot = {
  ExternalLink: Dl,
  IconWrapper: Ul,
  Icon: Vl
}, Pn = "external noreferrer";
function Co({
  className: e2,
  children: t2,
  noIcon: n2,
  rel: r2,
  ...i
}) {
  return /* @__PURE__ */ jsxs("a", { className: classNames(Ot.ExternalLink, e2), target: "_blank", rel: r2 ? `${Pn} ${r2}` : Pn, ...i, children: [
    t2,
    !n2 && /* @__PURE__ */ jsx("span", { className: Ot.IconWrapper, children: /* @__PURE__ */ jsx(Svg3696C0364Ce81148, { className: Ot.Icon }) })
  ] });
}
const Bd = {
  [LoginUiType.creditCard]: Svg3714337086137Eb1,
  [LoginUiType.note]: Svg6018Ebb68Aec24Ff,
  [LoginUiType.login]: Svg071A4A0C17B97D20,
  [LoginUiType.wifi]: SvgB1D9C11A519C251C
};
function Io({
  uiType: e2,
  ...t2
}) {
  const n2 = Bd[e2];
  return n2 ? /* @__PURE__ */ jsx(n2, { ...t2 }) : null;
}
const Td = "_UiTypeSelect_11w16_1", $d = "_Button_11w16_8 _UnstyledButton_14p2i_205", Ed = "_active_11w16_24", Pd = "_OverflowDropdownWrapper_11w16_43", Ad = "_dark_11w16_53", Md = "_OverflowDropdown_11w16_43", Od = "_OverflowButton_11w16_64 _UnstyledButton_14p2i_205", xe = {
  UiTypeSelect: Td,
  Button: $d,
  active: Ed,
  OverflowDropdownWrapper: Pd,
  dark: Ad,
  OverflowDropdown: Md,
  OverflowButton: Od
}, Fn = Object.values(LoginUiType);
function Fd({
  uiType: e2,
  setUiType: t2
}) {
  const [n2, {
    width: r2
  }] = he(), [i, s2] = reactExports.useState(Fn), c2 = Math.max(Math.floor((r2 - 20) / 120), 1);
  reactExports.useEffect(() => {
    i.indexOf(e2) >= c2 && s2([e2, ...Fn.filter((m2) => m2 !== e2)]);
  }, [i, e2, c2]);
  const a2 = i.slice(0, c2), l2 = i.slice(c2), d2 = Z();
  return /* @__PURE__ */ jsxs("div", { ref: n2, className: classNames(xe.UiTypeSelect, xe[d2]), role: "listbox", "aria-label": i18n._(
    /*i18n*/
    {
      id: "nNWuY1"
    }
  ), children: [
    a2.map((u2) => {
      const m2 = u2 === e2;
      return /* @__PURE__ */ jsxs("button", { type: "button", onClick: () => t2(u2), className: classNames(xe.Button, m2 && xe.active), role: "option", "aria-selected": m2, children: [
        /* @__PURE__ */ jsx(Io, { uiType: u2 }),
        /* @__PURE__ */ jsx("span", { children: U(u2) })
      ] }, u2);
    }),
    !!l2.length && /* @__PURE__ */ jsx(Wd, { overflowOptions: l2, setUiType: t2 })
  ] });
}
function Wd({
  overflowOptions: e2,
  setUiType: t2
}) {
  const [n2, r2] = reactExports.useState(false), i = reactExports.useCallback(() => r2(false), []), s2 = reactExports.useRef(null);
  return on(s2, i), /* @__PURE__ */ jsxs("div", { ref: s2, className: xe.OverflowDropdownWrapper, children: [
    /* @__PURE__ */ jsx("button", { type: "button", onClick: () => r2((c2) => !c2), className: xe.Button, children: /* @__PURE__ */ jsx(SvgC4E2C2A224B8321A, { title: i18n._(
      /*i18n*/
      {
        id: "2FYpfJ"
      }
    ) }) }),
    n2 && /* @__PURE__ */ jsx(rn, { className: xe.OverflowDropdown, children: e2.map((c2) => /* @__PURE__ */ jsxs("button", { type: "button", onClick: () => {
      t2(c2), i();
    }, className: xe.OverflowButton, role: "option", "aria-selected": false, children: [
      /* @__PURE__ */ jsx(Io, { uiType: c2 }),
      /* @__PURE__ */ jsx("span", { children: U(c2) })
    ] }, c2)) })
  ] });
}
function xt(e2) {
  return Array.isArray(e2) ? e2.length > 0 && e2.some(xt) : typeof e2 == "object" && e2 !== null ? Object.values(e2).some(xt) : !!e2;
}
function Le({
  children: e2,
  className: t2,
  ...n2
}) {
  return React$1.Children.toArray(e2).some((i) => React$1.isValidElement(i)) ? /* @__PURE__ */ jsx("fieldset", { className: classNames(y.FormGroup, t2), ...n2, children: e2 }) : null;
}
ee(["uiType", "password"])(({
  formik: e2,
  initialPassword: t2,
  newLogin: n2,
  resetNonEmptyFields: r2
}) => /* @__PURE__ */ jsx(Fd, { uiType: getValueWithPlaceholder(e2.values.uiType), setUiType: (i) => {
  e2.values.uiType !== i && (e2.setFieldValue("uiType", i), r2(), n2 && (i === LoginUiType.login && e2.values.password === "" ? e2.setFieldValue("password", t2) : i !== LoginUiType.login && e2.values.password === t2 && e2.setFieldValue("password", "")));
} }));
ee(["username"])(({
  formik: e2,
  writeToClipboard: t2,
  readOnly: n2,
  usernameSuggestions: r2
}) => {
  const {
    action: i
  } = de(t2, e2.values.username), {
    ref: s2,
    inlineUi: c2
  } = oe([i]);
  return n2 && !e2.values.username ? null : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(fo, { inputProps: {
    type: "text",
    ...e2.getFieldProps("username"),
    readOnly: n2,
    ref: s2,
    inputMode: "email",
    autoComplete: "off",
    autoCapitalize: "off",
    autoCorrect: "off"
  }, label: i18n._(
    /*i18n*/
    {
      id: "d3ZUIN"
    }
  ), error: e2.touched.username ? e2.errors.username : void 0, inlineUi: c2, suggestions: r2 ?? [], applySuggestion: (a2) => e2.setFieldValue("username", a2), optionsOverlay: true }) });
});
ee(["wifiSsid"])(({
  formik: e2,
  writeToClipboard: t2,
  readOnly: n2
}) => {
  const {
    action: r2
  } = de(t2, e2.values.wifiSsid), {
    ref: i,
    inlineUi: s2
  } = oe([r2]);
  return n2 && !e2.values.wifiSsid ? null : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { element: {
    type: "input",
    props: {
      type: "text",
      ...e2.getFieldProps("wifiSsid"),
      readOnly: n2,
      ref: i,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off"
    }
  }, label: i18n._(
    /*i18n*/
    {
      id: "MKYFuo"
    }
  ), error: e2.touched.wifiSsid ? e2.errors.wifiSsid : void 0, inlineUi: s2 }) });
});
ee(["uiType", "password"])(({
  formik: e2,
  newLogin: t2,
  writeToClipboard: n2,
  openPasswordGenerator: r2,
  setOpenPasswordGenerator: i,
  savePasswordGeneratorSettings: s2,
  passwordGeneratorSettings: c2,
  writeAuditlogEvent: a2,
  updateLoginStatusChecks: l2,
  enqueueUpdateLoginStatusChecks: d2,
  leakedPasswordCheckStatus: u2,
  permissions: m2,
  passwordNonEmpty: h2
}) => {
  const g2 = e2.values.uiType, v2 = !m2.editLogin, L2 = reactExports.useMemo(() => !m2.viewSecrets || !(g2 === LoginUiType.login || g2 === LoginUiType.wifi || t2 && xt(e2.values.password) || !t2 && h2) || v2 && !e2.values.password ? "notShown" : t2 && !v2 && e2.values.uiType === LoginUiType.login ? "initialPasswordGenerator" : r2 === "password" && !v2 ? "editPasswordGenerator" : "edit", [e2.values.password, e2.values.uiType, t2, r2, h2, m2.viewSecrets, v2, g2]), N2 = yo({
    initialValue: void 0,
    initialSettings: c2,
    onSettingsChange: l2,
    onChange: d2
  }), E2 = reactExports.useCallback((F2) => {
    e2.setFieldValue("password", F2, true), d2(F2);
  }, [e2, d2]), b2 = go({
    password: e2.values.password,
    setPassword: E2,
    initialSettings: c2,
    initialGeneratedPassword: e2.initialValues.password,
    onSettingsChange: l2
  }), {
    action: B2,
    show: I2,
    setShow: A2
  } = Ke({
    isEmpty: !e2.values.password,
    onShow: () => {
      a2 == null || a2({
        type: AuditlogEventType.LOGIN_R_PASSWORD_SHOW
      });
    }
  }), {
    action: w2
  } = de((F2) => {
    n2(F2, true), a2 == null || a2({
      type: AuditlogEventType.LOGIN_R_PASSWORD_COPY
    });
  }, e2.values.password), R2 = reactExports.useMemo(() => ({
    icon: SvgC707E009107B34Db,
    element: {
      type: "button",
      props: {
        type: "button",
        disabled: r2 !== void 0,
        onClick: () => {
          i("password"), N2.editPassword(dn(c2), true), a2 == null || a2({
            type: AuditlogEventType.LOGIN_R_PASSWORD_SHOW
          });
        }
      }
    },
    key: "generate",
    label: i18n._(
      /*i18n*/
      {
        id: "19BWU3"
      }
    )
  }), [r2, N2, c2, i, a2]), T2 = reactExports.useMemo(() => v2 ? [w2, B2] : [w2, B2, R2], [w2, R2, v2, B2]), {
    ref: S2,
    inlineUi: $
  } = oe(T2), U2 = reactExports.useRef(false);
  if (reactExports.useEffect(() => {
    U2.current || (U2.current = true, L2 === "edit" ? l2(e2.values.password) : L2 === "initialPasswordGenerator" ? l2(b2.password) : L2 === "editPasswordGenerator" && l2(N2.password));
  }, [e2.values.password, u2, L2, b2.password, N2.password, l2]), L2 === "notShown")
    return null;
  if (L2 === "initialPasswordGenerator")
    return /* @__PURE__ */ jsx(qt, { ...b2, className: y.FormElement, hideButtons: true, writeToClipboard: n2, error: e2.touched.password ? e2.errors.password : void 0, saveSettings: s2, savedSettings: c2, onNewPasswordBlur: l2, leakedPasswordCheckStatus: u2 });
  if (L2 === "editPasswordGenerator")
    return /* @__PURE__ */ jsx(qt, { ...N2, oldPassword: e2.values.password, className: y.FormElement, close: () => {
      i(void 0), l2(e2.values.password);
    }, apply: () => {
      e2.setFieldValue("password", N2.password), i(void 0);
    }, writeToClipboard: n2, saveSettings: s2, savedSettings: c2, onNewPasswordBlur: l2, leakedPasswordCheckStatus: u2 });
  if (L2 === "edit") {
    const F2 = (u2 == null ? void 0 : u2.status) === "checked" && u2.leakCount > 0, K2 = e2.getFieldProps("password");
    return /* @__PURE__ */ jsx("div", { className: y.FormElement, children: I2 ? /* @__PURE__ */ jsx(J, { element: {
      type: "input",
      props: {
        type: "text",
        autoComplete: "off",
        autoCapitalize: "off",
        autoCorrect: "off",
        ...K2,
        onBlur: (j) => {
          K2.onBlur(j), l2(j.currentTarget.value);
        },
        onChange: (j) => {
          K2.onChange(j), d2(j.currentTarget.value);
        },
        readOnly: v2,
        ref: S2
      }
    }, label: i18n._(
      /*i18n*/
      {
        id: "8ZsakT"
      }
    ), error: e2.touched.password && e2.errors.password ? e2.errors.password : F2 ? true : void 0, inlineUi: $, monospace: true }) : /* @__PURE__ */ jsx(Qe, { inlineUi: $, ref: S2, onButtonClick: () => A2(true), changed: e2.initialValues.password !== e2.values.password, children: /* @__PURE__ */ jsx(Trans, { id: "7C+Jn5" }) }) });
  }
  assertExhaustive();
});
ee(["totp", "totpDigits", "totpAlgorithm", "totpPeriod"])(({
  formik: e2,
  writeToClipboard: t2,
  showTotpTimeOffsetWarning: n2,
  checkTotpTimeOffset: r2,
  writeAuditlogEvent: i,
  permissions: s2
}) => {
  const [c2, a2] = reactExports.useState(false), l2 = !!e2.values.totp || c2, d2 = reactExports.useMemo(() => !l2 && (!s2.viewSecrets || !s2.editLogin) ? "notShown" : l2 ? s2.viewSecrets ? "edit" : "codeOnly" : "addButton", [s2.editLogin, s2.viewSecrets, l2]), [u2, m2] = reactExports.useState(false), {
    action: h2,
    show: g2,
    setShow: v2
  } = Ke({
    isEmpty: !e2.values.totp,
    onShow: () => {
      i == null || i({
        type: AuditlogEventType.LOGIN_R_TOTP_SECRET_SHOW
      });
    }
  }), {
    action: L2
  } = ut(() => {
    e2.setFieldValue("totp", ""), e2.setFieldValue("totpAlgorithm", void 0), e2.setFieldValue("totpDigits", void 0), e2.setFieldValue("totpPeriod", void 0), a2(false);
  }), N2 = reactExports.useMemo(() => {
    const w2 = getValueWithPlaceholder(e2.values.totpAlgorithm);
    return !!(w2 && w2 !== DEFAULT_TOTP_ALGORITHM || e2.values.totpDigits && e2.values.totpDigits !== DEFAULT_TOTP_DIGITS || e2.values.totpPeriod && e2.values.totpPeriod !== DEFAULT_TOTP_PERIOD);
  }, [e2.values.totpAlgorithm, e2.values.totpDigits, e2.values.totpPeriod]), {
    ref: E2,
    inlineUi: b2
  } = oe([h2, L2]), {
    onBlur: B2,
    ...I2
  } = e2.getFieldProps("totp");
  if (d2 === "notShown")
    return null;
  if (d2 === "addButton")
    return /* @__PURE__ */ jsx("div", { className: y.FormElementInfoLine, children: /* @__PURE__ */ jsx("button", { className: y.AddElement, type: "button", onClick: (w2) => {
      w2.stopPropagation(), a2(true), m2(true);
    }, children: /* @__PURE__ */ jsx(Trans, { id: "648VR4" }) }) });
  const A2 = /* @__PURE__ */ jsx(ho, { hidden: !n2, className: y.FormElement, recheck: r2 });
  if (d2 === "codeOnly")
    return e2.values.totp && s2.useLogin ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs("div", { className: classNames(y.FormElement, y.TotpCustomField), children: [
        /* @__PURE__ */ jsx("div", { className: y.TotpLabel, children: /* @__PURE__ */ jsx(Trans, { id: "dME5Kz" }) }),
        /* @__PURE__ */ jsx(Kt, { writeToClipboard: t2, totpSecret: e2.values.totp ?? "", totpAlgorithm: getValueWithPlaceholder(e2.values.totpAlgorithm), totpDigits: e2.values.totpDigits, totpPeriod: e2.values.totpPeriod })
      ] }),
      A2
    ] }) : null;
  if (d2 === "edit")
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs("div", { className: classNames(y.FormElement, y.TotpCustomField), children: [
        g2 ? /* @__PURE__ */ jsx(J, { className: y.TotpInput, element: {
          type: "input",
          props: {
            type: "text",
            autoComplete: "off",
            autoFocus: u2,
            ...I2,
            readOnly: !s2.editLogin,
            ref: E2,
            onBlur: (w2) => {
              if (B2(w2), !s2.editLogin)
                return;
              const R2 = getTotpParametersFromOtpauthUrl(w2.currentTarget.value);
              if (R2) {
                const T2 = normalizeTotpSecret(R2.secret);
                e2.setFieldValue("totp", T2), e2.setFieldValue("totpAlgorithm", R2.algorithm), e2.setFieldValue("totpDigits", R2.digits), e2.setFieldValue("totpPeriod", R2.period);
              } else {
                const T2 = normalizeTotpSecret(w2.currentTarget.value);
                e2.setFieldValue("totp", T2);
              }
              m2(false);
            }
          }
        }, label: i18n._(
          /*i18n*/
          {
            id: "g4uCmi"
          }
        ), error: e2.touched.totp ? e2.errors.totp : void 0, inlineUi: b2, monospace: true }) : /* @__PURE__ */ jsx(Qe, { className: y.TotpInput, inlineUi: b2, ref: E2, onButtonClick: () => v2(true), changed: e2.initialValues.totp !== e2.values.totp, children: /* @__PURE__ */ jsx(Trans, { id: "nld5XV" }) }),
        /* @__PURE__ */ jsx(Kt, { writeToClipboard: t2, totpSecret: e2.values.totp ?? "", totpAlgorithm: getValueWithPlaceholder(e2.values.totpAlgorithm), totpDigits: e2.values.totpDigits, totpPeriod: e2.values.totpPeriod })
      ] }),
      N2 && /* @__PURE__ */ jsx("div", { className: y.FormElementInfoLine, children: /* @__PURE__ */ jsx(Trans, { id: "ESK+7k" }) }),
      A2
    ] });
  assertExhaustive();
});
ee(["title"])(({
  formik: e2,
  readOnly: t2
}) => t2 && !e2.values.title ? null : /* @__PURE__ */ jsx(J, { className: y.FormElement, label: i18n._(
  /*i18n*/
  {
    id: "pfa8F0"
  }
), error: e2.touched.title ? e2.errors.title : void 0, element: {
  type: "input",
  props: {
    type: "text",
    autoComplete: "off",
    ...e2.getFieldProps("title"),
    onBlur: (n2) => {
      e2.getFieldProps("title").onBlur(n2), e2.setFieldValue("title", n2.currentTarget.value.trim());
    },
    readOnly: t2
  }
} }));
ee(["tags"])(({
  formik: e2,
  tagSuggestions: t2,
  readOnly: n2,
  onTagClick: r2
}) => {
  const i = e2.values.tags, [s2, c2] = reactExports.useState(""), a2 = reactExports.useMemo(() => (t2 ?? []).filter((u2) => !(i != null && i.includes(u2))), [i, t2]), [l2, d2] = reactExports.useState();
  return /* @__PURE__ */ jsx(FieldArray, { name: "tags", render: (u2) => {
    function m2(h2) {
      const g2 = normalizeTag(h2);
      if (!g2.length) {
        d2("noTagEntered");
        return;
      }
      if (i != null && i.includes(g2)) {
        d2("alreadyExists");
        return;
      }
      u2.push(g2), c2("");
    }
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      !!(i != null && i.length) && /* @__PURE__ */ jsxs("div", { className: classNames(y.FormElement, y.Tags), children: [
        /* @__PURE__ */ jsx("strong", { className: y.TagsLabel, children: /* @__PURE__ */ jsx(Trans, { id: "hko/4A" }) }),
        i.map((h2, g2) => (
          // Using key as index here to avoid glitch rendering for duplicated tags. We
          // usually prevent duplicated tags, but they can slip through anyways (e.g. from
          // imports) and lead to very glitchy behavior when their name is used as key.
          /* @__PURE__ */ jsxs("span", { className: classNames(y.TagChip, n2 && y.readOnly), title: h2, children: [
            r2 ? /* @__PURE__ */ jsx("button", { type: "button", onClick: () => r2(h2), className: y.TagText, children: h2 }) : /* @__PURE__ */ jsx("span", { className: y.TagText, children: h2 }),
            !n2 && /* @__PURE__ */ jsx(uo, { element: "button", tooltip: i18n._(
              /*i18n*/
              {
                id: "/7FPnu"
              }
            ), type: "button", onClick: () => u2.remove(g2), className: y.TagChipRemove, children: /* @__PURE__ */ jsx(Svg85901Eed410D7B8F, {}) })
          ] }, g2)
        ))
      ] }),
      !n2 && /* @__PURE__ */ jsx(fo, { className: y.FormElement, inputProps: {
        type: "text",
        value: s2,
        onChange: (h2) => {
          c2(h2.currentTarget.value), d2(void 0);
        },
        onBlur: () => d2(void 0)
      }, suggestions: a2, label: i18n._(
        /*i18n*/
        {
          id: "lyqwgn"
        }
      ), applySuggestion: m2, onInputEnter: () => s2 ? (m2(s2), {
        preventDefault: true,
        closeMenu: true
      }) : {
        preventDefault: true
      }, inlineUi: s2 ? {
        node: /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => m2(s2), className: y.TagAddButton, children: /* @__PURE__ */ jsx(Trans, { id: "m16xKo" }) }),
        width: "6rem"
      } : void 0, error: l2 === "alreadyExists" ? i18n._(
        /*i18n*/
        {
          id: "oYNiCo"
        }
      ) : l2 === "noTagEntered" ? i18n._(
        /*i18n*/
        {
          id: "XdSz+P"
        }
      ) : void 0, optionsOverlay: true })
    ] });
  } });
});
ee(["note", "uiType"])(({
  formik: e2,
  readOnly: t2
}) => t2 && !e2.values.note ? null : /* @__PURE__ */ jsx(J, { className: y.FormElement, element: {
  type: "autosizeTextarea",
  props: {
    ...e2.getFieldProps("note"),
    readOnly: t2,
    className: classNames(y.NoteTextarea, e2.values.uiType === LoginUiType.note && y.large)
  }
}, label: i18n._(
  /*i18n*/
  {
    id: "KiJn9B"
  }
), error: e2.touched.note ? e2.errors.note : void 0 }));
ee(["androidApps"])(({
  formik: e2,
  availableAndroidApps: t2,
  readOnly: n2
}) => t2 && !n2 ? /* @__PURE__ */ jsx(tu, { formik: e2, availableAndroidApps: t2 }) : /* @__PURE__ */ jsx(FieldArray, { name: "androidApps", render: (r2) => (e2.values.androidApps ?? []).filter((i) => i !== null).map(({
  displayName: i,
  iconDataUri: s2
}, c2) => /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { element: {
  type: "input",
  props: {
    type: "text",
    readOnly: true,
    value: i
  }
}, label: i18n._(
  /*i18n*/
  {
    id: "zVJj0U"
  }
), icon: So(s2), inlineUi: an({
  actions: n2 ? [] : [ut(() => r2.remove(c2)).action]
}) }) }, c2)) }));
function tu({
  formik: e2,
  availableAndroidApps: t2
}) {
  const n2 = e2.values.androidApps ?? [];
  let r2;
  n2.length ? r2 = n2 : r2 = [null];
  const [i, s2] = reactExports.useState(), c2 = r2.length === 1 && r2[0] === null;
  return /* @__PURE__ */ jsx(FieldArray, { name: "androidApps", render: (a2) => /* @__PURE__ */ jsxs(Fragment, { children: [
    r2.map((l2, d2) => {
      const u2 = `androidApps.${d2}`, m2 = e2.getFieldProps(u2).value;
      return /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(Ba, { clearable: false, options: t2, label: i18n._(
        /*i18n*/
        {
          id: "zVJj0U"
        }
      ), getValueLabel: ({
        displayName: h2
      }) => h2, getValueIconNode: ({
        iconDataUri: h2
      }) => So(h2), valuesEqual: ({
        appId: h2
      }, {
        appId: g2
      }) => h2 === g2, noMatchingOptionsText: i18n._(
        /*i18n*/
        {
          id: "nr1I0W"
        }
      ), value: m2, onChange: (h2) => {
        d2 >= n2.length ? a2.push(h2) : e2.setFieldValue(u2, h2 ?? null, false), s2(void 0);
      }, autoFocus: d2 === i, inlineUi: an({
        actions: c2 ? [] : [ut(() => a2.remove(d2)).action]
      }) }, "select") }, d2);
    }),
    /* @__PURE__ */ jsx("div", { className: classNames(y.FormElementInfoLine), children: /* @__PURE__ */ jsx("button", { className: y.AddElement, type: "button", onClick: () => {
      s2(r2.length ?? 0), n2.length === 0 && a2.push(null), a2.push(null);
    }, children: /* @__PURE__ */ jsx(Trans, { id: "iOiHwJ" }) }) })
  ] }) });
}
function So(e2) {
  return e2 != null && e2.startsWith("data:") ? /* @__PURE__ */ jsx(Fragment, { children: /* @__PURE__ */ jsx("img", { src: e2, alt: "", className: y.AndroidAppIcon }) }) : void 0;
}
ee(["websites", "websiteAttributes"])(({
  formik: e2,
  writeToClipboard: t2,
  readOnly: n2,
  focusedWebsiteInputRef: r2
}) => {
  const i = e2.values.websites ?? [];
  let s2;
  i.length ? s2 = i : s2 = [null];
  const c2 = s2.length === 1 && (s2[0] === null || normalizeWebsitePattern(s2[0]) === ""), [a2, l2] = reactExports.useState();
  return n2 && !s2.some((d2) => !!d2) ? null : /* @__PURE__ */ jsx(FieldArray, { name: "websites", render: (d2) => /* @__PURE__ */ jsx(Fragment, { children: s2.map((u2, m2) => /* @__PURE__ */ jsx(ou, { formik: e2, index: m2, readOnly: n2, autoFocus: a2 === m2, writeToClipboard: t2, hideDelete: c2, deleteWebsite: () => {
    d2.remove(m2);
  }, clearAutoFocus: () => l2(void 0), focusedWebsiteInputRef: r2, infoLineButton: !n2 && m2 === s2.length - 1 ? /* @__PURE__ */ jsx("button", { className: y.AddElement, type: "button", onClick: () => {
    l2(e2.values.websites.length), i.length === 0 && d2.push(null), d2.push(null);
  }, children: /* @__PURE__ */ jsx(Trans, { id: "iOiHwJ" }) }) : void 0 }, m2)) }) });
});
function ou({
  formik: e2,
  index: t2,
  writeToClipboard: n2,
  deleteWebsite: r2,
  readOnly: i,
  hideDelete: s2,
  autoFocus: c2,
  clearAutoFocus: a2,
  focusedWebsiteInputRef: l2,
  infoLineButton: d2
}) {
  var A2;
  const u2 = `websites.${t2}`, {
    onBlur: m2,
    ...h2
  } = e2.getFieldProps(u2), {
    action: g2
  } = de(n2, (h2 == null ? void 0 : h2.value) ?? ""), v2 = (A2 = e2.values.websiteAttributes) == null ? void 0 : A2[h2.value], L2 = h2.value ? {
    icon: SvgC8F08Adbe83Afe3E,
    key: "openinbrowser",
    label: i18n._(
      /*i18n*/
      {
        id: "yxTdsJ"
      }
    ),
    element: {
      type: "a",
      props: {
        href: `${getValueWithPlaceholder(v2 == null ? void 0 : v2.protocol) ?? "http"}://${h2.value}`,
        target: "_blank",
        rel: "noopener noreferrer"
      }
    }
  } : void 0, {
    ref: N2,
    inlineUi: E2
  } = oe([L2 ?? [], g2, !i && !s2 ? ut(r2).action : []].flat()), [b2, B2] = reactExports.useState(), I2 = reactExports.useMemo(() => {
    let w2 = h2.value;
    /^([a-z]+:)?\/\//.exec(w2) || (w2 = `https://${w2}`);
    const T2 = f$3(w2);
    return T2 ? getRelatedDomains(T2.psl.domain ?? T2.url.hostname) : void 0;
  }, [h2.value]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { label: i18n._(
      /*i18n*/
      {
        id: "On0aF2"
      }
    ), element: {
      type: "input",
      props: {
        type: "text",
        ...h2,
        autoFocus: c2,
        readOnly: i,
        inputMode: "url",
        autoCapitalize: "off",
        autoCorrect: "off",
        onFocus: () => {
          l2.current = {
            index: t2,
            oldNormalizedValue: h2.value
          };
        },
        onBlur: (w2) => {
          if (m2(w2), i)
            return;
          a2();
          const {
            websites: R2,
            websiteAttributes: T2
          } = Lo(e2.values, l2.current);
          l2.current = void 0, e2.setFieldValue("websites", R2), e2.setFieldValue("websiteAttributes", T2);
        },
        ref: N2
      }
    }, inlineUi: E2 }) }),
    (I2 || d2) && /* @__PURE__ */ jsxs("div", { className: y.FormElementInfoLine, children: [
      I2 && /* @__PURE__ */ jsx("span", { className: y.RelatedDomains, children: b2 === h2.value || I2.length < 4 ? I2.length === 1 ? /* @__PURE__ */ jsx(Trans, { id: "ai680t", values: {
        0: I2[0]
      } }) : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Trans, { id: "y4UGV2", values: {
          0: I2.slice(0, I2.length - 1).join(", "),
          1: I2[I2.length - 1]
        } }),
        I2.length >= 4 && /* @__PURE__ */ jsxs(Fragment, { children: [
          " ",
          /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => {
            B2(void 0);
          }, children: /* @__PURE__ */ jsx(Trans, { id: "vLyv1R" }) })
        ] })
      ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Trans, { id: "czBEzZ", values: {
          0: I2.length
        } }),
        " ",
        /* @__PURE__ */ jsx(Ge, { type: "button", onClick: () => {
          B2(h2.value);
        }, children: /* @__PURE__ */ jsx(Trans, { id: "8vETh9" }) })
      ] }) }),
      d2
    ] })
  ] });
}
ee(["customFields", "totp"])(({
  formik: e2,
  writeToClipboard: t2,
  readOnly: n2,
  hideSecrets: r2,
  savePasswordGeneratorSettings: i,
  passwordGeneratorSettings: s2,
  openPasswordGenerator: c2,
  setOpenPasswordGenerator: a2,
  showTotpTimeOffsetWarning: l2,
  checkTotpTimeOffset: d2,
  writeAuditlogEvent: u2
}) => {
  const [m2, h2] = reactExports.useState(false), [g2, v2] = reactExports.useState(), {
    customFields: L2
  } = e2.values, N2 = e2.values.totp ? void 0 : filterUnprotectedCustomFields(L2).totpField;
  return /* @__PURE__ */ jsx(FieldArray, { name: "customFields", render: (E2) => /* @__PURE__ */ jsxs(Fragment, { children: [
    L2.map((b2, B2) => {
      if (b2.protected && r2)
        return null;
      const I2 = `customFields.${B2}.value`, {
        onBlur: A2,
        ...w2
      } = e2.getFieldProps(I2), R2 = {
        ...w2,
        onBlur: (S2) => {
          v2(void 0), A2(S2);
        },
        autoFocus: B2 === g2,
        readOnly: n2
      }, T2 = e2.initialValues.customFields[B2];
      return N2 && b2 === N2 ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs("div", { className: classNames(y.FormElement, y.TotpCustomField), children: [
          /* @__PURE__ */ jsx(Wn, { className: y.TotpInput, element: {
            type: "input",
            props: {
              type: "text",
              ...R2,
              onBlur: (S2) => {
                if (R2.onBlur(S2), n2)
                  return;
                const $ = normalizeTotpSecret(S2.currentTarget.value);
                e2.setFieldValue(R2.name, $);
              }
            }
          }, id: b2.id, label: b2.name, fieldName: b2.name, deleteCustomField: () => E2.remove(B2), writeToClipboard: t2, protected: b2.protected, readOnly: n2, initialValue: T2 == null ? void 0 : T2.value, writeAuditlogEvent: u2 }),
          /* @__PURE__ */ jsx(Kt, { writeToClipboard: t2, totpSecret: b2.value })
        ] }, B2),
        /* @__PURE__ */ jsx(ho, { hidden: !l2, className: y.FormElement, recheck: d2 })
      ] }) : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(Wn, { element: {
        type: "input",
        props: {
          type: "text",
          ...R2
        }
      }, id: b2.id, label: b2.name, fieldName: b2.name, deleteCustomField: () => E2.remove(B2), writeToClipboard: t2, protected: b2.protected, readOnly: n2, passwordGenerator: {
        savePasswordGeneratorSettings: i,
        passwordGeneratorSettings: s2,
        setFieldValue: (S2) => {
          e2.setFieldValue(I2, S2, true);
        },
        openPasswordGenerator: c2,
        setOpenPasswordGenerator: a2
      }, initialValue: T2 == null ? void 0 : T2.value, writeAuditlogEvent: u2 }) }, B2);
    }),
    !n2 && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("div", { className: y.FormElementInfoLine, children: /* @__PURE__ */ jsxs("button", { className: y.AddElement, type: "button", onClick: (b2) => {
        b2.stopPropagation(), h2(!m2);
      }, children: [
        /* @__PURE__ */ jsx(Trans, { id: "CgUQh7" }),
        " ",
        /* @__PURE__ */ jsx(cn, { direction: "down" })
      ] }) }),
      /* @__PURE__ */ jsx("div", { className: y.DropdownButton, children: /* @__PURE__ */ jsx(su, { visible: m2, add: (b2) => {
        v2(e2.values.customFields.length), E2.push(b2), h2(false);
      }, close: () => h2(false) }) })
    ] })
  ] }) });
});
function Wn({
  writeToClipboard: e2,
  deleteCustomField: t2,
  protected: n2,
  readOnly: r2,
  passwordGenerator: i,
  id: s2,
  fieldName: c2,
  writeAuditlogEvent: a2,
  element: l2,
  initialValue: d2,
  ...u2
}) {
  var A2;
  const m2 = ((A2 = l2 == null ? void 0 : l2.props) == null ? void 0 : A2.value) ?? "", {
    action: h2
  } = de((w2) => {
    e2(w2, n2), a2 == null || a2({
      type: AuditlogEventType.LOGIN_R_CUSTOM_FIELD_COPY,
      customFieldId: s2
    });
  }, m2), {
    action: g2
  } = ut(t2), {
    action: v2,
    show: L2,
    setShow: N2
  } = Ke({
    isEmpty: !m2,
    onShow: () => {
      a2 == null || a2({
        type: AuditlogEventType.LOGIN_R_CUSTOM_FIELD_SHOW,
        customFieldId: s2
      });
    }
  }), E2 = {
    icon: SvgC707E009107B34Db,
    element: {
      type: "button",
      props: {
        type: "button",
        disabled: (i == null ? void 0 : i.openPasswordGenerator) !== void 0,
        onClick: () => {
          a2 == null || a2({
            type: AuditlogEventType.LOGIN_R_PASSWORD_SHOW,
            customFieldId: s2
          }), i == null || i.setOpenPasswordGenerator(s2);
        }
      }
    },
    key: "generate",
    label: i18n._(
      /*i18n*/
      {
        id: "19BWU3"
      }
    )
  };
  let b2 = [h2];
  n2 && (b2 = [...b2, v2], i && !r2 && (b2 = [...b2, E2])), r2 || (b2 = [...b2, g2]);
  const {
    ref: B2,
    inlineUi: I2
  } = oe(b2);
  return !r2 && i && i.openPasswordGenerator === s2 ? /* @__PURE__ */ jsx(iu, { oldPassword: m2, writeToClipboard: e2, fieldName: c2, ...i }) : n2 && !L2 ? /* @__PURE__ */ jsx(Qe, { inlineUi: I2, ref: B2, onButtonClick: () => N2(true), className: u2.className, changed: d2 !== m2, children: /* @__PURE__ */ jsx(Trans, { id: "h8lzfw", values: {
    0: u2.label
  } }) }) : /* @__PURE__ */ jsx(J, { ...u2, element: {
    ...l2,
    props: {
      ...l2.props,
      type: "text",
      ref: B2
    }
  }, inlineUi: I2, monospace: n2 });
}
function iu({
  oldPassword: e2,
  setOpenPasswordGenerator: t2,
  writeToClipboard: n2,
  savePasswordGeneratorSettings: r2,
  passwordGeneratorSettings: i,
  setFieldValue: s2,
  fieldName: c2
}) {
  const a2 = yo({
    initialValue: void 0,
    initialSettings: i ?? null,
    onChange: void 0
  });
  return /* @__PURE__ */ jsx(qt, { ...a2, oldPassword: e2, className: y.FormElement, close: () => t2(void 0), apply: () => {
    s2(a2.password), t2(void 0);
  }, writeToClipboard: n2, saveSettings: r2, savedSettings: i, oldPasswordLabel: i18n._(
    /*i18n*/
    {
      id: "Gv57aB",
      values: {
        fieldName: c2
      }
    }
  ), newPasswordLabel: c2 });
}
function Kt({
  writeToClipboard: e2,
  totpSecret: t2,
  totpAlgorithm: n2,
  totpDigits: r2,
  totpPeriod: i
}) {
  const {
    totp: s2,
    totpPercent: c2,
    totpDigits: a2
  } = Li(t2, n2, r2, i), {
    action: l2
  } = de(e2, s2);
  return /* @__PURE__ */ jsxs("div", { className: y.TotpCodeContainer, children: [
    /* @__PURE__ */ jsx("div", { className: y.TotpValue, children: s2 ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("span", { children: s2.substring(0, a2 / 2) }),
      /* @__PURE__ */ jsx("span", { children: s2.substring(a2 / 2) })
    ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("span", { children: "???" }),
      /* @__PURE__ */ jsx("span", { children: "???" })
    ] }) }),
    c2 && /* @__PURE__ */ jsx(Da, { percent: c2 }),
    /* @__PURE__ */ jsx(po, { actions: [l2] })
  ] });
}
function su({
  visible: e2,
  add: t2,
  close: n2
}) {
  const r2 = reactExports.useRef(null);
  return on(r2, n2), e2 ? /* @__PURE__ */ jsx(Formik, { initialValues: {
    name: "",
    protected: false,
    value: ""
  }, onSubmit: (s2) => {
    s2.protected ? t2({
      ...s2,
      protected: true,
      id: newUuid$1()
    }) : t2({
      ...s2,
      protected: false,
      id: newUuid$1()
    });
  }, validate: (s2) => {
    let c2 = {};
    return s2.name || (c2 = {
      ...c2,
      name: i18n._(
        /*i18n*/
        {
          id: "1xTnZJ"
        }
      )
    }), c2;
  }, children: (s2) => {
    const {
      onBlur: c2,
      ...a2
    } = s2.getFieldProps("name");
    return /* @__PURE__ */ jsxs(rn, { element: "div", className: y.Dropdown, ref: r2, onKeyDown: (l2) => {
      l2.key === "Enter" && (l2.preventDefault(), s2.handleSubmit());
    }, children: [
      /* @__PURE__ */ jsx(J, { label: i18n._(
        /*i18n*/
        {
          id: "6YtxFj"
        }
      ), element: {
        type: "input",
        props: {
          type: "text",
          autoComplete: "off",
          ...a2,
          onKeyDown: () => s2.setFieldTouched("name"),
          autoFocus: true
        }
      }, className: y.FormElement, error: s2.touched.name ? s2.errors.name : void 0 }),
      /* @__PURE__ */ jsxs("label", { className: classNames(y.FormElement, y.LabeledSwitch), children: [
        /* @__PURE__ */ jsx(at, { className: y.Switch, ...s2.getFieldProps({
          name: "protected",
          type: "checkbox"
        }) }),
        /* @__PURE__ */ jsx(Trans, { id: "g9eOjA" })
      ] }),
      /* @__PURE__ */ jsx(be, { buttonStyle: "primary", element: "button", type: "button", onClick: () => {
        s2.submitForm().catch(trackError);
      }, className: classNames(y.FormElement), children: /* @__PURE__ */ jsx(Trans, { id: "m16xKo" }) })
    ] });
  } }) : /* @__PURE__ */ jsx(Fragment, {});
}
const au = {
  [dist.creditCardType.types.AMERICAN_EXPRESS]: SvgEa285Cf2Cf54Ed10,
  [dist.creditCardType.types.DINERS_CLUB]: Svg4Bda20Dc465Fd5E8,
  [dist.creditCardType.types.DISCOVER]: Svg96E6C7C43A915C12,
  [dist.creditCardType.types.ELO]: Svg4Cd29C4C3E16Daa4,
  [dist.creditCardType.types.HIPERCARD]: SvgC919F85Dd32Ab2Ca,
  [dist.creditCardType.types.HIPER]: SvgDf6706Eae6F7E6B2,
  [dist.creditCardType.types.JCB]: SvgBc16C58Eb1De638B,
  [dist.creditCardType.types.MAESTRO]: Svg75Bb17D442A9Aa5E,
  [dist.creditCardType.types.MASTERCARD]: SvgF1A233802Cf96Ae4,
  [dist.creditCardType.types.UNIONPAY]: SvgD40Fa15A82Ff4Ca7,
  [dist.creditCardType.types.VISA]: Svg223Ca525897C672A
};
ee(["creditCard", "uiType"])(({
  formik: e2,
  readOnly: t2,
  writeToClipboard: n2,
  hideSecrets: r2,
  writeAuditlogEvent: i,
  nonEmptyFields: s2
}) => {
  var k2, Ie2, Je2, W2, Re2, Ae2, Xe2, pe2, pt, _t, Ze2, mt, Me2, et, tt, Oe2, ge2, te2, Fe2, nt, _e, mn, hn;
  const {
    warnings: c2,
    card: a2
  } = lu(e2), l2 = reactExports.useMemo(() => a2 ? au[a2 == null ? void 0 : a2.type] ?? SvgAcb05338A032C728 : SvgAcb05338A032C728, [a2]), {
    action: d2
  } = de(n2, (Ie2 = (k2 = e2.values.creditCard) == null ? void 0 : k2.number) == null ? void 0 : Ie2.replaceAll(" ", "")), {
    ref: u2,
    inlineUi: m2
  } = oe([d2]), {
    action: h2
  } = de(n2, (Je2 = e2.values.creditCard) == null ? void 0 : Je2.cardHolder), {
    ref: g2,
    inlineUi: v2
  } = oe([h2]), {
    action: L2
  } = de(n2, (W2 = e2.values.creditCard) == null ? void 0 : W2.expiration), {
    ref: N2,
    inlineUi: E2
  } = oe([L2]), {
    action: b2,
    show: B2,
    setShow: I2
  } = Ke({
    isEmpty: !((Re2 = e2.values.creditCard) != null && Re2.securityCode),
    onShow: () => i == null ? void 0 : i({
      type: AuditlogEventType.CREDIT_CARD_R_SECURITY_CODE_SHOW
    })
  }), {
    action: A2
  } = de((Q2) => {
    n2(Q2, true), i == null || i({
      type: AuditlogEventType.CREDIT_CARD_R_SECURITY_CODE_COPY
    });
  }, (Ae2 = e2.values.creditCard) == null ? void 0 : Ae2.securityCode), {
    ref: w2,
    inlineUi: R2
  } = oe([A2, b2]), {
    action: T2,
    show: S2,
    setShow: $
  } = Ke({
    isEmpty: !((Xe2 = e2.values.creditCard) != null && Xe2.pin),
    onShow: () => i == null ? void 0 : i({
      type: AuditlogEventType.CREDIT_CARD_R_PIN_SHOW
    })
  }), {
    action: U2
  } = de((Q2) => {
    n2(Q2, true), i == null || i({
      type: AuditlogEventType.CREDIT_CARD_R_PIN_COPY
    });
  }, (pe2 = e2.values.creditCard) == null ? void 0 : pe2.pin), F2 = reactExports.useMemo(() => ({
    icon: SvgC707E009107B34Db,
    element: {
      type: "button",
      props: {
        type: "button",
        disabled: !S2,
        onClick: () => {
          const {
            value: Q2
          } = tn(4, false, false, true, false);
          e2.setFieldValue("creditCard.pin", Q2);
        }
      }
    },
    key: "generate",
    label: i18n._(
      /*i18n*/
      {
        id: "YU1MkM"
      }
    )
  }), [e2, S2]), K2 = reactExports.useMemo(() => {
    var Q2;
    return (Q2 = e2.values.creditCard) != null && Q2.pin ? [U2, T2] : [U2, T2, F2];
  }, [U2, (pt = e2.values.creditCard) == null ? void 0 : pt.pin, F2, T2]), {
    ref: j,
    inlineUi: ie2
  } = oe(K2), ue2 = e2.values.uiType === "creditCard", Pe2 = a2 == null ? void 0 : a2.code.name;
  return /* @__PURE__ */ jsxs(Le, { children: [
    (ue2 || s2.number) && /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { className: y.FormElement, label: i18n._(
      /*i18n*/
      {
        id: "xHIEQ5"
      }
    ), icon: /* @__PURE__ */ jsx(l2, { title: (a2 == null ? void 0 : a2.niceType) ?? i18n._(
      /*i18n*/
      {
        id: "ooW934"
      }
    ), className: y.CreditCardIcon }), error: (_t = e2.touched.creditCard) != null && _t.number ? (Ze2 = e2.errors.creditCard) == null ? void 0 : Ze2.number : void 0, warning: c2.number, element: {
      type: "input",
      props: {
        type: "text",
        autoComplete: "off",
        ...e2.getFieldProps("creditCard.number"),
        onBlur: (Q2) => {
          if (e2.getFieldProps("creditCard.number").onBlur(Q2), t2)
            return;
          const Et = normalizeCreditCardNumber(Q2.currentTarget.value);
          e2.setFieldValue("creditCard.number", Et.number), e2.setFieldValue("creditCard.displayMaskedNumber", Et.displayMaskedNumber), e2.setFieldValue("creditCard.displayType", Et.displayType);
        },
        readOnly: t2,
        ref: u2
      }
    }, inlineUi: m2 }) }),
    (ue2 || s2.cardHolder) && /* @__PURE__ */ jsx("div", { className: y.FormElement, children: /* @__PURE__ */ jsx(J, { className: y.FormElement, label: i18n._(
      /*i18n*/
      {
        id: "bMFXRG"
      }
    ), error: (mt = e2.touched.creditCard) != null && mt.cardHolder ? (Me2 = e2.errors.creditCard) == null ? void 0 : Me2.cardHolder : void 0, element: {
      type: "input",
      props: {
        type: "text",
        autoComplete: "off",
        ...e2.getFieldProps("creditCard.cardHolder"),
        onBlur: (Q2) => {
          e2.getFieldProps("creditCard.cardHolder").onBlur(Q2), !t2 && e2.setFieldValue("creditCard.cardHolder", Q2.currentTarget.value.trim());
        },
        readOnly: t2,
        ref: g2
      }
    }, inlineUi: v2 }) }),
    (ue2 || s2.expiration || s2.securityCode) && /* @__PURE__ */ jsxs("div", { className: classNames(y.FormElement, y.CreditCardExpirationSecurityCode), children: [
      (ue2 || s2.expiration) && /* @__PURE__ */ jsx(J, { label: i18n._(
        /*i18n*/
        {
          id: "2Pjc5z"
        }
      ), className: y.CreditCardExpiration, error: (et = e2.touched.creditCard) != null && et.expiration ? (tt = e2.errors.creditCard) == null ? void 0 : tt.expiration : void 0, warning: c2.expiration, element: {
        type: "input",
        props: {
          type: "text",
          autoComplete: "off",
          ...e2.getFieldProps("creditCard.expiration"),
          onBlur: (Q2) => {
            e2.getFieldProps("creditCard.expiration").onBlur(Q2), !t2 && e2.setFieldValue("creditCard.expiration", normalizeCreditCardExpiration(Q2.currentTarget.value));
          },
          readOnly: t2,
          ref: N2
        }
      }, inlineUi: E2 }),
      !r2 && (ue2 || s2.securityCode) && (B2 ? /* @__PURE__ */ jsx(J, { label: a2 ? i18n._(
        /*i18n*/
        {
          id: "rmoyE2",
          values: {
            0: a2.code.size,
            cardCodeName: Pe2
          }
        }
      ) : i18n._(
        /*i18n*/
        {
          id: "wLmRnI"
        }
      ), className: y.CreditCardSecurityCode, error: (Oe2 = e2.touched.creditCard) != null && Oe2.securityCode ? (ge2 = e2.errors.creditCard) == null ? void 0 : ge2.securityCode : void 0, warning: c2.securityCode, element: {
        type: "input",
        props: {
          type: "text",
          autoComplete: "off",
          ...e2.getFieldProps("creditCard.securityCode"),
          readOnly: t2,
          ref: w2
        }
      }, inlineUi: R2, monospace: true }) : /* @__PURE__ */ jsx(Qe, { inlineUi: R2, ref: w2, onButtonClick: () => I2(true), className: y.CreditCardSecurityCode, changed: ((te2 = e2.initialValues.creditCard) == null ? void 0 : te2.securityCode) !== ((Fe2 = e2.values.creditCard) == null ? void 0 : Fe2.securityCode), children: /* @__PURE__ */ jsx(Trans, { id: "BqrHbB" }) }))
    ] }),
    !r2 && (ue2 || s2.pin) && /* @__PURE__ */ jsx("div", { className: y.FormElement, children: S2 ? /* @__PURE__ */ jsx(J, { label: i18n._(
      /*i18n*/
      {
        id: "sXULwc"
      }
    ), error: (nt = e2.touched.creditCard) != null && nt.pin ? (_e = e2.errors.creditCard) == null ? void 0 : _e.pin : void 0, element: {
      type: "input",
      props: {
        type: "text",
        autoComplete: "off",
        ...e2.getFieldProps("creditCard.pin"),
        readOnly: t2,
        ref: j
      }
    }, inlineUi: ie2, monospace: true }) : /* @__PURE__ */ jsx(Qe, { inlineUi: ie2, ref: j, onButtonClick: () => $(true), changed: ((mn = e2.initialValues.creditCard) == null ? void 0 : mn.pin) !== ((hn = e2.values.creditCard) == null ? void 0 : hn.pin), children: /* @__PURE__ */ jsx(Trans, { id: "2cIs6V" }) }) })
  ] });
});
function lu(e2) {
  const {
    card: t2,
    cardNumberWarning: n2,
    cardValid: r2
  } = reactExports.useMemo(() => {
    var l2;
    const a2 = At.number((l2 = e2.values.creditCard) == null ? void 0 : l2.number);
    return {
      cardValid: a2.isValid,
      card: a2.card,
      cardNumberWarning: Ft(e2, "number", a2)
    };
  }, [e2]), i = reactExports.useMemo(() => {
    var l2;
    const a2 = At.expirationDate((l2 = e2.values.creditCard) == null ? void 0 : l2.expiration);
    return Ft(e2, "expiration", a2);
  }, [e2]), s2 = reactExports.useMemo(() => {
    var l2;
    if (!r2 || !t2)
      return false;
    const a2 = At.cvv((l2 = e2.values.creditCard) == null ? void 0 : l2.securityCode, t2.code.size);
    return Ft(e2, "securityCode", a2);
  }, [t2, r2, e2]);
  return {
    warnings: {
      number: n2 ? i18n._(
        /*i18n*/
        {
          id: "0FSRiz"
        }
      ) : void 0,
      expiration: i ? i18n._(
        /*i18n*/
        {
          id: "Lyd22+"
        }
      ) : void 0,
      securityCode: s2 ? i18n._(
        /*i18n*/
        {
          id: "7xaBoY"
        }
      ) : void 0
    },
    card: t2
  };
}
function Ft(e2, t2, n2) {
  var r2, i;
  return (r2 = e2.values.creditCard) != null && r2[t2] ? (i = e2.touched.creditCard) != null && i[t2] ? !n2.isValid : !n2.isPotentiallyValid : false;
}
ee(["wifiSsid", "password"])(({
  formik: e2,
  writeAuditlogEvent: t2
}) => {
  const {
    action: n2,
    show: r2,
    setShow: i
  } = Ke({
    isEmpty: false,
    onShow: () => {
      t2 == null || t2({
        type: AuditlogEventType.WIFI_R_QR_SHOW
      });
    }
  }), s2 = reactExports.useMemo(() => [n2], [n2]), {
    ref: c2,
    inlineUi: a2
  } = oe(s2), l2 = bc(e2.values.wifiSsid ?? "", e2.values.password);
  return !e2.values.wifiSsid || !e2.values.password ? null : /* @__PURE__ */ jsx("div", { className: y.FormElement, children: r2 ? /* @__PURE__ */ jsx(Pc, { data: l2, inlineUi: a2 }) : /* @__PURE__ */ jsx(Qe, { inlineUi: a2, ref: c2, onButtonClick: () => i(true), changed: false, children: /* @__PURE__ */ jsx(Trans, { id: "vHxqT2" }) }) });
});
function Lo(e2, t2) {
  const n2 = [...e2.websites], r2 = {
    ...e2.websiteAttributes
  };
  let i;
  if (t2) {
    const s2 = n2[t2.index];
    if (s2) {
      const c2 = t2.oldNormalizedValue;
      i = normalizeWebsitePattern(s2);
      const a2 = getWebsiteAttributesEntry(s2);
      n2[t2.index] = i, r2[i] = {
        ...r2[i],
        ...r2 == null ? void 0 : r2[c2],
        ...a2
      };
    }
  }
  for (const s2 of Object.keys(r2))
    n2.includes(s2) || delete r2[s2];
  return e2.websiteAttributes === void 0 && Object.keys(r2).length === 0 ? {
    websites: n2,
    websiteAttributes: void 0,
    newFocusedWebsiteValue: i
  } : {
    websites: n2,
    websiteAttributes: r2,
    newFocusedWebsiteValue: i
  };
}
function ee(e2) {
  return function(n2) {
    return React$1.memo(n2, ({
      formik: r2,
      ...i
    }, {
      formik: s2,
      ...c2
    }) => {
      for (const a2 of e2)
        if (
          // Match formik FastField: https://github.com/jaredpalmer/formik/blob/958d67ca2c3e006031c31150ea0a42248b28ffc7/packages/formik/src/FastField.tsx#L79-L87
          r2.values[a2] !== s2.values[a2] || r2.touched[a2] !== s2.touched[a2] || r2.errors[a2] !== s2.errors[a2] || r2.isSubmitting !== s2.isSubmitting
        )
          return false;
      for (const a2 of Object.keys(i))
        if (vt(i, a2) && vt(c2, a2) && i[a2] !== c2[a2] || vt(i, a2) !== vt(c2, a2))
          return false;
      return true;
    });
  };
}
function vt(e2, t2) {
  return t2 in e2;
}
function zn({
  uiType: e2,
  permissions: t2,
  usePronoun: n2
}) {
  return t2.editLogin ? null : e2 === LoginUiType.creditCard ? n2 ? i18n._(
    /*i18n*/
    {
      id: "2rz/ET"
    }
  ) : i18n._(
    /*i18n*/
    {
      id: "KBRW1Z"
    }
  ) : e2 === LoginUiType.wifi ? n2 ? i18n._(
    /*i18n*/
    {
      id: "PwJojz"
    }
  ) : i18n._(
    /*i18n*/
    {
      id: "cyzc26"
    }
  ) : e2 === LoginUiType.login ? t2.useLogin && !t2.viewSecrets ? n2 ? i18n._(
    /*i18n*/
    {
      id: "du68I6"
    }
  ) : i18n._(
    /*i18n*/
    {
      id: "c8d9tl"
    }
  ) : n2 ? i18n._(
    /*i18n*/
    {
      id: "mJdpuD"
    }
  ) : i18n._(
    /*i18n*/
    {
      id: "ntxE/T"
    }
  ) : e2 === LoginUiType.note ? n2 ? i18n._(
    /*i18n*/
    {
      id: "7uotGR"
    }
  ) : i18n._(
    /*i18n*/
    {
      id: "U7HgqM"
    }
  ) : assertExhaustive();
}
const Wu = "_Push_16a0u_2", zu = "_landscape_16a0u_7", Du = "_PushStateInfo_16a0u_11", Uu = "_HelpMessage_16a0u_33", Vu = "_hidden_16a0u_38", ku = "_PushStateActionButton_16a0u_46", Hu = "_OpenMessage_16a0u_52", qu = "_OpenIcon_16a0u_64", ju = "_OpenAnimated_16a0u_77", Ku = "_ellipsis_16a0u_1", le = {
  Push: Wu,
  landscape: zu,
  PushStateInfo: Du,
  HelpMessage: Uu,
  hidden: Vu,
  PushStateActionButton: ku,
  OpenMessage: Hu,
  OpenIcon: qu,
  OpenAnimated: ju,
  ellipsis: Ku
}, Gu = "_LoginWindow_1apbt_1", Qu = "_open_1apbt_16", Yu = "_cornerBackground_1apbt_19", Ju = "_cornerBackgroundTransparent_1apbt_33", Xu = "_Background_1apbt_44", Zu = "_landscape_1apbt_74", ep = "_Content_1apbt_84", tp = "_additionalSideMargin_1apbt_94", np = "_respectContainerSize_1apbt_98", op = "_Close_1apbt_104", rp = "_Back_1apbt_44", ae = {
  LoginWindow: Gu,
  open: Qu,
  cornerBackground: Yu,
  cornerBackgroundTransparent: Ju,
  Background: Xu,
  landscape: Zu,
  Content: ep,
  additionalSideMargin: tp,
  respectContainerSize: np,
  Close: op,
  Back: rp
};
function ip({
  children: e2,
  className: t2,
  open: n2,
  landscape: r2,
  cornerBackground: i,
  cornerBackgroundTransparent: s2,
  respectContainerSize: c2,
  onResize: a2,
  onClose: l2,
  onBack: d2,
  onOpenEnd: u2
}) {
  const [m2, h2] = he(), [g2, v2] = he();
  reactExports.useEffect(() => {
    a2 && a2(v2.width, v2.height);
  }, [v2.height, v2.width, a2]);
  const [L2, N2] = he(), [E2, b2] = he(), B2 = reactExports.useMemo(() => {
    const R2 = (h2.height - v2.height) / 2, T2 = N2.height || b2.height;
    return R2 < T2;
  }, [b2.height, N2.height, h2.height, v2.height]), I2 = reactExports.useRef();
  reactExports.useEffect(() => {
    window.clearTimeout(I2.current), n2 && u2 && (I2.current = window.setTimeout(u2, 1e3));
  }, [u2, n2]);
  const A2 = reactExports.useMemo(() => debounce$1(10, () => {
    n2 && (window.clearTimeout(I2.current), u2 == null || u2());
  }), [u2, n2]), w2 = r2 ? Svg05454371D50Be11F : Svg86370Fb8F6D9029D;
  return /* @__PURE__ */ jsxs("div", { ref: m2, className: classNames(ae.LoginWindow, t2, {
    [ae.open]: n2,
    [ae.landscape]: r2,
    [ae.cornerBackground]: i,
    [ae.cornerBackgroundTransparent]: s2
  }), style: {
    // @ts-ignore css custom properties are a thing, even if typescript pretends they're not
    // stylelint-disable
    "--container-width": `${h2.width}px`,
    "--container-height": `${h2.height}px`,
    "--content-width": `${v2.width}px`,
    "--content-height": `${v2.height}px`,
    // stylelint-enable
    boxShadow: T
  }, children: [
    !i && /* @__PURE__ */ jsx(w2, { className: ae.Background, role: "presentation", onTransitionEnd: A2 }),
    /* @__PURE__ */ jsx("div", { ref: g2, className: classNames(ae.Content, {
      [ae.additionalSideMargin]: B2,
      [ae.respectContainerSize]: c2
    }), children: e2 }),
    l2 && /* @__PURE__ */ jsx("button", { type: "button", onClick: l2, className: ae.Close, ref: L2, children: /* @__PURE__ */ jsx(Svg85901Eed410D7B8F, { "aria-label": "Close" }) }),
    d2 && /* @__PURE__ */ jsx("button", { type: "button", onClick: d2, className: ae.Back, ref: E2, children: /* @__PURE__ */ jsx(SvgA67451C466Ea8Aca, { "aria-label": "Back" }) })
  ] });
}
function sp({
  unlockDeviceType: e2
}) {
  switch (e2) {
    case "phone":
      return /* @__PURE__ */ jsx(Trans, { id: "F0GBL0" });
    case "mobileSafari":
      return /* @__PURE__ */ jsx(Trans, { id: "aIJHYe" });
    case "multiple":
      return /* @__PURE__ */ jsx(Trans, { id: "MpA0AY" });
    case "securityKey":
      return /* @__PURE__ */ jsx(Trans, { id: "1yegnp" });
    default:
      assertExhaustive();
  }
}
function Ih({
  children: e2,
  state: t2,
  unlockDeviceType: n2,
  landscape: r2,
  cornerBackground: i,
  cornerBackgroundTransparent: s2,
  respectContainerSize: c2,
  onResize: a2,
  onClose: l2,
  onBack: d2,
  onOpenEnd: u2,
  onRetry: m2,
  onCancel: h2
}) {
  const g2 = t2 === "confirmed";
  return /* @__PURE__ */ jsx(ip, { open: g2, onResize: a2, onClose: l2, onBack: d2, onOpenEnd: u2, landscape: r2, cornerBackground: t2 === null ? i : false, cornerBackgroundTransparent: t2 === null ? s2 : false, respectContainerSize: c2, children: t2 === null ? e2 : g2 ? /* @__PURE__ */ jsx(cp, { landscape: r2 }) : /* @__PURE__ */ jsx(ap, { landscape: r2, state: t2, onRetry: m2, onCancel: h2, unlockDeviceType: n2 }) });
}
function ap({
  landscape: e2,
  state: t2,
  unlockDeviceType: n2,
  onRetry: r2,
  onCancel: i
}) {
  const [s2, c2] = reactExports.useState(false);
  return reactExports.useEffect(() => {
    if ((t2 === "warning" || t2 === "error") && c2(true), t2 === "connecting") {
      const a2 = setTimeout(() => c2(true), 15e3);
      return () => clearTimeout(a2);
    }
  }, [t2]), /* @__PURE__ */ jsxs("div", { className: classNames(le.Push, {
    [le.landscape]: e2
  }), children: [
    /* @__PURE__ */ jsx(Ki, { state: t2, small: e2, unlockDeviceType: n2 }),
    /* @__PURE__ */ jsxs("div", { className: le.PushStateInfo, children: [
      t2 === "error" || t2 === "warning" ? /* @__PURE__ */ jsx("p", { children: t2 === "error" ? i18n._(
        /*i18n*/
        {
          id: "zUtMod"
        }
      ) : i18n._(
        /*i18n*/
        {
          id: "7Bj3x9"
        }
      ) }) : /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx(sp, { unlockDeviceType: n2 }) }),
      (t2 === "error" || t2 === "warning") && r2 && /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx(be, { buttonStyle: "secondary", type: "button", onClick: r2, size: e2 ? "small" : "medium", className: le.PushStateActionButton, children: /* @__PURE__ */ jsx(Trans, { id: "KDw4GX" }) }) }),
      (t2 === "connecting" || t2 === "connected") && i && /* @__PURE__ */ jsx("p", { children: r2 && /* @__PURE__ */ jsx(be, { buttonStyle: "secondary", type: "button", onClick: i, size: e2 ? "small" : "medium", className: le.PushStateActionButton, children: /* @__PURE__ */ jsx(Trans, { id: "dEgA5A" }) }) }),
      /* @__PURE__ */ jsx("p", { "aria-hidden": !s2, className: classNames(le.HelpMessage, !s2 && le.hidden), children: /* @__PURE__ */ jsx(Co, { href: i18n._(
        /*i18n*/
        {
          id: "62ft/Z"
        }
      ), children: /* @__PURE__ */ jsx(Trans, { id: "xAAcWG" }) }) })
    ] })
  ] });
}
function cp({
  landscape: e2
}) {
  return /* @__PURE__ */ jsxs("div", { className: classNames(le.OpenMessage, {
    [le.landscape]: e2
  }), children: [
    /* @__PURE__ */ jsx(SvgF36883B8Db9C47Da, { className: le.OpenIcon, role: "presentation" }),
    /* @__PURE__ */ jsx("div", { className: le.OpenAnimated, children: /* @__PURE__ */ jsx(Trans, { id: "zUDyah" }) })
  ] });
}
const lp = "_Button_ouh1f_1", dp = "_Username_ouh1f_23", Vn = {
  Button: lp,
  Username: dp
};
function Sh({
  children: e2,
  onClick: t2,
  size: n2,
  className: r2,
  icon: i
}) {
  return /* @__PURE__ */ jsxs(be, { buttonStyle: "secondary", className: classNames(Vn.Button, r2), onClick: t2, size: n2, children: [
    i && /* @__PURE__ */ jsx(up, { icon: i }),
    /* @__PURE__ */ jsx("span", { className: Vn.Username, children: e2 }),
    " ",
    /* @__PURE__ */ jsx(Svg02Fe5840D790De36, {})
  ] });
}
function up({
  icon: e2,
  ...t2
}) {
  const n2 = e2 === "team" ? SvgC1B53E269A6A3694 : e2 === "inbox" ? Svg86A990C017Ab6E32 : assertExhaustive();
  return /* @__PURE__ */ jsx(n2, { ...t2 });
}
const Ep = "_NativeSelectWrapper_9ajt1_1", Pp = "_disabled_9ajt1_5", Ap = "_NativeSelect_9ajt1_1", Mp = "_Chevron_9ajt1_31", wt = {
  NativeSelectWrapper: Ep,
  disabled: Pp,
  NativeSelect: Ap,
  Chevron: Mp
};
function Th({
  className: e2,
  wrapperClassName: t2,
  ...n2
}) {
  return /* @__PURE__ */ jsxs("div", { className: classNames(wt.NativeSelectWrapper, {
    [wt.disabled]: n2.disabled
  }, t2), children: [
    /* @__PURE__ */ jsx("select", { className: classNames(wt.NativeSelect, e2), ...n2 }),
    /* @__PURE__ */ jsx(Svg588D2E3C75F50062, { className: wt.Chevron })
  ] });
}
const Op = "_SearchInputWrapper_1f8f1_1", Fp = "_small_1f8f1_8", Wp = "_dark_1f8f1_11", zp = "_SearchInput_1f8f1_1", Dp = "_SearchOverlay_1f8f1_49", Up = "_SearchOverlayIcon_1f8f1_61", Vp = "_PlaceholderText_1f8f1_73", kp = "_InlineUi_1f8f1_84", Hp = "_ClearButton_1f8f1_90 _UnstyledButton_14p2i_205", Ce = {
  SearchInputWrapper: Op,
  small: Fp,
  dark: Wp,
  SearchInput: zp,
  SearchOverlay: Dp,
  SearchOverlayIcon: Up,
  PlaceholderText: Vp,
  InlineUi: kp,
  ClearButton: Hp
}, $h = React$1.forwardRef(({
  value: e2,
  suggestions: t2,
  onKeyDown: n2,
  placeholder: r2,
  className: i,
  size: s2,
  inlineUi: c2,
  clear: a2,
  ...l2
}, d2) => {
  const u2 = reactExports.useRef(null), m2 = Z(), [h2, {
    width: g2
  }] = he();
  return /* @__PURE__ */ jsxs("div", { className: classNames(Ce.SearchInputWrapper, i, Ce[m2], Ce[s2 ?? "medium"]), style: {
    "--inline-ui-width": `${g2}px`
  }, children: [
    /* @__PURE__ */ jsx("input", { ...l2, type: "search", value: e2, className: classNames(Ce.SearchInput), autoCapitalize: "off", autoCorrect: "off", onKeyDown: a2 ? (v2) => {
      n2 == null || n2(v2), !v2.defaultPrevented && v2.key === "Escape" && e2 && (a2(), v2.preventDefault());
    } : n2, ref: qp(d2, u2) }),
    !!e2 && !!a2 && /* @__PURE__ */ jsx("button", { type: "button", onClick: () => {
      var v2;
      (v2 = u2.current) == null || v2.focus(), a2();
    }, className: Ce.ClearButton, children: /* @__PURE__ */ jsx(Svg12F2Ab3739Adfbea, { title: i18n._(
      /*i18n*/
      {
        id: "xCJdfg"
      }
    ) }) }),
    /* @__PURE__ */ jsxs("div", { className: Ce.SearchOverlay, children: [
      /* @__PURE__ */ jsx("div", { className: Ce.SearchOverlayIcon, children: /* @__PURE__ */ jsx(Svg78Cd0901269Cea25, {}) }),
      /* @__PURE__ */ jsx("div", { className: Ce.PlaceholderText, children: !e2 && r2 }),
      c2 && /* @__PURE__ */ jsx("div", { className: Ce.InlineUi, ref: h2, children: c2 })
    ] }),
    t2
  ] });
});
function qp(...e2) {
  return (t2) => {
    for (const n2 of e2)
      typeof n2 == "function" ? n2(t2) : n2 !== null && (n2.current = t2);
  };
}
function i_({
  className: e2
}) {
  const t2 = Ye(), n2 = Z();
  return t2 === "highlight" || n2 === "dark" ? /* @__PURE__ */ jsx(Svg9B19Acdf996Aea57, { role: "img", "aria-label": "heylogin", className: e2 }) : /* @__PURE__ */ jsx(Svg8Dd98122Bc298E52, { role: "img", "aria-label": "heylogin", className: e2 });
}
const u_ = "_Shortcut_1mv74_1", p_ = "_inverted_1mv74_11", __ = "_small_1mv74_15", m_ = "_Key_1mv74_20", Nt = {
  Shortcut: u_,
  inverted: p_,
  small: __,
  Key: m_
};
function Ah({
  shortcut: e2,
  small: t2,
  applePlatform: n2,
  invertColors: r2
}) {
  const i = reactExports.useMemo(() => {
    if (e2)
      return F$1(e2, n2);
  }, [n2, e2]);
  return /* @__PURE__ */ jsx("div", { className: classNames(Nt.Shortcut, {
    [Nt.small]: t2,
    [Nt.inverted]: r2
  }), children: i == null ? void 0 : i.map((s2, c2, a2) => /* @__PURE__ */ jsx(h_, { keyLabel: s2, trailingPlus: !t2 && c2 < a2.length - 1 }, s2)) });
}
function h_({
  keyLabel: e2,
  trailingPlus: t2
}) {
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx("div", { className: Nt.Key, children: e2 }),
    t2 && "+"
  ] });
}
Bo.shim();
const objectToString = Object.prototype.toString;
function isError(wat) {
  switch (objectToString.call(wat)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isBuiltin(wat, className) {
  return objectToString.call(wat) === `[object ${className}]`;
}
function isErrorEvent$1(wat) {
  return isBuiltin(wat, "ErrorEvent");
}
function isDOMError(wat) {
  return isBuiltin(wat, "DOMError");
}
function isDOMException(wat) {
  return isBuiltin(wat, "DOMException");
}
function isString3(wat) {
  return isBuiltin(wat, "String");
}
function isParameterizedString(wat) {
  return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
}
function isPrimitive(wat) {
  return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject(wat) {
  return isBuiltin(wat, "Object");
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return isBuiltin(wat, "RegExp");
}
function isThenable(wat) {
  return Boolean(wat && wat.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isNaN$1(wat) {
  return typeof wat === "number" && wat !== wat;
}
function isInstanceOf(wat, base2) {
  try {
    return wat instanceof base2;
  } catch (_e) {
    return false;
  }
}
function isVueViewModel(wat) {
  return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
}
function truncate(str, max2 = 0) {
  if (typeof str !== "string" || max2 === 0) {
    return str;
  }
  return str.length <= max2 ? str : `${str.slice(0, max2)}...`;
}
function safeJoin(input, delimiter2) {
  if (!Array.isArray(input)) {
    return "";
  }
  const output = [];
  for (let i = 0; i < input.length; i++) {
    const value = input[i];
    try {
      if (isVueViewModel(value)) {
        output.push("[VueViewModel]");
      } else {
        output.push(String(value));
      }
    } catch (e2) {
      output.push("[value cannot be serialized]");
    }
  }
  return output.join(delimiter2);
}
function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
  if (!isString3(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (isString3(pattern)) {
    return requireExactStringMatch ? value === pattern : value.includes(pattern);
  }
  return false;
}
function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
  return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
}
function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return;
  }
  const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
  if (originalException) {
    event.exception.values = truncateAggregateExceptions(
      aggregateExceptionsFromError(
        exceptionFromErrorImplementation,
        parser,
        limit,
        hint.originalException,
        key,
        event.exception.values,
        originalException,
        0
      ),
      maxValueLimit
    );
  }
}
function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error2, key, prevExceptions, exception, exceptionId) {
  if (prevExceptions.length >= limit + 1) {
    return prevExceptions;
  }
  let newExceptions = [...prevExceptions];
  if (isInstanceOf(error2[key], Error)) {
    applyExceptionGroupFieldsForParentException(exception, exceptionId);
    const newException = exceptionFromErrorImplementation(parser, error2[key]);
    const newExceptionId = newExceptions.length;
    applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
    newExceptions = aggregateExceptionsFromError(
      exceptionFromErrorImplementation,
      parser,
      limit,
      error2[key],
      key,
      [newException, ...newExceptions],
      newException,
      newExceptionId
    );
  }
  if (Array.isArray(error2.errors)) {
    error2.errors.forEach((childError, i) => {
      if (isInstanceOf(childError, Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, childError);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          childError,
          key,
          [newException, ...newExceptions],
          newException,
          newExceptionId
        );
      }
    });
  }
  return newExceptions;
}
function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    ...exception.type === "AggregateError" && { is_exception_group: true },
    exception_id: exceptionId
  };
}
function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    type: "chained",
    source,
    exception_id: exceptionId,
    parent_id: parentId
  };
}
function truncateAggregateExceptions(exceptions, maxValueLength) {
  return exceptions.map((exception) => {
    if (exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }
    return exception;
  });
}
function isGlobalObj(obj) {
  return obj && obj.Math == Math ? obj : void 0;
}
const GLOBAL_OBJ = typeof globalThis == "object" && isGlobalObj(globalThis) || // eslint-disable-next-line no-restricted-globals
typeof window == "object" && isGlobalObj(window) || typeof self == "object" && isGlobalObj(self) || typeof global == "object" && isGlobalObj(global) || function() {
  return this;
}() || {};
function getGlobalObject() {
  return GLOBAL_OBJ;
}
function getGlobalSingleton(name, creator, obj) {
  const gbl = obj || GLOBAL_OBJ;
  const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
  const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
  return singleton;
}
const WINDOW$6 = getGlobalObject();
const DEFAULT_MAX_STRING_LENGTH = 80;
function htmlTreeAsString(elem, options = {}) {
  if (!elem) {
    return "<unknown>";
  }
  try {
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    const out = [];
    let height = 0;
    let len = 0;
    const separator = " > ";
    const sepLength = separator.length;
    let nextStr;
    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
    const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch (_oO) {
    return "<unknown>";
  }
}
function _htmlElementAsString(el2, keyAttrs) {
  const elem = el2;
  const out = [];
  let className;
  let classes;
  let key;
  let attr;
  let i;
  if (!elem || !elem.tagName) {
    return "";
  }
  if (WINDOW$6.HTMLElement) {
    if (elem instanceof HTMLElement && elem.dataset && elem.dataset["sentryComponent"]) {
      return elem.dataset["sentryComponent"];
    }
  }
  out.push(elem.tagName.toLowerCase());
  const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
  if (keyAttrPairs && keyAttrPairs.length) {
    keyAttrPairs.forEach((keyAttrPair) => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }
    className = elem.className;
    if (className && isString3(className)) {
      classes = className.split(/\s+/);
      for (i = 0; i < classes.length; i++) {
        out.push(`.${classes[i]}`);
      }
    }
  }
  const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
  for (i = 0; i < allowedAttrs.length; i++) {
    key = allowedAttrs[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push(`[${key}="${attr}"]`);
    }
  }
  return out.join("");
}
function getLocationHref() {
  try {
    return WINDOW$6.document.location.href;
  } catch (oO) {
    return "";
  }
}
function getComponentName(elem) {
  if (!WINDOW$6.HTMLElement) {
    return null;
  }
  let currentElem = elem;
  const MAX_TRAVERSE_HEIGHT = 5;
  for (let i = 0; i < MAX_TRAVERSE_HEIGHT; i++) {
    if (!currentElem) {
      return null;
    }
    if (currentElem instanceof HTMLElement && currentElem.dataset["sentryComponent"]) {
      return currentElem.dataset["sentryComponent"];
    }
    currentElem = currentElem.parentNode;
  }
  return null;
}
const DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
const PREFIX = "Sentry Logger ";
const CONSOLE_LEVELS = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
];
const originalConsoleMethods = {};
function consoleSandbox(callback) {
  if (!("console" in GLOBAL_OBJ)) {
    return callback();
  }
  const console2 = GLOBAL_OBJ.console;
  const wrappedFuncs = {};
  const wrappedLevels = Object.keys(originalConsoleMethods);
  wrappedLevels.forEach((level) => {
    const originalConsoleMethod = originalConsoleMethods[level];
    wrappedFuncs[level] = console2[level];
    console2[level] = originalConsoleMethod;
  });
  try {
    return callback();
  } finally {
    wrappedLevels.forEach((level) => {
      console2[level] = wrappedFuncs[level];
    });
  }
}
function makeLogger() {
  let enabled = false;
  const logger2 = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
    isEnabled: () => enabled
  };
  if (DEBUG_BUILD$2) {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = () => void 0;
    });
  }
  return logger2;
}
const logger = makeLogger();
const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
  return protocol === "http" || protocol === "https";
}
function dsnToString(dsn, withPassword = false) {
  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;
  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
}
function dsnFromString(str) {
  const match2 = DSN_REGEX.exec(str);
  if (!match2) {
    consoleSandbox(() => {
      console.error(`Invalid Sentry Dsn: ${str}`);
    });
    return void 0;
  }
  const [protocol, publicKey, pass = "", host, port = "", lastPath] = match2.slice(1);
  let path = "";
  let projectId = lastPath;
  const split = projectId.split("/");
  if (split.length > 1) {
    path = split.slice(0, -1).join("/");
    projectId = split.pop();
  }
  if (projectId) {
    const projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }
  return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
}
function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || "",
    pass: components.pass || "",
    host: components.host,
    port: components.port || "",
    path: components.path || "",
    projectId: components.projectId
  };
}
function validateDsn(dsn) {
  if (!DEBUG_BUILD$2) {
    return true;
  }
  const { port, projectId, protocol } = dsn;
  const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
  const hasMissingRequiredComponent = requiredComponents.find((component) => {
    if (!dsn[component]) {
      logger.error(`Invalid Sentry Dsn: ${component} missing`);
      return true;
    }
    return false;
  });
  if (hasMissingRequiredComponent) {
    return false;
  }
  if (!projectId.match(/^\d+$/)) {
    logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
    return false;
  }
  if (!isValidProtocol(protocol)) {
    logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
    return false;
  }
  if (port && isNaN(parseInt(port, 10))) {
    logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
    return false;
  }
  return true;
}
function makeDsn(from) {
  const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
  if (!components || !validateDsn(components)) {
    return void 0;
  }
  return components;
}
class SentryError extends Error {
  /** Display name of this error instance. */
  constructor(message, logLevel = "warn") {
    super(message);
    this.message = message;
    this.name = new.target.prototype.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
    this.logLevel = logLevel;
  }
}
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  const original = source[name];
  const wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    markFunctionWrapped(wrapped, original);
  }
  source[name] = wrapped;
}
function addNonEnumerableProperty(obj, name, value) {
  try {
    Object.defineProperty(obj, name, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value,
      writable: true,
      configurable: true
    });
  } catch (o_O) {
    DEBUG_BUILD$2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
  }
}
function markFunctionWrapped(wrapped, original) {
  try {
    const proto2 = original.prototype || {};
    wrapped.prototype = original.prototype = proto2;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  } catch (o_O) {
  }
}
function getOriginalFunction(func) {
  return func.__sentry_original__;
}
function urlEncode(object) {
  return Object.keys(object).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`).join("&");
}
function convertToPlainObject(value) {
  if (isError(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value)
    };
  } else if (isEvent(value)) {
    const newObj = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value)
    };
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      newObj.detail = value.detail;
    }
    return newObj;
  } else {
    return value;
  }
}
function serializeEventTarget(target) {
  try {
    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return "<unknown>";
  }
}
function getOwnProperties(obj) {
  if (typeof obj === "object" && obj !== null) {
    const extractedProps = {};
    for (const property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = obj[property];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  const keys3 = Object.keys(convertToPlainObject(exception));
  keys3.sort();
  if (!keys3.length) {
    return "[object has no keys]";
  }
  if (keys3[0].length >= maxLength) {
    return truncate(keys3[0], maxLength);
  }
  for (let includedKeys = keys3.length; includedKeys > 0; includedKeys--) {
    const serialized = keys3.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys3.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}
function dropUndefinedKeys(inputValue) {
  const memoizationMap = /* @__PURE__ */ new Map();
  return _dropUndefinedKeys(inputValue, memoizationMap);
}
function _dropUndefinedKeys(inputValue, memoizationMap) {
  if (isPojo(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== void 0) {
      return memoVal;
    }
    const returnValue = {};
    memoizationMap.set(inputValue, returnValue);
    for (const key of Object.keys(inputValue)) {
      if (typeof inputValue[key] !== "undefined") {
        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
      }
    }
    return returnValue;
  }
  if (Array.isArray(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== void 0) {
      return memoVal;
    }
    const returnValue = [];
    memoizationMap.set(inputValue, returnValue);
    inputValue.forEach((item) => {
      returnValue.push(_dropUndefinedKeys(item, memoizationMap));
    });
    return returnValue;
  }
  return inputValue;
}
function isPojo(input) {
  if (!isPlainObject(input)) {
    return false;
  }
  try {
    const name = Object.getPrototypeOf(input).constructor.name;
    return !name || name === "Object";
  } catch (e2) {
    return true;
  }
}
const STACKTRACE_FRAME_LIMIT = 50;
const WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
const STRIP_FRAME_REGEXP = /captureMessage|captureException/;
function createStackParser(...parsers) {
  const sortedParsers = parsers.sort((a2, b2) => a2[0] - b2[0]).map((p2) => p2[1]);
  return (stack, skipFirst = 0) => {
    const frames = [];
    const lines = stack.split("\n");
    for (let i = skipFirst; i < lines.length; i++) {
      const line = lines[i];
      if (line.length > 1024) {
        continue;
      }
      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
      if (cleanedLine.match(/\S*Error: /)) {
        continue;
      }
      for (const parser of sortedParsers) {
        const frame = parser(cleanedLine);
        if (frame) {
          frames.push(frame);
          break;
        }
      }
      if (frames.length >= STACKTRACE_FRAME_LIMIT) {
        break;
      }
    }
    return stripSentryFramesAndReverse(frames);
  };
}
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }
  const localStack = Array.from(stack);
  if (/sentryWrapped/.test(localStack[localStack.length - 1].function || "")) {
    localStack.pop();
  }
  localStack.reverse();
  if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
    localStack.pop();
    if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
      localStack.pop();
    }
  }
  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
    ...frame,
    filename: frame.filename || localStack[localStack.length - 1].filename,
    function: frame.function || "?"
  }));
}
const defaultFunctionName = "<anonymous>";
function getFunctionName(fn) {
  try {
    if (!fn || typeof fn !== "function") {
      return defaultFunctionName;
    }
    return fn.name || defaultFunctionName;
  } catch (e2) {
    return defaultFunctionName;
  }
}
const handlers = {};
const instrumented = {};
function addHandler(type, handler) {
  handlers[type] = handlers[type] || [];
  handlers[type].push(handler);
}
function maybeInstrument(type, instrumentFn) {
  if (!instrumented[type]) {
    instrumentFn();
    instrumented[type] = true;
  }
}
function triggerHandlers(type, data) {
  const typeHandlers = type && handlers[type];
  if (!typeHandlers) {
    return;
  }
  for (const handler of typeHandlers) {
    try {
      handler(data);
    } catch (e2) {
      DEBUG_BUILD$2 && logger.error(
        `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
        e2
      );
    }
  }
}
function addConsoleInstrumentationHandler(handler) {
  const type = "console";
  addHandler(type, handler);
  maybeInstrument(type, instrumentConsole);
}
function instrumentConsole() {
  if (!("console" in GLOBAL_OBJ)) {
    return;
  }
  CONSOLE_LEVELS.forEach(function(level) {
    if (!(level in GLOBAL_OBJ.console)) {
      return;
    }
    fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
      originalConsoleMethods[level] = originalConsoleMethod;
      return function(...args) {
        const handlerData = { args, level };
        triggerHandlers("console", handlerData);
        const log = originalConsoleMethods[level];
        log && log.apply(GLOBAL_OBJ.console, args);
      };
    });
  });
}
function uuid4() {
  const gbl = GLOBAL_OBJ;
  const crypto2 = gbl.crypto || gbl.msCrypto;
  let getRandomByte = () => Math.random() * 16;
  try {
    if (crypto2 && crypto2.randomUUID) {
      return crypto2.randomUUID().replace(/-/g, "");
    }
    if (crypto2 && crypto2.getRandomValues) {
      getRandomByte = () => {
        const typedArray = new Uint8Array(1);
        crypto2.getRandomValues(typedArray);
        return typedArray[0];
      };
    }
  } catch (_2) {
  }
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(
    /[018]/g,
    (c2) => (
      // eslint-disable-next-line no-bitwise
      (c2 ^ (getRandomByte() & 15) >> c2 / 4).toString(16)
    )
  );
}
function getFirstException(event) {
  return event.exception && event.exception.values ? event.exception.values[0] : void 0;
}
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }
  const firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || "<unknown>";
  }
  return eventId || "<unknown>";
}
function addExceptionTypeValue(event, value, type) {
  const exception = event.exception = event.exception || {};
  const values2 = exception.values = exception.values || [];
  const firstException = values2[0] = values2[0] || {};
  if (!firstException.value) {
    firstException.value = value || "";
  }
  if (!firstException.type) {
    firstException.type = type || "Error";
  }
}
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  const defaultMechanism = { type: "generic", handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
  if (newMechanism && "data" in newMechanism) {
    const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}
function checkOrSetAlreadyCaught(exception) {
  if (exception && exception.__sentry_captured__) {
    return true;
  }
  try {
    addNonEnumerableProperty(exception, "__sentry_captured__", true);
  } catch (err) {
  }
  return false;
}
function arrayify(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
}
const WINDOW$5 = GLOBAL_OBJ;
const DEBOUNCE_DURATION = 1e3;
let debounceTimerID;
let lastCapturedEventType;
let lastCapturedEventTargetId;
function addClickKeypressInstrumentationHandler(handler) {
  const type = "dom";
  addHandler(type, handler);
  maybeInstrument(type, instrumentDOM);
}
function instrumentDOM() {
  if (!WINDOW$5.document) {
    return;
  }
  const triggerDOMHandler = triggerHandlers.bind(null, "dom");
  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
  WINDOW$5.document.addEventListener("click", globalDOMEventHandler, false);
  WINDOW$5.document.addEventListener("keypress", globalDOMEventHandler, false);
  ["EventTarget", "Node"].forEach((target) => {
    const proto2 = WINDOW$5[target] && WINDOW$5[target].prototype;
    if (!proto2 || !proto2.hasOwnProperty || !proto2.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto2, "addEventListener", function(originalAddEventListener) {
      return function(type, listener, options) {
        if (type === "click" || type == "keypress") {
          try {
            const el2 = this;
            const handlers2 = el2.__sentry_instrumentation_handlers__ = el2.__sentry_instrumentation_handlers__ || {};
            const handlerForType = handlers2[type] = handlers2[type] || { refCount: 0 };
            if (!handlerForType.handler) {
              const handler = makeDOMEventHandler(triggerDOMHandler);
              handlerForType.handler = handler;
              originalAddEventListener.call(this, type, handler, options);
            }
            handlerForType.refCount++;
          } catch (e2) {
          }
        }
        return originalAddEventListener.call(this, type, listener, options);
      };
    });
    fill(
      proto2,
      "removeEventListener",
      function(originalRemoveEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              const el2 = this;
              const handlers2 = el2.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers2[type];
              if (handlerForType) {
                handlerForType.refCount--;
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = void 0;
                  delete handlers2[type];
                }
                if (Object.keys(handlers2).length === 0) {
                  delete el2.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e2) {
            }
          }
          return originalRemoveEventListener.call(this, type, listener, options);
        };
      }
    );
  });
}
function isSimilarToLastCapturedEvent(event) {
  if (event.type !== lastCapturedEventType) {
    return false;
  }
  try {
    if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
      return false;
    }
  } catch (e2) {
  }
  return true;
}
function shouldSkipDOMEvent(eventType, target) {
  if (eventType !== "keypress") {
    return false;
  }
  if (!target || !target.tagName) {
    return true;
  }
  if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
    return false;
  }
  return true;
}
function makeDOMEventHandler(handler, globalListener = false) {
  return (event) => {
    if (!event || event["_sentryCaptured"]) {
      return;
    }
    const target = getEventTarget(event);
    if (shouldSkipDOMEvent(event.type, target)) {
      return;
    }
    addNonEnumerableProperty(event, "_sentryCaptured", true);
    if (target && !target._sentryId) {
      addNonEnumerableProperty(target, "_sentryId", uuid4());
    }
    const name = event.type === "keypress" ? "input" : event.type;
    if (!isSimilarToLastCapturedEvent(event)) {
      const handlerData = { event, name, global: globalListener };
      handler(handlerData);
      lastCapturedEventType = event.type;
      lastCapturedEventTargetId = target ? target._sentryId : void 0;
    }
    clearTimeout(debounceTimerID);
    debounceTimerID = WINDOW$5.setTimeout(() => {
      lastCapturedEventTargetId = void 0;
      lastCapturedEventType = void 0;
    }, DEBOUNCE_DURATION);
  };
}
function getEventTarget(event) {
  try {
    return event.target;
  } catch (e2) {
    return null;
  }
}
const WINDOW$4 = getGlobalObject();
function supportsFetch() {
  if (!("fetch" in WINDOW$4)) {
    return false;
  }
  try {
    new Headers();
    new Request("http://www.example.com");
    new Response();
    return true;
  } catch (e2) {
    return false;
  }
}
function isNativeFetch(func) {
  return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
function supportsNativeFetch() {
  if (typeof EdgeRuntime === "string") {
    return true;
  }
  if (!supportsFetch()) {
    return false;
  }
  if (isNativeFetch(WINDOW$4.fetch)) {
    return true;
  }
  let result = false;
  const doc = WINDOW$4.document;
  if (doc && typeof doc.createElement === "function") {
    try {
      const sandbox = doc.createElement("iframe");
      sandbox.hidden = true;
      doc.head.appendChild(sandbox);
      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
        result = isNativeFetch(sandbox.contentWindow.fetch);
      }
      doc.head.removeChild(sandbox);
    } catch (err) {
      DEBUG_BUILD$2 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
    }
  }
  return result;
}
function addFetchInstrumentationHandler(handler) {
  const type = "fetch";
  addHandler(type, handler);
  maybeInstrument(type, instrumentFetch);
}
function instrumentFetch() {
  if (!supportsNativeFetch()) {
    return;
  }
  fill(GLOBAL_OBJ, "fetch", function(originalFetch) {
    return function(...args) {
      const { method, url } = parseFetchArgs(args);
      const handlerData = {
        args,
        fetchData: {
          method,
          url
        },
        startTimestamp: Date.now()
      };
      triggerHandlers("fetch", {
        ...handlerData
      });
      return originalFetch.apply(GLOBAL_OBJ, args).then(
        (response) => {
          const finishedHandlerData = {
            ...handlerData,
            endTimestamp: Date.now(),
            response
          };
          triggerHandlers("fetch", finishedHandlerData);
          return response;
        },
        (error2) => {
          const erroredHandlerData = {
            ...handlerData,
            endTimestamp: Date.now(),
            error: error2
          };
          triggerHandlers("fetch", erroredHandlerData);
          throw error2;
        }
      );
    };
  });
}
function hasProp(obj, prop) {
  return !!obj && typeof obj === "object" && !!obj[prop];
}
function getUrlFromResource(resource) {
  if (typeof resource === "string") {
    return resource;
  }
  if (!resource) {
    return "";
  }
  if (hasProp(resource, "url")) {
    return resource.url;
  }
  if (resource.toString) {
    return resource.toString();
  }
  return "";
}
function parseFetchArgs(fetchArgs) {
  if (fetchArgs.length === 0) {
    return { method: "GET", url: "" };
  }
  if (fetchArgs.length === 2) {
    const [url, options] = fetchArgs;
    return {
      url: getUrlFromResource(url),
      method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
    };
  }
  const arg = fetchArgs[0];
  return {
    url: getUrlFromResource(arg),
    method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
  };
}
let _oldOnErrorHandler = null;
function addGlobalErrorInstrumentationHandler(handler) {
  const type = "error";
  addHandler(type, handler);
  maybeInstrument(type, instrumentError);
}
function instrumentError() {
  _oldOnErrorHandler = GLOBAL_OBJ.onerror;
  GLOBAL_OBJ.onerror = function(msg, url, line, column, error2) {
    const handlerData = {
      column,
      error: error2,
      line,
      msg,
      url
    };
    triggerHandlers("error", handlerData);
    if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
}
let _oldOnUnhandledRejectionHandler = null;
function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
  const type = "unhandledrejection";
  addHandler(type, handler);
  maybeInstrument(type, instrumentUnhandledRejection);
}
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
  GLOBAL_OBJ.onunhandledrejection = function(e2) {
    const handlerData = e2;
    triggerHandlers("unhandledrejection", handlerData);
    if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
  GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}
const WINDOW$3 = getGlobalObject();
function supportsHistory() {
  const chromeVar = WINDOW$3.chrome;
  const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;
  const hasHistoryApi = "history" in WINDOW$3 && !!WINDOW$3.history.pushState && !!WINDOW$3.history.replaceState;
  return !isChromePackagedApp && hasHistoryApi;
}
const WINDOW$2 = GLOBAL_OBJ;
let lastHref;
function addHistoryInstrumentationHandler(handler) {
  const type = "history";
  addHandler(type, handler);
  maybeInstrument(type, instrumentHistory);
}
function instrumentHistory() {
  if (!supportsHistory()) {
    return;
  }
  const oldOnPopState = WINDOW$2.onpopstate;
  WINDOW$2.onpopstate = function(...args) {
    const to2 = WINDOW$2.location.href;
    const from = lastHref;
    lastHref = to2;
    const handlerData = { from, to: to2 };
    triggerHandlers("history", handlerData);
    if (oldOnPopState) {
      try {
        return oldOnPopState.apply(this, args);
      } catch (_oO) {
      }
    }
  };
  function historyReplacementFunction(originalHistoryFunction) {
    return function(...args) {
      const url = args.length > 2 ? args[2] : void 0;
      if (url) {
        const from = lastHref;
        const to2 = String(url);
        lastHref = to2;
        const handlerData = { from, to: to2 };
        triggerHandlers("history", handlerData);
      }
      return originalHistoryFunction.apply(this, args);
    };
  }
  fill(WINDOW$2.history, "pushState", historyReplacementFunction);
  fill(WINDOW$2.history, "replaceState", historyReplacementFunction);
}
const WINDOW$1 = GLOBAL_OBJ;
const SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
function addXhrInstrumentationHandler(handler) {
  const type = "xhr";
  addHandler(type, handler);
  maybeInstrument(type, instrumentXHR);
}
function instrumentXHR() {
  if (!WINDOW$1.XMLHttpRequest) {
    return;
  }
  const xhrproto = XMLHttpRequest.prototype;
  fill(xhrproto, "open", function(originalOpen) {
    return function(...args) {
      const startTimestamp = Date.now();
      const method = isString3(args[0]) ? args[0].toUpperCase() : void 0;
      const url = parseUrl$1(args[1]);
      if (!method || !url) {
        return originalOpen.apply(this, args);
      }
      this[SENTRY_XHR_DATA_KEY] = {
        method,
        url,
        request_headers: {}
      };
      if (method === "POST" && url.match(/sentry_key/)) {
        this.__sentry_own_request__ = true;
      }
      const onreadystatechangeHandler = () => {
        const xhrInfo = this[SENTRY_XHR_DATA_KEY];
        if (!xhrInfo) {
          return;
        }
        if (this.readyState === 4) {
          try {
            xhrInfo.status_code = this.status;
          } catch (e2) {
          }
          const handlerData = {
            args: [method, url],
            endTimestamp: Date.now(),
            startTimestamp,
            xhr: this
          };
          triggerHandlers("xhr", handlerData);
        }
      };
      if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
        fill(this, "onreadystatechange", function(original) {
          return function(...readyStateArgs) {
            onreadystatechangeHandler();
            return original.apply(this, readyStateArgs);
          };
        });
      } else {
        this.addEventListener("readystatechange", onreadystatechangeHandler);
      }
      fill(this, "setRequestHeader", function(original) {
        return function(...setRequestHeaderArgs) {
          const [header, value] = setRequestHeaderArgs;
          const xhrInfo = this[SENTRY_XHR_DATA_KEY];
          if (xhrInfo && isString3(header) && isString3(value)) {
            xhrInfo.request_headers[header.toLowerCase()] = value;
          }
          return original.apply(this, setRequestHeaderArgs);
        };
      });
      return originalOpen.apply(this, args);
    };
  });
  fill(xhrproto, "send", function(originalSend) {
    return function(...args) {
      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
      if (!sentryXhrData) {
        return originalSend.apply(this, args);
      }
      if (args[0] !== void 0) {
        sentryXhrData.body = args[0];
      }
      const handlerData = {
        args: [sentryXhrData.method, sentryXhrData.url],
        startTimestamp: Date.now(),
        xhr: this
      };
      triggerHandlers("xhr", handlerData);
      return originalSend.apply(this, args);
    };
  });
}
function parseUrl$1(url) {
  if (isString3(url)) {
    return url;
  }
  try {
    return url.toString();
  } catch (e2) {
  }
  return void 0;
}
function getSDKSource() {
  return "npm";
}
function memoBuilder() {
  const hasWeakSet2 = typeof WeakSet === "function";
  const inner = hasWeakSet2 ? /* @__PURE__ */ new WeakSet() : [];
  function memoize2(obj) {
    if (hasWeakSet2) {
      if (inner.has(obj)) {
        return true;
      }
      inner.add(obj);
      return false;
    }
    for (let i = 0; i < inner.length; i++) {
      const value = inner[i];
      if (value === obj) {
        return true;
      }
    }
    inner.push(obj);
    return false;
  }
  function unmemoize(obj) {
    if (hasWeakSet2) {
      inner.delete(obj);
    } else {
      for (let i = 0; i < inner.length; i++) {
        if (inner[i] === obj) {
          inner.splice(i, 1);
          break;
        }
      }
    }
  }
  return [memoize2, unmemoize];
}
function normalize(input, depth = 100, maxProperties = Infinity) {
  try {
    return visit("", input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}
function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
  const normalized = normalize(object, depth);
  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return normalized;
}
function visit(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
  const [memoize2, unmemoize] = memo;
  if (value == null || // this matches null and undefined -> eqeq not eqeqeq
  ["number", "boolean", "string"].includes(typeof value) && !isNaN$1(value)) {
    return value;
  }
  const stringified = stringifyValue(key, value);
  if (!stringified.startsWith("[object ")) {
    return stringified;
  }
  if (value["__sentry_skip_normalization__"]) {
    return value;
  }
  const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
  if (remainingDepth === 0) {
    return stringified.replace("object ", "");
  }
  if (memoize2(value)) {
    return "[Circular ~]";
  }
  const valueWithToJSON = value;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
    try {
      const jsonValue = valueWithToJSON.toJSON();
      return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
    } catch (err) {
    }
  }
  const normalized = Array.isArray(value) ? [] : {};
  let numAdded = 0;
  const visitable = convertToPlainObject(value);
  for (const visitKey in visitable) {
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }
    if (numAdded >= maxProperties) {
      normalized[visitKey] = "[MaxProperties ~]";
      break;
    }
    const visitValue = visitable[visitKey];
    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
    numAdded++;
  }
  unmemoize(value);
  return normalized;
}
function stringifyValue(key, value) {
  try {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (isVueViewModel(value)) {
      return "[VueViewModel]";
    }
    if (isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && value !== value) {
      return "[NaN]";
    }
    if (typeof value === "function") {
      return `[Function: ${getFunctionName(value)}]`;
    }
    if (typeof value === "symbol") {
      return `[${String(value)}]`;
    }
    if (typeof value === "bigint") {
      return `[BigInt: ${String(value)}]`;
    }
    const objName = getConstructorName(value);
    if (/^HTML(\w*)Element$/.test(objName)) {
      return `[HTMLElement: ${objName}]`;
    }
    return `[object ${objName}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}
function getConstructorName(value) {
  const prototype = Object.getPrototypeOf(value);
  return prototype ? prototype.constructor.name : "null prototype";
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}
var States;
(function(States2) {
  const PENDING = 0;
  States2[States2["PENDING"] = PENDING] = "PENDING";
  const RESOLVED = 1;
  States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
  const REJECTED = 2;
  States2[States2["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));
function resolvedSyncPromise(value) {
  return new SyncPromise((resolve) => {
    resolve(value);
  });
}
function rejectedSyncPromise(reason) {
  return new SyncPromise((_2, reject) => {
    reject(reason);
  });
}
class SyncPromise {
  constructor(executor) {
    SyncPromise.prototype.__init.call(this);
    SyncPromise.prototype.__init2.call(this);
    SyncPromise.prototype.__init3.call(this);
    SyncPromise.prototype.__init4.call(this);
    this._state = States.PENDING;
    this._handlers = [];
    try {
      executor(this._resolve, this._reject);
    } catch (e2) {
      this._reject(e2);
    }
  }
  /** JSDoc */
  then(onfulfilled, onrejected) {
    return new SyncPromise((resolve, reject) => {
      this._handlers.push([
        false,
        (result) => {
          if (!onfulfilled) {
            resolve(result);
          } else {
            try {
              resolve(onfulfilled(result));
            } catch (e2) {
              reject(e2);
            }
          }
        },
        (reason) => {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e2) {
              reject(e2);
            }
          }
        }
      ]);
      this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(onrejected) {
    return this.then((val) => val, onrejected);
  }
  /** JSDoc */
  finally(onfinally) {
    return new SyncPromise((resolve, reject) => {
      let val;
      let isRejected;
      return this.then(
        (value) => {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        },
        (reason) => {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }
      ).then(() => {
        if (isRejected) {
          reject(val);
          return;
        }
        resolve(val);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (value) => {
      this._setResult(States.RESOLVED, value);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (reason) => {
      this._setResult(States.REJECTED, reason);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (state, value) => {
      if (this._state !== States.PENDING) {
        return;
      }
      if (isThenable(value)) {
        void value.then(this._resolve, this._reject);
        return;
      }
      this._state = state;
      this._value = value;
      this._executeHandlers();
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === States.PENDING) {
        return;
      }
      const cachedHandlers = this._handlers.slice();
      this._handlers = [];
      cachedHandlers.forEach((handler) => {
        if (handler[0]) {
          return;
        }
        if (this._state === States.RESOLVED) {
          handler[1](this._value);
        }
        if (this._state === States.REJECTED) {
          handler[2](this._value);
        }
        handler[0] = true;
      });
    };
  }
}
function makePromiseBuffer(limit) {
  const buffer = [];
  function isReady() {
    return limit === void 0 || buffer.length < limit;
  }
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0];
  }
  function add(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
    }
    const task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    void task.then(() => remove(task)).then(
      null,
      () => remove(task).then(null, () => {
      })
    );
    return task;
  }
  function drain(timeout) {
    return new SyncPromise((resolve, reject) => {
      let counter = buffer.length;
      if (!counter) {
        return resolve(true);
      }
      const capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);
      buffer.forEach((item) => {
        void resolvedSyncPromise(item).then(() => {
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject);
      });
    });
  }
  return {
    $: buffer,
    add,
    drain
  };
}
function parseUrl(url) {
  if (!url) {
    return {};
  }
  const match2 = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match2) {
    return {};
  }
  const query = match2[6] || "";
  const fragment = match2[8] || "";
  return {
    host: match2[4],
    path: match2[5],
    protocol: match2[2],
    search: query,
    hash: fragment,
    relative: match2[5] + query + fragment
    // everything minus origin
  };
}
const validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
function severityLevelFromString(level) {
  return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
}
const ONE_SECOND_IN_MS = 1e3;
function dateTimestampInSeconds() {
  return Date.now() / ONE_SECOND_IN_MS;
}
function createUnixTimestampInSecondsFunc() {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    return dateTimestampInSeconds;
  }
  const approxStartingTimeOrigin = Date.now() - performance2.now();
  const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
  return () => {
    return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
  };
}
const timestampInSeconds = createUnixTimestampInSecondsFunc();
(() => {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    return void 0;
  }
  const threshold = 3600 * 1e3;
  const performanceNow = performance2.now();
  const dateNow = Date.now();
  const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
  const timeOriginIsReliable = timeOriginDelta < threshold;
  const navigationStart = performance2.timing && performance2.timing.navigationStart;
  const hasNavigationStart = typeof navigationStart === "number";
  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  const navigationStartIsReliable = navigationStartDelta < threshold;
  if (timeOriginIsReliable || navigationStartIsReliable) {
    if (timeOriginDelta <= navigationStartDelta) {
      return performance2.timeOrigin;
    } else {
      return navigationStart;
    }
  }
  return dateNow;
})();
function createEnvelope(headers, items = []) {
  return [headers, items];
}
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]];
}
function forEachEnvelopeItem(envelope, callback) {
  const envelopeItems = envelope[1];
  for (const envelopeItem of envelopeItems) {
    const envelopeItemType = envelopeItem[0].type;
    const result = callback(envelopeItem, envelopeItemType);
    if (result) {
      return true;
    }
  }
  return false;
}
function encodeUTF8(input, textEncoder) {
  const utf8 = textEncoder || new TextEncoder();
  return utf8.encode(input);
}
function serializeEnvelope(envelope, textEncoder) {
  const [envHeaders, items] = envelope;
  let parts = JSON.stringify(envHeaders);
  function append(next) {
    if (typeof parts === "string") {
      parts = typeof next === "string" ? parts + next : [encodeUTF8(parts, textEncoder), next];
    } else {
      parts.push(typeof next === "string" ? encodeUTF8(next, textEncoder) : next);
    }
  }
  for (const item of items) {
    const [itemHeaders, payload] = item;
    append(`
${JSON.stringify(itemHeaders)}
`);
    if (typeof payload === "string" || payload instanceof Uint8Array) {
      append(payload);
    } else {
      let stringifiedPayload;
      try {
        stringifiedPayload = JSON.stringify(payload);
      } catch (e2) {
        stringifiedPayload = JSON.stringify(normalize(payload));
      }
      append(stringifiedPayload);
    }
  }
  return typeof parts === "string" ? parts : concatBuffers(parts);
}
function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
  const merged = new Uint8Array(totalLength);
  let offset = 0;
  for (const buffer of buffers) {
    merged.set(buffer, offset);
    offset += buffer.length;
  }
  return merged;
}
function createAttachmentEnvelopeItem(attachment, textEncoder) {
  const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
  return [
    dropUndefinedKeys({
      type: "attachment",
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType
    }),
    buffer
  ];
}
const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket"
};
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}
function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
  if (!metadataOrEvent || !metadataOrEvent.sdk) {
    return;
  }
  const { name, version } = metadataOrEvent.sdk;
  return { name, version };
}
function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: event.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
    ...dynamicSamplingContext && {
      trace: dropUndefinedKeys({ ...dynamicSamplingContext })
    }
  };
}
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
  const clientReportItem = [
    { type: "client_report" },
    {
      timestamp: timestamp || dateTimestampInSeconds(),
      discarded_events
    }
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}
const DEFAULT_RETRY_AFTER = 60 * 1e3;
function parseRetryAfterHeader(header, now = Date.now()) {
  const headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1e3;
  }
  const headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }
  return DEFAULT_RETRY_AFTER;
}
function disabledUntil(limits, dataCategory) {
  return limits[dataCategory] || limits.all || 0;
}
function isRateLimited(limits, dataCategory, now = Date.now()) {
  return disabledUntil(limits, dataCategory) > now;
}
function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
  const updatedRateLimits = {
    ...limits
  };
  const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
  const retryAfterHeader = headers && headers["retry-after"];
  if (rateLimitHeader) {
    for (const limit of rateLimitHeader.trim().split(",")) {
      const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
      const headerDelay = parseInt(retryAfter, 10);
      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
      if (!categories) {
        updatedRateLimits.all = now + delay;
      } else {
        for (const category of categories.split(";")) {
          if (category === "metric_bucket") {
            if (!namespaces || namespaces.split(";").includes("custom")) {
              updatedRateLimits[category] = now + delay;
            }
          } else {
            updatedRateLimits[category] = now + delay;
          }
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now + 60 * 1e3;
  }
  return updatedRateLimits;
}
const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
const DEFAULT_ENVIRONMENT = "production";
function getGlobalEventProcessors() {
  return getGlobalSingleton("globalEventProcessors", () => []);
}
function addGlobalEventProcessor(callback) {
  getGlobalEventProcessors().push(callback);
}
function notifyEventProcessors(processors, event, hint, index2 = 0) {
  return new SyncPromise((resolve, reject) => {
    const processor = processors[index2];
    if (event === null || typeof processor !== "function") {
      resolve(event);
    } else {
      const result = processor({ ...event }, hint);
      DEBUG_BUILD$1 && processor.id && result === null && logger.log(`Event processor "${processor.id}" dropped event`);
      if (isThenable(result)) {
        void result.then((final) => notifyEventProcessors(processors, final, hint, index2 + 1).then(resolve)).then(null, reject);
      } else {
        void notifyEventProcessors(processors, result, hint, index2 + 1).then(resolve).then(null, reject);
      }
    }
  });
}
function makeSession(context) {
  const startingTime = timestampInSeconds();
  const session = {
    sid: uuid4(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session)
  };
  if (context) {
    updateSession(session, context);
  }
  return session;
}
function updateSession(session, context = {}) {
  if (context.user) {
    if (!session.ipAddress && context.user.ip_address) {
      session.ipAddress = context.user.ip_address;
    }
    if (!session.did && !context.did) {
      session.did = context.user.id || context.user.email || context.user.username;
    }
  }
  session.timestamp = context.timestamp || timestampInSeconds();
  if (context.abnormal_mechanism) {
    session.abnormal_mechanism = context.abnormal_mechanism;
  }
  if (context.ignoreDuration) {
    session.ignoreDuration = context.ignoreDuration;
  }
  if (context.sid) {
    session.sid = context.sid.length === 32 ? context.sid : uuid4();
  }
  if (context.init !== void 0) {
    session.init = context.init;
  }
  if (!session.did && context.did) {
    session.did = `${context.did}`;
  }
  if (typeof context.started === "number") {
    session.started = context.started;
  }
  if (session.ignoreDuration) {
    session.duration = void 0;
  } else if (typeof context.duration === "number") {
    session.duration = context.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context.release) {
    session.release = context.release;
  }
  if (context.environment) {
    session.environment = context.environment;
  }
  if (!session.ipAddress && context.ipAddress) {
    session.ipAddress = context.ipAddress;
  }
  if (!session.userAgent && context.userAgent) {
    session.userAgent = context.userAgent;
  }
  if (typeof context.errors === "number") {
    session.errors = context.errors;
  }
  if (context.status) {
    session.status = context.status;
  }
}
function closeSession(session, status) {
  let context = {};
  if (status) {
    context = { status };
  } else if (session.status === "ok") {
    context = { status: "exited" };
  }
  updateSession(session, context);
}
function sessionToJSON(session) {
  return dropUndefinedKeys({
    sid: `${session.sid}`,
    init: session.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(session.started * 1e3).toISOString(),
    timestamp: new Date(session.timestamp * 1e3).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
    duration: session.duration,
    abnormal_mechanism: session.abnormal_mechanism,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent
    }
  });
}
const TRACE_FLAG_SAMPLED = 1;
function spanToTraceContext(span) {
  const { spanId: span_id, traceId: trace_id } = span.spanContext();
  const { data, op: op2, parent_span_id, status, tags, origin } = spanToJSON(span);
  return dropUndefinedKeys({
    data,
    op: op2,
    parent_span_id,
    span_id,
    status,
    tags,
    trace_id,
    origin
  });
}
function spanToJSON(span) {
  if (spanIsSpanClass(span)) {
    return span.getSpanJSON();
  }
  if (typeof span.toJSON === "function") {
    return span.toJSON();
  }
  return {};
}
function spanIsSpanClass(span) {
  return typeof span.getSpanJSON === "function";
}
function spanIsSampled(span) {
  const { traceFlags } = span.spanContext();
  return Boolean(traceFlags & TRACE_FLAG_SAMPLED);
}
function prepareEvent(options, event, hint, scope, client, isolationScope) {
  const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
  const prepared = {
    ...event,
    event_id: event.event_id || hint.event_id || uuid4(),
    timestamp: event.timestamp || dateTimestampInSeconds()
  };
  const integrations = hint.integrations || options.integrations.map((i) => i.name);
  applyClientOptions(prepared, options);
  applyIntegrationsMetadata(prepared, integrations);
  if (event.type === void 0) {
    applyDebugIds(prepared, options.stackParser);
  }
  const finalScope = getFinalScope(scope, hint.captureContext);
  if (hint.mechanism) {
    addExceptionMechanism(prepared, hint.mechanism);
  }
  const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [];
  const data = getGlobalScope().getScopeData();
  if (isolationScope) {
    const isolationData = isolationScope.getScopeData();
    mergeScopeData(data, isolationData);
  }
  if (finalScope) {
    const finalScopeData = finalScope.getScopeData();
    mergeScopeData(data, finalScopeData);
  }
  const attachments = [...hint.attachments || [], ...data.attachments];
  if (attachments.length) {
    hint.attachments = attachments;
  }
  applyScopeDataToEvent(prepared, data);
  const eventProcessors = [
    ...clientEventProcessors,
    // eslint-disable-next-line deprecation/deprecation
    ...getGlobalEventProcessors(),
    // Run scope event processors _after_ all other processors
    ...data.eventProcessors
  ];
  const result = notifyEventProcessors(eventProcessors, prepared, hint);
  return result.then((evt) => {
    if (evt) {
      applyDebugMeta(evt);
    }
    if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
    }
    return evt;
  });
}
function applyClientOptions(event, options) {
  const { environment, release, dist: dist2, maxValueLength = 250 } = options;
  if (!("environment" in event)) {
    event.environment = "environment" in options ? environment : DEFAULT_ENVIRONMENT;
  }
  if (event.release === void 0 && release !== void 0) {
    event.release = release;
  }
  if (event.dist === void 0 && dist2 !== void 0) {
    event.dist = dist2;
  }
  if (event.message) {
    event.message = truncate(event.message, maxValueLength);
  }
  const exception = event.exception && event.exception.values && event.exception.values[0];
  if (exception && exception.value) {
    exception.value = truncate(exception.value, maxValueLength);
  }
  const request = event.request;
  if (request && request.url) {
    request.url = truncate(request.url, maxValueLength);
  }
}
const debugIdStackParserCache = /* @__PURE__ */ new WeakMap();
function applyDebugIds(event, stackParser) {
  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
  if (!debugIdMap) {
    return;
  }
  let debugIdStackFramesCache;
  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
  if (cachedDebugIdStackFrameCache) {
    debugIdStackFramesCache = cachedDebugIdStackFrameCache;
  } else {
    debugIdStackFramesCache = /* @__PURE__ */ new Map();
    debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
  }
  const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
    let parsedStack;
    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
    if (cachedParsedStack) {
      parsedStack = cachedParsedStack;
    } else {
      parsedStack = stackParser(debugIdStackTrace);
      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
    }
    for (let i = parsedStack.length - 1; i >= 0; i--) {
      const stackFrame = parsedStack[i];
      if (stackFrame.filename) {
        acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
        break;
      }
    }
    return acc;
  }, {});
  try {
    event.exception.values.forEach((exception) => {
      exception.stacktrace.frames.forEach((frame) => {
        if (frame.filename) {
          frame.debug_id = filenameDebugIdMap[frame.filename];
        }
      });
    });
  } catch (e2) {
  }
}
function applyDebugMeta(event) {
  const filenameDebugIdMap = {};
  try {
    event.exception.values.forEach((exception) => {
      exception.stacktrace.frames.forEach((frame) => {
        if (frame.debug_id) {
          if (frame.abs_path) {
            filenameDebugIdMap[frame.abs_path] = frame.debug_id;
          } else if (frame.filename) {
            filenameDebugIdMap[frame.filename] = frame.debug_id;
          }
          delete frame.debug_id;
        }
      });
    });
  } catch (e2) {
  }
  if (Object.keys(filenameDebugIdMap).length === 0) {
    return;
  }
  event.debug_meta = event.debug_meta || {};
  event.debug_meta.images = event.debug_meta.images || [];
  const images = event.debug_meta.images;
  Object.keys(filenameDebugIdMap).forEach((filename) => {
    images.push({
      type: "sourcemap",
      code_file: filename,
      debug_id: filenameDebugIdMap[filename]
    });
  });
}
function applyIntegrationsMetadata(event, integrationNames) {
  if (integrationNames.length > 0) {
    event.sdk = event.sdk || {};
    event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
  }
}
function normalizeEvent(event, depth, maxBreadth) {
  if (!event) {
    return null;
  }
  const normalized = {
    ...event,
    ...event.breadcrumbs && {
      breadcrumbs: event.breadcrumbs.map((b2) => ({
        ...b2,
        ...b2.data && {
          data: normalize(b2.data, depth, maxBreadth)
        }
      }))
    },
    ...event.user && {
      user: normalize(event.user, depth, maxBreadth)
    },
    ...event.contexts && {
      contexts: normalize(event.contexts, depth, maxBreadth)
    },
    ...event.extra && {
      extra: normalize(event.extra, depth, maxBreadth)
    }
  };
  if (event.contexts && event.contexts.trace && normalized.contexts) {
    normalized.contexts.trace = event.contexts.trace;
    if (event.contexts.trace.data) {
      normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
    }
  }
  if (event.spans) {
    normalized.spans = event.spans.map((span) => {
      const data = spanToJSON(span).data;
      if (data) {
        span.data = normalize(data, depth, maxBreadth);
      }
      return span;
    });
  }
  return normalized;
}
function getFinalScope(scope, captureContext) {
  if (!captureContext) {
    return scope;
  }
  const finalScope = scope ? scope.clone() : new Scope();
  finalScope.update(captureContext);
  return finalScope;
}
function parseEventHintOrCaptureContext(hint) {
  if (!hint) {
    return void 0;
  }
  if (hintIsScopeOrFunction(hint)) {
    return { captureContext: hint };
  }
  if (hintIsScopeContext(hint)) {
    return {
      captureContext: hint
    };
  }
  return hint;
}
function hintIsScopeOrFunction(hint) {
  return hint instanceof Scope || typeof hint === "function";
}
const captureContextKeys = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function hintIsScopeContext(hint) {
  return Object.keys(hint).some((key) => captureContextKeys.includes(key));
}
function captureException(exception, hint) {
  return getCurrentHub().captureException(exception, parseEventHintOrCaptureContext(hint));
}
function captureMessage(message, captureContext) {
  const level = typeof captureContext === "string" ? captureContext : void 0;
  const context = typeof captureContext !== "string" ? { captureContext } : void 0;
  return getCurrentHub().captureMessage(message, level, context);
}
function captureEvent(event, hint) {
  return getCurrentHub().captureEvent(event, hint);
}
function configureScope$1(callback) {
  getCurrentHub().configureScope(callback);
}
function addBreadcrumb(breadcrumb, hint) {
  getCurrentHub().addBreadcrumb(breadcrumb, hint);
}
function withScope(...rest) {
  const hub = getCurrentHub();
  if (rest.length === 2) {
    const [scope, callback] = rest;
    if (!scope) {
      return hub.withScope(callback);
    }
    return hub.withScope(() => {
      hub.getStackTop().scope = scope;
      return callback(scope);
    });
  }
  return hub.withScope(rest[0]);
}
function getClient() {
  return getCurrentHub().getClient();
}
function getCurrentScope() {
  return getCurrentHub().getScope();
}
function startSession(context) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
  const { userAgent } = GLOBAL_OBJ.navigator || {};
  const session = makeSession({
    release,
    environment,
    user: currentScope.getUser() || isolationScope.getUser(),
    ...userAgent && { userAgent },
    ...context
  });
  const currentSession = isolationScope.getSession();
  if (currentSession && currentSession.status === "ok") {
    updateSession(currentSession, { status: "exited" });
  }
  endSession();
  isolationScope.setSession(session);
  currentScope.setSession(session);
  return session;
}
function endSession() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session) {
    closeSession(session);
  }
  _sendSessionUpdate();
  isolationScope.setSession();
  currentScope.setSession();
}
function _sendSessionUpdate() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const client = getClient();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session && client && client.captureSession) {
    client.captureSession(session);
  }
}
function captureSession(end = false) {
  if (end) {
    endSession();
    return;
  }
  _sendSessionUpdate();
}
function getRootSpan(span) {
  return span.transaction;
}
function getDynamicSamplingContextFromClient(trace_id, client, scope) {
  const options = client.getOptions();
  const { publicKey: public_key } = client.getDsn() || {};
  const { segment: user_segment } = scope && scope.getUser() || {};
  const dsc = dropUndefinedKeys({
    environment: options.environment || DEFAULT_ENVIRONMENT,
    release: options.release,
    user_segment,
    public_key,
    trace_id
  });
  client.emit && client.emit("createDsc", dsc);
  return dsc;
}
function getDynamicSamplingContextFromSpan(span) {
  const client = getClient();
  if (!client) {
    return {};
  }
  const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || "", client, getCurrentScope());
  const txn = getRootSpan(span);
  if (!txn) {
    return dsc;
  }
  const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;
  if (v7FrozenDsc) {
    return v7FrozenDsc;
  }
  const { sampleRate: maybeSampleRate, source } = txn.metadata;
  if (maybeSampleRate != null) {
    dsc.sample_rate = `${maybeSampleRate}`;
  }
  const jsonSpan = spanToJSON(txn);
  if (source && source !== "url") {
    dsc.transaction = jsonSpan.description;
  }
  dsc.sampled = String(spanIsSampled(txn));
  client.emit && client.emit("createDsc", dsc);
  return dsc;
}
function applyScopeDataToEvent(event, data) {
  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
  applyDataToEvent(event, data);
  if (span) {
    applySpanToEvent(event, span);
  }
  applyFingerprintToEvent(event, fingerprint);
  applyBreadcrumbsToEvent(event, breadcrumbs);
  applySdkMetadataToEvent(event, sdkProcessingMetadata);
}
function mergeScopeData(data, mergeData) {
  const {
    extra,
    tags,
    user,
    contexts,
    level,
    sdkProcessingMetadata,
    breadcrumbs,
    fingerprint,
    eventProcessors,
    attachments,
    propagationContext,
    // eslint-disable-next-line deprecation/deprecation
    transactionName,
    span
  } = mergeData;
  mergeAndOverwriteScopeData(data, "extra", extra);
  mergeAndOverwriteScopeData(data, "tags", tags);
  mergeAndOverwriteScopeData(data, "user", user);
  mergeAndOverwriteScopeData(data, "contexts", contexts);
  mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata);
  if (level) {
    data.level = level;
  }
  if (transactionName) {
    data.transactionName = transactionName;
  }
  if (span) {
    data.span = span;
  }
  if (breadcrumbs.length) {
    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
  }
  if (fingerprint.length) {
    data.fingerprint = [...data.fingerprint, ...fingerprint];
  }
  if (eventProcessors.length) {
    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
  }
  if (attachments.length) {
    data.attachments = [...data.attachments, ...attachments];
  }
  data.propagationContext = { ...data.propagationContext, ...propagationContext };
}
function mergeAndOverwriteScopeData(data, prop, mergeVal) {
  if (mergeVal && Object.keys(mergeVal).length) {
    data[prop] = { ...data[prop] };
    for (const key in mergeVal) {
      if (Object.prototype.hasOwnProperty.call(mergeVal, key)) {
        data[prop][key] = mergeVal[key];
      }
    }
  }
}
function applyDataToEvent(event, data) {
  const {
    extra,
    tags,
    user,
    contexts,
    level,
    // eslint-disable-next-line deprecation/deprecation
    transactionName
  } = data;
  const cleanedExtra = dropUndefinedKeys(extra);
  if (cleanedExtra && Object.keys(cleanedExtra).length) {
    event.extra = { ...cleanedExtra, ...event.extra };
  }
  const cleanedTags = dropUndefinedKeys(tags);
  if (cleanedTags && Object.keys(cleanedTags).length) {
    event.tags = { ...cleanedTags, ...event.tags };
  }
  const cleanedUser = dropUndefinedKeys(user);
  if (cleanedUser && Object.keys(cleanedUser).length) {
    event.user = { ...cleanedUser, ...event.user };
  }
  const cleanedContexts = dropUndefinedKeys(contexts);
  if (cleanedContexts && Object.keys(cleanedContexts).length) {
    event.contexts = { ...cleanedContexts, ...event.contexts };
  }
  if (level) {
    event.level = level;
  }
  if (transactionName) {
    event.transaction = transactionName;
  }
}
function applyBreadcrumbsToEvent(event, breadcrumbs) {
  const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
}
function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
  event.sdkProcessingMetadata = {
    ...event.sdkProcessingMetadata,
    ...sdkProcessingMetadata
  };
}
function applySpanToEvent(event, span) {
  event.contexts = { trace: spanToTraceContext(span), ...event.contexts };
  const rootSpan = getRootSpan(span);
  if (rootSpan) {
    event.sdkProcessingMetadata = {
      dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
      ...event.sdkProcessingMetadata
    };
    const transactionName = spanToJSON(rootSpan).description;
    if (transactionName) {
      event.tags = { transaction: transactionName, ...event.tags };
    }
  }
}
function applyFingerprintToEvent(event, fingerprint) {
  event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];
  if (fingerprint) {
    event.fingerprint = event.fingerprint.concat(fingerprint);
  }
  if (event.fingerprint && !event.fingerprint.length) {
    delete event.fingerprint;
  }
}
const DEFAULT_MAX_BREADCRUMBS = 100;
let globalScope;
class Scope {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called after {@link applyToEvent}. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  // eslint-disable-next-line deprecation/deprecation
  /**
   * Transaction Name
   */
  /** Span */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
    this._propagationContext = generatePropagationContext();
  }
  /**
   * Inherit values from the parent scope.
   * @deprecated Use `scope.clone()` and `new Scope()` instead.
   */
  static clone(scope) {
    return scope ? scope.clone() : new Scope();
  }
  /**
   * Clone this scope instance.
   */
  clone() {
    const newScope = new Scope();
    newScope._breadcrumbs = [...this._breadcrumbs];
    newScope._tags = { ...this._tags };
    newScope._extra = { ...this._extra };
    newScope._contexts = { ...this._contexts };
    newScope._user = this._user;
    newScope._level = this._level;
    newScope._span = this._span;
    newScope._session = this._session;
    newScope._transactionName = this._transactionName;
    newScope._fingerprint = this._fingerprint;
    newScope._eventProcessors = [...this._eventProcessors];
    newScope._requestSession = this._requestSession;
    newScope._attachments = [...this._attachments];
    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
    newScope._propagationContext = { ...this._propagationContext };
    newScope._client = this._client;
    return newScope;
  }
  /** Update the client on the scope. */
  setClient(client) {
    this._client = client;
  }
  /**
   * Get the client assigned to this scope.
   *
   * It is generally recommended to use the global function `Sentry.getClient()` instead, unless you know what you are doing.
   */
  getClient() {
    return this._client;
  }
  /**
   * Add internal on change listener. Used for sub SDKs that need to store the scope.
   * @hidden
   */
  addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }
  /**
   * @inheritDoc
   */
  setUser(user) {
    this._user = user || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      segment: void 0,
      username: void 0
    };
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(requestSession) {
    this._requestSession = requestSession;
    return this;
  }
  /**
   * @inheritDoc
   */
  setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setExtras(extras) {
    this._extra = {
      ...this._extra,
      ...extras
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setLevel(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the transaction name on the scope for future events.
   */
  setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setContext(key, context) {
    if (context === null) {
      delete this._contexts[key];
    } else {
      this._contexts[key] = context;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Sets the Span on the scope.
   * @param span Span
   * @deprecated Instead of setting a span on a scope, use `startSpan()`/`startSpanManual()` instead.
   */
  setSpan(span) {
    this._span = span;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * Returns the `Span` if there is one.
   * @deprecated Use `getActiveSpan()` instead.
   */
  getSpan() {
    return this._span;
  }
  /**
   * Returns the `Transaction` attached to the scope (if there is one).
   * @deprecated You should not rely on the transaction, but just use `startSpan()` APIs instead.
   */
  getTransaction() {
    const span = this._span;
    return span && span.transaction;
  }
  /**
   * @inheritDoc
   */
  setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(captureContext) {
    if (!captureContext) {
      return this;
    }
    const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
    if (scopeToMerge instanceof Scope) {
      const scopeData = scopeToMerge.getScopeData();
      this._tags = { ...this._tags, ...scopeData.tags };
      this._extra = { ...this._extra, ...scopeData.extra };
      this._contexts = { ...this._contexts, ...scopeData.contexts };
      if (scopeData.user && Object.keys(scopeData.user).length) {
        this._user = scopeData.user;
      }
      if (scopeData.level) {
        this._level = scopeData.level;
      }
      if (scopeData.fingerprint.length) {
        this._fingerprint = scopeData.fingerprint;
      }
      if (scopeToMerge.getRequestSession()) {
        this._requestSession = scopeToMerge.getRequestSession();
      }
      if (scopeData.propagationContext) {
        this._propagationContext = scopeData.propagationContext;
      }
    } else if (isPlainObject(scopeToMerge)) {
      const scopeContext = captureContext;
      this._tags = { ...this._tags, ...scopeContext.tags };
      this._extra = { ...this._extra, ...scopeContext.extra };
      this._contexts = { ...this._contexts, ...scopeContext.contexts };
      if (scopeContext.user) {
        this._user = scopeContext.user;
      }
      if (scopeContext.level) {
        this._level = scopeContext.level;
      }
      if (scopeContext.fingerprint) {
        this._fingerprint = scopeContext.fingerprint;
      }
      if (scopeContext.requestSession) {
        this._requestSession = scopeContext.requestSession;
      }
      if (scopeContext.propagationContext) {
        this._propagationContext = scopeContext.propagationContext;
      }
    }
    return this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = void 0;
    this._transactionName = void 0;
    this._fingerprint = void 0;
    this._requestSession = void 0;
    this._span = void 0;
    this._session = void 0;
    this._notifyScopeListeners();
    this._attachments = [];
    this._propagationContext = generatePropagationContext();
    return this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb
    };
    const breadcrumbs = this._breadcrumbs;
    breadcrumbs.push(mergedBreadcrumb);
    this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }
  /**
   * @inheritDoc
   * @deprecated Use `getScopeData()` instead.
   */
  getAttachments() {
    const data = this.getScopeData();
    return data.attachments;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    this._attachments = [];
    return this;
  }
  /** @inheritDoc */
  getScopeData() {
    const {
      _breadcrumbs,
      _attachments,
      _contexts,
      _tags,
      _extra,
      _user,
      _level,
      _fingerprint,
      _eventProcessors,
      _propagationContext,
      _sdkProcessingMetadata,
      _transactionName,
      _span
    } = this;
    return {
      breadcrumbs: _breadcrumbs,
      attachments: _attachments,
      contexts: _contexts,
      tags: _tags,
      extra: _extra,
      user: _user,
      level: _level,
      fingerprint: _fingerprint || [],
      eventProcessors: _eventProcessors,
      propagationContext: _propagationContext,
      sdkProcessingMetadata: _sdkProcessingMetadata,
      transactionName: _transactionName,
      span: _span
    };
  }
  /**
   * Applies data from the scope to the event and runs all event processors on it.
   *
   * @param event Event
   * @param hint Object containing additional information about the original exception, for use by the event processors.
   * @hidden
   * @deprecated Use `applyScopeDataToEvent()` directly
   */
  applyToEvent(event, hint = {}, additionalEventProcessors = []) {
    applyScopeDataToEvent(event, this.getScopeData());
    const eventProcessors = [
      ...additionalEventProcessors,
      // eslint-disable-next-line deprecation/deprecation
      ...getGlobalEventProcessors(),
      ...this._eventProcessors
    ];
    return notifyEventProcessors(eventProcessors, event, hint);
  }
  /**
   * Add data which will be accessible during event processing but won't get sent to Sentry
   */
  setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
    return this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(context) {
    this._propagationContext = context;
    return this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * Capture an exception for this scope.
   *
   * @param exception The exception to capture.
   * @param hint Optinal additional data to attach to the Sentry event.
   * @returns the id of the captured Sentry event.
   */
  captureException(exception, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture exception!");
      return eventId;
    }
    const syntheticException = new Error("Sentry syntheticException");
    this._client.captureException(
      exception,
      {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * Capture a message for this scope.
   *
   * @param message The message to capture.
   * @param level An optional severity level to report the message with.
   * @param hint Optional additional data to attach to the Sentry event.
   * @returns the id of the captured message.
   */
  captureMessage(message, level, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture message!");
      return eventId;
    }
    const syntheticException = new Error(message);
    this._client.captureMessage(
      message,
      level,
      {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * Captures a manually created event for this scope and sends it to Sentry.
   *
   * @param exception The event to capture.
   * @param hint Optional additional data to attach to the Sentry event.
   * @returns the id of the captured event.
   */
  captureEvent(event, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture event!");
      return eventId;
    }
    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
    return eventId;
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach((callback) => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }
}
function getGlobalScope() {
  if (!globalScope) {
    globalScope = new Scope();
  }
  return globalScope;
}
function generatePropagationContext() {
  return {
    traceId: uuid4(),
    spanId: uuid4().substring(16)
  };
}
const SDK_VERSION = "7.119.2";
const API_VERSION = parseFloat(SDK_VERSION);
const DEFAULT_BREADCRUMBS = 100;
class Hub {
  /** Is a {@link Layer}[] containing the client and scope */
  /** Contains the last event id of a captured event.  */
  /**
   * Creates a new instance of the hub, will push one {@link Layer} into the
   * internal stack on creation.
   *
   * @param client bound to the hub.
   * @param scope bound to the hub.
   * @param version number, higher number means higher priority.
   *
   * @deprecated Instantiation of Hub objects is deprecated and the constructor will be removed in version 8 of the SDK.
   *
   * If you are currently using the Hub for multi-client use like so:
   *
   * ```
   * // OLD
   * const hub = new Hub();
   * hub.bindClient(client);
   * makeMain(hub)
   * ```
   *
   * instead initialize the client as follows:
   *
   * ```
   * // NEW
   * Sentry.withIsolationScope(() => {
   *    Sentry.setCurrentClient(client);
   *    client.init();
   * });
   * ```
   *
   * If you are using the Hub to capture events like so:
   *
   * ```
   * // OLD
   * const client = new Client();
   * const hub = new Hub(client);
   * hub.captureException()
   * ```
   *
   * instead capture isolated events as follows:
   *
   * ```
   * // NEW
   * const client = new Client();
   * const scope = new Scope();
   * scope.setClient(client);
   * scope.captureException();
   * ```
   */
  constructor(client, scope, isolationScope, _version = API_VERSION) {
    this._version = _version;
    let assignedScope;
    if (!scope) {
      assignedScope = new Scope();
      assignedScope.setClient(client);
    } else {
      assignedScope = scope;
    }
    let assignedIsolationScope;
    if (!isolationScope) {
      assignedIsolationScope = new Scope();
      assignedIsolationScope.setClient(client);
    } else {
      assignedIsolationScope = isolationScope;
    }
    this._stack = [{ scope: assignedScope }];
    if (client) {
      this.bindClient(client);
    }
    this._isolationScope = assignedIsolationScope;
  }
  /**
   * Checks if this hub's version is older than the given version.
   *
   * @param version A version number to compare to.
   * @return True if the given version is newer; otherwise false.
   *
   * @deprecated This will be removed in v8.
   */
  isOlderThan(version) {
    return this._version < version;
  }
  /**
   * This binds the given client to the current scope.
   * @param client An SDK client (client) instance.
   *
   * @deprecated Use `initAndBind()` directly, or `setCurrentClient()` and/or `client.init()` instead.
   */
  bindClient(client) {
    const top = this.getStackTop();
    top.client = client;
    top.scope.setClient(client);
    if (client && client.setupIntegrations) {
      client.setupIntegrations();
    }
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `withScope` instead.
   */
  pushScope() {
    const scope = this.getScope().clone();
    this.getStack().push({
      // eslint-disable-next-line deprecation/deprecation
      client: this.getClient(),
      scope
    });
    return scope;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `withScope` instead.
   */
  popScope() {
    if (this.getStack().length <= 1)
      return false;
    return !!this.getStack().pop();
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.withScope()` instead.
   */
  withScope(callback) {
    const scope = this.pushScope();
    let maybePromiseResult;
    try {
      maybePromiseResult = callback(scope);
    } catch (e2) {
      this.popScope();
      throw e2;
    }
    if (isThenable(maybePromiseResult)) {
      return maybePromiseResult.then(
        (res) => {
          this.popScope();
          return res;
        },
        (e2) => {
          this.popScope();
          throw e2;
        }
      );
    }
    this.popScope();
    return maybePromiseResult;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.getClient()` instead.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   *
   * @deprecated Use `Sentry.getCurrentScope()` instead.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * @deprecated Use `Sentry.getIsolationScope()` instead.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the scope stack for domains or the process.
   * @deprecated This will be removed in v8.
   */
  getStack() {
    return this._stack;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   * @deprecated This will be removed in v8.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.captureException()` instead.
   */
  captureException(exception, hint) {
    const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
    const syntheticException = new Error("Sentry syntheticException");
    this.getScope().captureException(exception, {
      originalException: exception,
      syntheticException,
      ...hint,
      event_id: eventId
    });
    return eventId;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use  `Sentry.captureMessage()` instead.
   */
  captureMessage(message, level, hint) {
    const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
    const syntheticException = new Error(message);
    this.getScope().captureMessage(message, level, {
      originalException: message,
      syntheticException,
      ...hint,
      event_id: eventId
    });
    return eventId;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.captureEvent()` instead.
   */
  captureEvent(event, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!event.type) {
      this._lastEventId = eventId;
    }
    this.getScope().captureEvent(event, { ...hint, event_id: eventId });
    return eventId;
  }
  /**
   * @inheritDoc
   *
   * @deprecated This will be removed in v8.
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `Sentry.addBreadcrumb()` instead.
   */
  addBreadcrumb(breadcrumb, hint) {
    const { scope, client } = this.getStackTop();
    if (!client)
      return;
    const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions && client.getOptions() || {};
    if (maxBreadcrumbs <= 0)
      return;
    const timestamp = dateTimestampInSeconds();
    const mergedBreadcrumb = { timestamp, ...breadcrumb };
    const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
    if (finalBreadcrumb === null)
      return;
    if (client.emit) {
      client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
    }
    scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setUser()` instead.
   */
  setUser(user) {
    this.getScope().setUser(user);
    this.getIsolationScope().setUser(user);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setTags()` instead.
   */
  setTags(tags) {
    this.getScope().setTags(tags);
    this.getIsolationScope().setTags(tags);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setExtras()` instead.
   */
  setExtras(extras) {
    this.getScope().setExtras(extras);
    this.getIsolationScope().setExtras(extras);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setTag()` instead.
   */
  setTag(key, value) {
    this.getScope().setTag(key, value);
    this.getIsolationScope().setTag(key, value);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setExtra()` instead.
   */
  setExtra(key, extra) {
    this.getScope().setExtra(key, extra);
    this.getIsolationScope().setExtra(key, extra);
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.setContext()` instead.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setContext(name, context) {
    this.getScope().setContext(name, context);
    this.getIsolationScope().setContext(name, context);
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use `getScope()` directly.
   */
  configureScope(callback) {
    const { scope, client } = this.getStackTop();
    if (client) {
      callback(scope);
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  run(callback) {
    const oldHub = makeMain(this);
    try {
      callback(this);
    } finally {
      makeMain(oldHub);
    }
  }
  /**
   * @inheritDoc
   * @deprecated Use `Sentry.getClient().getIntegrationByName()` instead.
   */
  getIntegration(integration) {
    const client = this.getClient();
    if (!client)
      return null;
    try {
      return client.getIntegration(integration);
    } catch (_oO) {
      DEBUG_BUILD$1 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`);
      return null;
    }
  }
  /**
   * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
   *
   * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
   * new child span within the transaction or any span, call the respective `.startChild()` method.
   *
   * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
   *
   * The transaction must be finished with a call to its `.end()` method, at which point the transaction with all its
   * finished child spans will be sent to Sentry.
   *
   * @param context Properties of the new `Transaction`.
   * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
   * default values). See {@link Options.tracesSampler}.
   *
   * @returns The transaction which was just started
   *
   * @deprecated Use `startSpan()`, `startSpanManual()` or `startInactiveSpan()` instead.
   */
  startTransaction(context, customSamplingContext) {
    const result = this._callExtensionMethod("startTransaction", context, customSamplingContext);
    if (DEBUG_BUILD$1 && !result) {
      const client = this.getClient();
      if (!client) {
        logger.warn(
          "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
        );
      } else {
        logger.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`);
      }
    }
    return result;
  }
  /**
   * @inheritDoc
   * @deprecated Use `spanToTraceHeader()` instead.
   */
  traceHeaders() {
    return this._callExtensionMethod("traceHeaders");
  }
  /**
   * @inheritDoc
   *
   * @deprecated Use top level `captureSession` instead.
   */
  captureSession(endSession2 = false) {
    if (endSession2) {
      return this.endSession();
    }
    this._sendSessionUpdate();
  }
  /**
   * @inheritDoc
   * @deprecated Use top level `endSession` instead.
   */
  endSession() {
    const layer = this.getStackTop();
    const scope = layer.scope;
    const session = scope.getSession();
    if (session) {
      closeSession(session);
    }
    this._sendSessionUpdate();
    scope.setSession();
  }
  /**
   * @inheritDoc
   * @deprecated Use top level `startSession` instead.
   */
  startSession(context) {
    const { scope, client } = this.getStackTop();
    const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
    const { userAgent } = GLOBAL_OBJ.navigator || {};
    const session = makeSession({
      release,
      environment,
      user: scope.getUser(),
      ...userAgent && { userAgent },
      ...context
    });
    const currentSession = scope.getSession && scope.getSession();
    if (currentSession && currentSession.status === "ok") {
      updateSession(currentSession, { status: "exited" });
    }
    this.endSession();
    scope.setSession(session);
    return session;
  }
  /**
   * Returns if default PII should be sent to Sentry and propagated in ourgoing requests
   * when Tracing is used.
   *
   * @deprecated Use top-level `getClient().getOptions().sendDefaultPii` instead. This function
   * only unnecessarily increased API surface but only wrapped accessing the option.
   */
  shouldSendDefaultPii() {
    const client = this.getClient();
    const options = client && client.getOptions();
    return Boolean(options && options.sendDefaultPii);
  }
  /**
   * Sends the current Session on the scope
   */
  _sendSessionUpdate() {
    const { scope, client } = this.getStackTop();
    const session = scope.getSession();
    if (session && client && client.captureSession) {
      client.captureSession(session);
    }
  }
  /**
   * Calls global extension method and binding current instance to the function call
   */
  // @ts-expect-error Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _callExtensionMethod(method, ...args) {
    const carrier = getMainCarrier();
    const sentry = carrier.__SENTRY__;
    if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
      return sentry.extensions[method].apply(this, args);
    }
    DEBUG_BUILD$1 && logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
  }
}
function getMainCarrier() {
  GLOBAL_OBJ.__SENTRY__ = GLOBAL_OBJ.__SENTRY__ || {
    extensions: {},
    hub: void 0
  };
  return GLOBAL_OBJ;
}
function makeMain(hub) {
  const registry = getMainCarrier();
  const oldHub = getHubFromCarrier(registry);
  setHubOnCarrier(registry, hub);
  return oldHub;
}
function getCurrentHub() {
  const registry = getMainCarrier();
  if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
    const hub = registry.__SENTRY__.acs.getCurrentHub();
    if (hub) {
      return hub;
    }
  }
  return getGlobalHub(registry);
}
function getIsolationScope() {
  return getCurrentHub().getIsolationScope();
}
function getGlobalHub(registry = getMainCarrier()) {
  if (!hasHubOnCarrier(registry) || // eslint-disable-next-line deprecation/deprecation
  getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
    setHubOnCarrier(registry, new Hub());
  }
  return getHubFromCarrier(registry);
}
function hasHubOnCarrier(carrier) {
  return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
}
function getHubFromCarrier(carrier) {
  return getGlobalSingleton("hub", () => new Hub(), carrier);
}
function setHubOnCarrier(carrier, hub) {
  if (!carrier)
    return false;
  const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.hub = hub;
  return true;
}
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
  event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
  return event;
}
function createSessionEnvelope(session, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const envelopeHeaders = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
  return createEnvelope(envelopeHeaders, [envelopeItem]);
}
function createEventEnvelope(event, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
  delete event.sdkProcessingMetadata;
  const eventItem = [{ type: eventType }, event];
  return createEnvelope(envelopeHeaders, [eventItem]);
}
const SENTRY_API_VERSION = "7";
function getBaseApiEndpoint(dsn) {
  const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
  const port = dsn.port ? `:${dsn.port}` : "";
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
}
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}
function _encodedAuth(dsn, sdkInfo) {
  return urlEncode({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: dsn.publicKey,
    sentry_version: SENTRY_API_VERSION,
    ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
  });
}
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnelOrOptions = {}) {
  const tunnel = typeof tunnelOrOptions === "string" ? tunnelOrOptions : tunnelOrOptions.tunnel;
  const sdkInfo = typeof tunnelOrOptions === "string" || !tunnelOrOptions._metadata ? void 0 : tunnelOrOptions._metadata.sdk;
  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
}
const installedIntegrations = [];
function filterDuplicates(integrations) {
  const integrationsByName = {};
  integrations.forEach((currentInstance) => {
    const { name } = currentInstance;
    const existingInstance = integrationsByName[name];
    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
      return;
    }
    integrationsByName[name] = currentInstance;
  });
  return Object.keys(integrationsByName).map((k2) => integrationsByName[k2]);
}
function getIntegrationsToSetup(options) {
  const defaultIntegrations2 = options.defaultIntegrations || [];
  const userIntegrations = options.integrations;
  defaultIntegrations2.forEach((integration) => {
    integration.isDefaultInstance = true;
  });
  let integrations;
  if (Array.isArray(userIntegrations)) {
    integrations = [...defaultIntegrations2, ...userIntegrations];
  } else if (typeof userIntegrations === "function") {
    integrations = arrayify(userIntegrations(defaultIntegrations2));
  } else {
    integrations = defaultIntegrations2;
  }
  const finalIntegrations = filterDuplicates(integrations);
  const debugIndex = findIndex(finalIntegrations, (integration) => integration.name === "Debug");
  if (debugIndex !== -1) {
    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
    finalIntegrations.push(debugInstance);
  }
  return finalIntegrations;
}
function setupIntegrations(client, integrations) {
  const integrationIndex = {};
  integrations.forEach((integration) => {
    if (integration) {
      setupIntegration(client, integration, integrationIndex);
    }
  });
  return integrationIndex;
}
function afterSetupIntegrations(client, integrations) {
  for (const integration of integrations) {
    if (integration && integration.afterAllSetup) {
      integration.afterAllSetup(client);
    }
  }
}
function setupIntegration(client, integration, integrationIndex) {
  if (integrationIndex[integration.name]) {
    DEBUG_BUILD$1 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
    return;
  }
  integrationIndex[integration.name] = integration;
  if (installedIntegrations.indexOf(integration.name) === -1) {
    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
    installedIntegrations.push(integration.name);
  }
  if (integration.setup && typeof integration.setup === "function") {
    integration.setup(client);
  }
  if (client.on && typeof integration.preprocessEvent === "function") {
    const callback = integration.preprocessEvent.bind(integration);
    client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
  }
  if (client.addEventProcessor && typeof integration.processEvent === "function") {
    const callback = integration.processEvent.bind(integration);
    const processor = Object.assign((event, hint) => callback(event, hint, client), {
      id: integration.name
    });
    client.addEventProcessor(processor);
  }
  DEBUG_BUILD$1 && logger.log(`Integration installed: ${integration.name}`);
}
function findIndex(arr, callback) {
  for (let i = 0; i < arr.length; i++) {
    if (callback(arr[i]) === true) {
      return i;
    }
  }
  return -1;
}
function convertIntegrationFnToClass(name, fn) {
  return Object.assign(
    function ConvertedIntegration(...args) {
      return fn(...args);
    },
    { id: name }
  );
}
function defineIntegration(fn) {
  return fn;
}
function serializeMetricBuckets(metricBucketItems) {
  let out = "";
  for (const item of metricBucketItems) {
    const tagEntries = Object.entries(item.tags);
    const maybeTags = tagEntries.length > 0 ? `|#${tagEntries.map(([key, value]) => `${key}:${value}`).join(",")}` : "";
    out += `${item.name}@${item.unit}:${item.metric}|${item.metricType}${maybeTags}|T${item.timestamp}
`;
  }
  return out;
}
function createMetricEnvelope(metricBucketItems, dsn, metadata, tunnel) {
  const headers = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (metadata && metadata.sdk) {
    headers.sdk = {
      name: metadata.sdk.name,
      version: metadata.sdk.version
    };
  }
  if (!!tunnel && dsn) {
    headers.dsn = dsnToString(dsn);
  }
  const item = createMetricEnvelopeItem(metricBucketItems);
  return createEnvelope(headers, [item]);
}
function createMetricEnvelopeItem(metricBucketItems) {
  const payload = serializeMetricBuckets(metricBucketItems);
  const metricHeaders = {
    type: "statsd",
    length: payload.length
  };
  return [metricHeaders, payload];
}
const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
class BaseClient {
  /**
   * A reference to a metrics aggregator
   *
   * @experimental Note this is alpha API. It may experience breaking changes in the future.
   */
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Indicates whether this client's integrations have been set up. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(options) {
    this._options = options;
    this._integrations = {};
    this._integrationsInitialized = false;
    this._numProcessing = 0;
    this._outcomes = {};
    this._hooks = {};
    this._eventProcessors = [];
    if (options.dsn) {
      this._dsn = makeDsn(options.dsn);
    } else {
      DEBUG_BUILD$1 && logger.warn("No DSN provided, client will not send events.");
    }
    if (this._dsn) {
      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
      this._transport = options.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options.transportOptions,
        url
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
  captureException(exception, hint, scope) {
    if (checkOrSetAlreadyCaught(exception)) {
      DEBUG_BUILD$1 && logger.log(ALREADY_SEEN_ERROR);
      return;
    }
    let eventId = hint && hint.event_id;
    this._process(
      this.eventFromException(exception, hint).then((event) => this._captureEvent(event, hint, scope)).then((result) => {
        eventId = result;
      })
    );
    return eventId;
  }
  /**
   * @inheritDoc
   */
  captureMessage(message, level, hint, scope) {
    let eventId = hint && hint.event_id;
    const eventMessage = isParameterizedString(message) ? message : String(message);
    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);
    this._process(
      promisedEvent.then((event) => this._captureEvent(event, hint, scope)).then((result) => {
        eventId = result;
      })
    );
    return eventId;
  }
  /**
   * @inheritDoc
   */
  captureEvent(event, hint, scope) {
    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      DEBUG_BUILD$1 && logger.log(ALREADY_SEEN_ERROR);
      return;
    }
    let eventId = hint && hint.event_id;
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
    this._process(
      this._captureEvent(event, hint, capturedSpanScope || scope).then((result) => {
        eventId = result;
      })
    );
    return eventId;
  }
  /**
   * @inheritDoc
   */
  captureSession(session) {
    if (!(typeof session.release === "string")) {
      DEBUG_BUILD$1 && logger.warn("Discarded session because of missing or non-string release");
    } else {
      this.sendSession(session);
      updateSession(session, { init: false });
    }
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata in @sentry/types
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(timeout) {
    const transport = this._transport;
    if (transport) {
      if (this.metricsAggregator) {
        this.metricsAggregator.flush();
      }
      return this._isClientDoneProcessing(timeout).then((clientFinished) => {
        return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
      });
    } else {
      return resolvedSyncPromise(true);
    }
  }
  /**
   * @inheritDoc
   */
  close(timeout) {
    return this.flush(timeout).then((result) => {
      this.getOptions().enabled = false;
      if (this.metricsAggregator) {
        this.metricsAggregator.close();
      }
      return result;
    });
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(eventProcessor) {
    this._eventProcessors.push(eventProcessor);
  }
  /**
   * This is an internal function to setup all integrations that should run on the client.
   * @deprecated Use `client.init()` instead.
   */
  setupIntegrations(forceInitialize) {
    if (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) {
      this._setupIntegrations();
    }
  }
  /** @inheritdoc */
  init() {
    if (this._isEnabled()) {
      this._setupIntegrations();
    }
  }
  /**
   * Gets an installed integration by its `id`.
   *
   * @returns The installed integration or `undefined` if no integration with that `id` was installed.
   * @deprecated Use `getIntegrationByName()` instead.
   */
  getIntegrationById(integrationId) {
    return this.getIntegrationByName(integrationId);
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(integrationName) {
    return this._integrations[integrationName];
  }
  /**
   * Returns the client's instance of the given integration class, it any.
   * @deprecated Use `getIntegrationByName()` instead.
   */
  getIntegration(integration) {
    try {
      return this._integrations[integration.id] || null;
    } catch (_oO) {
      DEBUG_BUILD$1 && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);
      return null;
    }
  }
  /**
   * @inheritDoc
   */
  addIntegration(integration) {
    const isAlreadyInstalled = this._integrations[integration.name];
    setupIntegration(this, integration, this._integrations);
    if (!isAlreadyInstalled) {
      afterSetupIntegrations(this, [integration]);
    }
  }
  /**
   * @inheritDoc
   */
  sendEvent(event, hint = {}) {
    this.emit("beforeSendEvent", event, hint);
    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
    for (const attachment of hint.attachments || []) {
      env = addItemToEnvelope(
        env,
        createAttachmentEnvelopeItem(
          attachment,
          this._options.transportOptions && this._options.transportOptions.textEncoder
        )
      );
    }
    const promise = this._sendEnvelope(env);
    if (promise) {
      promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
    }
  }
  /**
   * @inheritDoc
   */
  sendSession(session) {
    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
    this._sendEnvelope(env);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(reason, category, eventOrCount) {
    if (this._options.sendClientReports) {
      const count = typeof eventOrCount === "number" ? eventOrCount : 1;
      const key = `${reason}:${category}`;
      DEBUG_BUILD$1 && logger.log(`Recording outcome: "${key}"${count > 1 ? ` (${count} times)` : ""}`);
      this._outcomes[key] = (this._outcomes[key] || 0) + count;
    }
  }
  /**
   * @inheritDoc
   */
  captureAggregateMetrics(metricBucketItems) {
    DEBUG_BUILD$1 && logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);
    const metricsEnvelope = createMetricEnvelope(
      metricBucketItems,
      this._dsn,
      this._options._metadata,
      this._options.tunnel
    );
    this._sendEnvelope(metricsEnvelope);
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(hook, callback) {
    if (!this._hooks[hook]) {
      this._hooks[hook] = [];
    }
    this._hooks[hook].push(callback);
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(hook, ...rest) {
    if (this._hooks[hook]) {
      this._hooks[hook].forEach((callback) => callback(...rest));
    }
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations } = this._options;
    this._integrations = setupIntegrations(this, integrations);
    afterSetupIntegrations(this, integrations);
    this._integrationsInitialized = true;
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(session, event) {
    let crashed = false;
    let errored = false;
    const exceptions = event.exception && event.exception.values;
    if (exceptions) {
      errored = true;
      for (const ex of exceptions) {
        const mechanism = ex.mechanism;
        if (mechanism && mechanism.handled === false) {
          crashed = true;
          break;
        }
      }
    }
    const sessionNonTerminal = session.status === "ok";
    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
    if (shouldUpdateAndSend) {
      updateSession(session, {
        ...crashed && { status: "crashed" },
        errors: session.errors || Number(errored || crashed)
      });
      this.captureSession(session);
    }
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(timeout) {
    return new SyncPromise((resolve) => {
      let ticked = 0;
      const tick = 1;
      const interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve(false);
          }
        }
      }, tick);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== false && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(event, hint, scope, isolationScope = getIsolationScope()) {
    const options = this.getOptions();
    const integrations = Object.keys(this._integrations);
    if (!hint.integrations && integrations.length > 0) {
      hint.integrations = integrations;
    }
    this.emit("preprocessEvent", event, hint);
    return prepareEvent(options, event, hint, scope, this, isolationScope).then((evt) => {
      if (evt === null) {
        return evt;
      }
      const propagationContext = {
        ...isolationScope.getPropagationContext(),
        ...scope ? scope.getPropagationContext() : void 0
      };
      const trace = evt.contexts && evt.contexts.trace;
      if (!trace && propagationContext) {
        const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
        evt.contexts = {
          trace: {
            trace_id,
            span_id: spanId,
            parent_span_id: parentSpanId
          },
          ...evt.contexts
        };
        const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this, scope);
        evt.sdkProcessingMetadata = {
          dynamicSamplingContext,
          ...evt.sdkProcessingMetadata
        };
      }
      return evt;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(event, hint = {}, scope) {
    return this._processEvent(event, hint, scope).then(
      (finalEvent) => {
        return finalEvent.event_id;
      },
      (reason) => {
        if (DEBUG_BUILD$1) {
          const sentryError = reason;
          if (sentryError.logLevel === "log") {
            logger.log(sentryError.message);
          } else {
            logger.warn(sentryError);
          }
        }
        return void 0;
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param scope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(event, hint, scope) {
    const options = this.getOptions();
    const { sampleRate } = options;
    const isTransaction = isTransactionEvent(event);
    const isError2 = isErrorEvent(event);
    const eventType = event.type || "error";
    const beforeSendLabel = `before send for type \`${eventType}\``;
    if (isError2 && typeof sampleRate === "number" && Math.random() > sampleRate) {
      this.recordDroppedEvent("sample_rate", "error", event);
      return rejectedSyncPromise(
        new SentryError(
          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
          "log"
        )
      );
    }
    const dataCategory = eventType === "replay_event" ? "replay" : eventType;
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
    return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then((prepared) => {
      if (prepared === null) {
        this.recordDroppedEvent("event_processor", dataCategory, event);
        throw new SentryError("An event processor returned `null`, will not send event.", "log");
      }
      const isInternalException = hint.data && hint.data.__sentry__ === true;
      if (isInternalException) {
        return prepared;
      }
      const result = processBeforeSend(options, prepared, hint);
      return _validateBeforeSendResult(result, beforeSendLabel);
    }).then((processedEvent) => {
      if (processedEvent === null) {
        this.recordDroppedEvent("before_send", dataCategory, event);
        if (isTransaction) {
          const spans = event.spans || [];
          const spanCount = 1 + spans.length;
          this.recordDroppedEvent("before_send", "span", spanCount);
        }
        throw new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
      }
      const session = scope && scope.getSession();
      if (!isTransaction && session) {
        this._updateSessionFromEvent(session, processedEvent);
      }
      if (isTransaction) {
        const spanCountBefore = processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing || 0;
        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
        const droppedSpanCount = spanCountBefore - spanCountAfter;
        if (droppedSpanCount > 0) {
          this.recordDroppedEvent("before_send", "span", droppedSpanCount);
        }
      }
      const transactionInfo = processedEvent.transaction_info;
      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
        const source = "custom";
        processedEvent.transaction_info = {
          ...transactionInfo,
          source
        };
      }
      this.sendEvent(processedEvent, hint);
      return processedEvent;
    }).then(null, (reason) => {
      if (reason instanceof SentryError) {
        throw reason;
      }
      this.captureException(reason, {
        data: {
          __sentry__: true
        },
        originalException: reason
      });
      throw new SentryError(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
      );
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(promise) {
    this._numProcessing++;
    void promise.then(
      (value) => {
        this._numProcessing--;
        return value;
      },
      (reason) => {
        this._numProcessing--;
        return reason;
      }
    );
  }
  /**
   * @inheritdoc
   */
  _sendEnvelope(envelope) {
    this.emit("beforeEnvelope", envelope);
    if (this._isEnabled() && this._transport) {
      return this._transport.send(envelope).then(null, (reason) => {
        DEBUG_BUILD$1 && logger.error("Error while sending event:", reason);
      });
    } else {
      DEBUG_BUILD$1 && logger.error("Transport disabled");
    }
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const outcomes = this._outcomes;
    this._outcomes = {};
    return Object.keys(outcomes).map((key) => {
      const [reason, category] = key.split(":");
      return {
        reason,
        category,
        quantity: outcomes[key]
      };
    });
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
}
function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
  const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
  if (isThenable(beforeSendResult)) {
    return beforeSendResult.then(
      (event) => {
        if (!isPlainObject(event) && event !== null) {
          throw new SentryError(invalidValueError);
        }
        return event;
      },
      (e2) => {
        throw new SentryError(`${beforeSendLabel} rejected with ${e2}`);
      }
    );
  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {
    throw new SentryError(invalidValueError);
  }
  return beforeSendResult;
}
function processBeforeSend(options, event, hint) {
  const { beforeSend, beforeSendTransaction } = options;
  if (isErrorEvent(event) && beforeSend) {
    return beforeSend(event, hint);
  }
  if (isTransactionEvent(event) && beforeSendTransaction) {
    if (event.spans) {
      const spanCountBefore = event.spans.length;
      event.sdkProcessingMetadata = {
        ...event.sdkProcessingMetadata,
        spanCountBeforeProcessing: spanCountBefore
      };
    }
    return beforeSendTransaction(event, hint);
  }
  return event;
}
function isErrorEvent(event) {
  return event.type === void 0;
}
function isTransactionEvent(event) {
  return event.type === "transaction";
}
function initAndBind(clientClass, options) {
  if (options.debug === true) {
    if (DEBUG_BUILD$1) {
      logger.enable();
    } else {
      consoleSandbox(() => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      });
    }
  }
  const scope = getCurrentScope();
  scope.update(options.initialScope);
  const client = new clientClass(options);
  setCurrentClient(client);
  initializeClient(client);
}
function setCurrentClient(client) {
  const hub = getCurrentHub();
  const top = hub.getStackTop();
  top.client = client;
  top.scope.setClient(client);
}
function initializeClient(client) {
  if (client.init) {
    client.init();
  } else if (client.setupIntegrations) {
    client.setupIntegrations();
  }
}
const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
function createTransport(options, makeRequest, buffer = makePromiseBuffer(
  options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
)) {
  let rateLimits = {};
  const flush = (timeout) => buffer.drain(timeout);
  function send(envelope) {
    const filteredEnvelopeItems = [];
    forEachEnvelopeItem(envelope, (item, type) => {
      const dataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, dataCategory)) {
        const event = getEventForEnvelopeItem(item, type);
        options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });
    if (filteredEnvelopeItems.length === 0) {
      return resolvedSyncPromise();
    }
    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
    const recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (item, type) => {
        const event = getEventForEnvelopeItem(item, type);
        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
      });
    };
    const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(
      (response) => {
        if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
          DEBUG_BUILD$1 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
        }
        rateLimits = updateRateLimits(rateLimits, response);
        return response;
      },
      (error2) => {
        recordEnvelopeLoss("network_error");
        throw error2;
      }
    );
    return buffer.add(requestTask).then(
      (result) => result,
      (error2) => {
        if (error2 instanceof SentryError) {
          DEBUG_BUILD$1 && logger.error("Skipped sending event because buffer is full.");
          recordEnvelopeLoss("queue_overflow");
          return resolvedSyncPromise();
        } else {
          throw error2;
        }
      }
    );
  }
  send.__sentry__baseTransport__ = true;
  return {
    send,
    flush
  };
}
function getEventForEnvelopeItem(item, type) {
  if (type !== "event" && type !== "transaction") {
    return void 0;
  }
  return Array.isArray(item) ? item[1] : void 0;
}
function applySdkMetadata(options, name, names = [name], source = "npm") {
  const metadata = options._metadata || {};
  if (!metadata.sdk) {
    metadata.sdk = {
      name: `sentry.javascript.${name}`,
      packages: names.map((name2) => ({
        name: `${source}:@sentry/${name2}`,
        version: SDK_VERSION
      })),
      version: SDK_VERSION
    };
  }
  options._metadata = metadata;
}
const DEFAULT_IGNORE_ERRORS = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  /^Cannot redefine property: googletag$/
];
const DEFAULT_IGNORE_TRANSACTIONS = [
  /^.*\/healthcheck$/,
  /^.*\/healthy$/,
  /^.*\/live$/,
  /^.*\/ready$/,
  /^.*\/heartbeat$/,
  /^.*\/health$/,
  /^.*\/healthz$/
];
const INTEGRATION_NAME$7 = "InboundFilters";
const _inboundFiltersIntegration = (options = {}) => {
  return {
    name: INTEGRATION_NAME$7,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    processEvent(event, _hint, client) {
      const clientOptions = client.getOptions();
      const mergedOptions = _mergeOptions(options, clientOptions);
      return _shouldDropEvent$1(event, mergedOptions) ? null : event;
    }
  };
};
const inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);
convertIntegrationFnToClass(
  INTEGRATION_NAME$7,
  inboundFiltersIntegration
);
function _mergeOptions(internalOptions = {}, clientOptions = {}) {
  return {
    allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
    denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
    ignoreErrors: [
      ...internalOptions.ignoreErrors || [],
      ...clientOptions.ignoreErrors || [],
      ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
    ],
    ignoreTransactions: [
      ...internalOptions.ignoreTransactions || [],
      ...clientOptions.ignoreTransactions || [],
      ...internalOptions.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS
    ],
    ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
  };
}
function _shouldDropEvent$1(event, options) {
  if (options.ignoreInternal && _isSentryError(event)) {
    DEBUG_BUILD$1 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(event)}`);
    return true;
  }
  if (_isIgnoredError(event, options.ignoreErrors)) {
    DEBUG_BUILD$1 && logger.warn(
      `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
    );
    return true;
  }
  if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
    DEBUG_BUILD$1 && logger.warn(
      `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
    );
    return true;
  }
  if (_isDeniedUrl(event, options.denyUrls)) {
    DEBUG_BUILD$1 && logger.warn(
      `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
        event
      )}.
Url: ${_getEventFilterUrl(event)}`
    );
    return true;
  }
  if (!_isAllowedUrl(event, options.allowUrls)) {
    DEBUG_BUILD$1 && logger.warn(
      `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
        event
      )}.
Url: ${_getEventFilterUrl(event)}`
    );
    return true;
  }
  return false;
}
function _isIgnoredError(event, ignoreErrors) {
  if (event.type || !ignoreErrors || !ignoreErrors.length) {
    return false;
  }
  return _getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
}
function _isIgnoredTransaction(event, ignoreTransactions) {
  if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
    return false;
  }
  const name = event.transaction;
  return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
}
function _isDeniedUrl(event, denyUrls) {
  if (!denyUrls || !denyUrls.length) {
    return false;
  }
  const url = _getEventFilterUrl(event);
  return !url ? false : stringMatchesSomePattern(url, denyUrls);
}
function _isAllowedUrl(event, allowUrls) {
  if (!allowUrls || !allowUrls.length) {
    return true;
  }
  const url = _getEventFilterUrl(event);
  return !url ? true : stringMatchesSomePattern(url, allowUrls);
}
function _getPossibleEventMessages(event) {
  const possibleMessages = [];
  if (event.message) {
    possibleMessages.push(event.message);
  }
  let lastException;
  try {
    lastException = event.exception.values[event.exception.values.length - 1];
  } catch (e2) {
  }
  if (lastException) {
    if (lastException.value) {
      possibleMessages.push(lastException.value);
      if (lastException.type) {
        possibleMessages.push(`${lastException.type}: ${lastException.value}`);
      }
    }
  }
  if (DEBUG_BUILD$1 && possibleMessages.length === 0) {
    logger.error(`Could not extract message for event ${getEventDescription(event)}`);
  }
  return possibleMessages;
}
function _isSentryError(event) {
  try {
    return event.exception.values[0].type === "SentryError";
  } catch (e2) {
  }
  return false;
}
function _getLastValidUrl(frames = []) {
  for (let i = frames.length - 1; i >= 0; i--) {
    const frame = frames[i];
    if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
      return frame.filename || null;
    }
  }
  return null;
}
function _getEventFilterUrl(event) {
  try {
    let frames;
    try {
      frames = event.exception.values[0].stacktrace.frames;
    } catch (e2) {
    }
    return frames ? _getLastValidUrl(frames) : null;
  } catch (oO) {
    DEBUG_BUILD$1 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
    return null;
  }
}
let originalFunctionToString;
const INTEGRATION_NAME$6 = "FunctionToString";
const SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
const _functionToStringIntegration = () => {
  return {
    name: INTEGRATION_NAME$6,
    setupOnce() {
      originalFunctionToString = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...args) {
          const originalFunction = getOriginalFunction(this);
          const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
          return originalFunctionToString.apply(context, args);
        };
      } catch (e2) {
      }
    },
    setup(client) {
      SETUP_CLIENTS.set(client, true);
    }
  };
};
const functionToStringIntegration = defineIntegration(_functionToStringIntegration);
convertIntegrationFnToClass(
  INTEGRATION_NAME$6,
  functionToStringIntegration
);
const WINDOW = GLOBAL_OBJ;
let ignoreOnError = 0;
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}
function ignoreNextOnError() {
  ignoreOnError++;
  setTimeout(() => {
    ignoreOnError--;
  });
}
function wrap(fn, options = {}, before) {
  if (typeof fn !== "function") {
    return fn;
  }
  try {
    const wrapper = fn.__sentry_wrapped__;
    if (wrapper) {
      if (typeof wrapper === "function") {
        return wrapper;
      } else {
        return fn;
      }
    }
    if (getOriginalFunction(fn)) {
      return fn;
    }
  } catch (e2) {
    return fn;
  }
  const sentryWrapped = function() {
    const args = Array.prototype.slice.call(arguments);
    try {
      if (before && typeof before === "function") {
        before.apply(this, arguments);
      }
      const wrappedArguments = args.map((arg) => wrap(arg, options));
      return fn.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();
      withScope((scope) => {
        scope.addEventProcessor((event) => {
          if (options.mechanism) {
            addExceptionTypeValue(event, void 0, void 0);
            addExceptionMechanism(event, options.mechanism);
          }
          event.extra = {
            ...event.extra,
            arguments: args
          };
          return event;
        });
        captureException(ex);
      });
      throw ex;
    }
  };
  try {
    for (const property in fn) {
      if (Object.prototype.hasOwnProperty.call(fn, property)) {
        sentryWrapped[property] = fn[property];
      }
    }
  } catch (_oO) {
  }
  markFunctionWrapped(sentryWrapped, fn);
  addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
  try {
    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, "name", {
        get() {
          return fn.name;
        }
      });
    }
  } catch (_oO) {
  }
  return sentryWrapped;
}
const DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
function exceptionFromError(stackParser, ex) {
  const frames = parseStackFrames(stackParser, ex);
  const exception = {
    type: ex && ex.name,
    value: extractMessage(ex)
  };
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  if (exception.type === void 0 && exception.value === "") {
    exception.value = "Unrecoverable error caught";
  }
  return exception;
}
function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
  const client = getClient();
  const normalizeDepth = client && client.getOptions().normalizeDepth;
  const event = {
    exception: {
      values: [
        {
          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
          value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })
        }
      ]
    },
    extra: {
      __serialized__: normalizeToSize(exception, normalizeDepth)
    }
  };
  if (syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception.values[0].stacktrace = { frames };
    }
  }
  return event;
}
function eventFromError(stackParser, ex) {
  return {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
}
function parseStackFrames(stackParser, ex) {
  const stacktrace = ex.stacktrace || ex.stack || "";
  const popSize = getPopSize(ex);
  try {
    return stackParser(stacktrace, popSize);
  } catch (e2) {
  }
  return [];
}
const reactMinifiedRegexp = /Minified React error #\d+;/i;
function getPopSize(ex) {
  if (ex) {
    if (typeof ex.framesToPop === "number") {
      return ex.framesToPop;
    }
    if (reactMinifiedRegexp.test(ex.message)) {
      return 1;
    }
  }
  return 0;
}
function extractMessage(ex) {
  const message = ex && ex.message;
  if (!message) {
    return "No error message";
  }
  if (message.error && typeof message.error.message === "string") {
    return message.error.message;
  }
  return message;
}
function eventFromException(stackParser, exception, hint, attachStacktrace) {
  const syntheticException = hint && hint.syntheticException || void 0;
  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionMechanism(event);
  event.level = "error";
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const syntheticException = hint && hint.syntheticException || void 0;
  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
  event.level = level;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
  let event;
  if (isErrorEvent$1(exception) && exception.error) {
    const errorEvent = exception;
    return eventFromError(stackParser, errorEvent.error);
  }
  if (isDOMError(exception) || isDOMException(exception)) {
    const domException = exception;
    if ("stack" in exception) {
      event = eventFromError(stackParser, exception);
    } else {
      const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
      const message = domException.message ? `${name}: ${domException.message}` : name;
      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, message);
    }
    if ("code" in domException) {
      event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
    }
    return event;
  }
  if (isError(exception)) {
    return eventFromError(stackParser, exception);
  }
  if (isPlainObject(exception) || isEvent(exception)) {
    const objectException = exception;
    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionTypeValue(event, `${exception}`, void 0);
  addExceptionMechanism(event, {
    synthetic: true
  });
  return event;
}
function eventFromString(stackParser, message, syntheticException, attachStacktrace) {
  const event = {};
  if (attachStacktrace && syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception = {
        values: [{ value: message, stacktrace: { frames } }]
      };
    }
  }
  if (isParameterizedString(message)) {
    const { __sentry_template_string__, __sentry_template_values__ } = message;
    event.logentry = {
      message: __sentry_template_string__,
      params: __sentry_template_values__
    };
    return event;
  }
  event.message = message;
  return event;
}
function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {
  const keys3 = extractExceptionKeysForMessage(exception);
  const captureType = isUnhandledRejection ? "promise rejection" : "exception";
  if (isErrorEvent$1(exception)) {
    return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
  }
  if (isEvent(exception)) {
    const className = getObjectClassName(exception);
    return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
  }
  return `Object captured as ${captureType} with keys: ${keys3}`;
}
function getObjectClassName(obj) {
  try {
    const prototype = Object.getPrototypeOf(obj);
    return prototype ? prototype.constructor.name : void 0;
  } catch (e2) {
  }
}
function createUserFeedbackEnvelope(feedback, {
  metadata,
  tunnel,
  dsn
}) {
  const headers = {
    event_id: feedback.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...metadata && metadata.sdk && {
      sdk: {
        name: metadata.sdk.name,
        version: metadata.sdk.version
      }
    },
    ...!!tunnel && !!dsn && { dsn: dsnToString(dsn) }
  };
  const item = createUserFeedbackEnvelopeItem(feedback);
  return createEnvelope(headers, [item]);
}
function createUserFeedbackEnvelopeItem(feedback) {
  const feedbackHeaders = {
    type: "user_report"
  };
  return [feedbackHeaders, feedback];
}
class BrowserClient extends BaseClient {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(options) {
    const sdkSource = WINDOW.SENTRY_SDK_SOURCE || getSDKSource();
    applySdkMetadata(options, "browser", ["browser"], sdkSource);
    super(options);
    if (options.sendClientReports && WINDOW.document) {
      WINDOW.document.addEventListener("visibilitychange", () => {
        if (WINDOW.document.visibilityState === "hidden") {
          this._flushOutcomes();
        }
      });
    }
  }
  /**
   * @inheritDoc
   */
  eventFromException(exception, hint) {
    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(message, level = "info", hint) {
    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   */
  captureUserFeedback(feedback) {
    if (!this._isEnabled()) {
      DEBUG_BUILD && logger.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const envelope = createUserFeedbackEnvelope(feedback, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this._sendEnvelope(envelope);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(event, hint, scope) {
    event.platform = event.platform || "javascript";
    return super._prepareEvent(event, hint, scope);
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    const outcomes = this._clearOutcomes();
    if (outcomes.length === 0) {
      DEBUG_BUILD && logger.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      DEBUG_BUILD && logger.log("No dsn provided, will not send outcomes");
      return;
    }
    DEBUG_BUILD && logger.log("Sending outcomes:", outcomes);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
    this._sendEnvelope(envelope);
  }
}
let cachedFetchImpl = void 0;
function getNativeFetchImplementation() {
  if (cachedFetchImpl) {
    return cachedFetchImpl;
  }
  if (isNativeFetch(WINDOW.fetch)) {
    return cachedFetchImpl = WINDOW.fetch.bind(WINDOW);
  }
  const document2 = WINDOW.document;
  let fetchImpl = WINDOW.fetch;
  if (document2 && typeof document2.createElement === "function") {
    try {
      const sandbox = document2.createElement("iframe");
      sandbox.hidden = true;
      document2.head.appendChild(sandbox);
      const contentWindow = sandbox.contentWindow;
      if (contentWindow && contentWindow.fetch) {
        fetchImpl = contentWindow.fetch;
      }
      document2.head.removeChild(sandbox);
    } catch (e2) {
      DEBUG_BUILD && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e2);
    }
  }
  return cachedFetchImpl = fetchImpl.bind(WINDOW);
}
function clearCachedFetchImplementation() {
  cachedFetchImpl = void 0;
}
function makeFetchTransport(options, nativeFetch = getNativeFetchImplementation()) {
  let pendingBodySize = 0;
  let pendingCount = 0;
  function makeRequest(request) {
    const requestSize = request.body.length;
    pendingBodySize += requestSize;
    pendingCount++;
    const requestOptions = {
      body: request.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: options.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
      ...options.fetchOptions
    };
    try {
      return nativeFetch(options.url, requestOptions).then((response) => {
        pendingBodySize -= requestSize;
        pendingCount--;
        return {
          statusCode: response.status,
          headers: {
            "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
            "retry-after": response.headers.get("Retry-After")
          }
        };
      });
    } catch (e2) {
      clearCachedFetchImplementation();
      pendingBodySize -= requestSize;
      pendingCount--;
      return rejectedSyncPromise(e2);
    }
  }
  return createTransport(options, makeRequest);
}
const XHR_READYSTATE_DONE = 4;
function makeXHRTransport(options) {
  function makeRequest(request) {
    return new SyncPromise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.onerror = reject;
      xhr.onreadystatechange = () => {
        if (xhr.readyState === XHR_READYSTATE_DONE) {
          resolve({
            statusCode: xhr.status,
            headers: {
              "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
              "retry-after": xhr.getResponseHeader("Retry-After")
            }
          });
        }
      };
      xhr.open("POST", options.url);
      for (const header in options.headers) {
        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
          xhr.setRequestHeader(header, options.headers[header]);
        }
      }
      xhr.send(request.body);
    });
  }
  return createTransport(options, makeRequest);
}
const UNKNOWN_FUNCTION = "?";
const CHROME_PRIORITY = 30;
const WINJS_PRIORITY = 40;
const GECKO_PRIORITY = 50;
function createFrame(filename, func, lineno, colno) {
  const frame = {
    filename,
    function: func,
    in_app: true
    // All browser frames are considered in_app
  };
  if (lineno !== void 0) {
    frame.lineno = lineno;
  }
  if (colno !== void 0) {
    frame.colno = colno;
  }
  return frame;
}
const chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
const chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
const chromeStackParserFn = (line) => {
  const parts = chromeRegex.exec(line);
  if (parts) {
    const isEval = parts[2] && parts[2].indexOf("eval") === 0;
    if (isEval) {
      const subMatch = chromeEvalRegex.exec(parts[2]);
      if (subMatch) {
        parts[2] = subMatch[1];
        parts[3] = subMatch[2];
        parts[4] = subMatch[3];
      }
    }
    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
    return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
  }
  return;
};
const chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];
const geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
const geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
const gecko = (line) => {
  const parts = geckoREgex.exec(line);
  if (parts) {
    const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
    if (isEval) {
      const subMatch = geckoEvalRegex.exec(parts[3]);
      if (subMatch) {
        parts[1] = parts[1] || "eval";
        parts[3] = subMatch[1];
        parts[4] = subMatch[2];
        parts[5] = "";
      }
    }
    let filename = parts[3];
    let func = parts[1] || UNKNOWN_FUNCTION;
    [func, filename] = extractSafariExtensionDetails(func, filename);
    return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
  }
  return;
};
const geckoStackLineParser = [GECKO_PRIORITY, gecko];
const winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
const winjs = (line) => {
  const parts = winjsRegex.exec(line);
  return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
};
const winjsStackLineParser = [WINJS_PRIORITY, winjs];
const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];
const defaultStackParser = createStackParser(...defaultStackLineParsers);
const extractSafariExtensionDetails = (func, filename) => {
  const isSafariExtension = func.indexOf("safari-extension") !== -1;
  const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
  return isSafariExtension || isSafariWebExtension ? [
    func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
    isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
  ] : [func, filename];
};
const MAX_ALLOWED_STRING_LENGTH = 1024;
const INTEGRATION_NAME$5 = "Breadcrumbs";
const _breadcrumbsIntegration = (options = {}) => {
  const _options = {
    console: true,
    dom: true,
    fetch: true,
    history: true,
    sentry: true,
    xhr: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME$5,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    setup(client) {
      if (_options.console) {
        addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));
      }
      if (_options.dom) {
        addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));
      }
      if (_options.xhr) {
        addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));
      }
      if (_options.fetch) {
        addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));
      }
      if (_options.history) {
        addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));
      }
      if (_options.sentry && client.on) {
        client.on("beforeSendEvent", _getSentryBreadcrumbHandler(client));
      }
    }
  };
};
const breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);
convertIntegrationFnToClass(INTEGRATION_NAME$5, breadcrumbsIntegration);
function _getSentryBreadcrumbHandler(client) {
  return function addSentryBreadcrumb(event) {
    if (getClient() !== client) {
      return;
    }
    addBreadcrumb(
      {
        category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
        event_id: event.event_id,
        level: event.level,
        message: getEventDescription(event)
      },
      {
        event
      }
    );
  };
}
function _getDomBreadcrumbHandler(client, dom) {
  return function _innerDomBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    let target;
    let componentName;
    let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
    let maxStringLength = typeof dom === "object" && typeof dom.maxStringLength === "number" ? dom.maxStringLength : void 0;
    if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
      DEBUG_BUILD && logger.warn(
        `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`
      );
      maxStringLength = MAX_ALLOWED_STRING_LENGTH;
    }
    if (typeof keyAttrs === "string") {
      keyAttrs = [keyAttrs];
    }
    try {
      const event = handlerData.event;
      const element = _isEvent(event) ? event.target : event;
      target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
      componentName = getComponentName(element);
    } catch (e2) {
      target = "<unknown>";
    }
    if (target.length === 0) {
      return;
    }
    const breadcrumb = {
      category: `ui.${handlerData.name}`,
      message: target
    };
    if (componentName) {
      breadcrumb.data = { "ui.component_name": componentName };
    }
    addBreadcrumb(breadcrumb, {
      event: handlerData.event,
      name: handlerData.name,
      global: handlerData.global
    });
  };
}
function _getConsoleBreadcrumbHandler(client) {
  return function _consoleBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const breadcrumb = {
      category: "console",
      data: {
        arguments: handlerData.args,
        logger: "console"
      },
      level: severityLevelFromString(handlerData.level),
      message: safeJoin(handlerData.args, " ")
    };
    if (handlerData.level === "assert") {
      if (handlerData.args[0] === false) {
        breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
        breadcrumb.data.arguments = handlerData.args.slice(1);
      } else {
        return;
      }
    }
    addBreadcrumb(breadcrumb, {
      input: handlerData.args,
      level: handlerData.level
    });
  };
}
function _getXhrBreadcrumbHandler(client) {
  return function _xhrBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const { startTimestamp, endTimestamp } = handlerData;
    const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
    if (!startTimestamp || !endTimestamp || !sentryXhrData) {
      return;
    }
    const { method, url, status_code, body } = sentryXhrData;
    const data = {
      method,
      url,
      status_code
    };
    const hint = {
      xhr: handlerData.xhr,
      input: body,
      startTimestamp,
      endTimestamp
    };
    addBreadcrumb(
      {
        category: "xhr",
        data,
        type: "http"
      },
      hint
    );
  };
}
function _getFetchBreadcrumbHandler(client) {
  return function _fetchBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const { startTimestamp, endTimestamp } = handlerData;
    if (!endTimestamp) {
      return;
    }
    if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
      return;
    }
    if (handlerData.error) {
      const data = handlerData.fetchData;
      const hint = {
        data: handlerData.error,
        input: handlerData.args,
        startTimestamp,
        endTimestamp
      };
      addBreadcrumb(
        {
          category: "fetch",
          data,
          level: "error",
          type: "http"
        },
        hint
      );
    } else {
      const response = handlerData.response;
      const data = {
        ...handlerData.fetchData,
        status_code: response && response.status
      };
      const hint = {
        input: handlerData.args,
        response,
        startTimestamp,
        endTimestamp
      };
      addBreadcrumb(
        {
          category: "fetch",
          data,
          type: "http"
        },
        hint
      );
    }
  };
}
function _getHistoryBreadcrumbHandler(client) {
  return function _historyBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    let from = handlerData.from;
    let to2 = handlerData.to;
    const parsedLoc = parseUrl(WINDOW.location.href);
    let parsedFrom = from ? parseUrl(from) : void 0;
    const parsedTo = parseUrl(to2);
    if (!parsedFrom || !parsedFrom.path) {
      parsedFrom = parsedLoc;
    }
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
      to2 = parsedTo.relative;
    }
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
      from = parsedFrom.relative;
    }
    addBreadcrumb({
      category: "navigation",
      data: {
        from,
        to: to2
      }
    });
  };
}
function _isEvent(event) {
  return !!event && !!event.target;
}
const INTEGRATION_NAME$4 = "Dedupe";
const _dedupeIntegration = () => {
  let previousEvent;
  return {
    name: INTEGRATION_NAME$4,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    processEvent(currentEvent) {
      if (currentEvent.type) {
        return currentEvent;
      }
      try {
        if (_shouldDropEvent(currentEvent, previousEvent)) {
          DEBUG_BUILD && logger.warn("Event dropped due to being a duplicate of previously captured event.");
          return null;
        }
      } catch (_oO) {
      }
      return previousEvent = currentEvent;
    }
  };
};
const dedupeIntegration = defineIntegration(_dedupeIntegration);
convertIntegrationFnToClass(INTEGRATION_NAME$4, dedupeIntegration);
function _shouldDropEvent(currentEvent, previousEvent) {
  if (!previousEvent) {
    return false;
  }
  if (_isSameMessageEvent(currentEvent, previousEvent)) {
    return true;
  }
  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
    return true;
  }
  return false;
}
function _isSameMessageEvent(currentEvent, previousEvent) {
  const currentMessage = currentEvent.message;
  const previousMessage = previousEvent.message;
  if (!currentMessage && !previousMessage) {
    return false;
  }
  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
    return false;
  }
  if (currentMessage !== previousMessage) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameExceptionEvent(currentEvent, previousEvent) {
  const previousException = _getExceptionFromEvent(previousEvent);
  const currentException = _getExceptionFromEvent(currentEvent);
  if (!previousException || !currentException) {
    return false;
  }
  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameStacktrace(currentEvent, previousEvent) {
  let currentFrames = _getFramesFromEvent(currentEvent);
  let previousFrames = _getFramesFromEvent(previousEvent);
  if (!currentFrames && !previousFrames) {
    return true;
  }
  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
    return false;
  }
  currentFrames = currentFrames;
  previousFrames = previousFrames;
  if (previousFrames.length !== currentFrames.length) {
    return false;
  }
  for (let i = 0; i < previousFrames.length; i++) {
    const frameA = previousFrames[i];
    const frameB = currentFrames[i];
    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
      return false;
    }
  }
  return true;
}
function _isSameFingerprint(currentEvent, previousEvent) {
  let currentFingerprint = currentEvent.fingerprint;
  let previousFingerprint = previousEvent.fingerprint;
  if (!currentFingerprint && !previousFingerprint) {
    return true;
  }
  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
    return false;
  }
  currentFingerprint = currentFingerprint;
  previousFingerprint = previousFingerprint;
  try {
    return !!(currentFingerprint.join("") === previousFingerprint.join(""));
  } catch (_oO) {
    return false;
  }
}
function _getExceptionFromEvent(event) {
  return event.exception && event.exception.values && event.exception.values[0];
}
function _getFramesFromEvent(event) {
  const exception = event.exception;
  if (exception) {
    try {
      return exception.values[0].stacktrace.frames;
    } catch (_oO) {
      return void 0;
    }
  }
  return void 0;
}
const INTEGRATION_NAME$3 = "GlobalHandlers";
const _globalHandlersIntegration = (options = {}) => {
  const _options = {
    onerror: true,
    onunhandledrejection: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME$3,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(client) {
      if (_options.onerror) {
        _installGlobalOnErrorHandler(client);
        globalHandlerLog("onerror");
      }
      if (_options.onunhandledrejection) {
        _installGlobalOnUnhandledRejectionHandler(client);
        globalHandlerLog("onunhandledrejection");
      }
    }
  };
};
const globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);
convertIntegrationFnToClass(
  INTEGRATION_NAME$3,
  globalHandlersIntegration
);
function _installGlobalOnErrorHandler(client) {
  addGlobalErrorInstrumentationHandler((data) => {
    const { stackParser, attachStacktrace } = getOptions();
    if (getClient() !== client || shouldIgnoreOnError()) {
      return;
    }
    const { msg, url, line, column, error: error2 } = data;
    const event = error2 === void 0 && isString3(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(
      eventFromUnknownInput(stackParser, error2 || msg, void 0, attachStacktrace, false),
      url,
      line,
      column
    );
    event.level = "error";
    captureEvent(event, {
      originalException: error2,
      mechanism: {
        handled: false,
        type: "onerror"
      }
    });
  });
}
function _installGlobalOnUnhandledRejectionHandler(client) {
  addGlobalUnhandledRejectionInstrumentationHandler((e2) => {
    const { stackParser, attachStacktrace } = getOptions();
    if (getClient() !== client || shouldIgnoreOnError()) {
      return;
    }
    const error2 = _getUnhandledRejectionError(e2);
    const event = isPrimitive(error2) ? _eventFromRejectionWithPrimitive(error2) : eventFromUnknownInput(stackParser, error2, void 0, attachStacktrace, true);
    event.level = "error";
    captureEvent(event, {
      originalException: error2,
      mechanism: {
        handled: false,
        type: "onunhandledrejection"
      }
    });
  });
}
function _getUnhandledRejectionError(error2) {
  if (isPrimitive(error2)) {
    return error2;
  }
  const e2 = error2;
  try {
    if ("reason" in e2) {
      return e2.reason;
    } else if ("detail" in e2 && "reason" in e2.detail) {
      return e2.detail.reason;
    }
  } catch (e22) {
  }
  return error2;
}
function _eventFromRejectionWithPrimitive(reason) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(reason)}`
        }
      ]
    }
  };
}
function _eventFromIncompleteOnError(msg, url, line, column) {
  const ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  let message = isErrorEvent$1(msg) ? msg.message : msg;
  let name = "Error";
  const groups = message.match(ERROR_TYPES_RE);
  if (groups) {
    name = groups[1];
    message = groups[2];
  }
  const event = {
    exception: {
      values: [
        {
          type: name,
          value: message
        }
      ]
    }
  };
  return _enhanceEventWithInitialFrame(event, url, line, column);
}
function _enhanceEventWithInitialFrame(event, url, line, column) {
  const e2 = event.exception = event.exception || {};
  const ev = e2.values = e2.values || [];
  const ev0 = ev[0] = ev[0] || {};
  const ev0s = ev0.stacktrace = ev0.stacktrace || {};
  const ev0sf = ev0s.frames = ev0s.frames || [];
  const colno = isNaN(parseInt(column, 10)) ? void 0 : column;
  const lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
  const filename = isString3(url) && url.length > 0 ? url : getLocationHref();
  if (ev0sf.length === 0) {
    ev0sf.push({
      colno,
      filename,
      function: "?",
      in_app: true,
      lineno
    });
  }
  return event;
}
function globalHandlerLog(type) {
  DEBUG_BUILD && logger.log(`Global Handler attached: ${type}`);
}
function getOptions() {
  const client = getClient();
  const options = client && client.getOptions() || {
    stackParser: () => [],
    attachStacktrace: false
  };
  return options;
}
const INTEGRATION_NAME$2 = "HttpContext";
const _httpContextIntegration = () => {
  return {
    name: INTEGRATION_NAME$2,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    preprocessEvent(event) {
      if (!WINDOW.navigator && !WINDOW.location && !WINDOW.document) {
        return;
      }
      const url = event.request && event.request.url || WINDOW.location && WINDOW.location.href;
      const { referrer } = WINDOW.document || {};
      const { userAgent } = WINDOW.navigator || {};
      const headers = {
        ...event.request && event.request.headers,
        ...referrer && { Referer: referrer },
        ...userAgent && { "User-Agent": userAgent }
      };
      const request = { ...event.request, ...url && { url }, headers };
      event.request = request;
    }
  };
};
const httpContextIntegration = defineIntegration(_httpContextIntegration);
convertIntegrationFnToClass(INTEGRATION_NAME$2, httpContextIntegration);
const DEFAULT_KEY = "cause";
const DEFAULT_LIMIT = 5;
const INTEGRATION_NAME$1 = "LinkedErrors";
const _linkedErrorsIntegration = (options = {}) => {
  const limit = options.limit || DEFAULT_LIMIT;
  const key = options.key || DEFAULT_KEY;
  return {
    name: INTEGRATION_NAME$1,
    // TODO v8: Remove this
    setupOnce() {
    },
    // eslint-disable-line @typescript-eslint/no-empty-function
    preprocessEvent(event, hint, client) {
      const options2 = client.getOptions();
      applyAggregateErrorsToEvent(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        exceptionFromError,
        options2.stackParser,
        options2.maxValueLength,
        key,
        limit,
        event,
        hint
      );
    }
  };
};
const linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
convertIntegrationFnToClass(INTEGRATION_NAME$1, linkedErrorsIntegration);
const DEFAULT_EVENT_TARGET = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
];
const INTEGRATION_NAME = "TryCatch";
const _browserApiErrorsIntegration = (options = {}) => {
  const _options = {
    XMLHttpRequest: true,
    eventTarget: true,
    requestAnimationFrame: true,
    setInterval: true,
    setTimeout: true,
    ...options
  };
  return {
    name: INTEGRATION_NAME,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      if (_options.setTimeout) {
        fill(WINDOW, "setTimeout", _wrapTimeFunction);
      }
      if (_options.setInterval) {
        fill(WINDOW, "setInterval", _wrapTimeFunction);
      }
      if (_options.requestAnimationFrame) {
        fill(WINDOW, "requestAnimationFrame", _wrapRAF);
      }
      if (_options.XMLHttpRequest && "XMLHttpRequest" in WINDOW) {
        fill(XMLHttpRequest.prototype, "send", _wrapXHR);
      }
      const eventTargetOption = _options.eventTarget;
      if (eventTargetOption) {
        const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
        eventTarget.forEach(_wrapEventTarget);
      }
    }
  };
};
const browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);
convertIntegrationFnToClass(
  INTEGRATION_NAME,
  browserApiErrorsIntegration
);
function _wrapTimeFunction(original) {
  return function(...args) {
    const originalCallback = args[0];
    args[0] = wrap(originalCallback, {
      mechanism: {
        data: { function: getFunctionName(original) },
        handled: false,
        type: "instrument"
      }
    });
    return original.apply(this, args);
  };
}
function _wrapRAF(original) {
  return function(callback) {
    return original.apply(this, [
      wrap(callback, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: getFunctionName(original)
          },
          handled: false,
          type: "instrument"
        }
      })
    ]);
  };
}
function _wrapXHR(originalSend) {
  return function(...args) {
    const xhr = this;
    const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
    xmlHttpRequestProps.forEach((prop) => {
      if (prop in xhr && typeof xhr[prop] === "function") {
        fill(xhr, prop, function(original) {
          const wrapOptions = {
            mechanism: {
              data: {
                function: prop,
                handler: getFunctionName(original)
              },
              handled: false,
              type: "instrument"
            }
          };
          const originalFunction = getOriginalFunction(original);
          if (originalFunction) {
            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
          }
          return wrap(original, wrapOptions);
        });
      }
    });
    return originalSend.apply(this, args);
  };
}
function _wrapEventTarget(target) {
  const globalObject = WINDOW;
  const proto2 = globalObject[target] && globalObject[target].prototype;
  if (!proto2 || !proto2.hasOwnProperty || !proto2.hasOwnProperty("addEventListener")) {
    return;
  }
  fill(proto2, "addEventListener", function(original) {
    return function(eventName, fn, options) {
      try {
        if (typeof fn.handleEvent === "function") {
          fn.handleEvent = wrap(fn.handleEvent, {
            mechanism: {
              data: {
                function: "handleEvent",
                handler: getFunctionName(fn),
                target
              },
              handled: false,
              type: "instrument"
            }
          });
        }
      } catch (err) {
      }
      return original.apply(this, [
        eventName,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        wrap(fn, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: getFunctionName(fn),
              target
            },
            handled: false,
            type: "instrument"
          }
        }),
        options
      ]);
    };
  });
  fill(
    proto2,
    "removeEventListener",
    function(originalRemoveEventListener) {
      return function(eventName, fn, options) {
        const wrappedEventHandler = fn;
        try {
          const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
          if (originalEventHandler) {
            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
          }
        } catch (e2) {
        }
        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
      };
    }
  );
}
const defaultIntegrations = [
  inboundFiltersIntegration(),
  functionToStringIntegration(),
  browserApiErrorsIntegration(),
  breadcrumbsIntegration(),
  globalHandlersIntegration(),
  linkedErrorsIntegration(),
  dedupeIntegration(),
  httpContextIntegration()
];
function getDefaultIntegrations(_options) {
  return [
    // eslint-disable-next-line deprecation/deprecation
    ...defaultIntegrations
  ];
}
function init$1(options = {}) {
  if (options.defaultIntegrations === void 0) {
    options.defaultIntegrations = getDefaultIntegrations();
  }
  if (options.release === void 0) {
    if (typeof __SENTRY_RELEASE__ === "string") {
      options.release = __SENTRY_RELEASE__;
    }
    if (WINDOW.SENTRY_RELEASE && WINDOW.SENTRY_RELEASE.id) {
      options.release = WINDOW.SENTRY_RELEASE.id;
    }
  }
  if (options.autoSessionTracking === void 0) {
    options.autoSessionTracking = true;
  }
  if (options.sendClientReports === void 0) {
    options.sendClientReports = true;
  }
  const clientOptions = {
    ...options,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options),
    transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport)
  };
  initAndBind(BrowserClient, clientOptions);
  if (options.autoSessionTracking) {
    startSessionTracking();
  }
}
function startSessionTracking() {
  if (typeof WINDOW.document === "undefined") {
    DEBUG_BUILD && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  startSession({ ignoreDuration: true });
  captureSession();
  addHistoryInstrumentationHandler(({ from, to: to2 }) => {
    if (from !== void 0 && from !== to2) {
      startSession({ ignoreDuration: true });
      captureSession();
    }
  });
}
function init2(options) {
  const opts = {
    ...options
  };
  applySdkMetadata(opts, "react");
  init$1(opts);
}
const HEYLOGIN_VERSION = "2024-11-29-99ee37d32";
const AUTOSNATCH_OVERLAY_SHADOW_WIDTH_PX = 4;
function getBackendUrl() {
  return "https://heylogin.app/api/v1";
}
function getFrontendServerUrl() {
  return `https://${getFrontendServerHost()}`;
}
function getFrontendServerHost() {
  return "heylogin.app";
}
function initSentry({
  entryPoint,
  contentScript,
  skipProductionCheck
}) {
  var _a2;
  const prodOrStagingBackend = (_a2 = getBackendHostname()) == null ? void 0 : _a2.endsWith("heylogin.app");
  const isProdOrStaging = prodOrStagingBackend;
  if (!isProdOrStaging && !skipProductionCheck) {
    return;
  }
  if (browser.extension.inIncognitoContext) {
    return;
  }
  const browserInfo = Bowser.parse(navigator.userAgent);
  if (browserInfo.browser.name === "Firefox") {
    return;
  }
  try {
    init2({
      dsn: "https://a84c0408f0864d0bb6002a42294d213b@stackreports.heylogin.app/5338044",
      release: HEYLOGIN_VERSION || "unknown version",
      // TODO reconsider this if we ever create staging build of the extension
      environment: "production",
      autoSessionTracking: false,
      integrations: (integrations) => {
        let filteredIntegrations = integrations;
        if (contentScript) {
          const disabledIntegrationNames = ["Breadcrumbs", "TryCatch", "GlobalHandlers"];
          filteredIntegrations = filteredIntegrations.filter((integration) => !disabledIntegrationNames.includes(integration.name));
        }
        return filteredIntegrations;
      },
      // see https://develop.sentry.dev/sdk/data-model/event-payloads/breadcrumbs/#breadcrumb-types
      beforeBreadcrumb: (breadcrumb, _hint) => {
        if (breadcrumb.type === "http") {
          if (breadcrumb.data && typeof breadcrumb.data.url === "string" && breadcrumb.data.url.startsWith("data:")) {
            return null;
          }
        }
        return breadcrumb;
      },
      beforeSend: (event) => {
        if (event.request) {
          event.request.url = void 0;
        }
        return event;
      },
      ignoreErrors: [
        // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
        "ResizeObserver loop limit exceeded",
        "ResizeObserver loop completed with undelivered notifications.",
        // Temporary fix, to avoid exhausting our sentry quota with this error: https://sentry.io/organizations/heylogin/issues/2274010196/
        // This is due to a chrome bug: https://bugs.chromium.org/p/chromium/issues/detail?id=1213925
        "Tabs cannot be queried right now (user may be dragging a tab).",
        // Nothing we can do about this error, no need to report
        "The browser is shutting down."
      ]
    });
    configureScope$1((scope) => {
      scope.setTag("entryPoint", entryPoint);
    });
    configureScope().catch(trackError);
    browser.runtime.onMessage.addListener(makeMessageListener({
      DataUpdate: configureScope
    }));
    if (!HEYLOGIN_VERSION && !skipProductionCheck && entryPoint === "background")
      ;
  } catch (e2) {
    console.error("Error while initializing error reporting ¯\\_(ツ)_/¯", e2);
  }
}
async function configureScope() {
  const response = await sendMessage({
    type: "GetUser"
  });
  if (response === messageError) {
    return;
  }
  const {
    userId,
    clientId
  } = {
    userId: void 0,
    clientId: void 0,
    ...response
  };
  updateSentryScope(userId, clientId);
}
function updateSentryScope(userId, clientId) {
  configureScope$1((scope) => {
    scope.setUser({
      id: userId
    });
    scope.setTag("clientId", clientId ?? "empty");
  });
}
function getBackendHostname() {
  try {
    return new URL(getBackendUrl()).hostname;
  } catch (e2) {
    return void 0;
  }
}
const messages$1 = JSON.parse(`{"jBI8Lx":[["0","plural",{"other":["#"," Logins durchsuchen"]}]],"ZsmGRL":["'am' ",["atAbsoluteDate"]],"aHvVg8":[["browserName"]," blockiert Browser-Erweiterungen auf dieser Seite"],"aLmCR/":[["browserName"]," blockiert heylogin auf dieser Seite"],"uooG+Q":[["hiddenLoginsCount","plural",{"one":["#"," weiteres Login anzeigen"],"other":["#"," weitere Logins anzeigen"]}]],"pgvip9":[["uppercaseName"]," kopiert!"],"8d6VgQ":["<0>In</0> ",["vaultLabel"]],"RQWed3":"1-Klick-Login erfolgreich eingerichtet. Du kannst dich jetzt auf jeder Webseite einloggen.","PWU3n3":"Zu Login hinzufügen","2vJK8B":"Nutzernamen hinzufügen","8uQ9hR":"Automatisch erzeugten Screenshot mitschicken","iH8pgl":"Zurück","lKI/c0":"weil dies ein InPrivate-Fenster ist","qxcrNq":"weil dieses Fenster im Inkognitomodus ist","96zC3l":"Dieses Fenster ist privat oder Chronik ist deaktiviert","06CVam":"Schildere kurz das Problem (optional)","dEgA5A":"Abbrechen","cQOi/5":"Kreditkartennummer","fFUXog":"Für mehr Optionen klicken","yz7wBu":"Schließen","mPl5nx":[["name"]," kopieren"],"F5QOVM":"Strg","7LG+7N":"Login löschen","OdTay+":"Login nicht speichern","jJzLu4":"Autom. Speichern auf diesem Gerät aktivieren","MAvRTx":"heylogin für diese Seite aktivieren","9Vnjc9":"Enter","zO1gmR":"Esc","7lpQPT":"Ablaufdatum","7Bj3x9":"Fehlgeschlagen","EB0nRS":["für ",["disabledPageHost"]],"NAPj3s":"Synchronisierung erzwingen","ziAjHi":"Generieren","19BWU3":"Passwort generieren","aAnzIW":["heylogin funktioniert für ",["0"]," nicht?"],"dkq141":"heylogin ist aktiv","U03GX6":"heylogin wird laufend verbesert. Mit deiner Hilfe schaffen wir das beste Login-Erlebnis!","6gkdg6":"heylogin wird an der falschen Stelle angezeigt","jMvyI+":"heylogin ist deaktiviert","XZBV9j":"heylogin wird nicht angezeigt","D1KO61":"heylogin: Du bist ausgeloggt","leDFPX":"heylogin einmalig auf dieser Seite ausblenden","Izy/1n":"Einloggen mit heylogin hat nicht funktioniert","Jq4085":"letzten","3oE2TF":"Login & Speichern","aoJeWE":"Einloggen in","DhwLlb":"Login hinzugefügt","NoL4kU":"Trotzdem einloggen","zUtMod":"Login abgebrochen","8MPwY1":["Login ",["relativeDate"]," erstellt"],"ZZ1E+C":"Login verschoben","Gx/Vss":"Login nicht gespeichert","Ym+sui":"Jetzt einloggen","J9IEfH":"Login gespeichert","71P+9z":"Login aktualisiert","z1owM3":"Login wurde entfernt","aabQDn":"Logins werden nicht gespeichert","m2TB6y":"Logins werden automatisch gespeichert","wckWOP":"Verwalten","rkcRqy":"Plan verwalten","QWdKwH":"Verschieben","00OyIR":"Login verschieben","S8X3Kf":"nächsten","OCApeu":"Keine Logins gefunden","/hpEcX":"Notiz","Fdp03t":"auf","UCQiqt":["auf ",["0"]],"qjzFN0":["auf ",["disabledPageHost"]],"7h/ahr":"auf allen Webseiten","yaFLo0":[["frontendServerHost"]," öffnen"],"qdCXwe":["Öffne <0>",["0"],"</0> im Browser um dich zu verbinden."],"fYyARG":"Öffne heylogin im Browser","+Gd0x/":"In heylogin öffnen","IHjtVj":"Login-Fenster öffnen","Qf8ECA":"Schnellzugriff öffnen","Yp+Hi/":"Einstellungen öffnen","yxTdsJ":"Webseite öffnen","/IX/7x":"Anderes Problem","uP0aE4":"Override-Version:","OMcfn6":"Passwort","8ZsakT":"Passwort","zJx6Vx":"Passwort geändert","PPgwqo":"Passwort nicht geändert","sXULwc":"PIN","3hTaGP":"Plan pausiert","Tpekep":"Stell bitte sicher, dass du Verbindung zum Internet hast.","0MTaJs":"Privater Account","WmGifL":"Wiederholung","SeI3Z8":"Als Standard festlegen","TRo55K":"Speichern in","idD8Ev":"Gespeichert","K/F6pa":"Wird gespeichert…","VObepA":"Screenshot","0FzuA+":[["0"]," Logins durchsuchen"],"ekAm3+":"Alle Logins durchsuchen","v8vJR1":"Deine Logins durchsuchen","3r06QJ":"Sicherheitscode","JlFcis":"Abschicken","PGetcZ":"Shift","kf83Ld":"Etwas ist schief gelaufen.","13X+48":"Fehler gefunden?","KM6m8p":"Team","JzZPb0":"Vielen Dank für deine Meldung.","gOW54d":["Der heylogin-Plan deiner Organisation <0>“",["organizationName"],"”</0> ist pausiert."],"+zHEzW":["Die heylogin-Testphase für <0>„",["organizationName"],"“</0> ist abgelaufen."],"imSNi2":"Die heylogin-Browser-Erweiterung benötigt ein Update. Bitte update die App, um heylogin zu verwenden.<0>heylogin updaten</0>","/jQctM":"In","hYzVzQ":"Bitte erlaube den Zugriff, um die Erweiterung zu aktivieren.","yPCvpC":"heute um","t9zNOe":"morgen","Kvajkr":"TOTP","XMUTjs":"TOTP-Code","6xOPtp":"TOTP-Schlüssel für","HyrObi":"Testphase abgelaufen","KDw4GX":"Erneut versuchen","9uI/rE":"Rückgängig","rtir7c":"unbekannt","1ZAe/6":"unbekannter Ort","VAOn4r":"Entsperren","4QFgr2":"Unbenanntes Login","GpHZ5V":"Änderung rückgängig gemacht","IURrEe":"Jetzt upgraden","vNZ8of":"Neues Login aus dem Posteingang verwenden?","Ha3UBC":"Security Key benutzen","silO9A":"Nutzername","7sNhEz":"Nutzername","i0/HKI":"Nutzername unbekannt","csCoda":"Version:","hdwiS9":"Login anzeigen","xgPaC3":"WLAN-Netzwerk","rQRrkB":"gestern","sGsut8":"Du bist ausgeloggt","Uqbot7":"Du bist nicht verbunden","IL3O8e":"Du hast keine Logins mit TOTP auf dieser Seite.","AlS6pf":"Dein Browser"}`);
const messages = JSON.parse('{"jBI8Lx":[["0","plural",{"other":["Search ","#"," logins"]}]],"ZsmGRL":[["atAbsoluteDate"]],"aHvVg8":[["browserName"]," blocks extensions on this page"],"aLmCR/":[["browserName"]," blocks heylogin on this page"],"uooG+Q":[["hiddenLoginsCount","plural",{"one":["Show ","#"," more login"],"other":["Show ","#"," more logins"]}]],"pgvip9":[["uppercaseName"]," copied!"],"8d6VgQ":["<0>In</0> ",["vaultLabel"]],"RQWed3":"1-click login set up successfully. You can now log in on any website.","PWU3n3":"Add to login","2vJK8B":"Add username","8uQ9hR":"Automatically include screenshot of current website","iH8pgl":"Back","lKI/c0":"because this is an InPrivate window","qxcrNq":"because this window is in incognito mode","96zC3l":"because this window is private or history is disabled","06CVam":"Briefly describe your problem (optional)","dEgA5A":"Cancel","cQOi/5":"card number","fFUXog":"Click for more options","yz7wBu":"Close","mPl5nx":["Copy ",["name"]],"F5QOVM":"Ctrl","7LG+7N":"Delete login","OdTay+":"Do not save login","jJzLu4":"Enable autosave on this device","MAvRTx":"Enable heylogin for this page","9Vnjc9":"Enter","zO1gmR":"Esc","7lpQPT":"expiration","7Bj3x9":"Failed","EB0nRS":["for ",["disabledPageHost"]],"NAPj3s":"Force sync (to fix syncing problems)","ziAjHi":"Generate","19BWU3":"Generate password","aAnzIW":["heylogin does not work for ",["0"],"?"],"dkq141":"heylogin is active","U03GX6":"heylogin is always improving. With your help, we can provide the best login experience!","6gkdg6":"heylogin is at the wrong position","jMvyI+":"heylogin is disabled","XZBV9j":"heylogin is not displayed","D1KO61":"heylogin: You are logged out","leDFPX":"Hide heylogin once on this page","Izy/1n":"I was not logged in","Jq4085":"last","3oE2TF":"Log in & save","aoJeWE":"Log into","DhwLlb":"Login added","NoL4kU":"Login anyways","zUtMod":"Login cancelled","8MPwY1":["Login created ",["relativeDate"]],"ZZ1E+C":"Login moved","Gx/Vss":"Login not saved","Ym+sui":"Login now","J9IEfH":"Login saved","71P+9z":"Login updated","z1owM3":"Login was removed","aabQDn":"Logins are not saved","m2TB6y":"Logins are saved automatically","wckWOP":"Manage","rkcRqy":"Manage plan","QWdKwH":"Move","00OyIR":"Move login","S8X3Kf":"next","OCApeu":"No logins found","/hpEcX":"note","Fdp03t":"on","UCQiqt":["on ",["0"]],"qjzFN0":["on ",["disabledPageHost"]],"7h/ahr":"on all websites","yaFLo0":["Open ",["frontendServerHost"]],"qdCXwe":["Open <0>",["0"],"</0> in the browser to connect."],"fYyARG":"Open heylogin in the browser","+Gd0x/":"Open in heylogin","IHjtVj":"Open login window","Qf8ECA":"Open quick access","Yp+Hi/":"Open settings","yxTdsJ":"Open website","/IX/7x":"Other","uP0aE4":"Override version:","OMcfn6":"password","8ZsakT":"Password","zJx6Vx":"Password changed","PPgwqo":"Password not changed","sXULwc":"PIN","3hTaGP":"Plan paused","Tpekep":"Please make sure you have internet connection.","0MTaJs":"Private Account","WmGifL":"Repeated password","SeI3Z8":"Save as default","TRo55K":"Save to","idD8Ev":"Saved","K/F6pa":"Saving…","VObepA":"screenshot","0FzuA+":["Search ",["0"]," logins"],"ekAm3+":"Search all logins","v8vJR1":"Search your logins","3r06QJ":"security code","JlFcis":"Send","PGetcZ":"Shift","kf83Ld":"Something went wrong.","13X+48":"Spotted a mistake?","KM6m8p":"Team","JzZPb0":"Thank you for your report","gOW54d":["The heylogin plan of your organization <0>“",["organizationName"],"”</0> is paused."],"+zHEzW":["The heylogin trial for <0>“",["organizationName"],"”</0> has expired."],"imSNi2":"The installed heylogin browser extension requires an update. To use heylogin, please update.<0>Update heylogin</0>","/jQctM":"To","hYzVzQ":"To activate the extension, please grant access.","yPCvpC":"today at","t9zNOe":"tomorrow","Kvajkr":"TOTP","XMUTjs":"TOTP code","6xOPtp":"TOTP secret for","HyrObi":"Trial Expired","KDw4GX":"Try again","9uI/rE":"Undo","rtir7c":"unknown","1ZAe/6":"unknown location","VAOn4r":"Unlock","4QFgr2":"Unnamed login","GpHZ5V":"Update reverted","IURrEe":"Upgrade now","vNZ8of":"Use new login from your inbox?","Ha3UBC":"Use security key","silO9A":"username","7sNhEz":"Username","i0/HKI":"Username unknown","csCoda":"Version:","hdwiS9":"View login","xgPaC3":"wifi network","rQRrkB":"yesterday","sGsut8":"You are logged out","Uqbot7":"You are not connected","IL3O8e":"You have no logins with TOTP on this page.","AlS6pf":"Your browser"}');
function initUiLocale() {
  const uiLocale = browser.i18n.getUILanguage();
  y$3({
    en: messages,
    de: messages$1
  }, uiLocale);
}
var _dec, _class;
let DebugMode = (_dec = Emittery$2.mixin("emitter"), _dec(_class = class DebugMode2 {
  constructor() {
    __publicField(this, "debugFlag", false);
    __publicField(this, "localDebugOverrideFlag");
    __publicField(this, "handleStorageChanged", (changes, areaName) => {
      if (areaName !== "local" || changes.debug === void 0) {
        return;
      }
      this.internalUpdateDebugFlag(changes.debug.newValue);
    });
  }
  async init() {
    browser.storage.onChanged.addListener(this.handleStorageChanged);
    const {
      debug: storageDebugFlag
    } = await browser.storage.local.get("debug");
    this.internalUpdateDebugFlag(storageDebugFlag);
  }
  get debug() {
    return this.localDebugOverrideFlag ?? this.debugFlag;
  }
  set debug(newDebug) {
    this.internalUpdateDebugFlag(newDebug);
    browser.storage.local.set({
      debug: this.debugFlag
    }).catch(trackError);
  }
  get localDebugOverride() {
    return this.localDebugOverrideFlag;
  }
  set localDebugOverride(newOverride) {
    this.withEvents(() => {
      this.localDebugOverrideFlag = newOverride;
    });
  }
  internalUpdateDebugFlag(newDebugFlag) {
    this.withEvents(() => {
      this.debugFlag = newDebugFlag;
    });
  }
  withEvents(cb2) {
    const oldDebug = this.debug;
    cb2();
    if (oldDebug !== this.debug) {
      debugConsole.showDebugMessages = this.debug;
      this.emitter.emit("change", {
        debug: this.debug
      }).catch(trackError);
    }
  }
}) || _class);
const debugMode = new DebugMode();
debugMode.init().catch(trackError);
function ExtDebugVisibleContextProvider({
  children
}) {
  const [debugVisible, setDebugVisible] = reactExports.useState(debugMode.debug);
  reactExports.useEffect(() => {
    const handleDebugChange = ({
      debug
    }) => setDebugVisible(debug);
    debugMode.on("change", handleDebugChange);
    return () => debugMode.off("change", handleDebugChange);
  }, []);
  const onDebugTriggered = reactExports.useCallback(() => {
    debugMode.debug = !debugMode.debug;
  }, []);
  gh(onDebugTriggered);
  return /* @__PURE__ */ jsx(dh, { value: debugVisible, children });
}
export {
  $h as $,
  deepEqual$1 as A,
  Th as B,
  Fc as C,
  D$1 as D,
  ExtDebugVisibleContextProvider as E,
  F$1 as F,
  AUTOSNATCH_OVERLAY_SHADOW_WIDTH_PX as G,
  i_ as H,
  Ih as I,
  g$3 as J,
  Ko as K,
  L,
  Ge as M,
  at as N,
  O,
  Ht as P,
  Si as Q,
  React$1 as R,
  Sh as S,
  Trans as T,
  Formik as U,
  vh as V,
  f$3 as W,
  a$1 as X,
  useCombobox as Y,
  Z,
  _h as _,
  jsxs as a,
  getLoginDisplayLabel as a0,
  Fragment as a1,
  assertExhaustive as a2,
  newUuid$1 as a3,
  WebpageOverrideStatus as a4,
  $t as a5,
  sleep as a6,
  yo as a7,
  qt as a8,
  dn as a9,
  Ki as aa,
  sp as ab,
  Li as ac,
  Da as ad,
  ch as ae,
  ja as af,
  Ri as ag,
  nn as ah,
  d$2 as ai,
  HEYLOGIN_VERSION as aj,
  debugMode as ak,
  jsonParseThaw as al,
  Bowser as am,
  m$2 as an,
  Ah as ao,
  ct as ap,
  qa as aq,
  wh as ar,
  J as as,
  Ni as at,
  I$1 as au,
  psl as av,
  getRelatedDomains as aw,
  ReactDOM as b,
  classNames as c,
  he as d,
  getFrontendServerUrl as e,
  useLingui as f,
  getValueWithPlaceholder as g,
  ho as h,
  i18n as i,
  jsx as j,
  LoginUiType as k,
  calculateTotp as l,
  mh as m,
  DEFAULT_TOTP_PERIOD as n,
  DEFAULT_TOTP_DIGITS as o,
  DEFAULT_TOTP_ALGORITHM as p,
  getFrontendServerHost as q,
  reactExports as r,
  be as s,
  initSentry as t,
  up as u,
  initUiLocale as v,
  I18nProvider as w,
  lh as x,
  yh as y,
  zn as z
};
//# sourceMappingURL=ExtDebugVisibleContext-6460380f.js.map
