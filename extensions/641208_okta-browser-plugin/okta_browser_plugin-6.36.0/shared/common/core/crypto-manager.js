Okta.CryptoManager=function(e){const s=Okta.Q;var r=Okta._okta;const o=r.map,t=r.reduce,a=Okta.fn.other.string.toUint8Array,n=Okta.fn.other.string.base64UrlDecode,i=Okta.fn.other.string.stringToBase64Url,u=Okta.fn.other.string.arrayBufferToBase64Url,p=Okta.fn.other.string.arrayBufferToBase64,c=Okta.fn.other.string.base64UrlToArrayBuffer,y=Okta.fn.base.guid;let g=null,f=null;const l={},d="ABCDEFGHJKLMNPQRSTUVWXYZ23456789";g=e.crypto||e.msCrypto||{},f=g.subtle||g.webkitSubtle;const m={exportedFormat:"jwk",algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usage:["verify"],isExtractable:!0};function h(){const e={supported:!0};g&&f?f.importKey?f.verify||(e.message="browser does not support crypto.subtle.verify",e.supported=!1):(e.message="browser does not support crypto.subtle.importKey",e.supported=!1):(e.message="browser does not natively support subtle crypto",e.supported=!1);var r="Crypto::isSubtleCryptoSupported: ";return e.supported?Log.info(r+"browser supports subtle crypto and the required functions"):Log.warn(r+e.message),e}function v(e){e=String.fromCharCode.apply(null,new Uint8Array(e));return i(e)}function b(e,r){const t=s.defer();let o="";function n(e,r){o="Error validating signature: "+e,Log.error("Crypto::validatePublicKey: "+o),r.resolve({valid:!1,message:o})}try{f.verify(m.algorithm,e,r.signature,r.content).then(function(e){o="signature is ",e?(o+="valid",Log.info("Crypto::validatePublicKey: "+o)):(o+="not valid",Log.warn("Crypto::validatePublicKey: "+o)),t.resolve({valid:!!e,message:o})}).catch(function(e){n(e,t)})}catch(e){n(e,t)}return t.promise}return l.verifyAuthIdToken=function(o,e){return o&&e?(delete e.use,l.importKey(e,m).then(function(e){if(!e){var r="failed to import public key";return Log.error("Crypto::verifyAuthIdToken: "+r),s({valid:!1,message:r})}var t=o.split("."),r=a(t[0]+"."+t[1]),t=n(t[2]);return b(e,{signature:a(t),content:r})})):s({valid:!1,message:"no idToken or key"})},l.isSubtleCryptoSupportedForAuth=function(){const e=h();if(!e.supported)return!1;f.digest?g.getRandomValues||(e.message="browser does not support crypto.getRandomValues",e.supported=!1):(e.message="browser does not support crypto.subtle.digest",e.supported=!1);var r="Crypto::isSubtleCryptoSupported: ";return e.supported?Log.info(r+"browser supports extra crypto for Okta auth"):Log.warn(r+e.message),e.supported},l.isSubtleCryptoSupportedForCSE=function(){var e="Crypto::isSubtleCryptoSupportedForCSE: ";return!!h()&&(f.encrypt?f.decrypt?f.generateKey?f.exportKey?!!f.deriveKey||(Log.warn(e+"browser does not support crypto.subtle.deriveKey"),!1):(Log.warn(e+"browser does not support crypto.subtle.exportKey"),!1):(Log.warn(e+"browser does not support crypto.subtle.generateKey"),!1):(Log.warn(e+"browser does not support crypto.subtle.decrypt"),!1):(Log.warn(e+"browser does not support crypto.subtle.encrypt"),!1))},l.computeChallenge=function(e){e=a(e);return f.digest("SHA-256",e).then(v)},l.generateRandomString=function(e){var r=new Uint8Array(Math.ceil(e/2)),r=g.getRandomValues(r);const t=o(r,function(e){return("0"+e.toString(16)).substr(-2)}).join("");return t.slice(0,e)},l.encrypt=function(e,r,t,o){r=(new TextEncoder).encode(r);return l.encryptArrayBuffer(e,r,t,o)},l.encryptArrayBuffer=function(e,r,t,o){const n=s.defer();return Log.info("Crypto::encrypt: starting encryption with options: "+JSON.stringify(t)),f.encrypt(t.algorithm,e,r).then(function(e){Log.info("Crypto::encrypt: plaintext encrypted successfully!");e=new Uint8Array(e);o?n.resolve(p(e)):n.resolve(u(e))}).catch(function(e){Log.error("Crypto::encrypt: "+e),n.reject(e)}),n.promise},l.decrypt=function(e,r,t){const o=s.defer();return l.decryptArrayBuffer(e,r,t).then(function(e){o.resolve((new TextDecoder).decode(e))}).catch(function(e){o.reject(e)}),o.promise},l.decryptArrayBuffer=function(e,r,t){const o=s.defer();Log.info("Crypto::decrypt: starting decryption with options: "+JSON.stringify(t));r=c(r);return f.decrypt(t.algorithm,e,r).then(function(e){Log.info("Crypto::decrypt: ciphertext decrypted successfully!"),o.resolve(e)}).catch(function(e){Log.error("Crypto::decrypt: "+e),o.reject(e)}),o.promise},l.generateKey=function(e){const r=s.defer();return Log.info("Crypto::generateKey: starting key generation with options: "+JSON.stringify(e)),f.generateKey(e.algorithm,e.isExtractable,e.usage).then(function(e){Log.info("Crypto::generateKey: key(s) generated successfully!"),r.resolve(e)}).catch(function(e){Log.error("Crypto::generateKey: "+e),r.reject(e)}),r.promise},l.importKey=function(e,r){function t(e,r){Log.warn("Crypto::importKey: Error importing key: "+e),r.resolve(null)}const o=s.defer();Log.info("Crypto::importKey: starting key import..");try{f.importKey(r.exportedFormat,e,r.algorithm,r.isExtractable,r.usage).then(function(e){Log.info("Crypto::importKey: key imported successfully"),o.resolve(e)}).catch(function(e){t(e,o)})}catch(e){t(e,o)}return o.promise},l.exportKey=function(e,r){const t=s.defer();return Log.info("Crypto::exportKey: exporting key to "+r),f.exportKey(r,e).then(function(e){Log.info("Crypto::exportKey: key exported successfully!"),t.resolve(e)}).catch(function(e){Log.error("Crypto::exportKey: "+e),t.reject(e)}),t.promise},l.deriveKey=function(e,r,t){function o(e,r){Log.error(n+" Error deriving key: "+e),r.reject(e)}const n="Crypto::deriveKey: ",i=s.defer();Log.info(n+"starting key derivation");try{f.deriveKey({name:t.algorithm.name,salt:a(r),iterations:t.algorithm.iterations,hash:t.algorithm.hash},e,{name:t.derivedKeyAlgorithm.name,length:t.derivedKeyAlgorithm.length},!0,t.derivedKeyAlgorithm.usage).then(function(e){Log.info(n+"key derived successfully!"),i.resolve(e)}).catch(function(e){o(e,i)})}catch(e){o(e,i)}return i.promise},l.createSecretKey=function(){var e=new Uint8Array(24),e=g.getRandomValues(e);return t(e,function(e,r){return e+d[r%d.length]},"")},l.createRandomSalt=function(){var e=new Uint8Array(32),e=g.getRandomValues(e);return window.btoa(String.fromCharCode.apply(null,e))},l.generateIV=function(){return g.getRandomValues(new Uint8Array(16))},l.generateVaultID=function(){return y()},l.createRandomSymKey=function(){return f.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"])},l};