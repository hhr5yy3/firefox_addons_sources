{"version":3,"file":"background-4101888f.js","sources":["../../src/background/backgroundFetch.ts","../../src/ui/utils/api/api.collect.ts","../../src/background/utils/normalizers.ts","../../src/background/receivers/index.ts","../../src/background/shopScrapperConf.ts","../../src/background/tabManager.ts","../../src/background/extensionManager.ts","../../src/background/index.ts"],"sourcesContent":["import { Fetcher } from '../ui/utils/api';\nimport { HTTPMethod, makeRequest } from './utils/request';\n\nexport const backgroundFetcher: Fetcher = async (i, o, sender) => {\n    const x = await makeRequest({\n        endpoint: i.toString(),\n        body: o?.body,\n        method: (o?.method as HTTPMethod) || 'GET',\n        sender,\n    });\n    return { json: () => Promise.resolve(x), ok: true } as Response;\n};\n","import { PayloadAction } from '@reduxjs/toolkit';\nimport { APIHandler } from '.';\nimport { backgroundFetcher } from '../../../background/backgroundFetch';\nimport browser from '../../../background/browser/browser';\nimport logger from '../../../background/utils/logger';\nimport { ObservableAPIStore } from './api.util';\nimport { MessageSender, TabInfo } from '~B/browser/browser.types';\n\ntype APIMessageData = void | { [k: string]: APIMessageData } | APIMessageData[];\ntype APIContext = { sender: MessageSender };\ntype APIAction<T extends APIMessageData = { [k: string]: APIMessageData }> =\n    | { type: string; payload: T }\n    | { type: string; error: unknown; payload?: undefined };\n\nconst apiCache: {\n    [k: string]: <TIn extends APIMessageData, TOut extends APIMessageData>(\n        this: APIContext,\n        message: TIn,\n    ) => Promise<APIAction<TOut>>;\n} = {};\n\nbrowser.runtime.onMessage.addListener(function (message: APIAction, sender) {\n    const apiMethod = apiCache[message.type];\n    if (!apiMethod) return false;\n\n    const context: APIContext = {\n        sender,\n    };\n\n    message?.payload !== undefined && logger.log('hola');\n\n    return apiMethod.call(context, message.payload);\n});\n\nconst processedAPIs: { [k: string]: any } = [];\n\nfunction createAPIReceiver<Methods, TResource>(api: APIHandler<Methods, TResource>) {\n    if (api.name in processedAPIs) {\n        logger.warn('API: ', api.name, 'registered twice');\n        return;\n    }\n    processedAPIs[api.name] = api;\n    api.init(backgroundFetcher);\n    const obAPI = ObservableAPIStore.get(api, false);\n    const cacheTimeDelta = 30 * 60 * 1000; // 10 minutes\n    let lastReadTimeStamp = 0;\n    let cachedResult: any = null;\n    for (const key in api.actions.q) {\n        const questionType = (api.actions.q as any)[key];\n        const answerType = (api.actions.a as any)[key];\n        const [apiId, action] = questionType.split('.');\n        const method: ((data: any) => Promise<any>) | undefined = obAPI[action];\n        if (action != 'read') {\n            if (method) {\n                const apiMethod = createMethodHandler(method, answerType);\n                apiCache[questionType] = async function (this: APIContext, data: any) {\n                    logger.debug(`api.collect[${api.name}.${action}]: `, data);\n                    api.setContext((ctx) => this);\n                    lastReadTimeStamp = 0;\n                    return apiMethod(data);\n                };\n            } else {\n                const errorMessage = `NO_API_${action.toUpperCase()}`;\n                logger.error('api.collect', errorMessage);\n                apiCache[questionType] = async function () {\n                    return Promise.resolve({\n                        type: answerType,\n                        error: new Error(errorMessage),\n                    });\n                };\n            }\n        } else {\n            const read = createMethodHandler<void, any>(\n                async () => {\n                    logger.debug(`api.collect[${api.name}.${action}]`);\n                    // Update on a regular on a max time delta basis\n                    if (lastReadTimeStamp + cacheTimeDelta < Date.now()) {\n                        const data = (await obAPI.readForce()) as any;\n                        logger.debug(`api.collect[${api.name}.${action}]: cache updated`, {\n                            data,\n                        });\n                        // sync code\n                        logger.debug(`api.collect[${api.name}.${action}]: triggering sync`);\n                        syncHandler({\n                            type: api.actions.syncId,\n                            payload: data,\n                        });\n                        // end sync code\n                        return data;\n                    }\n                    return obAPI.read();\n                },\n\n                answerType,\n            );\n            apiCache[questionType] = async function (this: APIContext) {\n                const result = await read();\n                if (result.payload !== undefined) {\n                    lastReadTimeStamp = Date.now();\n                }\n                return result;\n            };\n        }\n    }\n}\n\nfunction createMethodHandler<TIn extends APIMessageData, TOut extends APIMessageData>(\n    apiMethod: (data: TIn) => Promise<TOut>,\n    answerType: string,\n    sender?: TabInfo,\n): (data: TIn) => Promise<APIAction<TOut>> {\n    return async (data: TIn) => {\n        try {\n            try {\n                const result = await apiMethod(data);\n                return {\n                    type: answerType,\n                    payload: result,\n                };\n            } catch (e) {\n                return {\n                    type: answerType,\n                    error: e,\n                };\n            }\n        } catch (e) {\n            return Promise.resolve({\n                type: answerType,\n                error: e,\n            });\n        }\n    };\n}\n\nconst modules = import.meta.glob('~F/**/*.api.ts', { eager: true });\n\nconst apiRegistrationErrors: string[] = [];\nfor (const filename of Object.keys(modules)) {\n    logger.log(filename, 'moduleFile');\n    const apiHandler = modules[filename];\n\n    const moduleKeys = Object.keys(apiHandler);\n    logger.log('module result on collecting', apiHandler);\n\n    if (moduleKeys.length === 1) {\n        const moduleKey = moduleKeys[0];\n        createAPIReceiver(apiHandler[moduleKey]);\n    }\n\n    /*  try {\n            \n        } catch (e: any) {\n           \n        } */\n}\n\nif (apiRegistrationErrors.length > 0) {\n    throw new Error(\n        `INVALID_API_HANDLERS: ${apiRegistrationErrors.reduce(\n            (acc, curr) => `${acc}\\n${curr}`,\n            '',\n        )}`,\n    );\n}\n\nlet syncHandler: (data: PayloadAction<any>) => void = () => {};\n\nexport function registerSyncHandler(handler: (message: PayloadAction) => void) {\n    syncHandler = typeof handler === 'function' ? handler : syncHandler;\n}\n","import { MessageSender } from '~B/browser/browser';\nimport { IProductInfo } from '~F/product-stats/redux';\n\nexport function normalizeStr(str: string | null) {\n    return (str === null ? null : str.normalize('NFKC')) as string;\n}\n\nexport function normalizeProductInfo(sender: MessageSender, product: IProductInfo) {\n    product.id = (product.id === null ? null : `${product.id}`) as string;\n    product.price = normalizeDecimals(product.price);\n    product.shippingPrice = normalizeDecimals(product.shippingPrice);\n    product.title = normalizeStr(product.title);\n    product.imageUrl = product.imageUrl && normalizeUrl(sender, product.imageUrl);\n    return product;\n}\n\nexport function normalizeDecimals(decimalPrice: number | null) {\n    return decimalPrice === null ? null : parseFloat(parseFloat(`${decimalPrice}`).toFixed(2));\n}\n\nfunction normalizeUrl(sender: MessageSender, imageUrl: string) {\n    if (!sender) return imageUrl;\n    const shopUrl = new URL(imageUrl, sender.origin);\n    return shopUrl.href;\n}\nexport function normalizeWord(quantity: number, sWord: string, pWord: string) {\n    return quantity > 0 ? pWord : sWord;\n}\n","/* \nManages all messages that  get to the backgraund.\n@module src/background/receivers\n*/\n\nimport { normalizeDecimals, normalizeProductInfo } from '~B/utils/normalizers';\nimport {\n    answerSimpleLogin,\n    CREATE_TAB,\n    fetchProductStatsResult,\n    IProductStatsData,\n    LOGOUT,\n    Q_SIMPLE_LOGIN,\n    releasedOffert,\n    RELOAD_EXTENSION,\n    SCRAPPED_DATA,\n    startUIApp,\n} from '~F/app/redux/app/background-link.saga';\nimport { IOffer } from '~F/pepper-posts/redux/offer';\nimport { IPriceHistoryPoint, IProductInfo } from '~F/product-stats/redux';\nimport { M_ANALYTICS } from '../../ui/features/app/redux/analytics/analytics.saga';\nimport browser, { MessageSender } from '../browser/browser';\nimport { LoginCredentials, LoginPayload, UserData } from '../storage';\nimport { ExtensionScrappingWorkingMode, ScrappedData, ShopScrappingDetails } from '../types';\nimport analytics from '../utils/analytics';\nimport { isAuthorizationExpired, isAuthorizationRefreshable } from '../utils/auth';\nimport { errorCapture } from '../utils/errorCapture';\nimport logger from '../utils/logger';\nimport { receiveMessage, receiveMessages } from '../utils/messageEngine';\nimport { checkAuthRequest, makeRequest } from '../utils/request';\n\nimport { privatePolicyData } from '~B/storage/storage.repo';\nimport { setIsShopMatch, startAppLoading } from '~F/app/redux/app';\n\nreceiveMessage(Q_SIMPLE_LOGIN, async (sender, loginData?: LoginCredentials) => {\n    if (!loginData) {\n        return getAnswerSimpleLoginData();\n    }\n    try {\n        const authUser: LoginPayload = await checkAuthRequest('auth', loginData);\n        await UserData.set({\n            ...loginData,\n            ...authUser,\n        });\n\n        return answerSimpleLogin({\n            loggedIn: true,\n            username: authUser.username,\n            email: authUser.email,\n            avatarUrl: authUser.avatarUrl,\n        });\n    } catch (e: any) {\n        errorCapture(e);\n        logger.error('Cannot log in', e);\n        return answerSimpleLogin({\n            loggedIn: false,\n            username: '',\n            email: '',\n            avatarUrl: '',\n        });\n    }\n});\n\nreceiveMessage(LOGOUT, async (sender) => {\n    logger.log('bg user logout');\n    UserData.clear();\n});\n\nreceiveMessage(M_ANALYTICS, async (sender, event) => {\n    switch (event.method) {\n        case 'screenView':\n        case 'pageView':\n            event.data['tabId'] = sender.tab.id;\n    }\n\n    (analytics as any)[event.method](event.data);\n});\n\nreceiveMessages(\n    SCRAPPED_DATA,\n    async function* (\n        sender,\n        {\n            data: scrappedProduct,\n            url,\n            config,\n        }: { data: ScrappedData; url: string; config: ShopScrappingDetails },\n    ) {\n        let product = scrappedProduct as unknown as IProductInfo;\n        logger.debug('Scrapped product:', product);\n        // checking if we get the famous product id to start ui loading\n        //? this check is perfect for trying to bring the extension to pages out of product detail.\n        if (config?.workingMode === ExtensionScrappingWorkingMode.onlyId && !product?.id) {\n            yield setIsShopMatch(false);\n            return;\n        }\n        yield setIsShopMatch(true);\n        yield startAppLoading(true);\n        try {\n            product = normalizeProductInfo(sender, product);\n            logger.debug('Normalized product:', product);\n        } catch (error: any) {\n            logger.error('Normalization error', { error });\n        }\n\n        // if (product && product.id && product.shop) {\n        //? endpoint currently not avaliable in the api\n        // si no está el producto vuelvo a consultar la api pq el scrapper no ha funcionado como se espera0ría\n\n        logger.log('Analysis error short circuit -> Run App');\n\n        try {\n            if (!product?.url) {\n                product.url = url;\n            }\n\n            const { data: statsData } = (await makeRequest({\n                endpoint: `product`,\n                body: product,\n                method: 'POST',\n                sender,\n            })) as {\n                data: {\n                    stats: IProductInfo;\n                    priceHistory: IPriceHistoryPoint[];\n                };\n            };\n            const productStats = statsData?.stats;\n            const payload: IProductStatsData = {\n                shop: productStats?.shop || null,\n\n                product: productStats && normalizeProductInfo(sender, productStats),\n                priceHistory:\n                    (statsData.priceHistory &&\n                        statsData.priceHistory.map((elm) => {\n                            elm.price = normalizeDecimals(elm.price) as number;\n                            return elm;\n                        })) ||\n                    [],\n            };\n\n            yield getAnswerSimpleLoginData();\n            yield fetchProductStatsResult(payload);\n            yield startAppLoading(false);\n\n            const {\n                data: { postedOffer },\n            } = await makeRequest<{ data: { postedOffer: IOffer } }>({\n                endpoint: 'pepper/posted-offer',\n                body: product,\n                method: 'POST',\n                sender,\n            });\n            return releasedOffert(postedOffer);\n        } catch (e) {\n            logger.error(`${SCRAPPED_DATA} error`, e as any);\n            errorCapture(e);\n        }\n        // }\n    },\n);\n\nreceiveMessage(RELOAD_EXTENSION, (async (sender: MessageSender) => {\n    logger.log('RELOADING EXTENSION');\n\n    browser.runtime.reload?.();\n}) as any);\n/* \nLogin function that authorizes permission based on local storage credentials\nregarding token expiration. \n*/\nasync function getAnswerSimpleLoginData() {\n    const userData = await UserData.get();\n    if (!userData) {\n        return answerSimpleLogin({\n            loggedIn: false,\n            username: '',\n            email: '',\n            avatarUrl: '',\n        });\n    }\n\n    if (!(await isAuthorizationExpired())) {\n        return answerSimpleLogin({\n            loggedIn: true,\n            username: userData.username,\n            email: userData.email,\n            avatarUrl: userData.avatarUrl,\n        });\n    }\n\n    try {\n        if (await isAuthorizationRefreshable()) {\n            await checkAuthRequest('refresh', userData);\n\n            return answerSimpleLogin({\n                loggedIn: true,\n                username: userData.username,\n                email: userData.email,\n                avatarUrl: userData.avatarUrl,\n            });\n        }\n        const auth = await checkAuthRequest('auth', userData);\n        const newUserData = {\n            ...userData,\n            ...auth,\n        };\n        UserData.set(newUserData);\n        //\n        return answerSimpleLogin({\n            loggedIn: true,\n            username: newUserData.username,\n            avatarUrl: newUserData.avatarUrl,\n            email: newUserData.email,\n        });\n    } catch (e) {\n        errorCapture(e);\n        return answerSimpleLogin({\n            loggedIn: false,\n            username: '',\n            email: '',\n            avatarUrl: '',\n        });\n    }\n}\n\nreceiveMessage(CREATE_TAB, async (sender, tabName) => {\n    logger.log('create tab');\n\n    browser.tabs.create({ url: tabName }).then((tab) => {\n        logger.log('pptab', { tab });\n        privatePolicyData.set({ ppId: tab.id, isPolicyAuth: false });\n    });\n});\n","import browser from './browser/browser';\nimport { DataRepository } from './storage/storage.api';\nimport { ExtensionScrappingWorkingMode, ShopDetailMatcher, ShopScrappingDetails } from './types';\nimport logger from './utils/logger';\n\nexport namespace ShopScrapperConf {\n    //* interface\n    const scrpaConfStorage = new DataRepository<{\n        scrapConfigs: ShopScrappingDetails[];\n    }>('scrapConfigs');\n    export async function set(scrapConfigs: ShopScrappingDetails[]): Promise<void> {\n        await scrpaConfStorage.set({ scrapConfigs });\n    }\n\n    export async function get(): Promise<ShopDetailMatcher[]> {\n        const { scrapConfigs } = await scrpaConfStorage.get();\n        scList = (await discardDisabled([...scrapConfigs])).map((x) => ({\n            ...x,\n            matcher: new RegExp(x.urlMatch),\n        }));\n        return mergeConfigs(scList);\n    }\n\n    //* internal\n    let scList: ShopDetailMatcher[] = [];\n    async function discardDisabled(\n        scrapConfigs: ShopScrappingDetails[],\n    ): Promise<ShopScrappingDetails[]> {\n        if (\n            import.meta.env.VITE_NODE_ENV === 'production' &&\n            import.meta.env.VITE_INCLUDE_UTILS !== '1'\n        ) {\n            scrapConfigs = scrapConfigs.filter(\n                (x) => x.workingMode !== ExtensionScrappingWorkingMode.disabled,\n            );\n        }\n        return scrapConfigs;\n    }\n\n    async function mergeConfigs(\n        shopDetailMatchers: ShopDetailMatcher[],\n    ): Promise<ShopDetailMatcher[]> {\n        if (\n            import.meta.env.VITE_NODE_ENV !== 'production' ||\n            import.meta.env.VITE_INCLUDE_UTILS === '1'\n        ) {\n            let { localExtConf } = (await browser.storage.local.get({\n                localExtConf: [],\n            })) as {\n                localExtConf: ShopScrappingDetails[];\n            };\n            // Recreating regex matching due to lack of regex serialization\n            const localMatchers = (localExtConf || []).map((elm) => {\n                return {\n                    ...elm,\n                    matcher: new RegExp(elm.urlMatch),\n                };\n            });\n            logger.log('localExtConf inspection', localMatchers);\n            return [...localMatchers, ...shopDetailMatchers].reduce<ShopDetailMatcher[]>(\n                (acc, current) =>\n                    !acc.find((item) => item.id === current.id) ? [...acc, current] : acc,\n                [],\n            );\n        }\n\n        return shopDetailMatchers;\n    }\n}\n","import { PayloadAction } from '@reduxjs/toolkit';\nimport Browser from 'webextension-polyfill';\nimport browser from './browser/browser';\nimport { ExtensionScrappingWorkingMode, ShopDetailMatcher, ShopScrappingDetails } from './types';\nimport logger from './utils/logger';\nimport { shouldLoadUI } from '~F/app/redux/app/background-link.saga';\n\nexport type TabMatcher = {\n    matcher: RegExp;\n};\n\nexport type TabMatch = {\n    config: ShopDetailMatcher;\n    tabInfo: Browser.Tabs.Tab;\n    isProductPage: boolean;\n};\n\nexport interface ITabManager {\n    readonly tabs: Readonly<{\n        [k: number]: Readonly<TabMatch>;\n    }>;\n\n    broadcast<TM, TR>(message: PayloadAction<TM>): Promise<(PayloadAction<TR> | undefined)[]>;\n}\n\nexport class TabManager<TConfig extends ShopDetailMatcher> implements ITabManager {\n    private onTabMatched: (tabMatch: TabMatch) => void;\n    private getConfig: () => Promise<TConfig[]>;\n    private _tabs: {\n        [k: number]: TabMatch;\n    } = {};\n\n    get tabs() {\n        return this._tabs;\n    }\n\n    constructor({\n        getConfig,\n        onTabMatched,\n    }: {\n        getConfig: () => Promise<TConfig[]>;\n        onTabMatched: (tabMatch: TabMatch) => void;\n    }) {\n        this.getConfig = getConfig;\n        this.onTabMatched = onTabMatched;\n        this.onTabRemoved = this.onTabRemoved.bind(this);\n        this.onTabUpdated = this.onTabUpdated.bind(this);\n    }\n    broadcast<TM, TR>(\n        message: {\n            payload: TM;\n            type: string;\n        },\n        predicate?: (tab: TabMatch) => boolean,\n    ): Promise<({ payload: TR; type: string } | undefined)[]> {\n        const targets = predicate\n            ? Object.values(this._tabs).filter((tab) => predicate(tab))\n            : Object.values(this._tabs);\n\n        logger.log(`broadcast to [${targets.map((x) => x.tabInfo.id)}]:`, message);\n\n        return Promise.all(\n            targets.map((tab) =>\n                browser.tabs.sendMessage(tab.tabInfo.id, message).catch((e) => {\n                    logger.warn('broadcast error', e);\n                    throw e;\n                }),\n            ),\n        );\n    }\n\n    start() {\n        browser.tabs.onUpdated.addListener(this.onTabUpdated);\n\n        browser.tabs.onRemoved.addListener(this.onTabRemoved);\n    }\n\n    stop() {\n        browser.tabs.onUpdated.removeListener(this.onTabUpdated);\n        browser.tabs.onRemoved.removeListener(this.onTabRemoved);\n    }\n\n    private async onTabRemoved(tabId: number) {\n        const tabData = this._tabs[tabId];\n        if (tabData) {\n            delete this._tabs[tabId];\n            logger.debug('Current tabs:', this._tabs);\n        }\n    }\n\n    private async processTab(tabInfo: Browser.Tabs.Tab) {\n        logger.log('tab reloaded, looking for matchs');\n        let configList = await this.getConfig();\n\n        logger.debug('view configList', configList);\n        const shopUrl = new URL(tabInfo.url as string);\n\n        const ProductDetailPageConf = configList.find((v) => v.matcher.exec(tabInfo.url as string));\n\n        if (!!ProductDetailPageConf && shouldLoadUI(ProductDetailPageConf)) {\n            logger.debug('Match:', { config: ProductDetailPageConf, tabId: tabInfo.id });\n            logger.debug('workingMode', { workingMode: ProductDetailPageConf.workingMode });\n            this._tabs[tabInfo.id || -1] = { tabInfo, config: ProductDetailPageConf };\n            this.onTabMatched({\n                config: ProductDetailPageConf,\n                tabInfo,\n                isProductPage: true,\n            });\n            return;\n        }\n\n        //this.onTabMatched({ config: shopUrlConf, tabInfo, isProductPage: false });\n    }\n\n    /**\n     * Should be executed when tab refreshes or changes\n     */\n    private onTabUpdated(\n        tabId: number,\n        changeInfo: Browser.Tabs.OnUpdatedChangeInfoType,\n        tabInfo: Browser.Tabs.Tab,\n    ) {\n        if (!changeInfo || !changeInfo) {\n            return;\n        }\n\n        const currentTab = this._tabs[tabId];\n\n        logger.debug(`tab updated:`, {\n            id: tabId,\n            change: changeInfo,\n            tab: tabInfo,\n        });\n\n        if (currentTab && tabInfo.url !== currentTab.tabInfo.url) {\n            delete this._tabs[tabId];\n        }\n\n        logger.debug('Current tabs:', this._tabs);\n\n        if (changeInfo.status === 'complete') {\n            this.processTab(tabInfo);\n        }\n    }\n}\n","import { scrapConfigMatch } from '~F/app/redux/app/background-link.saga';\nimport { IPriceTrackNotification } from '~F/price-track/api';\nimport { registerSyncHandler } from '../ui/utils/api/api.collect';\nimport browser from './browser/browser';\nimport './receivers';\nimport { ShopScrapperConf } from './shopScrapperConf';\nimport { TabManager, TabMatch } from './tabManager';\nimport { ExtensionConfig, SerpShops, ShopDetailMatcher } from './types';\nimport { DataRepository } from './storage/storage.api';\n\nimport analytics from './utils/analytics';\nimport { userIsLoggedIn } from './utils/auth';\nimport { errorCapture } from './utils/errorCapture';\nimport logger from './utils/logger';\nimport { sendMessage } from './utils/messageEngine';\nimport { makeRequest } from './utils/request';\n\nimport { setIsProductPage, setIsShopMatch, startAppLoading } from '~F/app/redux/app';\n\nimport { serpShopsData } from './storage';\n\n/**\n * Handles extension lifecycle.\n * @namespace ExtensionManager\n */\nexport namespace ExtensionManager {\n    type tabMatchConf = {\n        tabMatchConf: { config: ShopDetailMatcher; id: number; isProductPage: boolean };\n    };\n    const tabMatchStorage = new DataRepository<tabMatchConf>('tabMatchConf', {} as tabMatchConf);\n    /**\n     * Class used to create a singleton object used to manage extension state */\n    class ExtensionManager {\n        private _tabManager = new TabManager({\n            getConfig: ShopScrapperConf.get,\n            onTabMatched: this.onTabMatched,\n        });\n\n        public get tabManager(): Readonly<TabManager> {\n            return this._tabManager;\n        }\n        /**\n         * Register main extension lifecicle hooks & start up the extension.\n         */\n        constructor() {\n            const baseurl = import.meta.env.VITE_ENDPOINT;\n\n            logger.debug(`baseurl: ${baseurl}`);\n            browser.alarms.onAlarm.addListener((alarm) => {\n                logger.debug('alarm', { alarm });\n                switch (alarm.name) {\n                    case 'mainLoop':\n                        this.refreshData();\n                        break;\n                    case 'scrapConfigMatch':\n                        tabMatchStorage\n                            .get()\n                            .then(({ tabMatchConf: { id, config, isProductPage } }) => {\n                                // bring products and all the things here\n                                // app data wuld start here\n\n                                if (isProductPage) {\n                                    sendMessage(id, scrapConfigMatch(config));\n                                    //sendMessage(id, setIsProductPage(isProductPage));\n                                }\n                            });\n                }\n            });\n            this.onTabMatched = this.onTabMatched.bind(this);\n            this.onExtensionLoad = this.onExtensionLoad.bind(this);\n            this.refreshData = this.refreshData.bind(this);\n\n            this._tabManager.start();\n\n            registerSyncHandler((message) => this._tabManager.broadcast(message));\n\n            browser.runtime.setUninstallURL('https://chollo.to/uninstall').then(() => {\n                logger.log('Uninstall URL');\n            });\n\n            this.onExtensionLoad();\n\n            this.refreshData();\n            browser.alarms.create('mainLoop', {\n                periodInMinutes: 30,\n            });\n        }\n        /**\n         * Check if url tab matched extension conf. If so it shows the extension.\n         * @param tabMatch\n         */\n        protected async onTabMatched({ config, tabInfo, isProductPage }: TabMatch) {\n            analytics.productView({\n                url: tabInfo?.url?.split('?')[0] as string,\n                tabId: tabInfo.id as number,\n            });\n\n            await tabMatchStorage.set({\n                tabMatchConf: { id: tabInfo.id as number, config, isProductPage },\n            });\n            browser.alarms.create('scrapConfigMatch', {\n                when: Date.now() + 700,\n            });\n        }\n        /**\n         * Clear ls & shows onboarding page first time extension is installed.\n         * @param details\n         */\n\n        /**\n         * Inits extension data, should be executed once\n         */\n        protected async onExtensionLoad() {\n            logger.debug('extension load');\n            analytics.extensionLoad();\n        }\n        /**\n         * Request extension-config api and set product scrapper config.\n         */\n        protected async refreshData() {\n            //? replace any type by more convenient and descriptive extension-config type\n            const { data } = (await makeRequest({\n                endpoint: 'extension-config',\n            })) as {\n                data: ExtensionConfig;\n            };\n            this.getSerpData();\n            logger.debug('configuration load', { config: data });\n            await ShopScrapperConf.set(data.scrapConfig);\n\n            await NotificationIcon.refreshCount();\n        }\n        protected async getSerpData() {\n            const { data } = (await makeRequest({\n                endpoint: 'shop',\n            })) as {\n                data: SerpShops;\n            };\n            serpShopsData.set(data);\n        }\n    }\n\n    /**\n     * Holds extension manager state object.\n     */\n    let singletonExtensionManager: ExtensionManager | null = null;\n    /**\n     * Getter that creates a new or returns a existing instance of extension manager.\n     * @returns singletonExtensionManager\n     */\n    export function get(): ExtensionManager {\n        singletonExtensionManager =\n            singletonExtensionManager === null ? new ExtensionManager() : singletonExtensionManager;\n        return singletonExtensionManager;\n    }\n}\n/** \n* @namespace NotificationIcon\n\n*/\n\nnamespace NotificationIcon {\n    /**\n     * Set number of notifications left to check by the user on extension icon.\n     * @memberOf NotificationIcon\n     */\n    export async function refreshCount() {\n        if (!(await userIsLoggedIn())) return;\n        try {\n            const { data } = (await makeRequest({\n                endpoint: 'price-track/notifications/',\n            })) as {\n                data: IPriceTrackNotification[];\n            };\n            const notifications = data.map<IPriceTrackNotification>((ptnot) => {\n                ptnot.product.id = (ptnot.product as any)['productInfoId'];\n                // mock enabled notifications. Don't forget disabling this line\n                //ptnot.status = 0;\n                // ^^^^^^^^^^^^^^^\n                return ptnot;\n            });\n            const unreadNotifications = notifications?.filter(\n                (v) => v.status === 0 || v.status === 1,\n            );\n\n            (browser as any).browserAction.setBadgeText({\n                text: (unreadNotifications?.length || '').toString(),\n            });\n        } catch (e: any) {\n            logger.warn('Cannot get notifications', e);\n        }\n    }\n}\n/**\n * Build a timer that manages extension-config api updates\n * @param {promise} callback - the function to be called recursively (usually extension api requests).\n * @param {number} [updateIntervalMilliseconds= 30 * 60 * 1000] - amount of time to recall the function in ms (cache update).\n * @returns {object} - an object with a run method that executes the main timer.\n */\nfunction timedLoop(\n    callback: () => Promise<void>,\n    updateIntervalMilliseconds = /*m*/ 30 * /*s*/ 60 * /*ms*/ 1000,\n) {\n    let lastUpdate = 0;\n    async function updateLoop() {\n        try {\n            const updateDelta = Date.now() - lastUpdate;\n            if (updateDelta < updateIntervalMilliseconds) {\n                setTimeout(updateLoop, updateIntervalMilliseconds - updateDelta);\n                return;\n            }\n\n            await callback();\n\n            lastUpdate = Date.now();\n            setTimeout(updateLoop, updateIntervalMilliseconds);\n        } catch (e: any) {\n            errorCapture(e);\n            logger.error(e.message, { exception: e });\n            // On five minutes we will retry\n            setTimeout(updateLoop, 5 * 60 * 1000);\n        }\n    }\n\n    return {\n        run: updateLoop,\n    };\n}\n","import { ExtensionManager } from './extensionManager';\n\nimport { getExtensionPage } from '~/ui/utils/urlAccess';\nimport browser from './browser/browser';\nimport { privatePolicyData, schemaData } from './storage/storage.repo';\nimport logger from './utils/logger';\n\nlogger.log('vars', import.meta.env);\n\nasync function checkStorageVersion() {\n    const schema = await schemaData.get();\n    if (schema?.version === null || (schema.version < 2 && import.meta.env.VITE_E2E !== '1')) {\n        await browser.storage.local.clear();\n        await browser.storage.sync.clear();\n        await schemaData.set({ version: 2 });\n    }\n}\n\nasync function launchBg() {\n    try {\n        await checkStorageVersion();\n        if ((await privatePolicyData.get()).isPolicyAuth) {\n            ExtensionManager.get();\n        } else {\n            const ppPage = getExtensionPage('privatePolicy.html');\n            logger.log(ppPage);\n            const ppTab = await browser.tabs.create({ url: ppPage });\n            await privatePolicyData.set({ ppId: ppTab.id, isPolicyAuth: false });\n        }\n    } catch (error) {\n        logger.debug('error loading extension', { e: error });\n    }\n}\nlaunchBg();\n"],"names":["ShopScrapperConf","ExtensionManager","NotificationIcon"],"mappings":"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"}