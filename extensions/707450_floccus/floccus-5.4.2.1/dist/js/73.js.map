{"version":3,"file":"73.js","mappings":"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","sources":["webpack://floccus/./src/lib/Logger.js","webpack://floccus/./src/lib/adapters/Fake.js","webpack://floccus/./src/lib/browser/BrowserAccountStorage.js","webpack://floccus/./src/test/test.js"],"sourcesContent":["/* global DEBUG */\nimport util from 'util'\nimport * as Parallel from 'async-parallel'\nimport packageJson from '../../package.json'\nimport Crypto from './Crypto'\nimport { Share } from '@capacitor/share'\nimport { Filesystem, Directory, Encoding } from '@capacitor/filesystem'\nimport { Capacitor } from '@capacitor/core'\n\nexport default class Logger {\n  static log() {\n    const logMsg = [new Date().toISOString(), ...arguments]\n\n    // log to console\n    DEBUG && console.log(util.format.apply(util, logMsg))\n    this.messages.push(util.format.apply(util, logMsg)) // TODO: Use a linked list here to get O(n)\n  }\n\n  static async persist() {\n    const Storage = (Capacitor.getPlatform() === 'web') ? await import('./browser/BrowserAccountStorage') : await import('./native/NativeAccountStorage')\n    await Storage.default.changeEntry(\n      'logs',\n      log => {\n        const messages = this.messages\n        this.messages = []\n        return messages // only save the last sync run\n      },\n      []\n    )\n  }\n\n  static async getLogs() {\n    const Storage = (Capacitor.getPlatform() === 'web') ? await import('./browser/BrowserAccountStorage') : await import('./native/NativeAccountStorage')\n    return Storage.default.getEntry('logs', [])\n  }\n\n  static async anonymizeLogs(logs) {\n    const regex = /\\[(.*?)\\]\\((.*?)\\)|\\[(.*?)\\]/g\n    const newLogs = await Parallel.map(logs, async(entry) => {\n      return Logger.replaceAsync(entry, regex, async(match, p1, p2, p3) => {\n        if (p1 && p2) {\n          const hash1 = await Crypto.sha256(p1)\n          const hash2 = await Crypto.sha256(p2)\n          return '[' + hash1 + ']' + '(' + hash2 + ')'\n        } else if (p3) {\n          const hash = await Crypto.sha256(p3)\n          return '[' + hash + ']'\n        }\n      })\n    }, 1)\n    const regex2 = /url=https?%3A%2F%2F.*$|url=https?%3A%2F%2F[^ ]*/\n    const regex3 = /https?:\\/\\/[^ /]*\\//\n    return newLogs\n      .map(line => line.replace(regex2, '###url###').replace(regex3, '###server###'))\n  }\n\n  static async replaceAsync(str, regex, asyncFn) {\n    // Stolen from https://stackoverflow.com/questions/33631041/javascript-async-await-in-replace\n    const promises = []\n    str.replace(regex, (match, ...args) => {\n      const promise = asyncFn(match, ...args)\n      promises.push(promise)\n    })\n    let data\n    try {\n      data = await Promise.all(promises)\n    } catch (e) {\n      console.error(e)\n    }\n    return str.replace(regex, () => data.shift())\n  }\n\n  static async downloadLogs(anonymous = false) {\n    let logs = await this.getLogs()\n    if (anonymous) {\n      logs = await Logger.anonymizeLogs(logs)\n    }\n    let blob = new Blob([logs.join('\\n')], {\n      type: 'text/plain',\n      endings: 'native'\n    })\n    this.download(\n      'floccus-' +\n        packageJson.version +\n        '-' +\n        new Date().toISOString().slice(0, 10) +\n        '-' +\n        (anonymous ? 'redacted' : 'full') +\n        '.log',\n      blob\n    )\n  }\n\n  static async download(filename, blob) {\n    if (Capacitor.getPlatform() === 'web') {\n      const element = document.createElement('a')\n\n      let objectUrl = URL.createObjectURL(blob)\n      element.setAttribute('href', objectUrl)\n      element.setAttribute('download', filename)\n\n      element.style.display = 'none'\n      document.body.appendChild(element)\n\n      element.click()\n\n      URL.revokeObjectURL(objectUrl)\n      document.body.removeChild(element)\n    } else {\n      const {uri: fileURI} = await Filesystem.writeFile({\n        path: 'Downloads/' + filename,\n        data: await blob.text(),\n        encoding: Encoding.UTF8,\n        directory: Directory.External,\n        recursive: true\n      })\n      await Share.share({\n        title: filename,\n        files: [fileURI],\n      })\n    }\n  }\n}\nLogger.messages = []\n","import CachingAdapter from './Caching'\n\nexport default class FakeAdapter extends CachingAdapter {\n  constructor(server) {\n    super()\n    this.server = server\n  }\n\n  static getDefaultValues() {\n    return {\n      type: 'fake'\n    }\n  }\n\n  setData(data) {\n    this.server = data\n  }\n\n  getData() {\n    return JSON.parse(JSON.stringify(this.server))\n  }\n\n  getLabel() {\n    return 'Fake account (floccus)'\n  }\n}\n","import browser from '../browser-api'\nimport Cryptography from '../Crypto'\nimport DefunctCryptography from '../DefunctCrypto'\nimport Mappings from '../Mappings'\nimport { Folder, ItemLocation } from '../Tree'\nimport AsyncLock from 'async-lock'\n\nconst storageLock = new AsyncLock()\n\nexport default class BrowserAccountStorage {\n  constructor(id) {\n    this.accountId = id\n  }\n\n  static async changeEntry(entryName, fn, defaultVal) {\n    await storageLock.acquire(entryName, async() => {\n      let entry = await BrowserAccountStorage.getEntry(entryName, defaultVal)\n      entry = fn(entry)\n\n      await browser.storage.local.set({ [entryName]: JSON.stringify(entry) })\n    })\n  }\n\n  static async getEntry(entryName, defaultVal) {\n    let entry = await browser.storage.local.get(entryName)\n    if (entry[entryName]) {\n      while (typeof entry[entryName] === 'string') {\n        entry[entryName] = JSON.parse(entry[entryName])\n      }\n      return entry[entryName]\n    } else {\n      return defaultVal\n    }\n  }\n\n  static deleteEntry(entryName) {\n    return browser.storage.local.remove(entryName)\n  }\n\n  static async getAllAccounts() {\n    let accounts = await BrowserAccountStorage.getEntry(`accounts`, {})\n    return Object.keys(accounts)\n  }\n\n  async getAccountData(key) {\n    let accounts = await BrowserAccountStorage.getEntry(`accounts`, {})\n    let data = accounts[this.accountId]\n    if (key) {\n      if (data.iv) {\n        data.password = await DefunctCryptography.decryptAES(key, data.iv, data.password)\n        delete data.iv\n      } else {\n        data.password = await Cryptography.decryptAES(key, data.password, data.username)\n        if (data.passphrase) {\n          data.passphrase = await Cryptography.decryptAES(key, data.passphrase, data.username)\n        }\n      }\n    }\n    return data\n  }\n\n  async setAccountData(data, key) {\n    let encData = data\n    if (key) {\n      if (data.iv) {\n        delete data.iv\n      }\n      encData = {\n        ...data,\n        password: await Cryptography.encryptAES(key, data.password, data.username),\n        ...(data.passphrase && {passphrase: await Cryptography.encryptAES(key, data.passphrase, data.username)})\n      }\n    }\n    return BrowserAccountStorage.changeEntry(\n      `accounts`,\n      accounts => {\n        accounts[this.accountId] = encData\n        return accounts\n      },\n      {}\n    )\n  }\n\n  async deleteAccountData() {\n    await BrowserAccountStorage.changeEntry(`accounts`, accounts => {\n      delete accounts[this.accountId]\n      return accounts\n    })\n    await this.deleteCache()\n    await this.deleteMappings()\n  }\n\n  async initCache() {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => ({})\n    )\n  }\n\n  async getCache() {\n    const data = await BrowserAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].cache`\n    )\n    return Folder.hydrate(data && Object.keys(data).length ? data : {location: ItemLocation.LOCAL})\n  }\n\n  async setCache(data) {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].cache`,\n      () => data\n    )\n  }\n\n  async deleteCache() {\n    await BrowserAccountStorage.deleteEntry(`bookmarks[${this.accountId}].cache`)\n  }\n\n  async initMappings() {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => ({})\n    )\n  }\n\n  async getMappings() {\n    const data = await BrowserAccountStorage.getEntry(\n      `bookmarks[${this.accountId}].mappings`\n    )\n    return new Mappings(\n      this,\n      data && Object.keys(data).length\n        ? data\n        : {\n          bookmarks: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          },\n          folders: {\n            ServerToLocal: {},\n            LocalToServer: {}\n          }\n        }\n    )\n  }\n\n  async setMappings(data) {\n    await BrowserAccountStorage.changeEntry(\n      `bookmarks[${this.accountId}].mappings`,\n      () => data\n    )\n  }\n\n  async deleteMappings() {\n    await BrowserAccountStorage.deleteEntry(`bookmarks[${this.accountId}].mappings`)\n  }\n\n  async getCurrentContinuation() {\n    return BrowserAccountStorage.getEntry(`bookmarks[${this.accountId}].continuation`)\n  }\n\n  async setCurrentContinuation(continuation) {\n    await BrowserAccountStorage.changeEntry(`bookmarks[${this.accountId}].continuation`, (_) => ({...continuation, createdAt: Date.now()}), null)\n  }\n}\n","import chai from 'chai'\nimport chaiAsPromised from 'chai-as-promised'\nimport random from 'random'\nimport seedrandom from 'seedrandom'\nimport Account from '../lib/Account'\nimport { Bookmark, Folder, ItemLocation } from '../lib/Tree'\nimport browser from '../lib/browser-api'\nimport Crypto from '../lib/Crypto'\nimport * as AsyncParallel from 'async-parallel'\nimport DefunctCrypto from '../lib/DefunctCrypto'\nimport Controller from '../lib/Controller'\nimport FakeAdapter from '../lib/adapters/Fake'\n\nchai.use(chaiAsPromised)\nconst expect = chai.expect\n\nlet expectTreeEqual = function(tree1, tree2, ignoreEmptyFolders, checkOrder = true) {\n  try {\n    expect(tree1.title).to.equal(tree2.title)\n    if (tree2.url) {\n      expect(tree1.url).to.equal(tree2.url)\n    } else {\n      if (checkOrder === false) {\n        tree2.children.sort((a, b) => {\n          if (a.title < b.title) return -1\n          if (a.title > b.title) return 1\n          return 0\n        })\n        tree1.children.sort((a, b) => {\n          if (a.title < b.title) return -1\n          if (a.title > b.title) return 1\n          return 0\n        })\n      }\n      let children1 = ignoreEmptyFolders\n        ? tree1.children.filter(child => !hasNoBookmarks(child))\n        : tree1.children\n      let children2 = ignoreEmptyFolders\n        ? tree2.children.filter(child => !hasNoBookmarks(child))\n        : tree2.children\n      expect(children1).to.have.length(children2.length)\n      children2.forEach((child2, i) => {\n        expectTreeEqual(children1[i], child2, ignoreEmptyFolders, checkOrder)\n      })\n    }\n  } catch (e) {\n    console.log(\n      `Trees are not equal: (checkOrder: ${checkOrder}, ignoreEmptyFolders: ${ignoreEmptyFolders})`,\n      'Tree 1:\\n' + tree1.inspect(0) + '\\n',\n      'Tree 2:\\n' + tree2.inspect(0)\n    )\n    throw e\n  }\n}\n\ndescribe('Floccus', function() {\n  this.timeout(120000) // no test should run longer than 120s\n  this.slow(20000) // 20s is slow\n\n  const params = (new URL(window.location.href)).searchParams\n  let SERVER, CREDENTIALS, ACCOUNTS, APP_VERSION, SEED, BROWSER, RANDOM_MANIPULATION_ITERATIONS\n  SERVER =\n    params.get('server') ||\n    'http://localhost'\n  CREDENTIALS = {\n    username: params.get('username') || 'admin',\n    password: params.get('password') || 'admin'\n  }\n  APP_VERSION = params.get('app_version') || 'stable'\n  BROWSER = params.get('browser') || 'firefox'\n\n  SEED = (new URL(window.location.href)).searchParams.get('seed') || Math.random() + ''\n  console.log('RANDOMNESS SEED', SEED)\n  random.use(seedrandom(SEED))\n\n  RANDOM_MANIPULATION_ITERATIONS = 35\n\n  ACCOUNTS = [\n    FakeAdapter.getDefaultValues(),\n    {\n      ...FakeAdapter.getDefaultValues(),\n      noCache: true,\n    },\n    {\n      type: 'nextcloud-bookmarks',\n      url: SERVER,\n      ...CREDENTIALS\n    },\n    {\n      type: 'nextcloud-bookmarks',\n      url: SERVER,\n      serverRoot: '/my folder/some subfolder',\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      passphrase: random.float(),\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.html',\n      bookmark_file_type: 'html',\n      ...CREDENTIALS\n    },\n    {\n      type: 'webdav',\n      url: `${SERVER}/remote.php/webdav/`,\n      bookmark_file: 'bookmarks.html',\n      bookmark_file_type: 'html',\n      passphrase: random.float(),\n      ...CREDENTIALS\n    },\n    {\n      type: 'git',\n      url: `${SERVER}/test.git`,\n      branch: 'main',\n      bookmark_file: 'bookmarks.xbel',\n      bookmark_file_type: 'xbel',\n      ...CREDENTIALS\n    },\n    {\n      type: 'git',\n      url: `${SERVER}/test.git`,\n      branch: 'main',\n      bookmark_file: 'bookmarks.html',\n      bookmark_file_type: 'html',\n      ...CREDENTIALS\n    },\n    {\n      type: 'google-drive',\n      bookmark_file: Math.random() + '.xbel',\n      password: '',\n      refreshToken: CREDENTIALS.password,\n    },\n    {\n      type: 'google-drive',\n      bookmark_file: Math.random() + '.xbel',\n      password: random.float(),\n      refreshToken: CREDENTIALS.password,\n    },\n    {\n      type: 'linkwarden',\n      url: SERVER,\n      serverFolder: 'Floccus-' + Math.random(),\n      ...CREDENTIALS,\n    },\n  ]\n\n  before(async function() {\n    const controller = await Controller.getSingleton()\n    controller.setEnabled(false)\n  })\n  after(async function() {\n    const controller = await Controller.getSingleton()\n    controller.setEnabled(true)\n  })\n\n  describe('Crypto', function() {\n    it('should encrypt and decrypt correctly', async function() {\n      const passphrase = 'test'\n      const salt = 'blah'\n      const message = 'I don\\'t know'\n      const payload = await Crypto.encryptAES(passphrase, message, salt)\n      console.log(payload)\n      const cleartext = await Crypto.decryptAES(passphrase, payload, salt)\n      expect(cleartext).to.equal(message)\n      console.log(cleartext)\n      console.log(message)\n    })\n\n    it('should encrypt and decrypt correctly (even with defunct crypto)', async function() {\n      const passphrase = 'test'\n      const message = 'I don\\'t know'\n      const payload = await DefunctCrypto.encryptAES(passphrase, DefunctCrypto.iv, message)\n      console.log(payload)\n      const cleartext = await DefunctCrypto.decryptAES(passphrase, DefunctCrypto.iv, payload)\n      expect(cleartext).to.equal(message)\n      console.log(cleartext)\n      console.log(message)\n    })\n  })\n\n  ACCOUNTS.forEach(ACCOUNT_DATA => {\n    describe(`${stringifyAccountData(ACCOUNT_DATA)} test ${ACCOUNT_DATA.serverRoot ? 'subfolder' : 'root'} Account`, function() {\n      let account\n      beforeEach('set up account', async function() {\n        account = await Account.create(ACCOUNT_DATA)\n      })\n      afterEach('clean up account', async function() {\n        if (account) {\n          let localRoot = account.getData().localRoot\n          if (localRoot) await browser.bookmarks.removeTree(localRoot)\n          await account.delete()\n        }\n      })\n      it('should create an account', async function() {\n        const secondInstance = await Account.get(account.id)\n        expect(secondInstance.getData()).to.deep.equal(account.getData())\n      })\n      it('should save and restore an account', async function() {\n        await account.setData(ACCOUNT_DATA)\n        expect(account.getData()).to.deep.equal({...account.getData(), ...ACCOUNT_DATA})\n\n        const secondInstance = await Account.get(account.id)\n        expect(secondInstance.getData()).to.deep.equal({...secondInstance.getData(), ...ACCOUNT_DATA})\n      })\n      it('should delete an account', async function() {\n        await account.delete()\n        expect(Account.get(account.id)).to.be.rejected\n        account = null // so afterEach notices it's deleted already\n      })\n      it('should not be initialized upon creation', async function() {\n        expect(await account.isInitialized()).to.be.false\n      })\n    })\n    describe(`${stringifyAccountData(ACCOUNT_DATA)} test ${ACCOUNT_DATA.serverRoot ? 'subfolder' : 'root'} Sync`,\n      function() {\n        context('with one client', function() {\n          let account\n          beforeEach('set up account', async function() {\n            account = await Account.create(ACCOUNT_DATA)\n            if (ACCOUNT_DATA.type === 'fake') {\n              account.server.bookmarksCache = new Folder({\n                id: '',\n                title: 'root',\n                location: 'Server'\n              })\n            }\n            await account.init()\n            if (ACCOUNT_DATA.noCache) {\n              account.storage.setCache = () => {\n                // noop\n              }\n              account.storage.setMappings = () => {\n                // noop\n              }\n            }\n          })\n          afterEach('clean up account', async function() {\n            if (!account) return\n            try {\n              await browser.bookmarks.removeTree(account.getData().localRoot)\n            } catch (e) {\n              console.error(e)\n            }\n            if (ACCOUNT_DATA.type === 'git') {\n              await account.server.clearServer()\n            } else if (ACCOUNT_DATA.type !== 'fake') {\n              await account.setData({ ...account.getData(), serverRoot: null })\n              account.lockTimeout = 0\n              const tree = await getAllBookmarks(account)\n              await withSyncConnection(account, async() => {\n                await AsyncParallel.each(tree.children, async child => {\n                  if (child instanceof Folder) {\n                    await account.server.removeFolder(child)\n                  } else {\n                    await account.server.removeBookmark(child)\n                  }\n                })\n              })\n            }\n            if (ACCOUNT_DATA.type === 'google-drive') {\n              const fileList = await account.server.listFiles('name = ' + \"'\" + account.server.bookmark_file + \"'\")\n              const files = fileList.files\n              for (const file of files) {\n                await account.server.deleteFile(file.id)\n              }\n              if (files.length > 1) {\n                throw new Error('Google Drive sync left more than one file behind')\n              }\n            }\n            await account.delete()\n          })\n          it('should create local bookmarks on the server', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({ title: 'url', url: bookmark.url })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create empty local folders on the server', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create local javascript bookmarks on the server', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'javascript:void(0)',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({ title: 'url', url: bookmark.url })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'javascript:void(1)',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree2 = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree2,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({ title: 'url', url: bookmark.url }),\n                          new Bookmark({ title: 'url2', url: bookmark2.url }),\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should update the server on local changes', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const newData = { title: 'blah' }\n            await browser.bookmarks.update(bookmark.id, newData)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: newData.title,\n                            url: bookmark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local changes of duplicates', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const newData = { title: 'blah' }\n            await browser.bookmarks.update(bookmark2.id, newData)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: newData.title,\n                            url: bookmark1.url\n                          })\n                        ]\n                      }),\n                      new Bookmark({\n                        title: ACCOUNT_DATA.type === 'nextcloud-bookmarks' ? newData.title : bookmark2.title,\n                        url: bookmark1.url\n                      }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local changes of url collisions', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'ur1l',\n              url: 'http://ur1.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const newData = { url: 'http://ur.l/' }\n            await browser.bookmarks.update(bookmark1.id, newData)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: bookmark2.title,\n                            url: bookmark2.url\n                          })\n                        ]\n                      }),\n                      new Bookmark({\n                        title: ACCOUNT_DATA.type === 'nextcloud-bookmarks' ? bookmark2.title : bookmark1.title,\n                        url: newData.url\n                      }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local removals', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.remove(bookmark.id)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local removals and recreations', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            expect(\n              (await getAllBookmarks(account)).children\n            ).to.have.lengthOf(0)\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.remove(bookmark.id)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree2 = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree2,\n              new Folder({\n                title: tree2.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            url: bookmark2.url,\n                            title: bookmark2.title\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server on local folder moves', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://ureff.l/',\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({ title: 'test', url: 'http://ureff.l/' })\n                    ]\n                  }),\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create server bookmarks locally', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let fooFolderId, barFolderId, serverMark\n            await withSyncConnection(account, async() => {\n              fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n              barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n              serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId\n              }\n\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: serverMark.title,\n                            url: serverMark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create empty server folders locally', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n              await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update local bookmarks on server changes', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n\n            const serverTree = await getAllBookmarks(account)\n            let fooFolderId, barFolderId, serverMarkId, serverMark\n            await withSyncConnection(account, async() => {\n              fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n              barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n              serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId\n              }\n\n              serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync() // propage creation\n            expect(account.getData().error).to.not.be.ok\n\n            const newServerMark = {\n              ...serverMark,\n              title: 'blah',\n              id: serverMarkId\n            }\n            await withSyncConnection(account, async() => {\n              await adapter.updateBookmark(new Bookmark(newServerMark))\n            })\n\n            await account.sync() // propage update\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [\n                          new Bookmark({\n                            title: newServerMark.title,\n                            url: newServerMark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update local bookmarks on server removals', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n\n            const serverTree = await getAllBookmarks(account)\n            if (adapter.onSyncStart) await adapter.onSyncStart()\n            const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo'}))\n            const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar'}))\n            const serverMark = {\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolderId\n            }\n\n            const serverMarkId = await adapter.createBookmark(\n              new Bookmark(serverMark)\n            )\n            if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n            await account.sync() // propage creation\n            expect(account.getData().error).to.not.be.ok\n\n            await withSyncConnection(account, async() => {\n              await adapter.removeBookmark({...serverMark, id: serverMarkId})\n            })\n\n            await account.sync() // propage update\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should not delete additions while sync is running', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            const syncPromise = account.sync() // propagate to server\n            await new Promise(resolve => setTimeout(resolve, 1000))\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://secondur.l/',\n              parentId: fooFolder.id\n            })\n            await syncPromise\n\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [new Bookmark({\n                          title: 'url',\n                          url: 'http://ur.l/',\n                        })]\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: 'http://secondur.l/',\n                      }),\n                    ]\n                  }),\n                ]\n              }),\n              false\n            )\n          })\n          it('should be able to handle duplicates', async function() {\n            const localRoot = account.getData().localRoot\n            const bookmarkData = {\n              title: 'url',\n              url: 'http://ur.l/'\n            }\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              ...bookmarkData,\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              ...bookmarkData,\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [new Bookmark(bookmarkData)]\n                  }),\n                  new Folder({\n                    title: 'bar',\n                    children: [new Bookmark(bookmarkData)]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should deduplicate unnormalized URLs', async function() {\n            const adapter = account.server\n\n            // create bookmark on server\n            const serverTree = await getAllBookmarks(account)\n            if (adapter.onSyncStart) await adapter.onSyncStart()\n            const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n            const serverMark1 = {\n              title: 'url',\n              url: 'http://ur.l/foo/bar?a=b&foo=b%C3%A1r+foo',\n              location: ItemLocation.SERVER\n            }\n            const serverMark2 = {\n              title: 'url2',\n              url: 'http://ur2.l/foo/bar?a=b&foo=b%C3%A1r+foo',\n              location: ItemLocation.SERVER\n            }\n            await adapter.createBookmark(\n              new Bookmark({ ...serverMark1, parentId: fooFolderId })\n            )\n            await adapter.createBookmark(\n              new Bookmark({ ...serverMark2, parentId: fooFolderId })\n            )\n            if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n            // create bookmark locally\n            const localRoot = account.getData().localRoot\n            const localMark1 = {\n              title: 'url',\n              url: 'http://ur.l/foo/bar?a=b&foo=bár+foo'\n            }\n            const localMark2 = {\n              title: 'url2',\n              url: 'http://ur2.l/foo/bar?a=b&foo=bár+foo'\n            }\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              ...localMark1,\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              ...localMark2,\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            // Sync again, so client can deduplicate\n            // necessary if using bookmarks < v0.12 or WebDAV\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark(serverMark1),\n                      new Bookmark(serverMark2)\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should deduplicate unnormalized URLs without getting stuck', async function() {\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks' && (APP_VERSION !== 'stable' && APP_VERSION !== 'master' && APP_VERSION !== 'stable3')) {\n              this.skip()\n            }\n\n            // create bookmark locally\n            const localRoot = account.getData().localRoot\n            const localMark1 = {\n              title: 'url',\n              url: 'http://nextcloud.com/'\n            }\n            const localMark2 = {\n              title: 'url2',\n              url: 'https://nextcloud.com'\n            }\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              ...localMark1,\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              ...localMark2,\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            expect(account.getData().error).to.not.be.ok\n\n            // Sync again, so client can deduplicate\n            // necessary if using bookmarks < v0.12 or WebDAV\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark(localMark1),\n                      new Bookmark(localMark2)\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should not fail when moving both folders and contents', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://ureff.l/',\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await browser.bookmarks.move(fooFolder.id, {\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.move(bookmark1.id, {\n              parentId: barFolder.id\n            })\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Folder({\n                        title: 'foo',\n                        children: [],\n                      }),\n                      new Bookmark({ title: 'test', url: 'http://ureff.l/' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should not fail when both moving folders and deleting their contents', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://ureff.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://uawdgr.l/',\n              parentId: fooFolder.id\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark3 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://urzur.l/',\n              parentId: barFolder.id\n            })\n            const bookmark4 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://uadgr.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(barFolder.id, { parentId: localRoot })\n            await browser.bookmarks.move(fooFolder.id, {\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.remove(bookmark3.id)\n            await account.sync() // update on server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark(bookmark4),\n                      new Folder({\n                        title: 'foo',\n                        children: [\n                          new Bookmark(bookmark1),\n                          new Bookmark(bookmark2)\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should handle strange characters well', async function() {\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo!\"§$%&/()=?\"',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: \"bar=?*'Ä_:-^;<script>\",\n              parentId: fooFolder.id\n            })\n            const bookmark = await browser.bookmarks.create({\n              title: 'url|!\"=)/§_:;Ä\\'*ü\"',\n              url: 'http://ur.l/?a&b=<script>',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo!\"§$%&/()=?\"',\n                    children: [\n                      new Folder({\n                        title: \"bar=?*'Ä_:-^;<script>\",\n                        children: [\n                          new Bookmark({\n                            title: 'url|!\"=)/§_:;Ä\\'*ü\"',\n                            url: bookmark.url\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should be able to delete a server folder', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.removeTree(fooFolder.id)\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: []\n              }),\n              false\n            )\n          })\n          it('should be able to delete a local folder', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              await adapter.removeFolder({id: tree.children[0].id})\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: []\n              }),\n              false\n            )\n          })\n          it('should be ok if both server and local bookmark are removed', async function() {\n            const adapter = account.server\n            let serverTree = await getAllBookmarks(account)\n            if (adapter.onSyncStart) await adapter.onSyncStart()\n            const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n            const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n            const serverMark = {\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolderId,\n              location: ItemLocation.SERVER\n            }\n            const serverMarkId = await adapter.createBookmark(\n              new Bookmark(serverMark)\n            )\n            if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n            await account.sync() // propagate creation\n            expect(account.getData().error).to.not.be.ok\n\n            await withSyncConnection(account, async() => {\n              await adapter.removeBookmark({...serverMark, id: serverMarkId})\n            })\n            await account.sync() // propagate update\n\n            expect(account.getData().error).to.not.be.ok\n            const localTree = await account.localTree.getBookmarksTree(true)\n\n            serverTree = await getAllBookmarks(account)\n\n            // Root must also be equal in the assertion\n            localTree.title = serverTree.title\n\n            expectTreeEqual(localTree, serverTree)\n          })\n          it('should ignore duplicates in the same folder', async function() {\n            if (ACCOUNT_DATA.type !== 'nextcloud-bookmarks') {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should move items successfully even into new folders', async function() {\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const subFolder = await browser.bookmarks.create({\n              title: 'sub',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.move(bookmark1.id, { parentId: subFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Bookmark({ title: 'url', url: 'http://ur.l/' })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items successfully when mixing creation and moving (1)', async function() {\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const topFolder = await browser.bookmarks.create({\n              title: 'top',\n              parentId: localRoot\n            })\n            const subFolder = await browser.bookmarks.create({\n              title: 'sub',\n              parentId: topFolder.id\n            })\n            await browser.bookmarks.move(fooFolder.id, { parentId: subFolder.id })\n            await browser.bookmarks.move(barFolder.id, { parentId: fooFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'top',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Folder({\n                            title: 'foo',\n                            children: [\n                              new Folder({\n                                title: 'bar',\n                                children: [\n                                  new Bookmark({\n                                    title: 'url',\n                                    url: 'http://ur.l/'\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'top',\n                    children: [\n                      new Folder({\n                        title: 'sub',\n                        children: [\n                          new Folder({\n                            title: 'foo',\n                            children: [\n                              new Folder({\n                                title: 'bar',\n                                children: [\n                                  new Bookmark({\n                                    title: 'url',\n                                    url: 'http://ur.l/'\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items successfully when mixing creation and moving (2)', async function() {\n            const localRoot = account.getData().localRoot\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: cFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: dFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: localRoot\n            })\n            await browser.bookmarks.move(bFolder.id, { parentId: eFolder.id })\n            const fFolder = await browser.bookmarks.create({\n              title: 'f',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.move(cFolder.id, { parentId: fFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'e',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Folder({\n                            title: 'f',\n                            children: [\n                              new Folder({\n                                title: 'c',\n                                children: [\n                                  new Folder({\n                                    title: 'd',\n                                    children: [\n                                      new Bookmark({\n                                        title: 'url',\n                                        url: 'http://ur.l/'\n                                      })\n                                    ]\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'e',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Folder({\n                            title: 'f',\n                            children: [\n                              new Folder({\n                                title: 'c',\n                                children: [\n                                  new Folder({\n                                    title: 'd',\n                                    children: [\n                                      new Bookmark({\n                                        title: 'url',\n                                        url: 'http://ur.l/'\n                                      })\n                                    ]\n                                  })\n                                ]\n                              })\n                            ]\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items without creating a folder loop', async function() {\n            if (APP_VERSION !== 'stable' && APP_VERSION !== 'master') {\n              this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: bFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // sync to server again for order to kick in\n            expect(account.getData().error).to.not.be.ok\n\n            // move b into a in client\n            await browser.bookmarks.move(bFolder.id, { parentId: aFolder.id })\n\n            // move a into b on server\n            await withSyncConnection(account, async() => {\n              const initialTree = await account.server.getBookmarksTree(true)\n              const aFolder = initialTree.children[0]\n              const bFolder = initialTree.children[1]\n              aFolder.parentId = bFolder.id\n              await account.server.updateFolder(aFolder)\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Bookmark({\n                            title: 'url',\n                            url: 'http://ur.l/',\n                          })\n\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              Boolean(account.server.orderFolder)\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            localTree.title = tree.title\n            expectTreeEqual(\n              localTree,\n              tree,\n              false,\n              Boolean(account.server.orderFolder)\n            )\n          })\n          it('should move items without confusing folders', async function() {\n            const localRoot = account.getData().localRoot\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: localRoot\n            })\n            const cFolder1 = await browser.bookmarks.create({\n              title: 'c',\n              parentId: aFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: cFolder1.id\n            })\n            const cFolder2 = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'test',\n              url: 'http://urrr.l/',\n              parentId: cFolder2.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // make sure order is propagated\n            expect(account.getData().error).to.not.be.ok\n\n            await account.init()\n\n            // move b into a in client\n            await browser.bookmarks.move(cFolder1.id, { parentId: localRoot })\n            await browser.bookmarks.move(cFolder2.id, { parentId: dFolder.id })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'b',\n                    children: []\n                  }),\n                  new Folder({\n                    title: 'd',\n                    children: [\n                      new Folder({\n                        title: 'c',\n                        children: [\n                          new Bookmark({\n                            title: 'test',\n                            url: 'http://urrr.l/',\n                          })\n                        ]\n                      })\n                    ]\n                  }),\n                  new Folder({\n                    title: 'c',\n                    children: [\n                      new Bookmark({\n                        title: 'url',\n                        url: 'http://ur.l/',\n                      })\n                    ]\n                  }),\n                ]\n              }),\n              false,\n              false\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            localTree.title = tree.title\n            expectTreeEqual(\n              localTree,\n              tree,\n              false,\n              false\n            )\n          })\n          it('should integrate existing items from both sides', async function() {\n            const localRoot = account.getData().localRoot\n\n            const adapter = account.server\n\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: aFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur.l/dalfk',\n              parentId: bFolder.id\n            })\n\n            let aFolderId, bookmark1Id,bFolderId,bookmark2Id\n            await withSyncConnection(account, async() => {\n              aFolderId = await adapter.createFolder(\n                new Folder({parentId: (await adapter.getBookmarksTree()).id,\n                  title: 'a'})\n              )\n              bookmark1Id = await adapter.createBookmark(\n                new Bookmark({\n                  title: 'url',\n                  url: 'http://ur.l',\n                  parentId: aFolderId\n                })\n              )\n\n              bFolderId = await adapter.createFolder(new Folder({parentId: aFolderId, title: 'b'}))\n              bookmark2Id = await adapter.createBookmark(\n                new Bookmark({\n                  title: 'url2',\n                  url: 'http://ur.l/dalfk',\n                  parentId: bFolderId\n                })\n              )\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Bookmark({\n                            title: 'url2',\n                            url: 'http://ur.l/dalfk'\n                          })\n                        ]\n                      }),\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false /* checkOrder */\n            )\n\n            expect(tree.findBookmark(bookmark1Id)).to.be.ok\n            expect(tree.findBookmark(bookmark2Id)).to.be.ok\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'a',\n                    children: [\n                      new Folder({\n                        title: 'b',\n                        children: [\n                          new Bookmark({\n                            title: 'url2',\n                            url: 'http://ur.l/dalfk'\n                          })\n                        ]\n                      }),\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false /* checkOrder */\n            )\n\n            expect(localTree.findBookmark(bookmark1.id)).to.be.ok\n            expect(localTree.findBookmark(bookmark2.id)).to.be.ok\n          })\n          it('should error when deleting too much local data', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await Promise.all([\n              'http://ur.l/',\n              'http://ur.ll/',\n              'http://ur2.l/',\n              'http://ur3.l/',\n              'http://ur4.l/',\n              'http://ur5.l/',\n              'http://ur6.l/',\n              'http://ur7.l/',\n              'http://ur8.l/',\n              'http://ur9.l/',\n              'http://ur10.l/',\n            ].map(url => browser.bookmarks.create({\n              title: 'url',\n              url,\n              parentId: barFolder.id\n            })))\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            // Remove everything on the server\n            const tree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              await AsyncParallel.each(tree.children, async child => {\n                if (child instanceof Folder) {\n                  await account.server.removeFolder(child)\n                } else {\n                  await account.server.removeBookmark(child)\n                }\n              })\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.be.ok // should have errored\n          })\n          it('should leave alone unaccepted bookmarks entirely', async function() {\n            if (!~ACCOUNT_DATA.type.indexOf('nextcloud')) {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'chrome://extensions/',\n              parentId: fooFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // propagate to server -- if we had cached the unacceptables, they'd be deleted now\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Folder({\n                        title: 'foo',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false\n            )\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'bar',\n                    children: [\n                      new Bookmark({ title: 'url', url: 'http://ur.l/' }),\n                      new Folder({\n                        title: 'foo',\n                        children: [\n                          new Bookmark({\n                            title: 'url2',\n                            url: 'chrome://extensions/'\n                          })\n                        ]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false\n            )\n          })\n          it('should sync separators', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              this.skip()\n              return\n            }\n            if (BROWSER !== 'firefox') {\n              this.skip()\n              return\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur2.l',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            let localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                    ]}),\n                ]}),\n              false\n            )\n            expectTreeEqual(\n              tree,\n              new Folder({title: tree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                    ]}),\n                ]}),\n              false\n            )\n\n            console.log('initial sync done')\n\n            await withSyncConnection(account, async() => {\n              // move first separator\n              await account.server.updateBookmark({...tree.children[0].children[0].children[1], parentId: tree.children[0].id})\n            })\n\n            console.log('move done')\n\n            await account.sync() // propagate to browser\n            expect(account.getData().error).to.not.be.ok\n\n            localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=467366'})\n                        ]}),\n                      new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=379999'})\n                    ]}),\n                ]}),\n              false\n            )\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({title: tree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                      new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=467366'})\n                    ]}),\n                ]}),\n              false\n            )\n          })\n          it('should sync separators 2', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              this.skip()\n              return\n            }\n            if (BROWSER !== 'firefox') {\n              this.skip()\n              return\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account.getData().localRoot\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: localRoot\n            })\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur2.l',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              type: 'separator',\n              parentId: fooFolder.id\n            })\n\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            let localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                    ]}),\n                ]}),\n              false\n            )\n            expectTreeEqual(\n              tree,\n              new Folder({title: tree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=467366'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=731368'})\n                        ]}),\n                    ]}),\n                ]}),\n              false\n            )\n\n            console.log('initial sync done')\n\n            await withSyncConnection(account, async() => {\n              // remove first separator\n              await account.server.removeBookmark(tree.children[0].children[0].children[1])\n            })\n            await account.sync() // propagate to browser\n            expect(account.getData().error).to.not.be.ok\n\n            localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({title: localTree.title,\n                children: [\n                  new Folder({title: 'bar',\n                    children: [\n                      new Folder({title: 'foo',\n                        children: [\n                          new Bookmark({title: 'url', url: 'http://ur.l/'}),\n                          new Bookmark({title: 'url2',url: 'http://ur2.l'}),\n                          new Bookmark({title: '-----', url: 'https://separator.floccus.org/?id=467366'})\n                        ]}),\n                    ]}),\n\n                ]}),\n              false\n            )\n          })\n          it('should sync root folder successfully', async function() {\n            const [root] = await browser.bookmarks.getTree()\n            await account.setData({...account.getData(), localRoot: root.id})\n            account = await Account.get(account.id)\n\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: root.children[0].id\n            })\n            await browser.bookmarks.create({\n              title: 'foo',\n              parentId: barFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account.sync() // propagate to server\n            expect(account.getData().error).to.not.be.ok\n\n            await account.sync() // propagate to server -- if we had cached the unacceptables, they'd be deleted now\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            const newRoot = await account.localTree.getBookmarksTree()\n            tree.title = newRoot.title\n            expectTreeEqual(\n              tree,\n              newRoot,\n              false,\n              false\n            )\n\n            // Switch it back to something harmless, so we don't attempt to clean up the root folder\n            await account.setData({...account.getData(), localRoot: barFolder.id})\n            account = await Account.get(account.id)\n          })\n          it('should sync root folder ignoring unsupported folders', async function() {\n            const [root] = await browser.bookmarks.getTree()\n\n            await Promise.all(\n              root.children.flatMap(child => child.children.map(child => browser.bookmarks.removeTree(child.id)))\n            )\n\n            const originalFolderId = account.getData().localRoot\n            await account.setData({...account.getData(), localRoot: root.id, })\n            account = await Account.get(account.id)\n            const adapter = account.server\n\n            let bookmark\n            let serverTree = await getAllBookmarks(account)\n            await withSyncConnection(account, async() => {\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url2',\n                url: 'http://ur2.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const id = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              bookmark = {...serverMark, id}\n            })\n\n            const secondBookmarkFolderTitle = root.children[0].title\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: root.children[0].id\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            serverTree = await getAllBookmarks(account)\n            const newRoot = await account.localTree.getBookmarksTree()\n            expect(serverTree.children).to.have.lengthOf(newRoot.children.length + 1)\n\n            await withSyncConnection(account, async() => {\n              bookmark.parentId = serverTree.children.find(folder => folder.title !== 'foo').id\n              const fooFolder = serverTree.children.find(folder => folder.title === 'foo')\n              await adapter.updateBookmark(new Bookmark(bookmark))\n              // toLowerCase to accommodate chrome (since we normalize the title)\n              const secondBookmark = serverTree.children.find(folder => folder.title.toLowerCase() === secondBookmarkFolderTitle.toLowerCase()).children.find(item => item.type === 'bookmark')\n              secondBookmark.parentId = fooFolder.id\n              await adapter.updateBookmark(secondBookmark)\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            serverTree = await getAllBookmarks(account)\n            const localTreeAfterSync = await account.localTree.getBookmarksTree()\n            expect(serverTree.children).to.have.lengthOf(localTreeAfterSync.children.length + 1)\n\n            // Switch it back to something harmless, so we don't attempt to clean up the root folder\n            await account.setData({...account.getData(), localRoot: originalFolderId})\n            account = await Account.get(account.id)\n          })\n          it('should synchronize ordering', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n\n            const localRoot = account.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const folder1 = await browser.bookmarks.create({\n              title: 'folder1',\n              parentId: fooFolder.id\n            })\n            const folder2 = await browser.bookmarks.create({\n              title: 'folder2',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url1',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur.ll/',\n              parentId: fooFolder.id\n            })\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            await browser.bookmarks.move(bookmark1.id, { index: 0 })\n            await browser.bookmarks.move(folder1.id, { index: 1 })\n            await browser.bookmarks.move(bookmark2.id, { index: 2 })\n            await browser.bookmarks.move(folder2.id, { index: 3 })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const localTree = await account.localTree.getBookmarksTree(true)\n            expectTreeEqual(\n              localTree,\n              new Folder({\n                title: localTree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({\n                        title: 'url1',\n                        url: bookmark1.url\n                      }),\n                      new Folder({\n                        title: 'folder1',\n                        children: []\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: bookmark2.url\n                      }),\n                      new Folder({\n                        title: 'folder2',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              true\n            )\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({\n                        title: 'url1',\n                        url: bookmark1.url\n                      }),\n                      new Folder({\n                        title: 'folder1',\n                        children: []\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: bookmark2.url\n                      }),\n                      new Folder({\n                        title: 'folder2',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false,\n              true\n            )\n          })\n          context('with slave mode', function() {\n            it(\"shouldn't create local bookmarks on the server\", async function() {\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expect(tree.children).to.have.lengthOf(0)\n            })\n            it(\"shouldn't update the server on local changes\", async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              const originalTree = await getAllBookmarks(account)\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n\n              const newData = { title: 'blah' }\n              await browser.bookmarks.update(bookmark.id, newData)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update the server on local removals\", async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              const originalTree = await getAllBookmarks(account)\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n\n              await browser.bookmarks.remove(bookmark.id)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update the server on local folder moves\", async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              await browser.bookmarks.create({\n                title: 'test',\n                url: 'http://ureff.l/',\n                parentId: fooFolder.id\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              const originalTree = await getAllBookmarks(account)\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n\n              await browser.bookmarks.move(barFolder.id, {\n                parentId: localRoot\n              })\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it('should create server bookmarks locally', async function() {\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({\n                              title: serverMark.title,\n                              url: serverMark.url\n                            })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should update local bookmarks on server changes', async function() {\n              if (ACCOUNT_DATA.noCache) {\n                return this.skip()\n              }\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n              const adapter = account.server\n\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n\n              const newServerMark = {\n                ...serverMark,\n                title: 'blah',\n                id: serverMarkId,\n                location: ItemLocation.SERVER\n              }\n\n              await withSyncConnection(account, async() => {\n                await adapter.updateBookmark(new Bookmark(newServerMark))\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({\n                              title: newServerMark.title,\n                              url: newServerMark.url\n                            })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should update local bookmarks on server removals', async function() {\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n\n              await withSyncConnection(account, async() => {\n                await adapter.removeBookmark({...serverMark, id: serverMarkId})\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: []\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should sync root folder ignoring unsupported folders', async function() {\n              const [root] = await browser.bookmarks.getTree()\n\n              await Promise.all(\n                root.children.flatMap(child => child.children.map(child => browser.bookmarks.removeTree(child.id)))\n              )\n\n              const originalFolderId = account.getData().localRoot\n              await account.setData({...account.getData(), localRoot: root.id, })\n              account = await Account.get(account.id)\n              const adapter = account.server\n\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              let bookmark\n              let serverTree = await getAllBookmarks(account)\n              await withSyncConnection(account, async() => {\n                const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n                const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n                const serverMark = {\n                  title: 'url2',\n                  url: 'http://ur2.l/',\n                  parentId: barFolderId,\n                  location: ItemLocation.SERVER\n                }\n                const id = await adapter.createBookmark(\n                  new Bookmark(serverMark)\n                )\n                bookmark = {...serverMark, id}\n              })\n\n              const secondBookmarkFolderTitle = root.children[0].title\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: root.children[0].id\n              })\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              serverTree = await getAllBookmarks(account)\n              const newRoot = await account.localTree.getBookmarksTree()\n              expect(serverTree.children).to.have.lengthOf(newRoot.children.length + 1)\n\n              await withSyncConnection(account, async() => {\n                bookmark.parentId = serverTree.children.find(folder => folder.title !== 'foo').id\n                const fooFolder = serverTree.children.find(folder => folder.title === 'foo')\n                await adapter.updateBookmark(new Bookmark(bookmark))\n                // toLowerCase to accommodate chrome (since we normalize the title)\n                const secondBookmark = serverTree.children.find(folder => folder.title.toLowerCase() === secondBookmarkFolderTitle.toLowerCase()).children.find(item => item.type === 'bookmark')\n                secondBookmark.parentId = fooFolder.id\n                await adapter.updateBookmark(secondBookmark)\n              })\n\n              await account.setData({ ...account.getData(), strategy: 'slave' })\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              serverTree = await getAllBookmarks(account)\n              const localTreeAfterSync = await account.localTree.getBookmarksTree()\n              expect(serverTree.children).to.have.lengthOf(localTreeAfterSync.children.length + 1)\n\n              // Switch it back to something harmless, so we don't attempt to clean up the root folder\n              await account.setData({...account.getData(), localRoot: originalFolderId})\n              account = await Account.get(account.id)\n            })\n          })\n          context('with overwrite mode', function() {\n            it('should create local bookmarks on the server', async function() {\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({ title: 'url', url: bookmark.url })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n            })\n            it('should create local bookmarks on the server respecting moves', async function() {\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: [\n                        new Folder({\n                          title: 'bar',\n                          children: [\n                            new Bookmark({ title: 'url', url: bookmark.url })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false\n              )\n\n              const bazFolder = await browser.bookmarks.create({\n                title: 'baz',\n                parentId: localRoot\n              })\n              const barazFolder = await browser.bookmarks.create({\n                title: 'baraz',\n                parentId: bazFolder.id\n              })\n              await browser.bookmarks.move(barFolder.id, {parentId: barazFolder.id})\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree2 = await getAllBookmarks(account)\n              expectTreeEqual(\n                tree2,\n                new Folder({\n                  title: tree.title,\n                  children: [\n                    new Folder({\n                      title: 'foo',\n                      children: []\n                    }),\n                    new Folder({\n                      title: 'baz',\n                      children: [\n                        new Folder({\n                          title: 'baraz',\n                          children: [\n                            new Folder({\n                              title: 'bar',\n                              children: [\n                                new Bookmark({ title: 'url', url: bookmark.url })\n                              ]\n                            })\n                          ]\n                        })\n                      ]\n                    })\n                  ]\n                }),\n                false,\n                Boolean(account.server.orderFolder)\n              )\n            })\n            it('should update the server on local changes', async function() {\n              if (ACCOUNT_DATA.noCache) {\n                return this.skip()\n              }\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n\n              const newData = { title: 'blah' }\n              await browser.bookmarks.update(bookmark.id, newData)\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it('should update the server on local removals', async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              const bookmark = await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n\n              await browser.bookmarks.remove(bookmark.id)\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it('should update the server on local folder moves', async function() {\n              expect(\n                (await getAllBookmarks(account)).children\n              ).to.have.lengthOf(0)\n\n              const localRoot = account.getData().localRoot\n              const fooFolder = await browser.bookmarks.create({\n                title: 'foo',\n                parentId: localRoot\n              })\n              await browser.bookmarks.create({\n                title: 'test',\n                url: 'http://ureff.l/',\n                parentId: fooFolder.id\n              })\n              const barFolder = await browser.bookmarks.create({\n                title: 'bar',\n                parentId: fooFolder.id\n              })\n              await browser.bookmarks.create({\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolder.id\n              })\n              await account.sync() // propagate to server\n              expect(account.getData().error).to.not.be.ok\n\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n\n              await browser.bookmarks.move(barFolder.id, {\n                parentId: localRoot\n              })\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.sync() // update on server\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await getAllBookmarks(account)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't create server bookmarks locally\", async function() {\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n              const adapter = account.server\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              const serverTree = await getAllBookmarks(account)\n\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync()\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update local bookmarks on server changes\", async function() {\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n\n              const newServerMark = {\n                ...serverMark,\n                title: 'blah',\n                id: serverMarkId,\n                location: ItemLocation.SERVER\n              }\n              await withSyncConnection(account, async() => {\n                await adapter.updateBookmark(new Bookmark(newServerMark))\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n            it(\"shouldn't update local bookmarks on server removals\", async function() {\n              const adapter = account.server\n              const serverTree = await getAllBookmarks(account)\n              if (adapter.onSyncStart) await adapter.onSyncStart()\n              const fooFolderId = await adapter.createFolder(new Folder({parentId: serverTree.id, title: 'foo', location: ItemLocation.SERVER}))\n              const barFolderId = await adapter.createFolder(new Folder({parentId: fooFolderId, title: 'bar', location: ItemLocation.SERVER}))\n              const serverMark = {\n                title: 'url',\n                url: 'http://ur.l/',\n                parentId: barFolderId,\n                location: ItemLocation.SERVER\n              }\n              const serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n              if (adapter.onSyncComplete) await adapter.onSyncComplete()\n\n              await account.sync() // propage creation\n              expect(account.getData().error).to.not.be.ok\n              const originalTree = await account.localTree.getBookmarksTree(true)\n              await account.setData({\n                ...account.getData(),\n                strategy: 'overwrite'\n              })\n\n              await withSyncConnection(account, async() => {\n                await adapter.removeBookmark({...serverMark, id: serverMarkId})\n              })\n\n              await account.sync() // propage update\n              expect(account.getData().error).to.not.be.ok\n\n              const tree = await account.localTree.getBookmarksTree(true)\n              originalTree.title = tree.title\n              expectTreeEqual(\n                tree,\n                originalTree,\n                false\n              )\n            })\n          })\n        })\n        context('with two clients', function() {\n          this.timeout(40 * 60000) // timeout after 20mins\n          let account1, account2\n          beforeEach('set up accounts', async function() {\n            account1 = await Account.create(ACCOUNT_DATA)\n            await account1.init()\n            account2 = await Account.create(ACCOUNT_DATA)\n            await account2.init()\n\n            if (ACCOUNT_DATA.type === 'fake') {\n              // Wrire both accounts to the same fake db\n              account2.server.bookmarksCache = account1.server.bookmarksCache = new Folder(\n                { id: '', title: 'root', location: 'Server' }\n              )\n              account2.server.__defineSetter__('highestId', (id) => {\n                account1.server.highestId = id\n              })\n              account2.server.__defineGetter__('highestId', () => account1.server.highestId)\n            }\n          })\n          afterEach('clean up accounts', async function() {\n            await browser.bookmarks.removeTree(account1.getData().localRoot)\n            if (ACCOUNT_DATA.type === 'git') {\n              await account1.server.clearServer()\n            } else if (ACCOUNT_DATA.type !== 'fake') {\n              await account1.setData({\n                ...account1.getData(),\n                serverRoot: null\n              })\n              account1.lockTimeout = 0\n              await withSyncConnection(account1, async() => {\n                const tree = await account1.server.getBookmarksTree(true)\n                await AsyncParallel.each(tree.children, async child => {\n                  if (child instanceof Folder) {\n                    await account1.server.removeFolder(child)\n                  } else {\n                    await account1.server.removeBookmark(child)\n                  }\n                })\n              })\n            }\n            if (ACCOUNT_DATA.type === 'google-drive') {\n              const fileList = await account1.server.listFiles('name = ' + \"'\" + account1.server.bookmark_file + \"'\")\n              const files = fileList.files\n              for (const file of files) {\n                await account1.server.deleteFile(file.id)\n              }\n              if (files.length > 1) {\n                throw new Error('Google Drive sync left more than one file behind')\n              }\n            }\n            try {\n              await browser.bookmarks.removeTree(account1.getData().localRoot)\n            } catch (e) {\n              // noop\n            }\n            await account1.delete()\n            try {\n              await browser.bookmarks.removeTree(account2.getData().localRoot)\n            } catch (e) {\n              // noop\n            }\n            await account2.delete()\n          })\n          it('should not sync two clients at the same time', async function() {\n            if (ACCOUNT_DATA.type === 'fake') {\n              return this.skip()\n            }\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks' && ['v1.1.2', 'v2.3.4', 'stable3', 'stable4'].includes(APP_VERSION)) {\n              return this.skip()\n            }\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            // Sync once first, so the file exists on GDrive and a lock can be set\n            await account1.sync()\n\n            let sync2, resolved = false\n            console.log('Starting sync with account 1')\n            await withSyncConnection(account1, async() => {\n              console.log('Syncing account 1')\n              console.log('Starting sync with account 2')\n              sync2 = account2.sync()\n              sync2.then(() => {\n                console.log('Finished sync with account 2')\n                resolved = true\n              })\n              await new Promise(resolve => setTimeout(resolve, 60000))\n              expect(account2.getData().error).to.be.not.ok\n              expect(account2.getData().scheduled).to.be.ok\n              expect(resolved).to.equal(true)\n            })\n            console.log('Finished sync with account 1')\n            sync2 = account2.sync()\n            sync2.then(() => {\n              console.log('Finished sync with account 2')\n              resolved = true\n            })\n            await new Promise(resolve => setTimeout(resolve, 60000))\n            expect(account2.getData().error).to.be.not.ok\n            expect(account2.getData().scheduled).to.be.not.ok\n            expect(resolved).to.equal(true)\n          })\n          it('should propagate edits using \"last write wins\"', async function() {\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            await account1.sync()\n            await account2.sync()\n\n            const serverTree = await getAllBookmarks(account1)\n\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n            tree1.title = tree2.title\n            expectTreeEqual(tree1, tree2)\n            tree2.title = serverTree.title\n            expectTreeEqual(tree2, serverTree)\n\n            await browser.bookmarks.update(bookmark1.id, {\n              title: 'NEW TITLE FROM ACC1'\n            })\n            await account1.sync()\n\n            const bm2Id = (await account2.localTree.getBookmarksTree(true))\n              .children[0].children[0].children[0].id\n            const newBookmark2 = await browser.bookmarks.update(bm2Id, {\n              title: 'NEW TITLE FROM ACC2'\n            })\n            await account2.sync()\n\n            await account1.sync()\n\n            const serverTreeAfterSyncing = await getAllBookmarks(account1)\n            expectTreeEqual(\n              serverTreeAfterSyncing,\n              new Folder({\n                title: serverTreeAfterSyncing.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Folder({\n                        title: 'bar',\n                        children: [new Bookmark(newBookmark2)]\n                      })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            const tree1AfterSyncing = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterSyncing = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterSyncing,\n              tree2AfterSyncing,\n              false\n            )\n            tree2AfterSyncing.title = serverTreeAfterSyncing.title\n            expectTreeEqual(\n              tree2AfterSyncing,\n              serverTreeAfterSyncing,\n              false\n            )\n          })\n          it('should overtake moves to a different client', async function() {\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            await account2.sync()\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false\n            )\n            console.log('First round ok')\n\n            await browser.bookmarks.move(bookmark1.id, {\n              parentId: fooFolder.id\n            })\n            console.log('acc1: Moved bookmark from bar into foo')\n\n            const tree1BeforeSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n\n            const serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            const tree1AfterSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterSecondSync,\n              tree1BeforeSecondSync,\n              false\n            )\n            serverTreeAfterSecondSync.title = tree1AfterSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterSecondSync,\n              tree1AfterSecondSync,\n              false\n            )\n            console.log('Second round first half ok')\n\n            await account2.sync()\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree2AfterThirdSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              tree1AfterSecondSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2AfterThirdSync,\n              false\n            )\n            console.log('Second round second half ok')\n\n            console.log('acc1: final sync')\n            await account1.sync()\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFinalSync,\n              tree2AfterThirdSync,\n              false\n            )\n            tree2AfterThirdSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              serverTreeAfterFinalSync,\n              false\n            )\n          })\n          it('should handle creations inside deletions gracefully', async function() {\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            // remove bar folder in account2\n            await browser.bookmarks.removeTree(tree2.children[0].children[0].id)\n            await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur2.l/',\n              parentId: barFolder.id\n            })\n            console.log(\n              'acc1: Created bookmark in bar and deleted bar on the other side'\n            )\n\n            const tree2BeforeSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterThirdSync,\n              tree2BeforeSecondSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2BeforeSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2BeforeSecondSync,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree2BeforeSecondSync,\n              false\n            )\n            tree2BeforeSecondSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2BeforeSecondSync,\n              false\n            )\n          })\n          it('should handle duplicate bookmarks in different serverRoot folders', async function() {\n            if (ACCOUNT_DATA.type !== 'nextcloud-bookmarks') {\n              return this.skip()\n            }\n            await account1.setData({...account1.getData(), serverRoot: '/folder1'})\n            await account2.setData({...account2.getData(), serverRoot: '/folder2'})\n\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n\n            const localRoot2 = account2.getData().localRoot\n            const fooFolder2 = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot2\n            })\n            const barFolder2 = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder2.id\n            })\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await browser.bookmarks.create({\n              title: 'foo',\n              url: 'http://ur.l/',\n              parentId: barFolder2.id\n            })\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTree1 = await getAllBookmarks(account1)\n\n            const tree1AfterSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n\n            // Note that we compare two different trees from two different server roots\n            // here, which just happen to look the same by virtue of this test\n\n            serverTree1.title = tree1AfterSync.title\n            expectTreeEqual(\n              serverTree1,\n              tree1AfterSync,\n              false\n            )\n            expectTreeEqual(\n              tree2AfterSync,\n              tree1AfterSync,\n              false\n            )\n          })\n          it('should handle concurrent hierarchy reversals', async function() {\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: cFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: bFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: cFolder.id})\n            console.log(\n              'acc1: MOVE a ->c'\n            )\n\n            // ---\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'c').id, {parentId: tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'b').id})\n            console.log(\n              'acc2: MOVE c ->b'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle complex hierarchy reversals', async function() {\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: aFolder.id\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: localRoot\n            })\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: dFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'f',\n              parentId: dFolder.id\n            })\n            const gFolder = await browser.bookmarks.create({\n              title: 'g',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: dFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur2.l/',\n              parentId: eFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: gFolder.id})\n            console.log(\n              'acc1: MOVE a ->g'\n            )\n            await browser.bookmarks.move(dFolder.id, {parentId: cFolder.id})\n            console.log(\n              'acc1: MOVE d ->c'\n            )\n\n            // ---\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'b').children.find(i => i.title === 'c').id, {parentId: tree2.children.find(i => i.title === 'd').children.find(i => i.title === 'f').id})\n            console.log(\n              'acc2: MOVE c ->f'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'b').id, {parentId: tree2.children.find(i => i.title === 'd').children.find(i => i.title === 'e').id})\n            console.log(\n              'acc2: MOVE b ->e'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle complex hierarchy reversals 2', async function() {\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const gFolder = await browser.bookmarks.create({\n              title: 'g',\n              parentId: aFolder.id\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            const dFolder = await browser.bookmarks.create({\n              title: 'd',\n              parentId: cFolder.id\n            })\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'f',\n              parentId: eFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'h',\n              parentId: bFolder.id\n            })\n\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: dFolder.id})\n            console.log(\n              'acc1: MOVE a ->d'\n            )\n            await browser.bookmarks.remove(gFolder.id)\n            console.log(\n              'acc1: REMOVE g'\n            )\n\n            // ---\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').children.find(i => i.title === 'c').id, {parentId: tree2.children.find(i => i.title === 'b').children.find(i => i.title === 'h').id})\n            console.log(\n              'acc2: MOVE c ->h'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').id, {parentId: tree2.children.find(i => i.title === 'e').children.find(i => i.title === 'f').id})\n            console.log(\n              'acc2: MOVE b ->f'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'e').id, {parentId: tree2.children.find(i => i.title === 'a').children.find(i => i.title === 'g').id})\n            console.log(\n              'acc2: MOVE e ->g'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle faux hierarchy reversals', async function() {\n            const localRoot = account1.getData().localRoot\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: localRoot\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: bFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'd',\n              parentId: localRoot\n            })\n            const eFolder = await browser.bookmarks.create({\n              title: 'e',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: cFolder.id\n            })\n            await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: bFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.move(aFolder.id, {parentId: cFolder.id})\n            console.log(\n              'acc1: MOVE a ->c'\n            )\n\n            await browser.bookmarks.remove(eFolder.id)\n            console.log(\n              'acc1: REMOVE e'\n            )\n\n            // ---\n\n            const newFolder = await browser.bookmarks.create({\n              title: 'new',\n              parentId: tree2.children.find(i => i.title === 'e').id\n            })\n            await browser.bookmarks.create({\n              title: 'urlabyrinth',\n              url: 'http://ur2.l/',\n              parentId: newFolder.id\n            })\n            console.log('acc2: CREATE new ->e')\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').children.find(i => i.title === 'c').id, {parentId: newFolder.id})\n            console.log(\n              'acc2: MOVE c ->new'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'b').id, {parentId: tree2.children.find(i => i.title === 'a').id})\n            console.log(\n              'acc2: MOVE b ->a'\n            )\n\n            await browser.bookmarks.move(tree2.children.find(i => i.title === 'e').id, {parentId: tree2.children.find(i => i.title === 'd').id})\n            console.log(\n              'acc2: MOVE e ->d'\n            )\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should handle complex move-remove interactions', async function() {\n            const localRoot = account1.getData().localRoot\n            const zFolder = await browser.bookmarks.create({\n              title: 'z',\n              parentId: localRoot\n            })\n            const aFolder = await browser.bookmarks.create({\n              title: 'a',\n              parentId: zFolder.id\n            })\n            const bFolder = await browser.bookmarks.create({\n              title: 'b',\n              parentId: localRoot\n            })\n            const cFolder = await browser.bookmarks.create({\n              title: 'c',\n              parentId: localRoot\n            })\n            await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: aFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'urlalala',\n              url: 'http://ur.la/',\n              parentId: bFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            await account2.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false,\n              false\n            )\n            console.log('First round ok')\n\n            const newFolder = await browser.bookmarks.create({\n              title: 'new',\n              parentId: aFolder.id\n            })\n            await browser.bookmarks.move(bookmark2.id, {parentId: newFolder.id})\n            await browser.bookmarks.move(aFolder.id, {parentId: bFolder.id})\n            await browser.bookmarks.move(zFolder.id, {parentId: cFolder.id})\n\n            // ---\n\n            const tree2 = await account2.localTree.getBookmarksTree(true)\n\n            await browser.bookmarks.removeTree(tree2.children.find(i => i.title === 'z').id)\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n            const tree1AfterThirdSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            serverTreeAfterThirdSync.title = tree1AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n\n            console.log('Second round second half ok')\n\n            console.log('acc2: final sync')\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            const tree2AfterFinalSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            tree2AfterFinalSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              serverTreeAfterFinalSync,\n              tree2AfterFinalSync,\n              false,\n              false\n            )\n            tree1AfterThirdSync.title = tree2AfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterFinalSync,\n              tree1AfterThirdSync,\n              false,\n              false\n            )\n          })\n          it('should synchronize ordering', async function() {\n            if (ACCOUNT_DATA.type === 'linkwarden') {\n              return this.skip()\n            }\n            expect(\n              (await getAllBookmarks(account1)).children\n            ).to.have.lengthOf(0)\n\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const folder1 = await browser.bookmarks.create({\n              title: 'folder1',\n              parentId: fooFolder.id\n            })\n            const folder2 = await browser.bookmarks.create({\n              title: 'folder2',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url1',\n              url: 'http://ur.l/',\n              parentId: fooFolder.id\n            })\n            const bookmark2 = await browser.bookmarks.create({\n              title: 'url2',\n              url: 'http://ur.ll/',\n              parentId: fooFolder.id\n            })\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            const localTree1 = await account1.localTree.getBookmarksTree(true)\n            const localTree2 = await account2.localTree.getBookmarksTree(true)\n            localTree2.title = localTree1.title\n            expectTreeEqual(localTree1, localTree2, true, true)\n\n            await browser.bookmarks.move(bookmark1.id, { index: 0 })\n            await browser.bookmarks.move(folder1.id, { index: 1 })\n            await browser.bookmarks.move(bookmark2.id, { index: 2 })\n            await browser.bookmarks.move(folder2.id, { index: 3 })\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n\n            const secondLocalTree1 = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              secondLocalTree1,\n              new Folder({\n                title: secondLocalTree1.title,\n                children: [\n                  new Folder({\n                    title: 'foo',\n                    children: [\n                      new Bookmark({\n                        title: 'url1',\n                        url: bookmark1.url\n                      }),\n                      new Folder({\n                        title: 'folder1',\n                        children: []\n                      }),\n                      new Bookmark({\n                        title: 'url2',\n                        url: bookmark2.url\n                      }),\n                      new Folder({\n                        title: 'folder2',\n                        children: []\n                      })\n                    ]\n                  })\n                ]\n              }),\n              true,\n              true\n            )\n\n            const secondLocalTree2 = await account2.localTree.getBookmarksTree(\n              true\n            )\n            secondLocalTree2.title = secondLocalTree1.title\n            expectTreeEqual(secondLocalTree1, secondLocalTree2, true, true)\n          })\n\n          // Skipping this, because nextcloud adapter currently\n          // isn't able to track bookmarks across dirs, thus in this\n          // scenario both bookmarks survive :/\n          it('should propagate moves using \"last write wins\"', async function() {\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks') {\n              return this.skip()\n            }\n            const localRoot = account1.getData().localRoot\n            const fooFolder = await browser.bookmarks.create({\n              title: 'foo',\n              parentId: localRoot\n            })\n            const barFolder = await browser.bookmarks.create({\n              title: 'bar',\n              parentId: fooFolder.id\n            })\n            const bookmark1 = await browser.bookmarks.create({\n              title: 'url',\n              url: 'http://ur.l/',\n              parentId: barFolder.id\n            })\n            const tree1 = await account1.localTree.getBookmarksTree(true)\n            await account1.sync()\n            await account2.sync()\n\n            const serverTreeAfterFirstSync = await getAllBookmarks(account1)\n            const tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            const tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1,\n              false\n            )\n            tree2AfterFirstSync.title = tree1.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1,\n              false\n            )\n            console.log('First round ok')\n\n            await browser.bookmarks.move(bookmark1.id, {\n              parentId: fooFolder.id\n            })\n            console.log('acc1: Moved bookmark from bar into foo')\n\n            const tree1BeforeSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n\n            const serverTreeAfterSecondSync = await getAllBookmarks(account1)\n            const tree1AfterSecondSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterSecondSync,\n              tree1BeforeSecondSync,\n              false\n            )\n            serverTreeAfterSecondSync.title = tree1AfterSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterSecondSync,\n              tree1AfterSecondSync,\n              false\n            )\n            console.log('Second round first half ok')\n\n            const bm2Id = (await account2.localTree.getBookmarksTree(true))\n              .children[0].children[0].children[0].id\n            await browser.bookmarks.move(bm2Id, {\n              parentId: account2.getData().localRoot\n            })\n            console.log('acc2: Moved bookmark from bar into root')\n            const tree2BeforeThirdSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            await account2.sync()\n\n            const serverTreeAfterThirdSync = await getAllBookmarks(account1)\n            const tree2AfterThirdSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              tree2BeforeThirdSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2AfterThirdSync,\n              false\n            )\n            console.log('Second round second half ok')\n\n            console.log('acc1: final sync')\n            await account1.sync()\n\n            const serverTreeAfterFinalSync = await getAllBookmarks(account1)\n            const tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            expectTreeEqual(\n              tree1AfterFinalSync,\n              tree2AfterThirdSync,\n              false\n            )\n            tree2AfterThirdSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              serverTreeAfterFinalSync,\n              false\n            )\n          })\n        })\n\n        context('with tabs', function() {\n          if (ACCOUNT_DATA.type === 'linkwarden') {\n            return\n          }\n          let account\n          beforeEach('set up account', async function() {\n            account = await Account.create(ACCOUNT_DATA)\n            if (ACCOUNT_DATA.type === 'fake') {\n              account.server.bookmarksCache = new Folder({\n                id: '',\n                title: 'root',\n                location: 'Server'\n              })\n            }\n            await account.init()\n            await account.setData({...account.getData(), localRoot: 'tabs'})\n            if (ACCOUNT_DATA.noCache) {\n              account.storage.setCache = () => {\n                // noop\n              }\n              account.storage.setMappings = () => {\n                // noop\n              }\n            }\n          })\n          afterEach('clean up account', async function() {\n            if (!account) return\n            try {\n              await awaitTabsUpdated()\n              const tabs = await browser.tabs.query({\n                windowType: 'normal' // no devtools or panels or popups\n              })\n              await browser.tabs.remove(tabs.filter(tab => tab.url.startsWith('http')).map(tab => tab.id))\n            } catch (e) {\n              console.error(e)\n            }\n            await awaitTabsUpdated()\n            if (ACCOUNT_DATA.type === 'git') {\n              await account.server.clearServer()\n            } else if (ACCOUNT_DATA.type !== 'fake') {\n              await account.setData({ ...account.getData(), serverRoot: null })\n              account.lockTimeout = 0\n              const tree = await getAllBookmarks(account)\n              await withSyncConnection(account, async() => {\n                await AsyncParallel.each(tree.children, async child => {\n                  if (child instanceof Folder) {\n                    await account.server.removeFolder(child)\n                  } else {\n                    await account.server.removeBookmark(child)\n                  }\n                })\n              })\n            }\n            if (ACCOUNT_DATA.type === 'google-drive') {\n              const fileList = await account.server.listFiles('name = ' + \"'\" + account.server.bookmark_file + \"'\")\n              const files = fileList.files\n              for (const file of files) {\n                await account.server.deleteFile(file.id)\n              }\n              if (files.length > 1) {\n                throw new Error('Google Drive sync left more than one file behind')\n              }\n            }\n            await account.delete()\n          })\n          it('should create local tabs on the server', async function() {\n            browser.tabs.create({\n              index: 1,\n              url: 'https://example.org/#test1'\n            })\n            browser.tabs.create({\n              index: 2,\n              url: 'https://example.org/#test2'\n            })\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should create server bookmarks as tabs', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let windowFolderId, serverMark\n            await withSyncConnection(account, async() => {\n              windowFolderId = await adapter.createFolder(new Folder({\n                parentId: serverTree.id,\n                title: 'Window 0',\n                location: ItemLocation.SERVER\n              }))\n              serverMark = {\n                title: 'Example Domain',\n                url: 'https://example.org/',\n                parentId: windowFolderId,\n                location: ItemLocation.SERVER\n              }\n\n              await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            const tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update the server when pushing local changes', async function() {\n            await account.setData({...account.getData(), strategy: 'overwrite'})\n\n            browser.tabs.create({\n              index: 1,\n              url: 'https://example.org/#test1'\n            })\n            const tab = browser.tabs.create({\n              index: 2,\n              url: 'https://example.org/#test2'\n            })\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            await browser.tabs.update(tab.id, {url: 'https://example.org/#test3'})\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test3' })\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should update local tabs when pulling server changes', async function() {\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let windowFolderId, serverMark, serverMarkId\n            await withSyncConnection(account, async() => {\n              windowFolderId = await adapter.createFolder(new Folder({\n                parentId: serverTree.id,\n                title: 'Window 0',\n                location: ItemLocation.SERVER\n              }))\n              serverMark = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test1',\n                parentId: windowFolderId,\n                location: ItemLocation.SERVER\n              }\n\n              serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            let serverMark2\n            await withSyncConnection(account, async() => {\n              serverMark2 = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test3',\n                parentId: tree.children[0].id,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark2)\n              )\n\n              await adapter.updateBookmark({ ...serverMark, id: serverMarkId, url: 'https://example.org/#test2', title: 'Example Domain', parentId: tree.children[0].id })\n            })\n\n            await account.setData({...account.getData(), strategy: 'slave'})\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test3' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n          })\n          it('should sync tabs correctly when merging server and local changes', async function() {\n            if (ACCOUNT_DATA.noCache) {\n              return this.skip()\n            }\n            const adapter = account.server\n            const serverTree = await getAllBookmarks(account)\n            let windowFolderId, serverMark, serverMarkId\n            await withSyncConnection(account, async() => {\n              windowFolderId = await adapter.createFolder(new Folder({\n                parentId: serverTree.id,\n                title: 'Window 0',\n                location: ItemLocation.SERVER\n              }))\n              serverMark = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test1',\n                parentId: windowFolderId,\n                location: ItemLocation.SERVER\n              }\n\n              serverMarkId = await adapter.createBookmark(\n                new Bookmark(serverMark)\n              )\n            })\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            let tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test1' }),\n                    ]\n                  })\n                ]\n              }),\n              false\n            )\n\n            let serverMark2\n            await withSyncConnection(account, async() => {\n              serverMark2 = {\n                title: 'Example Domain',\n                url: 'https://example.org/#test3',\n                parentId: tree.children[0].id,\n                location: ItemLocation.SERVER\n              }\n              await adapter.createBookmark(\n                new Bookmark(serverMark2)\n              )\n\n              await adapter.updateBookmark({ ...serverMark, id: serverMarkId, url: 'https://example.org/#test2', title: 'Example Domain', parentId: tree.children[0].id })\n            })\n\n            await browser.tabs.create({url: 'https://example.org/#test4'})\n            await awaitTabsUpdated()\n\n            await account.sync()\n            expect(account.getData().error).to.not.be.ok\n\n            tree = await getAllBookmarks(account)\n            expectTreeEqual(\n              tree,\n              new Folder({\n                title: tree.title,\n                children: [\n                  new Folder({\n                    title: 'Window 0',\n                    children: [\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test2' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test3' }),\n                      new Bookmark({ title: 'Example Domain', url: 'https://example.org/#test4' }),\n                    ]\n                  })\n                ]\n              }),\n              false,\n              false, // We're merging which doesn't guarantee an order\n            )\n          })\n        })\n      })\n  })\n\n  ACCOUNTS.forEach(ACCOUNT_DATA => {\n    describe(`${stringifyAccountData(ACCOUNT_DATA)} benchmark ${ACCOUNT_DATA.serverRoot ? 'subfolder' : 'root'}`, function() {\n      context('with two clients', function() {\n        this.timeout(120 * 60000) // timeout after 2h\n        let account1, account2, RUN_INTERRUPTS = false\n        let timeouts = []\n        let i = 0\n        const setInterrupt = () => {\n          if (!timeouts.length) {\n            timeouts = new Array(1000).fill(0).map(() =>\n              ACCOUNT_DATA.type === 'nextcloud-bookmarks' ? random.int(50000, 150000) : random.int(100,3000)\n            )\n          }\n          const timeout = timeouts[(i++) % 1000]\n          setTimeout(() => {\n            if (RUN_INTERRUPTS) {\n              console.log('INTERRUPT! (after ' + timeout + ')')\n              account1.cancelSync()\n              account2.cancelSync()\n              setInterrupt()\n            }\n          }, timeout)\n        }\n\n        beforeEach('set up accounts', async function() {\n          let _expectTreeEqual = expectTreeEqual\n          expectTreeEqual = (tree1, tree2, ignoreEmptyFolders, checkOrder) => _expectTreeEqual(tree1, tree2, ignoreEmptyFolders, !!checkOrder)\n\n          // reset random seed\n          random.use(seedrandom(SEED))\n\n          account1 = await Account.create({...ACCOUNT_DATA, failsafe: false})\n          await account1.init()\n          account2 = await Account.create({...ACCOUNT_DATA, failsafe: false})\n          await account2.init()\n\n          if (ACCOUNT_DATA.type === 'fake') {\n            // Wire both accounts to the same fake db\n            // We do not set the cache properties to the same object, because we want to only write onSynComplete\n            let fakeServerDb = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            account1.server.bookmarksCache = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            account2.server.bookmarksCache = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            account1.server.onSyncStart = () => {\n              account1.server.bookmarksCache = fakeServerDb.clone(false)\n            }\n            account1.server.onSyncComplete = () => {\n              fakeServerDb = account1.server.bookmarksCache.clone(false)\n            }\n            account2.server.onSyncStart = () => {\n              account2.server.bookmarksCache = fakeServerDb.clone(false)\n            }\n            account2.server.onSyncComplete = () => {\n              fakeServerDb = account2.server.bookmarksCache.clone(false)\n            }\n            account2.server.__defineSetter__('highestId', (id) => {\n              account1.server.highestId = id\n            })\n            account2.server.__defineGetter__('highestId', () => account1.server.highestId)\n          }\n          if (ACCOUNT_DATA.noCache) {\n            account1.storage.setCache = () => {\n              // noop\n            }\n            account1.storage.setMappings = () => {\n              // noop\n            }\n            account2.storage.setCache = () => {\n              // noop\n            }\n            account2.storage.setMappings = () => {\n              // noop\n            }\n          }\n        })\n        afterEach('clean up accounts', async function() {\n          RUN_INTERRUPTS = false\n          await browser.bookmarks.removeTree(account1.getData().localRoot)\n          if (ACCOUNT_DATA.type === 'git') {\n            await account1.server.clearServer()\n          } else if (ACCOUNT_DATA.type !== 'fake') {\n            await account1.setData({\n              ...account1.getData(),\n              serverRoot: null\n            })\n            account1.lockTimeout = 0\n            const tree = await getAllBookmarks(account1)\n            await withSyncConnection(account1, async() => {\n              await AsyncParallel.each(tree.children, async child => {\n                if (child instanceof Folder) {\n                  await account1.server.removeFolder(child)\n                } else {\n                  await account1.server.removeBookmark(child)\n                }\n              })\n            })\n          }\n          if (ACCOUNT_DATA.type === 'google-drive') {\n            const fileList = await account1.server.listFiles('name = ' + \"'\" + account1.server.bookmark_file + \"'\")\n            const files = fileList.files\n            for (const file of files) {\n              await account1.server.deleteFile(file.id)\n            }\n            if (files.length > 1) {\n              throw new Error('Google Drive sync left more than one file behind')\n            }\n          }\n          await account1.delete()\n          await browser.bookmarks.removeTree(account2.getData().localRoot)\n          await account2.delete()\n        })\n\n        it('should handle deep hierarchies with lots of bookmarks', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks = 0\n          let folders = 0\n          let magicFolder, magicBookmark\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + k,\n                url: 'http://ur.l/' + parentId + '/' + k,\n                parentId\n              })\n              bookmarks++\n              if (bookmarks === 33) magicBookmark = newBookmark\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + k,\n                parentId\n              })\n              folders++\n              if (folders === 33) magicFolder = newFolder\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          const tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n          }\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('First round ok')\n\n          await browser.bookmarks.move(magicBookmark.id, {\n            parentId: magicFolder.id\n          })\n          console.log('acc1: Moved bookmark')\n\n          let tree1BeforeSecondSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n\n          let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n          let tree1AfterSecondSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterSecondSync,\n              tree1BeforeSecondSync,\n              false\n            )\n            serverTreeAfterSecondSync.title = tree1AfterSecondSync.title\n            expectTreeEqual(\n              serverTreeAfterSecondSync,\n              tree1AfterSecondSync,\n              false\n            )\n          }\n          tree1BeforeSecondSync = null\n          serverTreeAfterSecondSync = null\n          console.log('Second round first half ok')\n\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n\n          let serverTreeAfterThirdSync = await getAllBookmarks(account1)\n\n          let tree2AfterThirdSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              tree1AfterSecondSync,\n              false\n            )\n            serverTreeAfterThirdSync.title = tree2AfterThirdSync.title\n            expectTreeEqual(\n              serverTreeAfterThirdSync,\n              tree2AfterThirdSync,\n              false\n            )\n          }\n          serverTreeAfterThirdSync = null\n          console.log('Second round second half ok')\n\n          console.log('acc1: final sync')\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n\n          let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n          let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFinalSync,\n              tree2AfterThirdSync,\n              false\n            )\n            tree2AfterThirdSync.title = serverTreeAfterFinalSync.title\n            expectTreeEqual(\n              tree2AfterThirdSync,\n              serverTreeAfterFinalSync,\n              false\n            )\n          }\n          serverTreeAfterFinalSync = null\n          tree1AfterFinalSync = null\n        })\n\n        it('should handle fuzzed changes from one client', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks = []\n          let folders = []\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + k + ':' + j,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + k + '/' + j,\n                parentId\n              })\n              bookmarks.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          serverTreeAfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            tree2AfterFirstSync = null\n            console.log('Initial round ok')\n\n            await randomlyManipulateTree(account1, folders, bookmarks, 20)\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            serverTreeAfterSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: second local tree tree ok')\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            serverTreeAfterFinalSync = null\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n            tree2AfterSecondSync = null\n          }\n        })\n\n        it('should handle fuzzed changes from two clients', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          tree1AfterFirstSync = null\n          serverTreeAfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            tree1AfterFirstSync = null\n            serverTreeAfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTree(account1, folders1, bookmarks1, 20)\n            await randomlyManipulateTree(account2, folders2, bookmarks2, 20)\n\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1AfterSync = null\n            serverTreeAfterSync = null\n            tree1BeforeSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            if (ACCOUNT_DATA.type === 'nextcloud-bookmarks') {\n              // Extra round-trip for Nextcloud Bookmarks' different ID system\n              await account1.sync()\n              expect(account1.getData().error).to.not.be.ok\n              await account2.sync()\n              expect(account2.getData().error).to.not.be.ok\n              console.log('Extra round-trip for Nextcloud Bookmarks completed')\n            }\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            serverTreeAfterFinalSync = null\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            tree2AfterSecondSync = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n\n        it('should handle fuzzed changes with deletions from two clients', async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTreeWithDeletions(account1, folders1, bookmarks1, RANDOM_MANIPULATION_ITERATIONS)\n            await randomlyManipulateTreeWithDeletions(account2, folders2, bookmarks2, RANDOM_MANIPULATION_ITERATIONS)\n\n            console.log(' acc1&acc2: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            tree1AfterSync = null\n            serverTreeAfterSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            // Sync twice, because some removal-move mixes are hard to sort out consistently\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            console.log('second round: account2 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            serverTreeAfterInit = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n        let interruptBenchmark\n        it.skip('should handle fuzzed changes with deletions from two clients with interrupts' + (ACCOUNT_DATA.type === 'fake' ? ' (with caching)' : ''), interruptBenchmark = async function() {\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await syncAccountWithInterrupts(account1)\n          console.log('Initial round account1 completed')\n          await syncAccountWithInterrupts(account2)\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('Initial round ok')\n\n          RUN_INTERRUPTS = true\n          setInterrupt()\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            RUN_INTERRUPTS = false\n            await randomlyManipulateTreeWithDeletions(account1, folders1, bookmarks1, RANDOM_MANIPULATION_ITERATIONS)\n            await randomlyManipulateTreeWithDeletions(account2, folders2, bookmarks2, RANDOM_MANIPULATION_ITERATIONS)\n            RUN_INTERRUPTS = true\n\n            console.log(' acc1 &acc2: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await syncAccountWithInterrupts(account1)\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            tree1AfterSync = null\n            serverTreeAfterSync = null\n            console.log('first half ok')\n\n            await syncAccountWithInterrupts(account2)\n\n            // Sync twice, because some removal-move mixes are hard to sort out consistently\n            await syncAccountWithInterrupts(account2)\n\n            console.log('second round: account2 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await syncAccountWithInterrupts(account1)\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await syncAccountWithInterrupts(account1)\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            serverTreeAfterInit = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n\n        if (ACCOUNT_DATA.type === 'fake') {\n          it.skip('should handle fuzzed changes with deletions from two clients with interrupts (no caching adapter)', async function() {\n            // Wire both accounts to the same fake db\n            // We set the cache properties to the same object, because we want to simulate nextcloud-bookmarks\n            account1.server.bookmarksCache = account2.server.bookmarksCache = new Folder(\n              { id: '', title: 'root', location: 'Server' }\n            )\n            delete account1.server.onSyncStart\n            delete account1.server.onSyncComplete\n            delete account2.server.onSyncStart\n            delete account2.server.onSyncComplete\n            await interruptBenchmark()\n          })\n        }\n\n        it('unidirectional should handle fuzzed changes from two clients', async function() {\n          await account2.setData({...account2.getData(), strategy: 'slave'})\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          tree1AfterFirstSync = null\n          serverTreeAfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            tree1AfterFirstSync = null\n            serverTreeAfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTree(account1, folders1, bookmarks1, 20)\n            await randomlyManipulateTree(account2, folders2, bookmarks2, 20)\n\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSecondSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree1AfterSync,\n                false\n              )\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            serverTreeAfterFinalSync = null\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterSync,\n                serverTreeAfterInit,\n                false\n              )\n              tree1AfterInit.title = serverTreeAfterSync.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterSync,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              tree2AfterSecondSync.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterInit,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            tree2AfterSecondSync = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n\n        it('unidirectional should handle fuzzed changes with deletions from two clients', async function() {\n          await account2.setData({...account2.getData(), strategy: 'slave'})\n          const localRoot = account1.getData().localRoot\n          let bookmarks1 = []\n          let folders1 = []\n\n          let bookmarks2\n          let folders2\n\n          const createTree = async(parentId, i, j) => {\n            const len = Math.abs(i - j)\n            for (let k = i; k < j; k++) {\n              const newBookmark = await browser.bookmarks.create({\n                title: 'url' + i + ':' + j + ':' + k,\n                url: 'http://ur.l/' + parentId + '/' + i + '/' + j + '/' + k,\n                parentId\n              })\n              bookmarks1.push(newBookmark)\n            }\n\n            if (len < 4) return\n\n            const step = Math.floor(len / 4)\n            for (let k = i; k < j; k += step) {\n              const newFolder = await browser.bookmarks.create({\n                title: 'folder' + i + ':' + k + ':' + (k + step),\n                parentId\n              })\n              folders1.push(newFolder)\n              await createTree(newFolder.id, k, k + step)\n            }\n          }\n\n          await createTree(localRoot, 0, 100)\n\n          let tree1Initial = await account1.localTree.getBookmarksTree(true)\n          await account1.sync()\n          expect(account1.getData().error).to.not.be.ok\n          console.log('Initial round account1 completed')\n          await account2.sync()\n          expect(account2.getData().error).to.not.be.ok\n          console.log('Initial round account2 completed')\n\n          let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n          let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n            true\n          )\n          let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n            true\n          )\n          if (!ACCOUNT_DATA.noCache) {\n            tree1AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree1AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: first tree ok')\n            serverTreeAfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              serverTreeAfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: server tree ok')\n            tree2AfterFirstSync.title = tree1Initial.title\n            expectTreeEqual(\n              tree2AfterFirstSync,\n              tree1Initial,\n              false\n            )\n            console.log('Initial round: second tree ok')\n          }\n          tree1Initial = null\n          serverTreeAfterFirstSync = null\n          tree1AfterFirstSync = null\n          tree2AfterFirstSync = null\n          console.log('Initial round ok')\n\n          for (let j = 0; j < 4; j++) {\n            console.log('STARTING LOOP ' + j)\n\n            let serverTreeAfterFirstSync = await getAllBookmarks(account1)\n\n            let tree1AfterFirstSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            let tree2AfterFirstSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree1AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('first tree ok')\n              tree2AfterFirstSync.title = serverTreeAfterFirstSync.title\n              expectTreeEqual(\n                tree2AfterFirstSync,\n                serverTreeAfterFirstSync,\n                false\n              )\n              console.log('Initial round: second tree ok')\n            }\n            serverTreeAfterFirstSync = null\n            tree1AfterFirstSync = null\n            console.log('Initial round ok')\n\n            if (!bookmarks2) {\n              tree2AfterFirstSync.createIndex()\n              bookmarks2 = Object.values(tree2AfterFirstSync.index.bookmark)\n              folders2 = Object.values(tree2AfterFirstSync.index.folder)\n                // Make sure we don't delete the root folder :see_no_evil:\n                .filter(item => item.id !== tree2AfterFirstSync.id)\n            }\n\n            await randomlyManipulateTreeWithDeletions(account1, folders1, bookmarks1, RANDOM_MANIPULATION_ITERATIONS)\n            await randomlyManipulateTreeWithDeletions(account2, folders2, bookmarks2, RANDOM_MANIPULATION_ITERATIONS)\n\n            console.log(' acc1: Moved items')\n\n            let tree1BeforeSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('second round: account1 completed')\n\n            let serverTreeAfterSync = await getAllBookmarks(account1)\n            let tree1AfterSync = await account1.localTree.getBookmarksTree(true)\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1BeforeSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                tree1AfterSync,\n                tree1BeforeSync,\n                false\n              )\n              console.log('Second round: local tree tree ok')\n              serverTreeAfterSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                serverTreeAfterSync,\n                tree1AfterSync,\n                false\n              )\n              console.log('Second round: server tree tree ok')\n            }\n            tree1BeforeSync = null\n            console.log('first half ok')\n\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            // Sync twice, because some removal-move mixes are hard to sort out consistently\n            await account2.sync()\n            expect(account2.getData().error).to.not.be.ok\n\n            console.log('second round: account2 completed')\n\n            let serverTreeAfterSecondSync = await getAllBookmarks(account1)\n\n            let tree2AfterSecondSync = await account2.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              serverTreeAfterSync.title = serverTreeAfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                serverTreeAfterSync,\n                false\n              )\n              serverTreeAfterSecondSync.title = tree2AfterSecondSync.title\n              expectTreeEqual(\n                serverTreeAfterSecondSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Second round: second server tree tree ok')\n            }\n            serverTreeAfterSecondSync = null\n            console.log('second half ok')\n\n            console.log('final sync')\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync completed')\n\n            let serverTreeAfterFinalSync = await getAllBookmarks(account1)\n\n            let tree1AfterFinalSync = await account1.localTree.getBookmarksTree(\n              true\n            )\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterFinalSync.title = tree1AfterSync.title\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree1AfterSync,\n                false\n              )\n              tree2AfterSecondSync.title = tree1AfterFinalSync.title\n              expectTreeEqual(\n                tree1AfterFinalSync,\n                tree2AfterSecondSync,\n                false\n              )\n              console.log('Final round: local tree tree ok')\n              serverTreeAfterSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                serverTreeAfterFinalSync,\n                serverTreeAfterSync,\n                false\n              )\n              tree2AfterSecondSync.title = serverTreeAfterFinalSync.title\n              expectTreeEqual(\n                tree2AfterSecondSync,\n                serverTreeAfterFinalSync,\n                false\n              )\n              console.log('Final round: server tree tree ok')\n            }\n            tree1AfterFinalSync = null\n\n            await account1.init()\n            await account1.sync()\n            expect(account1.getData().error).to.not.be.ok\n            console.log('final sync after init completed')\n\n            let serverTreeAfterInit = await getAllBookmarks(account1)\n\n            let tree1AfterInit = await account1.localTree.getBookmarksTree(\n              true\n            )\n\n            if (!ACCOUNT_DATA.noCache) {\n              tree1AfterInit.title = serverTreeAfterInit.title\n              expectTreeEqual(\n                tree1AfterInit,\n                serverTreeAfterInit,\n                false\n              )\n              tree1AfterInit.title = tree1AfterSync.title\n              expectTreeEqual(\n                tree1AfterInit,\n                tree1AfterSync,\n                false\n              )\n              console.log('Final round after init: local tree ok')\n              serverTreeAfterInit.title = serverTreeAfterSync.title\n              expectTreeEqual(\n                serverTreeAfterInit,\n                serverTreeAfterSync,\n                false\n              )\n              console.log('Final round after init: server tree ok')\n            }\n            serverTreeAfterInit = null\n            tree1AfterInit = null\n            serverTreeAfterInit = null\n          }\n        })\n      })\n    })\n  })\n})\n\nfunction hasNoBookmarks(child) {\n  if (child instanceof Bookmark) return false\n  else return !child.children.some(child => !hasNoBookmarks(child))\n}\n\nasync function getAllBookmarks(account) {\n  let tree\n  await withSyncConnection(account, async() => {\n    tree = await account.server.getBookmarksTree(true)\n  })\n  return tree\n}\n\nasync function withSyncConnection(account, fn) {\n  const adapter = account.server\n  if (adapter.onSyncStart) await adapter.onSyncStart()\n  await fn()\n  if (adapter.onSyncComplete) await adapter.onSyncComplete()\n}\n\nasync function randomlyManipulateTree(account, folders, bookmarks, iterations) {\n  for (let i = 0; i < iterations; i++) {\n    let magicBookmark\n    let magicFolder1\n    let magicFolder2\n    let magicFolder3\n    let magicFolder4\n    let magicFolder5\n    try {\n      // Randomly move one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      magicFolder1 = folders[random.int(0, folders.length - 1)]\n      await browser.bookmarks.move(magicBookmark.id, {\n        parentId: magicFolder1.id\n      })\n      console.log('Move ' + magicBookmark.title + ' to ' + magicFolder1.id)\n\n      // Randomly move two folders\n      magicFolder2 = folders[random.int(0, folders.length - 1)]\n      magicFolder3 = folders[random.int(0, folders.length - 1)]\n      if (magicFolder2 === magicFolder3) {\n        continue\n      }\n      const tree2 = (await browser.bookmarks.getSubTree(magicFolder2.id))[0]\n      const root = (await browser.bookmarks.getSubTree(account.getData().localRoot))[0]\n      if (Folder.hydrate(tree2).findFolder(magicFolder3.id)) {\n        continue\n      }\n      if (!Folder.hydrate(root).findFolder(magicFolder3.id)) { // This folder is not in our tree anymore for some reason\n        continue\n      }\n      await browser.bookmarks.move(magicFolder2.id, {\n        parentId: magicFolder3.id\n      })\n      console.log('Move #' + magicFolder2.id + '[' + magicFolder2.title + '] to ' + magicFolder3.id)\n\n      // Randomly create a folder\n      magicFolder4 = folders[random.int(0, folders.length - 1)]\n      const newFolder = await browser.bookmarks.create({\n        title: 'newFolder' + Math.random(),\n        parentId: magicFolder4.id\n      })\n      folders.push(newFolder)\n      console.log('Created #' + newFolder.id + '[' + newFolder.title + '] in ' + magicFolder4.id)\n\n      magicFolder5 = folders[random.int(0, folders.length - 1)]\n      const newBookmark = await browser.bookmarks.create({\n        title: 'newBookmark' + Math.random(),\n        url: 'http://ur.l/' + magicFolder5.id + '/' + Math.random(),\n        parentId: magicFolder5.id\n      })\n      bookmarks.push(newBookmark)\n      console.log('Created #' + newBookmark.id + '[' + newBookmark.title + '] in ' + magicFolder5.id)\n    } catch (e) {\n      console.log(e)\n    }\n  }\n}\n\nasync function randomlyManipulateTreeWithDeletions(account, folders, bookmarks, iterations) {\n  for (let i = 0; i < iterations; i++) {\n    let magicBookmark\n    let magicFolder1\n    let magicFolder2\n    let magicFolder3\n    let magicFolder4\n    let magicFolder5\n    try {\n      // Randomly remove one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      await browser.bookmarks.remove(magicBookmark.id)\n      bookmarks.splice(bookmarks.indexOf(magicBookmark), 1)\n      console.log('Remove ' + magicBookmark.title)\n\n      // Randomly rename one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      const newTitle = 'renamed' + Math.random()\n      await browser.bookmarks.update(magicBookmark.id, {title: newTitle})\n      console.log('Rename #' + magicBookmark.id + '[' + magicBookmark.title + '] to ' + newTitle)\n\n      // randomly remove one folder\n      magicFolder1 = folders[random.int(0, folders.length - 1)]\n      await browser.bookmarks.removeTree(magicFolder1.id)\n      folders.splice(folders.indexOf(magicFolder1), 1)\n      console.log('Removed #' + magicFolder1.id + '[' + magicFolder1.title + ']')\n\n      // Randomly move one bookmark\n      magicBookmark = bookmarks[random.int(0, bookmarks.length - 1)]\n      magicFolder1 = folders[random.int(0, folders.length - 1)]\n      await browser.bookmarks.move(magicBookmark.id, {\n        parentId: magicFolder1.id\n      })\n      console.log('Move ' + magicBookmark.title + ' to ' + magicFolder1.id)\n\n      // Randomly move two folders\n      magicFolder2 = folders[random.int(0, folders.length - 1)]\n      magicFolder3 = folders[random.int(0, folders.length - 1)]\n      if (magicFolder2 === magicFolder3) {\n        continue\n      }\n      const tree2 = (await browser.bookmarks.getSubTree(magicFolder2.id))[0]\n      const root = (await browser.bookmarks.getSubTree(account.getData().localRoot))[0]\n      if (Folder.hydrate(tree2).findFolder(magicFolder3.id)) {\n        continue\n      }\n      if (!Folder.hydrate(root).findFolder(magicFolder3.id)) { // This folder is not in our tree anymore for some reason\n        continue\n      }\n      await browser.bookmarks.move(magicFolder2.id, {\n        parentId: magicFolder3.id\n      })\n      console.log('Move #' + magicFolder2.id + '[' + magicFolder2.title + '] to ' + magicFolder3.id)\n\n      // Randomly create a folder\n      magicFolder4 = folders[random.int(0, folders.length - 1)]\n      const newFolder = await browser.bookmarks.create({\n        title: 'newFolder' + Math.random(),\n        parentId: magicFolder4.id\n      })\n      folders.push(newFolder)\n      console.log('Created #' + newFolder.id + '[' + newFolder.title + '] in ' + magicFolder4.id)\n\n      // Randomly create a bookmark\n      magicFolder5 = folders[random.int(0, folders.length - 1)]\n      const newBookmark = await browser.bookmarks.create({\n        title: 'newBookmark' + Math.random(),\n        url: 'http://ur.l/' + magicFolder5.id + '/' + Math.random(),\n        parentId: magicFolder5.id\n      })\n      bookmarks.push(newBookmark)\n      console.log('Created #' + newBookmark.id + '[' + newBookmark.title + '] in ' + magicFolder5.id)\n    } catch (e) {\n      console.log(e)\n    }\n  }\n}\n\nasync function syncAccountWithInterrupts(account) {\n  await account.sync()\n  try {\n    expect(account.getData().error).to.not.be.ok\n  } catch (e) {\n    if (!account.getData().error.includes('E026') && !account.getData().error.includes('E027')) {\n      throw e\n    } else {\n      console.log(account.getData().error)\n      account.lockTimeout = 0\n      await syncAccountWithInterrupts(account)\n    }\n  }\n}\n\nfunction stringifyAccountData(ACCOUNT_DATA) {\n  return `${ACCOUNT_DATA.type}${\n    (ACCOUNT_DATA.noCache ? '-noCache' : '') +\n    (typeof ACCOUNT_DATA.bookmark_file_type !== 'undefined' ? '-' + ACCOUNT_DATA.bookmark_file_type : '') +\n    ((ACCOUNT_DATA.type === 'google-drive' && ACCOUNT_DATA.password) || (ACCOUNT_DATA.type === 'webdav' && ACCOUNT_DATA.passphrase) ? '-encrypted' : '')\n  }`\n}\n\nfunction awaitTabsUpdated() {\n  return Promise.race([\n    new Promise(resolve => {\n      browser.tabs.onUpdated.addListener(() => {\n        browser.tabs.onUpdated.removeListener(resolve)\n        setTimeout(() => resolve(), 1000)\n      })\n    }),\n    new Promise(resolve => setTimeout(resolve, 1100))\n  ])\n}\n"],"names":["Logger","log","logMsg","Date","toISOString","arguments","this","messages","push","util","apply","persist","Storage","Capacitor","getPlatform","default","changeEntry","getLogs","getEntry","anonymizeLogs","logs","regex","newLogs","Parallel","async","replaceAsync","entry","match","p1","p2","p3","Crypto","regex2","regex3","map","line","replace","str","asyncFn","promises","data","_len","length","args","Array","_key","promise","Promise","all","e","console","error","shift","downloadLogs","anonymous","undefined","blob","Blob","join","type","endings","download","packageJson","slice","filename","element","document","createElement","objectUrl","URL","createObjectURL","setAttribute","style","display","body","appendChild","click","revokeObjectURL","removeChild","uri","fileURI","Filesystem","writeFile","path","text","encoding","Encoding","UTF8","directory","Directory","External","recursive","Share","share","title","files","FakeAdapter","CachingAdapter","constructor","server","super","getDefaultValues","setData","getData","JSON","parse","stringify","getLabel","storageLock","AsyncLock","BrowserAccountStorage","id","accountId","entryName","fn","defaultVal","acquire","browser","storage","local","set","get","deleteEntry","remove","getAllAccounts","accounts","Object","keys","getAccountData","key","iv","password","DefunctCryptography","decryptAES","Cryptography","username","passphrase","setAccountData","encData","deleteAccountData","deleteCache","deleteMappings","initCache","getCache","Folder","hydrate","location","ItemLocation","LOCAL","setCache","initMappings","getMappings","Mappings","bookmarks","ServerToLocal","LocalToServer","folders","setMappings","getCurrentContinuation","setCurrentContinuation","continuation","_","createdAt","now","chai","chaiAsPromised","expect","expectTreeEqual","tree1","tree2","ignoreEmptyFolders","checkOrder","to","equal","url","children","sort","a","b","children1","filter","child","hasNoBookmarks","children2","have","forEach","child2","i","inspect","Bookmark","some","getAllBookmarks","account","tree","withSyncConnection","getBookmarksTree","adapter","onSyncStart","onSyncComplete","randomlyManipulateTree","iterations","magicBookmark","magicFolder1","magicFolder2","magicFolder3","magicFolder4","magicFolder5","random","move","parentId","getSubTree","root","localRoot","findFolder","newFolder","create","Math","newBookmark","randomlyManipulateTreeWithDeletions","splice","indexOf","newTitle","update","removeTree","syncAccountWithInterrupts","sync","not","be","ok","includes","lockTimeout","stringifyAccountData","ACCOUNT_DATA","noCache","bookmark_file_type","awaitTabsUpdated","race","resolve","tabs","onUpdated","addListener","removeListener","setTimeout","describe","timeout","slow","params","window","href","searchParams","SERVER","CREDENTIALS","ACCOUNTS","APP_VERSION","SEED","BROWSER","RANDOM_MANIPULATION_ITERATIONS","seedrandom","serverRoot","bookmark_file","branch","refreshToken","serverFolder","before","Controller","setEnabled","after","it","salt","message","payload","cleartext","DefunctCrypto","encryptAES","beforeEach","Account","afterEach","delete","secondInstance","deep","rejected","isInitialized","false","context","bookmarksCache","init","clearServer","AsyncParallel","removeFolder","removeBookmark","listFiles","file","deleteFile","Error","fooFolder","barFolder","bookmark","Boolean","orderFolder","bookmark2","skip","newData","bookmark1","lengthOf","serverTree","fooFolderId","barFolderId","serverMark","createFolder","createBookmark","serverMarkId","newServerMark","updateBookmark","syncPromise","bookmarkData","serverMark1","serverMark2","localMark1","localMark2","bookmark3","bookmark4","localTree","subFolder","topFolder","aFolder","bFolder","cFolder","dFolder","eFolder","fFolder","initialTree","updateFolder","cFolder1","cFolder2","aFolderId","bookmark1Id","bFolderId","bookmark2Id","findBookmark","getTree","newRoot","flatMap","originalFolderId","secondBookmarkFolderTitle","find","folder","secondBookmark","toLowerCase","item","localTreeAfterSync","folder1","folder2","index","strategy","originalTree","bazFolder","barazFolder","account1","account2","__defineSetter__","highestId","__defineGetter__","sync2","resolved","then","scheduled","bm2Id","newBookmark2","serverTreeAfterSyncing","tree1AfterSyncing","tree2AfterSyncing","serverTreeAfterFirstSync","tree1AfterFirstSync","tree2AfterFirstSync","tree1BeforeSecondSync","serverTreeAfterSecondSync","tree1AfterSecondSync","serverTreeAfterThirdSync","tree2AfterThirdSync","serverTreeAfterFinalSync","tree1AfterFinalSync","tree2BeforeSecondSync","tree1AfterThirdSync","tree2AfterFinalSync","localRoot2","fooFolder2","barFolder2","serverTree1","tree1AfterSync","tree2AfterSync","gFolder","zFolder","localTree1","localTree2","secondLocalTree1","secondLocalTree2","tree2BeforeThirdSync","query","windowType","tab","startsWith","windowFolderId","RUN_INTERRUPTS","timeouts","setInterrupt","fill","cancelSync","interruptBenchmark","_expectTreeEqual","failsafe","fakeServerDb","clone","magicFolder","createTree","j","len","abs","k","step","floor","tree1Initial","tree1BeforeSync","serverTreeAfterSync","tree2AfterSecondSync","serverTreeAfterInit","tree1AfterInit","bookmarks2","folders2","bookmarks1","folders1","createIndex","values"],"sourceRoot":""}