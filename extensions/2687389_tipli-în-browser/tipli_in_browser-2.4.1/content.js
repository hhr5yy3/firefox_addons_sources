// noinspection Duplicates
'use strict';

const MessageTypes = {
  BASIC_DATA_REQUEST: 'BASIC_DATA_REQUEST',
  BASIC_DATA_RESPONSE: 'BASIC_DATA_RESPONSE',
  CONTENTS_REQUEST: 'CONTENTS_REQUEST',
  CONTENTS_RESPONSE: 'CONTENTS_RESPONSE',
  INSTRUCTIONS_REQUEST: 'INSTRUCTIONS_REQUEST',
  INSTRUCTIONS_RESPONSE: 'INSTRUCTIONS_RESPONSE',
  UPDATE_PREFERENCES_REQUEST: 'UPDATE_PREFERENCES_REQUEST',
  UPDATE_PREFERENCES_RESPONSE: 'UPDATE_PREFERENCES_RESPONSE',
  CONTROL_ICON_CLICK: 'CONTROL_ICON_CLICK',
  EMPTY_RESPONSE: 'EMPTY_RESPONSE',
  POPUP_BOX_OPEN: 'POPUP_BOX_OPEN',
  SERP_REQUEST: 'SERP_REQUEST',
  SERP_RESPONSE: 'SERP_RESPONSE',
  FEED_META_REQUEST: 'FEED_REQUEST',
  FEED_META_RESPONSE: 'FEED_RESPONSE',
  MANIFEST_REQUEST: 'MANIFEST_REQUEST',
  MANIFEST_RESPONSE: 'MANIFEST_RESPONSE',
  RESTORE_EXTENSION: 'RESTORE_EXTENSION',
  BLACKLIST_URL: 'BLACK_LIST_URL',
  BLACKLIST_REMOVE_URL: 'BLACKLIST_REMOVE_URL',
  DOMAIN_PREFERENCES: 'DOMAIN_PREFERENCES',
  DOMAIN_PREFERENCE_REMOVED: 'DOMAIN_PREFERENCE_REMOVED',
  REFRESH_FEED_REQUEST: 'REFRESH_FEED_REQUEST',
  REFRESH_FEED_RESPONSE: 'REFRESH_FEED_RESPONSE',
};

const ControlIconTypes = {
  CLOSE: 'close',
  HIDE: 'hide',
};

/*
 * Library of common units
 */

window.browser = window.browser || chrome;

function sendBackgroundMessage(type, payload, extensionId) {
  const empty = {}; // allow response destruction
  return new Promise(resolve => {
    const callback = response => resolve(response || empty);
    browser.runtime.sendMessage(extensionId, { type, payload }, callback);
  });
}

function stringToHash(string) {
  let hash = 0, i, chr = null;
  for (i = 0; i < string.length; i++) {
    chr = string.charCodeAt(i);
    hash = ((hash << 5) - hash) + chr;
    hash |= 0; // Convert to 32bit integer
  }
  return hash;
}

function classNames(...args) {
  const classes = [];
  const hasOwn = {}.hasOwnProperty;

  for (const arg of args) {
    if (!arg) continue;

    const argType = typeof arg;

    if (argType === 'string' || argType === 'number') {
      classes.push(arg);
    } else if (Array.isArray(arg) && arg.length) {
      const inner = classNames.apply(null, arg);
      if (inner) {
        classes.push(inner);
      }
    } else if (argType === 'object') {
      if (arg.toString !== Object.prototype.toString) {
        classes.push(arg.toString());
      } else {
        for (const key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes.push(key);
          }
        }
      }
    }
  }

  return classes.join(' ');
}

function localeUrlToTipliName(url) {
  const { host } = new URL(url);
  return host.split('.')[1];
}

/**
 * marked - a markdown parser
 * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var defaults = createCommonjsModule(function (module) {
function getDefaults() {
  return {
    baseUrl: null,
    breaks: false,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}

function changeDefaults(newDefaults) {
  module.exports.defaults = newDefaults;
}

module.exports = {
  defaults: getDefaults(),
  getDefaults,
  changeDefaults
};
});

/**
 * Helpers
 */
const escapeTest = /[&<>"']/;
const escapeReplace = /[&<>"']/g;
const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
const escapeReplacements = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }

  return html;
}

const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

function unescape(html) {
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

const caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = regex.source || regex;
  opt = opt || '';
  const obj = {
    replace: (name, val) => {
      val = val.source || val;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}

const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape(href))
        .replace(nonWordAndColonTest, '')
        .toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, '%');
  } catch (e) {
    return null;
  }
  return href;
}

const baseUrls = {};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

function resolveUrl(base, href) {
  if (!baseUrls[' ' + base]) {
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (justDomain.test(base)) {
      baseUrls[' ' + base] = base + '/';
    } else {
      baseUrls[' ' + base] = rtrim(base, '/', true);
    }
  }
  base = baseUrls[' ' + base];
  const relativeBase = base.indexOf(':') === -1;

  if (href.substring(0, 2) === '//') {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, '$1') + href;
  } else if (href.charAt(0) === '/') {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, '$1') + href;
  } else {
    return base + href;
  }
}

const noopTest = { exec: function noopTest() {} };

function merge(obj) {
  let i = 1,
    target,
    key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}

function splitCells(tableRow, count) {
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
      let escaped = false,
        curr = offset;
      while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
      if (escaped) {
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
      } else {
        // add space before unescaped |
        return ' |';
      }
    }),
    cells = row.split(/ \|/);
  let i = 0;

  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count) cells.push('');
  }

  for (; i < cells.length; i++) {
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
  }
  return cells;
}

// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
// /c*$/ is vulnerable to REDOS.
// invert: Remove suffix of non-c chars instead. Default falsey.
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return '';
  }

  // Length of suffix matching the invert condition.
  let suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }

  return str.substr(0, l - suffLen);
}

function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0,
    i = 0;
  for (; i < l; i++) {
    if (str[i] === '\\') {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}

function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
  }
}

// copied from https://stackoverflow.com/a/5450113/806777
function repeatString(pattern, count) {
  if (count < 1) {
    return '';
  }
  let result = '';
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}

var helpers = {
  escape,
  unescape,
  edit,
  cleanUrl,
  resolveUrl,
  noopTest,
  merge,
  splitCells,
  rtrim,
  findClosingBracket,
  checkSanitizeDeprecation,
  repeatString
};

const { defaults: defaults$1 } = defaults;
const {
  rtrim: rtrim$1,
  splitCells: splitCells$1,
  escape: escape$1,
  findClosingBracket: findClosingBracket$1
} = helpers;

function outputLink(cap, link, raw) {
  const href = link.href;
  const title = link.title ? escape$1(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, '$1');

  if (cap[0].charAt(0) !== '!') {
    return {
      type: 'link',
      raw,
      href,
      title,
      text
    };
  } else {
    return {
      type: 'image',
      raw,
      href,
      title,
      text: escape$1(text)
    };
  }
}

function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);

  if (matchIndentToCode === null) {
    return text;
  }

  const indentToCode = matchIndentToCode[1];

  return text
    .split('\n')
    .map(node => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }

      const [indentInNode] = matchIndentInNode;

      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }

      return node;
    })
    .join('\n');
}

/**
 * Tokenizer
 */
var Tokenizer_1 = class Tokenizer {
  constructor(options) {
    this.options = options || defaults$1;
  }

  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap) {
      if (cap[0].length > 1) {
        return {
          type: 'space',
          raw: cap[0]
        };
      }
      return { raw: '\n' };
    }
  }

  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, '');
      return {
        type: 'code',
        raw: cap[0],
        codeBlockStyle: 'indented',
        text: !this.options.pedantic
          ? rtrim$1(text, '\n')
          : text
      };
    }
  }

  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || '');

      return {
        type: 'code',
        raw,
        lang: cap[2] ? cap[2].trim() : cap[2],
        text
      };
    }
  }

  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();

      // remove trailing #s
      if (/#$/.test(text)) {
        const trimmed = rtrim$1(text, '#');
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          // CommonMark requires space before trailing #s
          text = trimmed.trim();
        }
      }

      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text: text
      };
    }
  }

  nptable(src) {
    const cap = this.rules.block.nptable.exec(src);
    if (cap) {
      const item = {
        type: 'table',
        header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
        raw: cap[0]
      };

      if (item.header.length === item.align.length) {
        let l = item.align.length;
        let i;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        l = item.cells.length;
        for (i = 0; i < l; i++) {
          item.cells[i] = splitCells$1(item.cells[i], item.header.length);
        }

        return item;
      }
    }
  }

  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: 'hr',
        raw: cap[0]
      };
    }
  }

  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ *> ?/gm, '');

      return {
        type: 'blockquote',
        raw: cap[0],
        text
      };
    }
  }

  list(src) {
    const cap = this.rules.block.list.exec(src);
    if (cap) {
      let raw = cap[0];
      const bull = cap[2];
      const isordered = bull.length > 1;

      const list = {
        type: 'list',
        raw,
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : '',
        loose: false,
        items: []
      };

      // Get each top-level item.
      const itemMatch = cap[0].match(this.rules.block.item);

      let next = false,
        item,
        space,
        bcurr,
        bnext,
        addBack,
        loose,
        istask,
        ischecked,
        endMatch;

      let l = itemMatch.length;
      bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);
      for (let i = 0; i < l; i++) {
        item = itemMatch[i];
        raw = item;

        if (!this.options.pedantic) {
          // Determine if current item contains the end of the list
          endMatch = item.match(new RegExp('\\n\\s*\\n {0,' + (bcurr[0].length - 1) + '}\\S'));
          if (endMatch) {
            addBack = item.length - endMatch.index + itemMatch.slice(i + 1).join('\n').length;
            list.raw = list.raw.substring(0, list.raw.length - addBack);

            item = item.substring(0, endMatch.index);
            raw = item;
            l = i + 1;
          }
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (i !== l - 1) {
          bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);
          if (
            !this.options.pedantic
              ? bnext[1].length >= bcurr[0].length || bnext[1].length > 3
              : bnext[1].length > bcurr[1].length
          ) {
            // nested list or continuation
            itemMatch.splice(i, 2, itemMatch[i] + (!this.options.pedantic && bnext[1].length < bcurr[0].length && !itemMatch[i].match(/\n$/) ? '' : '\n') + itemMatch[i + 1]);
            i--;
            l--;
            continue;
          } else if (
            // different bullet style
            !this.options.pedantic || this.options.smartLists
              ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1]
              : isordered === (bnext[2].length === 1)
          ) {
            addBack = itemMatch.slice(i + 1).join('\n').length;
            list.raw = list.raw.substring(0, list.raw.length - addBack);
            i = l - 1;
          }
          bcurr = bnext;
        }

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+[.)]) ?/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // trim item newlines at end
        item = rtrim$1(item, '\n');
        if (i !== l - 1) {
          raw = raw + '\n';
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(raw);
        if (i !== l - 1) {
          next = raw.slice(-2) === '\n\n';
          if (!loose) loose = next;
        }

        if (loose) {
          list.loose = true;
        }

        // Check for task list items
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.test(item);
          ischecked = undefined;
          if (istask) {
            ischecked = item[1] !== ' ';
            item = item.replace(/^\[[ xX]\] +/, '');
          }
        }

        list.items.push({
          type: 'list_item',
          raw,
          task: istask,
          checked: ischecked,
          loose: loose,
          text: item
        });
      }

      return list;
    }
  }

  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      return {
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        raw: cap[0],
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0])) : cap[0]
      };
    }
  }

  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
      const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      return {
        tag,
        raw: cap[0],
        href: cap[2],
        title: cap[3]
      };
    }
  }

  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      const item = {
        type: 'table',
        header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
      };

      if (item.header.length === item.align.length) {
        item.raw = cap[0];

        let l = item.align.length;
        let i;
        for (i = 0; i < l; i++) {
          if (/^ *-+: *$/.test(item.align[i])) {
            item.align[i] = 'right';
          } else if (/^ *:-+: *$/.test(item.align[i])) {
            item.align[i] = 'center';
          } else if (/^ *:-+ *$/.test(item.align[i])) {
            item.align[i] = 'left';
          } else {
            item.align[i] = null;
          }
        }

        l = item.cells.length;
        for (i = 0; i < l; i++) {
          item.cells[i] = splitCells$1(
            item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
            item.header.length);
        }

        return item;
      }
    }
  }

  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: 'heading',
        raw: cap[0],
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1]
      };
    }
  }

  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      return {
        type: 'paragraph',
        raw: cap[0],
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      };
    }
  }

  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: 'text',
        raw: cap[0],
        text: cap[0]
      };
    }
  }

  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: 'escape',
        raw: cap[0],
        text: escape$1(cap[1])
      };
    }
  }

  tag(src, inLink, inRawBlock) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!inLink && /^<a /i.test(cap[0])) {
        inLink = true;
      } else if (inLink && /^<\/a>/i.test(cap[0])) {
        inLink = false;
      }
      if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        inRawBlock = true;
      } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        inRawBlock = false;
      }

      return {
        type: this.options.sanitize
          ? 'text'
          : 'html',
        raw: cap[0],
        inLink,
        inRawBlock,
        text: this.options.sanitize
          ? (this.options.sanitizer
            ? this.options.sanitizer(cap[0])
            : escape$1(cap[0]))
          : cap[0]
      };
    }
  }

  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        // commonmark requires matching angle brackets
        if (!(/>$/.test(trimmedUrl))) {
          return;
        }

        // ending angle bracket cannot be escaped
        const rtrimSlash = rtrim$1(trimmedUrl.slice(0, -1), '\\');
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        // find closing parenthesis
        const lastParenIndex = findClosingBracket$1(cap[2], '()');
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf('!') === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = '';
        }
      }
      let href = cap[2];
      let title = '';
      if (this.options.pedantic) {
        // split pedantic href and title
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : '';
      }

      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {
          // pedantic allows starting angle bracket without ending angle bracket
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
        title: title ? title.replace(this.rules.inline._escapes, '$1') : title
      }, cap[0]);
    }
  }

  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src))
        || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link || !link.href) {
        const text = cap[0].charAt(0);
        return {
          type: 'text',
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0]);
    }
  }

  emStrong(src, maskedSrc, prevChar = '') {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;

    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return; // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

    const nextChar = match[1] || match[2] || '';

    if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;

      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;

      maskedSrc = maskedSrc.slice(-1 * src.length + lLength); // Bump maskedSrc to same section of string as src (move to lexer?)

      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];

        if (!rDelim) continue; // matched the first alternative in rules.js (skip the * in __abc*abc__)

        rLength = rDelim.length;

        if (match[3] || match[4]) { // found another Left Delim
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) { // either Left or Right Delim
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue; // CommonMark Emphasis Rules 9-10
          }
        }

        delimTotal -= rLength;

        if (delimTotal > 0) continue; // Haven't found enough closing delimiters

        // If this is the last rDelimiter, remove extra characters. *a*** -> *a*
        if (delimTotal + midDelimTotal - rLength <= 0 && !maskedSrc.slice(endReg.lastIndex).match(endReg)) {
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        }

        if (Math.min(lLength, rLength) % 2) {
          return {
            type: 'em',
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: src.slice(1, lLength + match.index + rLength)
          };
        }
        if (Math.min(lLength, rLength) % 2 === 0) {
          return {
            type: 'strong',
            raw: src.slice(0, lLength + match.index + rLength + 1),
            text: src.slice(2, lLength + match.index + rLength - 1)
          };
        }
      }
    }
  }

  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, ' ');
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape$1(text, true);
      return {
        type: 'codespan',
        raw: cap[0],
        text
      };
    }
  }

  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: 'br',
        raw: cap[0]
      };
    }
  }

  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: 'del',
        raw: cap[0],
        text: cap[2]
      };
    }
  }

  autolink(src, mangle) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === '@') {
        text = escape$1(this.options.mangle ? mangle(cap[1]) : cap[1]);
        href = 'mailto:' + text;
      } else {
        text = escape$1(cap[1]);
        href = text;
      }

      return {
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: 'text',
            raw: text,
            text
          }
        ]
      };
    }
  }

  url(src, mangle) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === '@') {
        text = escape$1(this.options.mangle ? mangle(cap[0]) : cap[0]);
        href = 'mailto:' + text;
      } else {
        // do extended autolink path validation
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape$1(cap[0]);
        if (cap[1] === 'www.') {
          href = 'http://' + text;
        } else {
          href = text;
        }
      }
      return {
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: 'text',
            raw: text,
            text
          }
        ]
      };
    }
  }

  inlineText(src, inRawBlock, smartypants) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (inRawBlock) {
        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$1(cap[0])) : cap[0];
      } else {
        text = escape$1(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
      }
      return {
        type: 'text',
        raw: cap[0],
        text
      };
    }
  }
};

const {
  noopTest: noopTest$1,
  edit: edit$1,
  merge: merge$1
} = helpers;

/**
 * Block-Level Grammar
 */
const block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
  html: '^ {0,3}(?:' // optional indentation
    + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
    + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
    + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
    + ')',
  def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
  nptable: noopTest$1,
  table: noopTest$1,
  lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};

block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit$1(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
block.item = edit$1(block.item, 'gm')
  .replace(/bull/g, block.bullet)
  .getRegex();

block.listItemStart = edit$1(/^( *)(bull) */)
  .replace('bull', block.bullet)
  .getRegex();

block.list = edit$1(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
  + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit$1(block.html, 'i')
  .replace('comment', block._comment)
  .replace('tag', block._tag)
  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
  .getRegex();

block.paragraph = edit$1(block._paragraph)
  .replace('hr', block.hr)
  .replace('heading', ' {0,3}#{1,6} ')
  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('blockquote', ' {0,3}>')
  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();

block.blockquote = edit$1(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge$1({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge$1({}, block.normal, {
  nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
    + ' {0,3}([-:]+ *\\|[-| :]*)' // Align
    + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)', // Cells
  table: '^ *\\|(.+)\\n' // Header
    + ' {0,3}\\|?( *[-:]+[-| :]*)' // Align
    + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
});

block.gfm.nptable = edit$1(block.gfm.nptable)
  .replace('hr', block.hr)
  .replace('heading', ' {0,3}#{1,6} ')
  .replace('blockquote', ' {0,3}>')
  .replace('code', ' {4}[^\\n]')
  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();

block.gfm.table = edit$1(block.gfm.table)
  .replace('hr', block.hr)
  .replace('heading', ' {0,3}#{1,6} ')
  .replace('blockquote', ' {0,3}>')
  .replace('code', ' {4}[^\\n]')
  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();

/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = merge$1({}, block.normal, {
  html: edit$1(
    '^ *(?:comment *(?:\\n|\\s*$)'
    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
    .replace('comment', block._comment)
    .replace(/tag/g, '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest$1, // fences not supported
  paragraph: edit$1(block.normal._paragraph)
    .replace('hr', block.hr)
    .replace('heading', ' *#{1,6} *[^\n]')
    .replace('lheading', block.lheading)
    .replace('blockquote', ' {0,3}>')
    .replace('|fences', '')
    .replace('|list', '')
    .replace('|html', '')
    .getRegex()
});

/**
 * Inline-Level Grammar
 */
const inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest$1,
  tag: '^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
  nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
  reflinkSearch: 'reflink|nolink(?!\\()',
  emStrong: {
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //        () Skip other delimiter (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /\_\_[^_]*?\*[^_]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
    rDelimUnd: /\*\*[^*]*?\_[^*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest$1,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^([\spunctuation])/
};

// list of punctuation marks from CommonMark spec
// without * and _ to handle the different emphasis markers * and _
inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

// sequences em should skip over [title](link), `code`, <html>
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
inline.escapedEmSt = /\\\*|\\_/g;

inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();

inline.emStrong.lDelim = edit$1(inline.emStrong.lDelim)
  .replace(/punct/g, inline._punctuation)
  .getRegex();

inline.emStrong.rDelimAst = edit$1(inline.emStrong.rDelimAst, 'g')
  .replace(/punct/g, inline._punctuation)
  .getRegex();

inline.emStrong.rDelimUnd = edit$1(inline.emStrong.rDelimUnd, 'g')
  .replace(/punct/g, inline._punctuation)
  .getRegex();

inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit$1(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

inline.tag = edit$1(inline.tag)
  .replace('comment', inline._comment)
  .replace('attribute', inline._attribute)
  .getRegex();

inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

inline.link = edit$1(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit$1(inline.reflink)
  .replace('label', inline._label)
  .getRegex();

inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g')
  .replace('reflink', inline.reflink)
  .replace('nolink', inline.nolink)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge$1({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge$1({}, inline.normal, {
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit$1(/^!?\[(label)\]\((.*?)\)/)
    .replace('label', inline._label)
    .getRegex(),
  reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace('label', inline._label)
    .getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge$1({}, inline.normal, {
  escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
});

inline.gfm.url = edit$1(inline.gfm.url, 'i')
  .replace('email', inline.gfm._extended_email)
  .getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge$1({}, inline.gfm, {
  br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
  text: edit$1(inline.gfm.text)
    .replace('\\b_', '\\b_| {2,}\\n')
    .replace(/\{2,\}/g, '*')
    .getRegex()
});

var rules = {
  block,
  inline
};

const { defaults: defaults$2 } = defaults;
const { block: block$1, inline: inline$1 } = rules;
const { repeatString: repeatString$1 } = helpers;

/**
 * smartypants text replacement
 */
function smartypants(text) {
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
}

/**
 * mangle email addresses
 */
function mangle(text) {
  let out = '',
    i,
    ch;

  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
}

/**
 * Block Lexer
 */
var Lexer_1 = class Lexer {
  constructor(options) {
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || defaults$2;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;

    const rules = {
      block: block$1.normal,
      inline: inline$1.normal
    };

    if (this.options.pedantic) {
      rules.block = block$1.pedantic;
      rules.inline = inline$1.pedantic;
    } else if (this.options.gfm) {
      rules.block = block$1.gfm;
      if (this.options.breaks) {
        rules.inline = inline$1.breaks;
      } else {
        rules.inline = inline$1.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }

  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: block$1,
      inline: inline$1
    };
  }

  /**
   * Static Lex Method
   */
  static lex(src, options) {
    const lexer = new Lexer(options);
    return lexer.lex(src);
  }

  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) {
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
  }

  /**
   * Preprocessing
   */
  lex(src) {
    src = src
      .replace(/\r\n|\r/g, '\n')
      .replace(/\t/g, '    ');

    this.blockTokens(src, this.tokens, true);

    this.inline(this.tokens);

    return this.tokens;
  }

  /**
   * Lexing
   */
  blockTokens(src, tokens = [], top = true) {
    if (this.options.pedantic) {
      src = src.replace(/^ +$/gm, '');
    }
    let token, i, l, lastToken;

    while (src) {
      // newline
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.type) {
          tokens.push(token);
        }
        continue;
      }

      // code
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        // An indented code block cannot interrupt a paragraph.
        if (lastToken && lastToken.type === 'paragraph') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // fences
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // heading
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // table no leading pipe (gfm)
      if (token = this.tokenizer.nptable(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // hr
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // blockquote
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        token.tokens = this.blockTokens(token.text, [], top);
        tokens.push(token);
        continue;
      }

      // list
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        l = token.items.length;
        for (i = 0; i < l; i++) {
          token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
        }
        tokens.push(token);
        continue;
      }

      // html
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // def
      if (top && (token = this.tokenizer.def(src))) {
        src = src.substring(token.raw.length);
        if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }

      // table (gfm)
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // lheading
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // top-level paragraph
      if (top && (token = this.tokenizer.paragraph(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // text
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      if (src) {
        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }

    return tokens;
  }

  inline(tokens) {
    let i,
      j,
      k,
      l2,
      row,
      token;

    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      switch (token.type) {
        case 'paragraph':
        case 'text':
        case 'heading': {
          token.tokens = [];
          this.inlineTokens(token.text, token.tokens);
          break;
        }
        case 'table': {
          token.tokens = {
            header: [],
            cells: []
          };

          // header
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            token.tokens.header[j] = [];
            this.inlineTokens(token.header[j], token.tokens.header[j]);
          }

          // cells
          l2 = token.cells.length;
          for (j = 0; j < l2; j++) {
            row = token.cells[j];
            token.tokens.cells[j] = [];
            for (k = 0; k < row.length; k++) {
              token.tokens.cells[j][k] = [];
              this.inlineTokens(row[k], token.tokens.cells[j][k]);
            }
          }

          break;
        }
        case 'blockquote': {
          this.inline(token.tokens);
          break;
        }
        case 'list': {
          l2 = token.items.length;
          for (j = 0; j < l2; j++) {
            this.inline(token.items[j].tokens);
          }
          break;
        }
      }
    }

    return tokens;
  }

  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = [], inLink = false, inRawBlock = false) {
    let token, lastToken;

    // String with links masked to avoid interference with em and strong
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;

    // Mask out reflinks
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    // Mask out other blocks
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }

    // Mask out escaped em & strong delimiters
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
    }

    while (src) {
      if (!keepPrevChar) {
        prevChar = '';
      }
      keepPrevChar = false;

      // escape
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // tag
      if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
        src = src.substring(token.raw.length);
        inLink = token.inLink;
        inRawBlock = token.inRawBlock;
        const lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // link
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        if (token.type === 'link') {
          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
        }
        tokens.push(token);
        continue;
      }

      // reflink, nolink
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        const lastToken = tokens[tokens.length - 1];
        if (token.type === 'link') {
          token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
          tokens.push(token);
        } else if (lastToken && token.type === 'text' && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      // em & strong
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
        tokens.push(token);
        continue;
      }

      // code
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // br
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // del (gfm)
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
        tokens.push(token);
        continue;
      }

      // autolink
      if (token = this.tokenizer.autolink(src, mangle)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // url (gfm)
      if (!inLink && (token = this.tokenizer.url(src, mangle))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }

      // text
      if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }

      if (src) {
        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }

    return tokens;
  }
};

const { defaults: defaults$3 } = defaults;
const {
  cleanUrl: cleanUrl$1,
  escape: escape$2
} = helpers;

/**
 * Renderer
 */
var Renderer_1 = class Renderer {
  constructor(options) {
    this.options = options || defaults$3;
  }

  code(code, infostring, escaped) {
    const lang = (infostring || '').match(/\S*/)[0];
    if (this.options.highlight) {
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) {
        escaped = true;
        code = out;
      }
    }

    code = code.replace(/\n$/, '') + '\n';

    if (!lang) {
      return '<pre><code>'
        + (escaped ? code : escape$2(code, true))
        + '</code></pre>\n';
    }

    return '<pre><code class="'
      + this.options.langPrefix
      + escape$2(lang, true)
      + '">'
      + (escaped ? code : escape$2(code, true))
      + '</code></pre>\n';
  }

  blockquote(quote) {
    return '<blockquote>\n' + quote + '</blockquote>\n';
  }

  html(html) {
    return html;
  }

  heading(text, level, raw, slugger) {
    if (this.options.headerIds) {
      return '<h'
        + level
        + ' id="'
        + this.options.headerPrefix
        + slugger.slug(raw)
        + '">'
        + text
        + '</h'
        + level
        + '>\n';
    }
    // ignore IDs
    return '<h' + level + '>' + text + '</h' + level + '>\n';
  }

  hr() {
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
  }

  list(body, ordered, start) {
    const type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
  }

  listitem(text) {
    return '<li>' + text + '</li>\n';
  }

  checkbox(checked) {
    return '<input '
      + (checked ? 'checked="" ' : '')
      + 'disabled="" type="checkbox"'
      + (this.options.xhtml ? ' /' : '')
      + '> ';
  }

  paragraph(text) {
    return '<p>' + text + '</p>\n';
  }

  table(header, body) {
    if (body) body = '<tbody>' + body + '</tbody>';

    return '<table>\n'
      + '<thead>\n'
      + header
      + '</thead>\n'
      + body
      + '</table>\n';
  }

  tablerow(content) {
    return '<tr>\n' + content + '</tr>\n';
  }

  tablecell(content, flags) {
    const type = flags.header ? 'th' : 'td';
    const tag = flags.align
      ? '<' + type + ' align="' + flags.align + '">'
      : '<' + type + '>';
    return tag + content + '</' + type + '>\n';
  }

  // span level renderer
  strong(text) {
    return '<strong>' + text + '</strong>';
  }

  em(text) {
    return '<em>' + text + '</em>';
  }

  codespan(text) {
    return '<code>' + text + '</code>';
  }

  br() {
    return this.options.xhtml ? '<br/>' : '<br>';
  }

  del(text) {
    return '<del>' + text + '</del>';
  }

  link(href, title, text) {
    href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }
    let out = '<a href="' + escape$2(href) + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += '>' + text + '</a>';
    return out;
  }

  image(href, title, text) {
    href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) {
      return text;
    }

    let out = '<img src="' + href + '" alt="' + text + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += this.options.xhtml ? '/>' : '>';
    return out;
  }

  text(text) {
    return text;
  }
};

/**
 * TextRenderer
 * returns only the textual part of the token
 */
var TextRenderer_1 = class TextRenderer {
  // no need for block level renderers
  strong(text) {
    return text;
  }

  em(text) {
    return text;
  }

  codespan(text) {
    return text;
  }

  del(text) {
    return text;
  }

  html(text) {
    return text;
  }

  text(text) {
    return text;
  }

  link(href, title, text) {
    return '' + text;
  }

  image(href, title, text) {
    return '' + text;
  }

  br() {
    return '';
  }
};

/**
 * Slugger generates header id
 */
var Slugger_1 = class Slugger {
  constructor() {
    this.seen = {};
  }

  serialize(value) {
    return value
      .toLowerCase()
      .trim()
      // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '')
      // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
      .replace(/\s/g, '-');
  }

  /**
   * Finds the next safe (unique) slug to use
   */
  getNextSafeSlug(originalSlug, isDryRun) {
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) {
      occurenceAccumulator = this.seen[originalSlug];
      do {
        occurenceAccumulator++;
        slug = originalSlug + '-' + occurenceAccumulator;
      } while (this.seen.hasOwnProperty(slug));
    }
    if (!isDryRun) {
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
    }
    return slug;
  }

  /**
   * Convert string to unique id
   * @param {object} options
   * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
   */
  slug(value, options = {}) {
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
  }
};

const { defaults: defaults$4 } = defaults;
const {
  unescape: unescape$1
} = helpers;

/**
 * Parsing & Compiling
 */
var Parser_1 = class Parser {
  constructor(options) {
    this.options = options || defaults$4;
    this.options.renderer = this.options.renderer || new Renderer_1();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer_1();
    this.slugger = new Slugger_1();
  }

  /**
   * Static Parse Method
   */
  static parse(tokens, options) {
    const parser = new Parser(options);
    return parser.parse(tokens);
  }

  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) {
    const parser = new Parser(options);
    return parser.parseInline(tokens);
  }

  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = '',
      i,
      j,
      k,
      l2,
      l3,
      row,
      cell,
      header,
      body,
      token,
      ordered,
      start,
      loose,
      itemBody,
      item,
      checked,
      task,
      checkbox;

    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      switch (token.type) {
        case 'space': {
          continue;
        }
        case 'hr': {
          out += this.renderer.hr();
          continue;
        }
        case 'heading': {
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape$1(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger);
          continue;
        }
        case 'code': {
          out += this.renderer.code(token.text,
            token.lang,
            token.escaped);
          continue;
        }
        case 'table': {
          header = '';

          // header
          cell = '';
          l2 = token.header.length;
          for (j = 0; j < l2; j++) {
            cell += this.renderer.tablecell(
              this.parseInline(token.tokens.header[j]),
              { header: true, align: token.align[j] }
            );
          }
          header += this.renderer.tablerow(cell);

          body = '';
          l2 = token.cells.length;
          for (j = 0; j < l2; j++) {
            row = token.tokens.cells[j];

            cell = '';
            l3 = row.length;
            for (k = 0; k < l3; k++) {
              cell += this.renderer.tablecell(
                this.parseInline(row[k]),
                { header: false, align: token.align[k] }
              );
            }

            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case 'blockquote': {
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case 'list': {
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;

          body = '';
          for (j = 0; j < l2; j++) {
            item = token.items[j];
            checked = item.checked;
            task = item.task;

            itemBody = '';
            if (item.task) {
              checkbox = this.renderer.checkbox(checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: 'text',
                    text: checkbox
                  });
                }
              } else {
                itemBody += checkbox;
              }
            }

            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
          }

          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case 'html': {
          // TODO parse inline content if parameter markdown=1
          out += this.renderer.html(token.text);
          continue;
        }
        case 'paragraph': {
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
        }
        case 'text': {
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === 'text') {
            token = tokens[++i];
            body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }

    return out;
  }

  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = '',
      i,
      token;

    const l = tokens.length;
    for (i = 0; i < l; i++) {
      token = tokens[i];
      switch (token.type) {
        case 'escape': {
          out += renderer.text(token.text);
          break;
        }
        case 'html': {
          out += renderer.html(token.text);
          break;
        }
        case 'link': {
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
        }
        case 'image': {
          out += renderer.image(token.href, token.title, token.text);
          break;
        }
        case 'strong': {
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
        }
        case 'em': {
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
        }
        case 'codespan': {
          out += renderer.codespan(token.text);
          break;
        }
        case 'br': {
          out += renderer.br();
          break;
        }
        case 'del': {
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
        }
        case 'text': {
          out += renderer.text(token.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return;
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};

const {
  merge: merge$2,
  checkSanitizeDeprecation: checkSanitizeDeprecation$1,
  escape: escape$3
} = helpers;
const {
  getDefaults,
  changeDefaults,
  defaults: defaults$5
} = defaults;

/**
 * Marked
 */
function marked(src, opt, callback) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  if (typeof opt === 'function') {
    callback = opt;
    opt = null;
  }

  opt = merge$2({}, marked.defaults, opt || {});
  checkSanitizeDeprecation$1(opt);

  if (callback) {
    const highlight = opt.highlight;
    let tokens;

    try {
      tokens = Lexer_1.lex(src, opt);
    } catch (e) {
      return callback(e);
    }

    const done = function(err) {
      let out;

      if (!err) {
        try {
          out = Parser_1.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!tokens.length) return done();

    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === 'code') {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }

            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });

    if (pending === 0) {
      done();
    }

    return;
  }

  try {
    const tokens = Lexer_1.lex(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser_1.parse(tokens, opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) {
      return '<p>An error occurred:</p><pre>'
        + escape$3(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge$2(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};

marked.getDefaults = getDefaults;

marked.defaults = defaults$5;

/**
 * Use Extension
 */

marked.use = function(extension) {
  const opts = merge$2({}, extension);
  if (extension.renderer) {
    const renderer = marked.defaults.renderer || new Renderer_1();
    for (const prop in extension.renderer) {
      const prevRenderer = renderer[prop];
      renderer[prop] = (...args) => {
        let ret = extension.renderer[prop].apply(renderer, args);
        if (ret === false) {
          ret = prevRenderer.apply(renderer, args);
        }
        return ret;
      };
    }
    opts.renderer = renderer;
  }
  if (extension.tokenizer) {
    const tokenizer = marked.defaults.tokenizer || new Tokenizer_1();
    for (const prop in extension.tokenizer) {
      const prevTokenizer = tokenizer[prop];
      tokenizer[prop] = (...args) => {
        let ret = extension.tokenizer[prop].apply(tokenizer, args);
        if (ret === false) {
          ret = prevTokenizer.apply(tokenizer, args);
        }
        return ret;
      };
    }
    opts.tokenizer = tokenizer;
  }
  if (extension.walkTokens) {
    const walkTokens = marked.defaults.walkTokens;
    opts.walkTokens = (token) => {
      extension.walkTokens(token);
      if (walkTokens) {
        walkTokens(token);
      }
    };
  }
  marked.setOptions(opts);
};

/**
 * Run callback for every token
 */

marked.walkTokens = function(tokens, callback) {
  for (const token of tokens) {
    callback(token);
    switch (token.type) {
      case 'table': {
        for (const cell of token.tokens.header) {
          marked.walkTokens(cell, callback);
        }
        for (const row of token.tokens.cells) {
          for (const cell of row) {
            marked.walkTokens(cell, callback);
          }
        }
        break;
      }
      case 'list': {
        marked.walkTokens(token.items, callback);
        break;
      }
      default: {
        if (token.tokens) {
          marked.walkTokens(token.tokens, callback);
        }
      }
    }
  }
};

/**
 * Parse Inline
 */
marked.parseInline = function(src, opt) {
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) {
    throw new Error('marked.parseInline(): input parameter is undefined or null');
  }
  if (typeof src !== 'string') {
    throw new Error('marked.parseInline(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
  }

  opt = merge$2({}, marked.defaults, opt || {});
  checkSanitizeDeprecation$1(opt);

  try {
    const tokens = Lexer_1.lexInline(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser_1.parseInline(tokens, opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) {
      return '<p>An error occurred:</p><pre>'
        + escape$3(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
};

/**
 * Expose
 */

marked.Parser = Parser_1;
marked.parser = Parser_1.parse;

marked.Renderer = Renderer_1;
marked.TextRenderer = TextRenderer_1;

marked.Lexer = Lexer_1;
marked.lexer = Lexer_1.lex;

marked.Tokenizer = Tokenizer_1;

marked.Slugger = Slugger_1;

marked.parse = marked;

var marked_1 = marked;

var locales = {
  'cs': {
    'more-sale-coupons': 'Další slevové kupóny',
    'shop': 'Obchod',
    'search': 'Hledání',
    'settings': 'Nastavení',
    'sign-in': 'Přihlásit se',
    'cashback-state': 'Stav odměn',
    'main-settings': 'Hlavní nastavení',
    'show-notifications-in-search': 'Zobrazovat upozornění ve vyhledávání',
    'advanced-settings': 'Pokročilé nastavení',
    'notifications': 'Správa upozornění',
    'locale': 'Volba webu a jazyka rozšíření',
    'lang-cs': 'jazyk Čeština',
    'lang-sk': 'jazyk Slovenština',
    'lang-pl': 'jazyk Polština',
    'lang-ro': 'jazyk Rumunština',
    'lang-hu': 'jazyk Maďarština',
    'shops-list-updated': 'Seznam obchodů aktualizován',
    'save-settings': 'Uložit nastavení',
    'hide-popup': 'Skrytí vyskakovacího okna',
    'disable-extension': 'Pozastavit funkci rozšíření',
    'settings-saved': 'Nastavení uloženo',
    'settings-save-error': 'Chyba při ukládání nastavení',
    'coupon-get-code': 'Získat kód',
    'coupon-copied': 'Zkopírováno',
    'sale-get-sale': 'Získat slevu',
    'go-to-slide': 'Přejít na slide',
    'reward-activated': 'Vaše odměny jsou aktivovány',
    'reward-activated-suffix': 'Po nákupu vám připíšeme odměnu.',
    'reward-deactivated': 'Pozor přišli jste o aktivované odměny',
    'similar-items-header': 'Prohlédněte si další slevové kupony z jiných obchodů',
    'blacklist-domain-example': 'domena.cz',
    'blacklist-add-domain': 'Přidat doménu',
    'blacklist-add-complete': 'Doména přidána',
    'blacklist-add-error': 'Doménu nelze přidat',
    'blacklist-add-exists': 'Doména byla již přidána',
    'blacklist-remove-complete': 'Nastavení doménu bylo odebráno',
    'extension-version': 'Verze rozšíření',
    'restore-extension': 'Obnovit rozšíření do výchozího nastavení',
    'restore-extension-confirm': 'Jste si jistí? Potvrzením dojde k přepsání vašeho nastavení na původní hodnoty.',
    'restore-extension-complete': 'Hotovo. Aktualizuji...',
    'hide': 'Trvale skrýt vyskakovací okno',
    'close': 'Zavřít',
    'reload-feed': 'aktualizovat seznam obchodů',
    'show-terms': 'Zobrazit podmínky',
    'more': 'více',
    'no-search-results': 'Žádné výsledky',
    'confirm-content-box-hide': 'Opravdu chcete trvale skrýt vyskakovací okno s nabídkami?',
    'no-sale-items': 'Pro tento obchod právě teď slevové kupóny nemáme.',
    'popup-extension-disabled-header': 'Pro tuto stránku máte rozšíření pozastaveno',
    'popup-extension-disabled-text': 'Pro změnu chování klikněte na tlačítko [Nastavení](/options.html) v dolní části.',
    'search-placeholder': 'Hledat obchody',
    'feed-refreshed': 'Seznam obchodů aktualizován',
  },
  'sk': {
    'more-sale-coupons': 'Dalšie zľavové kupón',
    'shop': 'Obchod',
    'search': 'Hľadanie',
    'settings': 'Nastavenie',
    'sign-in': 'Prihlásiť sa',
    'cashback-state': 'Stav odmien',
    'main-settings': 'Hlavné nastavenia',
    'show-notifications-in-search': 'Zobrazovať upozornenie vo vyhľadávaní',
    'advanced-settings': 'Pokročilé nastavenie',
    'notifications': 'Spravovanie upozornení',
    'locale': 'Voľba webu a jazyka rozšírenie',
    'lang-cs': 'jazyk český',
    'lang-sk': 'jazyk slovenský',
    'lang-pl': 'jazyk poľský',
    'lang-ro': 'jazyk rumunský',
    'lang-hu': 'jazyk maďarský',
    'shops-list-updated': 'Zoznam obchodov aktualizovaný',
    'save-settings': 'Uložiť nastavenia',
    'hide-popup': 'Skrytie vyskakovacieho okna',
    'disable-extension': 'Pozastaviť funkciu rozšírenia',
    'settings-saved': 'Nastavenie uložené',
    'settings-save-error': 'Chyba pri ukladaní nastavení',
    'coupon-get-code': 'Získať kód',
    'coupon-copied': 'Skopirované',
    'sale-get-sale': 'Získať zľavu',
    'go-to-slide': 'Prejsť na slide',
    'reward-activated': 'Vaše odmeny sú aktivované',
    'reward-activated-suffix': 'Po nákupe Vám pripíšeme odmenu.',
    'reward-deactivated': 'Pozor prišli ste o aktivované odmeny',
    'similar-items-header': 'Pozrite si dalšie zľavové kupóny z iných obchodov',
    'blacklist-domain-example': 'domena.sk',
    'blacklist-add-domain': 'Dodaj domenę',
    'blacklist-add-complete': 'Doména pridaná',
    'blacklist-add-error': 'Doménu nemožno pridať',
    'blacklist-add-exists': 'Doména bola už pridaná',
    'blacklist-remove-complete': 'Nastavenie doménu bolo odobraté',
    'extension-version': 'Verzia rozšírenie',
    'restore-extension': 'Obnovte pôvodné nastavenia rozšírení',
    'restore-extension-confirm': 'Ste si istí? Potvrdením dôjde k prepísaniu vášho nastavenia na pôvodné hodnoty.',
    'restore-extension-complete': 'Hotovo. Aktualizujem ...',
    'hide': 'Trvalo skryť vyskakovacie okno',
    'close': 'Zavrieť',
    'reload-feed': 'aktualizovať zoznam obchodov',
    'show-terms': 'Zobraziť podmienky',
    'more': 'viac',
    'no-search-results': 'Žiadne výsledky',
    'confirm-content-box-hide': 'Naozaj chcete natrvalo skryť vyskakovacie okno s ponukami?',
    'no-sale-items': 'Pre tento obchod práve teraz zľavové kupóny nemáme.',
    'popup-extension-disabled-header': 'Pre túto stránku máte rozšírenie pozastavené',
    'popup-extension-disabled-text': 'Pre zmenu správania kliknite na tlačidlo [Nastavenia](/options.html) v dolnej časti.',
    'search-placeholder': 'Hľadať obchody',
    'feed-refreshed': 'Zoznam obchodov aktualizovaný',
  },
  'pl': {
    'more-sale-coupons': 'Więcej kuponów zniżkowych',
    'shop': 'Sklep',
    'search': 'Szukać',
    'settings': 'Ustawienia',
    'sign-in': 'Zaloguj się',
    'cashback-state': 'Stan zwrotów',
    'main-settings': 'Ustawienia główne',
    'show-notifications-in-search': 'Pokaż powiadomienia w wyszukiwaniu',
    'advanced-settings': 'Ustawienia zaawansowane',
    'notifications': 'Powiadomienia',
    'locale': 'Wybór webu i języka rozszerzenia',
    'lang-cs': 'język czeski',
    'lang-sk': 'język słowacki',
    'lang-pl': 'język polski',
    'lang-ro': 'język rumuński',
    'lang-hu': 'język węgierski',
    'shops-list-updated': 'Lista sklepów zaktualizowana',
    'save-settings': 'Zapisać ustawienia',
    'hide-popup': 'Ukryj wyskakujące okienko',
    'disable-extension': 'Wstrzymaj funkcje rozszerzenia ',
    'settings-saved': 'Ustawienia zapisano',
    'settings-save-error': 'Błąd przy zapisywaniu ustawień',
    'coupon-get-code': 'Zyskać kod',
    'coupon-copied': 'Skopiowano',
    'sale-get-sale': 'Zyskać zniżkę',
    'go-to-slide': 'Przejdź na slide',
    'reward-activated': 'Zwroty są aktywowane ',
    'reward-activated-suffix': 'Po zakupie przypiszemy zwrot.',
    'reward-deactivated': 'Uwaga, aktywowane zwroty  zostały utracone',
    'similar-items-header': 'Przejrzyj  pozostałe kupony rabatowe  z innych sklepów',
    'blacklist-domain-example': 'domena.pl',
    'blacklist-add-domain': 'Dodaj domenę',
    'blacklist-add-complete': 'Domena została dodana',
    'blacklist-add-error': 'Nie można dodać domeny',
    'blacklist-add-exists': 'Domena została już dodana',
    'blacklist-remove-complete': 'Ustawienia domeny zostały usunięte',
    'extension-version': 'Wersja rozszerzenia',
    'restore-extension': 'Przywróć rozszerzenia do ustawień domyślnych',
    'restore-extension-confirm': 'Jesteś pewny? Potwierdzenie spowoduje nadpisanie ustawień do ich oryginalnych wartości.',
    'restore-extension-complete': 'Gotowy. Aktualizuję ...',
    'hide': 'Trwale ukryj wyskakujące okienko',
    'close': 'Blisko',
    'reload-feed': 'zaktualizuj listę sklepów',
    'show-terms': 'Pokaż warunki',
    'more': 'więcej',
    'no-search-results': 'Brak wyników',
    'confirm-content-box-hide': 'Na pewno chcesz trwale ukryć wyskakujące okienko z ofertami?',
    'no-sale-items': 'Niestety aktualnie nie oferujemy kuponów rabatowych do tego sklepu.',
    'popup-extension-disabled-header': 'Dla tej strony rozszerzenie zostało wstrzymane',
    'popup-extension-disabled-text': 'Aby zmienić ustawienia kliknij przycisk [Ustawienia](/options.html) w dolnej części',
    'search-placeholder': 'Wyszukaj sklepy',
    'feed-refreshed': 'Lista sklepów zaktualizowana',
  },
  'ro': {
    'more-sale-coupons': 'Alte cupoane de reducere',
    'shop': 'Magazin',
    'search': 'Căutare',
    'settings': 'Setări',
    'sign-in': 'Autentificare',
    'cashback-state': 'Starea recompenselor',
    'main-settings': 'Setările principale',
    'show-notifications-in-search': 'Afișează notificările în căutare',
    'advanced-settings': 'Setări avansate',
    'notifications': 'Gestionarea notificărilor',
    'locale': 'Alegerea webului și a limbei extensiei',
    'lang-cs': 'limba cehă',
    'lang-sk': 'limba slovacă',
    'lang-pl': 'limba poloneză',
    'lang-ro': 'limba română',
    'lang-hu': 'limba maghiară',
    'shops-list-updated': 'Lista magazinelor a fost actualizată',
    'save-settings': 'Salvează setările',
    'hide-popup': 'Ascunde fereastra pop-up',
    'disable-extension': 'Oprește funcția de extensie',
    'settings-saved': 'Setările au fost salvate',
    'settings-save-error': 'Eroare la salvarea setărilor',
    'coupon-get-code': 'Obține cod',
    'coupon-copied': 'Copiat',
    'sale-get-sale': 'Obține reducere',
    'go-to-slide': 'Treci la slide',
    'reward-activated': 'Recompensele dvs. sunt activate',
    'reward-activated-suffix': 'După cumpărătură vă vom atribui recompensă',
    'reward-deactivated': 'Atenție, ați pierdut recompensele activate',
    'similar-items-header': 'Uitați-vă la celelalte cupoane de reducere din alte magazine',
    'blacklist-domain-example': 'domeniu.ro',
    'blacklist-add-domain': 'Adaugă domeniu',
    'blacklist-add-complete': 'Domeniu adăugat',
    'blacklist-add-error': 'Domeniul nu poate fi adăugat',
    'blacklist-add-exists': 'Domeniul a fost deja adăugat',
    'blacklist-remove-complete': 'Setările domeniului au fost eliminate',
    'extension-version': 'Versiunea extensiei',
    'restore-extension': 'Restaurează extensia la setările prestabilite',
    'restore-extension-confirm': 'Sunteți sigur? Confirmând, setările dvs. se vor restabili la valorile inițiale.',
    'restore-extension-complete': 'Este gata. Se actualizează...',
    'hide': 'Ascunde pentru totdeauna fereastra pop-up',
    'close': 'Închide',
    'reload-feed': 'actualizează lista magazinelor',
    'show-terms': 'Arată condițiile',
    'more': 'mai mult',
    'no-search-results': 'Niciun rezultat',
    'confirm-content-box-hide': 'Sunteți sigur că vă doriți să ascundeți pentru totdeauna fereastra pop-up cu oferte?',
    'no-sale-items': 'Momentan nu avem cupoane de reducere pentru acest magazin.',
    'popup-extension-disabled-header': 'Pentru această pagină a fost oprită extensia',
    'popup-extension-disabled-text': 'Pentru a schimba setările accesați butonul [Setări](/options.html) din partea de jos.',
    'search-placeholder': 'Caută magazine',
    'feed-refreshed': 'Lista de magazine a fost actualizată',
  },
  'hu': {
    'more-sale-coupons': 'További kedvezményes kuponok',
    'shop': 'Webáruház',
    'search': 'Keresés',
    'settings': 'Beállítás',
    'sign-in': 'Bejelentkezés',
    'cashback-state': 'Jutalmak állapota',
    'main-settings': 'Főbeállítások',
    'show-notifications-in-search': 'Figyelmeztetések megjelenítése a kereséskor',
    'advanced-settings': 'Haladó beállítások',
    'notifications': 'Figyelmeztetések igazgatása',
    'locale': 'A web és a kiterjesztés nyelvének beállítása',
    'lang-cs': 'nyelv: cseh',
    'lang-sk': 'nyelv: szlovák',
    'lang-pl': 'nyelv: lengyel',
    'lang-ro': 'nyelv: román',
    'lang-hu': 'nyelv: magyar',
    'shops-list-updated': 'Webáruházak frissített listája',
    'save-settings': 'Beállítások mentése',
    'hide-popup': 'Felugró ablak elrejtése',
    'disable-extension': 'Kiterjesztés funkciójának megállítása',
    'settings-saved': 'Beállítások mentve',
    'settings-save-error': 'Hiba történt a beállítások mentése során',
    'coupon-get-code': 'Kód szerzése',
    'coupon-copied': 'Másolva',
    'sale-get-sale': 'Kedvezmény megszerzése',
    'go-to-slide': 'Ugrás a slide-ra',
    'reward-activated': 'Jutalmait aktiváltuk',
    'reward-activated-suffix': 'A vásárlás után jóváírjuk a jutalmát.',
    'reward-deactivated': 'Figyelem, elvesztette az aktivált jutalmát',
    'similar-items-header': 'Tekintse meg a többi webáruház kedvezményes kuponjait',
    'blacklist-domain-example': 'domain.hu',
    'blacklist-add-domain': 'Domain hozzáadása',
    'blacklist-add-complete': 'Domain hozzáadva',
    'blacklist-add-error': 'Nem lehet hozzáadni a domaint',
    'blacklist-add-exists': 'A domain már hozzá lett adva',
    'blacklist-remove-complete': 'A domain beállítása el lett távolítva',
    'extension-version': 'A kiterjesztés változata',
    'restore-extension': 'Kiterjesztés visszaállítása a kezdőbeállításokra',
    'restore-extension-confirm': 'Biztos benne? A megerősítéssel beállításai az eredeti állapotba kerülnek.',
    'restore-extension-complete': 'Kész. Aktualizálódik...',
    'hide': 'Felugró ablak elrejtése örökre',
    'close': 'Bezárás',
    'reload-feed': 'A webáruházak listájának frissítése',
    'show-terms': 'Feltételek megtekintése',
    'no-search-results': 'Nincs találat',
    'confirm-content-box-hide': 'Tényleg szeretné örökre elrejteni a felugró ablakot az ajánlatokkal?',
    'no-sale-items': 'Ebbe a webáruházba jelenleg nincs kedvezményes kuponunk.',
    'popup-extension-disabled-header': 'A kiterjesztés ehhez a weboldalhoz fel van függesztve',
    'popup-extension-disabled-text': 'A megvátoztatáshoz nyomjon a lent található [Beállítások](/options.html) gombra.',
    'search-placeholder': 'Webáruházak keresése',
    'feed-refreshed': 'Weboldalak listája frissítve',
  },
};

function initLocalization(locale) {
  const texts = locales[locale];
  return (key, defaultValue = '') => (texts && texts[key]) || defaultValue || key;
}

/**
 * Environment variables, imagine this file as a dot file.
 *  `extension/environment.js` is ignored Hard Link
 *
 * Use `npm run env:prod` or `npm run env:local` to use environment you need.
 */

const LOCALE_TIPLI_URL = {
  cs: 'https://www.tipli.cz',
  sk: 'https://www.tipli.sk',
  pl: 'https://www.tipli.pl',
  ro: 'https://www.tipli.ro',
  hu: 'https://www.tiplino.hu',
};

const DEFAULT_LOCALE = 'ro';

/*
 * File of pure JS Template literals used across extension to render data
 */

marked_1.use({
  renderer: {
    link(href, title, text) {
      return `<a href="${href}" title="${title}" target="_blank">${text}</a>`;
    },
  },
});
const md = (s) => (s ? marked_1(s).replace(/<[\/]?p>/g, '') : '');
let l = initLocalization(DEFAULT_LOCALE);

const init = ({ locale }) => {
  l = initLocalization(locale);
};

const locale_date = (timestamp) => {
  const date = new Date(timestamp);
  return [date.toLocaleDateString(), date.toLocaleTimeString()].join(' ');
};

/** warning: eagerly evaluates both parts */
const iif = (expr, truePart, falsePart) => (expr ? truePart : falsePart);
const when = (expr, truePart) => iif(expr, truePart, '');

const asset = (name) => browser.runtime.getURL(`assets/${name}`);

const locale_home_url = (locale = 'cs') => LOCALE_TIPLI_URL[locale];

/** Icon color can be changed via `--icon-color` custom property */
const terms_icon = ({ title, href }) => `
  <a class="terms-icon" href="${href}" title="${title}" target="_blank" rel="noopener noreferrer">
    <svg width="10" height="10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 .156a4.844 4.844 0 10.001 9.69A4.844 4.844 0 005 .155zm0 8.75A3.904 3.904 0 011.094 5 3.905 3.905 0 015 1.094 3.905 3.905 0 018.906 5 3.904 3.904 0 015 8.906zm2.095-4.984c0 1.31-1.415 1.33-1.415 1.814v.123c0 .13-.105.235-.234.235h-.892a.234.234 0 01-.234-.235V5.69c0-.698.53-.977.93-1.201.342-.193.552-.323.552-.578 0-.337-.43-.56-.777-.56-.453 0-.662.214-.956.585a.235.235 0 01-.325.041L3.2 3.565a.235.235 0 01-.051-.32c.461-.677 1.05-1.058 1.964-1.058.959 0 1.982.749 1.982 1.735zM5.82 7.187a.821.821 0 01-1.64 0 .821.821 0 011.64 0z" fill="var(--icon-color,#9D9D9D)"/></svg>
  </a>
`;

const tipli_logo = ({ locale } = {}, type = 'content-box') => `
  <a
    class="tipli-logo tipli-logo--${type}"
    href="${locale_home_url(locale)}"
    title="Tipli"
  >
    <img
      class="tipli-logo__image"
      src="${asset(`logo-${localeUrlToTipliName(LOCALE_TIPLI_URL[locale])}.png`)}"
      alt="Tipli"
    />
  </a>
`;

const display_money = ({ balance, currency }, { locale }) => {
  return parseFloat(balance || 0).toLocaleString(locale, {
    style: 'currency',
    currency,
  });
};

const reward_button = (buttonLabel = 'Label', buttonUrl, icon = '') =>
  `<a class="reward_button" href="${buttonUrl}">${icon} ${buttonLabel}</a>`;

const reward_deactivated = (buttonLabel, buttonUrl) => `
  <strong>${l('reward-deactivated')}</strong>
  ${reward_button(
    buttonLabel,
    buttonUrl,
    `<svg width="12" height="12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.01.188a5.793 5.793 0 014.005 1.61l.837-.838a.563.563 0 01.96.398V4.5c0 .31-.251.563-.562.563H8.108a.563.563 0 01-.398-.96l.979-.98a3.938 3.938 0 10-.096 5.84.28.28 0 01.383.013l.93.93c.114.114.109.3-.011.409A5.813 5.813 0 01.188 6 5.823 5.823 0 016.01.188z" fill="#fff"/></svg>`
  )}
`;

const reward_activated = () => `
  <svg width="13" height="13" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0)"><path d="M4.077 11.157l-3.9-4.225a.689.689 0 010-.92l.849-.919a.568.568 0 01.848 0L4.501 7.94l5.628-6.096a.568.568 0 01.848 0l.849.92a.689.689 0 010 .919l-6.9 7.475a.568.568 0 01-.849 0z" fill="#fff"/></g><defs><clipPath id="clip0"><path fill="#fff" transform="translate(.001)" d="M0 0h12v13H0z"/></clipPath></defs></svg>
  <strong>${l('reward-activated')}</strong>
  <span class="reward-suffix">${l('reward-activated-suffix')}</span>
`;

const reward_state = (
  reward,
  { buttonLabel, buttonUrl, buttonLabelReactivation, deepUrl }
) => {
  const enhanceAboutDeepUrl = str => {
    if (!str || !deepUrl) return str;
    const url = new URL(str);
    url.searchParams.set('deepUrl', deepUrl);
    return url.href;
  };

  if (reward.deactivated) {
    return reward_deactivated(buttonLabelReactivation, enhanceAboutDeepUrl(buttonUrl));
  }
  if (reward.cashback) {
    return reward_activated();
  }
  return reward_button(buttonLabel, enhanceAboutDeepUrl(buttonUrl));
};

const reward_cashback = (
  { shop, reward } = {},
  targetType,
) => {
  return `
    <div class="${classNames('shop-reward-cashback', {
      [`shop-reward-cashback--${targetType}`]: targetType,
      [`shop-reward-cashback--activated`]: reward.cashback,
      [`shop-reward-cashback--deactivated`]: reward.deactivated,
    })}">
      <div class="shop-reward-cashback__reward">
        ${md(shop.reward)}
      ${when(
        shop.conditionsUrl,
        terms_icon({ title: l('show-terms'), href: shop.conditionsUrl })
      )}
        <span>${shop.rewardSuffix}</span>
      </div>
      <div class="${classNames('shop-reward-cashback__button', {
        [`shop-reward-cashback__button--activated`]: reward.cashback,
        [`shop-reward-cashback__button--deactivated`]: reward.deactivated,
      })}">
        ${reward_state(reward, shop)}
      </div>
    </div>
  `;
};

const reward_coupons = ({ shop }, targetType) => `
  <div class="${classNames('shop-reward-coupons', {
    [`shop-reward-coupons--${targetType}`]: targetType,
  })}">
    ${icon('coupon', 16)}
    ${md(shop.reward)}
    <span>${shop.rewardSuffix}</span>
  </div>
`;

const reward_notice = ({ shop }, targetType) => `
  <div class="${classNames('shop-reward-notice', {
    [`shop-reward-notice--${targetType}`]: targetType,
  })}">
    <div class="shop-reward-notice__notice">
      ${md(shop.notice)}
    </div>
  </div>
`;

const shop_rewards = {
  cashback: reward_cashback,
  coupons: reward_coupons,
  notice: reward_notice,
};

const control_icon = (type, size) => `
  <button
    class="control-icon"
    id="control-icon-${type}"
    data-control-type="${type}"
    aria-label="${l(type)}"
  >
    ${icon(type, size)}
  </button>
`;

const sales_item = (context, reward) => sale => {
  if (!sales_types[sale.type]) return '';

  let title = sale.name || '';
  const maxLength = 46;

  if (context === 'popup' && title.length > maxLength) {
    title = title.substring(0, maxLength).trim() + '…';
  }

  const conditionsMaxLength = context === 'popup' ? 56 : 75;

  return `
    <div class="${classNames('sales-item', {
      [`sales-item--${context}`]: context,
      [`sales-item--activated`]: reward.coupons && !sale.isSimilar,
      [`sales-item--similar`]: sale.isSimilar,
    })}">
      <div class="sales-item__discount">${sale.reward || ''}</div>
      <div class="sales-item__title" title="${sale.name}">${title}</div>
      ${iif(
        sale.shopConditionsUrl,
        terms_icon({ href: sale.shopConditionsUrl, title: l('show-terms') }),
        `<i></i>`
      )}
      ${when(
        sale.shopConditionsText,
        `
          <div class="sales-item__shop-conditions-text">
            ${sale.shopConditionsText}
            ${iif(
              (sale.shopConditionsText || "").length > conditionsMaxLength,
              `<span class="sales-item__shop-conditions-text-more">&nbsp;...&nbsp;<strong>${l('more')}</strong></a>`, ""
            )}
          </div>`
      )}
      ${when(
        sale.isSimilar && context === 'content',
        `<div class="sales-item__cashback-reward">${sale.cashbackReward || ''}</div>`
      )}
      ${when(
        sale.isSimilar || context === 'popup',
        `
        <div class="sales-item__logo">
          <img alt="${sale.shopName}" src="${sale.shopLogoUrl}">
        </div>`
      )}
      <div class="sales-item__sticker">
        ${sales_types[sale.type](sale)}
      </div>
    </div>
  `;
};

const similar_items_header = (context) => `
  <div class="sales-item sales-item--${context} sales-item--header">
    ${l('similar-items-header')}
  </div>
`;

const content_box = ({
  shop = {},
  sales = [],
  preferences = {},
  reward = {},
} = {}) => {
  const similarSales = sales.filter((x) => x.isSimilar);
  const shopSales = sales.filter((x) => !x.isSimilar);

  return `
    <div class="content-box">
      <div class="content-box__header">
        ${tipli_logo(preferences)}
        <div class="content-box__controls">
          ${control_icon('hide')}
          ${control_icon('close')}
        </div>
      </div>
      ${shop_rewards[shop.rewardType]({ reward, shop }, 'content')}
      ${when(
        sales.length,
        `<div class="content-box__coupons">
          ${shopSales.map(sales_item('content', reward)).join('\n')}
          ${when(similarSales.length, similar_items_header('content'))}
          ${similarSales
            .map(sales_item('content', { coupons: false }))
            .join('\n')}
        </div>`
      )}
      ${iif(
        shop.rewardType === 'notice' && !sales.length,
        `<div class="content-box__footer content-box__footer--solid-button">
          ${reward_button(l('more-sale-coupons'), shop.shopDetailUrl)}
        </div>`,
        `<div class="content-box__footer content-box__footer--sticky-link">
          <a href="${shop.shopDetailUrl}">${l('more-sale-coupons')}</a>
        </div>`
      )}
    </div>
  `;
};

const icon = (type, size = 12) => `
  <img
    alt="${type}"
    class="${type} icon"
    src="${asset(`ic-${type}.svg`)}"
    width="${size}"
    height="${size}"
  />
`;

const user_cashback = (user = {}, preferences = {}) => `
  ${l('cashback-state')}:
  <strong>${display_money(user, preferences)}</strong>
`;

const signed_in_user = (user, preferences, rewardsLinks) => `
  <a href="${rewardsLinks}" class="popup-header__cashback">
    ${user_cashback(user, preferences)}
  </a>
  <a href="${rewardsLinks}" class="popup-header__user">
    <img alt="" src="${asset('ic-account.svg')}" width="12" height="12" />
    <span class="popup-header__username">${user.name}</span>
  </a>
`;

const signed_out_user = (preferences, currentTabUrl, signInLink) => `
  <div class="popup-header__user">
    <img alt="" src="${asset('ic-account.svg')}" width="12" height="12" />
    <a href="${signInLink}">${l('sign-in')}</a>
  </div>
`;

const user_part = (user, preferences, currentTabUrl, tipliLinks = {}) => {
  if (user && !user.empty) {
    return signed_in_user(user, preferences, tipliLinks.transactions);
  }
  return signed_out_user(preferences, currentTabUrl, tipliLinks.signIn);
};

const popup_header = ({
  user,
  preferences,
  tab: { url: currentTabUrl } = {},
  tipliLinks,
} = {}) => `
  <div class="popup-header">
    <div class="popup-header__logo">
      ${tipli_logo(preferences, 'popup-box')}
    </div>
    ${user_part(user, preferences, currentTabUrl, tipliLinks)}
  </div>
`;

const popup_footer = ({ currentPageUrlBase = '' }) => `
  <nav>
    <a href="#content" class="content-link">
      <svg width="10" height="10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.772 2.316L8.718.293A.507.507 0 008.278 0H1.72a.507.507 0 00-.44.293L.226 2.316c-.543 1.045-.061 2.498.955 2.664.073.012.148.018.222.018.481 0 .906-.254 1.198-.646.293.392.72.646 1.199.646.48 0 .905-.254 1.198-.646.292.392.719.646 1.198.646.48 0 .905-.254 1.198-.646.294.392.719.646 1.198.646.076 0 .15-.006.222-.018 1.02-.164 1.503-1.617.958-2.664zM8.595 5.625c-.162 0-.323-.03-.479-.074V7.5H1.882V5.55a1.81 1.81 0 01-.479.075c-.097 0-.196-.008-.292-.023a1.75 1.75 0 01-.266-.07v3.843c0 .346.232.625.52.625h7.272c.288 0 .52-.28.52-.625V5.531a1.421 1.421 0 01-.267.07 1.882 1.882 0 01-.295.024z" fill="var(--fill-color)"/></svg>
      ${l('shop')}
    </a>
    <a href="#search" class="search-link">
      <svg width="10" height="10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.863 8.646L7.916 6.7a.468.468 0 00-.332-.136h-.318A4.062 4.062 0 100 4.063a4.062 4.062 0 006.563 3.203v.318c0 .125.048.244.136.332l1.947 1.947c.184.184.481.184.663 0l.552-.552a.471.471 0 00.002-.665zm-5.8-2.084c-1.381 0-2.5-1.117-2.5-2.5 0-1.38 1.117-2.5 2.5-2.5 1.38 0 2.5 1.118 2.5 2.5 0 1.381-1.118 2.5-2.5 2.5z" fill="var(--fill-color)"/></svg>
      ${l('search')}
    </a>
    <a href="options.html#${currentPageUrlBase}" target="_blank">
      <svg width="10" height="12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.73 2.398l.28.154a.227.227 0 01.105.283 2.054 2.054 0 01-.363.602.25.25 0 01-.307.052l-.28-.153c-.156.129-.337.23-.534.298v.31c0 .112-.084.21-.202.228a2.29 2.29 0 01-.724 0 .236.236 0 01-.203-.229v-.31a1.704 1.704 0 01-.536-.297l-.279.153a.247.247 0 01-.307-.052 2.078 2.078 0 01-.363-.602.227.227 0 01.106-.283l.279-.154a1.6 1.6 0 010-.594l-.28-.154a.227.227 0 01-.105-.283C.103 1.146.227.943.38.765A.25.25 0 01.687.712l.28.154c.156-.13.337-.23.535-.298v-.31c0-.112.084-.21.2-.228.235-.038.481-.04.725 0a.236.236 0 01.204.229v.31c.197.067.378.168.535.297l.279-.154a.247.247 0 01.307.053c.154.178.277.382.363.602a.227.227 0 01-.106.283l-.279.154a1.6 1.6 0 010 .594zm-1.148.197c.578-.722-.28-1.545-1.032-.99-.58.722.28 1.545 1.032.99zm3.006 2.162l.328-.632a.48.48 0 01.568-.197c.473.167.906.495 1.285.799a.436.436 0 01.104.568l-.328.546c.267.3.48.648.619 1.029h.656c.227 0 .422.156.46.37a4.05 4.05 0 010 1.422.464.464 0 01-.46.375h-.656c-.14.381-.352.73-.62 1.03l.327.545c.113.188.07.43-.104.569-.379.303-.812.624-1.283.79a.48.48 0 01-.568-.196l-.328-.624a3.523 3.523 0 01-1.239 0l-.33.624a.475.475 0 01-.566.197c-.473-.167-.906-.488-1.285-.791a.436.436 0 01-.104-.569l.328-.545c-.267-.3-.48-.649-.619-1.03h-.658a.46.46 0 01-.46-.367 4.107 4.107 0 01-.001-1.425.464.464 0 01.46-.375h.657c.14-.38.352-.73.62-1.03l-.329-.545a.436.436 0 01.104-.568c.379-.304.812-.623 1.285-.79a.477.477 0 01.568.188l.328.632c.41-.073.83-.073 1.24 0zM6 6.962c-1.504-1.11-3.221.538-2.065 1.982C5.44 10.054 7.155 8.406 6 6.962zm3.568-4.564l.28.154a.227.227 0 01.105.283 2.054 2.054 0 01-.364.602.25.25 0 01-.306.052l-.28-.153c-.156.129-.337.23-.535.298v.31c0 .112-.084.21-.2.228a2.29 2.29 0 01-.725 0 .236.236 0 01-.204-.229v-.31a1.704 1.704 0 01-.535-.297l-.279.153a.247.247 0 01-.307-.052 2.078 2.078 0 01-.363-.602.227.227 0 01.106-.283l.279-.154a1.6 1.6 0 010-.594l-.28-.154a.227.227 0 01-.105-.283c.086-.221.21-.424.363-.602a.25.25 0 01.307-.053l.28.154c.156-.13.337-.23.534-.298v-.31c0-.112.084-.21.202-.228.234-.038.48-.04.724 0a.236.236 0 01.203.229v.31c.198.067.38.168.536.297l.279-.154a.247.247 0 01.306.053c.155.178.278.382.364.602a.227.227 0 01-.106.283l-.279.154a1.6 1.6 0 010 .594zm-1.15.197c.578-.722-.28-1.545-1.032-.99-.578.722.28 1.545 1.032.99z" fill="var(--fill-color)"/></svg>
      ${l('settings')}
    </a>
  </nav>
`;

const options_form = ({
  preferences: {
    locale,
    scanSeznam,
    scanGoogle,
    scanHeureka,
    scanZbozi,
    blacklistedDomains = [],
  } = {},
  feedMeta = {},
  manifest = {},
} = {}) => `
  <h1 class="text-center mt-4 mb-5">
    ${tipli_logo({ locale }, 'options-page')}
  </h1>

  <form class="preferences-form container p-2">
    <h2>${l('main-settings')}</h2>

    <div class="mt-4 mb-3">
      <h4>${l('show-notifications-in-search')}</h4>
      ${options_form_serp('scanGoogle', scanGoogle)}
      ${when(locale === 'cs', options_form_serp('scanSeznam', scanSeznam))}
      ${when(
        ['cs', 'sk'].includes(locale),
        options_form_serp('scanHeureka', scanHeureka)
      )}
      ${when(locale === 'cs', options_form_serp('scanZbozi', scanZbozi))}
    </div>

    <h2 class="mt-4 mb-3">${l('advanced-settings')}</h2>

    <div class="mt-4 mb-5">
      <h4>${l('notifications')}</h4>
      <div class="mt-3 mb-3" id="domain-preferences">
        ${blacklistedDomains.map(domain_preference).join('\n')}
      </div>
      <div class="mt-3 mb-3 form-inline">
        <div class="form-group">
          <input
            name="blacklist-add-domain"
            placeholder="${l('blacklist-domain-example')}"
            class="form-control form-control-sm mr-2"
          />
          <button
            type="button"
            class="btn btn-primary btn-sm"
            data-click-action="blacklist-add-domain"
          >
            ${l('blacklist-add-domain')}
          </button>
        </div>
      </div>

    </div>

    <div class="mt-4 mb-3">
      <h4 class="mb-3">${l('locale')}</h4>
      <div class="row mb-2">
        <div class="col">
          <label for="locale-cs">
            <strong>Tipli.cz</strong> - ${l('lang-cs')}
          </label>
        </div>
        <div class="col-1 d-flex justify-content-end">
          <div class="custom-control custom-radio">
            <input
              class="custom-control-input"
              id="locale-cs"
              type="radio"
              name="locale"
              value="cs"
              ${when(locale === 'cs', 'checked')}
            />
            <label class="custom-control-label" for="locale-cs"></label>
          </div>
        </div>
      </div>
      <div class="row mb-2">
        <div class="col">
          <label for="locale-sk">
            <strong>Tipli.sk</strong> - ${l('lang-sk')}
          </label>
        </div>
        <div class="col-1 d-flex justify-content-end">
          <div class="custom-control custom-radio">
            <input
              class="custom-control-input"
              id="locale-sk"
              type="radio"
              name="locale"
              value="sk"
              ${when(locale === 'sk', 'checked')}
            />
            <label class="custom-control-label" for="locale-sk"></label>
          </div>
        </div>
      </div>
      <div class="row mb-2">
        <div class="col">
          <label for="locale-pl">
            <strong>Tipli.pl</strong> - ${l('lang-pl')}
          </label>
        </div>
        <div class="col-1 d-flex justify-content-end">
          <div class="custom-control custom-radio">
            <input
              class="custom-control-input"
              id="locale-pl"
              type="radio"
              name="locale"
              value="pl"
              ${when(locale === 'pl', 'checked')}
            />
            <label class="custom-control-label" for="locale-pl"></label>
          </div>
        </div>
      </div>
      <div class="row mb-2">
        <div class="col">
          <label for="locale-ro">
            <strong>Tipli.ro</strong> - ${l('lang-ro')}
          </label>
        </div>
        <div class="col-1 d-flex justify-content-end">
          <div class="custom-control custom-radio">
            <input
              class="custom-control-input"
              id="locale-ro"
              type="radio"
              name="locale"
              value="ro"
              ${when(locale === 'ro', 'checked')}
            />
            <label class="custom-control-label" for="locale-ro"></label>
          </div>
        </div>
      </div>
      <div class="row mb-2">
        <div class="col">
          <label for="locale-ro">
            <strong>Tiplino.hu</strong> - ${l('lang-hu')}
          </label>
        </div>
        <div class="col-1 d-flex justify-content-end">
          <div class="custom-control custom-radio">
            <input
              class="custom-control-input"
              id="locale-hu"
              type="radio"
              name="locale"
              value="hu"
              ${when(locale === 'hu', 'checked')}
            />
            <label class="custom-control-label" for="locale-hu"></label>
          </div>
        </div>
      </div>
    </div>

    <div class="row d-flex align-items-end">
      <div class="col">
        <p class="small mb-1">
          ${l('extension-version')}: ${manifest.version}
        </p>
        <p class="small mb-1">
          <a data-click-action="restore-extension" href="#">
            ${l('restore-extension')}
          </a>
        </p>
        <p class="small mb-1">
          ${l('shops-list-updated')}: <span id="feed-updated-at-info">${locale_date(feedMeta.loadedAt)}</span> -
          <a href="#" data-click-action="refresh-feed">${l('reload-feed')}</a>
        </p>
      </div>
      <div class="col-4 d-flex justify-content-end">
        <button type="submit" class="btn btn-primary" disabled="disabled">
          ${l('save-settings')}
        </button>
      </div>
  </form>
`;

const options_form_serp = (type, checked) => {
  // TODO: Fix data structure or use localization
  const label = type.replace('scan', '').replace('Zbozi', 'Zboží');
  return `
    <div class="row align-items-center">
      <div class="col">
        <label for="type-${type}">${label}</label>
      </div>
      <div class="col-2 d-flex justify-content-end align-items-center">
        <label class="pure-material-switch">
          <input
            id="type-${type}"
            type="checkbox"
            name="${type}"
            ${when(checked, 'checked')}
          />
          <span></span>
        </label>
      </div>
    </div>
  `;
};

const domain_preference = (
  { urlBase, closeContentBox, disableExtension, newIndex },
  index = ''
) => `
  <div class="row align-items-center" data-url-base="${urlBase}">
    <div class="col-3">
      <label class="mb-0 domain_preference__address">
        <input type="hidden" name="blacklistedDomains[${newIndex || index || 0}][urlBase]" value="${urlBase}"/>
        <span title="${urlBase}">${urlBase}</span>
      </label>
    </div>
    <div class="col-4">
      <label class="mb-0 pure-material-checkbox">
        <input
          type="checkbox"
          name="blacklistedDomains[${newIndex || index || 0}][closeContentBox]"
          ${when(closeContentBox, 'checked')}
        />
        <span>${l('hide-popup')}</span>
      </label>
    </div>
    <div class="col-4">
      <label class="mb-0 pure-material-checkbox">
        <input
          type="checkbox"
          name="blacklistedDomains[${newIndex || index || 0}][disableExtension]"
          ${when(disableExtension, 'checked')}
        />
        <span>${l('disable-extension')}</span>
      </label>
    </div>
    <div class="col-1">
      <button
        class="domain_preference__remove-button"
        title="${l('remove')}"
        type="button"
        data-click-action="blacklist-remove-domain"
        data-click-payload="${urlBase}"
      >
        ${icon('remove', 20)}
      </button>
    </div>
  </div>
`;

const options_toast = ({ success = false, failure = false } = {}) => {
  if (success) {
    return `
      <div class="alert alert-success" role="alert" data-autohide="1600">
        ${success}
      </div>
    `;
  }
  if (failure) {
    return `
      <div class="alert alert-danger" role="alert" data-autohide="1600">
        ${failure}
      </div>
    `;
  }
  return '';
};

const popup_disabled = () => `
  <div class="popup-content popup-content--disabled">
    <svg width="30" height="30" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 .469C6.975.469.469 6.975.469 15S6.975 29.531 15 29.531 29.531 23.025 29.531 15 23.025.469 15 .469zm7.623 6.907c3.835 3.835 4.102 9.697 1.212 13.807L8.817 6.165c4.113-2.892 9.974-2.621 13.806 1.211zM7.377 22.623C3.542 18.79 3.275 12.928 6.165 8.818l15.018 15.018c-4.113 2.892-9.974 2.621-13.807-1.212z" fill="#9D9D9D"/></svg>
    <h3>${l('popup-extension-disabled-header')}</h3>
    <p>${md(l('popup-extension-disabled-text'))}</p>
  </div>
`;

const popup_content = ({ shop, reward, sales } = {}) => {
  const similarSales = sales.filter((x) => x.isSimilar);
  const shopSales = sales.filter((x) => !x.isSimilar);
  const hasItems = sales.length > 0;
  return `
    ${shop_rewards[shop.rewardType]({ shop, reward }, 'popup')}
    <div class="popup-content__coupons">
      ${when(
        !hasItems,
        `<div class="sales-item sales-item--popup sales-item--header">${l(
          'no-sale-items'
        )}</div>`
      )}
      ${shopSales.map(sales_item('popup', reward)).join('\n')}
      ${when(similarSales.length, similar_items_header('popup'))}
      ${similarSales
        .map(sales_item('popup', { coupons: false }))
        .join('\n')}
    </div>
  `;
};

const sales_types = {
  coupon: ({ redirectUrl, code }) =>
    `<a class="coupon"
        href="${redirectUrl}"
        data-sticker-text="${l('coupon-get-code')}"
        data-sticker-done="${l('coupon-copied')}"
      >${code}</a>`,
  // sale: ({redirectUrl}) => `<a class="sale" href="${redirectUrl}">${l('sale-get-sale')}</a>`
};

const banner = (i, url, imageUrl, name) => `
  <figure class="box-banners__banner" id="box-banner-${i}">
    <a href="${url}"><img src="${imageUrl}" alt="Tipli Banner" width="316" height="178"></a>
    <figcaption><a href="${url}">${name}</a></figcaption>
    <div class="box-banners__snapper"></div>
  </figure>
`;

const banner_navigation_item = (i) => `
  <li class="box-banners__navigation-item">
    <a class="box-banners__navigation-button"
       href="#box-banner-${i}"
      >${l('go-to-slide')} ${i}</a>
  </li>
`;

const box_banners = (banners) => !banners.length ? '' : `
  <div class="box-banners">
    <div class="box-banners__viewport">
      ${banners
        .map(({ name, url, imageUrl }, i) => banner(i, url, imageUrl, name))
        .join('\n')}
    </div>
    <aside class="box-banners__navigation">
      <ol class="box-banners__navigation-list">
        ${banners.map((_, i) => banner_navigation_item(i)).join('\n')}
      </ol>
    </aside>
  </div>
`;

const popup_search = ({ banners, shops, query }) => `
  <div class="popup-search"
    data-search-query="${when(query, encodeURIComponent(query))}">
    <div class="popup-search__banner">
      ${box_banners(banners)}
    </div>
    ${iif(
      shops.length,
      `<div class="popup-search__shops">${shops.map(shop_card).join('\n')}</div>`,
      `<div class="popup-search__no-results"><p>${l('no-search-results')}</p></div>`
    )}
  </div>
`;

const shop_cashback = ({ reward, rewardSuffix }) => `
  <span class="shop-cashback">
    <span class="shop-cashback__reward">${md(reward)}</span><br />
    <span class="shop-cashback__suffix">${rewardSuffix}</span>
  </span>
`;

const shop_card = ({
  name,
  logoUrl,
  redirectUrl,
  reward,
  rewardSuffix,
}) => `
  <a class="shop-card" href="${redirectUrl}" title="${name}">
    <div class="shop-card__image">
      <img src="${logoUrl}" alt="${name}">
    </div>
    <div class="shop-card__content">
      <h3 class="shop-card__title" title="${name}">${name}</h3>
      ${shop_cashback({ reward, rewardSuffix })}
    </div>
  </a>
`;

var templates = /*#__PURE__*/Object.freeze({
  __proto__: null,
  init: init,
  locale_date: locale_date,
  asset: asset,
  locale_home_url: locale_home_url,
  terms_icon: terms_icon,
  tipli_logo: tipli_logo,
  display_money: display_money,
  reward_button: reward_button,
  shop_rewards: shop_rewards,
  control_icon: control_icon,
  sales_item: sales_item,
  content_box: content_box,
  icon: icon,
  user_cashback: user_cashback,
  popup_header: popup_header,
  popup_footer: popup_footer,
  options_form: options_form,
  options_form_serp: options_form_serp,
  domain_preference: domain_preference,
  options_toast: options_toast,
  popup_disabled: popup_disabled,
  popup_content: popup_content,
  sales_types: sales_types,
  banner: banner,
  box_banners: box_banners,
  popup_search: popup_search,
  shop_cashback: shop_cashback,
  shop_card: shop_card
});

const createStyleSheetLinkElement = (path) => {
  const href = path.startsWith('http') ? path : browser.runtime.getURL(path);
  const link = document.createElement('link');
  link.setAttribute('rel', 'stylesheet');
  link.setAttribute('href', href);
  return link;
};
const createJavaScriptElement = (path) => {
  const href = path.startsWith('http') ? path : browser.runtime.getURL(path);
  const script = document.createElement('script');
  script.setAttribute('type', 'module');
  script.setAttribute('src', href);
  return script;
};

/**
 *
 * @callback RenderMethod
 * @param {string} selector
 * @param {string=} contentId Unique DOM ID to avoid rendered duplicities
 *
 * @typedef {Object} RenderOptions
 * @property {boolean} useShadowDOM Protect content against surrounding world
 * @property {string[]} injectScripts List of hrefs to external or internal asset
 * @property {string[]} injectStyles List of hrefs to external or internal asset
 *
 * @param {string} content HTML content
 * @param {RenderOptions} options
 *
 * @returns {RenderMethod} Where to render given content
 */
function render(
  content,
  { useShadowDOM, injectScripts = [], injectStyles = [] } = {}
) {
  const inject = (target) => {
    injectStyles.forEach((path) => {
      const link = createStyleSheetLinkElement(path);
      target.appendChild(link);
    });
    injectScripts.forEach((path) => {
      const script = createJavaScriptElement(path);
      target.appendChild(script);
    });
  };

  return ({ selector, append = false }, contentId) => {
    const target = document.querySelector(selector);

    if (append) {
      const container = document.createElement('div');
      container.innerHTML = content;
      target.appendChild(container);
      inject(target);
      return target;
    }

    if (!useShadowDOM) {
      target.innerHTML = content;
      inject(target);
      return target;
    }

    const container =
      document.querySelector(`#tipli-content-${contentId}`) ||
      document.createElement('div');
    container.setAttribute('id', `tipli-content-${contentId}`);
    const shadow = container.attachShadow({ mode: 'closed' });
    shadow.innerHTML = content;
    inject(shadow);
    target.appendChild(container);
    return [container, shadow];
  };
}

/**
 * Use data and render content,
 *  optionally can be rendered as shadow box not impacted by content styles and scripts
 *
 * @typedef {Object} RenderContentAppearance
 * @property {string} selector CSS selector to target where in DOM should be content rendered
 *
 * @typedef {Object} RenderContentParams
 * @property {string} contentType Name of content template
 * @property {Object} contentData Any data passed to template as its prop
 * @property {RenderContentAppearance} appearance Preferences to display content container
 *
 * @param {RenderContentParams} properties
 * @param {RenderOptions} options
 */
function renderContent(
  { contentType, contentData, appearance } = {},
  options = { locale: 'cs' }
) {
  init({ locale: options.locale });
  const content = templates[contentType](contentData);
  const contentId = stringToHash(contentType);
  return render(content, options)(appearance, contentId);
}

const TipliEvents = {
  CONTROL_CLICK: 'tipli:controlclick',
  STICKER_CLICK: 'tipli:stickerclick',
};

function handleStickerClick(item) {
  return event => {
    event.stopImmediatePropagation();
    navigator.clipboard.writeText(event.detail);
    item.classList.remove('sales-item--activated');
    item.classList.add('sales-item--done');
    setTimeout(() => {
      item.classList.add('sales-item--activated');
      item.classList.remove('sales-item--done');
    }, 3000);
    return false;
  };
}

function dispatchStickerClick(sticker) {
  return event => {
    event.stopImmediatePropagation();
    event.preventDefault();
    sticker.dispatchEvent(new CustomEvent(TipliEvents.STICKER_CLICK, {
      bubbles: true,
      detail: sticker.innerText
    }));
    return false;
  };
}

function handleConditionsMoreTextClick(item) {
  return event => {
    event.stopImmediatePropagation();
    item.parentNode.classList.add('sales-item__shop-conditions-text--open');
    return false;
  };
}

function dispatchControlClick(control, doConfirm = () => true) {

  return event => {
    event.stopImmediatePropagation();
    event.preventDefault();

    const { controlType } = control.dataset;
    if (!doConfirm(controlType)) return false;

    document.dispatchEvent(new CustomEvent(TipliEvents.CONTROL_CLICK, {
      bubbles: true,
      detail: { type: controlType }
    }));
    return false;
  }
}

// globals document

function scrape(list = []) {
  const readText = (selector) => {
    const elements = Array.from(document.querySelectorAll(selector));
    if (elements.length) return elements.map(element => element.textContent);
    else console.warn(`Element with selector ${selector} not found!`);
  };

  // Take array of records with { selector, paramName } properties
  //  and transform it to map with [$paramName]: <parsed text value>
  const listToMap = (data, { selector, paramName }) => ({
    ...data,
    [paramName]: readText(selector)
  });

  return list.reduce(listToMap, {});
}

function handleControlIcons(container) {
  document.addEventListener(TipliEvents.CONTROL_CLICK, ({ detail }) => {
    sendBackgroundMessage(MessageTypes.CONTROL_ICON_CLICK, detail);
    container.remove();
  });
}

function handleHeaderControls(container, { locale } = {}) {
  const l = initLocalization(locale);
  for (let control of container.querySelectorAll(".control-icon")) {
    control.addEventListener('click', dispatchControlClick(control, type => {
      if (type === ControlIconTypes.HIDE) {
        return confirm(l('confirm-content-box-hide'));
      }
      return true;
    }));
  }
}

function handleSalesItems(container) {
  // listen for custom event from child sticker with coupon code in event detail
  for (let item of container.querySelectorAll(".sales-item")) {
    item.addEventListener(TipliEvents.STICKER_CLICK, handleStickerClick(item));
  }
  // listen for clicks on active coupons, stops navigation to link and dispatches coupon code in custom event to parent
  for (let sticker of container.querySelectorAll(".sales-item--activated .sales-item__sticker")) {
    sticker.addEventListener('click', dispatchStickerClick(sticker));
  }
}

function handleConditionsMoreText(container) {
  // listen for clicks on more text link in conditions text element
  for (let link of container.querySelectorAll(".sales-item__shop-conditions-text-more")) {
    link.addEventListener('click', handleConditionsMoreTextClick(link));
  }
}

function render$1(contents, renderOptions) {
  for (let content of contents) {
    const [container, shadow] = renderContent(content, renderOptions);
    handleControlIcons(container);
    handleHeaderControls(shadow, renderOptions);
    handleSalesItems(shadow);
    handleConditionsMoreText(shadow);
  }
}

async function main() {

  // Ask background for instructions for current screen
  const { payload: { instructions } = {} } = await sendBackgroundMessage(
    MessageTypes.INSTRUCTIONS_REQUEST
  );

  // if none, abort content script activity
  if (!instructions) return;


  const renderOptions = {
    locale: instructions.locale,
    useShadowDOM: true,
    injectStyles: ['styles.css']
  };

  // Send scraped data (if any) and request contents to display
  const { payload: contents = [] } = await sendBackgroundMessage(
    MessageTypes.CONTENTS_REQUEST,
    scrape(instructions.read)
  );
  // Render all gained contents
  render$1(contents, renderOptions);

  // TODO: Watch triggers and then rerender
}

main().catch(err => console.error(err));
