async function isNavigatorOffline(){const e=await localStorage.getItem("offline");return!e||JSON.parse(e)}function isChrome(){return"undefined"!=typeof chrome&&"undefined"==typeof browser}async function createHttpHeaders(e){let t={Accept:"application/json","Content-Type":"application/json"};e&&(t["X-Auth-Token"]=e);const s=await localStorage.getItem("wsConnectionId");s&&(t["socket-connection-id"]=s),t["App-Name"]="extension-"+(isChrome()?"chrome":"firefox"),t["App-Version"]=aBrowser.runtime.getManifest().version,t["User-Agent"]=`${navigator.userAgent} extension/${aBrowser.runtime.getManifest().version}`;const a=await localStorage.getItem("sub-domain_subDomainName");a&&(t["sub-domain-name"]=a);const r=await localStorage.getItem("lang");return r&&(t["accept-language"]=r),t}function errorObj(e,t,s){return{data:null,error:{status:e,message:t,errorData:s}}}class ClockifyService{constructor(){}static get userId(){return localStorage.getItem("userId")}static get userEmail(){return localStorage.getItem("userEmail")}static get workspaceId(){return localStorage.getItem("activeWorkspaceId")}static get apiEndpoint(){return localStorage.getItem("permanent_baseUrl")}static get user(){return localStorage.getItem("user")}static routesToCache=[{path:"/auth/token/refresh",expiresInMilliseconds:3e3},{path:"/timeEntries/recent?limit=",expiresInMilliseconds:1e3}];static cache={};static addToCache(e,t){this.cache[e]={...t,timestamp:(new Date).getTime()}}static removeFromCache(e){delete this.cache[e]}static requestQueue={};static isEndpointInRoutesToCache(e){return this.routesToCache.find((t=>e.includes(t.path)))}static async getForces(){const e=await localStorage.getItem("workspaceSettings"),t=await localStorage.getItem("userSettings"),s=e?JSON.parse(e):{forceDescription:!1,forceProjects:!1,forceTasks:!1,projectPickerSpecialFilter:!1,forceTags:!1},a=t?JSON.parse(t):{projectPickerSpecialFilter:!1},{forceDescription:r,forceProjects:o,forceTasks:n,forceTags:i}=s,{projectPickerSpecialFilter:c}=a;return{forceDescription:r,forceProjects:o,forceTasks:n,projectPickerSpecialFilter:c,forceTags:i}}static async getCreateObjects(){const e=await localStorage.getItem("permanent_createObjects");return!!e&&JSON.parse(e)}static async getCanCreateProjects(){let e=await localStorage.getItem("workspaceSettings");e=JSON.parse(e);let t=await localStorage.getItem("userRoles");t=t.map((e=>e.role));const{whoCanCreateProjectsAndClients:s}=e?.entityCreationPermissions||{whoCanCreateProjectsAndClients:"ADMINS"};return"EVERYONE"===s||t.includes("WORKSPACE_ADMIN")||"ADMINS_AND_PROJECT_MANAGERS"===s&&t.includes("PROJECT_MANAGER")}static async getCanCreateTasks(){let e=await localStorage.getItem("workspaceSettings");e=JSON.parse(e);let t=await localStorage.getItem("userRoles");t=t.map((e=>e.role));const{whoCanCreateTasks:s}=e?.entityCreationPermissions||{whoCanCreateTasks:"ADMINS"};return"EVERYONE"===s||t.includes("WORKSPACE_ADMIN")||"ADMINS_AND_PROJECT_MANAGERS"===s&&t.includes("PROJECT_MANAGER")}static async getCanCreateTags(){let e=await localStorage.getItem("workspaceSettings");e=JSON.parse(e);let t=await localStorage.getItem("userRoles");t=t.map((e=>e.role));const{whoCanCreateTags:s}=e?.entityCreationPermissions||{whoCanCreateTags:"ADMINS"};return"EVERYONE"===s||t.includes("WORKSPACE_ADMIN")||"ADMINS_AND_PROJECT_MANAGERS"===s&&t.includes("PROJECT_MANAGER")}static async setOnline(){const e=await localStorage.getItem("offline");e&&"true"!==e||localStorage.setItem("offline","false")}static async setOffline(){const e=await localStorage.getItem("offline");e&&"false"!==e||localStorage.setItem("offline","true")}static async handleBannedResponse(e){const t=isChrome()?chrome:browser,s=e.message?.match(/Youâ€™ve been logged out since your ([a-f\d]{24}) workspace has been suspended\. Contact support@clockify\.me for more information/);if(s){const a=s[1];t.runtime.sendMessage({eventName:"WORKSPACE_BANNED",options:{...e,workspaceId:a}})}else(e.message?.includes("Access to workspace is denied")||e.message?.includes("account has been disabled"))&&t.runtime.sendMessage({eventName:"USER_BANNED",options:e})}static async apiCall(e,t="GET",s=null,a=!1,r){let o;if(a)o=null;else if(o=await TokenService.getToken(),!o)return errorObj("0","token is missing");const n=await createHttpHeaders(o),i=r?{...n,...r}:n,c=new Headers(i),l=await this.apiEndpoint;e===`${l}/auth/`&&c.delete("sub-domain-name");const u=this.isEndpointInRoutesToCache(e);if(u){const t=this.cache[e];if(t&&t.timestamp+u.expiresInMilliseconds>Date.now())return Promise.resolve(t);if(this.requestQueue[e]){const t=await this.requestQueue[e];return delete this.requestQueue[e],Promise.resolve(t)}}const d=new Request(e,{method:t,headers:c,body:s?JSON.stringify(s):null}),g=fetch(d).then((async t=>{let s;"error"===t.type?this.setOffline():this.setOnline();const a=[/Client with name '.*' already exists/,/.* project for client  already exists./,/Task name has to be between 1 and 1000 characters long/,/.* project for client .* already exists./,/Tag with name .* already exists/,/Manual time tracking disabled on .*/,/Task with name '.*' already exists/];switch(t.status){case 400:case 501:const{message:e}=await t.json();return errorObj(400,a.find((t=>t.test(e)))?e:`${clockifyLocales.YOU_ALREADY_HAVE_ENTRY_WITHOUT}. ${clockifyLocales.PLEASE_EDIT_YOUR_TIME_ENTRY}.`);case 403:if(s=await t.json(),s){if(406===s.code)return this.handleBannedResponse(s),errorObj(t.status,s?.message,s);if(4017===s.code)return aBrowser.runtime.sendMessage({eventName:"TOKEN_INVALID",options:s}),errorObj(t.status,"Token invalid",s);if(4030===s.code)return errorObj(t.status,"Manual time tracking disabled",s);if(501===s.code)return errorObj(t.status,"Access Denied",s);if(1003===s.code)return errorObj(t.status,"Can't edit locked time entry.",s)}return errorObj(t.status,"Unauthenticated");case 404:return errorObj(t.status,"Not found");case 405:return errorObj(t.status,"Method not allowed");case 406:return s=await t.json(),this.handleBannedResponse(s),errorObj(t.status,"Banned",s);case 401:if(s=await t.json(),s){if(4019===s.code&&aBrowser.runtime.sendMessage({eventName:"VERIFY_EMAIL_ENFORCED",message:{}}).then((e=>{console.log(e)})).catch((e=>console.log(e))),406===s.code)return this.handleBannedResponse(s),errorObj(t.status,s?.message,s);if(4017===s.code||4023===s.code)return aBrowser.runtime.sendMessage({eventName:"TOKEN_INVALID",options:s}),errorObj(t.status,"Token invalid",s);if(1e3===s.code)return aBrowser.runtime.sendMessage({eventName:"TOKEN_INVALID",options:s}),errorObj(t.status,s)}return errorObj(t.status,"Forbidden")}let r;if(t.ok){try{r=await t.json()}catch{r=null}return u&&(this.addToCache(e,{data:r,error:null,status:t.status}),setTimeout((()=>{this.removeFromCache(e)}),u.expiresInMilliseconds)),{data:r,error:null,status:t.status}}{const e=await t.text();return errorObj(t.status,e)}})).catch((e=>(console.error("There has been a problem with your fetch operation: ",e),errorObj(0,e))));return u&&(this.requestQueue[e]=g),await g}}